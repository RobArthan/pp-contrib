=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{An Execution Model for SWORD}  %% Mandatory field
\TPPref{DS/FMU/FEF/026}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.~D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{A formalisation of an execution model for the Front End
implementation of SWORD for the DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents

\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue 1.2 (23 February 1993)]
First draft for discussion.
\item[Issue \SCCSversion ({\FormatDate{93/04/01%
}}) ] Rework and further clarifications in the light of comments received.
\end{description}

\subsection{Changes Forecast}
The current issue is a partial draft to promote discussion about the approach.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document gives a formal specification of part of the SWORD Front
End giving the high-level security properties required of both the
Query Transformations of \cite{trans} and of the Front End Filter of
\cite{filter}.  It constitutes part of deliverable D3 of work package 1a, as
given in the Phase 2 Technical Proposal, \cite{DS/FMU/017}.

\subsection{Introduction}

\cite{DS/FMU/FEF/022} gives a formal description of the top-level
architecture of the Front End Implementation of SWORD and identifies
three subsystems from which the system is constructed, namely,
the SSQL Transformation Processor, the TSQL database, and the Output Filter.
It is the purpose of this document to give a more concrete formulation
of the critical requirements on these subsystems.

The current issue gives preliminary discussion of issues in
formalising the critical requirements. Some formal material is included.

\section{PRELIMINARIES}
The following \Product{} instructions set the context for the proof
tools and set up the new theory $fef026$, with parent the theory
$fef025$ in which the representation of an SSQL State as a TSQL State is formalised.
=SML 
open_theory "fef029";
new_theoryÛ"fef026"İ;
push_pc "hol";
=TEX

\section{REPRESENTATION OF DERIVED TABLES}
The abstract formulation of the critical requirements on
the subsystems of $FE\_SWORD$ given in \cite{DS/FMU/FEF/022}  give little
insight into {\em how} the subsystems are to be constructed. Further detail
on the actual data types involved is required to discuss this.

Apart from some minor and easily remedied differences of
organisation, the syntax of TSQL is a subset of the syntax of SSQL.
For simplicity, it has been chosen to model the TSQL abstract syntax as
being identical with the SSQL syntax. The TSQL semantics may then be
specified reusing most of the SSQL semantics of
\cite{DS/FMU/FEF/004,DS/FMU/FEF/005,DS/FMU/FEF/014} by imposing
a state invariant which asserts that all classification information in
the state, apart from where classifications are stored as data, is fixed
at the lowest classification. A formal treatment of the TSQL semantics along
these lines is given in \cite{DS/FMU/FEF/021}.

The representation of a TSQL state as an SSQL state is defined informally
in \cite{filter} and formally in \cite{DS/FMU/FEF/025}.
In the general case, an SSQL table
with $k$ columns is represented as a TSQL table with $1 + 3k$ columns:
the first column in the TSQL table contain the row existence classes,
successive blocks of 3 columns give the classification, the dinary data
and the sterling data for the corresponding SSQL column. The SSQL state
also associates some `static' classification information about each
table, namely: its class ($TS\_class$\footnote{%
The names used here are as used in \cite{DS/FMU/FEF/004}.%
}) and its maximum
row class ($TS\_maxRow$), and also about each column in a table, namely:
its existence class ($CC\_exist$) and the maximum and minimum classifications
for the data in the column ($CS\_min$, $CS\_max$). This information
is not represented in the TSQL state (as modelled here, although in
practice, it will be held in a TSQL table); however, it is used in
the transformations of \cite{filter} in order to optimise the representation,
so that, for example, the row existence class column is omitted if
$TS\_maxRow = TS\_class$.

The management of the optimisations discussed above and of the variable
scoping rules of the query language make a significant contribution to the
complexity of the transformations as specified in \cite{filter}. The scoping rules
also complicate the semantics of both SSQL as given in \cite{DS/FMU/FEF/014}
and hence of TSQL. The main security-relevant mechanisms used in the
transformations are therefore best understood if the optimisations,
the handling of the scoping rules for the two languages,
and the security checks themselves are
handled separately in a formal treatment.

Most of the complexity of the TSQL and SSQL semantics is in the $SELECT$
query. Indeed, at least in $TSQL$, the $DELETE$, $INSERT$ and $UPDATE$
queries can be modelled as a $SELECT$ query to compute a new table
followed by an assignment or a merge of the new table into an existing one table.

The security checks which apply to a $SELECT$ query are best understood
if we think of execution of the query as returning a {\em derived table}, which
we think of as having two components: the table specification
which contains static information about the table and its columns;
and the list of rows comprising the table data proper.
We will take a conceptual, unoptimised, view of derived tables
and so use the following data types for them:

¹HOLLABPROD ÛDerColSpecİüüüüüüüüüüüüüüüüüüü
Ü	ÛDCS_nameİ	: Ide LIST LIST;
Ü	ÛDCS_minİ	: Class;
Ü	ÛDCS_maxİ	: Class;
Ü	ÛDCS_existsİ	: Class
°üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
¹HOLLABPROD ÛDerTableSpecİüüüüüüüüüüüüüüüüüü
Ü	ÛDTS_nameİ	: Ide LIST LIST;
Ü	ÛDTS_classİ	: Class;
Ü	ÛDTS_maxRowİ	: Class;
Ü	ÛDTS_colSpecsİ	: DerColSpec LIST
°üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
¹HOLLABPROD ÛDerTableRowİüüüüüüüüüüüüüüüüüü
Ü	ÛDTR_whereİ	: Class;
Ü	ÛDTR_rowİ	: Class;
Ü	ÛDTR_colsİ	: (Class ¸ Item) LIST
°üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
¹HOLLABPROD ÛDerTableİüüüüüüüüüüüüüüüüüüüü
Ü	ÛDT_specİ		: DerTableSpec;
Ü	ÛDT_rowsİ		: DerTableRow LIST
°üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü

The information in the above is intended to be extracted from information
recorded for a table in the SSQL state or computed during derivation
of the table, as described in the following table:

\begin{centering}
\begin{tabular}{|l|p{4in}|}\hline
Field & Description \\\hline\hline
$DCS\_name$ &
The names by which the column may be known
(computed from $DirectoryS$ and the $ColSpec$s for the table initially) \\\hline
$DCS\_min$/$DCS\_max$ &
The minimum and maximum classes for data in the column
(taken from the $ColSpec$s for the column initially) \\\hline
$DCS\_exists$ &
The column existence class
(taken from the $ColCon$ for the column initially) \\\hline
$DTS\_name$ &
The names by which the table may be known
(computed from $DirectoryS$ initially) \\\hline
$DTS\_class$ &
The class of the table
(computed from the $TableSpec$ for the table initially) \\\hline
$DTS\_maxRow$ &
The maximum row existence class of the table
(computed from the $TableSpec$ for the table initially) \\\hline
$DTS\_colSpecs$ &
The column specifications for the table \\\hline
$DTR\_where$ &
The classification in this row of a $WHERE$
clause used to construct this table (taken equal to the client clearance
initially) \\\hline
$DTR\_row$ &
The existence classification of this row
(taken from the SSQL state initially) \\\hline
$DTR\_cols$ &
The classication and data for each field in this row
(taken from the SSQL state initially)  \\\hline
\end{tabular}
\end{centering}

\section{EXAMPLES}

Before discussing the use of the above representation of a derived
table within the formal framework, it may be helpful to consider some
examples of the transformation of SSQL queries into TSQL. 
For the examples which follow, the main part of the transformation algorithm
is defined in the description of $tuple\_list\sb{make\_outer}$ in \cite{trans}.

\paragraph{Example 1}
The basic principle of operation of the Front End implementation
of SWORD is apparent from the treatment of the simplest form
of $SELECT$ query:

=GFT SSQL Example
	SELECT * FROM table
=TEX

In essence, this is transformed into a single TSQL query
(with no check query) of the form\footnote{%
In fact, the optimised query may omit some of the expressions in the
select-list. In this case, $cc$ would certainly be omitted, since there
is no $WHERE$ clause.%
}:

=GFT TSQL Example
	SELECT cc, rc, col1‰s, col1‰d, col1‰c, ...
	FROM table‰t
	WHERE cc DOM rc
=TEX
where $table\sb{t}$ is the TSQL table implementing $table$,
$cc$ is a constant classification equal to the clearance of the client,
$rc$ is the column containing the row classes,
and the $col{\cal I}\sb{{\cal X}}$
are the columns containing the classes, sterling data and dinary data
for the (SSQL) columns of $table$. Viewed conceptually as a derived
table in the above sense, the result of this TSQL query represents the entirety
of all rows in $table$ whose existence the client is cleared to know,
together with a column of where clause classes all equal to
the clearance of the client. Filtering such a derived table amounts, in
effect, to removing all rows whose class is not dominated by the
client clearance and overwriting with a dummy value the data in all fields where
the field classification is not dominated by the client clearance.
Since, in this case, all of the classification information in the
derived table is taken directly from the database (and so may be assumed
to be correct), the result of this filtering removes all information
content which the client is not cleared to see\footnote{%
In the current specifications \cite{filter,trans}, the transformations
add the $WHERE$ clause as shown in the example and the filter apparently
does not need to eliminate rows whose existence the client is not cleared
to know since there will not be any. However, the row existence column
is passed into the filter. This point needs clarification.%
}.

\paragraph{Example 2}
For a more complex SSQL query classifications in the derived table
which represents its output are computed during execution of
the TSQL query. For example, consider:

=GFT SSQL Example
	SELECT col2 + col3 FROM table WHERE col1 < col2
=TEX

Here, in each row, computation of the $WHERE$ clause reveals information
about values in the first two fields of the row. Again there is no check
query and the transformed query might have the form:

=GFT TSQL Example
	SELECT col1‰c LUB col2‰c, rc, col2‰s + col3‰s, col2‰c LUB col3‰c
	FROM table‰t
	WHERE (col1‰s < col2‰s OR NOT cc DOM (col1‰c LUB col2‰c)) AND cc DOM rc
=TEX
Here the transformations have arranged to include in the derived table
passed to the filter, rows for which either the SSQL $WHERE$ clause is true
or the client is not cleared to compute the $WHERE$ clause. The filter
can then discard rows for which the $WHERE$ clause computation is a possible
covert channel. The classification associated with each computed data value
=INLINEFT
col2‰s + col3‰s
=TEX
\ in each row is the least upper bound of the classifications for
$col2$ and $col3$ in that row, since the result of the addition reveals
information about both of its operands. 

\paragraph{Example 3}
In the above examples, there is no need for a check query since the
data query can include all the information required for the filter
to eliminate possible covert channels. The check query becomes necessary
when the query includes a $GROUP$ $BY$ clause, e.g. consider the following
query:

=GFT SSQL Example
	SELECT col1, COUNT FROM table WHERE col2 > 0 GROUP BY col1
=TEX

This is intended to return a table showing, for each value of $col1$
appearing in $table$, the number of rows having that $col1$ value
and a positive $col2$ value. The query must not be allowed to reveal information
about rows whose $col1$
value the client is not cleared to see. This will result in a check query
as follows:

=GFT TSQL Example
	SELECT TRUE
	FROM table‰t
	WHERE cc DOM rc AND col2‰s > 0 AND NOT cc DOM col1‰c
=TEX
Thus the check query will return a row for each row in $table$ whose
existence the client is cleared to know, whose $col2$ value is such
that the row would be included in the counts to be made by the data query
and whose $col1$ value the client is not cleared to know. If there are
any such rows the data query should not be allowed to proceed.

\paragraph{Example 4}
The above examples involve selection from a single table. Selection
from (the cartesian product of) several tables follows similar lines except
that the row existence classes must be combined to give the existence
class for the derived table. For, example, consider:

=GFT SSQL Example
	SELECT * FROM tableA, tableB
=TEX

This is transformed into the following query, which is similar to the selection
from a single table but with the existence class in each row of the cartesian
product taken to be the least upper bound of the existence classes of the
two rows it is formed from.
=GFT TSQL Example
	SELECT cc, rcA LUB rcB, colA1‰s, colA1‰d, colA1‰c, ..., colB1‰s, colB1‰d, colB1‰c, ...
	FROM tableA‰t, tableB‰t,
	WHERE cc DOM (rcA LUB rcB)
=TEX

\paragraph{Discussion}
In fact, the above examples display most of the security relevant
features of the transformations, with the following exceptions:

\begin{enumerate}
\item
The more complex variants of a single select query,
e.g. the $HAVING$ clause.
\item
The details of the computation of the classification of
the result of an expression (cf. example 2 above where for each row,
the expression $col2 + col3$ is assigned a classification which
is the least upper bound of the classifications of $col2$ and $col3$ in that
row).
\item
The details of the mapping of the SSQL name space onto the TSQL name space.
\item
The handling of nested $SELECT$ queries and the management of the
scope of the name spaces within them.
\end{enumerate}

\section{EXECUTION MODEL (PART 1)}\label{EXECUTIONMODELI}
In order to simplify the handling both of nested $SELECT$s and
of name space management, it is proposed to use a model of the
TSQL execution mechanism in which the essence of the $SELECT$
functionality is separated out. To do this, we restrict attention
to transitions of the underlying DBMS whose effect can be viewed
as having been obtained by the following steps:

\begin{enumerate}
\item
Represent the visible state of the database as a list of derived tables, $dtl$;
\item
Perform some computation on $dtl$ resulting in a new derived table, $dt$;
\item
Either filter $dt$ to create the output for the client ($SELECT$ query),
or use $dt$ and other information from the query to update the database
(other queries).
\end{enumerate}

Here, step 1 is intended to involve a fixed mapping on database states
dependent on the SSQL database structure. The main security property
enforced by step 1 is the removal of tables which the client is not
cleared to see (cf. \cite{trans}, in which, we take it, such tables are
not entered into the global symbol table).

In step 3, the filtering for the output from the $SELECT$ queries is
to be carried out by using the filter specified in \cite{DS/FMU/FEF/024}.
The other sorts of query are to be processed on the assumption that $dt$ encodes
information about the modifications to be made to the table named in the query.

Step 2 is where the main security features of the transformations\cite{trans}
are modelled.
In particular, by bounding the class of computations permitted in this
step, we can formalise the intuitions behind the clearances which are
assigned by the transformations to the fields of derived tables.

The three-stage model of TSQL execution may be viewed
as an alternative description of the function $TSQLtf$ of
\cite{DS/FMU/FEF/021}, which reveals the semantic
issues but ignores syntactic ones. It may be formalised as follows:

¹HOLCONST
Ü	ÛEMİ :	(State‰t ­ DerTable LIST)
Ü		­ (Query ­ (DerTable LIST ­ DerTable ¸ Errors))
Ü		­ (Query ¸ (DerTable ¸ Errors) ¸ State‰t ­ State‰t ¸ ANSWER)
Ü		­ (Query,  State‰t) DBMS_TYPE
÷üüüüüüüüüüüüüüüüüüüüüüü
Üµ view; compile; act; query; st·
Ü	EM view compile act (query, st)
Ü=	let 	compute = compile query
Ü	in let	viewed = view st
Ü	in let	computed = compute viewed
Ü	in	act (query, computed, st)
°

Here the components, $view$, $compile$ and $act$ of the model represent
the three stages as follows:

\begin{enumerate}
\item
$view$ represents the state of the database as a list of derived tables;
\item
$compile$ compiles a query to give the derived-table-forming function it
computes;
\item
$act$ either updates the state or delivers an answer according to the
type of $query$ and the derived table computed by the compiled query.
\end{enumerate}


\section{REPRESENTING SSQL AND TSQL STATES AS DERIVED TABLES}

This section describes how SSQL and TSQL states are viewed as lists
of derived tables. A fairly explicit algorithm is
specified for the SSQL states. The view for the TSQL states is then loosely
specified in terms of the SSQL formulation.

The classification of a derived table in an SSQL state 
will be the least upper
 bound of the corresponding table classification and `containing directory' classifications in the SSQL state.



\subsection{Interpreting a State as a List of Tables}

Obtain a list of pairs of directory name and directory 
from a state together with the upper bound of the clearances for the directory.

¹HOLCONST
Ü	ÛStateDirsİ : State ­  (Class ¸ Ide LIST ¸ Directory) LIST
÷üüüüüüüüüüüüüü
Ü	µ s·	Elems (StateDirs s)
Ü	=	{	(c, (i, d))
Ü		|	(i, d)  repState s
Ü		±	c = (Dir_exist d lub Dir_class d)}
°

Obtain a list of pairs of table name and table 
from a directory.

¹HOLCONST
Ü	ÛDirTablesİ : Directory ­  (Ide  ¸ TableSpec) LIST
÷üüüüüüüüüüüüüü
Ü	µ d · Elems (DirTables d) = Dir_tables d
°

Obtain a list of quadruples of class, directory name, table name and table 
from a state. This involves propagating the classes and directory
names obtained for each directory $StateDirs$ into the information
returned for each table. 


¹HOLCONST
Ü	ÛStateTablesİ : State ­  (Class ¸ Ide LIST ¸ Ide  ¸ TableSpec)LIST
÷üüüüüüüüüüüüüü
Ü	µs · StateTables s =
Ü		let (cl,illdl) =  Split(StateDirs s)
Ü		in let (ill,dl) =  Split illdl
Ü		in let (itll) = (Map DirTables dl)
Ü		in let f c i it = (c, i,it)
Ü		in let g (c, i, its) = Map (f c i) its
Ü		in let h cl is itss = Map g (Combine cl (Combine is itss)) 
Ü		in Flat (h cl ill itll) 
°

\subsection{Mapping  SSQL Tables to Derived Tables}

First, obtain the static column information  
for a derived table from a $ColSpec$.
¹HOLCONST
Ü	ÛColSpec‰dİ : (Ide LIST ¸ Ide  ¸ TableSpec) ­ ColSpec  ­ DerColSpec
÷üüüüüüüüüüüüüü
Ü	µ d_name t_name t cs · ColSpec‰d (d_name,t_name,t) cs = 
Ü			let cc = (TS_cons t) @ (CS_consGroup cs)
Ü			in let tc_name = Cons t_name[CS_ide cs]
Ü			in  MkDerColSpec
Ü				[[CS_ide cs];tc_name;d_name ë tc_name]
Ü				(CS_min cs)
Ü				(CS_max cs)
Ü				(CC_exist cc)
°

Obtain the static table information  
for a derived table from a $TableSpec$.
¹HOLCONST
Ü	ÛTableSpec‰dİ : (Class ¸ Ide LIST ¸ Ide  ¸ TableSpec) ­ DerTableSpec
÷üüüüüüüüüüüüüü
Ü	µ c d_name t_name t · TableSpec‰d (c, d_name,t_name,t) = 
Ü		 MkDerTableSpec
Ü			[[t_name];d_name ë [t_name]]
Ü			(TS_class t lub c)
Ü			(TS_maxRow t)
Ü			(RelList(Squash{(n,cs)|¶ cs'· cs'  TS_colspecs t 
Ü				± cs = ColSpec‰d (d_name,t_name,t) cs' ± n = CS_posn cs'}))
°

Obtain the information  
in a derived table  row from a $TableSpec$, a $Row$ and a 
classification. The where clause class is set to bottom since no
where clause has been evaluated for the row.

¹HOLCONST
Ü	ÛTableRow‰dİ : TableSpec ­ Row ­ DerTableRow
÷üüüüüüüüüüüüüü
Ü	µt r · TableRow‰d t r = 
Ü		let f = Ì d · (Dat_class d,Dat_item d)
Ü		in	MkDerTableRow
Ü			lattice_bottom
Ü			(R_exist r)
Ü			(RelList(Squash
Ü			{(n,ic)|n  Dom(R_data r) ± ic = f((R_data r) @ n)}))
°

Now obtain the derived table from a $TableSpec$ and a classification.

¹HOLCONST
Ü	ÛTable‰dİ : (Class ¸ Ide LIST ¸ Ide  ¸ TableSpec) ­ DerTable
÷üüüüüüüüüüüüüü
Ü	µ c d_name t_name t · Table‰d (c, d_name,t_name,t) = 
Ü		 MkDerTable
Ü			(TableSpec‰d (c, d_name,t_name,t))
Ü			(Map (TableRow‰d t) (TS_rows t))
°

\subsection{Viewing an SSQL State as a List of Derived Tables}


Finally the mapping from an SSQL $State$  to a list of derived tables.

¹HOLCONST
Ü	ÛView‰sİ :  State ­  DerTable LIST
÷üüüüüüüüüüüüüü
Ü	µ s · View‰s s = Map Table‰d (StateTables s)
°

\subsection{Viewing a TSQL State as a List of Derived Tables}
The view of a TSQL state is obtained using the view function for SSQL
and the representation function of \cite{DS/FMU/FEF/025}.
¹HOLCONST
Ü	ÛView‰tİ : State‰t ­  DerTable LIST
÷üüüüüüüüüüüüüü
Ü	µ s‰t · µs‰s· s‰t = reprState s‰s ´ View‰t s‰t = View‰s s‰s
°
Note that the consistency of the above implicit definition requires
that any two SSQL states which are identified by $reprState$ must be the
same when viewed as lists of derived tables.

\section{ACTION FUNCTION}

A derived table is flattened into a list of data tuples using
the following function:
¹HOLCONST
Ü	ÛGiveDataİ	:	DerTable ­ Data LIST LIST
÷üüüüüüüüüüüüüü
Ü	µdt·	GiveData dt =
Ü	let	class_item c = ValuedItemItem(MkValuedItem sterling (ClassVal c))
Ü	in let	item_data i = MkData lattice_bottom i
Ü	in let	class_data c = item_data (class_item c)
Ü	in let	cell_cols (c, i) = [class_data c; item_data i]
Ü	in let	row_data r
Ü		=	Flat
Ü			(Cons
Ü			[class_data (DTR_where r); class_data (DTR_row r)]
Ü			(Map cell_cols (DTR_cols r)))
Ü	in	Map row_data(DT_rows dt)
°
The following, which is intended to determine whether or not a query
is a $SELECT$ query might be moved to an earlier document, I think:
¹HOLCONST
Ü	Ûis_selectİ	:	Query ­ BOOL
÷üüüüüüüüüüüüüüüü
Ü	µq· is_select q ¤ ¶ t·q = select t
°
We do not yet have a specification of any of the database update operations
and so the update function must be supplied as a parameter to the function
defining the action of the system:
¹HOLCONST
Ü	ÛAct‰tİ	:	(Query ¸ (DerTable ¸ Errors) ¸ State‰t ­ State‰t)
Ü		­	Query ¸ (DerTable ¸ Errors) ¸ State‰t ­ State‰t ¸ ANSWER
÷üüüüüüüüüüüüüüüü
Üµupd; query; dt; errs; st· 
Ü	Act‰t upd (query, (dt, errs), st)
Ü=	if	³errs = []
Ü	then	(st, ([], errs))
Ü	else if	is_select query
Ü	then	(st, (GiveData dt, errs))
Ü	else	(upd (query, (dt, errs), st), ([], []))
°

\section{CRITICAL PROPERTIES}
We can now attempt to state critical requirements on the main subsystems
of the architectural model of \cite{DS/FMU/FEF/022} by attempting
to bound the allowable untrusted queries which are executed.
Since we are currently only concerned with the $SELECT$ query, only
condition $subsys\_secureE$ from \cite{DS/FMU/FEF/022} is relevant.

First of all,
we need to specify an analogue of $hide$ for derived tables in order
to state the information flow constraints which apply to computations on them.
¹HOLCONST
Ü	ÛHideDerTableRowİ : Class ­ DerTableRow ­ DerTableRow
÷üüüüüüüüüüüüüü
Ü	µcc r·	HideDerTableRow cc r
Ü	=	let	d = ValuedItemItem(MkValuedItem sterling dummyVal)
Ü		in let	hc (c, i) = if cc dominates c then (c, i) else (c, d)
Ü		in	MkDerTableRow
Ü			(DTR_where r)
Ü			(DTR_row r)
Ü			(Map hc (DTR_cols r))
°
¹HOLCONST
Ü	ÛHideDerTableİ : Class ­ DerTable ­ DerTable
÷üüüüüüüüüüüüüü
Ü	µcc t·	HideDerTable cc t
Ü	=	let	rs = DT_rows t
Ü		in let	ss = DT_spec t
Ü		in let	tc = DTS_class ss
Ü		in let	okr = {r|cc dominates (DTR_row r lub DTR_where r lub tc)}
Ü		in 	MkDerTable ss (Map (HideDerTableRow cc) (rs ù okr))
°
Given a function, $f$, on lists of derived tables, let us say that the {\em risk
inputs} of $f$ at a given class, $c$ are those inputs for which
$f$ reveals information which should not be visible at class $c$:

¹HOLCONST
Ü	ÛRiskInputsİ : Class ­ (DerTable LIST ­ DerTable ¸ Errors) ­ (DerTable LIST ğ)
÷üüüüüüüüüüüüüü
Ü	µc f·
Ü	RiskInputs c f
Ü	=	
Ü	{	ts
Ü	|	¶ts‰0 ·
Ü		Map (HideDerTable c) ts‰0 = Map (HideDerTable c) ts
Ü	±	(	³HideDerTable c (Fst(f ts‰0)) = HideDerTable c (Fst(f ts))
Ü		²	³Snd (f ts‰0) = Snd (f ts))}
°



We can now assert the critical requirements on the $SELECT$ query processing
(corresponding to $subsys\_secureE$ of \cite{DS/FMU/FEF/022}).
using the following auxiliary: 

¹HOLCONST
Ü	ÛConditionEİ	:	(Query ­ (DerTable LIST ­ DerTable ¸ Errors))
Ü			­	Class
Ü			­	((Query ¸ (Query + ONE) ¸ 'PARS) + Errors) ğ
÷üüüüüüüüüüüüüü
Ü	µcompile cc·
Ü	ConditionE compile cc
Ü	=	
Ü	{	stp_res
Ü	|	isError stp_res ²
Ü		let	(dq, ocq, pars) = destVal stp_res
Ü		in let	dcomp = compile dq
Ü		in	µri·	ri  RiskInputs cc dcomp
Ü			´	IsL ocq
Ü			±	let	ccomp = compile (OutL ocq)
Ü				in	³DT_rows(Fst (ccomp ri)) = []
Ü				²	³Snd (ccomp ri) = []}
°
¹HOLCONST
Ü	ÛSTP_secure_Eİ	:	(Query ­ (DerTable LIST ­ DerTable ¸ Errors))
Ü				­	(Query, 'PARS) STP_TYPE ğ
÷üüüüüüüüüüüüüü
Ü	µcompile·
Ü	STP_secure_E compile
Ü	=	
Ü	{	stp
Ü	|	µ q c· stp(q, c)  ConditionE compile c}
°
(and similarly, presumably for the other 4 conditions from
\cite{DS/FMU/FEF/022}, although something would need to be said about the
details of $upd$).


We can now instantiate the generic formulation of the execution
model to the particular view and action functions of the previous sections.
¹HOLCONST
Ü	ÛEM‰1İ		:	(Query ­ (DerTable LIST ­ DerTable ¸ Errors))
Ü			­	(Query ¸ (DerTable ¸ Errors) ¸ State‰t ­ State‰t)
Ü			­	(Query, State‰t) DBMS_TYPE
÷üüüüüüüüüüüüüü
Ü	µ compile upd· 
Ü	EM‰1 compile upd
Ü=	EM View‰t compile (Act‰t upd)
°

A compiler and associated database update operation are correct with
respect to the TSQL semantics if the above construction
implements the TSQL semantics as specified by $TSQLtf$ in
\cite{DS/FMU/FEF/021}.

¹HOLCONST
Ü	ÛCorrect_Compileİ	:	((Query ­ (DerTable LIST ­ DerTable ¸ Errors))
Ü				¸	(Query ¸ (DerTable ¸ Errors) ¸ State‰t ­ State‰t)) ğ
÷üüüüüüüüüüüüüü
Ü	Correct_Compile  = {(compile, upd) | EM‰1 compile upd = TSQLtf}
°

To relate the three-stage model of TSQL execution
to the actual system constructed from the TSQL transition function, filter
of SSQL transformation processor
of \cite{DS/FMU/FEF/021,DS/FMU/FEF/024,DS/FMU/FEF/029}, we can now conjecture that if a compiler and associated database update
operation satisfy the above correctness criterion, and if the SSQL Query
Transformation Processor lies in the set $STP\_secure\_E$
determines from them, then the system components satisfy property
E of \cite{DS/FMU/FEF/022} with respect to the representation.

¹HOLCONST
Ü	ÛConditionE_Lemmaİ : BOOL
÷üüüüüüüüüüüüüü
Ü	ConditionE_Lemma
Ü¤	µcompile upd·
Ü		(compile, upd)  Correct_Compile
Ü	±	STP  STP_secure_E compile
Ü	´	(TSQLtf, STP, outputFilter)  subsys_secureE reprState
°
=TEX
\section{TABLE COMPUTATIONS}
The idea now is to define a set of operations on tables in terms
of which it is possible to characterise the allowable results of
compiling the queries produced by the SSQL Transformation processor.
This is intended to give some insight into the intuitions about operations
on tables which motivate the transformations.

The idea is to identify the primitive operations on tables and on the
security information in them which underlie the semantics of SSQL and
its implementation via the transformations. We envisage something like
an SSQL analogue of the relational algebra in which clearances are
computed along with the required data operations. The clearance
computations would be, at least informally, fairly directly related to the
clearance computation which are implicit in the transformations.
This would be formally related to the security policy by using it to
characterise a class of table computations for which the risk inputs
are either empty or have a known form. This could then be used to give
an alternative way of characterising the assertion
=INLINEFT
STP  STP_secure_E compile
=TEX
\ of the previous section, which would relate more closely, at least informally,
to the internal details of the transformations.

What follows comprises a few first thoughts on some of the definitions
which might be needed to define an SSQL relational algebra as mentioned
above. It is far from complete, indeed the layer corresponding to
$Value$s in SSQL has not been touched upon, but would be required to
fill in the allowable parameters to operations such as the $Where$
operation defined below. The formal relation of what follows with the earlier
material is not yet in place.

The set of computations on tables which are allowed to be produced
when queries generates by the SQL Transformation Processor are
compiled will essentially be defined
by taking the closure under composition
of a finite set of particular
operations adequate to represent the primitive constructs of TSQL.
The closure is formed using the following function:

¹HOLCONST
Ü	ÛCompClosureİ	:	('a LIST ­ 'a) SET
Ü			­	('a LIST ­ 'a) SET
÷üüüüüüüüüüüüüüüüüü
Ü	µfs·	CompClosure fs
Ü	=	¥
Ü		{	a
Ü		|	fs € a
Ü		±	µh gl il·
Ü				h  a ± Elems gl € a ± Elems il € 1 .. Length gl
Ü			´	let	irl tl = Map (Ìg·g tl) gl
Ü				in let	comp tl = h (Map (Nth(irl tl)) il)
Ü				in	comp  a}
°
That is to say, the closure under composition of a set of functions, $fs$,
is the smallest set of functions which contains $fs$ and is closed
under the operation which given a function $h$, a list of functions $gl$,
and a list of numbers $il$, returns the function which first applies
each function in $gl$ to produce a list of intermediate results, uses
$il$ as indices to select some or all of the intermediate results in some
order and then applies $h$ to the result. For example, if
=INLINEFT
gl = [g‰1; g‰2; g‰3]
=TEX
\ and
=INLINEFT
il = [3; 1; 1; 2]
=TEX
, the composite function is
=INLINEFT
Ì tl· h [g‰3 tl; g‰1 tl; g‰1 tl; g‰2 tl]
=TEX
.
=IGN
PC_C1 "hol1" rewrite_conv(map get_spec[¬Map®, ¬Nth®, ¬Let®])
¬let	irl tl = Map (Ìg·g tl) [g‰1; g‰2; g‰3]
in let	comp tl = h (Map (Nth(irl tl)) [3; 1; 1; 2])
in	comp®;
=TEX

We can now start to construct the primitive building blocks.
In each case, we identify the origin in the specification of
the transformations of the computation of the relevant clearances.
\subsection{Join}
The TSQL join operation is just cartesian product. The row class
and where clause class in each tuple in the product is the least upper
bound of the corresponding classes in each component tuple which contributes to
that tuple. The joined table has no name and the table class and maximum
row class are the least upper bounds of those in the component tables.


Cf. $tuple\_list\sb{make\_outer}$ in \cite{trans}.
¹HOLCONST
Ü	ÛJoinSpecsİ : DerTableSpec LIST ­ DerTableSpec
÷üüüüüüüüüüüüüüüüüü
Ü	µsl·
Ü	JoinSpecs sl =
Ü	let	n = []
Ü	and	cl = lubl (Map DTS_class sl)
Ü	and	mr = lubl (Map DTS_maxRow sl)
Ü	and	csl = Flat (Map DTS_colSpecs sl)
Ü	in	MkDerTableSpec n cl mr csl
°
¹HOLCONST
Ü	ÛJoinRowsİ : DerTableRow LIST LIST ­ DerTableRow LIST
÷üüüüüüüüüüüüüüüüüü
Ü	JoinRows [] = []
Ü±	µtab rest·
Ü	JoinRows (Cons tab rest) =
Ü	if	rest = []
Ü	then	tab
Ü	else	let	jrest = JoinRows rest
Ü		in let	join2 r‰1 r‰2 = (
Ü				MkDerTableRow
Ü				(DTR_where r‰1 lub DTR_where r‰2)
Ü				(DTR_row r‰1 lub DTR_row r‰2)
Ü				(DTR_cols r‰1 ë DTR_cols r‰2))
Ü		in let	blks = Map (Ìr‰1· Map (join2 r‰1) jrest) tab
Ü		in	Flat blks
°
¹HOLCONST
Ü	ÛJoinİ : DerTable LIST ­ DerTable
÷üüüüüüüüüüüüüüüüüü
Ü	µtl·	Join tl
Ü	=	MkDerTable
Ü		(JoinSpecs (Map DT_spec tl))
Ü		(JoinRows (Map DT_rows tl))
°
\subsection{Projection}
The projection operation is parameterised by a list
of functions which compute class-item pairs from a row of a table,
together with column specifications to use for the computed fields.
(Note this is a more general than projection of a single field to form
a one-column table but includes that as a special case).

The operation acts on the first table in the argument list. 
The argument functions are expected to assign appropriate classifications
to the resulting fields. The computed table is anonymous.

Cf. $tuple\_list\sb{make\_outer}$ in \cite{trans}.

=SML
declare_type_abbrev("PROJ_PAR", [],
	”((DerTableRow ­ Class ¸ Item) ¸ DerColSpec) LIST®);
=TEX
¹HOLCONST
Ü	ÛProjectSpecsİ	: PROJ_PAR
Ü			 ­ DerTableSpec LIST
Ü			 ­ DerTableSpec
÷üüüüüüüüüüüüüüüüüü
Ü	µps s ign·
Ü	ProjectSpecs ps [] = MkDerTableSpec [] lattice_bottom lattice_bottom []
Ü	±
Ü	ProjectSpecs ps (Cons s ign) =
Ü	MkDerTableSpec [] (DTS_class s) (DTS_maxRow s) (Map Snd ps)
°
¹HOLCONST
Ü	ÛProjectDataİ	: PROJ_PAR
Ü			 ­ DerTableRow LIST LIST
Ü			 ­ DerTableRow LIST
÷üüüüüüüüüüüüüüüüüü
Ü	µps tab ign·
Ü	ProjectData ps [] = []
Ü±	ProjectData ps (Cons tab ign) =
Ü	let	fs = (Map Fst ps)
Ü	in let	h r = MkDerTableRow (DTR_where r) (DTR_row r) (Map (Ìf·f r) fs)
Ü	in	Map h tab
°
¹HOLCONST
Ü	ÛProjectİ : PROJ_PAR ­ DerTable LIST ­ DerTable
÷üüüüüüüüüüüüüüüüüü
Ü	µps tl·	Project ps tl
Ü	=	MkDerTable
Ü		(ProjectSpecs ps (Map DT_spec tl))
Ü		(ProjectData ps (Map DT_rows tl))
°
\subsection{$WHERE$}
The $WHERE$ operation is parameterised by a
function to compute a class and a truth value from a row of a table.
The operation acts on the first table in the argument list. 
The argument function is expected to give an appropriate classification
for the where clause class. The specification of the computed table is
the same as the original.

Cf. $tuple\_list\sb{make\_outer}$ in \cite{trans}.

=SML
declare_type_abbrev(Û"WHERE_PAR"İ, [],
	”DerTableRow ­ Class ¸ BOOL®);
=TEX
¹HOLCONST
Ü	ÛWhereDataİ	: WHERE_PAR
Ü			 ­ DerTableRow LIST LIST
Ü			 ­ DerTableRow LIST
÷üüüüüüüüüüüüüüüüüü
Ü	µp tab ign·
Ü	WhereData p [] = []
Ü±	WhereData p (Cons tab ign) =
Ü	let	w r = (DTR_where r lub Fst (p r))
Ü	in let	h r = (Snd (p r), MkDerTableRow (w r) (DTR_row r) (DTR_cols r))
Ü	in	Map Snd (Map h tab ù {(t, r) | t})
°
¹HOLCONST
Ü	ÛWhereİ : WHERE_PAR ­ DerTable LIST ­ DerTable
÷üüüüüüüüüüüüüüüüüü
Ü	µp tl·	Where p tl
Ü	=	MkDerTable
Ü		(Hd (Map DT_spec tl))
Ü		(WhereData p (Map DT_rows tl))
°

and so on ...

\section{CLOSING DOWN}
The following \Product{} instruction restores the previous proof context.
=SML
pop_pc();
=TEX

=SML
output_theory{theory = "fef026",out_file = "fef026th.doc"};
=TEX

\newpage
\HOLindexOff
\input{fef026th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex
=TEX
\end{document}
=IGN
rewrite_conv[get_spec¬JoinRows®, let_def, map_def, flat_def, get_spec¬$ë®, get_spec¬$MkDerTableRow®]
¬
JoinRows
[
[	MkDerTableRow w1 r1 [(c, A); (c, FALSE)];
	MkDerTableRow w2 r2 [(c, B); (c, TRUE)] ];
[	MkDerTableRow w3 r3 [(c, X); (c, a); (c, TRUE)];
	MkDerTableRow w4 r4 [(c, Y); (c, b); (c, FALSE)] ];
[	MkDerTableRow w5 r5 [(c, x)];
	MkDerTableRow w6 r6 [(c, y)];
	MkDerTableRow w7 r7 [(c, z)] ]
]
®;



rewrite_conv[get_spec¬JoinRows®, let_def, map_def, flat_def, get_spec¬$ë®, get_spec¬$MkDerTableRow®]
¬
JoinRows
[
[	MkDerTableRow w1 r1 [(c, A); (c, FALSE)];
	MkDerTableRow w2 r2 [(c, B); (c, TRUE)] ];
[	 ];
[	MkDerTableRow w5 r5 [(c, x)];
	MkDerTableRow w6 r6 [(c, y)];
	MkDerTableRow w7 r7 [(c, z)] ]
]
®;
rewrite_conv[get_spec¬JoinRows®, let_def, map_def, flat_def, get_spec¬$ë®, get_spec¬$MkDerTableRow®]
¬
JoinRows
[
[	MkDerTableRow w1 r1 [(c, A); (c, FALSE)];
	MkDerTableRow w2 r2 [(c, B); (c, TRUE)] ];
[	 [] ];
[	MkDerTableRow w5 r5 [(c, x)];
	MkDerTableRow w6 r6 [(c, y)];
	MkDerTableRow w7 r7 [(c, z)] ]
]
®;


declare_type_abbrev("WHERE_PAR", [],
	”DerTableRow ­ Class ¸ BOOL®);

set_pc"hol";
set_goal([], ¬RiskInputs c (Ìdtl· (Join dtl, [])) = {}®);

a(rewrite_tac[get_spec¬RiskInputs®]);

a(PC_T "sets_ext" contr_tac);

a(all_asm_ante_tac THEN rewrite_tac[]);

a(rewrite_tac(map get_spec[¬Join®, ¬HideDerTable®, ¬JoinSpecs®, ¬JoinRows®]));

a(rewrite_tac[let_def]);

a(rewrite_tac(map get_spec[¬MkDerTable®]));

a strip_tac;

val lemma = tac_proof(([], ¬µf g x y·f = g ± x = y ´ f x = g y®),
		REPEAT strip_tac THEN asm_rewrite_tac[]);

a(bc_tac[lemma]);

a(strip_tac THEN bc_tac[prove_rule[]¬µf g x y·f = g ± x = y ´ f x = g y®]);

