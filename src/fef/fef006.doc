=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Security Conjecture for the SSQL Abstract Machine}  %% Mandatory field
\TPPref{DS/FMU/FEF/006}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Approved}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{The formal specification of the SSQL abstract machine and  the conjecture
to be proven in order to prove its security. This contributes to  the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[\SCCSversion ({\FormatDate{$Date$
}})] First approved version.
\end{description}

\subsection{Changes Forecast}
Changes  may be necessary  as a result of issues raised
during  the transcription of the specification.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document gives a formal specification of  the SSQL abstract machine
and a formal specification of the security conjecture required to
be proven in order to prove the security of the SSQL semantics. It constitutes deliverable D4 of work package 1a, as given
in section 7 of the Secure Database Technical Proposal, \cite{DS/FMU/017}.

\subsection{Introduction}

In the Secure Database Technical Proposal, \cite{DS/FMU/017}, we stated that we propose 
to formalise the semantics of SSQL in such a way as to separate out
security considerations from other aspects of the semantics.
In this document ,  we describe how to construct an SSQL abstract machine from a transition
function and an initial state, $isstate$. The transition
function is built from the three components $hide$, $processQuery$ and $updateState$. The 
function $hide$, defined in \cite{DS/FMU/FEF/005},  operates on the 
state of the 
database  and returns a `sanitised' version of the state. 
The function  $processQuery$, defined in \cite{DS/FMU/FEF/004}, computes the result of a 
query on the `sanitised' state of the database. The function  $updateState$, 
defined in \cite{DS/FMU/FEF/005}, checks the security  of the result of
the query processing and only applies the update to the
database if it is secure.  


\section{PRELIMINARIES}
The following ICL HOL instructions set up the new theory $fef006$ and set the context 
for the proof tools.

=SML 
open_theory "fef005";
new_theoryÛ"fef006"İ;
push_pc "hol2";
=TEX

\section{CONSTRUCTION OF AN SSQL ABSTRACT MACHINE} \label{CONSTR}
\subsection{Types of Components}
As stated in \cite{DS/FMU/017}, we model an SSQL  abstract machine as a pair
consisting of a state transition function and an initial state.
The transition function is to be built from the three components
$hide$ and $updateState$, specified in  \cite{DS/FMU/FEF/005}, and  $processQuery$, specified in  \cite{DS/FMU/FEF/004}. 
We first give abbreviation definitions for the types $Hide$ of the $hide$ component,
$Process$ of the $processQuery$ component and $Ustate$ of the $updateState$ component.

=SML
declare_type_abbrev(Û"Hide"İ,[],” Class ¸ State ­ State®);
=TEX

=SML
declare_type_abbrev(Û"Process"İ,[],” Query ¸ Class ¸ State ­ Effect ¸ Errors®);
=TEX

=SML
declare_type_abbrev(Û"Ustate"İ,[],” Class ¸ (Effect ¸ Errors) ¸ State ­ 
				State ¸ (Class ¸ (Data LIST LIST ¸ Errors))®);
=TEX

We also give an abbreviation definition for the type of state transition functions, $Stf$.

=SML
declare_type_abbrev(Û"Stf"İ,[],” (Query ¸ Class) ¸ State ­ 
				State ¸ (Class ¸ (Data LIST LIST ¸ Errors))®);
=TEX

\subsection{Building a Transition Function}

We define a function, $mkTf$, which builds a transition function from three components: a component
of type $Hide$, a component of type $Process$ and a component of type $Ustate$. The resulting transition function
updates the original state of the database by using the
result of processing a query on the hidden state of the database. 

¹HOLCONST
Ü	ÛmkTfİ : Hide ­ Process ­ Ustate ­ Stf
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü
Ü	µh:Hide; p:Process; u:Ustate; q : Query; c : Class; s : State
Ü	·	(mkTf h p u) ((q,c),s) 
Ü		= 
Ü		u(c,p(q,c,h(c,s)),s)
° 
\subsection{The SSQL Abstract Machine}

An abstract machine is constructed from a pair consisting of a 
transition function and some initial state, of type $State$.

=SML
declare_type_abbrev(Û"Am"İ,[],” Stf ¸ State®);
=TEX

We specify the initial state, $isstate$ of the SSQL abstract machine.

¹HOLCONST
Ü	Ûisstateİ : State
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	T
° 

An SSQL abstract machine is one which is constructed from the
transition function built from the three components
$hide$, $processQuery$ and $updateState$, and the initial state $isstate$. 

¹HOLCONST
Ü	ÛSSQLamİ : Am
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	SSQLam = (mkTf hide processQuery updateState,isstate)
° 



\section{SECURITY CONJECTURE} 

We formalise the conjecture that the behaviour of the SSQL abstract machine
 is $secure$, as defined in \cite{DS/FMU/FEF/003}. First, we define what
we mean by `behaviour'. 

\subsection{Behavioural Abstraction} \label{BEHAVIOUR}
We define a function $behaviours$, generic in QUERY, DATA and STATE, which takes a transition function and a state and 
yields a behavioural model of type $BEHAVIOURS$ (a function from sequences of inputs to sequences of outputs). This behavioural model is independent of the representation of internal states.

We first need to define $iterate$ on states in the usual way. 

¹HOLCONST
Ü	Ûiterateİ : ((('QUERY ¸ Class) ¸ 'STATE) ­ ('STATE ¸ (Class ¸ 'DATA))) ­
Ü			((('QUERY ¸ Class)LIST ¸ 'STATE) 
Ü				­ ('STATE ¸ ((Class ¸ 'DATA)LIST)))
÷üüüüüüüüüüüüüüüüüüüüüüü
Ü	µs:'STATE;i:'QUERY ¸ Class;si:('QUERY ¸ Class) LIST;
Ü	f:(('QUERY ¸ Class) ¸ 'STATE) ­ ('STATE ¸ (Class ¸ 'DATA))
Ü	·	(iterate f) ([],s) = (s,[])
Ü	±
Ü		let	sso = (iterate f)(si,s)
Ü		in
Ü			(iterate f)(si ë [i],s)
Ü			= 
Ü			(Fst(f(i,Fst sso)),Snd sso ë [Snd(f(i,Fst sso))])
°


We define $behaviours$ as an iterated transition function from the initial state:

¹HOLCONST
Ü	Ûbehavioursİ : (((('QUERY ¸ Class) ¸ 'STATE) 
Ü				­ ('STATE ¸ (Class ¸ 'DATA))) ¸ 'STATE) 
Ü				­ ('QUERY,'DATA)BEHAVIOURS
÷üüüüüüüüüüüüüüüüüüüüüüü
Ü	µ tf : ('QUERY ¸ Class) ¸ 'STATE ­ 'STATE ¸ (Class ¸ 'DATA);istate:'STATE;
Ü		si:('QUERY ¸ Class)LIST
Ü	·	behaviours(tf,istate) si= Snd((iterate tf)(si,istate))
°

\subsection{SSQL Abstract Machine Correctness Conjecture}

Finally, we formally state the  correctness conjecture for the SSQL Abstract Machine, i.e. 
that its behaviour, as defined in section \ref{BEHAVIOUR}, is secure, as defined in 
\cite{DS/FMU/FEF/003}.

=GFT
	?ô 	behaviours SSQLam  secure
=TEX


\section{CLOSING DOWN}
The following ICL HOL instruction restores the previous proof context.
=SML
pop_pc();
=TEX

\section{APPROVAL OF THE SECURITY CONJECTURE} 
Comments on this document by DRA to be made  by 19th June 1992.


=IGN
output_theory{theory = "fef006",outfile = "fef006th.doc"};
=TEX

\newpage
\input{fef006th.tex}
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}

