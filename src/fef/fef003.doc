=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Formal Security Policy}  %% Mandatory field
\TPPref{DS/FMU/FEF/003}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{The formalisation of the security conjecture for the DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}}) ] Temporary fix to make $Á~Í$ postfix. $lattice\_bottom$, $lattice\_top$ and $lub$
 defined with $dominates$.

\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document gives a formal specification of a behavioural model of  systems
and a formal specification of a security policy which is a property on such
systems. It constitutes deliverable D1 of work package 1a, as given
in section 7 of the Secure Database Technical Proposal, \cite{DS/FMU/017}.

\subsection{Introduction}
In the Secure Database Technical Proposal, \cite{DS/FMU/017}, we stated that we propose 
to use a formalisation of a policy which is essentially a {\em non-interference}
formulation of the {\em no flows down} requirement expressed in Annex 1, {\em The SWORD Secure DBMS}, to the ITT \cite{ittdra}. The formal material from Section 5 of 
\cite{DS/FMU/017}
has been transferred to this document. This comprises a formal specification of a behavioural model of  systems
and a formal specification of a security policy which is a property on such
systems.
The SSQL specifications will be formalised as a particular behavioural model so
that it can be proven that SSQL provides information flow security.



\section{FORMAL SECURITY POLICY}
\subsection{Setting Up}
The following \Product{} instructions set up the new theory $fef003$ and set the context 
for the proof tools.
=SML
open_theory"wrk049";
new_theory €"fef003"›;
push_pc "hol";
declare_postfix (300,"Á~Í");
=TEX
An index of the names used in the formal specification may be found in Section \ref{INDEX}. 
A listing of the theory $fef003$ created by processing this document using \Product{}
may be found at the end of this document.

\subsection{Classification}
We begin formalising
the security model by defining a relation $dominates$
on classifications. We introduce a new type to represent the classifications.

=SML
new_type("Class",0);
=TEX

Classifications are partially ordered by the relation {\it dominates}. We define $lattice\_bottom$, $lattice\_top$ and
a least upper bound on classes, $lub$.

=SML
declare_infix (150,"dominates");
declare_infix (250,"lub");
=TEX

πHOLCONST
‹	$€dominates› : Class ≠ Class ≠ BOOL;
‹	$€lattice_bottom› : Class;
‹	$€lattice_top› : Class;
‹	$€lub› : Class ≠ Class ≠ Class
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ x y z: Class ∑
‹		x dominates x
‹	±	(x dominates y ± y dominates x ¥ x = y)
‹	±	(x dominates y ± y dominates z ¥ x dominates z)
‹±	(µ x ∑ x dominates lattice_bottom)
‹±	(µ x ∑ lattice_top dominates x)
‹±	(µ x y z∑ (x lub y dominates x)
‹		± (x lub y dominates y) 
‹		± (z dominates x ± z dominates y ¥ z dominates x lub y))
∞
=TEX

\subsection{The Type of Behavioural Models of Systems}

The definition of information flow security presented here is a property
on behavioural models of systems. An input to a system  under consideration 
is a single query  and a classification. Output from the system generated by a 
single query is a classification and some data.

A `behaviour' of a system is a single sequence of inputs and
the resulting sequence of outputs. A behavioural model
is the set of all possible behaviours.
This is formalised  as a function from the sequence of permissible inputs to the system, yielding the corresponding outputs.
The behavioural model is independent of the state of the system and generic in QUERY and DATA. 
=SML
declare_type_abbrev("BEHAVIOURS",["'QUERY","'DATA"],
	¨: ('QUERY ∏ Class)LIST ≠ (Class ∏ 'DATA)LISTÆ);
=TEX

\subsection{Critical Requirements} \label{CRITICAL}

We now attempt to capture (in fact {\em define}) what it means to say that such a 
behavioural model is {\em secure}.
The critical requirement is then that the behavioural model be secure.

The intended meaning of {\it secure} here concerns the nature of the information flows permitted by the behavioural model.

The formulation below is an ``interference style'' formulation.
To express the flow constraint in this way, it is first necessary to define filtering operations on the inputs and outputs of the system.

Two sequences of inputs {\it si1} and {\it si2} are the same when viewed from a classification {\it clear} if, after purging from both any input whose classification is not dominated by {\it clear}, the two resulting purged 
sequences are identical.


πHOLCONST
‹	€same_ins› : Class ≠ (('QUERY ∏ Class)LIST ™ ('QUERY ∏ Class)LIST)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µclear: Class; si1 si2: ('QUERY ∏ Class)LIST
‹	∑	(si1,si2) ç same_ins clear 
‹		§
‹		let v = {(q,c)|(clear dominates c)}
‹		in
‹		si1 ˘ v = si2 ˘ v
∞

Two sequences of outputs {\it so1} and {\it so2} are the same when viewed from a classification {\it clear} if, after purging from both any output whose classification is not dominated by {\it clear}, the two resulting purged 
sequences are identical.

πHOLCONST
‹	€same_outs› : Class ≠ ((Class ∏ 'DATA)LIST ™ (Class ∏ 'DATA)LIST)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µclear: Class; so1 so2: (Class ∏ 'DATA)LIST
‹	∑	(so1,so2) ç same_outs clear 
‹		§
‹		let v = {(c,d)|(clear dominates c)}
‹		in
‹		so1 ˘ v = so2 ˘ v
∞

The constraint on information flows proposed for verification is that outputs classified at classes dominated by any class {\it clear} are independent of inputs at classifications which 
are not dominated by {\it clear}.
We assume that mechanisms outside the scope of this model ensure that users see only those outputs which they are cleared to see, and that inputs are correctly classified.

This is expressed by saying that if two sequences of inputs are the same when viewed at a certain classification then the outputs will be the same when viewed at that classification.


πHOLCONST
‹	€secure›: ('QUERY,'DATA)BEHAVIOURS  
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µbm:('QUERY,'DATA)BEHAVIOURS
‹	∑	bm ç secure 
‹		§
‹		µ clear : Class; si1 si2 :('QUERY ∏ Class)LIST
‹			∑	(si1,si2) ç same_ins clear 
‹				¥
‹				(bm si1,bm si2) ç same_outs clear
∞

The enunciation of the security requirement as a {\it property} of behavioural models of systems
enables us to express directly the claim that a behavioural model of
 an implementation is secure.
The formal specifications of the design and implementation of the SSQL system
 will then be expressed as entities, the behavioural model of which has type 
(some instance of) {\it BEHAVIOURS}.
The proposition that they exhibit secure behaviour will then be expressible, 
and provable.
\section{CLOSING DOWN}
The following \Product{} instruction restores the previous proof context.
=SML
pop_pc();
=TEX

\section{THE SECURITY MODEL JUSTIFICATION} \label{JUST}
The formal security policy given here is exactly that of the Secure Database Technical Proposal, \cite{DS/FMU/017}, which is the basis of the current contract.  After reconsideration, it was decided that  the constraints
on the function $BEHAVIOURS$  should be removed since they 
were not part of the security policy and hence were irrelevant. 


The justification for using  {\em non-interference} as a security model for
the SSQL front end filter may be found in the text introducing
and defining $same\_ins$, $same\_outs$ and $secure$ in Section \ref{CRITICAL}.
This is a straightforward formalisation of the {\em no flows down} policy cited in Annex 1 of the ITT \cite{ittdra} 
that results returned
to clients are affected only by inputs of lower or equal classification. 

We have defined information flow security as a property on 
behavioural models of systems. This means that security is dependent only on inputs to and outputs from the system, and is independent
of the state of the system. A secure refinement from the SSQL abstract
machine to an SSQL implementation is one which preserves behaviour,
hence we may refine the state of the system to an implementation
provided we maintain its behaviour.

=IGN
output_theory{theory = "fef003",out_file = "fef003th.doc"};
=TEX
\newpage
\HOLindexOff
\input{fef003th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}




