=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Formal Security Policy}  %% Mandatory field
\TPPref{DS/FMU/FEF/003}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Approved}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{The formalisation of the security conjecture for the DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue 2.1] First approved version.
\item[Issue $Revision$ ({\FormatDate{$Date$
}})] Generic parameters missing from specification of $secure$.
\end{description}

\subsection{Changes Forecast}
Technical changes to the policy may be necessary  as a result of issues raised
during  the transcription of the specification.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document gives a formal specification of a behavioural model of  systems
and a formal specification of a security policy which is a property on such
systems. It constitutes deliverable D1 of work package 1a, as given
in section 7 of the Secure Database Technical Proposal, \cite{DS/FMU/017}.

\subsection{Introduction}
In the Secure Database Technical Proposal, \cite{DS/FMU/017}, we stated that we propose 
to use a formalisation of a policy which is essentially a {\em non-interference}
formulation of the {\em no flows down} requirement expressed in Annex 1, {\em The SWORD Secure DBMS}, to the ITT \cite{ittdra}. The formal material from Section 5 of 
\cite{DS/FMU/017}
has been transferred to this document. This comprises a formal specification of a behavioural model of  systems
and a formal specification of a security policy which is a property on such
systems.
The SSQL specifications will be formalised as a particular behavioural model so
that it can be proven that SSQL provides information flow security.



\section{FORMAL SECURITY POLICY}
\subsection{Setting Up}
The following ICL HOL instructions set up the new theory $fef003$.
Â
close_theory();
load_theory "Z_Lib_rel";
new_theory"‚fef003·";
Ê
An index of the names in the Z specification may be found in Section \ref{INDEX}. 
A listing of the theory $fef003$ created by processing this document using ICL HOL
is in Section \ref{THEORYLIST}.
\subsection{Classification}
We begin formalising
the security model by defining a relation $dominates$
on classifications. We introduce a given set to represent the classifications.

Ë
›	[‚Class·]
Ê

Classifications are partially ordered by the relation {\it dominates}.

Í
›
›	_‚dominates·_ : Class ê Class
…ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
›	É x,y,z: Class é
›			x dominates x
›		Ä	(x dominates y Ä y dominates x ä x = y)
›		Ä	(x dominates y Ä y dominates z ä x dominates z)
À

\subsection{The Type of Behavioural Models of Systems}

The definition of information flow security presented here is a property
on behavioural models of systems. An input to a system  under consideration 
is a single query  and a classification. Output from the system generated by a 
single query is a classification and some data.

A `behaviour' of a system is a single sequence of inputs and
the resulting sequence of outputs. A behavioural model
is the set of all possible behaviours.
This is formalised in Z as a function from the sequence of permissible inputs to the system, yielding the corresponding outputs.
The behavioural model is independent of the state of the system and generic in QUERY and DATA. We also require the constraints that the function is total and
 the function be obtained by iterating a single step transition function. 


Ë
›	‚BEHAVIOURS·[QUERY,DATA] == 
›		{f: seq(QUERY â Class)  ã seq(Class â DATA)
›		|	Ési,si': seq(QUERY â Class); so:seq(Class â DATA)
›			| 	f si = so
›			é 	#si = #so		
›				Ä 	
›				(Ñso': seq(Class â DATA) é f(si µ si') = so µ so')
›		}
Ê

\subsection{Critical Requirements} \label{CRITICAL}

We now attempt to capture (in fact {\em define}) what it means to say that such a 
behavioural model is {\em secure}.
The critical requirement is then that the behavioural model be secure.

The intended meaning of {\it secure} here concerns the nature of the information flows permitted by the behavioural model.

The formulation below is an ``interference style'' formulation.
To express the flow constraint in this way, it is first necessary to define filtering operations on the inputs and outputs of the system.

Two sequences of inputs {\it si1} and {\it si2} are the same when viewed from a classification {\it c} if, after purging from both any input whose classification is not dominated by {\it c}, the two resulting purged 
sequences are identical.

Î[QUERY]
›	‚same_ins· : Class ã (seq(QUERY â Class) ê seq(QUERY â Class))
…ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
›
›	Éc: Class; si1, si2: seq(QUERY â Class); v:ë (QUERY â Class)
›	|	v = {qc: QUERY â Class|(c dominates (second qc))}
›	é	(si1,si2) ù same_ins c 
›		Ç
›		si1 ¡ v = si2 ¡ v
À

Two sequences of outputs {\it so1} and {\it so2} are the same when viewed from a classification {\it c} if, after purging from both any output whose classification is not dominated by {\it c}, the two resulting purged 
sequences are identical.

Î[DATA]
›	‚same_outs· : Class ã (seq (Class â DATA) ê seq (Class â DATA))
…ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
›
›	Éc: Class; so1, so2: seq (Class â DATA); v: ë (Class â DATA)
›	|	v = {cd: Class â DATA|(c dominates (first cd))}
›	é	(so1,so2) ù same_outs c 
›		Ç
›		so1 ¡ v = so2 ¡ v
À

The constraint on information flows proposed for verification is that outputs classified at classes dominated by any class {\it c} are independent of inputs at classifications which 
are not dominated by {\it c}.
We assume that mechanisms outside the scope of this model ensure that users see only those outputs which they are cleared to see, and that inputs are correctly classified.

This is expressed by saying that if two sequences of inputs are the same when viewed at a certain classification then the outputs will be the same when viewed at that classification.

Î[QUERY,DATA]
›	‚secure· : ë BEHAVIOURS[QUERY,DATA]
…ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
›
›	Ébm:BEHAVIOURS[QUERY,DATA]é bm ù secure Ç
›
›	(É c : Class; si1,si2 :seq(QUERY â Class)
›	|	(si1,si2) ù same_ins[QUERY] c 
›	é	(bm si1,bm si2) ù same_outs[DATA] c)
À

The enunciation of the security requirement as a {\it property} of behavioural models of systems
enables us to express directly the claim that a behavioural model of
 an implementation is secure.
The formal specifications of the design and implementation of the SSQL system
 will then be expressed as entities, the behavioural model of which has type 
(some instance of) {\it BEHAVIOURS}.
The proposition that they exhibit secure behaviour will then be expressible, 
and provable.
\section{THE SECURITY MODEL JUSTIFICATION} \label{JUST}
The formal security policy given here is exactly that of the Secure Database Technical Proposal, \cite{DS/FMU/017}, which is the basis of the current contract.


The justification for using  {\em non-interference} as a security model for
the SSQL front end filter may be found in the text introducing
and defining $same\_ins$, $same\_outs$ and $secure$ in Section \ref{CRITICAL}.
This is a straightforward formalisation of the {\em no flows down} policy cited in Annex 1 of the ITT \cite{ittdra} 
that results returned
to clients are affected only by inputs of lower or equal classification. 

We have defined information flow security as a property on 
behavioural models of systems. This means that security is dependent only on inputs to and outputs from the system, and is independent
of the state of the system. A secure refinement from the SSQL abstract
machine to an SSQL implementation is one which preserves behaviour,
hence we may refine the state of the system to an implementation
provided we maintain its behaviour.

\section{APPROVAL OF THE FORMAL SECURITY POLICY} 
Comments on this document by DRA to be made  by 30th April 1992.

\newpage
\section{THEORY LISTING}\label{THEORYLIST}
Â
list_z_theory"fef003";
Ê

ÛHOL output
Listing of the Theory fef003

Constants

Class			: ë Class
dominates		: ë (Class â Class)
BEHAVIOURS	: ë ë (ë (Ì â (*QUERY â Class)) â ë (Ì â (Class â *DATA)))
same_ins		: ë (Class â ë (ë (Ì â (*QUERY â Class)) â ë (Ì â (*QUERY â Class))))
same_outs		: ë (Class â ë (ë (Ì â (Class â *DATA)) â ë (Ì â (Class â *DATA))))
secure			: ë ë (ë (Ì â (*QUERY â Class)) â ë (Ì â (Class â *DATA)))

Definitions

(Class = (HOL ABS_ë(\ x.T) LOH))
((dominates ù (Class ê Class)) Ä 
	(Éx: Class; y: Class; z: Class | true 
	é 	(((x dominates x) Ä (((x dominates y) Ä (y dominates x)) ä (x = y))) 
	Ä 	(((x dominates y) Ä (y dominates z)) ä (x dominates z)))))
[QUERY, DATA](BEHAVIOURS = {f: (seq (QUERY â Class) ã seq (Class â DATA)) 
	|	(Ési: seq (QUERY â Class); si': seq (QUERY â Class); so: seq (Class â DATA) 
		| ((f si) = so) 
		é (((# si) = (# so)) 
		Ä (Ñso': seq (Class â DATA) | true é ((f (si µ si')) = (so µ so'))))) é f})
[QUERY]((same_ins ù (Class ã (seq (QUERY â Class) ê seq (QUERY â Class)))) Ä 
	(Éc: Class; si1: seq (QUERY â Class); si2: seq (QUERY â Class); v: ë (QUERY â Class) 
	| 	(v = {qc: (QUERY â Class) | (c dominates (second qc)) é qc}) 
	é 	(((si1, si2) ù (same_ins c)) Ç ((si1 ¡ v) = (si2 ¡ v)))))
[DATA]((same_outs ù (Class ã (seq (Class â DATA) ê seq (Class â DATA)))) Ä 
	(Éc: Class; so1: seq (Class â DATA); so2: seq (Class â DATA); v: ë (Class â DATA) 
	| 	(v = {cd: (Class â DATA) | (c dominates (first cd)) é cd}) 
	é 	(((so1, so2) ù (same_outs c)) Ç ((so1 ¡ v) = (so2 ¡ v)))))
[QUERY, DATA]((secure ù ë BEHAVIOURS) Ä 
	(Ébm: BEHAVIOURS | true 
	é 	((bm ù secure) 
		Ç 
		(Éc: Class; si1: seq (QUERY â Class); si2: seq (QUERY â Class) 
		| 	((si1, si2) ù (same_ins c)) 
		é	 (((bm si1), (bm si2)) ù (same_outs c))))))

Theorems
val it = () : unit   
Ê

\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}




