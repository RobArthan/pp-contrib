
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Phase II Proof Finale}  %% Mandatory field
\TPPref{DS/FMU/FEF/036}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
%\TPPauthor{R.~D.~Arthan & WIN01}  %% Mandatory field
\TPPauthors{R.~D.~Arthan & WIN01\\G.~M.~Prout & WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document  completes the table computations security
proof and uses it with the partial proof of the execution model security
to provide the best partial 
proof for Phase II of the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion(\FormatDate{$Date$
})] Some explanation added.
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document provides a formal proof of the conjecture $TableComputationsSecure$
from the proof strategy, \cite{DS/FMU/FEF/034}. This result is used, 
together with the partial proof achieved in \cite{DS/FMU/FEF/031} 
of the execution model conjecture $EM\_SecureE$ of \cite{DS/FMU/FEF/034}, to produce
the best partial proof for Phase II. It constitutes part of deliverable D13 of work package 3, 
as given
in section 3 of the Proposal for Phase 2, \cite{DS/FMU/FEF/018}.



\subsection{Introduction}

In ``Table Computations for SWORD'', \cite{DS/FMU/FEF/032}, semantic functions for 
the value and table  computations are defined together with  corresponding
 critical properties $OK\_VCâd$,  $OK\_VCâc$, $OK\_TCâd$ and $OK\_TCâc$. Documents
\cite{DS/FMU/FEF/033} and \cite{DS/FMU/FEF/035} provide formal proofs that all
these semantics functions satisfy their identified critical properties. We now
bring together these proofs to prove the conjecture
$TableComputationsSecure$ of  the proof strategy, \cite{DS/FMU/FEF/034}. This is
achieved via an induction principle for the set of semantic functions, in a similar
manner to that of the example in section 3.3 of \cite{DS/FMU/FEF/032}.

During the production  of the specifications of the semantic functions
and during the process of proving that they satisfy their identified critical 
properties,
errors in the underlying query transformation specifications of \cite{trans}
came to light. These errors are significant in that they render the SWORD
system insecure. We give a brief account of measures taken to
correct the specifications.

Finally we provide the best partial proof for Phase II. The
proof of  $TableComputationsSecure$ and the partial proof 
in \cite{DS/FMU/FEF/031} of the execution model conjecture, $EM\_SecureE$, 
(defined in \cite{DS/FMU/FEF/034}) are used to improve on $Theorem4$ of 
the proof strategy, \cite{DS/FMU/FEF/034}.
 
\section{PRELIMINARIES}
The following \Product{} instructions set up a new theory $fef036$
to hold the theorems to be proved and set up a proof context in which
to carry out the proofs. 

=SML 
open_theory "fef035";
(force_delete_theory "fef036" handle _ => ());
new_theory€"fef036"›;
set_pc"hol";
=TEX
\section{TABLE COMPUTATIONS SECURITY PROOF}
=TEX
\subsection{Induction Principle}
In \cite{DS/FMU/FEF/032}, we gave an account of reducing the critical
requirements on the SSQL Transformation Processor by placing
a bound on the allowed TSQL queries it produces. This involved a 
reformulation of the classification computations which underlie
the query transformations defined in \cite{trans} in terms
of a relational algebra model of TSQL execution. The semantic functions 
defined in \cite{DS/FMU/FEF/032}
bring out the security checks which correspond to each of the constructors
of the SSQL language. The  overall security checks
required by the SSQL semantics are then reduced to properties of the individual
constructors by an induction principle for the set of semantic functions.

We first express the induction principle as a HOL theorem.

=SML
set_goal([], ¨µcc:Class∑
	µtcs : TABLE_COMP SET; vcs : VALUE_COMP SET∑
		(µci∑ DenoteConstant ci ç vcs)
	±	(µi∑ Contents i ç vcs)
	±	(µi∑ Classification i ç vcs)
	±	CountAll ç vcs

	±	(µf e∑ e ç vcs ¥ MonOp f e ç vcs)
	±	(µf e1 e2∑ e1 ç vcs ± e2 ç vcs ¥ BinOp f e1 e2 ç vcs)
	±	(µf e1 e2 e3∑ e1 ç vcs ± e2 ç vcs ± e3 ç vcs ¥ TriOp f e1 e2 e3 ç vcs)
	±	(µel∑ Elems el Ä vcs ¥ BinOpAnd cc el ç vcs)
	±	(µel∑ Elems el Ä vcs ¥ BinOpOr cc el ç vcs)

	±	(µte cel ee∑ te ç vcs ± Elems(Map Fst cel) Ä vcs ±
				Elems(Map Snd cel) Ä vcs ± ee ç vcs ¥
					CaseVal cc te cel ee ç vcs)
	±	(µcel ee∑ Elems(Map Fst cel) Ä vcs ±
				Elems(Map Snd cel) Ä vcs ± ee ç vcs  ¥
					Case cc cel ee ç vcs)

	±	(µe∑ e ç vcs ¥ SetFuncAllAnd cc e ç vcs)
	±	(µe∑ e ç vcs ¥ SetFuncAllOr cc e ç vcs)
	±	(µe∑ e ç vcs ¥ CountNonNull e ç vcs)
	±	(µe∑ e ç vcs ¥ CountDistinct e ç vcs)
	±	(µe∑ e ç vcs ¥ CommonValue e ç vcs)

	±	(µf e∑ e ç vcs ¥ SetFuncAll f e ç vcs)
	±	(µf e∑ e ç vcs ¥ SetFuncDistinct f e ç vcs)

	±	(µte∑ te ç tcs ¥ ExistsTuples cc te ç vcs)
	±	(µte∑ te ç tcs ¥ SingleValue cc te ç vcs)

	±	(JoinedRowExistence cc ç vcs)
=TEX
=SML
	±	(µi∑ TableContents i ç tcs)

	±	(µesl tel e1 ml nl e2∑ Elems(Map Fst esl) Ä vcs
			± Elems tel Ä tcs ± e1 ç vcs ± e2 ç vcs
				¥ AllTuples cc esl tel e1 ml nl e2 ç tcs)
(*	±	(µesl tel e1 ml nl e2∑ Elems(Map Fst esl) Ä vcs)
			± Elems tel Ä tcs ± e1 ç vcs ± e2 ç vcs
				¥ DistinctTuples cc esl tel e1 ml nl e2 ç tcs)
	±	(µesl tel e1 ml nl e2∑ Elems(Map Fst esl) Ä vcs)
			± Elems tel Ä tcs) ± e1 ç vcs ± e2 ç vcs
				¥ Evaluate cc esl tel e1 ml nl e2 ç tcs)	*)
	¥	TableComputations cc Ä tcs
	±	ValueComputations cc Ä vcs
Æ);
a(REPEAT µ_tac THEN strip_tac
	THEN rewrite_tac[rewrite_rule[get_spec¨•â2Æ] (get_spec¨TableComputationsÆ)]
	THEN PC_T1"sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (strip_asm_tac o µ_elim¨tcsÆ)
	THEN POP_ASM_T (ante_tac o µ_elim¨vcsÆ)
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T (strip_asm_tac o µ_elim¨vcsÆ)
	THEN POP_ASM_T (ante_tac o µ_elim¨tcsÆ)
	THEN asm_rewrite_tac[]);
val €table_computation_induction_thm› =
	save_pop_thm"table_computation_induction_thm";
=TEX
\subsection{Proof of $TableComputationsSecure$}

We need to put together all the lemmas proved in \cite{DS/FMU/FEF/033} 
and \cite{DS/FMU/FEF/035} which comprise the inductive steps of
the  induction principle of the previous section.
The critical properties $OK\_VCâd$ and $OK\_VCâc$ are proven separately
 in \cite{DS/FMU/FEF/033} for each value form. Similarly, the critical 
properties $OK\_TCâd$ and $OK\_TCâc$ are proven separately
 in \cite{DS/FMU/FEF/035} for each table form. We first ``massage''
the separate lemmas from \cite{DS/FMU/FEF/033} and \cite{DS/FMU/FEF/035}
to give a list of lemmas of a suitable form for the induction principle.
For example, consider the two separate monadic form 
results from \cite{DS/FMU/FEF/033} :
=GFT
Ù µc f vc∑ vc ç OK_VCâd c ¥ MonOp f vc ç OK_VCâd c
Ù µc f vc∑ vc ç OK_VCâc c ¥ MonOp f vc ç OK_VCâc c
=TEX
In order to match the form of the induction principle, we require the result
=GFT
Ù µc f vc∑ vc ç OK_VCâd c ° OK_VCâc c ¥ MonOp f vc ç OK_VCâd c ° OK_VCâc c
=TEX
Rather than prove each result of this form separately, we use 
forward inference on all the appropriate lemmas of \cite{DS/FMU/FEF/033}
and \cite{DS/FMU/FEF/035}together to obtain a  theorem suitable
for use by the induction principle.


We set an ML variable $ok\_vc\_tc\_conjs$ to the list of terms
of the correct form for the hypothesis of the induction principle.
=SML
val €ok_vc_tc_conjs› = map (curry mk_µ ¨c:ClassÆ)
[
¨µci∑ DenoteConstant ci ç OK_VCâd c ° OK_VCâc cÆ,
¨µi∑ Contents i ç OK_VCâd c ° OK_VCâc cÆ,
¨µi∑ Classification i ç OK_VCâd c ° OK_VCâc cÆ,
¨CountAll ç OK_VCâd c ° OK_VCâc cÆ,
=TEX
=SML
¨µf e∑ e ç OK_VCâd c ° OK_VCâc c ¥ MonOp f e ç OK_VCâd c ° OK_VCâc cÆ,
¨µf e1 e2∑ e1 ç OK_VCâd c ° OK_VCâc c ± e2 ç OK_VCâd c ° OK_VCâc c ¥ 
		BinOp f e1 e2 ç OK_VCâd c ° OK_VCâc cÆ,
¨µf e1 e2 e3∑ e1 ç OK_VCâd c ° OK_VCâc c ± e2 ç OK_VCâd c ° OK_VCâc c ± 
	e3 ç OK_VCâd c ° OK_VCâc c ¥ 
	TriOp f e1 e2 e3 ç OK_VCâd c ° OK_VCâc cÆ,
¨µel∑ Elems el Ä OK_VCâd c ° OK_VCâc c ¥ BinOpAnd c el ç OK_VCâd c ° OK_VCâc cÆ,
¨µel∑ Elems el Ä OK_VCâd c ° OK_VCâc c ¥ BinOpOr c el ç OK_VCâd c ° OK_VCâc cÆ,
=TEX
=SML
¨µte cel ee∑
	te ç OK_VCâd c ° OK_VCâc c ± Elems(Map Fst cel) Ä OK_VCâd c ° OK_VCâc c ±
	Elems(Map Snd cel) Ä OK_VCâd c ° OK_VCâc c ± ee ç OK_VCâd c ° OK_VCâc c ¥
			CaseVal c te cel ee ç OK_VCâd c ° OK_VCâc cÆ,
¨µcel ee∑ Elems(Map Fst cel) Ä OK_VCâd c ° OK_VCâc c ±
	Elems(Map Snd cel) Ä OK_VCâd c ° OK_VCâc c ± ee ç OK_VCâd c ° OK_VCâc c  ¥
		Case c cel ee ç OK_VCâd c ° OK_VCâc cÆ,
=TEX
=SML
¨µe∑ e ç OK_VCâd c ° OK_VCâc c ¥ SetFuncAllAnd c e ç OK_VCâd c ° OK_VCâc cÆ,
¨µe∑ e ç OK_VCâd c ° OK_VCâc c ¥ SetFuncAllOr c e ç OK_VCâd c ° OK_VCâc cÆ,
¨µe∑ e ç OK_VCâd c ° OK_VCâc c ¥ CountNonNull e ç OK_VCâd c ° OK_VCâc cÆ,
¨µe∑ e ç OK_VCâd c ° OK_VCâc c ¥ CountDistinct e ç OK_VCâd c ° OK_VCâc cÆ,
¨µe∑ e ç OK_VCâd c ° OK_VCâc c ¥ CommonValue e ç OK_VCâd c ° OK_VCâc cÆ,

¨µf e∑ e ç OK_VCâd c ° OK_VCâc c ¥ SetFuncAll f e ç OK_VCâd c ° OK_VCâc cÆ,
¨µf e∑ e ç OK_VCâd c ° OK_VCâc c ¥ SetFuncDistinct f e ç OK_VCâd c ° OK_VCâc cÆ,

¨µte∑ te ç OK_TCâd c ° OK_TCâc c ¥ ExistsTuples c te ç OK_VCâd c ° OK_VCâc cÆ,
¨µte∑ te ç OK_TCâd c ° OK_TCâc c ¥ SingleValue c te ç OK_VCâd c ° OK_VCâc cÆ,
¨JoinedRowExistence c ç OK_VCâd c ° OK_VCâc cÆ,
=TEX
=SML
¨µ i∑ TableContents i ç OK_TCâd c ° OK_TCâc cÆ,
¨µ esl tel e1 ml nl e2∑
	Elems (Map Fst esl) Ä OK_VCâd c ° OK_VCâc c ±	
	Elems tel Ä OK_TCâd c ° OK_TCâc c ±	e1 ç OK_VCâd c ° OK_VCâc c ±	
	e2 ç OK_VCâd c ° OK_VCâc c
         	 ¥ AllTuples c esl tel e1 ml nl e2 ç OK_TCâd c ° OK_TCâc cÆ
];
=TEX
The following theorems will be used to eliminate $°$.
=SML
val ths = map (pc_rule1"sets_ext1"prove_rule[]) [
	¨µx a b∑x ç a ° b § x ç a ± x ç bÆ,
	¨µc a b∑c Ä a ° b § c Ä a ± c Ä bÆ];
=TEX
We retrieve all the lemmas from \cite{DS/FMU/FEF/033} 
and \cite{DS/FMU/FEF/035} where the right hand side of the conclusion
is of the form $ç\ OK\_VCâd$, $ç\ OK\_VCâc$, $ç\ OK\_TCâd$, or $ç\ OK\_TCâd$.
We set an ML variable $ok\_vc\_tc\_thms$ to this list of lemmas.

=SML
val €ok_vc_tc_thms› = 
	map
	(fn (_, t) =>
		((hd o rev o strip_¥ o snd o strip_µ o concl) t, rewrite_rule ths t
								handle Fail _ => t))
	((get_thms"fef033" @ get_thms"fef035")
	drop
	(fn t =>
		let	val x = (fst o dest_app o snd o dest_app o hd o rev o
					strip_¥ o snd o strip_µ o concl o snd) t
		in	not(x =$ ¨OK_VCâdÆ) andalso not(x =$ ¨OK_VCâcÆ) 
			andalso not(x =$ ¨OK_TCâdÆ) andalso not(x =$ ¨OK_TCâcÆ)
		end	handle Fail _ => true));
=TEX
We now use the list of proven results, $ok\_vc\_tc\_thms$, together with
 the tactic $ok\_vc\_tc\_tac$ and rule $ok\_vc\_tc\_rule$, to prove a
list of theorems $ok\_vc\_tc\_lemmas$ which are in a form suitable to
be incorporated into the induction principle.

=SML
val €ok_vc_tc_tac› : TACTIC = (fn gl as (_, cnc) =>
	let	val th = snd(find ok_vc_tc_thms
			(fn (t, _) =>
				(term_match cnc t; true) handle Fail _ => false));
	in	SOLVED_T (all_fc_tac[th] THEN asm_rewrite_tac[])
			ORELSE rewrite_tac[th]
	end	gl
);
=TEX
=SML
fun €ok_vc_tc_rule› t = (
	tac_proof(([], t), once_rewrite_tac ths THEN REPEAT strip_tac THEN ok_vc_tc_tac)
);
=TEX
The list of theorems produced by mapping $ok\_vc\_tc\_rule$ 
over  $ok\_vc\_tc\_conjs$ has been conjoined to give a single
theorem (using $list\_±\_intro$) so that the results of all these 
computations 
may be seen in the theory listing
=SML
val €ok_vc_tc_lemmas› = save_thm("ok_vc_tc_lemmas", 
	list_±_intro(map ok_vc_tc_rule ok_vc_tc_conjs));
=TEX
Now the proof of $TableComputationsSecure$.
=SML
set_goal([], ¨TableComputationsSecureÆ);
a(lemma_tac¨µc∑	TableComputations c Ä OK_TCâd cÆ);
(* *** Goal "1" *** *)
a µ_tac;
a(ante_tac(list_µ_elim[¨c:ClassÆ, ¨OK_TCâd c ° OK_TCâc cÆ, ¨OK_VCâd c ° OK_VCâc cÆ]
		table_computation_induction_thm)
	THEN asm_rewrite_tac [ok_vc_tc_lemmas]);
a(PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac OK_TCâd_lemma);
a(PC_T1 "sets_ext1" asm_prove_tac[get_spec¨TableComputationsSecureÆ]);
val €TableComputationsSecure_thm› = save_pop_thm"TableComputationsSecure_thm";
=TEX
\section{PHASE II PROOF SUMMARY}

In the proof strategy, \cite{DS/FMU/FEF/034}, we identified the three main
areas which would be amenable to formal reasoning :
\begin{enumerate}
\item
Architectural Model
\item
$TSQL$ ExecutionModel
\item
Table Computations
\end{enumerate}

In the time available, most of the proof effort has been concerned
with  area (3). The conjecture $TableComputationsSecure$ has been proven. In
addition work in area (2) has resulted in a partial proof of the security
of the TSQL Execution Model. The result of this is the replacement
of the conjecture $EM\_SecureE$,defined in \cite{DS/FMU/FEF/034}, by 
two more detailed assumptions, $Viewât\_secureE$ and  $outputFilter\_secureE$.
The first of these is  an information flow property 
stating that if two $SSQL$ states  are the same when viewed
at a particular classification then their
representations as $TSQL$ states when viewed as lists of derived tables
are also the same at that classification. 
The second is an information flow property
on the output filter.

\subsection{Errors Discovered During Proof Work}
One of the most important outcomes of the formal proof work carried 
out in phase II was the discovery of errors in the specifications
of \cite{DS/FMU/FEF/032} which model the query transformations
of \cite{trans}.  Initially, we identified the requirement of the 
critical property $OK\_TCâd$ on table computations and the associated 
$OK\_VCâd$ on value computations. Essentially $OK\_TCâd$ and $OK\_VCâd$
capture the required information flow
properties. However, we discovered during proof work
that the classification label which is output by the system could itself 
be a covert channel. It was necessary to strengthen  the requirements
on table and value computations; $OK\_TCâc$ and $OK\_VCâc$  were
introduced for this purpose. Further problems emerged as a 
result of strengthening the
requirements on table and value computations. In particular, the specifications
of  $Group$ and $AllTuples$ were changed to ensure that output clearances
were not a source of insecurity. 

In addition, an error in 
the specification of $Where$ of \cite{DS/FMU/FEF/032} was 
discovered during proof work. It was necessary to change
the specification so that the value computation
only used rows about whose existence the
client is  cleared to know. This ensures, for example, that
aggregate functions such as $COUNT(*)$ inside the $WHERE$ clause itself
are not a source of covert channels.

A fuller account of problems encountered
during proof work may be found in \cite{DS/FMU/FEF/002}.


\subsection{Phase II Partial Proof}
We now use the proof of $TableComputationsSecure$ together with the partial 
proof
from \cite{DS/FMU/FEF/031} of $EM\_SecureE$ to update $Theorem4$ of
\cite{DS/FMU/FEF/034} to give the
best partial proof of the overall system
security.
=SML
set_goal(
	[¨Architecture_SecureÆ,
	 ¨Subsys_SecureAÆ,
	 ¨Subsys_SecureBÆ,
	 ¨Subsys_SecureCÆ,
	 ¨Subsys_SecureDÆ,
	 ¨Viewât_secureEÆ,
	 ¨outputFilter_secureEÆ,
	 ¨Correct_Compile_OkSTPÆ],
				¨FE_SWORD_SYSTEM_secureÆ);
=TEX
=SML
a(strip_asm_tac EM_SecureE_thm THEN 
	asm_tac TableComputationsSecure_thm THEN 
	strip_asm_tac Theorem4);
val €Theorem5› = save_pop_thm "Theorem5";
=TEX
=GFT ProofPower output
Theorem5 = 
    Architecture_Secure,
    Subsys_SecureA,
    Subsys_SecureB,
    Subsys_SecureC,
    Subsys_SecureD,
    Viewât_secureE,
    outputFilter_secureE,
    Correct_Compile_OkSTP
  Ù FE_SWORD_SYSTEM_secure 
=TEX

\newpage
\HOLindexOff
\input{fef036th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}
