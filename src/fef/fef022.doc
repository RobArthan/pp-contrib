=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{SWORD Front End Architectural Model}  %% Mandatory field
\TPPref{DS/FMU/FEF/004}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.~D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{The first part of the formal specifications of a model
of the SWORD Front End for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\newpage

\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef,rdafef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}}) ] First draft.
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document gives a formal specification of part of the SWORD Front
End giving the high-level security properties required of both the
Query Transformations of \cite{trans} and of the Front End Filter of
\cite{filter}.  It constitutes deliverable D3 of work package 1a, as
given in the Phase 2 Technical Proposal, \cite{DS/FMU/017}.

\subsection{Introduction}

The Front End implementation of the SWORD database provides an
implementation of the secure query language, SSQL, \cite{specssql}, via
transformation into the target query language, TSQL, which is a modest
extension of the Standard Query Language, SQL. The SWORD Front End thus
provides a multi-level secure RDBMS in which both data and security
information are stored in a conventional DBMS system implementing
TSQL.

This document is intended to serve the following purposes:

\begin{itemize}
	\item to give a formal model in HOL of the overall architecture
	of the SWORD Front End, identifying its top-level subsystems
and their interconnection;
	\item to relate the architectural model to the formal
	specification of the {\em no flows down} security policy given
in \cite{DS/FMU/FEF/003};
	\item to identify the critical requirements on the top-level
subsystems, which, if met, are conjectured to ensure that the model of
the SWORD Front End satisfies the policy.  \end{itemize}


\subsection{Issues}

\section{PRELIMINARIES}
The following \Product{} instructions set the context for the proof
tools and set up the new theory $fef022$, with parent the theory
$fef006$ in which the SSQL Abstract Machine used to define the
semantics of SSQL is formalised.
=SML 
open_theory "fef006";
new_theory€"fef022"›;
push_pc "hol";
=TEX

\newpage
\section{ARCHITECTURAL MODEL}
In outline, the SWORD Front End operates as follows.  An SSQL query
supplied by a client is transformed by the Front End into a TSQL query
to perform the operation intended by the SSQL query, together with an
optional TSQL query to make certain security checks. The Front End
executes the check query, if any, on the conventional DBMS and uses the
response to determine whether the SSQL access is permitted. If the
access is permitted, then the other TSQL query is executed to select
data from, or to modify, the database. The results of a $SELECT$ query
are not returned directly to the user, since they may still include
data which the user is not cleared to see. Instead, the results are
passed through a filter process which overwrites any data that the
client may not see and it is the output of the filter which is returned
to the client. In some circumstances, the data returned to the client
may not be complete, in that there may be rows of data for which it is
not permitted for the client to evaluate the SSQL $WHERE$ clause; in
such cases, an additional advisory message is also returned to the user
indicating that the data may not be complete.

The construction of a behavioural model of the SWORD Front End which
follows is quite similar to the construction of the SSQL Abstract
Machine of \cite{DS/FMU/FEF/006}: a state-transition function for the
system is constructed from various components, an initial state is
defined, and then these two are combined to give a behavioural model of
the system as a whole. Both the initial state and the behavioural model
are parameterised by a function giving the representation of SSQL
Abstract Machine states as states of the TSQL DBMS.

\subsection{Transition Function Construction}

We choose to model the transition function by considering it to be made
up from four subsystems as follows:

\begin{itemize}
	\item The TSQL query processor of the conventional DBMS.
	\item An SSQL Transformation Processor for performing the
syntactic transformation of an SSQL query to give one or two TSQL
queries together with any additional parameters required by the other
components.
	\item An Output Filter for removing data which the client is
not allowed to see from the output of the TSQL DBMS and for deciding
whether the data may not be complete.
	\item A Check Function for testing the results of the optional
check query.
\end{itemize}

The DBMS is modelled using the following types, the first of which is
used in the types of the other components:

=SML
declare_type_abbrev(€"ANSWER"›, [],
	î Data LIST LIST ∏ ErrorsÆ);

declare_type_abbrev(€"DBMS_TYPE"›, ["'TSQL_QUERY", "'ST"],
	î ('TSQL_QUERY ∏ 'ST) ≠ ('ST ∏ ANSWER)Æ);
=TEX
Note that the data returned by the TSQL DBMS is taken to have the same
type as the data returned by the SSQL Abstract Machine of
\cite{DS/FMU/FEF/006}.  (This follows \cite{filter} and reflects the
close relationship between the TSQL and SSQL type systems.)

The remaining components are taken to have types as follows (in which
=INLINEFT
'TSQL_QUERY + ONE
=TEX
\ is the disjoint union of $'TSQL\_QUERY$ and a one-point type, i.e.,
an optional TSQL query).

=SML
declare_type_abbrev(€"STP_TYPE"›, ["'TSQL_QUERY", "'PARS"],
	î (Query ∏ Class) ≠ 'TSQL_QUERY ∏ ('TSQL_QUERY + ONE) ∏ 'PARS Æ);

declare_type_abbrev(€"FILTER_TYPE"›, ["'PARS"],
	î (Class ∏ ANSWER ∏ 'PARS) ≠ ANSWERÆ);

declare_type_abbrev(€"CHECK_TYPE"›, ["'PARS"],
	î ANSWER ∏ 'PARS ≠ ErrorsÆ);
=TEX
Note that the type of the SSQL Transformation Processor does not
involve the TSLQ state; this reflects the fact that, while it is
planned in the SWORD Front End implementation to store information
relating to the structure of the database in the TSQL DBMS, in the
model, it is assumed, as agreed, that the structure of the database is
fixed.

The transition function itself has the following type:
=SML
declare_type_abbrev(€"TF_TYPE"›, ["'ST"],
	î ((Query ∏ Class) ∏ 'ST) ≠ ('ST ∏ (Class ∏ ANSWER))Æ);
=TEX

The construction of the transition function from the four subsystems is
as follows:

πHOLCONST
‹	€mkTfât›	: ('TSQL_QUERY, 'ST) DBMS_TYPE
‹			≠ ('TSQL_QUERY, 'PARS) STP_TYPE
‹			≠ 'PARS FILTER_TYPE
‹			≠ 'PARS CHECK_TYPE
‹			≠ 'ST TF_TYPE
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ dbms stp filter check q c st∑
‹		mkTfât dbms stp filter check ((q, c), st)
‹	=	let	(dq, ocq, pars) = stp (q, c)
‹		in let	(st', errs) =
‹				if IsL ocq
‹				then	let (st', ans1) = dbms (OutL ocq, st)
‹					in (st', check (ans1, pars))
‹				else	(st, [])
‹		in	if errs = []
‹			then	let	(st'',ans2) = dbms (dq, st')
‹				in	(st'', (c, filter (c, ans2, pars)))
‹			else	(st', (c, [], errs))
∞


\subsection{Initial State}

In order to specify the initial state, and later to define the security
requirements on the subsystems, we need to have available a function to
map any state of the SSQL abstract machine of \cite{DS/FMU/FEF/006} to
the TSQL state which represents it.  The initial TSQL state is the
result of representing the initial SSQL state:

πHOLCONST
‹	€istateât› : (State ≠ 'ST) ≠ 'ST
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µrepr∑istateât repr = repr isstate
‹	
∞

\subsection{Behavioural Model}
The top-level structure of the Front End implementation of SWORD is
then captured in the following definition, which defines how subsystems
of the appropriate types are combined to make a behavioural model of
the system in the sense of the formal security policy of
\cite{DS/FMU/FEF/003}. Like the initial state, the model is
parameterised by the function representing SSQL states as TSQL states
in addition to the subsystems proper.


πHOLCONST
‹	€FE_SWORD›	: (State ≠ 'ST)
‹			≠ ('TSQL_QUERY, 'ST) DBMS_TYPE
‹			≠ ('TSQL_QUERY, 'PARS) STP_TYPE
‹			≠ 'PARS FILTER_TYPE
‹			≠ 'PARS CHECK_TYPE
‹			≠ (Query, ANSWER) BEHAVIOURS
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µrepr dbms stp filter check∑
‹		FE_SWORD repr dbms stp filter check
‹	=	behaviours (mkTfât dbms stp filter check, istateât repr)
∞

\section{Correctness Conjecture}

For a given representation function, $repr$, and subsystems, $dbms$,
$stp$, $filter$, and $check$, the security policy of
\cite{DS/FMU/FEF/003} applies directly:

=GFT
	?Ù	FE_SWORD repr dbms stp filter check ç secure
=TEX

But, of course, this places stringent requirements on the parameters to
$FE\_SWORD$. In order to formulate these requirements, we use the
$hide$ function of \cite{DS/FMU/FEF/005} and quantification over the
SSQL states to make the necessary assertions about information flow in
the TSQL states:

πHOLCONST
‹	€subsys_secure›	: (State ≠ 'ST)
‹			≠ (('TSQL_QUERY, 'ST) DBMS_TYPE
‹			∏  ('TSQL_QUERY, 'PARS) STP_TYPE
‹			∏  'PARS FILTER_TYPE
‹			∏  'PARS CHECK_TYPE ) SET
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹µrepr dbms stp filter check∑
‹	(dbms, stp, filter, check) ç subsys_secure repr
‹§	(µq c s∑ ∂â1s'∑ s' = Fst(mkTfât dbms stp filter check ((q, c), repr s)))
‹±
‹	(µq c s1 s2 s1' s2' d1 d2∑
‹		hide(c, s1) = hide(c, s2)
‹	±	(repr s1', d1) = mkTfât dbms stp filter check ((q, c), repr s1)
‹	±	(repr s2', d2) = mkTfât dbms stp filter check ((q, c), repr s2)
‹	¥	d1 = d2 ± hide(c, s1') = hide(c, s2'))
‹±
‹	(µq c1 c2 s' s d∑
‹		(repr s', d) = mkTfât dbms stp filter check ((q, c1), repr s)
‹	±	≥c2 dominates c1
‹	¥	hide(c2, s') = hide(c2, s))
∞

Informally, the above says that the components $dbms$, $stp$, $filter$
and $check$ are secure subsystems with respect to a given
representation function $repr$ provided the transition function which
$mkTf\sb{t}$ constructs from them has the following properties:
	{\em(a)} execution of a query preserves all the structural
constraints which allow a TSQL state to be viewed in a unique way as an
SSQL state;
	{\em(b)} execution of a query at clearance $c$ does not allow
information to flow from the parts of the state which are not visible
at clearance $c$ into the output or into parts of the state which are
visible at that clearance;
	{\em(c)} the effect on the state of executing a query at
clearance $c1$ is not visible at any clearance $c2$ which does not
dominate $c1$.

Clearly the first of the above three clauses only makes sense if $repr$
is 1-1. The space optimisations made in the transformations imply that
one cannot recover the SSQL state from the TSQL state alone, since, for
example, without knowledge of the structure of the SSQL table it
represents, one cannot tell whether the first column of a TSQL table
contains row existence classes, or column classes or data (according as
whether the row class, first column class or both are known to be
constant). It is assumed, therefore, that both the transformations and
the representation function will be defined using some loosely
specified, but constant, specification of the structure of the SSQL
state.



The correctness conjecture for the architectural model presented in
this document is then the following conjecture

=GFT
	?Ù	µrepr dbms stp filter check∑
			(dbms, stp, filter, check) ç subsys_secure repr
		¥	FE_SWORD repr dbms stp filter check ç secure
=TEX

=TEX
\section{CLOSING DOWN}
The following \Product{} instruction restores the previous proof context.
=SML
pop_pc();
=TEX

=SML
output_theory{theory = "fef022",out_file = "fef022th.doc"};
=TEX

\newpage
\HOLindexOff
\input{fef022th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex
=TEX
\end{document}





