=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{SWORD Front End Architectural Model}  %% Mandatory field
\TPPref{DS/FMU/FEF/022}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.~D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{The first part of the formal specifications of a model
of the SWORD Front End for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\newpage

\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue 1.2 ({\FormatDate{93/02/08}}) ] First draft.
\item[Issue \SCCSversion~({\FormatDate{$Date$
}}) ] Corrected after comments and further thought.
Check function removed, since the test is always that it returns
no rows. Subsystem security property reformulated so as not to
mention the construction function.
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document gives a formal specification of part of the SWORD Front
End giving the high-level security properties required of both the
Query Transformations of \cite{trans} and of the Front End Filter of
\cite{filter}.  It constitutes part of deliverable D3 of work package 1a, as
given in the Phase 2 Technical Proposal, \cite{DS/FMU/017}.

\subsection{Introduction}

The Front End implementation of the SWORD database provides an
implementation of the secure query language, SSQL, \cite{specssql}, via
transformation into the target query language, TSQL, which is a modest
extension of the Standard Query Language, SQL. The SWORD Front End thus
provides a multi-level secure RDBMS in which both data and security
information are stored in a conventional DBMS system implementing
TSQL.

This document is intended to serve the following purposes:

\begin{itemize}
	\item to give a formal model in HOL of the overall architecture
	of the SWORD Front End, identifying its top-level subsystems
and their interconnection;
	\item to relate the architectural model to the formal
	specification of the {\em no flows down} security policy given
in \cite{DS/FMU/FEF/003};
	\item to identify the critical requirements on the top-level
subsystems, which, if met, are conjectured to ensure that the model of
the SWORD Front End satisfies the policy.  \end{itemize}


\section{PRELIMINARIES}
The following \Product{} instructions set the context for the proof
tools and set up the new theory $fef022$, with parent the theory
$fef006$ in which the SSQL Abstract Machine used to define the
semantics of SSQL is formalised.
=SML 
open_theory "fef006";
new_theory€"fef022"›;
push_pc "hol";
=TEX

\newpage
\section{ARCHITECTURAL MODEL}
In outline, the SWORD Front End operates as follows.  An SSQL query
supplied by a client is transformed by the Front End into a TSQL query
to perform the operation intended by the SSQL query, together with an
optional TSQL query to make certain security checks. The Front End
executes the check query, if any, on the conventional DBMS and uses the
response to determine whether the SSQL access is permitted (the check
query is always a $SELECT$ query which returns an empty table
if the access is permitted). If the
access is permitted, then the other TSQL query is executed to select
data from, or to modify, the database. The results of a $SELECT$ query
are not returned directly to the user, since they may still include
data which the user is not cleared to see. Instead, the results are
passed through a filter process which overwrites any data that the
client may not see and it is the output of the filter which is returned
to the client. In some circumstances, the data returned to the client
may not be complete, in that there may be rows of data for which it is
not permitted for the client to evaluate the SSQL $WHERE$ clause; in
such cases, an additional advisory message is also returned to the user
indicating that the data may not be complete.

The construction of a behavioural model of the SWORD Front End which
follows is quite similar to the construction of the SSQL Abstract
Machine of \cite{DS/FMU/FEF/006}: a state-transition function for the
system is constructed from various components, an initial state is
defined, and then these two are combined to give a behavioural model of
the system as a whole. Both the initial state and the behavioural model
are parameterised by a function giving the representation of SSQL
Abstract Machine states as states of the TSQL DBMS.

\subsection{Transition Function Construction}

We choose to model the transition function by considering it to be made
up from three subsystems as follows:

\begin{itemize}
	\item The TSQL query processor of the conventional DBMS.
	\item An SSQL Transformation Processor for performing the
syntactic transformation of an SSQL query to give one or two TSQL
queries together with any additional parameters required by the other
components.
	\item An Output Filter for removing data which the client is
not allowed to see from the output of the TSQL DBMS and for deciding
whether the data may not be complete.
\end{itemize}

The DBMS is modelled using the following types, the first of which is
used in the types of the other components:

=SML
declare_type_abbrev(€"ANSWER"›, [],
	î Data LIST LIST ∏ ErrorsÆ);

declare_type_abbrev(€"DBMS_TYPE"›, ["'TSQL_QUERY", "'ST"],
	î ('TSQL_QUERY ∏ 'ST) ≠ ('ST ∏ ANSWER)Æ);
=TEX
Note that the data returned by the TSQL DBMS is taken to have the same
type as the data returned by the SSQL Abstract Machine of
\cite{DS/FMU/FEF/006}.  (This follows \cite{filter} and reflects the
close relationship between the TSQL and SSQL type systems.)

The remaining components are taken to have types as follows (in which
=INLINEFT
'TSQL_QUERY + ONE
=TEX
\ is the disjoint union of $'TSQL\_QUERY$ and a one-point type, i.e.,
an optional TSQL query).

=SML
declare_type_abbrev(€"STP_TYPE"›, ["'TSQL_QUERY", "'PARS"],
	î (Query ∏ Class) ≠ 'TSQL_QUERY ∏ ('TSQL_QUERY + ONE) ∏ 'PARS Æ);

declare_type_abbrev(€"FILTER_TYPE"›, ["'PARS"],
	î (Class ∏ ANSWER ∏ 'PARS) ≠ ANSWERÆ);
=TEX
Note that the type of the SSQL Transformation Processor means that its
effect does not depend upon TSQL state;
this reflects the fact that, while it is planned in the SWORD Front End
implementation to store information
relating to the structure of the database in the TSQL DBMS, in the
model, it is assumed that the structure of the database is
fixed.

The transition function itself has the following type:
=SML
declare_type_abbrev(€"TF_TYPE"›, ["'ST"],
	î ((Query ∏ Class) ∏ 'ST) ≠ ('ST ∏ (Class ∏ ANSWER))Æ);
=TEX

The construction of the transition function from the four subsystems is
as follows:

πHOLCONST
‹	€mkTfât›	: ('TSQL_QUERY, 'ST) DBMS_TYPE
‹			≠ ('TSQL_QUERY, 'PARS) STP_TYPE
‹			≠ 'PARS FILTER_TYPE
‹			≠ 'ST TF_TYPE
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ dbms stp filter q c st∑
‹		mkTfât dbms stp filter ((q, c), st)
‹	=	let	(dq, ocq, pars) = stp (q, c)
‹		in let	(st', (cks, errs)) =
‹				if IsL ocq
‹				then	dbms (OutL ocq, st)
‹				else	(st, ([], []))
‹		in	if cks = [] ± errs = [] 
‹			then	let	(st'',ans2) = dbms (dq, st')
‹				in	(st'', (c, filter (c, ans2, pars)))
‹			else	(st', (c, [], [notCleared]))
∞


\subsection{Initial State}

In order to specify the initial state, and later to define the security
requirements on the subsystems, we need to have available a function to
map any state of the SSQL abstract machine of \cite{DS/FMU/FEF/006} to
the TSQL state which represents it.  The initial TSQL state is the
result of representing the initial SSQL state.

πHOLCONST
‹	€istateât› : (State ≠ 'ST) ≠ 'ST
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µrepr∑istateât repr = repr isstate
‹	
∞

(The initial state is presented in this way, rather than just by using
$repr\,isstate$ in the behavioural model, to emphasise the analogy between
the construction of the Front End Implementation model and the SSQL
abstract machine.)
\subsection{Behavioural Model}
The top-level structure of the Front End implementation of SWORD is
then captured in the following definition, which defines how subsystems
of the appropriate types are combined to make a behavioural model of
the system in the sense of the formal security policy of
\cite{DS/FMU/FEF/003}. Like the initial state, the model is
parameterised by the function representing SSQL states as TSQL states
in addition to the subsystems proper.


πHOLCONST
‹	€FE_SWORD›	: (State ≠ 'ST)
‹			≠ ('TSQL_QUERY, 'ST) DBMS_TYPE
‹			≠ ('TSQL_QUERY, 'PARS) STP_TYPE
‹			≠ 'PARS FILTER_TYPE
‹			≠ (Query, ANSWER) BEHAVIOURS
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µrepr dbms stp filter∑
‹		FE_SWORD repr dbms stp filter
‹	=	behaviours (mkTfât dbms stp filter, istateât repr)
∞

\section{Subsystem Correctness Conjecture}\label{SubsystemCorrectness}

For a given representation function, $repr$, and subsystems, $dbms$,
$stp$, $filter$, and $check$, the security policy of
\cite{DS/FMU/FEF/003} applies directly:

=GFT
	?Ù	FE_SWORD repr dbms stp filter check ç secure
=TEX

But, of course, this places stringent requirements on the parameters to
$FE\_SWORD$. In order to formulate these requirements, we use the
$hide$ function of \cite{DS/FMU/FEF/005} and quantification over the
SSQL states to make the necessary assertions about information flow in
the TSQL states. Of necessity, at the level of abstraction taken
so far in this document, it is only possible to make these assertions
as properties of the three subsystems taken together. The following
formulation has been derived by attempting to
give necessary conditions on the results of the SSQL Transformation
Processor to ensure that a secure system results for a given DBMS and
filter operation. As with the initial state and behavioural model,
the assertion is parameterised by the represention function, $repr$.

πHOLCONST
‹	€subsys_secure›	: (State ≠ 'ST)
‹			≠ (('TSQL_QUERY, 'ST) DBMS_TYPE
‹			∏  ('TSQL_QUERY, 'PARS) STP_TYPE
‹			∏  'PARS FILTER_TYPE) SET
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹µrepr dbms stp filter∑
‹	(dbms, stp, filter) ç subsys_secure repr
‹§	µq c∑
‹	let	(dq, ocq, pars) = stp(q, c)
‹	in let	check st =
‹			if	IsL ocq
‹			then	let	(cks, errs) = Snd(dbms(OutL ocq, st))
‹				in	≥errs = [] ± cks = []
‹			else	T
‹	in
‹(*A*)		(µs∑ ∂â1s'∑ check (repr s) ¥ repr s' = Fst(dbms(dq, repr s)))
‹
‹(*B*)	±	(µstâ1∑	IsL ocq
‹		¥	let	(stâ2, (cks, errs)) = dbms(OutL ocq, stâ1)
‹			in	stâ2 = stâ1 ± errs = [])
‹
‹(*C*)	±	(µc' s' s d∑
‹			(repr s', d) = dbms(dq, repr s)
‹		±	≥hide(c', s) = hide(c', s')
‹		±	≥c' dominates c
‹		¥	≥check(repr s))
‹
‹(*D*)	±	(µc' sâ1 sâ2 sâ1' sâ2' dâ1 dâ2∑
‹			hide(c, sâ1) = hide(c, sâ2)
‹		±	(repr sâ1', dâ1) = dbms(dq, repr sâ1)
‹		±	(repr sâ2', dâ2) = dbms(dq, repr sâ2)
‹		±	c' dominates c
‹		±	≥hide(c', sâ1') = hide(c', sâ2')
‹		¥	≥check(repr sâ1))
‹
‹(*E*)	±	(µsâ1 sâ2 sâ1' sâ2' dâ1 dâ2∑
‹			hide(c, sâ1) = hide(c, sâ2)
‹		±	(repr sâ1', dâ1) = dbms(dq, repr sâ1)
‹		±	(repr sâ2', dâ2) = dbms(dq, repr sâ2)
‹		±	≥filter(c, dâ1, pars) = filter(c, dâ2, pars)
‹		¥	≥check(repr sâ1))
∞

Informally, the above says that the components $dbms$, $stp$ and $filter$
are secure subsystems with respect to a given
representation function $repr$
if the data query, $dq$, optional check query, $ocq$ and parameters,
$pars$ returned by $stp$ for any query, $q$, at any clearance, $c$, have the
following properties (where we say that ``the check succeeds for a state''
if there is no query in $ocq$ or if there is but its execution gives an
empty table):

\begin{description}
\item{$A$}
Execution of $dq$ on any state for which the check succeeds
preserves all the structural
constraints which allow a TSQL state to be viewed in a unique way as an
SSQL state;
\item{$B$}
If there is a query in $dcq$ then its execution does not change the
state (i.e., it is a $SELECT$ query) and gives rise to no errors;
\item{$C$}
If for some clearance $c'$, execution of $dq$ changes the state
in a way which is visible at clearance $c'$, and $c'$ does not dominate
$c$, then the check must not succeed;
\item{$D$}
If the states resulting from execution of $dq$
reveal a distinction which a client at clearance $c'$,
dominating $c$, is not allowed then the check must not succeed.
\item{$E$}
If the output resulting from execution of $dq$ reveal a distinction
which a client at clearance $c$ is not allowed to see between two states,
then the check must not succeed.
\end{description}

Clearly clause $A$ makes little sense unless $repr$
is 1-1. The space optimisations made in the transformations imply that
one cannot recover the SSQL state from the TSQL state alone, since, for
example, without knowledge of the structure of the SSQL table it
represents, one cannot tell whether the first column of a TSQL table
contains row existence classes, or column classes or data (according as
whether the row class, first column class or both are known to be
constant). It is assumed, therefore, that both the transformations and
the representation function will be defined using some loosely
specified, but constant, specification of the structure of the SSQL
state (essentially, the structure implicit in the loosely defined
initial abstract state, $isstate$, of \cite{DS/FMU/FEF/006}).

Clauses $C$, $D$ and $E$ correspond to clauses $1$, $2$ and $3$
of the $4$ clauses of the relation
$secureUpdate$ of \cite{DS/FMU/FEF/007}, which captures the
security properties on the relationship between the $hide$ and $updateState$
components of the SSQL Abstract Machine.
Clause $4$ of $secureUpdate$ just says that the client clearance is
faithfully passed on from the input to the output, and is ensured by
the definition of $mkTf\sb{t}$.

The correctness conjecture for the architectural model presented in
this document is then the following conjecture

=GFT
	?Ù	µrepr dbms stp filter check∑
			(dbms, stp, filter, check) ç subsys_secure repr
		¥	FE_SWORD repr dbms stp filter check ç secure
=TEX
\section{CLOSING DOWN}
The following \Product{} instruction restores the previous proof context.
=SML
pop_pc();
=TEX

=SML
output_theory{theory = "fef022",out_file = "fef022th.doc"};
=TEX

\newpage
\HOLindexOff
\input{fef022th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex
=TEX
\end{document}





