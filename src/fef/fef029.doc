=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Specification of Query Transformations in HOL (II)}  %% Mandatory field
\TPPref{DS/FMU/FEF/020}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{A specification of the SSQL Query Transformations in HOL for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}})]  First draft
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document gives a formal specification in HOL (\cite{milner90}, \cite{paulson91}) of the SSQL query transformations of \cite{trans}. It constitutes part of
 deliverable D11 of work package 3, as given
in the Proposal for Phase~2, \cite{DS/FMU/FEF/018}.

The current version of this document is a partial draft intended to indicate
the flavour of what can be done in this area. In particular, the main
mutually recursive functions which perform the transformations are currently
in vestigial form, since their structure is heavily dependent on the
SSQL syntax and so it is felt best to defer their formalisation in HOL until
the SSQL syntax definitions \cite{DS/FMU/FEF/014} have been brought into
line with the most recent specification of SSQL.

\subsection{Introduction}
We provide HOL specifications of the
SSQL query transformations of \cite{trans}. Preliminary
material needed
 to support these query
transformation specifications may be found in \cite{DS/FMU/FEF/028}.

\subsection{ProofPower Preamble}
The following commands initialise the ProofPower system to accept
the specifications:
=SML
open_theory"fef028";
new_theoryÛ"fef029"İ;
set_pc"hol";
=TEX
\section{THE TRANSFORMATIONS}
The following error values are required in addition to those introduced
in \cite{DS/FMU/FEF/004}.

¹HOLCONST
ÜÛinternalErrorİ		ÛwrongWorthİ			ÛnotTriggerİ
ÜÛonlyInTriggersİ		ÛnotMonadicİ			ÛnotDyadicİ
ÜÛnotTriadicİ			ÛnotSetFunctionİ		ÛnoSuchParameterİ
ÜÛnoScopeİ			ÛwrongScopeİ			ÛambiguousNameİ
ÜÛemptyUnionListİ		:				Error
÷üüüüüüüüüüüüüüüüüüüüüüü
Ü	true
°

=TEX
\subsection{Incompletely Specified Transformations}
Some functions have not been specified in \cite{trans}.
They are loosely defined here. Some of them depend on the state of
the transformation process, this is modelled by the following labelled
product type. Of the four components of the state, only the first,
the symbol table stack, varies during the transformation, the other components
simply record information supplied as parameters to the overall transformation
process. The projection functions for these parameter components serve
for the functions of the same name from \cite{DS/FMU/FEF/028,trans}.

¹HOLLABPROD ÛTRANS_STATEİüüüüüüüüüüüüüüüüü
Ü	st_stack			: ST_STACK;
Ü	query_class			: Class;
Ü	query_constants_class		: Class;
Ü	client_clearance		: Class
°üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
¹HOLCONST
Ü	Ûcheck_enumİ : Enum ¸ Int ¸ Table_spec ­ BOOL;
Ü	Ûcheck_fixedİ : Fixed ¸ Int ¸ Int ­ BOOL;
Ü	Ûcheck_floatingİ : Float ¸ Int ¸ Int ¸ Int ­ BOOL;
Ü	Ûcheck_intervalİ : Interval ¸ STRING ­ BOOL;
Ü	Ûcheck_timeİ : Time ¸ STRING ­ BOOL;
Ü	ÛtimeFormatToIntervalİ : STRING ­ STRING;
Ü	Ûunique_nameİ : TRANS_STATE ­ STRING;
Ü	Ûcontextual_dataİ : STRING ­ Value ¸ Class;
Ü	Ûdefault_directoryİ : STRING LIST
÷üüüüüüüüüüüüüüüü
Ü	true
°
=TEX
Notes:

\begin{enumerate}
\item $check\_enum$ is, presumably, parameterised by the structure
{\em and content} of the database. The above parameterisation is therefore
not very realistic, since it only permits dependence on the structure of
the database (presumed fixed), not its contents.
\item $unique\_name$ parameterised as above could only produce names which
were unique within the current symbol-table scope, not within the entire
transformation process.
\end{enumerate}

We need a function to set up an initial state based on the client clearance:

¹HOLCONST
Ü	init_trans_state: Class ­ TRANS_STATE
÷üüüüüüüüüüüüü
Üµc·	init_trans_state c =
Ü	MkTRANS_STATE
Ü	(MkST_STACK [] [])
Ü	c
Ü	c
Ü	c
°


\subsection{Symbol Table Model}
¹HOLCONST
Ü	Ûfind‰c‰o‰l‰u‰m‰nİ : ColumnSpecification ¸ TableDetail LIST ­
Ü					(TableDetail ¸ SsqlCol ¸ TsqlCol)LIST
÷üüüüüüüüüüüüüüüüüüüüüüüüüüü
Üµcs tdl·
Ü	find‰c‰o‰l‰u‰m‰n(cs,tdl) =
Ü	let	look (n, td, scl, tcl) =
Ü		let  sctcl = splice scl tcl
Ü		in let sctcl' = sctcl ù {(sc, tc) | sc_name sc = mk_name‰s n}
Ü		in Map (Ì(sc, tc)· (td, sc, tc)) sctcl'
Ü	in let	do1td td =
Ü		CASE cs [
Ü		WHEN_anonymous_column col·
Ü			look(col, td, td_columns td, td_implementation td);
Ü		WHEN_specific (ts, col)·
Ü			CASE (td_tableName td) [
Ü			WHEN_name‰t‰n ts·
Ü				look(col, td, td_columns td, td_implementation td);
Ü			OTHERS []
Ü			]
Ü		]
Ü	in	Flat(Map do1td tdl)
°
=TEX
¹HOLCONST
Ü	Ûfind‰i‰d‰e‰n‰tİ : ColumnSpecification ¸ IdentDetail LIST ­
Ü					IdentDetail LIST
÷üüüüüüüüüüüüüüüüüüüüüüüüüüü
Üµcs idl·
Ü	find‰i‰d‰e‰n‰t (cs, idl) =
Ü	CASE cs [
Ü	WHEN_specific (t, c)· [];
Ü	WHEN_anonymous_column col·
Ü		idl ù {id | col = id_identName id}
Ü	]
°
=TEX
We replace the function $look$, which is private to $lookup\sb{column\_info}$
in \cite{DS/FMU/FEF/029,trans} by a top-level function,
$lookup\_column\_info\_look$ (since it is recursive and HOL local functions
cannot be recursive).
¹HOLCONST
Ü 	Ûlookup_column_info_lookİ :
Ü		ColumnSpecification  ¸ Scope LIST ­ (TableInfo ¸ SsqlCol)RESULT
÷üüüüüüüüüüüüüüüüüüüüüüü
Üµcs ti outer·
Ü	lookup_column_info_look (cs, []) = Exception [noSuchColumn]
Ü±	lookup_column_info_look (cs, outer ë [ti]) =
Ü	let	t = s_tables ti
Ü	in let	tdsctcl = find‰c‰o‰l‰u‰m‰n(cs, t)
Ü	in	if	tdsctcl = []
Ü		then	lookup_column_info_look (cs, outer)
Ü		else if	Tl(tdsctcl) = []
Ü		then	let (td, sc, tc) = Hd tdsctcl in Ok(td_info td, sc)
Ü		else	Exception [ambiguousName]
°
¹HOLCONST
Ü 	Ûlookup‰c‰o‰l‰u‰m‰n‰i‰n‰f‰oİ :
Ü	TRANS_STATE ­ ColumnSpecification ­ (TableInfo ¸ SsqlCol)RESULT
÷üüüüüüüüüüüüüüüüüüüüüüü
Üµst cs·	lookup‰c‰o‰l‰u‰m‰n‰i‰n‰f‰o st cs =
Ü		lookup_column_info_look (cs, symbolTable(st_stack st))
°
=TEX
¹HOLCONST
Ü	ÛmaxBoundİ : BoundInfo ­ Class
÷üüüüüüüüüüü
Üµc·	maxBound c =
Ü	CASE c [
Ü	WHEN_upb c· c;
Ü	WHEN_constant c· c
Ü	]
°
=TEX
¹HOLCONST
Ü	Ûinnermostİ : Scope LIST ­ Scope LIST
÷üüüüüüüüüüüü
Üµouter inner·
Ü	innermost [] = []
Ü±	innermost (outer ë [inner]) =
Ü	let tds = s_tables inner
Ü	in	if	tds = []
Ü		then	innermost outer ë [inner]
Ü		else	[inner]
°
As with $lookup\sb{column\_info}$, we replace the recursive
function $look$ local to $lookup\sb{col\_info}$
by a top-level function $look\_up\_col\_spec\_class\_look$.
The comments before the $then$s below show the corresponding ML pattern match
(cf. \cite{DS/FMU/FEF/020}).
¹HOLCONST
Ü	Ûlookup_col_spec_class_lookİ
Ü		: ColumnSpecification  ¸ Scope LIST ­ (TsqlRepr ¸ Class) RESULT
÷üüüüüüüüüüüüüüüü
Üµ cs outer ti·
Ü	lookup_col_spec_class_look(cs,[]) = Exception [noSuchColumn]
Ü±	lookup_col_spec_class_look(cs, outer ë [ti]) = 	
Ü	let	(t, i) = (s_tables ti, s_identifiers ti)
Ü	in let	cds = find‰c‰o‰l‰u‰m‰n(cs,t)
Ü	and	ids = find‰i‰d‰e‰n‰t(cs,i)
Ü	in 	if	ids = []
Ü		then	if	cds = []
Ü(* ([], []) *)		then	lookup_col_spec_class_look(cs, outer)
Ü			else	if	Tl cds = []
Ü(* ([(td,sc,tc)], []) *)	then 	let	(td, sc, tc) = Hd cds
Ü					in let	u = maxBound (sc_col_class sc)
Ü					in	CASE (tc_class_name tc) [
Ü						WHEN_anon‰t‰c
Ü							(Exception[internalError]);
Ü						WHEN_name‰t‰c s·
Ü							Ok(mk_column(td_genCorr td, s), u);
Ü						WHEN_constant‰t‰c c·
Ü							Ok(mk_constant_class c,u)
Ü						]
Ü(* (xs, []) *)				else	Exception [ambiguousName]
Ü		else	if	cds = [] ± Tl ids = []
Ü(* ([], [id]) *)	then	let	id = Hd ids
Ü				in let	cl = id_lub‰i‰d id
Ü				in	CASE (id_cName id) [
Ü					WHEN_none‰t (Ok(mk_constant_class cl, cl));
Ü					WHEN_anon‰t (Exception[internalError]);
Ü					WHEN_name‰t s·Ok(mk_local_identifier s, cl)
Ü					]
Ü(* (xs, ys) *)		else	Exception [ambiguousName]
°
¹HOLCONST
Ü	Ûlookup‰c‰o‰l‰s‰p‰e‰c‰c‰l‰a‰s‰sİ :
Ü		TRANS_STATE ­ (BOOL ¸ ColumnSpecification) ­ (TsqlRepr ¸ Class)RESULT
÷üüüüüüüüüüüüü
Üµst flg cs·
Ü	lookup‰c‰o‰l‰s‰p‰e‰c‰c‰l‰a‰s‰s st (flg, cs) =
Ü	if	flg
Ü	then	lookup_col_spec_class_look(cs, innermost(symbolTable(st_stack st)))
Ü	else	lookup_col_spec_class_look(cs, (symbolTable(st_stack st)))
°
=TEX
{\it Mutatatis mutandis},
the remarks about $lookup\_col\_spec\_class\_look$ above apply both to
to $lookup\_col\_spec\_dinary\_look$, and to
$lookup\_col\_spec\_sterling\_look$ below.
¹HOLCONST
Ü	Ûlookup_col_spec_dinary_lookİ
Ü		: ColumnSpecification  ¸ Scope LIST ­ TsqlRepr RESULT
÷üüüüüüüüüüüüüüüü
Üµ cs outer ti·
Ü	lookup_col_spec_dinary_look(cs,[]) = Exception [noSuchColumn]
Ü±	lookup_col_spec_dinary_look(cs, outer ë [ti]) = 	
Ü	let	(t, i) = (s_tables ti, s_identifiers ti)
Ü	in let	cds = find‰c‰o‰l‰u‰m‰n(cs,t)
Ü	and	ids = find‰i‰d‰e‰n‰t(cs,i)
Ü	in 	if	ids = []
Ü		then	if	cds = []
Ü(* ([], []) *)		then	lookup_col_spec_dinary_look(cs, outer)
Ü			else	if	Tl cds = []
Ü(* ([(td,sc,tc)], []) *)	then 	let	(td, sc, tc) = Hd cds
Ü					in	CASE (tc_dinary_name tc) [
Ü						WHEN_none‰t
Ü							(Exception[internalError]);
Ü						WHEN_anon‰t
Ü							(Exception[internalError]);
Ü						WHEN_name‰t s·
Ü							Ok(mk_column(td_genCorr td, s))
Ü						]
Ü(* (xs, []) *)				else	Exception [ambiguousName]
Ü		else	if	cds = [] ± Tl ids = []
Ü(* ([], [id]) *)	then	let	id = Hd ids
Ü				in let	(st, w) = id_info id
Ü				in	if	w = dinary
Ü					then	Ok(mk_local_identifier(id_vName id))
Ü					else	Ok(c_constant_null)
Ü(* (xs, ys) *)		else	Exception [ambiguousName]
°
=TEX
¹HOLCONST
Ü	Ûlookup‰c‰o‰l‰s‰p‰e‰c‰d‰i‰n‰a‰r‰yİ :
Ü		TRANS_STATE ­ (BOOL ¸ ColumnSpecification) ­ TsqlRepr RESULT
÷üüüüüüüüüüüüü
Üµst flg cs·
Ü	lookup‰c‰o‰l‰s‰p‰e‰c‰d‰i‰n‰a‰r‰y st (flg, cs) =
Ü	if	flg
Ü	then	lookup_col_spec_dinary_look(cs, innermost(symbolTable(st_stack st)))
Ü	else	lookup_col_spec_dinary_look(cs, (symbolTable(st_stack st)))
°
¹HOLCONST
Ü	Ûlookup_col_spec_sterling_lookİ
Ü		: ColumnSpecification  ¸ Scope LIST ­ TsqlRepr RESULT
÷üüüüüüüüüüüüüüüü
Üµ cs outer ti·
Ü	lookup_col_spec_sterling_look(cs,[]) = Exception [noSuchColumn]
Ü±	lookup_col_spec_sterling_look(cs, outer ë [ti]) = 	
Ü	let	(t, i) = (s_tables ti, s_identifiers ti)
Ü	in let	cds = find‰c‰o‰l‰u‰m‰n(cs,t)
Ü	and	ids = find‰i‰d‰e‰n‰t(cs,i)
Ü	in 	if	ids = []
Ü		then	if	cds = []
Ü(* ([], []) *)		then	lookup_col_spec_sterling_look(cs, outer)
Ü			else	if	Tl cds = []
Ü(* ([(td,sc,tc)], []) *)	then 	let	(td, sc, tc) = Hd cds
Ü					in	CASE (tc_sterling_name tc) [
Ü						WHEN_none‰t
Ü							(Exception[internalError]);
Ü						WHEN_anon‰t
Ü							(Exception[internalError]);
Ü						WHEN_name‰t s·
Ü							Ok(mk_column(td_genCorr td, s))
Ü						]
Ü(* (xs, []) *)				else	Exception [ambiguousName]
Ü		else	if	cds = [] ± Tl ids = []
Ü(* ([], [id]) *)	then	let	id = Hd ids
Ü				in let	(st, w) = id_info id
Ü				in	if	w = sterling
Ü					then	Ok(mk_local_identifier(id_vName id))
Ü					else	Ok(c_constant_null)
Ü(* (xs, ys) *)		else	Exception [ambiguousName]
°
=TEX
¹HOLCONST
Ü	Ûlookup‰c‰o‰l‰s‰p‰e‰c‰s‰t‰e‰r‰l‰i‰n‰gİ :
Ü		TRANS_STATE ­ (BOOL ¸ ColumnSpecification) ­ TsqlRepr RESULT
÷üüüüüüüüüüüüü
Üµst flg cs·
Ü	lookup‰c‰o‰l‰s‰p‰e‰c‰s‰t‰e‰r‰l‰i‰n‰g st (flg, cs) =
Ü	if	flg
Ü	then	lookup_col_spec_sterling_look(cs, innermost(symbolTable(st_stack st)))
Ü	else	lookup_col_spec_sterling_look(cs, (symbolTable(st_stack st)))
°
=TEX
¹HOLCONST
Ü	Ûlookup‰l‰o‰c‰a‰l‰c‰o‰l‰i‰m‰p‰l‰e‰m‰e‰n‰t‰a‰t‰i‰o‰nİ
Ü		: TRANS_STATE ­ TsqlCol LIST RESULT
÷üüüüüüüüüüüüüüüüüüü
Üµ st· lookup‰l‰o‰c‰a‰l‰c‰o‰l‰i‰m‰p‰l‰e‰m‰e‰n‰t‰a‰t‰i‰o‰n st =
Ü	let	extract_implementation sc =
Ü		Fold ($ë) (Map td_implementation (s_tables sc)) []
Ü	in let	trs =
Ü		Fold ($ë)
Ü		(Map extract_implementation (innermost(symbolTable(st_stack st))))[]
Ü	in	if	trs = []
Ü		then	Exception[noScope]
Ü		else	Ok trs
°
=TEX
¹HOLCONST
Ü	Ûlookup‰l‰o‰c‰a‰l‰c‰o‰l‰i‰n‰f‰oİ
Ü		: TRANS_STATE ­ SsqlCol LIST RESULT
÷üüüüüüüüüüüüüüüüüüü
Üµ st· lookup‰l‰o‰c‰a‰l‰c‰o‰l‰i‰n‰f‰o st =
Ü	let	extract_columns sc =
Ü		Fold ($ë) (Map td_columns (s_tables sc)) []
Ü	in let	trs =
Ü		Fold ($ë)
Ü		(Map extract_columns (innermost(symbolTable(st_stack st))))[]
Ü	in	if	trs = []
Ü		then	Exception[noScope]
Ü		else	Ok trs
°
=TEX
¹HOLCONST
Ü	Ûlookup‰l‰o‰c‰a‰l‰c‰o‰l‰s‰p‰e‰c‰c‰l‰a‰s‰s‰e‰sİ
Ü		: TRANS_STATE ­ (TsqlRepr ¸ Class) LIST RESULT
÷üüüüüüüüüüüüüüüüüüü
Üµ st· lookup‰l‰o‰c‰a‰l‰c‰o‰l‰s‰p‰e‰c‰c‰l‰a‰s‰s‰e‰s st =
Ü	let	look2(corr,sc,tc) =
Ü		let	u = maxBound(sc_col_class sc)
Ü		in	CASE (tc_class_name tc) [
Ü			WHEN_anon‰t‰c (Exception[internalError]);
Ü			WHEN_name‰t‰c s· Ok(mk_column(corr, s), u);
Ü			WHEN_constant‰t‰c c· Ok(mk_constant_class c,u)
Ü			]
Ü	in let	look1 td = at3 (Map look2)
Ü			(seq (Length (td_columns td)) (td_genCorr td),
Ü				td_columns td, td_implementation td)
Ü	in let	look sc = Fold ($ë) (Map look1 (s_tables sc)) []
Ü	in let	trs =
Ü		Fold ($ë) (Map look (innermost(symbolTable(st_stack st))))[]
Ü	in	if	trs = []
Ü		then	Exception[noScope]
Ü		else	ListOk trs
°
=TEX
¹HOLCONST
Ü	Ûlookup‰l‰o‰c‰a‰l‰c‰o‰l‰s‰p‰e‰c‰s‰t‰e‰r‰l‰i‰n‰g‰sİ
Ü		: TRANS_STATE ­ TsqlRepr LIST RESULT
÷üüüüüüüüüüüüüüüüüüü
Üµ st· lookup‰l‰o‰c‰a‰l‰c‰o‰l‰s‰p‰e‰c‰s‰t‰e‰r‰l‰i‰n‰g‰s st =
Ü	let	look2(corr,tc) =
Ü		CASE (tc_sterling_name tc) [
Ü		WHEN_none‰t (Ok c_constant_null);
Ü		WHEN_anon‰t (Exception[internalError]);
Ü		WHEN_name‰t s· Ok(mk_column(corr, s))
Ü		]
Ü	in let	look1 td = at2 (Map look2)
Ü			(seq (Length (td_columns td)) (td_genCorr td),
Ü				td_implementation td)
Ü	in let	look sc = Fold ($ë) (Map look1 (s_tables sc)) []
Ü	in let	trs =
Ü		Fold ($ë) (Map look (innermost(symbolTable(st_stack st))))[]
Ü	in	if	trs = []
Ü		then	Exception[noScope]
Ü		else	ListOk trs
°
=TEX
¹HOLCONST
Ü	Ûlookup‰l‰o‰c‰a‰l‰r‰o‰w‰c‰l‰a‰s‰s‰e‰sİ
Ü		: TRANS_STATE ­ TsqlRepr LIST RESULT
÷üüüüüüüüüüüüüüüüüüü
Üµ st· lookup‰l‰o‰c‰a‰l‰r‰o‰w‰c‰l‰a‰s‰s‰e‰s st =
Ü	let	look1 td =
Ü		CASE (td_rowClass td) [
Ü		WHEN_anon‰t‰c (Exception[internalError]);
Ü		WHEN_name‰t‰c s· Ok(mk_column(td_genCorr td, s));
Ü		WHEN_constant‰t‰c c· Ok(mk_constant_class c)
Ü		]
Ü	in let	look sc = Map look1 (s_tables sc)
Ü	in let	trs =
Ü		Fold ($ë) (Map look (innermost(symbolTable(st_stack st))))[]
Ü	in	if	trs = []
Ü		then	Exception[noScope]
Ü		else	ListOk trs
°
=TEX
Again {\it mutatatis mutandis},
the remarks about $lookup\_col\_spec\_class\_look$ above apply to
to the following.
¹HOLCONST
Ü	Ûlookup_column_row_class_lookİ
Ü		: TRANS_STATE ­ ColumnSpecification  ¸ Scope LIST ­ TsqlRepr RESULT
÷üüüüüüüüüüüüüüüü
Üµ st cs outer ti·
Ü	lookup_column_row_class_look st (cs,[]) = Exception [noSuchColumn]
Ü±	lookup_column_row_class_look st (cs, outer ë [ti]) = 	
Ü	let	(t, i) = (s_tables ti, s_identifiers ti)
Ü	in let	cds = find‰c‰o‰l‰u‰m‰n(cs,t)
Ü	and	ids = find‰i‰d‰e‰n‰t(cs,i)
Ü	in 	if	ids = []
Ü		then	if	cds = []
Ü(* ([], []) *)		then	lookup_column_row_class_look st (cs, outer)
Ü			else	if	Tl cds = []
Ü(* ([(td,sc,tc)], []) *)	then 	let	(td, sc, tc) = Hd cds
Ü					in	CASE (td_rowClass td) [
Ü						WHEN_anon‰t‰c
							(Exception[internalError]);
Ü						WHEN_name‰t‰c s·
							Ok(mk_column(td_genCorr td, s));
Ü						WHEN_constant‰t‰c c·
							Ok(mk_constant_class c)
Ü						]
Ü(* (xs, []) *)				else	Exception [ambiguousName]
Ü		else	if	cds = [] ± Tl ids = []
Ü(* ([], [id]) *)	then	let	id = Hd ids
Ü				in	Ok(mk_constant_class(query_class st))
Ü(* (xs, ys) *)		else	Exception [ambiguousName]
°
¹HOLCONST
Ü	Ûlookup‰c‰o‰l‰u‰m‰n‰r‰o‰w‰c‰l‰a‰s‰sİ
Ü		: TRANS_STATE ­ (BOOL ¸ ColumnSpecification) ­ TsqlRepr RESULT
÷üüüüüüüüüüüüüüüüüüüü
Üµst flg cs·
Ü	lookup‰c‰o‰l‰u‰m‰n‰r‰o‰w‰c‰l‰a‰s‰s st (flg, cs) =
Ü	if	flg
Ü	then	lookup_column_row_class_look st (cs, innermost(symbolTable(st_stack st)))
Ü	else	lookup_column_row_class_look st (cs, (symbolTable(st_stack st)))
°
=TEX
Again {\it mutatatis mutandis},
the remarks about $lookup\_col\_spec\_class\_look$ above apply to
to the following.

¹HOLCONST
Ü	Ûlookup_table_row_class_lookİ
Ü		: TableSpecification ¸ Scope LIST ­ TsqlRepr RESULT
÷üüüüüüüüüüüüüüüüüüüüüü
Üµts outer ti·
Ü	lookup_table_row_class_look (ts, []) = Exception [noSuchTable]
Ü±	lookup_table_row_class_look (ts, outer ë [ti]) =
Ü	let	look1 (ts, td) =
Ü			CASE (td_tableName td) [
Ü			WHEN_anon‰t‰n [];
Ü			WHEN_name‰t‰n tn·
Ü				if	ts = tn
Ü				then	CASE (td_rowClass td) [
Ü					WHEN_anon‰t‰c [Exception[internalError]];
Ü					WHEN_name‰t‰c s·
Ü						[Ok(mk_column(td_genCorr td, s))];
Ü					WHEN_constant‰t‰c c·
Ü						[Ok(mk_constant_class c)]
Ü					]
Ü				else	[]
Ü			]
Ü	in let	(tds, ids) = (s_tables ti, s_identifiers ti)
Ü	in let	trs = Fold ($ë) (at2 (Map look1) (seq (Length tds) (ts), tds)) []
Ü	in	if	trs = [] then lookup_table_row_class_look (ts, outer)
Ü		else if	Tl trs = []
Ü		then	Hd trs
Ü		else	Exception[ambiguousName]
°
¹HOLCONST
Ü	Ûlookup‰t‰a‰b‰l‰e‰r‰o‰w‰c‰l‰a‰s‰sİ
Ü		: TRANS_STATE ­ (BOOL ¸ TableSpecification) ­ TsqlRepr RESULT
÷üüüüüüüüüüüüüüüüüüüü
Üµst flg ts·
Ü	lookup‰t‰a‰b‰l‰e‰r‰o‰w‰c‰l‰a‰s‰s st (flg, ts) =
Ü	if	flg
Ü	then	lookup_table_row_class_look (ts, innermost(symbolTable(st_stack st)))
Ü	else	lookup_table_row_class_look (ts, (symbolTable(st_stack st)))
°

¹HOLCONST
Ü	Ûlookup_table_detail_lookİ
Ü		: TableSpecification ¸ Scope LIST ­ TableDetail RESULT
÷üüüüüüüüüüüüüüüüüüüüüü
Üµts outer ti·
Ü	lookup_table_detail_look (ts, []) = Exception [noSuchTable]
Ü±	lookup_table_detail_look (ts, outer ë [ti]) =
Ü	let	look1 (ts, td) =
Ü			CASE (td_tableName td) [
Ü			WHEN_anon‰t‰n [];
Ü			WHEN_name‰t‰n tn·
Ü				if	ts = tn
Ü				then	[td]
Ü				else	[]
Ü			]
Ü	in let	(tds, ids) = (s_tables ti, s_identifiers ti)
Ü	in let	tis = Fold ($ë) (at2 (Map look1) (seq (Length tds) (ts), tds)) []
Ü	in	if	tis = [] then lookup_table_detail_look (ts, outer)
Ü		else if	Tl tis = []
Ü		then	Ok(Hd tis)
Ü		else	Exception[ambiguousName]
°
¹HOLCONST
Ü	Ûlookup‰t‰a‰b‰l‰e‰d‰e‰t‰a‰i‰lİ
Ü		: TRANS_STATE ­ TableSpecification ­ TableDetail RESULT
÷üüüüüüüüüüüüüüüüüüüü
Üµst ts·
Ü	lookup‰t‰a‰b‰l‰e‰d‰e‰t‰a‰i‰l st ts =
Ü	lookup_table_detail_look (ts, (symbolTable(st_stack st)))
°
=TEX
\subsection{Symbol Table Operations}
The following operation on state is a convenient short-hand in defining
these operations. It replaces the top scope in the symbol table in a state
with a given value.
¹HOLCONST
Ü	Ûupdate_top_scopeİ : TRANS_STATE ­ Scope ­ TRANS_STATE
÷üüüüüüüüüüüüüüüüü
Üµst sc·
Ü	update_top_scope st sc =
Ü	let	stk = st_stack st
Ü	in let	symt = symbolTable stk
Ü	in let	outer = Rev(Tl(Rev symt))
Ü	in let	symt' = outer ë [sc]
Ü	in	MkTRANS_STATE
Ü		(MkST_STACK symt' (parameterTable stk))
Ü		(query_class st) (query_constants_class st) (client_clearance st)
°
The local function $find$ used in several places in the following has been
misspelt as $fynd$ to avoid clashing with the constant $find$ defined
in \cite{DS/FMU/FEF/014}.
¹HOLCONST
Ü	Ûenter‰i‰d‰e‰n‰t‰i‰f‰i‰e‰rİ
Ü		: TRANS_STATE ­ (STRING ¸ ExpType ¸ Class)
Ü			­ (TRANS_STATE ¸ STRING ¸ STRING)RESULT
÷üüüüüüüüüüüü
Üµst name et up·
Ü	enter‰i‰d‰e‰n‰t‰i‰f‰i‰e‰r st (name,et,up) =
Ü	let	fynd (n,id) = if n = id_identName id then  [id] else []
Ü	in let	sl = symbolTable(st_stack st)
Ü	in	if	sl = []
Ü		then	Exception[noScope]
Ü		else 	let	outer = Rev(Tl(Rev sl))
Ü			in let	 ti = Hd(Rev sl)
Ü			in let	(tds, ids) = (s_tables ti, s_identifiers ti)
Ü			in	if	tds = []
Ü				then	let	unv = unique_name st
Ü					in let	unc = unique_name st
Ü					in let	id =
Ü						MkIdentDetail
Ü						name et up unv (mk_name‰t unc)
Ü					in	if	³
Ü							at2 (Map fynd)
Ü							(seq(Length ids)name,ids)
Ü							= []
Ü						then	Exception[ambiguousName]
Ü						else	let	sc' = MkScope [] (ids ë [id])
Ü							in	Ok(update_top_scope st sc', unv,unc)
Ü				else 	Exception[wrongScope]
°
¹HOLCONST
Ü	Ûenter‰i‰d‰e‰n‰t‰i‰f‰e‰r‰c‰o‰n‰s‰t‰a‰n‰t‰c‰l‰a‰s‰sİ
Ü		: TRANS_STATE ­ (STRING ¸ ExpType ¸ Class)
Ü			­ (TRANS_STATE ¸ STRING)RESULT
÷üüüüüüüüüüüü
Üµst name et clasf·
Ü	enter‰i‰d‰e‰n‰t‰i‰f‰e‰r‰c‰o‰n‰s‰t‰a‰n‰t‰c‰l‰a‰s‰s st (name,et,clasf) =
Ü	let	fynd (n,id) = if n = id_identName id then  [id] else []
Ü	in let	sl = symbolTable(st_stack st)
Ü	in	if	sl = []
Ü		then	Exception[noScope]
Ü		else 	let	outer = Rev(Tl(Rev sl))
Ü			in let	 ti = Hd(Rev sl)
Ü			in let	(tds, ids) = (s_tables ti, s_identifiers ti)
Ü			in	if	tds = []
Ü				then	let	unv = unique_name st
Ü					in let	id =
Ü						MkIdentDetail
Ü						name et clasf unv c_anon‰t
Ü					in	if	³
Ü							at2 (Map fynd)
Ü							(seq(Length ids)name,ids)
Ü							= []
Ü						then	Exception[ambiguousName]
Ü						else	let	sc' = MkScope [] (ids ë [id])
Ü							in	Ok (update_top_scope st sc', unv)
Ü				else 	Exception[wrongScope]
°
=TEX
¹HOLCONST
Ü	Ûextract‰p‰a‰r‰a‰m‰e‰t‰e‰rİ : STRING ¸ ParamInfo LIST  ­ ParamInfo LIST
÷üüüüüüüüüüüüüüüüüüüüü
Üµname l·
Ü	extract‰p‰a‰r‰a‰m‰e‰t‰e‰r (name,l) = l ù {pi | pi_name pi = name}
°
=TEX
¹HOLCONST
Ü	Ûenter‰p‰a‰r‰a‰m‰e‰t‰e‰rİ
Ü	: TRANS_STATE ­ STRING ¸ Value ¸ Class ­ TRANS_STATE RESULT
÷üüüüüüüüüüüüüüüüü
Üµst name v clasf·
Ü	enter‰p‰a‰r‰a‰m‰e‰t‰e‰r st (name,v,clasf) =	
Ü	let	sl = symbolTable(st_stack st)
Ü	in let	pt = parameterTable(st_stack st)
Ü	in 	if	sl = []
Ü		then	Exception[noScope]
Ü		else if	extract‰p‰a‰r‰a‰m‰e‰t‰e‰r(name, pt) = []
Ü		then	Ok(MkTRANS_STATE
Ü			(MkST_STACK sl (pt ë [MkParamInfo name v clasf]))
Ü			(query_class st) (query_constants_class st)
Ü			(client_clearance st))
Ü		else	Exception[ambiguousName]
°
=TEX
¹HOLCONST
Ü	Ûenter‰c‰o‰r‰r‰t‰a‰b‰l‰eİ
Ü	: TRANS_STATE
Ü	­ (STRING ¸ TableName ¸ TableInfo ¸ SsqlCol LIST ¸ TsqlClassName ¸ TsqlCol LIST)
Ü	­ (TRANS_STATE ¸ STRING)RESULT
÷üüüüüüüüüüüü
Üµst cn ts ti scs rcn tcs·
Ü	enter‰c‰o‰r‰r‰t‰a‰b‰l‰e st (cn, ts, ti, scs, rcn, tcs) =
Ü	let	sl = symbolTable(st_stack st)
Ü	in	if	sl = []
Ü		then	Exception[noScope]
Ü		else 	let	outer = Rev(Tl(Rev sl))
Ü			in let	 t = Hd(Rev sl)
Ü			in let	(tds, ids) = (s_tables t, s_identifiers t)
Ü			in	if	ids = []
Ü				then	let	gc = unique_name st
Ü					in let	td =
Ü						MkTableDetail
Ü						ts (mk_name‰s cn) gc ti scs rcn
Ü						tcs (MkConstraintInfo[][][][][])
Ü					in let	sc' = MkScope (tds ë [td]) []
Ü					in	Ok (update_top_scope st sc', gc)
Ü				else 	Exception[wrongScope]
°
=TEX
¹HOLCONST
Ü	Ûenter‰t‰a‰b‰l‰eİ
Ü	: TRANS_STATE
Ü	­ (TableName ¸ TableInfo ¸ SsqlCol LIST ¸ TsqlClassName ¸ TsqlCol LIST)
Ü	­ (TRANS_STATE ¸ STRING)RESULT
÷üüüüüüüüüüüü
Üµst ts ti scs rcn tcs·
Ü	enter‰t‰a‰b‰l‰e st (ts, ti, scs, rcn, tcs) =
Ü	let	sl = symbolTable(st_stack st)
Ü	in	if	sl = []
Ü		then	Exception[noScope]
Ü		else 	let	outer = Rev(Tl(Rev sl))
Ü			in let	 t = Hd(Rev sl)
Ü			in let	(tds, ids) = (s_tables t, s_identifiers t)
Ü			in	if	ids = []
Ü				then	let	gc = unique_name st
Ü					in let	td =
Ü						MkTableDetail
Ü						ts (c_anon‰s) gc ti scs rcn
Ü						tcs (MkConstraintInfo[][][][][])
Ü					in let	sc' = MkScope (tds ë [td]) []
Ü					in	Ok (update_top_scope st sc', gc)
Ü				else 	Exception[wrongScope]
°
=TEX
¹HOLCONST
Ü	Ûenter_scopeİ : TRANS_STATE ­ TRANS_STATE
÷üüüüüüüüüüüüüüüüü
Üµst·
Ü	enter_scope st =
Ü	let	stk = st_stack st
Ü	in let	symt = symbolTable stk
Ü	in let	outer = Rev(Tl(Rev symt))
Ü	in let	symt' = outer ë []
Ü	in	MkTRANS_STATE
Ü		(MkST_STACK symt' (parameterTable stk))
Ü		(query_class st) (query_constants_class st) (client_clearance st)
°
=TEX
The block-structured approach we use means that $leave\_scope$ is
not necessary.

¹HOLCONST
Ü	Ûget‰t‰a‰b‰l‰e‰i‰n‰f‰oİ
Ü	: TableSpecification ­
Ü	(TableInfo ¸ ConstraintInfo ¸ SsqlCol LIST ¸ TsqlClassName ¸ TsqlCol LIST)
÷üüüüüüüüüüüüüüüü
Ü	true
°
=TEX
The function $lookup\sp{local\_table\_implementation}$ of \cite{DS/FMU/FEF/020,trans}
is not used so we omit it.
=TEX
¹HOLCONST
Ü	Ûlookup‰l‰o‰c‰a‰l‰t‰a‰b‰l‰e‰i‰n‰f‰oİ
Ü	: TRANS_STATE ­ (TableInfo LIST) RESULT
÷üüüüüüüüüüüüüüüü
Üµst·	lookup‰l‰o‰c‰a‰l‰t‰a‰b‰l‰e‰i‰n‰f‰o st =
Ü	let 	look sc = Map td_info (s_tables sc)
Ü	in let	trs = Fold($ë)(Map look (innermost(symbolTable(st_stack st)))) []
Ü	in	if trs = []
Ü		then	Exception[noScope]
Ü		else	Ok trs
°
=TEX
¹HOLCONST
Ü	Ûlookup‰p‰a‰r‰a‰m‰d‰a‰t‰aİ
Ü	: TRANS_STATE ­ STRING ­ (Value ¸ Class) RESULT
÷üüüüüüüüüüüüüüüü
Üµst name·
Ü	lookup‰p‰a‰r‰a‰m‰d‰a‰t‰a st name =
Ü	let infos = extract‰p‰a‰r‰a‰m‰e‰t‰e‰r(name, parameterTable(st_stack st))
Ü	in	if	infos = []
Ü		then	Exception[noSuchParameter]
Ü		else if	Tl infos = []
Ü		then	let info = Hd infos in Ok(pi_val‰p info, pi_clasf info)
Ü		else	Exception[internalError]
°
=TEX
¹HOLCONST
Ü	Ûin_new_scopeİ
Ü	: (TRANS_STATE ­ 'a ­ 'b) ­ (TRANS_STATE ­ 'a ­ 'b)
÷üüüüüüüüüüüüüüüü
Üµwhat·
Ü	in_new_scope what = (Ìst· (Ìa· what (enter_scope st) a))
°
=TEX
\subsection{Transformations Proper}
The following glosses over the difference between $ColSpec$s as defined
in \cite{DS/FMU/FEF/014} and the more recent versions of \cite{specssql}.

We also do not spell out the details of various checking functions
such as $monop\_type$ etc.
¹HOLCONST
Ü	Ûrepr_colİ : TsqlRepr ­ Col_spec RESULT
÷üüüüüüüüüüüüüüüüüü
Üµtr·
Ü	repr_col tr =
Ü	CASE tr [
Ü	WHEN_local_identifier name·  Ok(denote_col_spec [name]);
Ü	WHEN_column(corr,col)· Ok(denote_col_spec[corr;col]);
Ü	WHEN_constant_class c· Exception[internalError];
Ü	WHEN_constant_null (Exception[internalError])
Ü	]
°
=TEX
¹HOLCONST
Ü	Ûall_data_columns‰l‰o‰c‰a‰lİ : TRANS_STATE ­ Col_spec LIST RESULT
÷üüüüüüüüüüüüüüüüüüü
Üµst·	all_data_columns‰l‰o‰c‰a‰l st =
Ü	Try
Ü	(ListOk o Map repr_col)
Ü	(lookup‰l‰o‰c‰a‰l‰c‰o‰l‰s‰p‰e‰c‰s‰t‰e‰r‰l‰i‰n‰g‰s st)
°
=TEX
¹HOLCONST
Ü	Ûbinop_typeİ : Op ¸ SwordType ¸ SwordType ­ SwordType RESULT
÷üüüüüüüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûmonop_typeİ : Op ¸ SwordType ­ SwordType RESULT
÷üüüüüüüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûtriop_typeİ : Op ¸ SwordType ¸ SwordType ¸ SwordType ­ SwordType RESULT
÷üüüüüüüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûset_func_typeİ : Op ¸ SwordType ­ SwordType RESULT
÷üüüüüüüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûcheck_booleanİ : ExpType ­ ExpType RESULT
÷üüüüüüüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûcheck_type_conversionİ : SwordType ¸ SwordType ­ ONE RESULT
÷üüüüüüüüüüüüüüüüüü
Ü	true
°
=TEX
The following interprets the old-style SSQL column specification as
formed from a hierarchical table directory name followed by a table
name followed by a column name.
¹HOLCONST
Ü	Ûconvert‰c‰o‰l‰s‰p‰e‰cİ : Col_spec ­ ColumnSpecification
÷üüüüüüüüüüüüüü
Üµil·	convert‰c‰o‰l‰s‰p‰e‰c (denote_col_spec il)  =
Ü	let	col = Hd(Rev il)
Ü	in let	dir = Hd(Tl(Rev il))
Ü	in let	tab = Tl(Tl(Rev il))
Ü	in	mk_specific(mk_absolute(tab, dir), col)
°

°
¹HOLCONST
Ü	Ûclass_columnİ : TRANS_STATE ­ Col_spec ­ (Col_spec + Class) RESULT
÷üüüüüüüüüüüüüü
Üµst cs·
Ü	class_column st cs =
Ü	let	csc = lookup‰c‰o‰l‰s‰p‰e‰c‰c‰l‰a‰s‰s st (true, convert‰c‰o‰l‰s‰p‰e‰c cs)
Ü	in	if	isVal csc
Ü		then	let	(tr, lub_cl) = destVal csc
Ü			in	CASE tr [
Ü				WHEN_local_identifier name·
Ü					Ok(InL(denote_col_spec [name]));
Ü				WHEN_column (gen_corr, gen_col)·
Ü					Ok(InL(denote_col_spec([gen_corr; gen_col])));
Ü				WHEN_constant_class cl· Ok(InR cl);
Ü				WHEN_constant_null (Exception[internalError])
Ü				]
Ü		else	giveError(destError csc)		
°
=TEX
=SML
¹HOLCONST
Ü	Ûdenote_nameİ : TsqlRepr ­ Value
÷üüüüüüüüüüüüüüüüü
Üµtr·	denote_name tr =
Ü	CASE tr [
Ü	WHEN_local_identifier s· contents(denote_col_spec [s]);
Ü 	WHEN_column(cn,col)· contents(denote_col_spec [cn;col]);
Ü 	WHEN_constant_class c· denote_class c;
Ü 	WHEN_constant_null denote_null
Ü	]
°
=TEX	
¹HOLCONST
Ü	Ûcolumn_data_testİ : TRANS_STATE ­ Col_spec ­ Value LIST RESULT
÷üüüüüüüüüüüüüü
Üµst cs·
Ü	column_data_test st cs =
Ü	let	csc = lookup‰c‰o‰l‰s‰p‰e‰c‰c‰l‰a‰s‰s st (true, convert‰c‰o‰l‰s‰p‰e‰c cs)
Ü	in	if	isVal csc
Ü		then	let	(tr, u) = destVal csc
Ü			in	if	client_clearance st dom u
Ü				then	Ok[]
Ü				else	let cc = denote_class(client_clearance st)
Ü					in	Ok[binop"dom"(cc, denote_name tr)]
Ü		else	giveError(destError csc)	
°
=TEX	
=SML
¹HOLCONST
Ü	Ûcol_expİ : ExpType ­ ColType RESULT
÷üüüüüüüüüüüüüü
Üµt w·
Ü	col_exp (t, w) =
Ü	if w = dinary then Ok(c_nullType, t)
Ü	else if w = sterling then Ok(t, c_nullType)
Ü	else if w = worthless then Ok(t, c_nullType)	
Ü	else Exception[wrongType]
°
=TEX	
=SML
¹HOLCONST
Ü	Ûcol_targetİ : SsqlCol ­ TsqlCol RESULT
÷üüüüüüüüüüüüüüü
Üµ sc·
Ü	col_target sc =
Ü	let	bound bi =
Ü		CASE bi [
Ü		WHEN_upb c· c_anon‰t‰c;
Ü		WHEN_constant c·mk_constant‰t‰c c
Ü		]
Ü	in let	target ((s, d), c) =
Ü		if	s = c_nullType ± d = c_nullType
Ü		then	Exception[internalError]
Ü		else if	d = c_nullType
Ü		then	Ok(MkTsqlCol c_anon‰t c_none‰t c)
Ü		else if	s = c_nullType
Ü		then	Ok(MkTsqlCol c_none‰t c_anon‰t c)
Ü		else 	Ok(MkTsqlCol c_anon‰t c_anon‰t c)
Ü	in 	target(sc_type_field sc, bound(sc_col_class sc))
°
=TEX
The following interprets the old-style SSQL table specification as
formed from a hierarchical table directory name followed by a table
name followed by a column name.
¹HOLCONST
Ü	Ûconvert‰t‰a‰b‰l‰e‰s‰p‰e‰cİ : Table_spec ­ TableSpecification
÷üüüüüüüüüüüüüü
Üµil·	convert‰t‰a‰b‰l‰e‰s‰p‰e‰c (denote_table_spec il)  =
Ü	let	tab = Hd(Rev il)
Ü	in let	dir = Tl(Rev il)
Ü	in	mk_absolute(dir, tab)
°
=TEX
¹HOLCONST
Ü	Ûconstant_value‰t‰y‰p‰eİ : Value ­ SwordType
÷üüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûconvert‰s‰s‰q‰l‰t‰y‰p‰eİ : Type ­ SwordType
÷üüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûconvert_tableSpecification_backupİ
Ü	: STRING LIST ¸ î ­ STRING LIST RESULT
÷üüüüüüüüüüüüüü
Üµd dirs n·
Ü	convert_tableSpecification_backup ([], 0)
Ü	= Ok []
Ü±	convert_tableSpecification_backup (Cons d dirs, 0)
Ü	= Ok (Cons d dirs)
Ü±	convert_tableSpecification_backup ([], n+1)
Ü	= Exception[noSuchDirectory]
Ü±	convert_tableSpecification_backup (Cons d dirs, n+1) =
Ü	convert_tableSpecification_backup (dirs, n)
°

¹HOLCONST
Ü	Ûconvert‰t‰a‰b‰l‰e‰S‰p‰e‰c‰i‰f‰c‰a‰t‰i‰o‰nİ
Ü	: TableSpecification ­ Table_spec RESULT
÷üüüüüüüüüüüüüü
Üµts·	convert‰t‰a‰b‰l‰e‰S‰p‰e‰c‰i‰f‰c‰a‰t‰i‰o‰n ts =
Ü	CASE ts [
Ü	WHEN_absolute(directory,table)·
Ü		Ok(denote_table_spec(directory ë [table]));
Ü	WHEN_default(up,directory,table)·
Ü		let	dir = convert_tableSpecification_backup
Ü				(default_directory, up)
Ü		in	if	isError dir
Ü			then	giveError(destError dir)
Ü			else	Ok(denote_table_spec(destVal dir ë directory ë [table]))
Ü	]
°

=TEX

¹HOLCONST
Ü	Ûtable_nameİ
Ü	: TableSpecification ­ STRING
÷üüüüüüüüüüüüüü
Üµts·	table_name ts =
Ü	let	dot s = s ë "."
Ü	in	CASE ts [
Ü		WHEN_absolute(dir,tab)·
Ü			if	dir = []
Ü			then	tab
Ü			else	Fold ($ë) (Map dot dir) [] ë tab;
Ü		WHEN_default(up,dir,tab)·
Ü			if	dir = []
Ü			then	Flat(seq up "-") ë tab
Ü			else	Flat(seq up "-") ë Fold ($ë) (Map dot dir) [] ë tab
Ü	]
°
=TEX
¹HOLCONST
Ü	Ûconvert‰s‰w‰o‰r‰d‰t‰y‰p‰eİ : SwordType ­ Type
÷üüüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûconvert‰t‰y‰p‰eİ : Type ­ Type
÷üüüüüüüüüüüüüü
Üµt·	convert‰t‰y‰p‰e t =
Ü	convert‰s‰w‰o‰r‰d‰t‰y‰p‰e(convert‰s‰s‰q‰l‰t‰y‰p‰e t)
°
=TEX
¹HOLCONST
Ü	Ûdenote‰c‰l‰a‰s‰s‰e‰x‰pİ : ExpClass ­ Value
÷üüüüüüüüüüüüüü
Üµec·
Ü	denote‰c‰l‰a‰s‰s‰e‰x‰p ec =
Ü	CASE ec [
Ü	WHEN_variable(v,c)· v;
Ü	WHEN_constant‰e‰c c· denote_class c
Ü	]
°
=TEX
¹HOLCONST
Ü	Ûlub‰b‰o‰u‰n‰d‰i‰n‰f‰oİ : BoundInfo ¸ BoundInfo ­ BoundInfo
÷üüüüüüüüüüü
Üµbi1 bi2·
Ü	lub‰b‰o‰u‰n‰d‰i‰n‰f‰o (bi1, bi2) =
Ü	CASE bi1 [
Ü	WHEN_upb c1·
Ü		CASE bi2 [
Ü			WHEN_upb c2·mk_upb(c1 lub c2);
Ü			WHEN_constant c2· mk_upb(c1 lub c2)
Ü		];
Ü	WHEN_constant c1·
Ü		CASE bi2 [
Ü			WHEN_upb c2·mk_upb(c1 lub c2);
Ü			WHEN_constant c2· if c1 = c2 then bi1 else mk_upb(c1 lub c2)
Ü		]
Ü	]
°
=TEX
¹HOLCONST
Ü	Ûlub‰e‰x‰p‰c‰l‰a‰s‰sİ : ExpClass ¸ ExpClass ­ ExpClass
÷üüüüüüüüüüü
Üµec1 ec2·
Ü	lub‰e‰x‰p‰c‰l‰a‰s‰s (ec1, ec2) =
Ü	CASE ec1 [
Ü	WHEN_variable (v1, c1)·
Ü		CASE ec2 [
Ü			WHEN_variable (v2, c2)·
Ü				mk_variable(binop "lub" (v1, v2), c1 lub c2);
Ü			WHEN_constant‰e‰c c2·
Ü				 mk_variable(binop "lub" (v1, denote_class c2), c1 lub c2)
Ü		];
Ü	WHEN_constant‰e‰c c1·
Ü		CASE ec2 [
Ü			WHEN_variable (v2, c2)·
Ü				 mk_variable(binop "lub" (v2, denote_class c1), c1 lub c2);
Ü			WHEN_constant‰e‰c c2·
Ü				mk_constant‰e‰c (c1 lub c2)
Ü		]
Ü	]
°
=TEX
=SML
¹HOLCONST
Ü	Ûlub‰t‰y‰p‰eİ : SwordType ¸ SwordType ­ SwordType
÷üüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûlub‰c‰o‰l‰t‰y‰p‰eİ : ColType ¸ ColType ­ ColType
÷üüüüüüüüüüü
Üµ s1 d1 s2 d2·
Ü	lub‰c‰o‰l‰t‰y‰p‰e((s1, d1), (s2, d2)) =
Ü	(lub‰t‰y‰p‰e(s1,s2),lub‰t‰y‰p‰e(d1,d2))
°
=TEX
¹HOLCONST
Ü	Ûlub‰w‰o‰r‰t‰hİ : Worth ¸ Worth ­ Worth
÷üüüüüüüüüüü
Üµ w1 w2·
Ü	lub‰w‰o‰r‰t‰h (w1, w2) =
Ü	if w1 = w2 then	w1
Ü	else if	w2 = worthless then w1
Ü	else if	w1 = worthless then w2
Ü	else priceless
°
¹HOLCONST
Ü	Ûlub‰e‰x‰pİ : ExpType ¸ ExpType ­ ExpType
÷üüüüüüüüüüü
Üµ t1 w1 t2 w2·
Ü	lub‰e‰x‰p((t1, w1), (t2, w2)) =
Ü	(lub‰t‰y‰p‰e(t1,t2),lub‰w‰o‰r‰t‰h(w1,w2))
°
=TEX
¹HOLCONST
Ü	Ûlub‰s‰s‰q‰l‰n‰a‰m‰eİ : SsqlName ¸ SsqlName ­ SsqlName
÷üüüüüüüüüüü
Üµ sn1 sn2·
Ü	lub‰s‰s‰q‰l‰n‰a‰m‰e (sn1, sn2) =
Ü	CASE sn1 [
Ü	WHEN_name‰s s1·
Ü		CASE sn2 [
Ü			WHEN_name‰s s2· if s1 = s2 then sn1 else c_anon‰s;
Ü			OTHERS c_anon‰s
Ü		];
Ü	OTHERS c_anon‰s
Ü	]
°
=TEX
¹HOLCONST
Ü	Ûlub‰s‰s‰q‰l‰c‰o‰lİ : SsqlCol ¸ SsqlCol ­ SsqlCol
÷üüüüüüüüüüü
Üµ n1 t1 ce1 cc1 n2 t2 ce2 cc2·
Ü	lub‰s‰s‰q‰l‰c‰o‰l (MkSsqlCol n1 t1 ce1 cc1, MkSsqlCol n2 t2 ce2 cc2) =
Ü	MkSsqlCol
Ü	(lub‰s‰s‰q‰l‰n‰a‰m‰e(n1,n2)) (lub‰c‰o‰l‰t‰y‰p‰e(t1,t2))
Ü	(ce1 lub ce2) (lub‰b‰o‰u‰n‰d‰i‰n‰f‰o(cc1,cc2))
°
=TEX
¹HOLCONST
Ü	Ûlub‰t‰a‰b‰l‰e‰i‰n‰f‰oİ : TableInfo ¸ TableInfo ­ TableInfo
÷üüüüüüüüüüü
Üµ tec1 tc1 rc1 tec2 tc2 rc2·
Ü	lub‰t‰a‰b‰l‰e‰i‰n‰f‰o (MkTableInfo tec1 tc1 rc1, MkTableInfo tec2 tc2 rc2) =
Ü	MkTableInfo
Ü	(tec1 lub tec2) (tc1 lub tc2) (lub‰b‰o‰u‰n‰d‰i‰n‰f‰o(rc1,rc2))
°
=TEX
¹HOLCONST
Ü	Ûlub‰t‰s‰q‰l‰c‰l‰a‰s‰s‰n‰a‰m‰eİ : TsqlClassName ¸ TsqlClassName ­ TsqlClassName
÷üüüüüüüüüüü
Üµ tcn1 tcn2·
Ü	lub‰t‰s‰q‰l‰c‰l‰a‰s‰s‰n‰a‰m‰e (tcn1, tcn2) =
Ü	CASE tcn1 [
Ü	WHEN_name‰t‰c s1·
Ü		CASE tcn2 [
Ü			WHEN_name‰t‰c s2· if s1 = s2 then tcn1 else c_anon‰t‰c;
Ü			OTHERS c_anon‰t‰c
Ü		];
Ü	OTHERS c_anon‰t‰c
Ü	]
°
=TEX
¹HOLCONST
Ü	Ûlub‰t‰s‰q‰l‰n‰a‰m‰eİ : TsqlName ¸ TsqlName ­ TsqlName
÷üüüüüüüüüüü
Üµ tn1 tn2·
Ü	lub‰t‰s‰q‰l‰n‰a‰m‰e (tn1, tn2) =
Ü	CASE tn1 [
Ü	WHEN_name‰t s1·
Ü		CASE tn2 [
Ü			WHEN_name‰t s2· if s1 = s2 then tn1 else c_anon‰t;
Ü			OTHERS c_anon‰t
Ü		];
Ü	WHEN_none‰t
Ü		(CASE tn2 [
Ü			WHEN_none‰t c_none‰t;
Ü			OTHERS c_anon‰t
Ü		]);
Ü	OTHERS c_anon‰t
Ü	]
°
=TEX
¹HOLCONST
Ü	Ûlub‰t‰s‰q‰l‰c‰o‰lİ : TsqlCol ¸ TsqlCol ­ TsqlCol
÷üüüüüüüüüüü
Üµ s1 d1 c1 s2 d2 c2·
Ü	lub‰t‰s‰q‰l‰c‰o‰l (MkTsqlCol s1 d1 c1, MkTsqlCol s2 d2 c2) =
Ü	MkTsqlCol
Ü	(lub‰t‰s‰q‰l‰n‰a‰m‰e(s1, s2))
Ü	(lub‰t‰s‰q‰l‰n‰a‰m‰e(d1, d2))
Ü	(lub‰t‰s‰q‰l‰c‰l‰a‰s‰s‰n‰a‰m‰e(c1, c2))
°
=TEX
The new $Select\_value$ category corresponds (at least in its $anonynomous$
option with the old $Value$, which appears as the operand to
$select\_value$).
¹HOLCONST
Ü	Ûmake‰s‰vİ : TsqlCol ¸ TsqlCol ­ Value LIST RESULT
÷üüüüüüüüüüü
Üµ f t·
Ü	make‰s‰v (f, t) =
Ü	let	data_col (ftn, ttn) =
Ü			CASE ftn [
Ü			WHEN_none‰t
Ü				(CASE ttn [
Ü				WHEN_none‰t (Ok []);
Ü				WHEN_anon‰t (Ok[denote_null]);
Ü				WHEN_name‰t ts· Exception[internalError]]);
Ü			WHEN_anon‰t
Ü				(CASE ttn [
Ü				WHEN_none‰t (Ok[denote_null]);
Ü				OTHERS (Exception[internalError])]);
Ü			WHEN_name‰t fs·
Ü				(CASE ttn [
Ü				WHEN_anon‰t (Ok[contents(denote_col_spec [fs])]);
Ü				WHEN_name‰t ts· Ok[contents(denote_col_spec [fs])];
Ü				WHEN_none‰t (Exception[internalError])])]
Ü	in let class_col (fcn, tcn) =
Ü			CASE fcn [
Ü			WHEN_constant‰t‰c fc·
Ü				CASE tcn [
Ü				WHEN_constant‰t‰c tc·
Ü					if fc = tc
Ü					then Ok []
Ü					else Exception[internalError];
Ü				WHEN_name‰t‰c tn· Ok[denote_class fc];
Ü				WHEN_anon‰t‰c (Exception[internalError])];
Ü			WHEN_name‰t‰c f·
Ü				CASE tcn [
Ü				WHEN_constant‰t‰c tc·Exception[internalError];
Ü				WHEN_name‰t‰c tn· Ok[contents(denote_col_spec [f])];
Ü				WHEN_anon‰t‰c (Ok[contents(denote_col_spec [f])])];
Ü			WHEN_anon‰t‰c (Exception[internalError])]
Ü	in let	ssv = data_col(tc_sterling_name f, tc_sterling_name t)
Ü	in let	dsv = data_col(tc_dinary_name f, tc_dinary_name t)
Ü	in let	csv = class_col(tc_class_name f, tc_class_name t)
Ü	in	if	isError ssv ² isError dsv ² isError csv
Ü		then	Exception[internalError]
Ü		else	Ok(destVal ssv ë destVal dsv ë destVal csv)
°
=TEX
¹HOLCONST
Ü	Ûremove_constantsİ : (Col_spec + Class) LIST ­ Col_spec LIST
÷üüüüüüüüüüüüüüüüüüü
Üµx s·
Ü	remove_constants [] = []
Ü±	remove_constants (Cons x s) =
Ü	if IsL x
Ü	then Cons (OutL x) (remove_constants s)
Ü	else remove_constants s
°
=TEX
¹HOLCONST
Ü	Ûremove_nullsİ : TsqlRepr LIST ­ TsqlRepr LIST
÷üüüüüüüüüüüüüüüüüüü
Üµx trs·
Ü	remove_nulls [] = []
Ü±	remove_nulls (Cons x trs) =
Ü	CASE x [
Ü	WHEN_constant_null (remove_nulls trs);
Ü	OTHERS (Cons x (remove_nulls trs))]
°
=TEX
¹HOLCONST
Ü	Ûupperİ : ExpClass ­ Class
÷üüüüüüüüüüüüüüüüüüü
Üµec·	upper ec =
Ü	CASE ec [
Ü	WHEN_variable (c, u)· u;
Ü	WHEN_constant‰e‰c u· u]
°
=TEX
¹HOLCONST
Ü	Ûmake_caseİ : Value ¸ ExpClass ­ Value
÷üüüüüüüüüüüüüüüüüüü
Üµdata ec·
Ü	make_case (data, ec) =
Ü	CASE ec [
Ü	WHEN_variable (c, u)· case [data] [denote_class(lattice_top)] c;
Ü	WHEN_constant‰e‰c c· case [data] [denote_class(lattice_top)] (denote_class c)]
°
=TEX
¹HOLCONST
Ü	Ûsimplify‰a‰n‰d‰sİ : Value LIST ¸ ExpClass LIST ­ Value ¸ ExpClass
÷üüüüüüüüüüüüüüüüüüü
Üµvs cs·
Ü	simplify‰a‰n‰d‰s (vs, cs) =
Ü	let	v = fold (binop And) vs
Ü	in let	c = case [v]
Ü			[fold(binop "lub")(Map denote‰c‰l‰a‰s‰s‰e‰x‰p cs)]
Ü			(fold(binop "glb")(at2 (Map make_case) (vs,cs)))
Ü	in let	u = fold (Uncurry $lub) (Map upper cs)
Ü	in	(v, mk_variable(c, u))
°
=TEX
¹HOLCONST
Ü	Ûsimplify‰o‰r‰sİ : Value LIST ¸ ExpClass LIST ­ Value ¸ ExpClass
÷üüüüüüüüüüüüüüüüüüü
Üµvs cs·
Ü	simplify‰o‰r‰s (vs, cs) =
Ü	let	v = fold (binop Or) vs
Ü	in let	c = case [v]
Ü			[fold(binop "glb")(Map denote‰c‰l‰a‰s‰s‰e‰x‰p cs)]
Ü			(fold(binop "lub")(at2 (Map make_case) (vs,cs)))
Ü	in let	u = fold (Uncurry $lub) (Map upper cs)
Ü	in	(v, mk_variable(c, u))
°
=TEX
¹HOLCONST
Ü	Ûconstant_value‰d‰a‰t‰aİ : Value ­ Value
÷üüüüüüüüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûdinary_columnsİ : TRANS_STATE ­ Col_spec LIST ­ Col_spec LIST RESULT
÷üüüüüüüüüüüüüüüüüüü
Üµst css·
Ü	dinary_columns st css =
Ü	let	look cs = lookup‰c‰o‰l‰s‰p‰e‰c‰d‰i‰n‰a‰r‰y st (false,convert‰c‰o‰l‰s‰p‰e‰c cs)
Ü	in	Try
Ü		(ListOk o Map repr_col o remove_nulls)
Ü		(ListOk (Map look css))
°
=TEX
¹HOLCONST
Ü	Ûsterling_columnsİ : TRANS_STATE ­ Col_spec LIST ­ Col_spec LIST RESULT
÷üüüüüüüüüüüüüüüüüüü
Üµst css·
Ü	sterling_columns st css =
Ü	let	look cs = lookup‰c‰o‰l‰s‰p‰e‰c‰s‰t‰e‰r‰l‰i‰n‰g st (false,convert‰c‰o‰l‰s‰p‰e‰c cs)
Ü	in	Try
Ü		(ListOk o Map repr_col o remove_nulls)
Ü		(ListOk (Map look css))
°
=TEX
¹HOLCONST
Ü	Ûtuple_list‰m‰a‰x‰r‰o‰w‰c‰l‰a‰s‰sİ : TRANS_STATE ­ Tuple_list ­ ExpClass
÷üüüüüüüüüüüüüüüüüüü
Üµst t·	tuple_list‰m‰a‰x‰r‰o‰w‰c‰l‰a‰s‰s st t =
Ü	mk_constant‰e‰c(client_clearance st)
°
=TEX
¹HOLCONST
Ü	Ûupb_row_classİ : TableInfo ­ Class
÷üüüüüüüüüüüüüüüüüüü
Üµtec tc rowc·
Ü	upb_row_class (MkTableInfo tec tc rowc) =
Ü	CASE rowc [
Ü	WHEN_upb rc· rc;
Ü	WHEN_constant rc· rc]
°
=TEX
In the following, the specifications of $internal\_value‰c‰l‰a‰s‰s$  and
$value\_type$  are incomplete. ($all\_binop$,
$some\_binop$, $all\_binop\_list$ and $some\_binop\_list$
are missing from $internal\_value‰c‰l‰a‰s‰s$ and $caseVal$ is
missing from $value\_type$.)

¹HOLCONST
Ü	Ûvalue‰d‰a‰t‰aİ : TRANS_STATE ­ Value ­ Value
÷üüüüüüüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûvalue‰t‰y‰p‰eİ : TRANS_STATE ­ Value ­ ExpType
÷üüüüüüüüüüüüüüüüüü
Ü	true
°
=TEX
We now have to start breaking up the mutually recursive functions
of \cite{DS/FMU/FEF/020}. We do this by passing the functions to
be recalled recursively as parameters. For example:
¹HOLCONST
Ü	Ûvalue‰c‰l‰a‰s‰sİ
Ü	: (TRANS_STATE ­ Value ­ InternalExpClass RESULT)
Ü		­ TRANS_STATE ­ Value ­ ExpClass RESULT
÷üüüüüüüüüüüüü
Üµst ivc v·
Ü	value‰c‰l‰a‰s‰s ivc st v =
Ü	let	x = ivc st v
Ü	in	if isError x
Ü		then giveError (destError x)
Ü		else	Ok(CASE (destVal x) [
Ü			WHEN_ands(datas, classes)·
Ü				let	(v, c) = simplify‰a‰n‰d‰s(datas,classes)
Ü				in	c;
Ü			WHEN_ors(datas,classes)·
Ü				let	(v, c) = simplify‰o‰r‰s(datas,classes)
Ü				in c;
Ü			WHEN_simple ec·
Ü				CASE ec [
Ü				WHEN_variable(exp,up)· mk_variable(exp,up);
Ü				WHEN_constant‰e‰c c· mk_constant‰e‰c c]
Ü			])
°
=TEX
¹HOLCONST
Ü	Ûtuple_list‰d‰a‰t‰aİ :TRANS_STATE ­ Tuple_list ­ Tuple_list RESULT
÷üüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûtuple_list‰t‰y‰p‰eİ : TRANS_STATE ­ Tuple_list ­ Tuple_list RESULT
÷üüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûfrom_spec‰e‰n‰t‰e‰rİ : TRANS_STATE ­ From_spec ­ From_spec RESULT
÷üüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûselect_list‰t‰y‰p‰eİ : TRANS_STATE ­ Select_list ­ ExpType RESULT
÷üüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûselect_value‰t‰y‰p‰eİ : TRANS_STATE ­ Value ­ ExpType RESULT
÷üüüüüüüüüüü
Ü	true
°
=TEX
=TEX
¹HOLCONST
Ü	Ûtuple_list‰i‰n‰f‰oİ : TRANS_STATE ­ Tuple_list
Ü		­ (TableName  ¸ TableInfo ¸ SsqlCol LIST) RESULT
÷üüüüüüüüüüü
Ü	true
°
=TEX
=TEX
¹HOLCONST
Ü	Ûtuple_list‰m‰a‰k‰eİ
Ü	: TRANS_STATE ­ Tuple_list ¸ TsqlClassName ¸ TsqlCol LIST
Ü		­ Tuple_list RESULT
÷üüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûfrom_spec‰i‰n‰f‰oİ
Ü	: TRANS_STATE ­ From_spec
Ü		­ (TableInfo ¸ SsqlCol LIST ¸ TsqlClassName ¸ TsqlCol LIST) RESULT
÷üüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûselect_list‰i‰n‰f‰oİ
Ü	: TRANS_STATE ­ Select_list ­ SsqlCol LIST RESULT
÷üüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûselect_value‰i‰n‰f‰oİ
Ü	: TRANS_STATE ­ Value ­ SsqlCol RESULT
÷üüüüüüüüüüü
Ü	true
°
¹HOLCONST
Ü	Ûvalue‰i‰n‰f‰oİ
Ü	: TRANS_STATE ­ Value ­ SsqlCol RESULT
÷üüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	 Ûinternal_value‰c‰l‰a‰s‰sİ : TRANS_STATE ­ Value ­ InternalExpClass RESULT
÷üüüüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	 Ûtuple_list‰c‰l‰a‰s‰sİ : TRANS_STATE ­ Tuple_list ­ Tuple_list
÷üüüüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	 Ûselect_list‰c‰l‰a‰s‰sİ : TRANS_STATE ­ Select_list ­ Select_list RESULT
÷üüüüüüüüüüüüüüü
Ü	true
°
¹HOLCONST
Ü	 Ûselect_value‰c‰l‰a‰s‰sİ : TRANS_STATE ­ Value ­ Value RESULT
÷üüüüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûselect_list‰m‰a‰k‰eİ
Ü	: TRANS_STATE ­ (Select_list ¸ TsqlClassName ¸ TsqlCol LIST)
Ü		­ Value LIST RESULT
÷üüüüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûselect_value‰m‰a‰k‰eİ
Ü	: TRANS_STATE ­ (Value ¸ TsqlCol LIST) ­ Value LIST RESULT
÷üüüüüüüüüüüüüüü
Ü	true
°
¹HOLCONST
Ü	Ûmake_colİ : TRANS_STATE ­ (Value ¸ TsqlCol) ­ Value LIST RESULT
÷üüüüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûmake‰d‰i‰n‰a‰r‰yİ : TRANS_STATE ­ (Value ¸ ExpType) ­ Value RESULT
÷üüüüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûmake‰s‰t‰e‰r‰l‰i‰n‰gİ : TRANS_STATE ­ (Value ¸ ExpType) ­ Value RESULT
÷üüüüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûselect_list‰d‰a‰t‰aİ : TRANS_STATE ­ Select_list ­ Select_list RESULT
÷üüüüüüüüüüüüüüü
Ü	true
°
¹HOLCONST
Ü	Ûselect_value‰d‰a‰t‰aİ : TRANS_STATE ­ Value ­ Value RESULT
÷üüüüüüüüüüüüüüü
Ü	true
°
¹HOLCONST
Ü	Ûtuple_list‰m‰a‰k‰e‰o‰u‰t‰e‰rİ
Ü	: TRANS_STATE ­ (Tuple_list ¸ BOOL ¸ TsqlClassName ¸ TsqlCol LIST)
Ü				 ­ (Tuple_list ¸ Query LIST) RESULT
÷üüüüüüüüüüüüüüü
Ü	true
°
=TEX
That is the last of the mutually recursive functions.
¹HOLCONST
Ü	Ûtuple_list‰o‰u‰t‰e‰r‰i‰n‰f‰oİ
Ü	: TRANS_STATE ­ Tuple_list ­ BOOL RESULT
÷üüüüüüüüüüüüüüü
Ü	true
°
¹HOLCONST
Ü	Ûtransform‰s‰e‰l‰e‰c‰t‰q‰u‰e‰r‰yİ
Ü	: TRANS_STATE ­ Query ­
Ü	(SsqlCol LIST ¸ Query ¸ BOOL ¸ TsqlClassName ¸ TsqlCol LIST ¸ Query LIST)
Ü									RESULT
÷üüüüüüüüüüüüüüü
Ü	true
°
¹HOLCONST
Ü	Ûquery‰s‰e‰l‰e‰c‰t‰q‰u‰e‰r‰yİ
Ü	: TRANS_STATE ­ Query ­ Query RESULT
÷üüüüüüüüüüüüüüü
Ü	true
°
\section{INTERFACE}
We now wish to define the SSQL Transformation Processor as required
by \cite{DS/FMU/FEF/022}. It is parameterised by the as yet undefined
processing of the various updating queries.

The local function $dynamic$ below computes the list of boolean flags needed by the output filter of \cite{DS/FMU/FEF/022} from the list of $TsqlCol$s
produced by
=INLINEFT
transform‰s‰e‰l‰e‰c‰t‰q‰u‰e‰r‰y
=TEX
.

Since the processing of updating queries is as yet unspecified, we treat
it as an error if the select query processing fails (e.g, because the
query is not a select query).
=SML
¹HOLCONST
Ü	ÛSTPİ : (Query, FILTER_PARS) STP_TYPE
÷üüüüüüüüüüü
Üµq c·	STP (q, c) =
Ü	let	st = init_trans_state c
Ü	in let	res = transform‰s‰e‰l‰e‰c‰t‰q‰u‰e‰r‰y st q
Ü	in	if	isError res
Ü		then	giveError(destError res)
Ü		else	Ok
Ü			let	(scs, tq, scw, rc, tcs, chks) = destVal res
Ü			in let	dynamic tc =
Ü				CASE tc [WHEN_constant‰t‰c c· false; OTHERS true]
Ü			in let	cc = Map (dynamic o tc_class_name) tcs
Ü			in let	cr = if dynamic rc then InL c else InR One
Ü			in let	cq = if chks = [] then InR One else InL(Hd chks)
Ü			in	(tq, cq, (scw, cr, cc))
°
=TEX
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}

