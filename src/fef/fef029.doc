=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Specification of Query Transformations in HOL (II)}  %% Mandatory field
\TPPref{DS/FMU/FEF/020}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{A specification of the SSQL Query Transformations in HOL for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}})]  First draft
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document gives a formal specification in HOL (\cite{milner90}, \cite{paulson91}) of the SSQL query transformations of \cite{trans}. It constitutes part of
 deliverable D11 of work package 3, as given
in the Proposal for Phase~2, \cite{DS/FMU/FEF/018}.

\subsection{Introduction}
We provide HOL specifications of the 
SSQL query transformations of \cite{trans}. Preliminary 
material needed
 to support these query 
transformation specifications may be found in \cite{DS/FMU/FEF/028}.
\subsection{ProofPower Preamble}
The following commands initialise the ProofPower system to accept
the specifications:
=SML
open_theory"fef028";
new_theoryÛ"fef029"İ;
set_pc"hol";
=TEX
\section{THE TRANSFORMATIONS}
The following error values are required in addition to those introduced
in \cite{DS/FMU/FEF/004}.

¹HOLCONST
ÜÛinternalErrorİ		ÛwrongWorthİ			ÛnotTriggerİ
ÜÛonlyInTriggersİ		ÛnotMonadicİ			ÛnotDyadicİ
ÜÛnotTriadicİ			ÛnotSetFunctionİ		ÛnoSuchParameterİ
ÜÛnoScopeİ			ÛwrongScopeİ			ÛambiguousNameİ
ÜÛemptyUnionListİ		:				Error
÷üüüüüüüüüüüüüüüüüüüüüüü
Ü	true
°

=TEX
\subsection{Incompletely Specified Transformations}
Some functions have not been specified in \cite{trans}.
They are loosely defined here. Some of them depend on the state of
the transformation process, this is modelled by the following labelled
product type. Of the four components of the state, only the first,
the symbol table stack, varies during the transformation, the other components
simply record information supplied as parameters to the overall transformation
process. The projection functions for these parameter components serve
for the functions of the same name from \cite{DS/FMU/FEF/028,trans}.

¹HOLLABPROD ÛTRANS_STATEİüüüüüüüüüüüüüüüüü
Ü	st_stack			: ST_STACK;
Ü	query_class			: Class;
Ü	query_constants_class		: Class;
Ü	client_clearance		: Class
°üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
¹HOLCONST
Ü	Ûcheck_enumİ : Enum ¸ Int ¸ Table_spec ­ BOOL;
Ü	Ûcheck_fixedİ : Fixed ¸ Int ¸ Int ­ BOOL;
Ü	Ûcheck_floatingİ : Float ¸ Int ¸ Int ¸ Int ­ BOOL;
Ü	Ûcheck_intervalİ : Interval ¸ STRING ­ BOOL;
Ü	Ûcheck_timeİ : Time ¸ STRING ­ BOOL;
Ü	ÛtimeFormatToIntervalİ : STRING ­ STRING;
Ü	Ûunique_nameİ : TRANS_STATE ­ STRING;
Ü	Ûcontextual_dataİ : STRING ­ Value ¸ Class;
Ü	Ûdefault_directoryİ : STRING LIST
÷üüüüüüüüüüüüüüüü
Ü	true
°
=TEX
Notes:

\begin{enumerate}
\item $check\_enum$ is, presumably, parameterised by the structure
{\em and content} of the database. The above parameterisation is therefore
not very realistic, since it only permits dependence on the structure of
the database (presumed fixed), not its contents.
\item $unique\_name$ parameterised as above could only produce names which
were unique within the current symbol-table scope, not within the entire
transformation process.
\end{enumerate}

\subsection{Symbol Table Model}
¹HOLCONST
Ü	Ûfind‰c‰o‰l‰u‰m‰nİ : ColumnSpecification ¸ TableDetail LIST ­ 
Ü					(TableDetail ¸ SsqlCol ¸ TsqlCol)LIST
÷üüüüüüüüüüüüüüüüüüüüüüüüüüü
Üµcs tdl·
Ü	find‰c‰o‰l‰u‰m‰n(cs,tdl) =
Ü	let	look (n, td, scl, tcl) =
Ü		let  sctcl = splice scl tcl
Ü		in let sctcl' = sctcl ù {(sc, tc) | sc_name sc = mk_name‰s n}
Ü		in Map (Ì(sc, tc)· (td, sc, tc)) sctcl'
Ü	in let	do1td td =
Ü		CASE cs [
Ü		WHEN_anonymous_column col·
Ü			look(col, td, td_columns td, td_implementation td);
Ü		WHEN_specific (ts, col)·
Ü			CASE (td_tableName td) [
Ü			WHEN_name‰t‰n ts·
Ü				look(col, td, td_columns td, td_implementation td);
Ü			OTHERS []
Ü			]
Ü		]
Ü	in	Flat(Map do1td tdl)
°
=TEX
¹HOLCONST
Ü	Ûfind‰i‰d‰e‰n‰tİ : ColumnSpecification ¸ IdentDetail LIST ­ 
Ü					IdentDetail LIST
÷üüüüüüüüüüüüüüüüüüüüüüüüüüü
Üµcs idl·
Ü	find‰i‰d‰e‰n‰t (cs, idl) =
Ü	CASE cs [
Ü	WHEN_specific (t, c)· [];
Ü	WHEN_anonymous_column col·
Ü		idl ù {id | col = id_identName id}
Ü	]
°
=TEX
We replace the function $look$, which is private to $lookup\sb{column\_info}$
in \cite{DS/FMU/FEF/029,trans} by a top-level function,
$lookup\_column\_info\_look$ (since it is recursive and HOL local functions
cannot be recursive).
¹HOLCONST
Ü 	Ûlookup_column_info_lookİ :
Ü		ColumnSpecification  ¸ Scope LIST ­ (TableInfo ¸ SsqlCol)RESULT
÷üüüüüüüüüüüüüüüüüüüüüüü
Üµcs ti outer·
Ü	lookup_column_info_look (cs, []) = Exception [noSuchColumn]
Ü±	lookup_column_info_look (cs, outer @ [ti]) =
Ü	let	t = s_tables ti
Ü	in let	tdsctcl = find‰c‰o‰l‰u‰m‰n(cs, t)
Ü	in	if	tdsctcl = []
Ü		then	lookup_column_info_look (cs, outer)
Ü		else if	Tl(tdsctcl) = []
Ü		then	let (td, sc, tc) = Hd tdsctcl in Ok(td_info td, sc)
Ü		else	Exception [ambiguousName]
°
¹HOLCONST
Ü 	Ûlookup‰c‰o‰l‰u‰m‰n‰_‰i‰n‰f‰oİ :
Ü	TRANS_STATE ­ ColumnSpecification ­ (TableInfo ¸ SsqlCol)RESULT
÷üüüüüüüüüüüüüüüüüüüüüüü
Üµst cs·	lookup‰c‰o‰l‰u‰m‰n‰_‰i‰n‰f‰o st cs =
Ü		lookup_column_info_look (cs, symbolTable(st_stack st))
°
=TEX
¹HOLCONST
Ü	ÛmaxBoundİ : BoundInfo ­ Class
÷üüüüüüüüüüü
Üµc·	maxBound c =
Ü	CASE c [
Ü	WHEN_upb c· c;
Ü	WHEN_constant c· c
Ü	]
°
=TEX
¹HOLCONST
Ü	Ûinnermostİ : Scope LIST ­ Scope LIST
÷üüüüüüüüüüüü
Üµouter inner·
Ü	innermost [] = []
Ü±	innermost (outer @ [inner]) =
Ü	let tds = s_tables inner
Ü	in	if	tds = []
Ü		then	innermost outer @ [inner]
Ü		else	[inner]
°
As with $lookup\sb{column\_info}$, we replace the recursive
function $look$ local to $lookup\sb{col\_info}$
by a top-level function $look\_up\_col\_spec\_class\_look$.
The comments before the $then$s below show the corresponding ML pattern match
(cf. \cite{DS/FMU/FEF/020}).
¹HOLCONST
Ü	Ûlookup_col_spec_class_lookİ
Ü		: ColumnSpecification  ¸ Scope LIST ­ (TsqlRepr ¸ Class) RESULT
÷üüüüüüüüüüüüüüüü
Üµ cs outer ti·
Ü	lookup_col_spec_class_look(cs,[]) = Exception [noSuchColumn]
Ü±	lookup_col_spec_class_look(cs, outer @ [ti]) = 	
Ü	let	(t, i) = (s_tables ti, s_identifiers ti)
Ü	in let	cds = find‰c‰o‰l‰u‰m‰n(cs,t)
Ü	and	ids = find‰i‰d‰e‰n‰t(cs,i)
Ü	in 	if	ids = []
Ü		then	if	cds = []
Ü(* ([], []) *)		then	lookup_col_spec_class_look(cs, outer)
Ü			else	if	Tl cds = []
Ü(* ([(td,sc,tc)], []) *)	then 	let	(td, sc, tc) = Hd cds
Ü					in let	u = maxBound (sc_col_class sc)
Ü					in	CASE (tc_class_name tc) [
Ü						WHEN_anon‰t‰c
Ü							(Exception[internalError]);
Ü						WHEN_name‰t‰c s·
Ü							Ok(mk_column(td_genCorr td, s), u);
Ü						WHEN_constant‰t‰c c·
Ü							Ok(mk_constant_class c,u)
Ü						]
Ü(* (xs, []) *)				else	Exception [ambiguousName]
Ü		else	if	cds = [] ± Tl ids = []
Ü(* ([], [id]) *)	then	let	id = Hd ids
Ü				in let	cl = id_lub‰i‰d id
Ü				in	CASE (id_cName id) [
Ü					WHEN_none‰t (Ok(mk_constant_class cl, cl));
Ü					WHEN_anon‰t (Exception[internalError]);
Ü					WHEN_name‰t s·Ok(mk_local_identifier s, cl)
Ü					]
Ü(* (xs, ys) *)		else	Exception [ambiguousName]
°
¹HOLCONST
Ü	Ûlookup‰c‰o‰l‰_‰s‰p‰e‰c‰_‰c‰l‰a‰s‰sİ :
Ü		TRANS_STATE ­ (BOOL ¸ ColumnSpecification) ­ (TsqlRepr ¸ Class)RESULT 
÷üüüüüüüüüüüüü
Üµst flg cs·
Ü	lookup‰c‰o‰l‰_‰s‰p‰e‰c‰_‰c‰l‰a‰s‰s st (flg, cs) =
Ü	if	flg
Ü	then	lookup_col_spec_class_look(cs, innermost(symbolTable(st_stack st)))
Ü	else	lookup_col_spec_class_look(cs, (symbolTable(st_stack st)))
°
=TEX
{\it Mutatatis mutandis},
the remarks about $lookup\_col\_spec\_class\_look$ above apply both to
to $lookup\_col\_spec\_dinary\_look$, and to
$lookup\_col\_spec\_sterling\_look$ below.
¹HOLCONST
Ü	Ûlookup_col_spec_dinary_lookİ
Ü		: ColumnSpecification  ¸ Scope LIST ­ TsqlRepr RESULT
÷üüüüüüüüüüüüüüüü
Üµ cs outer ti·
Ü	lookup_col_spec_dinary_look(cs,[]) = Exception [noSuchColumn]
Ü±	lookup_col_spec_dinary_look(cs, outer @ [ti]) = 	
Ü	let	(t, i) = (s_tables ti, s_identifiers ti)
Ü	in let	cds = find‰c‰o‰l‰u‰m‰n(cs,t)
Ü	and	ids = find‰i‰d‰e‰n‰t(cs,i)
Ü	in 	if	ids = []
Ü		then	if	cds = []
Ü(* ([], []) *)		then	lookup_col_spec_dinary_look(cs, outer)
Ü			else	if	Tl cds = []
Ü(* ([(td,sc,tc)], []) *)	then 	let	(td, sc, tc) = Hd cds
Ü					in	CASE (tc_dinary_name tc) [
Ü						WHEN_none‰t
Ü							(Exception[internalError]);
Ü						WHEN_anon‰t
Ü							(Exception[internalError]);
Ü						WHEN_name‰t s·
Ü							Ok(mk_column(td_genCorr td, s))
Ü						]
Ü(* (xs, []) *)				else	Exception [ambiguousName]
Ü		else	if	cds = [] ± Tl ids = []
Ü(* ([], [id]) *)	then	let	id = Hd ids
Ü				in let	(st, w) = id_info id
Ü				in	if	w = dinary
Ü					then	Ok(mk_local_identifier(id_vName id))
Ü					else	Ok(c_constant_null)
Ü(* (xs, ys) *)		else	Exception [ambiguousName]
°
=TEX
¹HOLCONST
Ü	Ûlookup‰c‰o‰l‰_‰s‰p‰e‰c‰_‰d‰i‰n‰a‰r‰yİ :
Ü		TRANS_STATE ­ (BOOL ¸ ColumnSpecification) ­ TsqlRepr RESULT 
÷üüüüüüüüüüüüü
Üµst flg cs·
Ü	lookup‰c‰o‰l‰_‰s‰p‰e‰c‰_‰d‰i‰n‰a‰r‰y st (flg, cs) =
Ü	if	flg
Ü	then	lookup_col_spec_dinary_look(cs, innermost(symbolTable(st_stack st)))
Ü	else	lookup_col_spec_dinary_look(cs, (symbolTable(st_stack st)))
°
¹HOLCONST
Ü	Ûlookup_col_spec_sterling_lookİ
Ü		: ColumnSpecification  ¸ Scope LIST ­ TsqlRepr RESULT
÷üüüüüüüüüüüüüüüü
Üµ cs outer ti·
Ü	lookup_col_spec_sterling_look(cs,[]) = Exception [noSuchColumn]
Ü±	lookup_col_spec_sterling_look(cs, outer @ [ti]) = 	
Ü	let	(t, i) = (s_tables ti, s_identifiers ti)
Ü	in let	cds = find‰c‰o‰l‰u‰m‰n(cs,t)
Ü	and	ids = find‰i‰d‰e‰n‰t(cs,i)
Ü	in 	if	ids = []
Ü		then	if	cds = []
Ü(* ([], []) *)		then	lookup_col_spec_sterling_look(cs, outer)
Ü			else	if	Tl cds = []
Ü(* ([(td,sc,tc)], []) *)	then 	let	(td, sc, tc) = Hd cds
Ü					in	CASE (tc_sterling_name tc) [
Ü						WHEN_none‰t
Ü							(Exception[internalError]);
Ü						WHEN_anon‰t
Ü							(Exception[internalError]);
Ü						WHEN_name‰t s·
Ü							Ok(mk_column(td_genCorr td, s))
Ü						]
Ü(* (xs, []) *)				else	Exception [ambiguousName]
Ü		else	if	cds = [] ± Tl ids = []
Ü(* ([], [id]) *)	then	let	id = Hd ids
Ü				in let	(st, w) = id_info id
Ü				in	if	w = sterling
Ü					then	Ok(mk_local_identifier(id_vName id))
Ü					else	Ok(c_constant_null)
Ü(* (xs, ys) *)		else	Exception [ambiguousName]
°
=TEX
¹HOLCONST
Ü	Ûlookup‰c‰o‰l‰_‰s‰p‰e‰c‰_‰s‰t‰e‰r‰l‰i‰n‰gİ :
Ü		TRANS_STATE ­ (BOOL ¸ ColumnSpecification) ­ TsqlRepr RESULT 
÷üüüüüüüüüüüüü
Üµst flg cs·
Ü	lookup‰c‰o‰l‰_‰s‰p‰e‰c‰_‰s‰t‰e‰r‰l‰i‰n‰g st (flg, cs) =
Ü	if	flg
Ü	then	lookup_col_spec_sterling_look(cs, innermost(symbolTable(st_stack st)))
Ü	else	lookup_col_spec_sterling_look(cs, (symbolTable(st_stack st)))
°
=TEX
¹HOLCONST
Ü	Ûlookup‰l‰o‰c‰a‰l‰_‰c‰o‰l‰_‰i‰m‰p‰l‰e‰m‰e‰n‰t‰a‰t‰i‰o‰nİ
Ü		: TRANS_STATE ­ TsqlCol LIST RESULT 
÷üüüüüüüüüüüüüüüüüüü
Üµ st· lookup‰l‰o‰c‰a‰l‰_‰c‰o‰l‰_‰i‰m‰p‰l‰e‰m‰e‰n‰t‰a‰t‰i‰o‰n st =
Ü	let	extract_implementation sc =
Ü		Fold ($@) (Map td_implementation (s_tables sc)) []
Ü	in let	trs =
Ü		Fold ($@)
Ü		(Map extract_implementation (innermost(symbolTable(st_stack st))))[]
Ü	in	if	trs = []
Ü		then	Exception[noScope]
Ü		else	Ok trs
°
=TEX
¹HOLCONST
Ü	Ûlookup‰l‰o‰c‰a‰l‰_‰c‰o‰l‰_‰i‰n‰f‰oİ
Ü		: TRANS_STATE ­ SsqlCol LIST RESULT 
÷üüüüüüüüüüüüüüüüüüü
Üµ st· lookup‰l‰o‰c‰a‰l‰_‰c‰o‰l‰_‰i‰n‰f‰o st =
Ü	let	extract_columns sc =
Ü		Fold ($@) (Map td_columns (s_tables sc)) []
Ü	in let	trs =
Ü		Fold ($@)
Ü		(Map extract_columns (innermost(symbolTable(st_stack st))))[]
Ü	in	if	trs = []
Ü		then	Exception[noScope]
Ü		else	Ok trs
°
=TEX
¹HOLCONST
Ü	Ûlookup‰l‰o‰c‰a‰l‰_‰c‰o‰l‰_‰s‰p‰e‰c‰_‰c‰l‰a‰s‰s‰e‰sİ
Ü		: TRANS_STATE ­ (TsqlRepr ¸ Class) LIST RESULT 
÷üüüüüüüüüüüüüüüüüüü
Üµ st· lookup‰l‰o‰c‰a‰l‰_‰c‰o‰l‰_‰s‰p‰e‰c‰_‰c‰l‰a‰s‰s‰e‰s st =
Ü	let	look2(corr,sc,tc) =
Ü		let	u = maxBound(sc_col_class sc)
Ü		in	CASE (tc_class_name tc) [
Ü			WHEN_anon‰t‰c (Exception[internalError]);
Ü			WHEN_name‰t‰c s· Ok(mk_column(corr, s), u);
Ü			WHEN_constant‰t‰c c· Ok(mk_constant_class c,u)
Ü			]
Ü	in let	look1 td = at3 (Map look2)
Ü			(seq (Length (td_columns td)) (td_genCorr td),
Ü				td_columns td, td_implementation td)
Ü	in let	look sc = Fold ($@) (Map look1 (s_tables sc)) []
Ü	in let	trs = 
Ü		Fold ($@) (Map look (innermost(symbolTable(st_stack st))))[]
Ü	in	if	trs = []
Ü		then	Exception[noScope]
Ü		else	ListOk trs
°
=TEX
¹HOLCONST
Ü	Ûlookup‰l‰o‰c‰a‰l‰_‰c‰o‰l‰_‰s‰p‰e‰c‰_‰s‰t‰e‰r‰l‰i‰n‰g‰sİ
Ü		: TRANS_STATE ­ TsqlRepr LIST RESULT 
÷üüüüüüüüüüüüüüüüüüü
Üµ st· lookup‰l‰o‰c‰a‰l‰_‰c‰o‰l‰_‰s‰p‰e‰c‰_‰s‰t‰e‰r‰l‰i‰n‰g‰s st =
Ü	let	look2(corr,tc) =
Ü		CASE (tc_sterling_name tc) [
Ü		WHEN_none‰t (Ok c_constant_null);
Ü		WHEN_anon‰t (Exception[internalError]);
Ü		WHEN_name‰t s· Ok(mk_column(corr, s))
Ü		]
Ü	in let	look1 td = at2 (Map look2)
Ü			(seq (Length (td_columns td)) (td_genCorr td),
Ü				td_implementation td)
Ü	in let	look sc = Fold ($@) (Map look1 (s_tables sc)) []
Ü	in let	trs = 
Ü		Fold ($@) (Map look (innermost(symbolTable(st_stack st))))[]
Ü	in	if	trs = []
Ü		then	Exception[noScope]
Ü		else	ListOk trs
°
=TEX
¹HOLCONST
Ü	Ûlookup‰l‰o‰c‰a‰l‰_‰r‰o‰w‰_‰c‰l‰a‰s‰s‰e‰sİ
Ü		: TRANS_STATE ­ TsqlRepr LIST RESULT 
÷üüüüüüüüüüüüüüüüüüü
Üµ st· lookup‰l‰o‰c‰a‰l‰_‰r‰o‰w‰_‰c‰l‰a‰s‰s‰e‰s st =
Ü	let	look1 td =
Ü		CASE (td_rowClass td) [
Ü		WHEN_anon‰t‰c (Exception[internalError]);
Ü		WHEN_name‰t‰c s· Ok(mk_column(td_genCorr td, s));
Ü		WHEN_constant‰t‰c c· Ok(mk_constant_class c)
Ü		]
Ü	in let	look sc = Map look1 (s_tables sc)
Ü	in let	trs = 
Ü		Fold ($@) (Map look (innermost(symbolTable(st_stack st))))[]
Ü	in	if	trs = []
Ü		then	Exception[noScope]
Ü		else	ListOk trs
°
=TEX
Again {\it mutatatis mutandis},
the remarks about $lookup\_col\_spec\_class\_look$ above apply to
to the following.
¹HOLCONST
Ü	Ûlookup_column_row_class_lookİ
Ü		: TRANS_STATE ­ ColumnSpecification  ¸ Scope LIST ­ TsqlRepr RESULT
÷üüüüüüüüüüüüüüüü
Üµ st cs outer ti·
Ü	lookup_column_row_class_look st (cs,[]) = Exception [noSuchColumn]
Ü±	lookup_column_row_class_look st (cs, outer @ [ti]) = 	
Ü	let	(t, i) = (s_tables ti, s_identifiers ti)
Ü	in let	cds = find‰c‰o‰l‰u‰m‰n(cs,t)
Ü	and	ids = find‰i‰d‰e‰n‰t(cs,i)
Ü	in 	if	ids = []
Ü		then	if	cds = []
Ü(* ([], []) *)		then	lookup_column_row_class_look st (cs, outer)
Ü			else	if	Tl cds = []
Ü(* ([(td,sc,tc)], []) *)	then 	let	(td, sc, tc) = Hd cds
Ü					in	CASE (td_rowClass td) [
Ü						WHEN_anon‰t‰c
							(Exception[internalError]);
Ü						WHEN_name‰t‰c s·
							Ok(mk_column(td_genCorr td, s));
Ü						WHEN_constant‰t‰c c·
							Ok(mk_constant_class c)
Ü						]
Ü(* (xs, []) *)				else	Exception [ambiguousName]
Ü		else	if	cds = [] ± Tl ids = []
Ü(* ([], [id]) *)	then	let	id = Hd ids
Ü				in	Ok(mk_constant_class(query_class st))
Ü(* (xs, ys) *)		else	Exception [ambiguousName]
°
¹HOLCONST
Ü	Ûlookup‰c‰o‰l‰u‰m‰n‰_‰r‰o‰w‰_‰c‰l‰a‰s‰sİ
Ü		: TRANS_STATE ­ (BOOL ¸ ColumnSpecification) ­ TsqlRepr RESULT
÷üüüüüüüüüüüüüüüüüüüü
Üµst flg cs·
Ü	lookup‰c‰o‰l‰u‰m‰n‰_‰r‰o‰w‰_‰c‰l‰a‰s‰s st (flg, cs) =
Ü	if	flg
Ü	then	lookup_column_row_class_look st (cs, innermost(symbolTable(st_stack st)))
Ü	else	lookup_column_row_class_look st (cs, (symbolTable(st_stack st)))
°
=TEX
Again {\it mutatatis mutandis},
the remarks about $lookup\_col\_spec\_class\_look$ above apply to
to the following.

¹HOLCONST
Ü	Ûlookup_table_row_class_lookİ
Ü		: TableSpecification ¸ Scope LIST ­ TsqlRepr RESULT
÷üüüüüüüüüüüüüüüüüüüüüü
Üµts outer ti·
Ü	lookup_table_row_class_look (ts, []) = Exception [noSuchTable]
Ü±	lookup_table_row_class_look (ts, outer @ [ti]) =
Ü	let	look1 (ts, td) =
Ü			CASE (td_tableName td) [
Ü			WHEN_anon‰t‰n [];
Ü			WHEN_name‰t‰n tn·
Ü				if	ts = tn
Ü				then	CASE (td_rowClass td) [
Ü					WHEN_anon‰t‰c [Exception[internalError]];
Ü					WHEN_name‰t‰c s·
Ü						[Ok(mk_column(td_genCorr td, s))];
Ü					WHEN_constant‰t‰c c·
Ü						[Ok(mk_constant_class c)]
Ü					]
Ü				else	[]
Ü			]
Ü	in let	(tds, ids) = (s_tables ti, s_identifiers ti)
Ü	in let	trs = Fold ($@) (at2 (Map look1) (seq (Length tds) (ts), tds)) []
Ü	in	if	trs = [] then lookup_table_row_class_look (ts, outer)
Ü		else if	Tl trs = []
Ü		then	Hd trs
Ü		else	Exception[ambiguousName]
°
¹HOLCONST
Ü	Ûlookup‰t‰a‰b‰l‰e‰_‰r‰o‰w‰_‰c‰l‰a‰s‰sİ
Ü		: TRANS_STATE ­ (BOOL ¸ TableSpecification) ­ TsqlRepr RESULT
÷üüüüüüüüüüüüüüüüüüüü
Üµst flg ts·
Ü	lookup‰t‰a‰b‰l‰e‰_‰r‰o‰w‰_‰c‰l‰a‰s‰s st (flg, ts) =
Ü	if	flg
Ü	then	lookup_table_row_class_look (ts, innermost(symbolTable(st_stack st)))
Ü	else	lookup_table_row_class_look (ts, (symbolTable(st_stack st)))
°

¹HOLCONST
Ü	Ûlookup_table_detail_lookİ
Ü		: TableSpecification ¸ Scope LIST ­ TableDetail RESULT
÷üüüüüüüüüüüüüüüüüüüüüü
Üµts outer ti·
Ü	lookup_table_detail_look (ts, []) = Exception [noSuchTable]
Ü±	lookup_table_detail_look (ts, outer @ [ti]) =
Ü	let	look1 (ts, td) =
Ü			CASE (td_tableName td) [
Ü			WHEN_anon‰t‰n [];
Ü			WHEN_name‰t‰n tn·
Ü				if	ts = tn
Ü				then	[td]
Ü				else	[]
Ü			]
Ü	in let	(tds, ids) = (s_tables ti, s_identifiers ti)
Ü	in let	tis = Fold ($@) (at2 (Map look1) (seq (Length tds) (ts), tds)) []
Ü	in	if	tis = [] then lookup_table_detail_look (ts, outer)
Ü		else if	Tl tis = []
Ü		then	Ok(Hd tis)
Ü		else	Exception[ambiguousName]
°
¹HOLCONST
Ü	Ûlookup‰t‰a‰b‰l‰e‰_‰d‰e‰t‰a‰i‰lİ
Ü		: TRANS_STATE ­ TableSpecification ­ TableDetail RESULT
÷üüüüüüüüüüüüüüüüüüüü
Üµst ts·
Ü	lookup‰t‰a‰b‰l‰e‰_‰d‰e‰t‰a‰i‰l st ts =
Ü	lookup_table_detail_look (ts, (symbolTable(st_stack st)))
°
=TEX
\subsection{Symbol Table Operations}
The following operation on state is a convenient short-hand in defining
these operations. It replaces the top scope in the symbol table in a state
with a given value.
¹HOLCONST
Ü	Ûupdate_top_scopeİ : TRANS_STATE ­ Scope ­ TRANS_STATE
÷üüüüüüüüüüüüüüüüü
Üµst sc·
Ü	update_top_scope st sc =
Ü	let	stk = st_stack st
Ü	in let	symt = symbolTable stk
Ü	in let	outer = Rev(Tl(Rev symt))
Ü	in let	symt' = outer @ [sc]
Ü	in	MkTRANS_STATE
Ü		(MkST_STACK symt' (parameterTable stk))
Ü		(query_class st) (query_constants_class st) (client_clearance st)
°
The local function $find$ used in several places in the following has been
misspelt as $fynd$ to avoid clashing with the constant $find$ defined
in \cite{DS/FMU/FEF/014}.
¹HOLCONST
Ü	Ûenter‰i‰d‰e‰n‰t‰i‰f‰i‰e‰rİ
Ü		: TRANS_STATE ­ (STRING ¸ ExpType ¸ Class)
Ü			­ (TRANS_STATE ¸ STRING ¸ STRING)RESULT
÷üüüüüüüüüüüü
Üµst name et up·
Ü	enter‰i‰d‰e‰n‰t‰i‰f‰i‰e‰r st (name,et,up) =
Ü	let	fynd (n,id) = if n = id_identName id then  [id] else []
Ü	in let	sl = symbolTable(st_stack st)
Ü	in	if	sl = []
Ü		then	Exception[noScope]
Ü		else 	let	outer = Rev(Tl(Rev sl))
Ü			in let	 ti = Hd(Rev sl)
Ü			in let	(tds, ids) = (s_tables ti, s_identifiers ti)
Ü			in	if	tds = []
Ü				then	let	unv = unique_name st
Ü					in let	unc = unique_name st
Ü					in let	id =
Ü						MkIdentDetail 
Ü						name et up unv (mk_name‰t unc)
Ü					in	if	³
Ü							at2 (Map fynd)
Ü							(seq(Length ids)name,ids)
Ü							= []
Ü						then	Exception[ambiguousName]
Ü						else	let	sc' = MkScope [] (ids @ [id])
Ü							in	Ok (update_top_scope st sc', unv,unc)
Ü				else 	Exception[wrongScope]
°
¹HOLCONST
Ü	Ûenter‰i‰d‰e‰n‰t‰i‰f‰e‰r‰_‰c‰o‰n‰s‰t‰a‰n‰t‰_‰c‰l‰a‰s‰sİ
Ü		: TRANS_STATE ­ (STRING ¸ ExpType ¸ Class)
Ü			­ (TRANS_STATE ¸ STRING)RESULT
÷üüüüüüüüüüüü
Üµst name et clasf·
Ü	enter‰i‰d‰e‰n‰t‰i‰f‰e‰r‰_‰c‰o‰n‰s‰t‰a‰n‰t‰_‰c‰l‰a‰s‰s st (name,et,clasf) =
Ü	let	fynd (n,id) = if n = id_identName id then  [id] else []
Ü	in let	sl = symbolTable(st_stack st)
Ü	in	if	sl = []
Ü		then	Exception[noScope]
Ü		else 	let	outer = Rev(Tl(Rev sl))
Ü			in let	 ti = Hd(Rev sl)
Ü			in let	(tds, ids) = (s_tables ti, s_identifiers ti)
Ü			in	if	tds = []
Ü				then	let	unv = unique_name st
Ü					in let	id =
Ü						MkIdentDetail 
Ü						name et clasf unv c_anon‰t
Ü					in	if	³
Ü							at2 (Map fynd)
Ü							(seq(Length ids)name,ids)
Ü							= []
Ü						then	Exception[ambiguousName]
Ü						else	let	sc' = MkScope [] (ids @ [id])
Ü							in	Ok (update_top_scope st sc', unv)
Ü				else 	Exception[wrongScope]
°
=TEX
¹HOLCONST
Ü	Ûextract‰p‰a‰r‰a‰m‰e‰t‰e‰rİ : STRING ¸ ParamInfo LIST  ­ ParamInfo LIST
÷üüüüüüüüüüüüüüüüüüüüü
Üµname l·
Ü	extract‰p‰a‰r‰a‰m‰e‰t‰e‰r (name,l) = l ù {pi | pi_name pi = name}
°
=TEX
¹HOLCONST
Ü	Ûenter‰p‰a‰r‰a‰m‰e‰t‰e‰rİ
Ü	: TRANS_STATE ­ STRING ¸ Value ¸ Class ­ TRANS_STATE RESULT
÷üüüüüüüüüüüüüüüüü
Üµst name v clasf·
Ü	enter‰p‰a‰r‰a‰m‰e‰t‰e‰r st (name,v,clasf) =	
Ü	let	sl = symbolTable(st_stack st)
Ü	in let	pt = parameterTable(st_stack st)
Ü	in 	if	sl = []
Ü		then	Exception[noScope]
Ü		else if	extract‰p‰a‰r‰a‰m‰e‰t‰e‰r(name, pt) = []
Ü		then	Ok(MkTRANS_STATE
Ü			(MkST_STACK sl (pt @ [MkParamInfo name v clasf]))
Ü			(query_class st) (query_constants_class st)
Ü			(client_clearance st))
Ü		else	Exception[ambiguousName]
°
=TEX
¹HOLCONST
Ü	Ûenter‰c‰o‰r‰r‰_‰t‰a‰b‰l‰eİ
Ü		: TRANS_STATE ­ (STRING ¸ TableName ¸ TableInfo ¸ SsqlCol LIST ¸ TsqlClassName ¸ TsqlCol LIST)
Ü			­ (TRANS_STATE ¸ STRING)RESULT
÷üüüüüüüüüüüü
Üµst cn ts ti scs rcn tcs·
Ü	enter‰c‰o‰r‰r‰_‰t‰a‰b‰l‰e st (cn, ts, ti, scs, rcn, tcs) =
Ü	let	sl = symbolTable(st_stack st)
Ü	in	if	sl = []
Ü		then	Exception[noScope]
Ü		else 	let	outer = Rev(Tl(Rev sl))
Ü			in let	 t = Hd(Rev sl)
Ü			in let	(tds, ids) = (s_tables t, s_identifiers t)
Ü			in	if	ids = []
Ü				then	let	gc = unique_name st
Ü					in let	td =
Ü						MkTableDetail 
Ü						ts (mk_name‰s cn) gc ti scs rcn
Ü						tcs (MkConstraintInfo[][][][][])
Ü					in let	sc' = MkScope (tds @ [td]) []
Ü					in	Ok (update_top_scope st sc', gc)
Ü				else 	Exception[wrongScope]
°
=TEX
¹HOLCONST
Ü	Ûenter‰t‰a‰b‰l‰eİ
Ü		: TRANS_STATE ­ (TableName ¸ TableInfo ¸ SsqlCol LIST ¸ TsqlClassName ¸ TsqlCol LIST)
Ü			­ (TRANS_STATE ¸ STRING)RESULT
÷üüüüüüüüüüüü
Üµst ts ti scs rcn tcs·
Ü	enter‰t‰a‰b‰l‰e st (ts, ti, scs, rcn, tcs) =
Ü	let	sl = symbolTable(st_stack st)
Ü	in	if	sl = []
Ü		then	Exception[noScope]
Ü		else 	let	outer = Rev(Tl(Rev sl))
Ü			in let	 t = Hd(Rev sl)
Ü			in let	(tds, ids) = (s_tables t, s_identifiers t)
Ü			in	if	ids = []
Ü				then	let	gc = unique_name st
Ü					in let	td =
Ü						MkTableDetail 
Ü						ts (c_anon‰s) gc ti scs rcn
Ü						tcs (MkConstraintInfo[][][][][])
Ü					in let	sc' = MkScope (tds @ [td]) []
Ü					in	Ok (update_top_scope st sc', gc)
Ü				else 	Exception[wrongScope]
°
=TEX
¹HOLCONST
Ü	Ûenter_scopeİ : TRANS_STATE ­ TRANS_STATE
÷üüüüüüüüüüüüüüüüü
Üµst·
Ü	enter_scope st =
Ü	let	stk = st_stack st
Ü	in let	symt = symbolTable stk
Ü	in let	outer = Rev(Tl(Rev symt))
Ü	in let	symt' = outer @ []
Ü	in	MkTRANS_STATE
Ü		(MkST_STACK symt' (parameterTable stk))
Ü		(query_class st) (query_constants_class st) (client_clearance st)
°
=TEX
The block-structured approach we use means that $leave\_scope$ is
not necessary.

¹HOLCONST
Ü	Ûget‰t‰a‰b‰l‰e‰i‰n‰f‰oİ
Ü	: TableSpecification ­
Ü	(TableInfo ¸ ConstraintInfo ¸ SsqlCol LIST ¸ TsqlClassName ¸ TsqlCol LIST)
÷üüüüüüüüüüüüüüüü
Ü	true
°
=TEX
¹HOLCONST
Ü	Ûget‰t‰a‰b‰l‰e‰i‰n‰f‰oİ
Ü	: TableSpecification ­
Ü	(TableInfo ¸ ConstraintInfo ¸ SsqlCol LIST ¸ TsqlClassName ¸ TsqlCol LIST)
÷üüüüüüüüüüüüüüüü
Ü	true
°
=TEX
The function $lookup\sp{local\_table\_implementation}$ of \cite{DS/FMU/FEF/020,trans}
is not used so we omit it.
=TEX
¹HOLCONST
Ü	Ûlookup‰l‰o‰c‰a‰l‰_‰t‰a‰b‰l‰e‰_‰i‰n‰f‰oİ
Ü	: TRANS_STATE ­ (TableInfo LIST) RESULT
÷üüüüüüüüüüüüüüüü
Üµst·	lookup‰l‰o‰c‰a‰l‰_‰t‰a‰b‰l‰e‰_‰i‰n‰f‰o st =
Ü	let 	look sc = Map td_info (s_tables sc)
Ü	in let	trs = Fold($@)(Map look (innermost(symbolTable(st_stack st)))) []
Ü	in	if trs = []
Ü		then	Exception[noScope]
Ü		else	Ok trs
°
=TEX
¹HOLCONST
Ü	Ûlookup‰p‰a‰r‰a‰m‰_‰d‰a‰t‰aİ
Ü	: TRANS_STATE ­ STRING ­ (Value ¸ Class) RESULT
÷üüüüüüüüüüüüüüüü
Üµst name·
Ü	lookup‰p‰a‰r‰a‰m‰_‰d‰a‰t‰a st name =
Ü	let infos = extract‰p‰a‰r‰a‰m‰e‰t‰e‰r(name, parameterTable(st_stack st))
Ü	in	if	infos = []
Ü		then	Exception[noSuchParameter]
Ü		else if	Tl infos = []
Ü		then	let info = Hd infos in Ok(pi_val‰p info, pi_clasf info)
Ü		else	Exception[internalError]
°
=TEX
¹HOLCONST
Ü	Ûin_new_scopeİ
Ü	: (TRANS_STATE ­ 'a ­ 'b) ­ (TRANS_STATE ­ 'a ­ 'b)
÷üüüüüüüüüüüüüüüü
Üµwhat·
Ü	in_new_scope what = (Ìst· (Ìa· what (enter_scope st) a))
°
=TEX
\subsection{Transformations Proper}
=SML
fun 	(Ûrepr_colİ : TsqlRepr ­ Col_specètsqlê) 
			(local_identifier name) =  denote_col_spec‰t name
|	repr_col	(column(corr,col)) = absolute_col_spec‰t([],corr,col)
|	repr_col	(constant_class c) = raise internalError
|	repr_col	constant_null = raise internalError;
=TEX
=SML
fun 	(Ûall_data_columnsèlocalêİ : unit ­ Col_specètsqlê list) () 
					= map repr_col(lookup‰l‰o‰c‰a‰l‰_‰c‰o‰l‰_‰s‰p‰e‰c‰_‰s‰t‰e‰r‰l‰i‰n‰g‰s());
=TEX
=SML
fun 	(Ûbinop_typeİ : Op ¸ SwordType ¸ SwordType ­ SwordType) 
				(plus_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					fixedType(p1 max p2,s1 max s2)
| 	binop_type 		(plus_op,floatingType(m1,e1,os1),floatingType(m2,e2,os2)) = 
					if m1 = m2 andalso e1 = e2 andalso os1 = os2 
					then floatingType(m1,e1,os1)
					else raise wrongType
|	binop_type 		(plus_op,enumType(p1,t1),fixedType(p2,0)) = enumType(p1,t1)
|	binop_type 		(plus_op,timeType f1,intervalType f2) = timeType f1
|	binop_type 		(plus_op,intervalType f1,intervalType f2) = 
					if f1 = f2
					then intervalType f1
					else raise wrongType
|	binop_type 		(plus_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(minusd_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					fixedType(p1 max p2,s1 max s2)
| 	binop_type 		(minusd_op,floatingType(m1,e1,os1),floatingType(m2,e2,os2)) = 
					if m1 = m2 andalso e1 = e2 andalso os1 = os2 
					then floatingType(m1,e1,os1)
					else raise wrongType
|	binop_type 		(minusd_op,enumType(p1,t1),fixedType(p2,0)) = enumType(p1,t1)
|	binop_type 		(minusd_op,timeType f1,intervalType f2) = timeType f1
|	binop_type 		(minusd_op,intervalType f1,intervalType f2) = 
					if f1 = f2
					then intervalType f1
					else raise wrongType
|	binop_type 		(minusd_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(times_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					fixedType(p1 max p2,s1 max s2)
| 	binop_type 		(times_op,floatingType(m1,e1,os1),floatingType(m2,e2,os2)) = 
					if m1 = m2 andalso e1 = e2 andalso os1 = os2 
					then floatingType(m1,e1,os1)
					else raise wrongType
|	binop_type 		(times_op,intervalType f,fixedType(p,s)) = intervalType f
|	binop_type 		(times_op,intervalType f,floatingType(m,e,os)) =  intervalType f
|	binop_type 		(times_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(divide_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					fixedType(p1 max p2,s1 max s2)
| 	binop_type 		(divide_op,floatingType(m1,e1,os1),floatingType(m2,e2,os2)) = 
					if m1 = m2 andalso e1 = e2 andalso os1 = os2 
					then floatingType(m1,e1,os1)
					else raise wrongType
|	binop_type 		(divide_op,intervalType f,fixedType(p,s)) = intervalType f
|	binop_type 		(divide_op,intervalType f,floatingType(m,e,os)) =  intervalType f
|	binop_type 		(divide_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(concat_op,stringType(min1,max1),stringType(min2,max2)) = 
					stringType(min1 + min2,max1 + max2)
|	binop_type		(concat_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(and_op,booleanType,booleanType) = booleanType
|	binop_type		(and_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(or_op,booleanType,booleanType) = booleanType
|	binop_type		(or_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(less_than_op,stringType(min1,max1),stringType(min2,max2)) = 
					booleanType
|	binop_type		(less_than_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					booleanType
| 	binop_type 		(less_than_op,floatingType(m1,e1,os1),floatingType(m2,e2,os2)) = 
					booleanType
|	binop_type 		(less_than_op,enumType(p1,t1),enumType(p2,t2)) = 
					if p1 = p2 andalso t1 = t2 
					then booleanType
					else raise wrongType
|	binop_type 		(less_than_op,timeType f1,timeType f2) = 
					booleanType
|	binop_type 		(less_than_op,intervalType f1,intervalType f2) = 
					booleanType
|	binop_type 		(less_than_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(less_or_equal_op,stringType(min1,max1),
					stringType(min2,max2)) = 
					booleanType
|	binop_type		(less_or_equal_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					booleanType
| 	binop_type 		(less_or_equal_op,floatingType(m1,e1,os1),
					floatingType(m2,e2,os2)) = 
					booleanType
|	binop_type 		(less_or_equal_op,enumType(p1,t1),enumType(p2,t2)) = 
					if p1 = p2 andalso t1 = t2 
					then booleanType
					else raise wrongType
|	binop_type 		(less_or_equal_op,timeType f1,timeType f2) = 
					booleanType
|	binop_type 		(less_or_equal_op,intervalType f1,intervalType f2) = 
					booleanType
|	binop_type 		(less_or_equal_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(greater_or_equal_op,stringType(min1,max1),
					stringType(min2,max2)) = 
					booleanType
|	binop_type		(greater_or_equal_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					booleanType
| 	binop_type 		(greater_or_equal_op,floatingType(m1,e1,os1),
					floatingType(m2,e2,os2)) = 
					booleanType
|	binop_type 		(greater_or_equal_op,enumType(p1,t1),enumType(p2,t2)) = 
					if p1 = p2 andalso t1 = t2 
					then booleanType
					else raise wrongType
|	binop_type 		(greater_or_equal_op,timeType f1,timeType f2) = 
					booleanType
|	binop_type 		(greater_or_equal_op,intervalType f1,intervalType f2) = 
					booleanType
|	binop_type 		(greater_or_equal_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(greater_than_op,stringType(min1,max1),
					stringType(min2,max2)) = 
					booleanType
|	binop_type		(greater_than_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					booleanType
| 	binop_type 		(greater_than_op,floatingType(m1,e1,os1),
					floatingType(m2,e2,os2)) = 
					booleanType
|	binop_type 		(greater_than_op,enumType(p1,t1),enumType(p2,t2)) = 
					if p1 = p2 andalso t1 = t2 
					then booleanType
					else raise wrongType
|	binop_type 		(greater_than_op,timeType f1,timeType f2) = 
					booleanType
|	binop_type 		(greater_than_op,intervalType f1,intervalType f2) = 
					booleanType
|	binop_type 		(greater_than_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(equal_op,nullType,t) = 			booleanType
|	binop_type		(equal_op,t,nullType) = 			booleanType
|	binop_type		(equal_op,booleanType,booleanType) = 	booleanType
|	binop_type		(equal_op,stringType(min1,max1),stringType(min2,max2)) = 
					booleanType
|	binop_type		(equal_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					booleanType
|	binop_type 		(equal_op,enumType(p1,t1),enumType(p2,t2)) = 
					if p1 = p2 andalso t1 = t2 
					then booleanType
					else raise wrongType
| 	binop_type 		(equal_op,floatingType(m1,e1,os1),floatingType(m2,e2,os2)) = 
					booleanType
|	binop_type 		(equal_op,timeType f1,timeType f2) = 		booleanType
|	binop_type 		(equal_op,intervalType f1,intervalType f2) = 	booleanType
|	binop_type 		(equal_op,classType,classType) = 			booleanType
|	binop_type 		(equal_op,codeType,codeType) = 			booleanType
|	binop_type 		(equal_op,anyType,anyType) =			booleanType
|	binop_type 		(equal_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(not_equal_op,nullType,t) = 			booleanType
|	binop_type		(not_equal_op,t,nullType) = 			booleanType
|	binop_type		(not_equal_op,booleanType,booleanType) = 	booleanType
|	binop_type		(not_equal_op,stringType(min1,max1),stringType(min2,max2)) = 
					booleanType
|	binop_type		(not_equal_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					booleanType
|	binop_type 		(not_equal_op,enumType(p1,t1),enumType(p2,t2)) = 
					if p1 = p2 andalso t1 = t2 
					then booleanType
					else raise wrongType
| 	binop_type 		(not_equal_op,floatingType(m1,e1,os1),
					floatingType(m2,e2,os2)) = 
					booleanType
|	binop_type 		(not_equal_op,timeType f1,timeType f2) = 		booleanType
|	binop_type 		(not_equal_op,intervalType f1,intervalType f2) = 	booleanType
|	binop_type 		(not_equal_op,classType,classType) = 		booleanType
|	binop_type 		(not_equal_op,codeType,codeType) = 		booleanType
|	binop_type 		(not_equal_op,anyType,anyType) =			booleanType
|	binop_type 		(not_equal_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type 		(lub_op,classType,classType) = classType
|	binop_type 		(lub_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type 		(glb_op,classType,classType) = classType
|	binop_type 		(glb_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type 		(dom_op,classType,classType) = booleanType
|	binop_type 		(dom_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type 		(dom_by_op,classType,classType) = booleanType
|	binop_type 		(dom_by_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(liked_op,stringType(min1,max1),stringType(min2,max2)) = 
					booleanType
|	binop_type 		(liked_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(maximum_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					fixedType(p1 max p2,s1 max s2)
|	binop_type 		(maximum_op,enumType(p1,t1),enumType(p2,t2)) = 
					if p1 = p2 andalso t1 = t2 
					then enumType(p1,t1)
					else raise wrongType
| 	binop_type 		(maximum_op,floatingType(m1,e1,os1),
					floatingType(m2,e2,os2)) = 
					if m1 = m2 andalso e1 = e2 andalso os1 = os2
					then floatingType(m1,e1,os1)
					else raise wrongType
|	binop_type 		(maximum_op,timeType f1,timeType f2) =
					if f1 = f2
					then timeType f1
					else raise wrongType
|	binop_type 		(maximum_op,intervalType f1,intervalType f2) =
					if f1 = f2
					then intervalType f1
					else raise wrongType
|	binop_type 		(maximum_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(minimum_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					fixedType(p1 max p2,s1 max s2)
|	binop_type 		(minimum_op,enumType(p1,t1),enumType(p2,t2)) = 
					if p1 = p2 andalso t1 = t2 
					then enumType(p1,t1)
					else raise wrongType
| 	binop_type 		(minimum_op,floatingType(m1,e1,os1),
					floatingType(m2,e2,os2)) = 
					if m1 = m2 andalso e1 = e2 andalso os1 = os2
					then floatingType(m1,e1,os1)
					else raise wrongType
|	binop_type 		(minimum_op,timeType f1,timeType f2) =
					if f1 = f2
					then timeType f1
					else raise wrongType
|	binop_type 		(minimum_op,intervalType f1,intervalType f2) =
					if f1 = f2
					then intervalType f1
					else raise wrongType
|	binop_type 		(minimum_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type 		(opr,t1,t2) = raise notDyadic;
=TEX
=SML
fun 	(Ûmonop_typeİ : Op ¸ SwordType ­ SwordType) 
			(not_op,booleanType) =  booleanType
|	monop_type	(not_op,t) = raise wrongType
=TEX
=SML
|	monop_type	(definitely_op,booleanType) =  booleanType
|	monop_type	(definitely_op,t) = raise wrongType
=TEX
=SML
|	monop_type	(possibly_op,booleanType) =  booleanType
|	monop_type	(possibly_op,t) = raise wrongType
=TEX
=SML
|	monop_type	(minus_op,fixedType(p,s)) = fixedType(p,s)
|	monop_type	(minus_op,floatingType(m,e,os)) = floatingType(m,e,os)
|	monop_type	(minus_op,intervalType f) = intervalType f
|	monop_type	(minus_op,t) = raise wrongType
=TEX
=SML
|	monop_type	(ord_op,enumType(p,t)) = fixedType(p,0)
|	monop_type	(ord_op,stringType(mini,maxi)) = fixedType(1,0)
|	monop_type	(ord_op,t) = raise wrongType
=TEX
=SML
|	monop_type	(char_op,fixedType(p,s)) = stringType(1,1)
|	monop_type	(char_op,t) = raise wrongType
=TEX
=SML
|	monop_type	(upper_op,stringType(mini,maxi)) = stringType(mini,maxi)
|	monop_type	(upper_op,t) = raise wrongType
=TEX
=SML
|	monop_type	(lower_op,stringType(mini,maxi)) = stringType(mini,maxi)
|	monop_type	(lower_op,t) = raise wrongType
=TEX
=SML
|	monop_type	(opr,t) = raise notMonadic;
=TEX
=SML
fun 	(Ûtriop_typeİ : Op ¸ SwordType  ¸ SwordType  ¸ SwordType ­ SwordType) 
			(liket_op,stringType(min1,max1),stringType(min2,max2),
							stringType(min3,max3)) =  booleanType
|	triop_type	(liket_op,t1,t2,t3) = raise wrongType
|	triop_type	(between_op,fixedType(p1,s1),fixedType(p2,s2),
							fixedType(p3,s3)) =  booleanType
|	triop_type	(between_op,floatingType(m1,e1,os1),floatingType(m2,e2,os2),
							floatingType(m3,e3,os3)) =  booleanType
|	triop_type	(between_op,stringType(min1,max1),stringType(min2,max2),
							stringType(min3,max3)) =  booleanType
|	triop_type	(between_op,enumType(p1,t1),enumType(p2,t2),enumType(p3,t3)) =
				if p1 = p2 andalso p2 = p3 andalso t1 = t2 andalso t2 = t3
				then booleanType
				else raise wrongType
|	triop_type	(between_op,timeType(f1),timeType(f2),
							timeType(f3)) = booleanType
|	triop_type	(between_op,intervalType(f1),intervalType(f2),
							intervalType(f3)) = booleanType
|	triop_type	(between_op,classType,classType,classType) = booleanType
|	triop_type	(between_op,t1,t2,t3) = raise wrongType
|	triop_type	(opr,t1,t2,t3) = raise notTriadic;
=TEX
=SML
fun 	(Ûset_func_typeİ : Op ¸ SwordType ­ SwordType) 
				(plus_op,fixedType(p,s)) = fixedType(p,s)
| 	set_func_type 		(plus_op,floatingType(m,e,os)) =  floatingType(m,e,os)
|	set_func_type 		(plus_op,intervalType f) = intervalType f
|	set_func_type 		(plus_op,t) = raise wrongType
=TEX
=SML
|	set_func_type 		(concat_op,stringType (mini,maxi)) = stringType (mini,maxi)
|	set_func_type 		(concat_op,t) = raise wrongType
=TEX
=SML
|	set_func_type 		(and_op,booleanType) = booleanType
|	set_func_type 		(and_op,t) = raise wrongType
=TEX
=SML
|	set_func_type 		(or_op,booleanType) = booleanType
|	set_func_type 		(or_op,t) = raise wrongType
=TEX
=SML
|	set_func_type 		(lub_op,classType) = classType
|	set_func_type 		(lub_op,t) = raise wrongType
=TEX
=SML
|	set_func_type 		(glb_op,classType) = classType
|	set_func_type 		(glb_op,t) = raise wrongType
=TEX
=SML
|	set_func_type		(maximum_op,fixedType(p,s)) = fixedType(p,s)
| 	set_func_type 		(maximum_op,floatingType(m,e,os)) = floatingType(m,e,os)
|	set_func_type 		(maximum_op,enumType(p,t)) = enumType(p,t)
|	set_func_type 		(maximum_op,intervalType f) =
  intervalType f
|	set_func_type 		(maximum_op,timeType f) =
  timeType f
|	set_func_type 		(maximum_op,t) = raise wrongType
=TEX
=SML
|	set_func_type		(minimum_op,fixedType(p,s)) = fixedType(p,s)
| 	set_func_type 		(minimum_op,floatingType(m,e,os)) = floatingType(m,e,os)
|	set_func_type 		(minimum_op,enumType(p,t)) = enumType(p,t)
|	set_func_type 		(minimum_op,intervalType f) =
  intervalType f
|	set_func_type 		(minimum_op,timeType f) = timeType f
|	set_func_type 		(minimum_op,t) = raise wrongType
=TEX
=SML
|	set_func_type		(average_op,fixedType(p,s)) = fixedType(p,s)
| 	set_func_type 		(average_op,floatingType(m,e,os)) = floatingType(m,e,os)
|	set_func_type 		(average_op,intervalType f) =
  intervalType f
|	set_func_type 		(average_op,t) = raise wrongType;
=TEX	
=SML
fun 	(Ûcheck_booleanİ : ExpType ­ ExpType) (booleanType,w) = (booleanType,w)
|	check_boolean 		(t,w) = raise wrongType;
=TEX
=SML
fun 	(Ûcheck_type_conversionİ : SwordType ¸ SwordType ­ unit)
				(nullType,t) = ()
|	check_type_conversion	(stringType(min1,max1),stringType(min2,max2)) = ()
|	check_type_conversion	(stringType(mini,maxi),fixedType(p,s)) = ()
|	check_type_conversion	(stringType(mini,maxi),floatingType(m,e,os)) = ()
|	check_type_conversion	(stringType(mini,maxi),timeType f) = ()
|	check_type_conversion	(stringType(mini,maxi),intervalType f) = ()
|	check_type_conversion	(stringType(mini,maxi),enumType(p,t)) = ()
|	check_type_conversion	(stringType(mini,maxi),codeType) = ()
=TEX
=SML
|	check_type_conversion	(fixedType(p,s),stringType(mini,maxi)) = ()
|	check_type_conversion	(fixedType(p1,s1),fixedType(p2,s2)) = ()
|	check_type_conversion	(fixedType(p,s),floatingType(m,e,os)) = ()
=TEX
=SML
|	check_type_conversion	(floatingType(m,e,os),stringType(mini,maxi)) = ()
|	check_type_conversion	(floatingType(m,e,os),fixedType(p,s)) = ()
|	check_type_conversion	(floatingType(m1,e1,os1),floatingType(m2,e2,os2)) = ()
=TEX
=SML
|	check_type_conversion	(timeType f,stringType(mini,maxi)) = ()
|	check_type_conversion	(intervalType f,stringType(mini,maxi)) = ()
=TEX
=SML
|	check_type_conversion	(enumType(p,t),stringType(mini,maxi)) = ()
=TEX
=SML
|	check_type_conversion	(timeType f1,timeType f2) = ()
=TEX
=SML
|	check_type_conversion	(intervalType f1,intervalType f2) = ()
=TEX
=SML
|	check_type_conversion	(codeType,stringType(mini,maxi)) = ()
=TEX
=SML
|	check_type_conversion	(anyType,t) = ()
|	check_type_conversion	(t,anyType) = ()
=TEX
=SML
|	check_type_conversion 	(t1,t2) = raise wrongType;
=TEX
=SML
fun 	(Ûcheck_type_conversionèdomainêİ : SwordType ¸ SwordType ­ unit)
						(stringType(min1,max1),timeType f) = ()
|	check_type_conversionèdomainê		(stringType(min1,max1),classType) = ()
|	check_type_conversionèdomainê		(timeType f,stringType(min1,max1)) = ()
|	check_type_conversionèdomainê		(classType,stringType(min1,max1)) = ()
|	check_type_conversionèdomainê 		(t1,t2) = raise wrongType;
=TEX
=SML
fun 	(Ûconvertècol_specêİ : Col_specèssqlê ­ ColumnSpecification) 
				(denote_col_spec‰s col) = anonymous_column col
| 	convertècol_specê 	(absolute_col_spec‰s(dir,tab,col)) = 
					specific(absolute(dir,tab),col)
| 	convertècol_specê 	(default_col_spec‰s(up,dir,tab,col)) = 
					specific(default(up,dir,tab),col);
=TEX
=SML
fun 	(Ûclass_columnİ : Col_specèssqlê­ (Col_specètsqlê,Class)Sum) cs = 
	case 	(lookup‰c‰o‰l‰_‰s‰p‰e‰c‰_‰c‰l‰a‰s‰s(true,convertècol_specê cs)) of 
		(local_identifier name, lub_cl) => inL(denote_col_spec‰t name)
	|	(column(gen_corr,gen_col), lub_cl) => 
						inL(absolute_col_spec‰t([],gen_corr,gen_col))
	|	(constant_class cl, lub_cl) => inR cl
	| 	(constant_null, lub_cl) => raise internalError;		
=TEX
=SML
fun 	(Ûdenote_nameİ : TsqlRepr ­ Valueètsqlê)
			(local_identifier s) = contents‰t(denote_col_spec‰t s)
| 	denote_name	(column(cn,col)) = contents‰t(absolute_col_spec‰t ([],cn,col))
| 	denote_name	(constant_class c) = denote_class‰t c
| 	denote_name	constant_null = denote_null‰t;
=TEX	
=SML
fun 	(Ûcolumn_data_testİ : Col_specèssqlê ­ Valueètsqlê list) cs =
		let	val (tr,u) = lookup‰c‰o‰l‰_‰s‰p‰e‰c‰_‰c‰l‰a‰s‰s(false,convertècol_specê cs) 
		in
		if 	client_clearance()  dom u
		then []
		else	let val cc = denote_class‰t(client_clearance())
			in	[binop‰t(dom_op,(cc,denote_name tr))]
			end
		end;
=TEX	
=SML
fun 	(Ûcol_expİ : ExpType ­ ColType) 
			(t,dinary) = (nullType,t)
|	col_exp		(t,sterling) = (t,nullType)
|	col_exp		(t,worthless) = (t,nullType)	
|	col_exp		(t,priceless) = raise wrongType;
=TEX	
=SML
fun 	(Ûcol_targetİ : SsqlCol ­ TsqlCol) sc =
	let 	fun 	(bound : BoundInfo ­ TsqlClassName) (upb c) =  anonètcê
		| 	bound (constant c) = constantètcê c
		fun 	(target : ColType ¸ TsqlClassName ­ TsqlCol)
				((nullType,nullType),c) = raise internalError
		| 	target	((s,nullType),c) = 	{sterling_name = anon‰t,
							dinary_name = none‰t,
							class_name = c}
		| 	target 	((nullType,d),c) = 	{sterling_name = none‰t,
							dinary_name = anon‰t,
							class_name = c}
		| 	target 	((s,d),c) = 		{sterling_name = anon‰t,
							dinary_name = anon‰t,
							class_name = c}
	in 	target(#type_field sc,bound(#col_class sc))
	end;
=TEX
=SML
fun 	(Ûconvertètable_specêİ : Table_spec ­ TableSpecification) 
				(absolute_table_spec‰s(dir,tab)) = absolute(dir,tab)
| 	convertètable_specê 	(default_table_spec‰s(up,dir,tab)) = default(up,dir,tab);
=TEX
=SML
fun 	(Ûconstant_valueètypeêİ : Constant_valueèssqlê ­ SwordType) 
				denote_null‰s = nullType
| 	constant_valueètypeê	denote_void‰s = monoleanType
| 	constant_valueètypeê	denote_true‰s = booleanType
| 	constant_valueètypeê	denote_false‰s = booleanType
| 	constant_valueètypeê	(denote_string‰s(s,string_type‰s(mini,maxi))) = 
					(if mini <= size s andalso size s <= maxi
					then stringType(mini,maxi)
					else raise wrongType)
| 	constant_valueètypeê	(denote_fixed‰s(f,fixed_type‰s(p,s))) = 
					(if check_fixed(f,p,s)
					then fixedType(p,s)
					else raise wrongType)
| 	constant_valueètypeê	(denote_floating‰s(f,floating_type‰s(m,e,os))) = 
					(if check_floating(f,m,e,os)
					then floatingType(m,e,os)
					else raise wrongType)
| 	constant_valueètypeê	(denote_enum‰s(e,enum_type‰s(p,t))) = 
					(if check_enum(e,p,t)
					then enumType(p,convertètable_specê t)
					else raise wrongType)
| 	constant_valueètypeê	(denote_time‰s(tm,time_type‰s f)) = 
					(if check_time(tm,f)
					then timeType f
					else raise wrongType)
| 	constant_valueètypeê	(denote_interval‰s(i,interval_type‰s f)) = 
					(if check_interval(i,f)
					then intervalType f
					else raise wrongType)
| 	constant_valueètypeê	(denote_class‰s c) = classType
| 	constant_valueètypeê	(denote_code‰s c) = codeType
| 	constant_valueètypeê	other = raise wrongType;
=TEX
=SML
fun 	(Ûconvertèssql_typeêİ : Typeèssqlê ­ SwordType)
	 			monolean_type‰s = monoleanType
|	convertèssql_typeê 	boolean_type‰s = booleanType
|	convertèssql_typeê 	(string_type‰s(mini,maxi)) = stringType(mini,maxi)
|	convertèssql_typeê 	(fixed_type‰s(p,s)) = fixedType(p,s)
|	convertèssql_typeê 	(floating_type‰s(m,e,os)) = floatingType(m,e,os)
|	convertèssql_typeê 	(enum_type‰s(p,t)) = enumType(p,convertètable_specê(t))
|	convertèssql_typeê 	(time_type‰s f) = timeType f
|	convertèssql_typeê 	(interval_type‰s f) = intervalType f
|	convertèssql_typeê 	class_type‰s = classType
|	convertèssql_typeê 	code_type‰s = codeType
|	convertèssql_typeê 	any_type‰s = anyType;
=TEX
=SML
fun 	(ÛconvertètableSpecificationêİ :TableSpecification ­ Table_specètsqlê)
				(absolute(directory,table)) = absolute_table_spec‰t(directory,table)
|	convertètableSpecificationê	(default(up,directory,table)) = 
		let 	fun 	(backUp : string list ¸ int ­ string list)(dir,0) = dir
			|	backUp (dir,n) = if n > 0 andalso length dir > 0
						then backUp(rev(tl(rev dir)),n - 1)
						else raise noSuchDirectory
			val 	dir = backUp(default_directory(),up) @ directory 
		in	absolute_table_spec‰t(dir,table)
		end;
=TEX
=SML
local	 fun	(dot : string ­ string) s = s ^ "."
in
fun 	(Ûtable_nameİ : TableSpecification ­ string)
			(absolute([],tab)) = tab
|	table_name	(absolute(dir,tab)) = (fold  (op ^)(map dot dir)) ^ tab
|	table_name 	(default(up,[],tab)) =  implode(seq(up,"-")) ^ tab
|	table_name 	(default(up,dir,tab)) =  implode(seq(up,"-")) 
					^ (fold  (op ^)(map dot dir)) ^ tab
end;
=TEX
=SML
fun 	(Ûconvertèsword_typeêİ : SwordType ­ Typeètsqlê)
				nullType = raise internalError
|	convertèsword_typeê	monoleanType = monolean_type‰t
|	convertèsword_typeê 	booleanType = boolean_type‰t 
|	convertèsword_typeê 	(stringType(mini,maxi)) = string_type‰t(mini,maxi)
|	convertèsword_typeê 	(fixedType(p,s)) = fixed_type‰t(p,s)
|	convertèsword_typeê 	(floatingType(m,e,os)) = floating_type‰t(m,e,os)
|	convertèsword_typeê 	(enumType(p,t)) = enum_type‰t(p,table_name t)
|	convertèsword_typeê 	(timeType f) = time_type‰t f
|	convertèsword_typeê 	(intervalType f) = interval_type‰t f
|	convertèsword_typeê 	classType = class_type‰t 
|	convertèsword_typeê 	codeType = code_type‰t 
|	convertèsword_typeê 	anyType = any_type‰t;
=TEX
=SML
fun 	(Ûconvertètypeêİ : Typeèssqlê ­ Typeètsqlê) t = convertèsword_typeê(convertèssql_typeê(t));
=TEX
=SML
fun 	(Ûdenoteèclass_expêİ : ExpClass ­ Valueètsqlê) 
				(variable(v,c)) = v
|	denoteèclass_expê		(constantèecê c) = denote_class‰t c;
=TEX
=SML
fun 	(Ûlubèbound_infoêİ : BoundInfo ¸ BoundInfo ­ BoundInfo)
				(upb c1,upb c2) = upb(c1 lub c2)
|	lubèbound_infoê		(constant c1,upb c2) = upb(c1 lub c2)
|	lubèbound_infoê		(upb c1,constant c2) = upb(c1 lub c2)
|	lubèbound_infoê		(constant c1,constant c2) =	if c1 = c2 then constant c1
								else upb(c1 lub c2);
=TEX
=SML
fun 	(Ûlubèexp_classêİ : ExpClass ¸ ExpClass ­ ExpClass)
				(variable(v1,c1),constantèecê c2) =
					variable(binop‰t(lub_op,(v1,denote_class‰t c2)),c1 lub c2)
|	lubèexp_classê 		(constantèecê c1,constantèecê c2) =
					constantèecê(c1 lub c2)
|	lubèexp_classê 		(constantèecê c1,variable(v2,c2)) =
					variable(binop‰t(lub_op,(v2,denote_class‰t c1)),c1 lub c2)
|	lubèexp_classê 		(variable(v1,c1),variable(v2,c2)) =
					variable(binop‰t(lub_op,(v1,v2)),c1 lub c2);
=TEX
=SML
fun 	(Ûlubètypeêİ : SwordType ¸ SwordType ­ SwordType)(t1,t2) = 	
	if t1 = t2 
	then t1
	else 	case(t1,t2) of
			(stringType(min1,max1),stringType(min2,max2)) => 
				stringType(min1 min min2,max1 max max2)
		|	(fixedType(p1,s1),fixedType(p2,s2)) => 
				fixedType(p1 max p2,s1 max s2)
		|	 _ => raise wrongType;
=TEX
=SML
fun 	(Ûlubècol_typeêİ : ColType ¸ ColType ­ ColType)
			((s1,d1),(s2,d2)) = (lubètypeê(s1,s2),lubètypeê(d1,d2));

=TEX
The exception $designError$ is raised in the following definition. Without the last clause, pattern matching is 
not exhaustive, although the case of $(dinary,dinary)$, say, 
is caught by the $if$.
=SML
exception designError of string;
fun 	(Ûlubèworthêİ : Worth ¸ Worth ­ Worth)(w1,w2) = 
	if w1 = w2 
	then w1
	else 	case(w1,w2) of
			(w1,worthless) => w1
		|	(worthless,w2) => w2
		|	(priceless,w2) => priceless
		|	(w1,priceless) => priceless
		|	(dinary,sterling) => priceless
		|	(sterling,dinary) => priceless
		|	_ => raise designError "lubèworthê";
=TEX
=SML
fun 	(Ûlubèexpêİ : ExpType ¸ ExpType ­ ExpType)
			((t1,w1),(t2,w2)) = (lubètypeê(t1,t2),lubèworthê(w1,w2));
=TEX
=SML
fun 	(Ûlubèssql_nameêİ : SsqlName ¸ SsqlName ­ SsqlName)
			(name‰s s1,name‰s s2) = 	if s1 = s2 then name‰s s1
							else anon‰s
|	lubèssql_nameê	(sn1,sn2) = anon‰s;
=TEX
=SML
fun 	(Ûlubèssql_colêİ : SsqlCol ¸ SsqlCol ­ SsqlCol)
	({name = n1,type_field = t1,col_exist = ce1,col_class = cc1},
		{name = n2,type_field = t2,col_exist = ce2,col_class = cc2}) 
		=  
		{name = lubèssql_nameê(n1,n2),
		type_field = lubècol_typeê(t1,t2),
		col_exist = ce1 lub ce2,
		col_class = lubèbound_infoê(cc1,cc2)};
=TEX
=SML
fun 	(Ûlub‰t‰a‰b‰l‰e‰i‰n‰f‰oİ : TableInfo ¸ TableInfo ­ TableInfo)
	({table_exist_class = tec1,table_class = tc1,row_class = rc1},
		{table_exist_class = tec2,table_class = tc2,row_class = rc2}) 
		=  
		{table_exist_class = tec1 lub tec2,
		table_class = tc1 lub tc2,
		row_class = lubèbound_infoê(rc1,rc2)};
=TEX
=SML
fun 	(Ûlubètsql_class_nameêİ : TsqlClassName ¸ TsqlClassName ­ TsqlClassName)
				(nameètcê s1,nameètcê s2) = 	if s1 = s2 then nameètcê s1
								else anonètcê
|	lubètsql_class_nameê	(constantètcê c1,constantètcê c2) = 	if c1 = c2 then constantètcê c1
									else anonètcê
|	lubètsql_class_nameê	(x,y) = anonètcê;
=TEX
=SML
fun 	(Ûlubètsql_nameêİ : TsqlName ¸ TsqlName ­ TsqlName)
			(name‰t s1,name‰t s2) =	if s1 = s2 then name‰t s1
							else anon‰t
|	lubètsql_nameê	(none‰t,none‰t) = none‰t
|	lubètsql_nameê	(tn1,tn2) = anon‰t;
=TEX			
=SML
fun 	(Ûlubètsql_colêİ : TsqlCol ¸ TsqlCol ­ TsqlCol)
	({sterling_name = s1,dinary_name= d1,class_name = c1},
		{sterling_name = s2,dinary_name= d2,class_name = c2}) 
		=  
		{sterling_name = lubètsql_nameê(s1,s2),
		dinary_name = lubètsql_nameê(d1,d2),
		class_name = lubètsql_class_nameê(c1,c2)};
=TEX
=SML
local	fun	(data_col : TsqlName ¸ TsqlName ­ Select_valueètsqlê list)
				(none‰t,none‰t) = []
	|	data_col	(name‰t s,anon‰t) = 
						[anonymous_value‰t(contents‰t(denote_col_spec‰t s))]
	|	data_col	(name‰t fs,name‰t ts) = 
						[anonymous_value‰t(contents‰t(denote_col_spec‰t fs))]
	|	data_col	(none‰t,anon‰t) = [anonymous_value‰t(denote_null‰t)]
	|	data_col	(anon‰t,none‰t) = [anonymous_value‰t(denote_null‰t)]
	|	data_col	(n1,n2) = raise internalError
	fun	(class_col : TsqlClassName ¸ TsqlClassName ­ Select_valueètsqlê list)
				(constantètcê fc,constantètcê tc) =	if fc = tc then []
								else raise internalError
	|	class_col	(nameètcê f,nameètcê tn) =
						[anonymous_value‰t(contents‰t(denote_col_spec‰t f))]
	|	class_col	(constantètcê fc,nameètcê tn) =
						[anonymous_value‰t(denote_class‰t fc)]
	|	class_col	(nameètcê f,anonètcê) =
						[anonymous_value‰t(contents‰t(denote_col_spec‰t f))]
	|	class_col	(constantètcê fc,anonètcê) =
						[anonymous_value‰t(denote_class‰t fc)]
	|	class_col	(c1,c2) = raise internalError
in
fun 	(Ûmakeèsvêİ : TsqlCol ¸ TsqlCol ­ Select_valueètsqlê list)(f,t) =
		data_col(#sterling_name f,#sterling_name t) @
		data_col(#dinary_name f,#dinary_name t) @
		class_col(#class_name f,#class_name t)
end;
=TEX
=SML
fun 	(Ûremove_constantsİ : (Col_specètsqlê,Class)Sum list ­ Col_specètsqlê list) [] = []
|	remove_constants ((inL c) :: s) = c :: (remove_constants s)
|	remove_constants ((inR c) :: s) = remove_constants s;
=TEX
=SML
fun 	(Ûremove_nullsİ : TsqlRepr list ­ TsqlRepr list) [] = []
|	remove_nulls (constant_null :: trs) = remove_nulls trs
|	remove_nulls (x :: trs) = x :: (remove_nulls trs);
=TEX
=SML
fun 	(Ûupperİ : ExpClass ­ Class)
		(variable(c,u)) = u
|	upper	(constantèecê u) = u;
=TEX
=SML
local	fun	(make_case : Valueètsqlê ¸ ExpClass ­ Valueètsqlê)
			(data,variable(c,u)) = case‰t(	[data], 
							[denote_class‰t(lattice_top())],
							c)
	|	make_case(data,constantèecê c) = case‰t(	[data], 
								[denote_class‰t(lattice_top())],
								denote_class‰t c)
in		
fun 	(Ûsimplifyèandsêİ : Valueètsqlê list ¸ ExpClass list ­ Valueètsqlê ¸ ExpClass)
	(vs,cs) =	
		let	val v = fold(curry binop‰t and_op)vs
			val c = case‰t(	[v],
					[fold(curry binop‰t lub_op)(map denoteèclass_expê cs)],
					fold(curry binop‰t glb_op)(at2 (map make_case) (vs,cs)))
			val u = fold (op lub)(map upper cs)
		in 	(v,variable(c,u))
		end
end;
=TEX
=SML
local	fun	(make_case : Valueètsqlê ¸ ExpClass ­ Valueètsqlê)
			(data,variable(c,u)) = case‰t(	[data], 
							[denote_class‰t(lattice_top())],
							c)
	|	make_case(data,constantèecê c) = case‰t(	[data], 
								[denote_class‰t(lattice_top())],
								denote_class‰t c)
in		
fun 	(Ûsimplifyèorsêİ : Valueètsqlê list ¸ ExpClass list ­ Valueètsqlê ¸ ExpClass)
	(vs,cs) =	
		let	val v = fold(curry binop‰t and_op)vs
			val c = case‰t(	[v],
					[fold(curry binop‰t glb_op)(at2 (map make_case) (vs,cs))],
					fold(curry binop‰t lub_op)(map denoteèclass_expê cs))
			val u = fold (op lub)(map upper cs)
		in 	(v,variable(c,u))
		end
end;
=TEX
=SML
fun 	(Ûconstant_valueèdataêİ : Constant_valueèssqlê ­ Valueètsqlê)
				denote_null‰s = denote_null‰t
|	constant_valueèdataê 	denote_void‰s = denote_void‰t
|	constant_valueèdataê 	denote_true‰s = denote_true‰t
|	constant_valueèdataê 	denote_false‰s = denote_false‰t
|	constant_valueèdataê 	(denote_string‰s (s,t)) = 
								denote_string‰t (s,convertètypeê t)
|	constant_valueèdataê	(denote_fixed‰s (f,t)) = 
								denote_fixed‰t (f,convertètypeê t)
|	constant_valueèdataê	(denote_floating‰s (f,t)) = 
								denote_floating‰t (f,convertètypeê t)
|	constant_valueèdataê	(denote_enum‰s (e,t)) = 
								denote_enum‰t (e,convertètypeê t)
|	constant_valueèdataê	(denote_time‰s (tm,t)) = 
								denote_time‰t (tm,convertètypeê t)
|	constant_valueèdataê	(denote_interval‰s (i,t)) = 
								denote_interval‰t (i,convertètypeê t)
|	constant_valueèdataê	(denote_class‰s c) = denote_class‰t c
|	constant_valueèdataê	(denote_code‰s c) = denote_code‰t c;
=TEX
=SML
local	fun 	(look : Col_specèssqlê ­ TsqlRepr)
			cs = lookup‰c‰o‰l‰_‰s‰p‰e‰c‰_‰d‰i‰n‰a‰r‰y(false,convertècol_specê cs)
in
fun 	(Ûdinary_columnsİ : Col_specèssqlê list ­ Col_specètsqlê list)
		css = map repr_col (remove_nulls(map look css))
end;
=TEX
=SML
local	fun 	(look : Col_specèssqlê ­ TsqlRepr)
			cs = lookup‰c‰o‰l‰_‰s‰p‰e‰c‰_‰s‰t‰e‰r‰l‰i‰n‰g(false,convertècol_specê cs)
in
fun 	(Ûsterling_columnsİ : Col_specèssqlê list ­ Col_specètsqlê list)
		css = map repr_col (remove_nulls(map look css))
end;
=TEX
=SML
fun 	(Ûtuple_listèmax_row_classêİ : Tuple_listèssqlê ­ ExpClass) 
			t = constantèecê(client_clearance());
=TEX
=SML			
fun 	(Ûupb_row_classİ : TableInfo ­ Class)
			{table_exist_class=tec,table_class=tc,row_class=upb rc} = rc
|	upb_row_class	{table_exist_class=tec,table_class=tc,row_class=constant rc} = rc;
=TEX
In the following, the specifications of $internal\_valueèclassê$  and 
$value\_type$  are incomplete. ($all\_binop$, 
$some\_binop$, $all\_binop\_list$ and $some\_binop\_list$ 
are missing from $internal\_valueèclassê$ and $caseVal$ is 
missing from $value\_type$.)

=SML
fun 	(Ûvalueèdataêİ : Valueèssqlê ­ Valueètsqlê)
			(denote_constant‰s  c) = constant_valueèdataê c
=TEX
=SML
|	valueèdataê	(monop‰s (opr,v)) = monop‰t (opr,valueèdataê v)
|	valueèdataê	(binop‰s (opr,(v1,v2))) = binop‰t (opr,(valueèdataê v1,valueèdataê v2))
|	valueèdataê	(triop‰s (opr,(v1,v2,v3))) = triop‰t (opr,(valueèdataê v1,
								valueèdataê v2,valueèdataê v3))
=TEX
=SML
|	valueèdataê	(convert‰s (v,t)) = convert‰t (valueèdataê v,convertètypeê t)
|	valueèdataê	(convert_domain‰s (v,domain,t)) =
			let 	val ts = convertètable_specê domain
				val tn = table_name ts
			in convert_domain‰t (tn,(valueèdataê v,convertètypeê t))
			end
=TEX
=SML
|	valueèdataê	(make_sterling‰s v) = valueèdataê v
| 	valueèdataê	(make_dinary‰s v) = valueèdataê v
=TEX
=SML
|	valueèdataê	(declare‰s (id,(v1,v2))) =
			in_new_scope(fn () =>
			let 	val t1 = valueètypeê v1
				val data1 = valueèdataê v1
				val class1 = valueèclassê v1
				val data2 = valueèdataê v2
			in	case class1 of
					variable (c,u) => 
					let	val (cn,dn) = enter‰i‰d‰e‰n‰t‰i‰f‰i‰e‰r(id,t1,u)
					in	declare‰t (cn,(c,declare‰t(dn,(data1,data2)))) 
					end
				| 	constantèecê c =>
					let	val dn =  enter‰i‰d‰e‰n‰t‰i‰f‰e‰r‰_‰c‰o‰n‰s‰t‰a‰n‰t‰_‰c‰l‰a‰s‰s(id,t1,c)
					in declare‰t(dn,(data1,data2)) 
					end
			end)
=TEX
=SML
| 	valueèdataê	(caseVal‰s (test,caseList,valList,elseVal)) = caseVal‰t(valueèdataê test,
									map valueèdataê caseList,
									map valueèdataê valList,
									valueèdataê elseVal)
| 	valueèdataê	(case‰s (caseList,valList,elseVal)) = case‰t(map valueèdataê caseList,
									map valueèdataê valList,
									valueèdataê elseVal)
=TEX
=SML
|	valueèdataê	(set_func_all‰s (opr,v)) = set_func_all‰t (opr,valueèdataê v)
|	valueèdataê	(set_func_distinct‰s (opr,v)) = set_func_distinct‰t (opr,valueèdataê v)
|	valueèdataê	(count_non_null‰s (v,t)) = count_non_null‰t (valueèdataê v,convertètypeê t)
|	valueèdataê	(count_distinct‰s (v,t)) = count_distinct‰t (valueèdataê v,convertètypeê t)
|	valueèdataê	(count_all‰s t) = count_all‰t (convertètypeê t)
=TEX
=SML
|	valueèdataê	(all_binop‰s (opr,(v,vs))) = all_binop‰t (opr,(valueèdataê v,tuple_listèdataê vs))
|	valueèdataê	(some_binop‰s (opr,(v,vs))) = 
					some_binop‰t (opr,(valueèdataê v,tuple_listèdataê vs))
|	valueèdataê	(all_binop_list‰s (opr,(v,vs))) = 
					all_binop_list‰t (opr,(valueèdataê v,map valueèdataê vs))
|	valueèdataê	(some_binop_list‰s (opr,(v,vs))) = 
					some_binop_list‰t (opr,(valueèdataê v,map valueèdataê  vs))
|	valueèdataê	(exists_tuples‰s tuples) = exists_tuples‰t (tuple_listèdataê tuples)
|	valueèdataê	(single_value‰s v) = single_value‰t (tuple_listèdataê v)
=TEX
=SML
|	valueèdataê	(contents‰s cs) = 
				(case lookup‰c‰o‰l‰_‰s‰p‰e‰c‰_‰s‰t‰e‰r‰l‰i‰n‰g(false,convertècol_specê cs) of
					constant_null => denote_null‰t
				|	tr => contents‰t(repr_col tr))
|	valueèdataê	(sterling_contents‰s cs) = 
				(case lookup‰c‰o‰l‰_‰s‰p‰e‰c‰_‰s‰t‰e‰r‰l‰i‰n‰g(false,convertècol_specê cs) of
					constant_null => denote_null‰t
				|	tr => contents‰t(repr_col tr))
|	valueèdataê	(dinary_contents‰s cs) = 
				(case lookup‰c‰o‰l‰_‰s‰p‰e‰c‰_‰d‰i‰n‰a‰r‰y(false,convertècol_specê cs) of
					constant_null => denote_null‰t
				|	tr => contents‰t(repr_col tr))
=TEX
=SML
|	valueèdataê	(classification‰s col) = 	let val 	cs = class_column col
							in 	if isL cs then (contents‰t(getL cs))
								else denote_class‰t (getR cs)
							end

=TEX
=SML
|	valueèdataê	(row_existence‰s t) = 	
				let 	val	ts = convertètable_specê t
 					val	rc = lookup‰t‰a‰b‰l‰e‰_‰r‰o‰w‰_‰c‰l‰a‰s‰s(false,ts)
				in  denote_name rc
				end
=TEX
=SML
|	valueèdataê	joined_row_existence‰s = 	
				let val 	ns = lookup‰l‰o‰c‰a‰l‰_‰r‰o‰w‰_‰c‰l‰a‰s‰s‰e‰s()
				in (fold(curry binop‰t lub_op)(map denote_name ns))
				end
=TEX
=SML
|	valueèdataê	(classify‰s(v,c)) = valueèdataê v
|	valueèdataê	(classify_default‰s v) = valueèdataê v
=TEX
=SML
|	valueèdataê	(observed‰s(n,c)) = raise notTrigger
|	valueèdataê	(modified‰s n) = raise notTrigger
=TEX
=SML
|	valueèdataê	(context‰s s) = 	let val  (cv,class) = contextual_data s
						in	constant_valueèdataê cv 
						end
|	valueèdataê	(parameter‰s name) = 	let val  (cv,class) = lookup‰p‰a‰r‰a‰m‰_‰d‰a‰t‰a name
							in	constant_valueèdataê cv 
							end
=TEX
=SML
and 	(Ûvalueètypeêİ : Valueèssqlê ­ ExpType)
			(denote_constant‰s c) = (constant_valueètypeê c,worthless)
=TEX
=SML
|	valueètypeê	(monop‰s (opr,v)) = 	let val (t,w) = valueètypeê v
						in (monop_type(opr,t),w)
						end
=TEX
=SML
|	valueètypeê	(binop‰s (opr,(v1,v2))) = 	let 	val (t1,w1) = valueètypeê v1
								val (t2,w2) = valueètypeê v2
							in (binop_type (opr,t1,t2),lubèworthê(w1,w2))
							end
=TEX
=SML
|	valueètypeê	(triop‰s (opr,(v1,v2,v3))) = 
				let 	val (t1,w1) = valueètypeê v1
					val (t2,w2) = valueètypeê v2
					val (t3,w3) = valueètypeê v3
				in (triop_type (opr,t1,t2,t3),lubèworthê(w1,lubèworthê(w2,w3)))
				end
=TEX
=SML
|	valueètypeê	(convert‰s (v,t)) = 	let 	val st = convertèssql_typeê t
							val (ty,w) = valueètypeê v
							val ok = check_type_conversionèdomainê(ty,st)
						in (st,w)
						end
=TEX
=SML
|	valueètypeê	(convert_domain‰s (v,domain,t)) =
						let 	val st = convertèssql_typeê t
							val (ty,w) = valueètypeê v
							val ok = check_type_conversionèdomainê(ty,st)
						in (st,w)
						end
=TEX
=SML
|	valueètypeê	(make_sterling‰s v) = 	let val (t,w) = valueètypeê v
						in (t,sterling)
						end
=TEX
=SML
|	valueètypeê	(make_dinary‰s v) = 	let val (t,w) = valueètypeê v
						in (t,dinary)
						end
=TEX
=SML
|	valueètypeê	(declare‰s (id,(v1,v2))) = 	
					let	val et = valueètypeê v1
						val cl = lattice_top()
					in
					in_new_scope(fn () => 
						let val i = enter‰i‰d‰e‰n‰t‰i‰f‰e‰r‰_‰c‰o‰n‰s‰t‰a‰n‰t‰_‰c‰l‰a‰s‰s(id,et,cl)
						in valueètypeê v2 
						end)
					end
=TEX
=SML		
|	valueètypeê	(case‰s (caseList,valList,elseVal)) = 
				let	val  ok =  map check_boolean(map valueètypeê caseList)
				in 	fold lubèexpê(map valueètypeê (valList @ [elseVal]))
				end
=TEX
=SML
|	valueètypeê	(set_func_all‰s(opr,v)) = 	let val (t,w) = valueètypeê v
							in 
							(set_func_type(opr,t),w)
							end
|	valueètypeê	(set_func_distinct‰s(opr,v)) = 	let val (t,w) = valueètypeê v
								in 
								(set_func_type(opr,t),w)
								end
=TEX
=SML
|	valueètypeê	(count_non_null‰s(v,t))	=	
					let 	val st = convertèssql_typeê t
						val (t,w) = valueètypeê v
					in 	case st of
							fixedType(p,s) => (st,worthless)
						| 	other => raise wrongType
					end
|	valueètypeê	(count_distinct‰s(v,t))	=	
					let 	val st = convertèssql_typeê t
						val (t,w) = valueètypeê v
					in 	case st of
							fixedType(p,s) => (st,worthless)
						| 	other => raise wrongType
					end
=TEX
=SML
|	valueètypeê	(count_all‰s t)	=	let 	val st = convertèssql_typeê t
						in 	case st of
								fixedType(p,s) => (st,worthless)
							| 	other => raise wrongType
						end
=TEX
=SML						
|	valueètypeê	(all_binop‰s (opr,(v,vs))) =	
			let 	val tt = tuple_listètypeê vs
			in 	if length tt <> 1 then raise tooWide
				else	let	val (t1,w1) = valueètypeê v
						val (t2,w2) = hd tt
					in (binop_type(opr,t1,t2),lubèworthê(w1,w2))
					end
			end
					
|	valueètypeê	(some_binop‰s (opr,(v,vs))) =	
			let 	val tt = tuple_listètypeê vs
			in 	if length tt <> 1 then raise tooWide
				else	let	val (t1,w1) = valueètypeê v
						val (t2,w2) = hd tt
					in (binop_type(opr,t1,t2),lubèworthê(w1,w2))
					end
			end
=TEX
=SML	
|	valueètypeê	(all_binop_list‰s (opr,(v,vs))) =
			let	fun (binop_exp : Op ¸ ExpType ¸ ExpType ­ ExpType)
					(opr,(t1,w1),(t2,w2)) = 
						(binop_type(opr,t1,t2),lubèworthê(w1,w2))
				val ets2 = map valueètypeê vs
				val ets1 = seq(length ets2,valueètypeê v)
			in fold lubèexpê (at3(map binop_exp) (seq(length ets2,opr),ets1,ets2))
			end
|	valueètypeê	(some_binop_list‰s (opr,(v,vs))) =
			let	fun (binop_exp : Op ¸ ExpType ¸ ExpType ­ ExpType)
					(opr,(t1,w1),(t2,w2)) = 
						(binop_type(opr,t1,t2),lubèworthê(w1,w2))
				val ets2 = map valueètypeê vs
				val ets1 = seq(length ets2,valueètypeê v)
			in fold lubèexpê (at3(map binop_exp) (seq(length ets2,opr),ets1,ets2))
			end
=TEX
=SML	
|	valueètypeê	(exists_tuples‰s tuples) =
			let	val tt = tuple_listètypeê tuples
			in 	(booleanType,worthless)
			end
=TEX
=SML	
|	valueètypeê	(single_value‰s tuples) =
			let	val tt = tuple_listètypeê tuples
			in 	if length tt <> 1 then raise tooWide
				else	hd tt
			end
=TEX
=SML	
|	valueètypeê	(contents‰s cs) =
			let	val (ti,sc) = lookup‰c‰o‰l‰u‰m‰n‰_‰i‰n‰f‰o (convertècol_specê cs)
			in 	(case (#type_field sc) of
					(nullType,nullType) => (nullType,sterling)
				|	(st,nullType) => (st,sterling)
				|	(nullType,dt) => (dt,dinary)
				|	(st,dt) => (st,sterling))
			end
=TEX
=SML	
|	valueètypeê	(sterling_contents‰s cs) =
			let	val (ti,sc) = lookup‰c‰o‰l‰u‰m‰n‰_‰i‰n‰f‰o (convertècol_specê cs)
			in 	(case (#type_field sc) of
					(nullType,nullType) => (nullType,sterling)
				|	(st,nullType) => (st,sterling)
				|	(nullType,dt) => raise wrongWorth
				|	(st,dt) => (st,sterling))
			end
=TEX
=SML	
|	valueètypeê	(dinary_contents‰s cs) =
			let	val (ti,sc) = lookup‰c‰o‰l‰u‰m‰n‰_‰i‰n‰f‰o (convertècol_specê cs)
			in 	(case (#type_field sc) of
					(nullType,nullType) => (nullType,dinary)
				|	(st,nullType) => raise wrongWorth
				|	(nullType,dt) => (dt,dinary)
				|	(st,dt) => (dt,dinary))
			end
=TEX
=SML
|	valueètypeê	(classification‰s col) = (classType,worthless)
|	valueètypeê	(row_existence‰s t) = (classType,worthless)
|	valueètypeê	joined_row_existence‰s = (classType,worthless)	
|	valueètypeê	(classify‰s(v,c)) = 	(case valueètypeê c of
							(classType,w) => valueètypeê v
						|	(other,w) => raise wrongType)
|	valueètypeê	(classify_default‰s v) = valueètypeê v
|	valueètypeê	(observed‰s(n,c)) = raise onlyInTriggers
|	valueètypeê	(modified‰s n) = raise onlyInTriggers
|	valueètypeê	(context‰s s) = 	let val  (cv,class) = contextual_data s
						in	(constant_valueètypeê cv,worthless) 
						end
|	valueètypeê	(parameter‰s name) = 	let val  (cv,class) = lookup‰p‰a‰r‰a‰m‰_‰d‰a‰t‰a name
							in	(constant_valueètypeê cv,worthless) 
							end
=TEX
=SML
and 	(Ûvalueèclassêİ : Valueèssqlê ­ ExpClass)
		v = case internal_valueèclassê v of
			ands(datas,classes) => 	let val (v,c) = simplifyèandsê(datas,classes)
						in c
						end
			| ors(datas,classes) => let val (v,c) = simplifyèorsê(datas,classes)
						in c
						end
			| simple(variable(exp,up)) => variable(exp,up)
			| simple(constantèecê c) => constantèecê c
=TEX
=SML
and 	(Ûtuple_listèdataêİ : Tuple_listèssqlê ­ Tuple_listètsqlê)
			(table_contents‰s t) = in_new_scope(fn () =>
			let	val ts = convertètable_specê t
				val tn = convertètableSpecificationê ts
				val (ti,ci,scs,rc,tcs) = get‰t‰a‰b‰l‰e‰i‰n‰f‰o ts
				fun (sel: TsqlCol ­ Select_valueètsqlê)
					{sterling_name = name‰t n,
					dinary_name=dn,
					class_name=cn}
					= anonymous_value‰t(contents‰t(denote_col_spec‰t n))
				| sel	x = raise internalError
			in	all_tuples‰t(select_values‰t(map sel tcs),
					[from‰t(table_contents‰t tn)],denote_true‰t,[],denote_true‰t)
			end)
=TEX
=SML
|	tuple_listèdataê 	(all_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fss = map from_specèenterê fr
				val gs = sterling_columns gb_sterling
				val gd = dinary_columns gb_dinary
				val gc = map class_column gb_class
			in all_tuples‰t(select_listèdataê sel,
					fss,valueèdataê where,gs @ gd @ remove_constants gc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèdataê 	(distinct_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fss = map from_specèenterê fr
				val gs = sterling_columns gb_sterling
				val gd = dinary_columns gb_dinary
				val gc = map class_column gb_class
			in distinct_tuples‰t(select_listèdataê sel,
					fss,valueèdataê where,gs @ gd @ remove_constants gc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèdataê 	(evaluate‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fss = map from_specèenterê fr
				val gs = sterling_columns gb_sterling
				val gd = dinary_columns gb_dinary
				val gc = map class_column gb_class
			in evaluate‰t(select_listèdataê sel,
					fss,valueèdataê where,gs @ gd @ remove_constants gc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèdataê 	(tuple‰s vals) = 
				tuple‰t(map valueèdataê vals)
=TEX
=SML
|	tuple_listèdataê 	(union‰s tls) = 
				union‰t(map tuple_listèdataê tls)
=TEX
=SML
|	tuple_listèdataê 	(name_columns‰s(names,tul)) 
						= tuple_listèdataê tul
=TEX
=SML
and 	(Ûtuple_listètypeêİ : Tuple_listèssqlê ­ ExpType list) 
				(table_contents‰s ts) =
					let	fun (col_info : TableInfo ¸ ConstraintInfo ¸ 
							SsqlCol list ¸ TsqlClassName ¸ TsqlCol list 
									­ SsqlCol list)
							(ti,ci,scs,rc,tcs) = scs
						fun (t:SsqlCol ­ ColType)
							c = #type_field c
						fun (f:ColType ­ ExpType)
							    (nullType,nullType) = raise internalError
							| f (st,nullType) = (st,sterling)
							| f (nullType,dt) = raise internalError
							| f (st,dt) = (st,sterling)
					in map f(map t(col_info(get‰t‰a‰b‰l‰e‰i‰n‰f‰o(convertètable_specê ts))))
					end
=TEX
=SML
|	tuple_listètypeê	(all_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
				= 	in_new_scope(fn () =>
					let	val fs = map from_specèenterê fr
						val where_ok = check_boolean(valueètypeê where)
						val having_ok  = check_boolean(valueètypeê having)
					in select_listètypeê sel
					end)
=TEX
=SML
|	tuple_listètypeê	(distinct_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
				= 	in_new_scope(fn () =>
					let	val fs = map from_specèenterê fr
						val where_ok = check_boolean(valueètypeê where)
						val having_ok  = check_boolean(valueètypeê having)
					in select_listètypeê sel
					end)
=TEX
=SML
|	tuple_listètypeê	(evaluate‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
				= 	in_new_scope(fn () =>
					let	val fs = map from_specèenterê fr
						val where_ok = check_boolean(valueètypeê where)
						val having_ok  = check_boolean(valueètypeê having)
					in select_listètypeê sel
					end)
=TEX
=SML
|	tuple_listètypeê	(tuple‰s vals) = map valueètypeê vals
=TEX
=SML
|	tuple_listètypeê	(union‰s tls) =	let val tiss = map tuple_listètypeê tls
						in 	if length tiss = 0
							then raise emptyUnionList
							else map (fold lubèexpê)(invert tiss)
						end
=TEX
=SML
|	tuple_listètypeê	(name_columns‰s (names,tul)) =	tuple_listètypeê tul
=TEX
=SML
and 	(Ûfrom_specèenterêİ : From_specèssqlê ­ From_specètsqlê) fs =
	let 	fun	(c_names : TsqlClassName ­ string list)
				(constantètcê c) = []
		|	c_names	(nameètcê s) = [s]
		|	c_names anonètcê = raise internalError
		fun	(names : TsqlName ­ string list)
				none‰t = []
		|	names	(name‰t s) = [s]
		|	names	anon‰t = raise internalError
		fun	(col_names : TsqlCol ­ string list) tc
				 = names(#sterling_name tc)
				@ names(#dinary_name tc)
				@ c_names(#class_name tc)
	in
=TEX
=SML	
	(case fs of
		(from‰s t) => 
			let	val (tn,ti,scs,rc,tcs) = tuple_listèinfoê t
				val tul = tuple_listèmakeê (t,rc,tcs)
				val cor = enterètableê(tn,ti,scs,rc,tcs)
				val cns = (case rc of
						anonètcê => raise internalError
					|	nameètcê s => [s]
					|	constantètcê c => [])
					@ fold (op @) (map col_names tcs)
			in	correlate_from‰t(cor,name_columns‰t(cns,tul))
			end
=TEX
=SML
	|	(correlate_from‰s(name,t)) =>
			let	val (tn,ti,scs,rc,tcs) = tuple_listèinfoê t
				val tul = tuple_listèmakeê (t,rc,tcs)
				val cor = enter‰c‰o‰r‰r‰_‰t‰a‰b‰l‰e(name,tn,ti,scs,rc,tcs)
				val cns = (case rc of
						anonètcê => raise internalError
					|	nameètcê s => [s]
					|	constantètcê c => [])
					@ fold (op @) (map col_names tcs)
			in	correlate_from‰t(cor,name_columns‰t(cns,tul))
			end)
	end
=TEX
=SML
and 	(Ûselect_listètypeêİ : Select_listèssqlê ­ ExpType list)
			all_columns‰s =
				let 	fun (t : SsqlCol ­ ColType) c = #type_field c
					fun (f : ColType ­ ExpType)
						  (nullType,nullType) = raise internalError
					| 	f (st,nullType) = (st,sterling)
					| 	f (nullType,dt) = (dt,dinary)
					|	f (st,dt) = (st,sterling)
				in map f(map t(lookup‰l‰o‰c‰a‰l‰_‰c‰o‰l‰_‰i‰n‰f‰o()))
				end
|	select_listètypeê (select_values‰s vals) = map select_valueètypeê vals
=TEX
=SML
and 	(Ûselect_valueètypeêİ : Select_valueèssqlê ­ ExpType)
				(anonymous_value‰s v) = valueètypeê v
|	select_valueètypeê	(named_value‰s(name,v)) = valueètypeê v
|	select_valueètypeê	(anonymous_pair‰s(sval,dval)) = valueètypeê sval
|	select_valueètypeê	(named_pair‰s(name,(sval,dval))) = valueètypeê sval
=TEX
=SML
and 	(Ûtuple_listèinfoêİ : Tuple_listèssqlê ­ 	TableName  ¸ TableInfo ¸ SsqlCol list 
								¸ TsqlClassName ¸ TsqlCol list) 
			(table_contents‰s t) = 
				let 	val ts = convertètable_specê t
					val (ti,ci,scs,rc,tcs) = get‰t‰a‰b‰l‰e‰i‰n‰f‰o ts
				in 	(nameètnê ts,ti,scs,rc,tcs)
				end
=TEX
=SML
|	tuple_listèinfoê	(all_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)) =
				let	val (tis,scss,rcs,tcss) = split4 (map from_specèinfoê fr)
				in 	in_new_scope(fn () =>
					let 	val fs = map from_specèenterê fr
						val sli = select_listèinfoê sel
					in	(anonètnê,fold lub‰t‰a‰b‰l‰e‰i‰n‰f‰o tis,sli,
							fold lubètsql_class_nameê rcs,map col_target sli)
					end)
				end
=TEX
=SML
|	tuple_listèinfoê	(distinct_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)) =
				let	val (tis,scss,rcs,tcss) = split4 (map from_specèinfoê fr)
				in 	in_new_scope(fn () =>
					let 	val fs = map from_specèenterê fr
						val sli = select_listèinfoê sel
					in	(anonètnê,fold lub‰t‰a‰b‰l‰e‰i‰n‰f‰o tis,sli,
							fold lubètsql_class_nameê rcs,map col_target sli)
					end)
				end
=TEX
=SML
|	tuple_listèinfoê	(evaluate‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)) =
				let	val (tis,scss,rcs,tcss) = split4 (map from_specèinfoê fr)
				in 	in_new_scope(fn () =>
					let 	val fs = map from_specèenterê fr
						val sli = select_listèinfoê sel
					in	(anonètnê,fold lub‰t‰a‰b‰l‰e‰i‰n‰f‰o tis,sli,
							fold lubètsql_class_nameê rcs,map col_target sli)
					end)
				end
=TEX
=SML
|	tuple_listèinfoê	(tuple‰s vals) =
			let	val	ti = 	{table_exist_class = query_constants_class(),
						table_class = query_constants_class(),
						row_class = constant(query_constants_class())}
				val scs = map valueèinfoê vals
				val tcs = map col_target scs
			in	(anonètnê,ti,scs,constantètcê(query_constants_class()),tcs)
			end
=TEX
=SML
|	tuple_listèinfoê	(union‰s tls) =
			if length tls = 1
			then tuple_listèinfoê(hd tls)
			else 	let	val (tts,tis,scss,rcs,tcss) = split5 (map tuple_listèinfoê tls)
					val ti = fold lub‰t‰a‰b‰l‰e‰i‰n‰f‰o tis
					val scs = map(fold lubèssql_colê)(invert scss)
					val rc = fold lubètsql_class_nameê rcs
					val tcs = map(fold lubètsql_colê) (invert tcss)
				in	(anonètnê,ti,scs,rc,tcs)
				end
=TEX					
=SML
|	tuple_listèinfoê	(name_columns‰s (names,tul)) =
		let	fun	(merge : string ¸ SsqlCol ­ SsqlCol)
				(n,{name=cn,type_field=ty,col_exist=ce,col_class=cc})
				= {name=name‰s n,type_field=ty,col_exist=ce,col_class=cc}
			val 	(tn,ti,scs,rc,tcs) = tuple_listèinfoê tul
		in	(tn,ti,at2(map merge)(names,scs),rc,tcs)
		end
=TEX
=SML
and 	(Ûtuple_listèmakeêİ : Tuple_listèssqlê ¸ TsqlClassName ¸ TsqlCol list ­ Tuple_listètsqlê ) 
			(table_contents‰s t,to_rc,to_tcs) = 
			let 	val (ti,ci,scs,rc,tcs) = get‰t‰a‰b‰l‰e‰i‰n‰f‰o (convertètable_specê t)
				val tc = table_contents‰t(convertètableSpecificationê(convertètable_specê t))
				fun (mk : TsqlName ¸ TsqlName ­ Valueètsqlê list)
					(name‰t f,name‰t tn) = [contents‰t(denote_col_spec‰t f)]
				| 	mk	(name‰t f,anon‰t) = [contents‰t(denote_col_spec‰t f)]
				| 	mk	(name‰t f,none‰t) = raise internalError
				| 	mk	(anon‰t,name‰t tn) = raise internalError
				|	mk	(anon‰t,anon‰t) = raise internalError
				|	mk	(anon‰t,none‰t) = raise internalError
				|	mk	(none‰t,name‰t tn) = [denote_null‰t]
				|	mk	(none‰t,anon‰t) = [denote_null‰t]
				|	mk	(none‰t,none‰t) = []
				fun (mkc : TsqlClassName ¸ TsqlClassName ­ Valueètsqlê list)
					(nameètcê f,nameètcê t) = [contents‰t(denote_col_spec‰t f)]
				| 	mkc	(nameètcê f,constantètcê c) = raise internalError
				| 	mkc	(constantètcê c,nameètcê tn) = [denote_class‰t c]
				| 	mkc	(constantètcê c1,constantètcê c2) = 	
									if c1 = c2 then []
									else raise internalError
				| 	mkc	(anonètcê,x) = raise internalError
				| 	mkc	(nameètcê f,anonètcê) = [contents‰t(denote_col_spec‰t f)]
				| 	mkc	(constantètcê c,anonètcê) = [denote_class‰t c]
				fun (col : TsqlCol ¸ TsqlCol ­ Valueètsqlê list)
					({sterling_name= from_sn,dinary_name = from_dn,
						class_name = from_cn},
					{sterling_name= to_sn,dinary_name = to_dn,
						class_name = to_cn}) = 
					mk(from_sn,to_sn) @ mk(from_dn,to_dn) 
						@ mkc(from_cn,to_cn)
			in	if to_rc = rc andalso to_tcs = tcs
				then tc
				else 	let val vals = mkc(rc,to_rc) @ 
							(fold (op @)(at2(map col)(tcs,to_tcs)))
					in all_tuples‰t(select_values‰t(map anonymous_value‰t vals),
					[from‰t tc],denote_true‰t,[],denote_true‰t)
					end
			end
=TEX
=SML
|	tuple_listèmakeê 	(all_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)
						,to_rc,to_tcs)
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val gbs = sterling_columns gb_sterling
				val gbd = dinary_columns gb_dinary
				val gbc = remove_constants(map class_column gb_class)
			in all_tuples‰t(select_values‰t(select_listèmakeê(sel,to_rc,to_tcs)),
					fs,valueèdataê where,gbs @ gbd @ gbc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèmakeê 	(distinct_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)
						,to_rc,to_tcs)
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val gbs = sterling_columns gb_sterling
				val gbd = dinary_columns gb_dinary
				val gbc = remove_constants(map class_column gb_class)
			in distinct_tuples‰t(select_values‰t(select_listèmakeê(sel,to_rc,to_tcs)),
					fs,valueèdataê where,gbs @ gbd @ gbc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèmakeê 	(evaluate‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)
						,to_rc,to_tcs)
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val gbs = sterling_columns gb_sterling
				val gbd = dinary_columns gb_dinary
				val gbc = remove_constants(map class_column gb_class)
			in evaluate‰t(select_values‰t(select_listèmakeê(sel,to_rc,to_tcs)),
					fs,valueèdataê where,gbs @ gbd @ gbc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèmakeê 	(tuple‰s vals,to_rc,to_tcs) = 
			let	val tvals = (case to_rc of
					constantètcê c => []
				|	other => [(denote_class‰t (query_constants_class()))])
				@ (fold(op @)(at2(map make_col)(vals,to_tcs)))
			in tuple‰t tvals
			end	
=TEX
=SML
|	tuple_listèmakeê 	(union‰s tls,to_rc,to_tcs) = 
				if length tls <> 1
				then tuple_listèmakeê(hd tls,to_rc,to_tcs)
				else union‰t(at3(map tuple_listèmakeê)
						(tls,seq(length tls,to_rc),seq(length tls,to_tcs)))
=TEX
=SML
|	tuple_listèmakeê 	(name_columns‰s(names,tul),to_rc,to_tcs) 
						= tuple_listèmakeê(tul,to_rc,to_tcs)
=TEX
=SML
and 	(Ûfrom_specèinfoêİ : From_specèssqlê ­ 
					TableInfo ¸ SsqlCol list ¸ TsqlClassName ¸ TsqlCol list)
			(from‰s t) =	let	val (tn,ti,scs,rc,tcs) = tuple_listèinfoê t
					in 	(ti,scs,rc,tcs)
					end
|	from_specèinfoê	(correlate_from‰s(cn,t)) = 	let	val (tn,ti,scs,rc,tcs) = tuple_listèinfoê t
							in 	(ti,scs,rc,tcs)
							end
=TEX		
=SML
and 	(Ûselect_listèinfoêİ : Select_listèssqlê ­ SsqlCol list)
			all_columns‰s = lookup‰l‰o‰c‰a‰l‰_‰c‰o‰l‰_‰i‰n‰f‰o()
|	select_listèinfoê (select_values‰s vals) = map select_valueèinfoê vals
=TEX
=SML
and 	(Ûselect_valueèinfoêİ : Select_valueèssqlê ­ SsqlCol)
			(anonymous_value‰s v) = valueèinfoê v

=TEX
=SML
|	select_valueèinfoê	(named_value‰s(n,v)) = 
			let 	val {name = nm,type_field = ty,col_exist = ce,col_class =cc} 
				= valueèinfoê v
			in 	{name = name‰s n,type_field = ty,col_exist = ce,col_class = cc}
			end
=TEX
=SML
|	select_valueèinfoê	(anonymous_pair‰s(sval,dval)) = 
			let 	val (stype,sw) = valueètypeê sval
				val (dtype,dw) = valueètypeê dval
				val u = upper(valueèclassê sval) 
						lub upper(valueèclassê dval)
			in	{name = anon‰s,
				type_field = (stype,dtype),
				col_exist = query_constants_class(),
				col_class = upb u}
			end
=TEX
=SML
|	select_valueèinfoê	(named_pair‰s(n,(sval,dval))) = 
			let 	val (stype,sw) = valueètypeê sval
				val (dtype,dw) = valueètypeê dval
				val u = upper(valueèclassê sval) 
						lub upper(valueèclassê dval)
			in	{name = name‰s n,
				type_field = (stype,dtype),
				col_exist = query_constants_class(),
				col_class = upb u}
			end
=TEX
=SML
and 	(Ûvalueèinfoêİ : Valueèssqlê ­ SsqlCol)
		v = 	case valueèclassê v of
				variable(exp,c) => 	{name= anon‰s,
							 type_field= col_exp(valueètypeê v),
							 col_exist=query_constants_class(),
							 col_class=upb c} 
			| 	constantèecê c => 	{name= anon‰s,
							 type_field= col_exp(valueètypeê v),
							 col_exist=query_constants_class(),
							 col_class=constant c}
=TEX
=SML
and 	(Ûinternal_valueèclassêİ : Valueèssqlê ­ InternalExpClass)
				(denote_constant‰s c) = 
						simple(constantèecê(query_constants_class()))
|	internal_valueèclassê	(monop‰s(opr,v)) = simple(valueèclassê v)
=TEX
=SML
|	internal_valueèclassê	(binop‰s(or_op,(val1,val2))) =
				let 	
				val (v1,c1) =
					(case (internal_valueèclassê val1) of
					ands(datas,classes) => 
							split[simplifyèandsê(datas,classes)]
					| ors(datas,classes) => (datas,classes)
					| simple e => ([valueèdataê val1],[e]))
				val (v2,c2) =
					(case (internal_valueèclassê val2) of
					ands(datas,classes) => 
							split[simplifyèandsê(datas,classes)]
					| ors(datas,classes) => (datas,classes)
					| simple e => ([valueèdataê val2],[e]))
				in ors(v1 @ v2,c1 @ c2)
				end
=TEX
=SML
|	internal_valueèclassê	(binop‰s(and_op,(val1,val2))) =
				let 	
				val (v1,c1) =
					(case (internal_valueèclassê val1) of
					ands(datas,classes) => (datas,classes)
					| ors(datas,classes) => 
							split[simplifyèorsê(datas,classes)]
					 
					| simple e => ([valueèdataê val1],[e]))
				val (v2,c2) =
					(case (internal_valueèclassê val2) of
					ands(datas,classes) => (datas,classes)
					| ors(datas,classes) => 
							split[simplifyèorsê(datas,classes)]
					
					| simple e => ([valueèdataê val2],[e]))
				in ors(v1 @ v2,c1 @ c2)
				end
=TEX
=SML
|	internal_valueèclassê	(binop‰s(opr,(val1,val2))) =
				let 	val vc1 = valueèclassê val1
					val vc2 = valueèclassê val2
				in 	simple(lubèexp_classê(vc1,vc2))
				end
=TEX
=SML
|	internal_valueèclassê	(triop‰s(opr,(val1,val2,val3))) =
				let 	val vc1 = valueèclassê val1
					val vc2 = valueèclassê val2
					val vc3 = valueèclassê val3
				in 	simple(lubèexp_classê(vc1,lubèexp_classê(vc2,vc3)))
				end
=TEX
=SML
|	internal_valueèclassê	(convert‰s(v,t)) = simple(valueèclassê v)
|	internal_valueèclassê	(convert_domain‰s(v,domain,t)) = simple(valueèclassê v)
|	internal_valueèclassê	(make_sterling‰s v) = simple(valueèclassê v)
|	internal_valueèclassê	(make_dinary‰s v) = simple(valueèclassê v)
=TEX
=SML
|	internal_valueèclassê	(declare‰s (id,(val1,val2))) =
			let 	val t1 = valueètypeê val1
				val data1 = valueèdataê val1
				val class1 = valueèclassê val1
				val class2 = valueèclassê val2
				val class2exp = denoteèclass_expê class2
			in					
				in_new_scope(fn () =>
				let val c =	
					case class1 of
						variable (c,u) => 
						let val (cn,dn) = enter‰i‰d‰e‰n‰t‰i‰f‰i‰e‰r(id,t1,u)
						in	declare‰t (cn,(c,
								declare‰t(dn,(data1,class2exp)))) 
						end
					| 	constantèecê c =>
						let val dn =  enter‰i‰d‰e‰n‰t‰i‰f‰e‰r‰_‰c‰o‰n‰s‰t‰a‰n‰t‰_‰c‰l‰a‰s‰s(id,t1,c)
						in declare‰t(dn,(data1,class2exp)) 
						end
				in		simple(variable(c,upper class2))
				end)
			end 
=TEX
=SML
| 	internal_valueèclassê	(caseVal‰s (test,caseList,valList,elseVal)) = 
				let 	val tcn = unique_name()
					val tc = contents‰t(denote_col_spec‰t tcn)
					val tvn = unique_name()
					val tv = contents‰t(denote_col_spec‰t tvn)
					fun (limb1  : Valueèssqlê ¸ Valueèssqlê 
							­ Valueètsqlê list ¸ Valueètsqlê list)
						(e,v) = 
						let 	val v1 = denoteèclass_expê(valueèclassê e)
							val t1 = monop‰t(not_op,binop‰t(dom_op,
								(denote_class‰t(query_class()),v1)))
							val t2 = binop‰t(equal_op,(tv,valueèdataê e))
							val v2 = denoteèclass_expê(valueèclassê v)
						in	([t1,t2],[v1,v2])
						end
					fun (limb : Valueèssqlê list ¸ Valueèssqlê list 
							­ Valueètsqlê list ¸ Valueètsqlê list)
						(es,vs) = 
						let val (ess,vss) = split(at2(map limb1)(es,vs))
						in (fold(op @)ess,fold(op @)vss)
						end
					fun (uppers : ExpClass list ­ Class)
						es = fold (op lub) (map upper es)	
					val (c1,v1) = limb(caseList,valList)
					val check_list = case‰t(c1,v1,
							denoteèclass_expê(valueèclassê elseVal))
					val check_test = case‰t([binop‰t(dom_op,(denote_class‰t
									(query_class()),tc))],
								[check_list],
								tc)
					val c = declare‰t(tcn,(denoteèclass_expê(valueèclassê test),
							declare‰t(tvn,(valueèdataê test,check_test))))
					val u = uppers(map valueèclassê
							(caseList @ valList @ [test,elseVal]))
				in simple(variable(c,u))
				end
=TEX
=SML								
| 	internal_valueèclassê	(case‰s (caseList,valList,elseVal)) = 
				let 	fun (limb1  : Valueèssqlê ¸ Valueèssqlê 
							­ Valueètsqlê list ¸ Valueètsqlê list)
						(e,v) = 
						let 	val v1 = denoteèclass_expê(valueèclassê e)
							val t1 = monop‰t(not_op,binop‰t(dom_op,
								(denote_class‰t(query_class()),v1)))
							val v2 = denoteèclass_expê(valueèclassê v)
						in	([t1,valueèdataê e],[v1,v2])
						end
					fun (limb : Valueèssqlê list ¸ Valueèssqlê list 
							­ Valueètsqlê list ¸ Valueètsqlê list)
						(es,vs) = 
						let val (ess,vss) = split(at2(map limb1)(es,vs))
						in (fold(op @)ess,fold(op @)vss)
						end
					fun (uppers : ExpClass list ­ Class)
						es = fold (op lub) (map upper es)	
					val (c1,v1) = limb(caseList,valList)
					val c = case‰t(c1,v1,denoteèclass_expê(valueèclassê elseVal))
					val u = uppers(map valueèclassê
							(caseList @ valList @ [elseVal]))
				in simple(variable(c,u))
				end
=TEX
=SML
|	internal_valueèclassê	(set_func_all‰s (and_op,v)) = 
				(case valueèclassê v of
					variable(c,u) =>
					let	val cf = case‰t([valueèdataê v],
								[denote_class‰t(lattice_top())],
								c)
						val ce = case‰t([set_func_all‰t(and_op,valueèdataê v)],
								[set_func_all‰t(lub_op,c)],
								set_func_all‰t(glb_op,cf))
					in	simple(variable(ce,u))
					end
				|	constantèecê c => simple(constantèecê c))
=TEX
=SML
|	internal_valueèclassê	(set_func_all‰s (or_op,v)) = 
				(case valueèclassê v of
					variable(c,u) =>
					let	val ct = case‰t([valueèdataê v],
								[c],
								denote_class‰t(lattice_top()))
						val ce = case‰t([set_func_all‰t(or_op,valueèdataê v)],
								[set_func_all‰t(glb_op,ct)],
								set_func_all‰t(lub_op,c))
					in	simple(variable(ce,u))
					end
				|	constantèecê c => simple(constantèecê c))
=TEX
=SML
|	internal_valueèclassê	(set_func_all‰s (opr,v)) = 
				(case valueèclassê v of
					variable(c,u) =>
					simple(variable(set_func_all‰t(lub_op,c),u))
				|	constantèecê c => simple(constantèecê c))
=TEX
=SML
|	internal_valueèclassê	(set_func_distinct‰s (and_op,v)) = 
				(case valueèclassê v of
					variable(c,u) =>
					let	val cf = case‰t([valueèdataê v],
								[denote_class‰t(lattice_top())],
								c)
						val ce = case‰t([set_func_all‰t(and_op,valueèdataê v)],
								[set_func_all‰t(lub_op,c)],
								set_func_all‰t(glb_op,cf))
					in	simple(variable(ce,u))
					end
				|	constantèecê c => simple(constantèecê c))
=TEX
=SML
|	internal_valueèclassê	(set_func_distinct‰s (or_op,v)) = 
				(case valueèclassê v of
					variable(c,u) =>
					let	val ct = case‰t([valueèdataê v],
								[c],
								denote_class‰t(lattice_top()))
						val ce = case‰t([set_func_all‰t(or_op,valueèdataê v)],
								[set_func_all‰t(glb_op,ct)],
								set_func_all‰t(lub_op,c))
					in	simple(variable(ce,u))
					end
				|	constantèecê c => simple(constantèecê c))
=TEX
=SML
|	internal_valueèclassê	(set_func_distinct‰s (opr,v)) = 
				(case valueèclassê v of
					variable(c,u) =>
					simple(variable(set_func_all‰t(lub_op,c),u))
				|	constantèecê c => simple(constantèecê c))
=TEX
=SML
|	internal_valueèclassê	(count_non_null‰s (v,t)) = 
				(case valueèclassê v of
					variable(c,u) =>
					simple(variable(set_func_all‰t(lub_op,c),u))
				|	constantèecê c => simple(constantèecê c))
=TEX
=SML
|	internal_valueèclassê	(count_distinct‰s (v,t)) = 
				(case valueèclassê v of
					variable(c,u) =>
					simple(variable(set_func_all‰t(lub_op,c),u))
				|	constantèecê c => simple(constantèecê c))
=TEX
=SML
|	internal_valueèclassê	(count_all‰s t) = 
				let val ti = fold lub‰t‰a‰b‰l‰e‰i‰n‰f‰o(lookup‰l‰o‰c‰a‰l‰_‰t‰a‰b‰l‰e‰_‰i‰n‰f‰o())
				in	case #row_class ti of
						upb u =>
						let	val c = fold(curry binop‰t lub_op)(map 
								denote_name(lookup‰l‰o‰c‰a‰l‰_‰r‰o‰w‰_‰c‰l‰a‰s‰s‰e‰s()))
						in simple(variable(c,u))
						end
					| 	constant u => simple(constantèecê u)
				end
=TEX
=SML
|	internal_valueèclassê	(exists_tuples‰s tuples) = 
				let val (tn,ti,scs,rc,tcs) = tuple_listèinfoê tuples
				in	case #row_class ti of
						upb u =>
						let val c = denoteèclass_expê
								(tuple_listèmax_row_classê tuples)
						in simple(variable(c,u))
						end
					| 	constant u => simple(constantèecê u)
				end
=TEX
=SML
|	internal_valueèclassê	(single_value‰s v) =  
				let val (tn,ti,scs,rc,tcs) = tuple_listèinfoê v
				in	case #col_class (hd scs) of
						upb u =>
						let val c = single_value‰t (tuple_listèclassê v)
						in simple(variable(c,u))
						end
					| 	constant u => simple(constantèecê u)
				end
=TEX
=SML
|	internal_valueèclassê	(contents‰s col) = 
				let val (tr,u) = lookup‰c‰o‰l‰_‰s‰p‰e‰c‰_‰c‰l‰a‰s‰s(false,convertècol_specê col)
				in	case tr of
						constant_class c => simple(constantèecê c)
					| 	other => simple(variable(denote_name tr,u))
				end
=TEX
=SML
|	internal_valueèclassê	(sterling_contents‰s col) = 
				let val (tr,u) = lookup‰c‰o‰l‰_‰s‰p‰e‰c‰_‰c‰l‰a‰s‰s(false,convertècol_specê col)
				in	case tr of
						constant_class c => simple(constantèecê c)
					| 	other => simple(variable(denote_name tr,u))
				end
=TEX
=SML
|	internal_valueèclassê	(dinary_contents‰s col) = 
				let val (tr,u) = lookup‰c‰o‰l‰_‰s‰p‰e‰c‰_‰c‰l‰a‰s‰s(false,convertècol_specê col)
				in	case tr of
						constant_class c => simple(constantèecê c)
					| 	other => simple(variable(denote_name tr,u))
				end
=TEX
=SML
|	internal_valueèclassê	(classification‰s col) = 
				let val (ti,ci) = lookup‰c‰o‰l‰u‰m‰n‰_‰i‰n‰f‰o(convertècol_specê col)
				in	case #row_class ti of
						upb u =>
						let 	val rc = lookup‰c‰o‰l‰u‰m‰n‰_‰r‰o‰w‰_‰c‰l‰a‰s‰s
									(false,convertècol_specê col)
							val c = denote_name rc
						in 	simple(variable(c,u))
						end
					| 	constant c => simple(constantèecê c)
				end

=TEX
=SML
|	internal_valueèclassê	(row_existence‰s t) = 	
				let val td = lookup‰t‰a‰b‰l‰e‰_‰d‰e‰t‰a‰i‰l(convertètable_specê t)
				in  simple(constantèecê (#table_class(#info td)))
				end
=TEX
=SML
|	internal_valueèclassê	joined_row_existence‰s = 	
				let val ti = fold lub‰t‰a‰b‰l‰e‰i‰n‰f‰o(lookup‰l‰o‰c‰a‰l‰_‰t‰a‰b‰l‰e‰_‰i‰n‰f‰o())
				in  simple(constantèecê (#table_class ti))
				end
=TEX
=SML
|	internal_valueèclassê	(classify‰s(v,c)) = simple(valueèclassê c)
|	internal_valueèclassê	(classify_default‰s v) = simple(constantèecê(query_class()))
=TEX
=SML
|	internal_valueèclassê	(observed‰s(n,c)) = raise notTrigger
|	internal_valueèclassê	(modified‰s n) = raise notTrigger
|	internal_valueèclassê	(context‰s t) =
				let val  (cv,class) = contextual_data t
				in simple(constantèecê class) 
				end
|	internal_valueèclassê	(parameter‰s name) = 	
				let val (cv,class) = lookup‰p‰a‰r‰a‰m‰_‰d‰a‰t‰a name
				in simple(constantèecê class) 
				end
=TEX
=SML
and 	(Ûtuple_listèclassêİ : Tuple_listèssqlê  ­ Tuple_listètsqlê ) 
			(table_contents‰s t) = in_new_scope(fn () =>
			let	val ts = convertètable_specê t
				val tn = convertètableSpecificationê ts
				val (ti,ci,scs,rc,tcs) = get‰t‰a‰b‰l‰e‰i‰n‰f‰o ts
				fun (sel: TsqlCol ­ Select_valueètsqlê)
					{sterling_name = sn,
					dinary_name=dn,
					class_name=nameètcê n}
					= anonymous_value‰t(contents‰t(denote_col_spec‰t n))
				| sel 	{sterling_name = sn,
					dinary_name=dn,
					class_name=constantètcê c}
					= anonymous_value‰t(denote_class‰t c)
				| sel	x = raise internalError
			in	all_tuples‰t(select_values‰t(map sel tcs),
					[from‰t(table_contents‰t tn)],denote_true‰t,[],denote_true‰t)
			end)
=TEX
=SML
|	tuple_listèclassê 	(all_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fss = map from_specèenterê fr
				val gs = sterling_columns gb_sterling
				val gd = dinary_columns gb_dinary
				val gc = map class_column gb_class
			in all_tuples‰t(select_listèclassê sel,
					fss,valueèdataê where,gs @ gd @ remove_constants gc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèclassê 	(distinct_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fss = map from_specèenterê fr
				val gs = sterling_columns gb_sterling
				val gd = dinary_columns gb_dinary
				val gc = map class_column gb_class
			in distinct_tuples‰t(select_listèclassê sel,
					fss,valueèdataê where,gs @ gd @ remove_constants gc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèclassê 	(evaluate‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fss = map from_specèenterê fr
				val gs = sterling_columns gb_sterling
				val gd = dinary_columns gb_dinary
				val gc = map class_column gb_class
			in evaluate‰t(select_listèclassê sel,
					fss,valueèdataê where,gs @ gd @ remove_constants gc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèclassê 	(tuple‰s vals) = 
				tuple‰t(map denoteèclass_expê(map valueèclassê vals))
=TEX
=SML
|	tuple_listèclassê 	(union‰s tls) = 
				union‰t(map tuple_listèclassê tls)
=TEX
=SML
|	tuple_listèclassê 	(name_columns‰s(names,tul)) 
						= tuple_listèclassê tul
and 	(Ûselect_listèclassêİ : Select_listèssqlê ­ Select_listètsqlê)
			all_columns‰s = 
				let val (trs,classes) = split(lookup‰l‰o‰c‰a‰l‰_‰c‰o‰l‰_‰s‰p‰e‰c‰_‰c‰l‰a‰s‰s‰e‰s())
				in select_values‰t(map anonymous_value‰t (map denote_name trs))
				end
|	select_listèclassê (select_values‰s vals) = select_values‰t(map select_valueèclassê vals)
=TEX
=SML
and 	(Ûselect_valueèclassêİ : Select_valueèssqlê ­ Select_valueètsqlê)
				(anonymous_value‰s v) = 
					anonymous_value‰t(denoteèclass_expê(valueèclassê v))
|	select_valueèclassê	(named_value‰s(name,v)) = 
					anonymous_value‰t(denoteèclass_expê(valueèclassê v))
|	select_valueèclassê	(anonymous_pair‰s(sval,dval)) = 
					anonymous_value‰t(denoteèclass_expê(valueèclassê sval))
|	select_valueèclassê	(named_pair‰s(name,(sval,dval))) = 
					anonymous_value‰t(denoteèclass_expê(valueèclassê sval))
=TEX					
=SML
=TEX
=SML
and 	(Ûselect_listèmakeêİ : Select_listèssqlê ¸ TsqlClassName ¸ TsqlCol list ­ Select_valueètsqlê list)
			(all_columns‰s,to_rc,to_tcs) = 
				let	val rcs = lookup‰l‰o‰c‰a‰l‰_‰r‰o‰w‰_‰c‰l‰a‰s‰s‰e‰s()
					val rc = (fold(curry binop‰t lub_op)(map denote_name rcs))
				in
				(case to_rc of
					anonètcê => [anonymous_value‰t rc]
				| 	nameètcê s => [anonymous_value‰t rc]
				|	constantètcê c => [])
				
				end
				@
				(fold (op @)(at2(map makeèsvê)
					(lookup‰l‰o‰c‰a‰l‰_‰c‰o‰l‰_‰i‰m‰p‰l‰e‰m‰e‰n‰t‰a‰t‰i‰o‰n(),to_tcs)))
=TEX
=SML
|	select_listèmakeê (select_values‰s vals,to_rc,to_tcs) = 
			let	fun	 (make : TsqlRepr ­ Valueètsqlê )
						(local_identifier s) = raise internalError
				|	make	(column(t,c)) = contents‰t(absolute_col_spec‰t([],t,c))
				|	make	(constant_class c) = denote_class‰t c
				|	make	constant_null = denote_null‰t
			in	(case to_rc of
						anonètcê => 
						let val rcvs = map make(lookup‰l‰o‰c‰a‰l‰_‰r‰o‰w‰_‰c‰l‰a‰s‰s‰e‰s())
						in [anonymous_value‰t
							(fold(curry binop‰t lub_op)rcvs)]
						end
					|	nameètcê s => 
						let val rcvs = map make(lookup‰l‰o‰c‰a‰l‰_‰r‰o‰w‰_‰c‰l‰a‰s‰s‰e‰s())
						in [anonymous_value‰t
							(fold(curry binop‰t lub_op)rcvs)]
						end
					|	constantètcê c => [])
				@
				(fold (op @)(at2(map select_valueèmakeê)(vals,to_tcs)))
			end
=TEX
=SML
and 	(Ûselect_valueèmakeêİ : Select_valueèssqlê ¸ TsqlCol­ Select_valueètsqlê list)
				(anonymous_value‰s v,tcol) = 
						map anonymous_value‰t(make_col(v,tcol))
|	select_valueèmakeê	(named_value‰s(name,v),tcol) = 
						map anonymous_value‰t(make_col(v,tcol))
|	select_valueèmakeê	(anonymous_pair‰s(sval,dval),tcol) = 
						let	val sv = anonymous_value‰t(valueèdataê sval)
							val sd = anonymous_value‰t(valueèdataê dval)
						in 	[sv,sd]
						end	
|	select_valueèmakeê	(named_pair‰s(name,(sval,dval)),tcol) = 
						let	val sv = anonymous_value‰t(valueèdataê sval)
							val sd = anonymous_value‰t(valueèdataê dval)
						in 	[sv,sd]
						end
=TEX
=SML
and 	(Ûmake_colİ : Valueèssqlê ¸ TsqlCol ­ Valueètsqlê list)
		(v,tcol) =	let val et =  valueètypeê v
				in
				(case (#sterling_name tcol) of
					none‰t => []
				|	anon‰t => [makeèsterlingê(v,et)]
				|	name‰t s => [makeèsterlingê(v,et)])
				@
				(case (#dinary_name tcol) of
					none‰t => []
				|	anon‰t => [makeèdinaryê(v,et)]
				|	name‰t s => [makeèdinaryê(v,et)])
				@
				(case (#class_name tcol) of
					anonètcê => [denoteèclass_expê(valueèclassê v)]
				|	nameètcê s => [denoteèclass_expê(valueèclassê v)]
				|	constantètcê c => [])
				end
=TEX
=SML
and 	(Ûmakeèdinaryêİ : Valueèssqlê ¸ ExpType ­ Valueètsqlê)
			(v,(t,priceless)) = raise wrongType
|	makeèdinaryê	(v,(t,sterling)) =  denote_null‰t
|	makeèdinaryê	(v,(t,dinary)) =  valueèdataê v 
|	makeèdinaryê	(v,(t,worthless)) =  denote_null‰t
=TEX
=SML
and 	(Ûmakeèsterlingêİ : Valueèssqlê ¸ ExpType ­ Valueètsqlê)
			(v,(t,priceless)) = raise wrongType
|	makeèsterlingê	(v,(t,sterling)) =  valueèdataê v
|	makeèsterlingê	(v,(t,dinary)) =  denote_null‰t 
|	makeèsterlingê	(v,(t,worthless)) =  valueèdataê v
=TEX
=SML
and 	(Ûselect_listèdataêİ : Select_listèssqlê ­ Select_listètsqlê)
			all_columns‰s = select_values‰t(map anonymous_value‰t (map contents‰t
						(all_data_columnsèlocalê())))
|	select_listèdataê (select_values‰s vals) = select_values‰t(map select_valueèdataê vals)
=TEX
=SML
and 	(Ûselect_valueèdataêİ : Select_valueèssqlê ­ Select_valueètsqlê)
				(anonymous_value‰s v) = anonymous_value‰t(valueèdataê v)
|	select_valueèdataê	(named_value‰s(name,v)) = anonymous_value‰t(valueèdataê v)
|	select_valueèdataê	(anonymous_pair‰s(sval,dval)) = anonymous_value‰t(valueèdataê sval)
|	select_valueèdataê	(named_pair‰s(name,(sval,dval))) = 
							anonymous_value‰t(valueèdataê sval)
=TEX		
=SML
fun 	(Ûtuple_listèmake_outerêİ : Tuple_listèssqlê ¸ bool ¸ TsqlClassName ¸ TsqlCol list 
						­ Tuple_listètsqlê ¸ Queryètsqlê list ) 
			(table_contents‰s t,scw,to_rc,to_tcs) = 
			let 	val ts = convertètable_specê t
				val (ti,ci,scs,rc,tcs) = get‰t‰a‰b‰l‰e‰i‰n‰f‰o ts
				val where_class = denote_class‰t(query_constants_class())
				val sl = (case scw of
						true => [anonymous_value‰t where_class]
					|	false => [])
					@
					(case to_rc of
						constantètcê c => []
					|	other => 
						(case rc of 
							anonètcê => raise internalError
						|	nameètcê col => 
							[anonymous_value‰t(contents‰t
									(denote_col_spec‰t col))]
						|	constantètcê cl => 
							[anonymous_value‰t(denote_class‰t cl)]))
					@ (fold (op @) (at2(map makeèsvê)(tcs,to_tcs)))
				val fs = from‰t(table_contents‰t(convertètableSpecificationê ts))
				val sel_q = all_tuples‰t(select_values‰t sl,[fs],denote_true‰t,
								[],denote_true‰t)
			in	(sel_q,[])
			end
=TEX
=SML
|	tuple_listèmake_outerê 	(all_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)
						,scw,to_rc,to_tcs)
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val sel_vals = select_listèmakeê(sel,to_rc,to_tcs)
				val where_v = valueèdataê where
				val where_c = valueèclassê where
				val where_class = case where_c of
							variable(exp,c) => exp
						  |	constantèecê c => denote_class‰t c
				val sel_list = 	case scw of
						 true => [anonymous_value‰t where_class]@ sel_vals
						| false => sel_vals	
				val sl = select_values‰t sel_list
				val cc = denote_class‰t(client_clearance())
				val wchk = case where_c of
					   	variable(exp,c) => 
							if client_clearance() dom c	
							then where_v
							else 	let val ok = binop‰t(dom_op,(cc,exp))
								in binop‰t(or_op,(where_v,
									monop‰t(not_op,ok)))
								end
					    |	constantèecê c =>
							if client_clearance() dom c	
							then where_v
							else 	denote_true‰t
				val max_rc = fold (op lub)(map upb_row_class
								(lookup‰l‰o‰c‰a‰l‰_‰t‰a‰b‰l‰e‰_‰i‰n‰f‰o()))	
				val rcs = map denote_name(lookup‰l‰o‰c‰a‰l‰_‰r‰o‰w‰_‰c‰l‰a‰s‰s‰e‰s())
				val rvis = binop‰t(dom_op,(cc,fold(curry binop‰t lub_op)rcs))
				val w = 	if client_clearance() dom max_rc
						then wchk
						else binop‰t(and_op,(wchk,rvis))
				val gbs = sterling_columns gb_sterling
				val gbd = dinary_columns gb_dinary
				val gbc = remove_constants(map class_column gb_class)
=TEX
=SML
				val groupby_test = fold(op @)(map column_data_test
								(gb_sterling @ gb_dinary))
				val having_test =	case valueèclassê having of
								constantèecê c =>
									if client_clearance() dom c	
									then []
									else 	[denote_false‰t]
							|	variable(exp,c) => 
									if client_clearance() dom c	
									then []
									else [binop‰t(dom_op,(cc,exp))]
				val tests = groupby_test @ having_test
				val checks = 	
					if length tests = 0
					then []
					else 	
					let 	val t = monop‰t(not_op,
							(fold(curry binop‰t and_op)tests))
						val bad = 	if client_clearance() dom max_rc
								then [where_v,t]
								else [rvis,where_v,t]
						val junk = anonymous_value‰t(denote_true‰t)
						val junk_sl = select_values‰t[junk]
					in [select‰t(all_tuples‰t(junk_sl,fs,
						fold(curry binop‰t and_op)bad,[],denote_true‰t))]
					end
				val sel_q = all_tuples‰t(sl,fs,w,gbs @ gbd @ gbc,valueèdataê having)
			in (sel_q,checks)
			end)		
=TEX
=SML
|	tuple_listèmake_outerê 	(distinct_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)
						,scw,to_rc,to_tcs)
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val sel_vals = select_listèmakeê(sel,to_rc,to_tcs)
				val where_v = valueèdataê where
				val where_c = valueèclassê where
				val where_class = case where_c of
							variable(exp,c) => exp
						  |	constantèecê c => denote_class‰t c
				val sel_list = 	case scw of
						 true => [anonymous_value‰t where_class]@ sel_vals
						| false => sel_vals	
				val sl = select_values‰t sel_list
				val cc = denote_class‰t(client_clearance())
				val wchk = case where_c of
					   	variable(exp,c) => 
							if client_clearance() dom c	
							then where_v
							else 	let val ok = binop‰t(dom_op,(cc,exp))
								in binop‰t(or_op,(where_v,
									monop‰t(not_op,ok)))
								end
					    |	constantèecê c =>
							if client_clearance() dom c	
							then where_v
							else 	denote_true‰t
				val max_rc = fold (op lub)(map upb_row_class
								(lookup‰l‰o‰c‰a‰l‰_‰t‰a‰b‰l‰e‰_‰i‰n‰f‰o()))	
				val rcs = map denote_name(lookup‰l‰o‰c‰a‰l‰_‰r‰o‰w‰_‰c‰l‰a‰s‰s‰e‰s())
				val rvis = binop‰t(dom_op,(cc,fold(curry binop‰t lub_op)rcs))
				val w = 	if client_clearance() dom max_rc
						then wchk
						else binop‰t(and_op,(wchk,rvis))
				val gbs = sterling_columns gb_sterling
				val gbd = dinary_columns gb_dinary
				val gbc = remove_constants(map class_column gb_class)
=TEX
=SML
				val groupby_test = fold(op @)(map column_data_test
								(gb_sterling @ gb_dinary))
				val having_test =	case valueèclassê having of
								constantèecê c =>
									if client_clearance() dom c	
									then []
									else 	[denote_false‰t]
							|	variable(exp,c) => 
									if client_clearance() dom c	
									then []
									else [binop‰t(dom_op,(cc,exp))]
				val tests = groupby_test @ having_test
				val checks = 	
					if length tests = 0
					then []
					else 	
					let 	val t = monop‰t(not_op,
							(fold(curry binop‰t and_op)tests))
						val bad = 	if client_clearance() dom max_rc
								then [where_v,t]
								else [rvis,where_v,t]
						val junk = anonymous_value‰t(denote_true‰t)
						val junk_sl = select_values‰t[junk]
					in [select‰t(all_tuples‰t(junk_sl,fs,
						fold(curry binop‰t and_op)bad,[],denote_true‰t))]
					end
				val sel_q = distinct_tuples‰t
						(sl,fs,w,gbs @ gbd @ gbc,valueèdataê having)
			in (sel_q,checks)
			end)		
=TEX
=SML
|	tuple_listèmake_outerê 	(evaluate‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)
						,scw,to_rc,to_tcs)
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val sel_vals = select_listèmakeê(sel,to_rc,to_tcs)
				val where_v = valueèdataê where
				val where_c = valueèclassê where
				val where_class = case where_c of
							variable(exp,c) => exp
						  |	constantèecê c => denote_class‰t c
				val sel_list = 	case scw of
						 true => [anonymous_value‰t where_class]@ sel_vals
						| false => sel_vals	
				val sl = select_values‰t sel_list
				val cc = denote_class‰t(client_clearance())
				val wchk = case where_c of
					   	variable(exp,c) => 
							if client_clearance() dom c	
							then where_v
							else 	let val ok = binop‰t(dom_op,(cc,exp))
								in binop‰t(or_op,(where_v,
									monop‰t(not_op,ok)))
								end
					    |	constantèecê c =>
							if client_clearance() dom c	
							then where_v
							else 	denote_true‰t
				val max_rc = fold (op lub)(map upb_row_class
								(lookup‰l‰o‰c‰a‰l‰_‰t‰a‰b‰l‰e‰_‰i‰n‰f‰o()))	
				val rcs = map denote_name(lookup‰l‰o‰c‰a‰l‰_‰r‰o‰w‰_‰c‰l‰a‰s‰s‰e‰s())
				val rvis = binop‰t(dom_op,(cc,fold(curry binop‰t lub_op)rcs))
				val w = 	if client_clearance() dom max_rc
						then wchk
						else binop‰t(and_op,(wchk,rvis))
				val gbs = sterling_columns gb_sterling
				val gbd = dinary_columns gb_dinary
				val gbc = remove_constants(map class_column gb_class)
=TEX
=SML
				val groupby_test = fold(op @)(map column_data_test
								(gb_sterling @ gb_dinary))
				val having_test =	case valueèclassê having of
								constantèecê c =>
									if client_clearance() dom c	
									then []
									else 	[denote_false‰t]
							|	variable(exp,c) => 
									if client_clearance() dom c	
									then []
									else [binop‰t(dom_op,(cc,exp))]
				val tests = groupby_test @ having_test
				val checks = 	
					if length tests = 0
					then []
					else 	
					let 	val t = monop‰t(not_op,
							(fold(curry binop‰t and_op)tests))
						val bad = 	if client_clearance() dom max_rc
								then [where_v,t]
								else [rvis,where_v,t]
						val junk = anonymous_value‰t(denote_true‰t)
						val junk_sl = select_values‰t[junk]
					in [select‰t(all_tuples‰t(junk_sl,fs,
						fold(curry binop‰t and_op)bad,[],denote_true‰t))]
					end
				val sel_q = evaluate‰t(sl,fs,w,gbs @ gbd @ gbc,valueèdataê having)
			in (sel_q,checks)
			end)		
=TEX
=SML
|	tuple_listèmake_outerê 	(tuple‰s vals,scw,to_rc,to_tcs) = 
			let 	val q = denote_class‰t (query_constants_class())
				val tvals = 	(case scw of 
						true => [q]
			  			| 	false => [])
						@ (case to_rc of
						constantètcê c => []
			  			|	other => [q])
						@ (fold(op @)(at2(map make_col)(vals,to_tcs)))
			in (tuple‰t tvals,[])
			end	
=TEX
=SML
|	tuple_listèmake_outerê 	(union‰s tls,scw,to_rc,to_tcs) = 
				if length tls = 1
				then tuple_listèmake_outerê(hd tls,scw,to_rc,to_tcs)
				else 	let	val (ts,qs) = split(at4(map tuple_listèmake_outerê)
								(tls,
									seq(length tls,scw),
									seq(length tls,to_rc),
									seq(length tls,to_tcs)))
					in (union‰t ts, fold (op @) qs)
					end
=TEX
=SML
|	tuple_listèmake_outerê 	(name_columns‰s(names,tul),scw,to_rc,to_tcs) 
						= tuple_listèmake_outerê(tul,scw,to_rc,to_tcs);	
=TEX	
=SML
fun 	(Ûtuple_listèouter_infoêİ : Tuple_listèssqlê ­ bool) 
			(table_contents‰s t) =  false
=TEX
=SML
|	tuple_listèouter_infoê(all_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val where_c = valueèclassê where
			in 	case where_c of
					variable(exp,c) => not(client_clearance() dom c)
				  |	constantèecê c => not(client_clearance() dom c)
			end)
=TEX
=SML
|	tuple_listèouter_infoê(distinct_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val where_c = valueèclassê where
			in 	case where_c of
					variable(exp,c) => not(client_clearance() dom c)
				  |	constantèecê c => not(client_clearance() dom c)
			end)
=TEX
=SML
|	tuple_listèouter_infoê(evaluate‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val where_c = valueèclassê where
			in 	case where_c of
					variable(exp,c) => not(client_clearance() dom c)
				  |	constantèecê c => not(client_clearance() dom c)
			end)
=TEX
=SML
|	tuple_listèouter_infoê(tuple‰s vals) = false
=TEX
=SML
|	tuple_listèouter_infoê(union‰s tls) = fold or(map tuple_listèouter_infoê tls)
=TEX
=SML
|	tuple_listèouter_infoê(name_columns‰s(names,tul)) = tuple_listèouter_infoê tul;
=TEX
=SML
fun 	(Ûtransformèselect_queryêİ : Queryèssqlê ­ SsqlCol list ¸ Queryètsqlê ¸ bool ¸ TsqlClassName 
							¸ TsqlCol list  ¸ Queryètsqlê list)
				(select‰s vals) = 	
					let 	val scw = tuple_listèouter_infoê vals
						val (tn,ti,scs,rc,tcs) = tuple_listèinfoê vals
						val (tul,chks) = tuple_listèmake_outerê(vals,scw,rc,tcs)
					in	(scs,select‰t tul,scw,rc,tcs,chks)
					end
|	transformèselect_queryê	q = raise internalError;	
=TEX							
=SML
fun 	(Ûqueryèselect_queryêİ : Queryèssqlê ­ Queryètsqlê)
			(select‰s vals) = 	let val (tn,ti,scs,rc,tcs) = tuple_listèinfoê vals
						in select‰t(tuple_listèmakeê(vals,rc,tcs))
						end
|	queryèselect_queryê q = raise internalError;
	
=TEX	
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}

