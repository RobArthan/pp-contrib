=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Execution Model Security Proofs}  %% Mandatory field
\TPPref{DS/FMU/FEF/031}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Approved}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.B.~Jones & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document contains the formal proofs relating to 
DS/FMU/FEF/026; it forms part of the Phase II proofs for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion(\FormatDate{$Date$
})] Latest approved version.
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document provides a formal proof relating
to the specifications in ``An Execution Model for SWORD'' \cite{DS/FMU/FEF/026}.
It constitutes part of deliverable D13 of work package 3, as given
in section 3 of the Proposal for Phase 2, \cite{DS/FMU/FEF/018}.


(The current version is a rough draft of proofs of some of the propositions
produced as pilot work during the third stage of phase 2.)

\subsection{Introduction}
\section{PRELIMINARIES}
The following \Product{} instructions set up a new theory $fef031$
to hold the theorems to be proved and set up a proof context in which
to carry out the proofs. Some theorems are required from the theory
$fef010$ defined in \cite{DS/FMU/FEF/010} and so this is made a parent of
the theory $fef031$.

=SML 
open_theory "fef026";
new_theory€"fef031"›;
new_parent"fef010";
set_pc"hol";
=TEX
\section{MISCELLANY}
=SML
set_goal([], ¨µf g list∑ Map f (Map g list) = Map (f o g) listÆ);
a(REPEAT strip_tac);
a(list_induction_tac ¨listÆ THEN asm_rewrite_tac[get_spec¨MapÆ]);
val map_o_lemma = save_pop_thm"map_o_lemma";
=TEX
=SML
set_goal([], ¨µc∑c lub c = c ± lubl[c] = cÆ);
a(strip_tac THEN rewrite_tac(map get_spec[¨MapÆ, ¨lublÆ, ¨FoldÆ, ¨HeadÆ]));
a(lemma_tac¨c dominates c ± c lub c dominates cÆ THEN1 prove_tac[get_spec¨$lubÆ]);
a(all_fc_tac[get_spec¨$lubÆ]);
a(all_fc_tac[get_spec¨$lubÆ]);
val €lub_lemma› = save_pop_thm"lub_lemma";
=TEX
=SML
push_goal([], ¨µc1 c2 c3∑
	c1 dominates c2 lub c3 § c1 dominates c2 ± c1 dominates c3Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨c2 lub c3 dominates c2Æ THEN1 rewrite_tac[get_spec¨$lubÆ]
	THEN all_fc_tac[get_spec¨$lubÆ]);
(* *** Goal "2" *** *)
a(lemma_tac¨c2 lub c3 dominates c3Æ THEN1 rewrite_tac[get_spec¨$lubÆ]
	THEN all_fc_tac[get_spec¨$lubÆ]);
(* *** Goal "3" *** *)
a(all_fc_tac[get_spec¨$lubÆ]);
val €dominates_lub_lemma› = save_pop_thm"dominates_lub_lemma";
=TEX
=SML
set_goal([], ¨µx1 x2 y1 y2∑MkDerTable x1 x2 = MkDerTable y1 y2 § x1 = y1 ± x2 = y2Æ);
a(REPEAT_UNTIL is_§ strip_tac THEN §_tac THEN_TRY asm_rewrite_tac[]);
a(LEMMA_T¨y1 = DT_spec (MkDerTable x1 x2) ± y2 = DT_rows (MkDerTable x1 x2)Æ
	rewrite_thm_tac
	THEN1 (asm_rewrite_tac[]THEN rewrite_tac[get_spec¨MkDerTableÆ]));
a(rewrite_tac[get_spec¨MkDerTableÆ]);
val €MkDerTable_lemma› = save_pop_thm"MkDerTable_lemma";
=TEX
=SML
set_goal([], ¨µx1 x2 x3 y1 y2 y3∑MkDerTableRow x1 x2 x3 = MkDerTableRow y1 y2 y3 § x1 = y1 ± x2 = y2 ± x3 = y3Æ);
a(REPEAT_UNTIL is_§ strip_tac THEN §_tac THEN_TRY asm_rewrite_tac[]);
a(LEMMA_T¨y1 = DTR_where (MkDerTableRow x1 x2 x3)
	± y2 = DTR_row (MkDerTableRow x1 x2 x3)
	 ± y3 = DTR_cols (MkDerTableRow x1 x2 x3)Æ
	rewrite_thm_tac
	THEN1 (asm_rewrite_tac[]THEN rewrite_tac[get_spec¨MkDerTableRowÆ]));
a(rewrite_tac[get_spec¨MkDerTableRowÆ]);
val €MkDerTableRow_lemma› = save_pop_thm"MkDerTableRow_lemma";
=TEX
\section{CONSISTENCY PROOFS}
=SML
push_consistency_goal¨isErrorÆ;
a(∂_tac¨(InL, InR, OutL, OutR, IsL, IsR)Æ);
a(rewrite_tac[get_spec¨IsLÆ]);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(∂_tac¨OutL veÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨OutR veÆ THEN asm_rewrite_tac[]);
val €isError_consistency_thm› = save_consistency_thm ¨isErrorÆ (pop_thm());
=TEX
\section{$ConditionE\_Lemma$}
=SML
val €conj100› = ¨ConditionE_LemmaÆ;
val €conj101› = ¨µ compile upd∑
	STP ç STP_secure_E compile
	¥ (EMâ1 compile upd, STP, outputFilter) ç subsys_secureE reprStateÆ;
val €conj102› = ¨µc : Class; s1 s2 : State∑
	hide (c, s1) = hide (c, s2)
	¥	Map (HideDerTable c) (Viewât(reprState s1))
	=	Map (HideDerTable c) (Viewât(reprState s2))Æ;
val €conj103› = ¨µc : Class; t1 t2 : DerTable; fps : FILTER_PARS∑
		HideDerTable c t1 = HideDerTable c t2
	¥		outputFilter(c, (GiveData t1, []), fps)
		=	outputFilter(c, (GiveData t2, []), fps)Æ;
val €conj104› = ¨µt : DerTable ∑ GiveData t = [] § DT_rows t = []Æ;
=TEX
=SML
set_goal([conj101], conj100);
a(rewrite_tac(map get_spec[¨ConditionE_LemmaÆ, ¨Correct_CompileÆ])
	THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(DROP_ASM_T ¨EMâ1 compile upd = TSQLtfÆ (asm_rewrite_thm_tac o eq_sym_rule));
val €ConditionE_Lemma1› = save_pop_thm"ConditionE_Lemma1";
=TEX
=SML
push_goal([], ¨
µupd; qdes∑ 
	Actât upd qdes
 =	let (query, (dt, errs), st) = qdes
	in
	if	≥errs = []
	then	(st, ([], errs))
	else if	is_select query
	then	(st, (GiveData dt, errs))
	else	(upd (query, (dt, errs), st), ([], []))
Æ
);
a(REPEAT strip_tac);
a(lemma_tac¨∂q d e s∑qdes = (q, (d, e), s)Æ 
	THEN_LIST[id_tac, asm_rewrite_tac[get_spec¨ActâtÆ, let_def]]);
a(MAP_EVERY ∂_tac [¨Fst qdesÆ, ¨Fst(Fst(Snd qdes))Æ,
	¨Snd(Fst(Snd qdes))Æ, ¨Snd(Snd qdes)Æ]
	THEN rewrite_tac[]);
val €Actât_lemma› = save_pop_thm"Actât_lemma";
=TEX
=SML
set_goal([conj102, conj103, conj104], conj101);
a(rewrite_tac(map get_spec[¨subsys_secureEÆ, ¨LetÆ,
	¨STP_secure_EÆ, ¨ConditionEÆ]));
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 5 (strip_asm_tac o
	once_rewrite_rule[prove_rule[]¨µp q∑p ≤ q § p ≤ (≥p ± q)Æ] o
	list_µ_elim[¨qÆ, ¨cÆ]));
(* *** Goal "1" *** *)
a(asm_rewrite_tac(map get_spec[¨ok_to_proceedÆ]));
(* *** Goal "2" *** *)
a(asm_rewrite_tac(map get_spec[¨ok_to_proceedÆ, ¨LetÆ]));
a(all_asm_ante_tac);
a(lemma_tac¨∂dq ocq fps∑destVal (STP (q, c)) = (dq, ocq, fps)Æ
	THEN1
	(MAP_EVERY ∂_tac [¨Fst (destVal (STP (q, c)))Æ,
		¨Fst(Snd (destVal (STP (q, c))))Æ,
		¨Snd(Snd (destVal (STP (q, c))))Æ]
	THEN rewrite_tac[]));
a(asm_rewrite_tac[] THEN REPEAT_N 9 strip_tac);
a(lemma_tac¨Viewât (reprState sâ1) ç RiskInputs c (compile dq)Æ);
(* *** Goal "2.1" *** *)
a(rewrite_tac[get_spec¨RiskInputsÆ] THEN REPEAT strip_tac);
a(∂_tac¨Viewât (reprState sâ2)Æ);
a(ALL_ASM_FC_T rewrite_tac []);
a(contr_tac);
a(LIST_DROP_NTH_ASM_T [6, 7] (MAP_EVERY ante_tac)
	THEN asm_rewrite_tac(Actât_lemma::map get_spec[¨EMâ1Æ, ¨EMÆ, ¨LetÆ]));
a(cases_tac ¨≥ Snd (compile dq (Viewât (reprState sâ1))) = []Æ
	THEN cases_tac ¨is_select dqÆ
	THEN asm_rewrite_tac[]);
(* *** Goal "2.1.1" *** *)
a(contr_tac);
a(DROP_NTH_ASM_T 11 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a(contr_tac);
a(DROP_NTH_ASM_T 11 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.1.3" *** *)
a(contr_tac);
a(DROP_NTH_ASM_T 11 ante_tac THEN asm_rewrite_tac[]);
a(ALL_ASM_FC_T rewrite_tac []);
(* *** Goal "2.1.4" *** *)
a(contr_tac);
a(DROP_NTH_ASM_T 11 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(LIST_GET_NTH_ASM_T [2] (FC_T (MAP_EVERY ante_tac)));
a(strip_tac THEN asm_rewrite_tac[]);
a(rewrite_tac[taut_rule¨µa b c∑ (a ¥ ≥b) ¥ c § (≥a ¥ c) ± (a ± ≥b ¥ c)Æ]);
a(REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(asm_rewrite_tac(Actât_lemma::map get_spec[¨EMâ1Æ, ¨EMÆ, ¨LetÆ]));
(* *** Goal "2.2.2" *** *)
a(POP_ASM_T ante_tac);
a(asm_rewrite_tac(Actât_lemma::map get_spec[¨EMâ1Æ, ¨EMÆ, ¨LetÆ]));
val €ConditionE_Lemma2› = save_pop_thm"ConditionE_Lemma2";
=TEX
=SML
set_goal([], conj104);
a(rewrite_tac(map get_spec [¨GiveDataÆ, ¨LetÆ]));
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[get_spec¨MapÆ]);
a(all_asm_ante_tac THEN strip_asm_tac(µ_elim ¨DT_rows tÆ list_cases_thm)
	THEN asm_rewrite_tac[get_spec¨MapÆ]);
val €ConditionE_Lemma3› = save_pop_thm"ConditionE_Lemma3";
=TEX
\section{RISK INPUT CALCULATION}
=SML
set_goal([], ¨µc t∑ DT_spec (HideDerTable c t) = DT_spec tÆ);
a(rewrite_tac (map get_spec[¨HideDerTableÆ, ¨DT_specÆ, ¨LetÆ]));
val €DT_spec_HideDerTable_lemma› = save_pop_thm"DT_spec_HideDerTable_lemma";
=TEX
=SML
set_goal([], ¨µc ts1 ts2∑
	Map (HideDerTable c) ts1 = Map (HideDerTable c) ts2
¥	(Map DT_spec ts1) = (Map DT_spec ts2)Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨
	Map DT_spec(Map (HideDerTable c) ts1) =
	Map DT_spec(Map (HideDerTable c) ts2)Æ
	ante_tac THEN1 asm_rewrite_tac[]);
a(lemma_tac¨DT_spec o HideDerTable c = DT_specÆ
	THEN1 PC_T1 "hol2" rewrite_tac[DT_spec_HideDerTable_lemma]);
a(asm_rewrite_tac[map_o_lemma]);
val €map_HideDerTable_map_DT_spec_lemma› =
	save_pop_thm"map_HideDerTable_map_DT_spec_lemma";
=TEX
=SML
push_goal([], ¨µc r rs∑
	HideDerTableData c [] = []
±	HideDerTableData c (Cons r rs) = 
		if	c dominates (DTR_row r lub DTR_where r)
		then	Cons (HideDerTableRow c r) (HideDerTableData c rs)
		else	HideDerTableData c rs
Æ);
a(rewrite_tac(map get_spec[¨HideDerTableDataÆ, ¨$˘Æ, ¨MapÆ, ¨LetÆ]));
a(REPEAT strip_tac);
a(cases_tac¨c dominates (DTR_row r lub DTR_where r)Æ THEN asm_rewrite_tac[]);
a(rewrite_tac(map get_spec[¨MapÆ]));
val €HideDerTableData_lemma› = save_pop_thm"HideDerTableData_lemma";
=TEX
=SML
push_goal([], ¨µc r1 r2 rs∑
	JoinRows r1 [] = []
±	JoinRows r1 (Cons r2 rs) = 
	Cons
	(MkDerTableRow
		(DTR_where r1 lub DTR_where r2)
		(DTR_row r1 lub DTR_row r2)
		(DTR_cols r1 Î DTR_cols r2))
	(JoinRows r1 rs)
Æ);
a(rewrite_tac(map get_spec[¨JoinRowsÆ, ¨MapÆ, ¨LetÆ]));
val €JoinRows_lemma› = save_pop_thm"JoinRows_lemma";
=TEX
=SML
push_goal([], ¨µc blks∑
	HideDerTableData c (Flat blks) = Flat (Map (HideDerTableData c) blks)
Æ);
a(REPEAT strip_tac);
a(list_induction_tac¨blksÆ THEN asm_rewrite_tac(map get_spec[¨FlatÆ, ¨MapÆ]));
(* *** Goal "1" *** *)
a(rewrite_tac(map get_spec[¨HideDerTableDataÆ, ¨MapÆ, ¨LetÆ, ¨$˘Æ]));
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(list_induction_tac¨xÆ);
(* *** Goal "1" *** *)
a(lemma_tac¨HideDerTableData c [] = []Æ
	THEN1 rewrite_tac(map get_spec[¨HideDerTableDataÆ, ¨MapÆ, ¨LetÆ, ¨$˘Æ]));
a(asm_rewrite_tac(map get_spec[¨$AppendÆ, ¨MapÆ, ¨FlatÆ]));
(* *** Goal "2.2" *** *)
a(rewrite_tac(map get_spec[¨$AppendÆ, ¨MapÆ, ¨FlatÆ]));
a(all_asm_ante_tac
	THEN rewrite_tac(map get_spec[¨HideDerTableDataÆ, ¨MapÆ, ¨LetÆ])
	THEN REPEAT strip_tac);
a(rewrite_tac[get_spec¨$˘Æ]);
a(cases_tac ¨c dominates DTR_row x' lub DTR_where x'Æ THEN
	TOP_ASM_T rewrite_thm_tac
	THEN asm_rewrite_tac(map get_spec[¨MapÆ, ¨$AppendÆ]));
val €HideDerTable_flat_lemma› =
	save_pop_thm"HideDerTable_flat_lemma";
=TEX
=SML
val €conj1› = ¨RiskInputs c (Ãdtl∑ (Join dtl, [])) = {}Æ;
val €conj2› = ¨µc ts1 ts2∑
	Map (HideDerTable c) ts1 = Map (HideDerTable c) ts2
¥	HideDerTableData c (JoinData (Map DT_rows ts1)) =
	HideDerTableData c (JoinData (Map DT_rows ts2))Æ;
val €conj3› = ¨µc ts1 ts2∑
	Map (HideDerTable c) ts1 = Map (HideDerTable c) ts2
¥	Map (HideDerTableData c) (Map DT_rows ts1)
	= Map (HideDerTableData c) (Map DT_rows ts2)Æ;
val €conj4› = ¨µc ds1 ds2∑
	Map (HideDerTableData c) ds1 = Map (HideDerTableData c) ds2
¥	HideDerTableData c (JoinData ds1) =
	HideDerTableData c (JoinData ds2)Æ;
val €conj5› = ¨µc rs1 rs2∑
	Flat(Map (Ãr∑ HideDerTableData c (JoinRows r rs2)) rs1) =
	Flat(Map (Ãr∑ JoinRows r (HideDerTableData c rs2)) (HideDerTableData c rs1))Æ;
val €conj6› = ¨µc r rs∑
		HideDerTableData c (JoinRows r rs)
	=	if	c dominates DTR_row r lub DTR_where r
		then	JoinRows (HideDerTableRow c r) (HideDerTableData c rs)
		else []Æ;
=TEX
=SML
set_goal([conj2], conj1);
a(rewrite_tac[get_spec¨RiskInputsÆ]);
a(PC_T "sets_ext" contr_tac);
a(all_asm_ante_tac THEN rewrite_tac[]);
a(REPEAT strip_tac);
a(rewrite_tac(map get_spec[¨JoinÆ, ¨HideDerTableÆ, ¨MkDerTableÆ]));
a(ALL_ASM_FC_T rewrite_tac [map_HideDerTable_map_DT_spec_lemma]);
val €RiskInputs_Join_lemma1› = save_pop_thm"RiskInputs_Join_lemma1";
=TEX
=SML
set_goal([conj3, conj4], conj2);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(all_asm_fc_tac[]);
val €RiskInputs_Join_lemma2› = save_pop_thm"RiskInputs_Join_lemma2";
=TEX
=SML
set_goal([], conj3);
a(REPEAT_N 2 strip_tac);
a(list_induction_tac¨ts1Æ);
(* *** Goal "1" *** *)
a(strip_tac);
a(strip_asm_tac(µ_elim¨ts2Æ list_cases_thm)
	THEN asm_rewrite_tac[map_def]);
(* *** Goal "2" *** *)
a(REPEAT_N 2 strip_tac);
a(strip_asm_tac(µ_elim¨ts2Æ list_cases_thm)
	THEN asm_rewrite_tac[map_def]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(asm_ante_tac ¨HideDerTable c x = HideDerTable c x'Æ
	THEN rewrite_tac[MkDerTable_lemma, get_spec¨HideDerTableÆ]);
a(REPEAT strip_tac);
val €RiskInputs_Join_lemma3› = save_pop_thm"RiskInputs_Join_lemma3";
=TEX
=SML
set_goal([conj5], conj4);
a(strip_tac THEN strip_tac);
a(list_induction_tac ¨ds1Æ);
(* *** Goal "1" *** *)
a(rewrite_tac[get_spec¨MapÆ, map_null_thm]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[get_spec¨MapÆ] THEN REPEAT µ_tac);
a(strip_asm_tac(µ_elim¨ds2Ælist_cases_thm) THEN 
	asm_rewrite_tac[get_spec¨MapÆ, map_null_thm]);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim¨ds1Ælist_cases_thm));
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ, map_null_thm]);
a(REPEAT strip_tac THEN var_elim_asm_tac¨list2 = []Æ);
a(asm_rewrite_tac(map get_spec [¨JoinDataÆ, ¨LetÆ]));
(* *** Goal "2.2" *** *)
a(lemma_tac¨≥ds1 = [] ± ≥list2 = []Æ THEN1 asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
a(swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[get_spec¨MapÆ, map_null_thm]);
(* *** Goal "2.2.2" *** *)
a(LIST_DROP_NTH_ASM_T [3, 6] (Combinators.K id_tac));
a(asm_rewrite_tac(let_def::HideDerTable_flat_lemma::map get_spec [¨JoinDataÆ]));
a(asm_rewrite_tac[map_o_lemma,
	pc_rule1"hol2"prove_rule[]¨µf g z∑(f o (Ãx∑g x z)) = (Ãx∑f(g x z))Æ]);
a(ALL_ASM_FC_T rewrite_tac[]);
val €RiskInputs_Join_lemma4› = save_pop_thm"RiskInputs_Join_lemma4";
=TEX
=SML
set_goal([conj6], conj5);
a(REPEAT strip_tac);
a(list_induction_tac ¨rs1Æ);
(* *** Goal "1" *** *)
a(rewrite_tac(map get_spec[¨HideDerTableDataÆ, ¨FlatÆ, ¨MapÆ, ¨LetÆ, ¨$˘Æ]));
(* *** Goal "2" *** *)
a(rewrite_tac(HideDerTableData_lemma :: map get_spec[¨FlatÆ, ¨MapÆ]));
a(strip_tac);
a(cases_tac¨c dominates (DTR_row x lub DTR_where x)Æ
	THEN asm_rewrite_tac(map get_spec[¨$ÎÆ, ¨MapÆ, ¨FlatÆ]));
val €RiskInputs_Join_lemma5› = save_pop_thm"RiskInputs_Join_lemma5";
=TEX
=SML
set_goal([], conj6);
a(REPEAT strip_tac);
a(list_induction_tac¨rsÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[HideDerTableData_lemma, JoinRows_lemma]);
a(CASES_T ¨c dominates (DTR_row r lub DTR_where r)Æ rewrite_thm_tac);
(* *** Goal "2" *** *)
a(strip_tac);
a(cases_tac ¨c dominates (DTR_row r lub DTR_where r)Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a(swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[] THEN swap_nth_asm_concl_tac 1);
a(DROP_NTH_ASM_T 2 ante_tac);
a(rewrite_tac[HideDerTableData_lemma, JoinRows_lemma,
	dominates_lub_lemma, get_spec¨MkDerTableRowÆ]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
a(cases_tac ¨c dominates DTR_row x ± c dominates DTR_where xÆ
	THEN asm_rewrite_tac[]);
a(rewrite_tac[JoinRows_lemma]);
a(asm_rewrite_tac(MkDerTableRow_lemma:: map_Î_thm1::
	map get_spec[¨HideDerTableRowÆ, ¨MkDerTableRowÆ, ¨LetÆ]));
(* *** Goal "2.2" *** *)
a(POP_ASM_T ante_tac);
a(asm_rewrite_tac[HideDerTableData_lemma, JoinRows_lemma,
	dominates_lub_lemma, get_spec¨MkDerTableRowÆ]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val €RiskInputs_Join_lemma6› = save_pop_thm"RiskInputs_Join_lemma6";
=TEX
=SML
push_goal([], ¨µx∑≥IsL x § IsR xÆ);
a(rewrite_tac[sum_clauses]);
a(contr_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[sum_clauses]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨InR (OutR x) = InL (OutL x)Æ (strip_asm_tac o rewrite_rule[])
	THEN pure_asm_rewrite_tac[] THEN REPEAT strip_tac);
val ≥_is_l_lemma = save_pop_thm "≥_is_l_lemma";
=TEX
=SML
set_goal([], conj1);
a(MAP_EVERY (ante_tac o all_¥_intro) [
	RiskInputs_Join_lemma1,
	RiskInputs_Join_lemma2,
	RiskInputs_Join_lemma3,
	RiskInputs_Join_lemma4,
	RiskInputs_Join_lemma5,
	RiskInputs_Join_lemma6]
	THEN taut_tac);
val €RiskInputs_Join_thm› = save_pop_thm"RiskInputs_Join_thm";
=TEX
=IGN
set_goal([], ¨
	µe∑ µ
=TEX
\section{CLOSING DOWN}
The following \Product{} instruction restores the previous proof context.
=SML
pop_pc();
=TEX

\newpage
\HOLindexOff
\input{fef031th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}
