=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Execution Model Security Proofs}  %% Mandatory field
\TPPref{DS/FMU/FEF/031}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Approved}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.B.~Jones & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document contains the formal proofs relating to 
DS/FMU/FEF/026; it forms part of the Phase II proofs for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion(\FormatDate{$Date$
})] Removed obsolete material.
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document provides a formal proof relating
to the specifications in ``An Execution Model for SWORD'' \cite{DS/FMU/FEF/026}.
It constitutes part of deliverable D13 of work package 3, as given
in section 3 of the Proposal for Phase 2, \cite{DS/FMU/FEF/018}.


(The current version is a rough draft of proofs of some of the propositions
produced as pilot work during the third stage of phase 2.)

\subsection{Introduction}
This document provides a formal proof of the  conjecture
$EM\_SecureE_1$ from the proof strategy document, \cite{DS/FMU/FEF/034}, which states
that $Viewât\_secureE$ and $outputFilter\_secureE$ imply
$EM\_SecureE$.
\section{PRELIMINARIES}
The following \Product{} instructions set up a new theory $fef031$
to hold the theorems to be proved and set up a proof context in which
to carry out the proofs. Some theorems are required from the theory
$fef010$ defined in \cite{DS/FMU/FEF/010} and so this is made a parent of
the theory $fef031$.

=SML 
open_theory "fef026";
new_theory€"fef031"›;
new_parent"fef010";
new_parent"fef034";
set_pc"hol";
=TEX
\section{MISCELLANY}
=SML
set_goal([], ¨µf g list∑ Map f (Map g list) = Map (f o g) listÆ);
a(REPEAT strip_tac);
a(list_induction_tac ¨listÆ THEN asm_rewrite_tac[get_spec¨MapÆ]);
val map_o_lemma = save_pop_thm"map_o_lemma";
=TEX
=SML
set_goal([], ¨µc∑c lub c = c ± lubl[c] = cÆ);
a(strip_tac THEN rewrite_tac(map get_spec[¨MapÆ, ¨lublÆ, ¨FoldÆ, ¨HeadÆ]));
a(strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨c dominates c ± c lub c dominates cÆ THEN1 prove_tac[get_spec¨$lubÆ]);
a(all_fc_tac[get_spec¨$lubÆ]);
a(all_fc_tac[get_spec¨$lubÆ]);
(* *** Goal "2" *** *)
a(lemma_tac¨c dominates c lub lattice_bottom ± c lub lattice_bottom dominates cÆ
	THEN1 prove_tac[get_spec¨$lubÆ]);
(* *** Goal "2.1" *** *)
a(lemma_tac¨c dominates c ± c dominates lattice_bottomÆ
	THEN1 prove_tac[get_spec¨$lubÆ]);
a(all_fc_tac[get_spec¨$lubÆ]);
(* *** Goal "2.2" *** *)
a(all_fc_tac[get_spec¨$lubÆ]);
val €lub_lemma› = save_pop_thm"lub_lemma";
=TEX
=SML
push_goal([], ¨µc1 c2 c3∑
	c1 dominates c2 lub c3 § c1 dominates c2 ± c1 dominates c3Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨c2 lub c3 dominates c2Æ THEN1 rewrite_tac[get_spec¨$lubÆ]
	THEN all_fc_tac[get_spec¨$lubÆ]);
(* *** Goal "2" *** *)
a(lemma_tac¨c2 lub c3 dominates c3Æ THEN1 rewrite_tac[get_spec¨$lubÆ]
	THEN all_fc_tac[get_spec¨$lubÆ]);
(* *** Goal "3" *** *)
a(all_fc_tac[get_spec¨$lubÆ]);
val €dominates_lub_lemma› = save_pop_thm"dominates_lub_lemma";
=TEX
=SML
set_goal([], ¨µx1 x2 y1 y2∑MkDerTable x1 x2 = MkDerTable y1 y2 § x1 = y1 ± x2 = y2Æ);
a(REPEAT_UNTIL is_§ strip_tac THEN §_tac THEN_TRY asm_rewrite_tac[]);
a(LEMMA_T¨y1 = DT_spec (MkDerTable x1 x2) ± y2 = DT_rows (MkDerTable x1 x2)Æ
	rewrite_thm_tac
	THEN1 (asm_rewrite_tac[]THEN rewrite_tac[get_spec¨MkDerTableÆ]));
a(rewrite_tac[get_spec¨MkDerTableÆ]);
val €MkDerTable_lemma› = save_pop_thm"MkDerTable_lemma";
=TEX
=SML
set_goal([], ¨µx1 x2 x3 y1 y2 y3∑MkDerTableRow x1 x2 x3 = MkDerTableRow y1 y2 y3 
	§ x1 = y1 ± x2 = y2 ± x3 = y3Æ);
a(REPEAT_UNTIL is_§ strip_tac THEN §_tac THEN_TRY asm_rewrite_tac[]);
a(LEMMA_T¨y1 = DTR_where (MkDerTableRow x1 x2 x3)
	± y2 = DTR_row (MkDerTableRow x1 x2 x3)
	 ± y3 = DTR_cols (MkDerTableRow x1 x2 x3)Æ
	rewrite_thm_tac
	THEN1 (asm_rewrite_tac[]THEN rewrite_tac[get_spec¨MkDerTableRowÆ]));
a(rewrite_tac[get_spec¨MkDerTableRowÆ]);
val €MkDerTableRow_lemma› = save_pop_thm"MkDerTableRow_lemma";
=TEX
\section{CONSISTENCY PROOFS}
=SML
push_consistency_goal¨isErrorÆ;
a(∂_tac¨(InL, InR, OutL, OutR, IsL, IsR)Æ);
a(rewrite_tac[get_spec¨IsLÆ]);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(∂_tac¨OutL veÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨OutR veÆ THEN asm_rewrite_tac[]);
val €isError_consistency_thm› = save_consistency_thm ¨isErrorÆ (pop_thm());
=TEX
\section{$EM\_SecureE$}

=SML
val €conj100› = ¨Correct_Compile_STP_secure_E ¥ Subsys_SecureEÆ;
val €conj101› = ¨µ compile upd∑
	STP ç STP_secure_E compile
	¥ (EMâ1 compile upd, STP, outputFilter) ç subsys_secureE reprStateÆ;
val €conj102› = ¨Viewât_secureEÆ;
val €conj103› = ¨outputFilter_secureEÆ;
val €conj104› = ¨µt : DerTable ∑ GiveData t = [] § DT_rows t = []Æ;
=TEX
=SML
set_goal([conj101], conj100);
a(rewrite_tac(map get_spec[¨Correct_Compile_STP_secure_EÆ,
	¨Correct_CompileÆ,¨Subsys_SecureEÆ]) THEN REPEAT strip_tac);
a(DROP_ASM_T ¨EMâ1 compile upd = TSQLtfÆ (rewrite_thm_tac o eq_sym_rule));
a(asm_fc_tac[] THEN asm_rewrite_tac[]);
val €EM_SecureE_Lemma1› = save_pop_thm"EM_SecureE_Lemma1";
=TEX
=SML
push_goal([], ¨
µupd; qdes∑ 
	Actât upd qdes
 =	let (query, (dt, errs), st) = qdes
	in
	if	≥errs = []
	then	(st, ([], errs))
	else if	is_select query
	then	(st, (GiveData dt, errs))
	else	(upd (query, (dt, errs), st), ([], []))
Æ
);
a(REPEAT strip_tac);
a(lemma_tac¨∂q d e s∑qdes = (q, (d, e), s)Æ 
	THEN_LIST[id_tac, asm_rewrite_tac[get_spec¨ActâtÆ, let_def]]);
a(MAP_EVERY ∂_tac [¨Fst qdesÆ, ¨Fst(Fst(Snd qdes))Æ,
	¨Snd(Fst(Snd qdes))Æ, ¨Snd(Snd qdes)Æ]
	THEN rewrite_tac[]);
val €Actât_lemma› = save_pop_thm"Actât_lemma";
=TEX
=SML
set_goal([conj102, conj103, conj104], conj101);
a(rewrite_tac(map get_spec[¨subsys_secureEÆ, ¨LetÆ,
	¨STP_secure_EÆ, ¨ConditionEÆ]));
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 5 (strip_asm_tac o
	once_rewrite_rule[prove_rule[]¨µp q∑p ≤ q § p ≤ (≥p ± q)Æ] o
	list_µ_elim[¨qÆ, ¨cÆ]));
(* *** Goal "1" *** *)
a(asm_rewrite_tac(map get_spec[¨ok_to_proceedÆ]));
(* *** Goal "2" *** *)
a(asm_rewrite_tac(map get_spec[¨ok_to_proceedÆ, ¨LetÆ]));
a(all_asm_ante_tac);
a(lemma_tac¨∂dq ocq fps∑destVal (STP (q, c)) = (dq, ocq, fps)Æ
	THEN1
	(MAP_EVERY ∂_tac [¨Fst (destVal (STP (q, c)))Æ,
		¨Fst(Snd (destVal (STP (q, c))))Æ,
		¨Snd(Snd (destVal (STP (q, c))))Æ]
	THEN rewrite_tac[]));
a(asm_rewrite_tac[] THEN REPEAT_N 9 strip_tac);
a(lemma_tac¨Viewât (reprState sâ1) ç RiskInputs c (compile dq)Æ);
=TEX
=SML
(* *** Goal "2.1" *** *)
a(rewrite_tac[get_spec¨RiskInputsÆ] THEN REPEAT strip_tac);
a(∂_tac¨Viewât (reprState sâ2)Æ);
a(DROP_ASM_T ¨Viewât_secureEÆ (strip_asm_tac o rewrite_rule[get_spec¨Viewât_secureEÆ]));
a(ALL_ASM_FC_T rewrite_tac []);
a(contr_tac);
a(LIST_DROP_NTH_ASM_T [7,8] (MAP_EVERY ante_tac)
	THEN asm_rewrite_tac(Actât_lemma::map get_spec[¨EMâ1Æ, ¨EMÆ, ¨LetÆ]));
a(cases_tac ¨≥ Snd (compile dq (Viewât (reprState sâ1))) = []Æ
	THEN cases_tac ¨is_select dqÆ
	THEN asm_rewrite_tac[]);
(* *** Goal "2.1.1" *** *)
a(contr_tac);
a(DROP_NTH_ASM_T 12 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a(contr_tac);
a(DROP_NTH_ASM_T 12 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.1.3" *** *)
a(contr_tac);
a(DROP_NTH_ASM_T 12 ante_tac THEN asm_rewrite_tac[]);
a(DROP_ASM_T¨outputFilter_secureEÆ (strip_asm_tac o rewrite_rule[get_spec¨outputFilter_secureEÆ]));
a(ALL_ASM_FC_T rewrite_tac []);
(* *** Goal "2.1.4" *** *)
a(contr_tac);
a(DROP_NTH_ASM_T 12 ante_tac THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "2.2" *** *)
a(LIST_GET_NTH_ASM_T [2] (FC_T (MAP_EVERY ante_tac)));
a(strip_tac THEN asm_rewrite_tac[]);
a(rewrite_tac[taut_rule¨µa b c∑ (a ¥ ≥b) ¥ c § (≥a ¥ c) ± (a ± ≥b ¥ c)Æ]);
a(REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(asm_rewrite_tac(Actât_lemma::map get_spec[¨EMâ1Æ, ¨EMÆ, ¨LetÆ]));
(* *** Goal "2.2.2" *** *)
a(POP_ASM_T ante_tac);
a(asm_rewrite_tac(Actât_lemma::map get_spec[¨EMâ1Æ, ¨EMÆ, ¨LetÆ]));
val €EM_SecureE_Lemma2› = save_pop_thm"EM_SecureE_Lemma2";
=TEX
=SML
set_goal([], conj104);
a(rewrite_tac(map get_spec [¨GiveDataÆ, ¨LetÆ]));
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[get_spec¨MapÆ]);
a(all_asm_ante_tac THEN strip_asm_tac(µ_elim ¨DT_rows tÆ list_cases_thm)
	THEN asm_rewrite_tac[get_spec¨MapÆ]);
val €EM_SecureE_Lemma3› = save_pop_thm"EM_SecureE_Lemma3";
=TEX
=SML
set_goal([],¨EM_SecureEÆ);
a(rewrite_tac[get_spec¨EM_SecureEÆ]);
a(REPEAT strip_tac);
a(strip_asm_tac EM_SecureE_Lemma3);
a(strip_asm_tac EM_SecureE_Lemma2);
a(strip_asm_tac EM_SecureE_Lemma1);
val €EM_SecureE_thm› = save_pop_thm"EM_SecureE_thm";
=TEX
\newpage
\HOLindexOff
\input{fef031th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}
