
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Table Computation Security Proofs}  %% Mandatory field
\TPPref{DS/FMU/FEF/035}  %% Mandatory field
\def\SCCSversion{$Revision: 1.9 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 1993/11/09 17:29:13 $
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
%\TPPauthor{R.~D.~Arthan & WIN01}  %% Mandatory field
\TPPauthors{R.~D.~Arthan & WIN01\\G.~M.~Prout & WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document completes the formal proofs relating to 
DS/FMU/FEF/032; it forms part of the Phase II proofs for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\def\TPPheadlhs{Lemma 1}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion(\FormatDate{$Date: 1993/11/09 17:29:13 $
})] Lemmas renamed. Section bringing together proofs from fef033 and fef035 moved to fef036.
\item[Issue 1.10] Removed dependency on ICL logo font
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document provides a formal proof relating
to the specifications in ``An Execution Model for SWORD'' \cite{DS/FMU/FEF/026}.
It constitutes part of deliverable D13 of work package 3, as given
in section 3 of the Proposal for Phase 2, \cite{DS/FMU/FEF/018}.


(The current version is a rough draft of proofs of some of the propositions
produced as pilot work during the third stage of phase 2.)

\subsection{Introduction}
\section{PRELIMINARIES}
The following \Product{} instructions set up a new theory $fef035$
to hold the theorems to be proved and set up a proof context in which
to carry out the proofs. 

=SML 
open_theory "fef033";
(force_delete_theory "fef035" handle _ => ());
new_theory€"fef035"›;
set_pc"hol";
=TEX
\section{LEMMAS}
=SML
push_goal([],¨µ f l∑ Length (Map f l) = Length lÆ);
a(REPEAT µ_tac);
a(list_induction_tac¨lÆTHEN asm_rewrite_tac(map get_spec[¨MapÆ,¨LengthÆ]));
val €length_map_lemma› = save_pop_thm"length_map_lemma";
=TEX
=SML
push_goal([], ¨µl i f  ∑  i º # l ± 1 º i 
	¥ f (Nth l i) = Nth (Map f l) i Æ);
a µ_tac;
a(list_induction_tac¨lÆ THEN rewrite_tac(map get_spec[¨NthÆ,¨MapÆ,¨LengthÆ])
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(cases_tac¨i=1ÆTHEN asm_rewrite_tac[]);
a(list_spec_nth_asm_tac 4 [¨i-1Æ,¨fÆ]);
(* *** Goal "2.1" *** *)
a(GET_ASM_T ¨1 º iÆ (strip_asm_tac o rewrite_rule[get_spec¨$ºÆ]));
a(var_elim_nth_asm_tac 1);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[]));
(* *** Goal "2.2" *** *)
a(GET_ASM_T ¨1 º iÆ (strip_asm_tac o rewrite_rule[get_spec¨$ºÆ]));
a(var_elim_nth_asm_tac 1);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[]));
a(strip_asm_tac (µ_elim¨i'Æ Ó_cases_thm));
a(var_elim_nth_asm_tac 1);
val €fun_nth_map_lemma› = save_pop_thm"fun_nth_map_lemma";
=TEX
=SML
push_goal([], ¨µi f lâ1 lâ2 ∑  i º # lâ1  ± 1 º i ± Map f lâ1 = Map f lâ2
	¥ f (Nth lâ1 i) = f (Nth lâ2 i) Æ);
a(REPEAT strip_tac);
a(lemma_tac¨# (Map f lâ1) = # (Map f lâ2)Æ
	THEN1 asm_rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule [length_map_thm]));
a(lemma_tac¨i º # lâ2Æ
	THEN1 POP_ASM_T (asm_rewrite_thm_tac o eq_sym_rule));
a(all_fc_tac[fun_nth_map_lemma]);
a(asm_rewrite_tac[]);
val €fun_nth_map_lemma1› = save_pop_thm"fun_nth_map_lemma1";
=TEX
=SML
push_goal([],¨µ tl el gp gps ∑
	ProjectData tl el [] = []
±	ProjectData tl el (Cons gp gps) = 
	Map (Ã r∑ MkDerTableRow (DTR_where r) (DTR_row r) (Map (Ã e∑ e tl gp r) el)) gp
	Î ProjectData tl el gpsÆ);
a(rewrite_tac(map get_spec[¨MapÆ,¨ProjectDataÆ,¨FlatÆ,¨LetÆ]) THEN REPEAT strip_tac);
val €ProjectData_lemma› = save_pop_thm"ProjectData_lemma";
=TEX
=SML
set_goal([], ¨µc t∑ DT_spec (HideDerTable c t) = DT_spec tÆ);
a(rewrite_tac (map get_spec[¨HideDerTableÆ, ¨DT_specÆ, ¨LetÆ]));
val €DT_spec_HideDerTable_lemma› = save_pop_thm"DT_spec_HideDerTable_lemma";
=TEX
=SML
set_goal([], ¨µc ts1 ts2∑
	Map (HideDerTable c) ts1 = Map (HideDerTable c) ts2
¥	(Map DT_spec ts1) = (Map DT_spec ts2)Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨
	Map DT_spec(Map (HideDerTable c) ts1) =
	Map DT_spec(Map (HideDerTable c) ts2)Æ
	ante_tac THEN1 asm_rewrite_tac[]);
a(lemma_tac¨DT_spec o HideDerTable c = DT_specÆ
	THEN1 PC_T1 "hol2" rewrite_tac[DT_spec_HideDerTable_lemma]);
a(asm_rewrite_tac[map_o_lemma]);
val €map_HideDerTable_map_DT_spec_lemma› =
	save_pop_thm"map_HideDerTable_map_DT_spec_lemma";
=TEX
=SML
push_goal([], ¨µc r rs∑
	HideDerTableData c [] = []
±	HideDerTableData c (Cons r rs) = 
		if	c dominates DTR_row r
		then	Cons (HideDerTableRow c r) (HideDerTableData c rs)
		else	HideDerTableData c rs
Æ);
a(rewrite_tac(map get_spec[¨HideDerTableDataÆ, ¨$˘Æ, ¨MapÆ, ¨LetÆ]));
a(REPEAT strip_tac);
a(cases_tac¨c dominates DTR_row rÆ THEN asm_rewrite_tac[get_spec¨MapÆ]);
val €HideDerTableData_lemma› = save_pop_thm"HideDerTableData_lemma";
=TEX
=SML
push_goal([], ¨µc r1 r2 rs∑
	JoinRows r1 [] = []
±	JoinRows r1 (Cons r2 rs) = 
	Cons
	(MkDerTableRow
		(DTR_where r1 lub DTR_where r2)
		(DTR_row r1 lub DTR_row r2)
		(DTR_cols r1 Î DTR_cols r2))
	(JoinRows r1 rs)
Æ);
a(rewrite_tac(map get_spec[¨JoinRowsÆ, ¨MapÆ, ¨LetÆ]));
val €JoinRows_lemma› = save_pop_thm"JoinRows_lemma";
=TEX
=SML
push_goal([], ¨µc blks∑
	HideDerTableData c (Flat blks) = Flat (Map (HideDerTableData c) blks)
Æ);
a(REPEAT strip_tac);
a(list_induction_tac¨blksÆ THEN asm_rewrite_tac(map get_spec[¨FlatÆ, ¨MapÆ]));
(* *** Goal "1" *** *)
a(rewrite_tac(map get_spec[¨HideDerTableDataÆ, ¨MapÆ, ¨LetÆ, ¨$˘Æ]));
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(list_induction_tac¨xÆ);
(* *** Goal "1" *** *)
a(lemma_tac¨HideDerTableData c [] = []Æ
	THEN1 rewrite_tac(map get_spec[¨HideDerTableDataÆ, ¨MapÆ, ¨LetÆ, ¨$˘Æ]));
a(asm_rewrite_tac(map get_spec[¨$AppendÆ, ¨MapÆ, ¨FlatÆ]));
(* *** Goal "2.2" *** *)
a(rewrite_tac(map get_spec[¨$AppendÆ, ¨MapÆ, ¨FlatÆ]));
a(all_asm_ante_tac
	THEN rewrite_tac(map get_spec[¨HideDerTableDataÆ, ¨MapÆ, ¨LetÆ])
	THEN REPEAT strip_tac);
a(rewrite_tac[get_spec¨$˘Æ]);
a(cases_tac ¨c dominates DTR_row x'Æ THEN
	TOP_ASM_T rewrite_thm_tac
	THEN asm_rewrite_tac(map get_spec[¨MapÆ, ¨$AppendÆ]));
val €HideDerTable_flat_lemma› =
	save_pop_thm"HideDerTable_flat_lemma";
=TEX
=SML
val €conj1› = ¨µtlâ0  tlâ1 c∑
	Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1 ¥
	HideDerTable
               c
               (MkDerTable
                   (Fst (Join tlâ0))
                   (Snd (Join tlâ0)))
             = HideDerTable
               c
               (MkDerTable
                   (Fst (Join tlâ1))
                   (Snd (Join tlâ1)))Æ;
val €conj2› = ¨µc ts1 ts2∑
	Map (HideDerTable c) ts1 = Map (HideDerTable c) ts2
¥	HideDerTableData c (JoinData (Map DT_rows ts1)) =
	HideDerTableData c (JoinData (Map DT_rows ts2))Æ;
val €conj3› = ¨µc ts1 ts2∑
	Map (HideDerTable c) ts1 = Map (HideDerTable c) ts2
¥	Map (HideDerTableData c) (Map DT_rows ts1)
	= Map (HideDerTableData c) (Map DT_rows ts2)Æ;
val €conj4› = ¨µc ds1 ds2∑
	Map (HideDerTableData c) ds1 = Map (HideDerTableData c) ds2
¥	HideDerTableData c (JoinData ds1) =
	HideDerTableData c (JoinData ds2)Æ;
val €conj5› = ¨µc rs1 rs2∑
	Flat(Map (Ãr∑ HideDerTableData c (JoinRows r rs2)) rs1) =
	Flat(Map (Ãr∑ JoinRows r (HideDerTableData c rs2)) (HideDerTableData c rs1))Æ;
val €conj6› = ¨µc r rs∑
		HideDerTableData c (JoinRows r rs)
	=	if	c dominates DTR_row r
		then	JoinRows (HideDerTableRow c r) (HideDerTableData c rs)
		else []Æ;
=TEX
=SML
set_goal([conj2], conj1);
a(REPEAT strip_tac);
a(rewrite_tac(MkDerTable_lemma :: map get_spec[¨JoinÆ, ¨HideDerTableÆ, ¨MkDerTableÆ]));
a(ALL_ASM_FC_T rewrite_tac [map_HideDerTable_map_DT_spec_lemma]);
val €Join_lemma1› = save_pop_thm"Join_lemma1";
=TEX
=SML
set_goal([conj3, conj4], conj2);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(all_asm_fc_tac[]);
val €Join_lemma2› = save_pop_thm"Join_lemma2";
=TEX
=SML
set_goal([], conj3);
a(REPEAT_N 2 strip_tac);
a(list_induction_tac¨ts1Æ);
(* *** Goal "1" *** *)
a(strip_tac);
a(strip_asm_tac(µ_elim¨ts2Æ list_cases_thm)
	THEN asm_rewrite_tac[map_def]);
(* *** Goal "2" *** *)
a(REPEAT_N 2 strip_tac);
a(strip_asm_tac(µ_elim¨ts2Æ list_cases_thm)
	THEN asm_rewrite_tac[map_def]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(asm_ante_tac ¨HideDerTable c x = HideDerTable c x'Æ
	THEN rewrite_tac[MkDerTable_lemma, get_spec¨HideDerTableÆ]);
a(REPEAT strip_tac);
val €Join_lemma3› = save_pop_thm"Join_lemma3";
=TEX
=SML
set_goal([conj5], conj4);
a(strip_tac THEN strip_tac);
a(list_induction_tac ¨ds1Æ);
(* *** Goal "1" *** *)
a(rewrite_tac[get_spec¨MapÆ, map_null_thm]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[get_spec¨MapÆ] THEN REPEAT µ_tac);
a(strip_asm_tac(µ_elim¨ds2Ælist_cases_thm) THEN 
	asm_rewrite_tac[get_spec¨MapÆ, map_null_thm]);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim¨ds1Ælist_cases_thm));
=TEX
=SML
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ, map_null_thm]);
a(REPEAT strip_tac THEN var_elim_asm_tac¨list2 = []Æ);
a(asm_rewrite_tac(map get_spec [¨JoinDataÆ, ¨LetÆ]));
(* *** Goal "2.2" *** *)
a(lemma_tac¨≥ds1 = [] ± ≥list2 = []Æ THEN1 asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
a(swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[get_spec¨MapÆ, map_null_thm]);
(* *** Goal "2.2.2" *** *)
a(LIST_DROP_NTH_ASM_T [3, 6] (Combinators.K id_tac));
a(asm_rewrite_tac(let_def::HideDerTable_flat_lemma::map get_spec [¨JoinDataÆ]));
a(asm_rewrite_tac[map_o_lemma,
	pc_rule1"hol2"prove_rule[]¨µf g z∑(f o (Ãx∑g x z)) = (Ãx∑f(g x z))Æ]);
a(ALL_ASM_FC_T rewrite_tac[]);
val €Join_lemma4› = save_pop_thm"Join_lemma4";
=TEX
=SML
set_goal([conj6], conj5);
a(REPEAT strip_tac);
a(list_induction_tac ¨rs1Æ);
(* *** Goal "1" *** *)
a(rewrite_tac(map get_spec[¨HideDerTableDataÆ, ¨FlatÆ, ¨MapÆ, ¨LetÆ, ¨$˘Æ]));
(* *** Goal "2" *** *)
a(rewrite_tac[dominates_lub_lemma,HideDerTableData_lemma,get_spec¨FlatÆ,get_spec¨MapÆ]);
a(strip_tac);
a(cases_tac¨c dominates DTR_row xÆ
	THEN asm_rewrite_tac(map get_spec[¨$ÎÆ, ¨MapÆ, ¨FlatÆ]));
val €Join_lemma5› = save_pop_thm"Join_lemma5";
=TEX
=SML
set_goal([], conj6);
a(REPEAT strip_tac);
a(list_induction_tac¨rsÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[HideDerTableData_lemma, JoinRows_lemma]);
a(CASES_T ¨c dominates DTR_row rÆ rewrite_thm_tac);
(* *** Goal "2" *** *)
a(strip_tac);
a(cases_tac ¨c dominates DTR_row rÆ THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "2.1" *** *)
a(swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[] THEN swap_nth_asm_concl_tac 1);
a(DROP_NTH_ASM_T 2 ante_tac);
a(rewrite_tac[HideDerTableData_lemma, JoinRows_lemma,
	dominates_lub_lemma, get_spec¨MkDerTableRowÆ]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
a(cases_tac ¨c dominates DTR_row xÆTHEN asm_rewrite_tac[]);
a(rewrite_tac[JoinRows_lemma]);
a(asm_rewrite_tac(MkDerTableRow_lemma:: map_Î_thm1::
	map get_spec[¨HideDerTableRowÆ, ¨MkDerTableRowÆ, ¨LetÆ]));
(* *** Goal "2.2" *** *)
a(POP_ASM_T ante_tac);
a(asm_rewrite_tac[HideDerTableData_lemma, JoinRows_lemma,
	dominates_lub_lemma, get_spec¨MkDerTableRowÆ]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val €Join_lemma6› = save_pop_thm"Join_lemma6";
=TEX
=SML
set_goal([], conj1);
a(MAP_EVERY (ante_tac o all_¥_intro) [
	Join_lemma1,
	Join_lemma2,
	Join_lemma3,
	Join_lemma4,
	Join_lemma5,
	Join_lemma6]
	THEN taut_tac);
val €Join_OKâd_lemma› = save_pop_thm"Join_OKâd_lemma";
=TEX
=SML
push_goal([],¨µ c tlâ0 tlâ1 tel
∑ Elems tel Ä OK_TCâd c
      ± c dominates lubl (Fst (Split (Map (Ã te∑ te tlâ0) tel)))
      ± Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1
    ¥ Map (HideDerTable c) (Snd (Split (Map (Ã te∑ te tlâ0) tel)))
      = Map (HideDerTable c) (Snd (Split (Map (Ã te∑ te tlâ1) tel)))Æ);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN DROP_NTH_ASM_T 2 ante_tac);
a(list_induction_tac¨telÆ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac(map get_spec[¨MapÆ]));
(* *** Goal "2" *** *)
a(rewrite_tac[dominates_lub_lemma,lubl_lemma,split_thm,get_spec¨MapÆ]);
a(REPEAT strip_tac);
=TEX
=SML
(* *** Goal "3" *** *)
a(PC_T1 "sets_ext" asm_prove_tac[get_spec¨ElemsÆ]);
(* *** Goal "4" *** *)
a(REPEAT strip_tac);
a(asm_rewrite_tac[split_thm,get_spec¨MapÆ]);
a(lemma_tac¨x ç OK_TCâd cÆ);
(* *** Goal "4.1" *** *)
a(PC_T1 "sets_ext" asm_prove_tac[get_spec¨ElemsÆ]);
(* *** Goal "4.2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[get_spec¨OK_TCâdÆ]));
a(DROP_NTH_ASM_T 3 (strip_asm_tac o rewrite_rule[dominates_lub_lemma,lubl_lemma,
	split_thm,get_spec¨MapÆ]));
a(contr_tac THEN all_asm_fc_tac[]);
val €AllTuples_lemma1› = save_pop_thm"AllTuples_lemma1";
=TEX
=SML
push_goal([],¨µ c tlâ0 tlâ1 rlâ0 rlâ1 râ0 râ1 sl∑ 
	Elems sl Ä OK_VCâd c ° OK_VCâc c
	± Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1
	± Map (HideDerTableRow c) rlâ0 = Map (HideDerTableRow c) rlâ1
	± HideDerTableRow c râ0 = HideDerTableRow c râ1
	¥ HideDerTableRow c 
	     (MkDerTableRow (DTR_where râ0) (DTR_row râ0) (Map (Ã e∑ e tlâ0 rlâ0 râ0) sl))
	= 
	HideDerTableRow c 
	     (MkDerTableRow (DTR_where râ1) (DTR_row râ1) (Map (Ã e∑ e tlâ1 rlâ1 râ1) sl))Æ);
a(REPEAT strip_tac);
a(TOP_ASM_T ante_tac THEN rewrite_tac(MkDerTableRow_lemma :: 
	map get_spec[¨HideDerTableRowÆ,¨LetÆ,¨MkDerTableRowÆ])
	THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 7 ante_tac);
a(list_induction_tac ¨slÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext" asm_prove_tac[get_spec¨ElemsÆ]);
=TEX
=SML
(* *** Goal "3" *** *)
a(REPEAT strip_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
a(lemma_tac¨x ç OK_VCâd c ± x ç OK_VCâc cÆ);
(* *** Goal "3.1" *** *)
a(PC_T1 "sets_ext" asm_prove_tac[get_spec¨ElemsÆ]);
(* *** Goal "3.2" *** *)
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN 
	rewrite_tac(map get_spec[¨OK_VCâdÆ,¨OK_VCâcÆ]));
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(POP_ASM_T (asm_tac o eq_sym_rule));
a(cases_tac¨c dominates Fst (x tlâ0 rlâ0 râ0)ÆTHEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 3 discard_tac);
a(lemma_tac¨Snd (x tlâ0 rlâ0 râ0) = Snd (x tlâ1 rlâ1 râ1)Æ
	THEN1 contr_tac THEN all_asm_fc_tac[]);
a(once_rewrite_tac[prove_rule[]¨x tlâ0 rlâ0 râ0 = (Fst (x tlâ0 rlâ0 râ0), Snd (x tlâ0 rlâ0 râ0))Æ]);
a(POP_ASM_T pure_rewrite_thm_tac);
a(DROP_NTH_ASM_T 2 (rewrite_thm_tac o eq_sym_rule));
val €ProjectData_lemma1› = save_pop_thm"ProjectData_lemma1";
=TEX
=SML
push_goal([],¨µ c rlâ0 rlâ1 ∑ Map (HideDerTableRow c) rlâ0 = Map (HideDerTableRow c) rlâ1
	¥ HideDerTableData c rlâ0 = HideDerTableData c rlâ1Æ);
a(REPEAT µ_tac);
a(intro_µ_tac(¨rlâ1Æ,¨rlâ1Æ));
a(list_induction_tac¨rlâ0Æ);
(* *** Goal "1" *** *)
a µ_tac;
a(strip_asm_tac(µ_elim¨rlâ1Ælist_cases_thm));
(* *** Goal "1.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(asm_rewrite_tac[get_spec¨MapÆ]);
=TEX
=SML
(* *** Goal "2" *** *)
a(REPEAT µ_tac);
a(strip_asm_tac(µ_elim¨rlâ1Ælist_cases_thm));
(* *** Goal "2.1" *** *)
a(asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[get_spec¨MapÆ,HideDerTableData_lemma]);
a(cases_tac¨c dominates DTR_row xÆ THEN
	cases_tac¨c dominates DTR_row x'Æ THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "2.2.1" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2" *** *)
a(rewrite_tac(MkDerTableRow_lemma :: map get_spec
	[¨HideDerTableRowÆ,¨MkDerTableRowÆ,¨LetÆ]));
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 6 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.3" *** *)
a(rewrite_tac(MkDerTableRow_lemma :: map get_spec
	[¨HideDerTableRowÆ,¨MkDerTableRowÆ,¨LetÆ]));
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 6 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.4" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
val €HideDerTableData_lemma1› = save_pop_thm"HideDerTableData_lemma1";
=TEX
\section{CONJECTURES FOR $AllTuples$ OKNESS PROOFS}
\subsection{$Where$}
=SML
val €Where_conj1› = ¨µtl rl c e ∑
	 c dominates lubl (Map DTR_row (Where c tl rl e))Æ;
=TEX

=SML
val €Where_conj2› = ¨µ tlâ0 tlâ1 rlâ0 rlâ1 c e
∑ e ç OK_VCâd c ° OK_VCâc c
      ± Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1
      ± HideDerTableData c rlâ0 = HideDerTableData c rlâ1
    ¥ Map (HideDerTableRow c) (Where c tlâ0 rlâ0 e)
      = Map (HideDerTableRow c) (Where c tlâ1 rlâ1 e)Æ;
=TEX
\subsection{$Group$}
We require separate conjectures for the proofs of $OK\_TCâd$ and $OK\_TCâc$.
\subsubsection{Data OKness Conjecture}
=SML
val €Group_conj1› = ¨µtlâ0  tlâ1 rlâ0 rlâ1 c e ml nl ∑
	e ç OK_VCâd c ° OK_VCâc c
±	c dominates lubl (Map DTR_row rlâ0)
±	c dominates lubl (Map DTR_row rlâ1)
±	Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1 
±	Map (HideDerTableRow c) rlâ0 = Map (HideDerTableRow c) rlâ1
±	≥ Map (Map (HideDerTableRow c)) (Snd(Group c tlâ0 rlâ0 ml nl e)) 
	= 
	Map (Map (HideDerTableRow c)) (Snd(Group c tlâ1 rlâ1 ml nl e))
¥	≥ c dominates Fst(Group c tlâ0 rlâ0 ml nl e)Æ ;
=TEX
The specification of $Group$ is subdivided to facilitate the proof
of the conjecture about $Group$.
πHOLCONST
‹	€GroupA›	: DerTableRow LIST
‹		≠ Ó LIST
‹		≠ Ó LIST
‹		≠ (Class ∏ (DerTableRow LIST LIST))
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹µrl gbsterling gbclass∑
‹	GroupA rl gbsterling gbclass =
‹	let	gpby row = (ListNth gbsterling (Map Snd (DTR_cols row)),
‹				ListNth gbclass (Map Fst(DTR_cols row)))
‹	in let	gbc row = lubl(ListNth gbsterling (Map Fst(DTR_cols row)))
‹	in 	(lubl (Map gbc rl), MakeGroups gpby rl)
∞

=TEX
πHOLCONST
‹	€GroupB›	: DerTable LIST
‹			≠ DerTableRow LIST LIST
‹			≠ VALUE_COMP
‹			≠ (Class ∏ (DerTableRow LIST LIST))
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹µtl gps having∑
‹	GroupB tl gps having =
‹	let	has_test gp = ((CommonValue having) tl gp Arbitrary)
‹	in let	wanted_gps = gps ˘ {gp | ItemBool(Snd (has_test gp))}
‹	in	(lubl(Map (Fst o has_test) gps), wanted_gps)
∞
=TEX
The following lemma demonstrates that $Group$ can be reconstituted from
$GroupA$ and $GroupB$.
=SML
set_goal([], ¨
µcc tl rl gbsterling gbclass having∑
	Group cc tl rl gbsterling gbclass having =
	let	(c1, gps) = GroupA rl gbsterling gbclass
	in let	(c2, wanted_gps) = GroupB tl gps having
	in	((if cc dominates c1 then c2 else c1), wanted_gps)
Æ);
a(REPEAT strip_tac THEN
	rewrite_tac(map get_spec[¨GroupÆ, ¨GroupAÆ, ¨GroupBÆ, ¨LetÆ]));
val €Group_lemma1› = save_pop_thm"Group_lemma1";
=TEX
Next, conjectures about $GroupA$ and $GroupB$ are given.
=SML
val €GroupA_conj1› = ¨µrlâ0 rlâ1 c gbsterling gbclass ∑
	c dominates lubl (Map DTR_row rlâ0)
±	c dominates lubl (Map DTR_row rlâ1)
±	Map (HideDerTableRow c) rlâ0 = Map (HideDerTableRow c) rlâ1
±	≥ Map (Map (HideDerTableRow c)) (Snd(GroupA rlâ0 gbsterling gbclass)) 
	= 
	Map (Map (HideDerTableRow c)) (Snd(GroupA rlâ1 gbsterling gbclass))
¥	≥ c dominates Fst(GroupA rlâ0 gbsterling gbclass)Æ ;
=TEX
=SML
val €GroupB_conj1› = ¨µtlâ0  tlâ1 gpsâ0 gpsâ1 c having ∑
	having ç OK_VCâd c ° OK_VCâc c
±	Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1 
±	Map (Map (HideDerTableRow c)) gpsâ0 = Map (Map (HideDerTableRow c)) gpsâ1 
±	≥ Map (Map (HideDerTableRow c)) (Snd(GroupB tlâ0 gpsâ0 having)) 
	= 
	Map (Map (HideDerTableRow c)) (Snd(GroupB tlâ1 gpsâ1 having))
¥	≥ c dominates Fst(GroupB tlâ0 gpsâ0 having)Æ ;
=TEX
Finally, under the assumptions $GroupA\_conj$ and $GroupB\_conj$, $Group\_conj$
is proven.
=SML
set_goal([GroupA_conj1, GroupB_conj1], Group_conj1);
a(rewrite_tac[Group_lemma1, let_def, dominates_lub_lemma]
	THEN REPEAT strip_tac);
a(cases_tac¨c dominates Fst (GroupA rlâ0 ml nl)Æ THEN asm_rewrite_tac[]);
a(GET_NTH_ASM_T 10 bc_thm_tac);
a(∂_tac¨Snd (GroupA rlâ1 ml nl)Æ THEN ∂_tac¨tlâ1Æ);
a(contr_tac THEN all_asm_fc_tac[]);
val €Group_lemma2› = save_pop_thm"Group_lemma2";
=TEX
\subsubsection{Classification OKness Conjecture}
First, conjectures for $GroupA$ and $GroupB$.
=SML
val €GroupA_conj2› = ¨µ rlâ0 rlâ1 c gbsterling gbclass
           ∑ Map (HideDerTableRow c) rlâ0 = Map (HideDerTableRow c) rlâ1
                ¥ Fst (GroupA rlâ0 gbsterling gbclass)
                 = Fst (GroupA rlâ1 gbsterling gbclass)Æ;
=TEX
=SML
val €GroupB_conj2› = ¨µ tlâ0 tlâ1 gpsâ0 gpsâ1 c having
∑ having ç OK_VCâc c
      ± Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1
      ± Map (Map (HideDerTableRow c)) gpsâ0
        = Map (Map (HideDerTableRow c)) gpsâ1
    ¥  Fst (GroupB tlâ0 gpsâ0 having) = Fst (GroupB tlâ1 gpsâ1 having)Æ;
=TEX
Finally, the overall $Ok3ness$ conjecture for $Group$.
=SML
val €Group_conj2› = ¨µ tlâ0 tlâ1 rlâ0 rlâ1 c e ml nl
    ∑ e ç OK_VCâc c
          ± Map (HideDerTableRow c) rlâ0 = Map (HideDerTableRow c) rlâ1
          ± Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1
          ¥ Fst (Group c tlâ0 rlâ0 ml nl e) = Fst (Group c tlâ1 rlâ1 ml nl e)Æ;
=TEX


\subsection{$ProjectData$}
=SML
val €ProjectData_conj› = ¨µtlâ0  tlâ1 gpsâ0 gpsâ1 c sl ∑
	Elems sl Ä OK_VCâd c ° OK_VCâc c
±	Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1 
±	Map (Map (HideDerTableRow c)) gpsâ0 = Map (Map (HideDerTableRow c)) gpsâ1
¥
	Map (HideDerTableRow c) (ProjectData tlâ0 sl gpsâ0) 
	= 
	Map (HideDerTableRow c) (ProjectData tlâ1 sl gpsâ1)Æ;
=TEX
\section{PROOFS OF $AllTuples$ CONJECTURES}
\subsection{$Where$}
$Where$ is first defined in terms of new operations W and H to give a primitive
recursive formulation.

πHOLCONST
‹	€W› 	: Class
‹		≠ DerTable LIST
‹		≠ DerTableRow LIST
‹		≠ DerTableRow LIST
‹		≠ VALUE_COMP
‹		≠ DerTableRow LIST
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹µc tl rlâ1 r rlâ2 e ∑
‹	W c tl rlâ1 [] e = []
‹±	W c tl rlâ1 (Cons r rlâ2) e =   
‹     (let w = DTR_where r lub Fst (e tl rlâ1 r)
‹     in let h = ((ItemBool (Snd (e tl rlâ1 r)) ≤ ≥ c dominates w)
‹			± c dominates DTR_row r)
‹     in	if h then Cons (MkDerTableRow w (DTR_row r) (DTR_cols r))
‹			(W c tl rlâ1 rlâ2 e)
‹		else (W c tl rlâ1 rlâ2 e))
∞
=TEX
πHOLCONST
‹	€H› 	: Class
‹		≠ DerTableRow LIST
‹		≠ DerTableRow LIST
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹µc rl ∑ H c rl = rl ˘ {r|c dominates DTR_row r}
∞
=TEX
The following lemma relates $Where$ to $W$.
=SML
push_goal([],¨µ c tl rl e ∑ Where c tl rl e = W c tl (H c rl) (H c rl) eÆ);
a(rewrite_tac(map get_spec[¨WhereÆ,¨WÆ,¨HÆ,¨LetÆ]) THEN REPEAT strip_tac);
a(lemma_tac¨µ rs ∑Map
               Snd
               (Map
                     (Ã r
                       ∑ ((ItemBool (Snd (e tl (rs ˘ {r|c dominates DTR_row r}) r))
                               ≤ ≥ c
                                   dominates DTR_where r
                                     lub Fst (e tl (rs ˘ {r|c dominates DTR_row r}) r)),
                           MkDerTableRow
                               (DTR_where r
                                   lub Fst (e tl (rs ˘ {r|c dominates DTR_row r}) r))
                               (DTR_row r)
                               (DTR_cols r)))
                     (rl ˘ {r|c dominates DTR_row r})
                   ˘ {(t, r)|t})
             = W c tl (rs ˘ {r|c dominates DTR_row r}) (rl ˘ {r|c dominates DTR_row r}) eÆ
	THEN_LIST[id_tac,asm_rewrite_tac[]]);
=TEX
=SML
a(list_induction_tac¨rlÆ);
(* *** Goal "1" *** *)
a(rewrite_tac(map get_spec[¨WÆ,¨MapÆ,¨$˘Æ]));
(* *** Goal "2" *** *)
a(rewrite_tac(map get_spec[¨WÆ,¨MapÆ,¨$˘Æ,¨LetÆ]));
a(REPEAT strip_tac);
a(cases_tac¨c dominates DTR_row xÆTHEN asm_rewrite_tac
	(map get_spec[¨WÆ,¨MapÆ,¨$˘Æ,¨LetÆ]));
a(cases_tac¨ItemBool (Snd (e tl (rs ˘ {r|c dominates DTR_row r}) x))
                       ≤ ≥ c dominates DTR_where x
                             lub Fst (e tl (rs ˘ {r|c dominates DTR_row r}) x)Æ
	THEN asm_rewrite_tac[get_spec¨MapÆ]);
val €Where_W_lemma› = save_pop_thm"Where_W_lemma";
=TEX
The conjectures about $Where$ are now proven.
=SML
push_goal([],Where_conj1);
a(rewrite_tac[Where_W_lemma,get_spec¨HÆ]THEN REPEAT µ_tac);
a(lemma_tac¨µ rs ∑ c dominates lubl 
	(Map DTR_row (W c tl (rs ˘ {r|c dominates DTR_row r})
                       (rl ˘ {r|c dominates DTR_row r}) e))Æ
	THEN_LIST[id_tac,asm_rewrite_tac[]]);
a(list_induction_tac¨rlÆ);
(* *** Goal "1" *** *)
a(rewrite_tac(lubl_lemma :: map get_spec[¨MapÆ,¨WÆ,¨$˘Æ,¨$dominatesÆ]));
(* *** Goal "2" *** *)
a(rewrite_tac[get_spec¨$˘Æ] THEN REPEAT µ_tac);
a(cases_tac¨c dominates DTR_row xÆTHEN 
	asm_rewrite_tac(map get_spec[¨MapÆ,¨WÆ,¨LetÆ]));
a(cases_tac¨ItemBool (Snd (e tl (rs ˘ {r|c dominates DTR_row r}) x))
                           ≤ ≥ c dominates DTR_where x
                            lub Fst (e tl (rs ˘ {r|c dominates DTR_row r}) x)Æ
	THEN asm_rewrite_tac(lubl_lemma :: dominates_lub_lemma :: map 
		get_spec[¨MapÆ,¨MkDerTableRowÆ]));
val €Where_dominates_lemma› = save_pop_thm"Where_dominates_lemma";
=TEX
Before a proof of $Where_conj2$ is given, some subsidiary lemmas are proven.
=SML
push_goal([],¨µ tlâ0 tlâ1 rlâ0 rlâ1 râ0 râ1 c e
∑ e ç OK_VCâd c ° OK_VCâc c
      ± Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1
      ± Map (HideDerTableRow c) rlâ0 = Map (HideDerTableRow c) rlâ1
      ± HideDerTableRow c râ0 = HideDerTableRow c râ1
    ¥ (((ItemBool (Snd (e tlâ0 rlâ0 râ0)) ≤ ≥ c dominates DTR_where râ0 lub Fst (e tlâ0 rlâ0 râ0))
             ± c dominates DTR_row râ0) §
	((ItemBool (Snd (e tlâ1 rlâ1 râ1)) ≤ ≥ c dominates DTR_where râ1 lub Fst (e tlâ1 rlâ1 râ1))
             ± c dominates DTR_row râ1))Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(GET_NTH_ASM_T 1 ante_tac THEN
	rewrite_tac(MkDerTableRow_lemma :: 
	map get_spec[¨HideDerTableRowÆ,¨LetÆ,¨MkDerTableRowÆ])	THEN ¥_tac);
=TEX
=SML
a(POP_ASM_T discard_tac);
a(DROP_NTH_ASM_T 7 ante_tac THEN DROP_NTH_ASM_T 6 ante_tac THEN 
	rewrite_tac(map get_spec[¨OK_VCâdÆ,¨OK_VCâcÆ]));
a(¥_tac THEN all_asm_fc_tac[]);
a(DROP_NTH_ASM_T 2 discard_tac THEN ¥_tac);
a(cases_tac¨c dominates Fst (e tlâ0 rlâ0 râ0)Æ);
(* *** Goal "1" *** *)
a(list_spec_nth_asm_tac 2 [¨tlâ0Æ,¨tlâ1Æ,¨rlâ0Æ,¨rlâ1Æ,¨râ0Æ,¨râ1Æ]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨≥ c dominates Fst (e tlâ1 rlâ1 râ1)Æ);
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 3 (asm_rewrite_thm_tac o eq_sym_rule));
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[dominates_lub_lemma]THEN REPEAT strip_tac);
val €Where_lemma› = save_pop_thm"Where_lemma";
=TEX
=SML
push_goal([],¨µtlâ0  tlâ1 rlâ0 rlâ1  rl1 rl2 c e ∑
	e ç OK_VCâd c ° OK_VCâc c
±	Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1 
±	Map (HideDerTableRow c) rlâ0 = Map (HideDerTableRow c) rlâ1
±	Map (HideDerTableRow c) rl1 = Map (HideDerTableRow c) rl2
	¥
	Map (HideDerTableRow c) (W c tlâ0 rl1 rlâ0 e) = 
	Map (HideDerTableRow c) (W c tlâ1 rl2 rlâ1 e)Æ);
a(REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac);
a(intro_µ_tac(¨rl1Æ,¨rl1Æ) THEN intro_µ_tac(¨rl2Æ,¨rl2Æ) THEN intro_µ_tac(¨rlâ1Æ,¨rlâ1Æ));
=TEX
=SML
a(list_induction_tac¨rlâ0Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨rlâ1Ælist_cases_thm));
(* *** Goal "1.1" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(rewrite_tac[get_spec¨WÆ]);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
=TEX
=SML
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨rlâ1Ælist_cases_thm));
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
a(REPEAT strip_tac);
a(rewrite_tac(map get_spec[¨WÆ,¨LetÆ]));
a(CASES_T¨(ItemBool (Snd (e tlâ0 rl1 x)) ≤ 
	≥ c dominates DTR_where x lub Fst (e tlâ0 rl1 x))
                       ± c dominates DTR_row xÆasm_tac);
=TEX
=SML
(* *** Goal "2.2.1" *** *)
a(LEMMA_T¨(ItemBool (Snd (e tlâ1 rl2 x')) ≤ 
	≥ c dominates DTR_where x' lub Fst (e tlâ1 rl2 x'))
                       ± c dominates DTR_row x'Ærewrite_thm_tac);
(* *** Goal "2.2.1.1" *** *)
a(LEMMA_T¨e ç OK_VCâd c ° OK_VCâc cÆasm_tac THEN_LIST[REPEAT strip_tac,id_tac]);
a(ante_tac(list_µ_elim[¨tlâ0Æ,¨tlâ1Æ,¨rl1Æ,¨rl2Æ,¨xÆ,¨x'Æ,¨cÆ,¨eÆ]Where_lemma)
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1.2" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(rewrite_tac[get_spec¨MapÆ]);
a(all_asm_fc_tac[]);
a(POP_ASM_T rewrite_thm_tac THEN POP_ASM_T discard_tac);
a(GET_NTH_ASM_T 2 ante_tac THEN rewrite_tac
	(MkDerTableRow_lemma :: map get_spec[¨HideDerTableRowÆ,¨LetÆ,¨MkDerTableRowÆ])
	THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 10 ante_tac  THEN rewrite_tac[get_spec¨OK_VCâcÆ]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "2.2.2" *** *)
a(LEMMA_T¨≥((ItemBool (Snd (e tlâ1 rl2 x')) ≤ 
	≥ c dominates DTR_where x' lub Fst (e tlâ1 rl2 x'))
                       ± c dominates DTR_row x')Ærewrite_thm_tac);
(* *** Goal "2.2.2.1" *** *)
a(LEMMA_T¨e ç OK_VCâd c ° OK_VCâc cÆasm_tac THEN_LIST[REPEAT strip_tac,id_tac]);
a(ante_tac(list_µ_elim[¨tlâ0Æ,¨tlâ1Æ,¨rl1Æ,¨rl2Æ,¨xÆ,¨x'Æ,¨cÆ,¨eÆ]Where_lemma)
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(all_asm_fc_tac[]);
val €W_lemma› = save_pop_thm"W_lemma";
=TEX
=SML
push_goal([],Where_conj2);
a(REPEAT strip_tac);
a(rewrite_tac[Where_W_lemma]);
a(bc_tac[W_lemma]THEN_TRY PC_T1 "sets_ext" asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac(map get_spec[¨LetÆ,¨HideDerTableDataÆ,¨HÆ]));
val €Where_OKâd_lemma› = save_pop_thm"Where_OKâd_lemma";
=TEX
\subsection{$Group$}
First, some lemmas about $MakeGroups$ and the columns of a $DTR\_row$.
=SML
push_goal([],¨µ xs gpby ∑ ≥ [] ç Elems (MakeGroups gpby xs)Æ);
a(REPEAT strip_tac);
a(list_induction_tac¨xsÆ);
(* *** Goal "1" *** *)
a(rewrite_tac(map get_spec[¨ElemsÆ,¨MakeGroupsÆ]));
(* *** Goal "2" *** *)
a(strip_tac THEN rewrite_tac(map get_spec[¨ElemsÆ,¨MakeGroupsÆ]));
a(lemma_tac¨∂ gps ∑ MakeGroups gpby xs = gpsÆTHEN1 prove_∂_tac);
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
a(POP_ASM_T discard_tac);
a(list_induction_tac¨gpsÆ);
=TEX
=SML
(* *** Goal "2.1" *** *)
a(rewrite_tac(map get_spec[¨ElemsÆ,¨PutInGroupÆ]));
(* *** Goal "2.2" *** *)
a(PC_T1 "sets_ext" asm_prove_tac[get_spec¨ElemsÆ]);
(* *** Goal "2.3" *** *)
a(rewrite_tac(map get_spec[¨ElemsÆ,¨PutInGroupÆ]));
a(REPEAT strip_tac);
a(cases_tac¨gpby x = gpby (Head x')ÆTHEN asm_rewrite_tac[]);
(* *** Goal "2.3.1" *** *)
a(asm_prove_tac[get_spec¨ElemsÆ]);
(* *** Goal "2.3.2" *** *)
a(asm_prove_tac[get_spec¨ElemsÆ]);
val €MakeGroups_lemma1› = save_pop_thm"MakeGroups_lemma1";
=TEX
=SML
set_goal([],¨µ râ1 râ2 c ∑ 
	HideDerTableRow c râ1 = HideDerTableRow c râ2
      ¥ Map Fst (DTR_cols râ1) =  Map Fst (DTR_cols râ2)Æ);
a(REPEAT strip_tac);
a(POP_ASM_T  (strip_asm_tac o rewrite_rule(MkDerTableRow_lemma :: map get_spec
	[¨HideDerTableRowÆ,¨LetÆ,¨MkDerTableRowÆ])));
a(LIST_DROP_NTH_ASM_T [2,3](MAP_EVERY discard_tac));
a(POP_ASM_T ante_tac);
a(lemma_tac¨∂l1 ∑ DTR_cols râ1 = l1ÆTHEN1 prove_∂_tac);
a(lemma_tac¨∂l2 ∑ DTR_cols râ2 = l2ÆTHEN1 prove_∂_tac);
a(POP_ASM_T rewrite_thm_tac THEN POP_ASM_T rewrite_thm_tac );
a(intro_µ_tac(¨l2Æ,¨l2Æ));
a(list_induction_tac¨l1Æ);
=TEX
=SML
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨l2Ælist_cases_thm));
(* *** Goal "1.1" *** *)
a(POP_ASM_T rewrite_thm_tac);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨l2Ælist_cases_thm));
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
=TEX
=SML
(* *** Goal "2.2" *** *)
a(var_elim_nth_asm_tac 1);
a(POP_ASM_T ante_tac);
a(rewrite_tac[get_spec¨MapÆ]);
a(REPEAT ¥_tac);
a(all_asm_fc_tac[]);
a(asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 3 ante_tac);
a(cases_tac¨c dominates Fst xÆTHEN cases_tac¨c dominates Fst x'ÆTHEN asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
a(¥_T rewrite_thm_tac);
(* *** Goal "2.2.2" *** *)
a(¥_T (strip_asm_tac o once_rewrite_rule[prove_rule[]¨x = (Fst x,Snd x)Æ]));
(* *** Goal "2.2.3" *** *)
a(¥_T (strip_asm_tac o once_rewrite_rule[prove_rule[]¨x' = (Fst x',Snd x')Æ]));
val €GroupA_cols_lemma1› = save_pop_thm"GroupA_cols_lemma1";
=TEX
=SML
push_goal([],¨µ râ1 râ2 c gbsterling gbclass ∑ 
	c dominates lubl (ListNth gbsterling (Map Fst (DTR_cols râ1)))
±	HideDerTableRow c râ1 = HideDerTableRow c râ2
      ¥ ListNth gbsterling (Map Snd (DTR_cols râ1))
          = ListNth gbsterling (Map Snd (DTR_cols râ2))Æ);
a(REPEAT strip_tac);
a(TOP_ASM_T  (strip_asm_tac o rewrite_rule(MkDerTableRow_lemma :: map get_spec
	[¨HideDerTableRowÆ,¨LetÆ,¨MkDerTableRowÆ])));
a(all_asm_fc_tac[HideDerTableRow_Length_lemma]);
a(all_asm_fc_tac[GroupA_cols_lemma1]);
a(LIST_DROP_NTH_ASM_T [4,5,6](MAP_EVERY discard_tac));
a(DROP_NTH_ASM_T 4 ante_tac);
a(LIST_INDUCTION_T¨gbsterlingÆasm_tac);
=TEX
=SML
(* *** Goal "1" *** *)
a(rewrite_tac[get_spec¨ListNthÆ]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[get_spec¨ListNthÆ,length_map_lemma,lubl_lemma,dominates_lub_lemma]);
a(µ_tac THEN CASES_T¨1 º x ± x º # (DTR_cols râ2)Æasm_tac THEN
	asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN_TRY all_asm_fc_tac[]);
a(lemma_tac¨x º # (DTR_cols râ1)ÆTHEN1 asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 5 (strip_asm_tac));
a(lemma_tac¨c dominates Nth (Map Fst (DTR_cols râ1)) xÆTHEN1 asm_rewrite_tac[]);
=TEX
=SML
a(strip_asm_tac(list_µ_elim[¨DTR_cols râ1Æ,¨xÆ,
	¨Fst: Class ∏ (ValuedItem + ONE) ≠ ClassÆ]fun_nth_map_lemma));
a(DROP_NTH_ASM_T 2 ante_tac THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule) 
	THEN ¥_tac);
a(strip_asm_tac(list_µ_elim[¨DTR_cols râ2Æ,¨xÆ,
	¨Fst: Class ∏ (ValuedItem + ONE) ≠ ClassÆ]fun_nth_map_lemma));
a(DROP_NTH_ASM_T 7 ante_tac THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule) 
	THEN ¥_tac);
a(strip_asm_tac(list_µ_elim[¨DTR_cols râ1Æ,¨xÆ,
	¨Snd: Class ∏ (ValuedItem + ONE) ≠ ValuedItem + ONEÆ]fun_nth_map_lemma));
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(strip_asm_tac(list_µ_elim[¨DTR_cols râ2Æ,¨xÆ,
	¨Snd: Class ∏ (ValuedItem + ONE) ≠ ValuedItem + ONEÆ]fun_nth_map_lemma));
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
=TEX
=SML
a(LIST_DROP_NTH_ASM_T [1,2,3,5,9,10](MAP_EVERY ante_tac));
a(lemma_tac¨∂l1 ∑ DTR_cols râ1 = l1ÆTHEN1 prove_∂_tac);
a(lemma_tac¨∂l2 ∑ DTR_cols râ2 = l2ÆTHEN1 prove_∂_tac);
a(POP_ASM_T rewrite_thm_tac THEN POP_ASM_T rewrite_thm_tac );
a(LIST_DROP_NTH_ASM_T [2,3,4](MAP_EVERY discard_tac));
a(POP_ASM_T ante_tac);
a(intro_µ_tac(¨l2Æ,¨l2Æ));
a(intro_µ_tac(¨xÆ,¨xÆ));
a(list_induction_tac¨l1Æ);
=TEX
=SML
(* *** Goal "2.1.1" *** *)
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 4(strip_asm_tac o rewrite_rule[length_def]));
a(DROP_NTH_ASM_T 7 ante_tac THEN POP_ASM_T  rewrite_thm_tac);
(* *** Goal "2.1.2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨l2Ælist_cases_thm));
(* *** Goal "2.1.2.1" *** *)
a(DROP_NTH_ASM_T 6 ante_tac THEN asm_rewrite_tac[get_spec¨LengthÆ]);
(* *** Goal "2.1.2.2" *** *)
a(var_elim_nth_asm_tac 1);
a(LIST_DROP_NTH_ASM_T [1,2,3,4,5,6](MAP_EVERY ante_tac));
a(rewrite_tac(map get_spec[¨LengthÆ,¨MapÆ,¨NthÆ]));
a(cases_tac¨x'=1ÆTHEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "2.1.2.2.1" *** *)
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
(* *** Goal "2.1.2.2.2" *** *)
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 10 (ante_tac o list_µ_elim[¨x'-1Æ,¨list2Æ]));
a(asm_rewrite_tac[]);
a(GET_ASM_T ¨1 º x'Æ (strip_asm_tac o rewrite_rule[get_spec¨$ºÆ]));
a(var_elim_nth_asm_tac 1);
a(asm_rewrite_tac[]);
a(strip_asm_tac (µ_elim¨iÆ Ó_cases_thm));
a(POP_ASM_T rewrite_thm_tac);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[] THEN 
	REPEAT strip_tac THEN all_asm_fc_tac[]);
val €GroupA_cols_lemma2› = save_pop_thm"GroupA_cols_lemma2";
=TEX
=SML
push_goal([],¨µ rlâ0 rlâ1 g ∑
	Map g rlâ0 = Map g rlâ1
¥	Map (Map g) (MakeGroups g rlâ0) = Map (Map g) (MakeGroups g rlâ1)Æ);
a µ_tac;
a(list_induction_tac¨rlâ0Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨rlâ1Ælist_cases_thm));
(* *** Goal "1.1" *** *)
a(POP_ASM_T rewrite_thm_tac);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
=TEX
=SML
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨rlâ1Ælist_cases_thm));
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2.2" *** *)
a(var_elim_nth_asm_tac 1);
a(POP_ASM_T ante_tac THEN 
	rewrite_tac[get_spec¨MapÆ,get_spec¨MakeGroupsÆ]); 
a(REPEAT ¥_tac);
a(all_asm_fc_tac[]);
a(DROP_NTH_ASM_T 4 discard_tac);
=TEX
=SML
a(lemma_tac¨∂l0 ∑ MakeGroups g rlâ0 = l0ÆTHEN1 prove_∂_tac);
a(lemma_tac¨∂l1 ∑ MakeGroups g list2 = l1ÆTHEN1 prove_∂_tac);
a(ante_tac(list_µ_elim[¨rlâ0Æ,¨gÆ]MakeGroups_lemma1));
a(ante_tac(list_µ_elim[¨list2Æ,¨gÆ]MakeGroups_lemma1));
a(DROP_NTH_ASM_T 3 ante_tac THEN 
	POP_ASM_T rewrite_thm_tac THEN POP_ASM_T rewrite_thm_tac);
a(intro_µ_tac(¨l1Æ,¨l1Æ));
a(list_induction_tac¨l0Æ);
(* *** Goal "2.2.1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨l1Ælist_cases_thm));
(* *** Goal "2.2.1.1" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(rewrite_tac[get_spec¨PutInGroupÆ,get_spec¨MapÆ]);
a(asm_rewrite_tac[]);
(* *** Goal "2.2.1.2" *** *)
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
=TEX
=SML
(* *** Goal "2.2.2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨l1Ælist_cases_thm));
(* *** Goal "2.2.2.1" *** *)
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2.2.2.2" *** *)
a(var_elim_nth_asm_tac 1);
a(LIST_DROP_NTH_ASM_T [1,2,3](MAP_EVERY ante_tac) THEN 
	rewrite_tac(map get_spec[¨MapÆ,¨ElemsÆ,¨PutInGroupÆ])); 
a(REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(strip_asm_tac(µ_elim¨x''Ælist_cases_thm));
(* *** Goal "2.2.2.2.1" *** *)
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a(strip_asm_tac(µ_elim¨x'''Ælist_cases_thm));
=TEX
=SML
(* *** Goal "2.2.2.2.2.1" *** *)
a(DROP_NTH_ASM_T 7 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.2" *** *)
a(var_elim_nth_asm_tac 1);
a(var_elim_nth_asm_tac 1);
a(LIST_DROP_NTH_ASM_T [2,3,4,5,8](MAP_EVERY discard_tac));
a(DROP_NTH_ASM_T 3 (strip_asm_tac o rewrite_rule[get_spec¨MapÆ]));
a(rewrite_tac[]);
a(cases_tac¨g x = g x''''ÆTHEN cases_tac¨g x' = g x'''''Æ
	THEN asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2.2.2.2.2.2.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.2.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
val €MakeGroups_lemma2› = save_pop_thm"MakeGroups_lemma2";
=TEX
=SML
push_goal([],¨µ rlâ0 rlâ1 g h ∑
	Map g rlâ0 = Map g rlâ1
±	Map h rlâ0 = Map h rlâ1
¥	Map (Map h) (MakeGroups g rlâ0) = Map (Map h) (MakeGroups g rlâ1)Æ);
a µ_tac;
a(list_induction_tac¨rlâ0Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨rlâ1Ælist_cases_thm));
(* *** Goal "1.1" *** *)
a(POP_ASM_T rewrite_thm_tac);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
=TEX
=SML
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨rlâ1Ælist_cases_thm));
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2.2" *** *)
a(var_elim_nth_asm_tac 1);
a(POP_ASM_T ante_tac THEN  POP_ASM_T ante_tac THEN
	rewrite_tac[get_spec¨MapÆ,get_spec¨MakeGroupsÆ]); 
a(REPEAT ¥_tac);
a(all_asm_fc_tac[]);
a(DROP_NTH_ASM_T 6 discard_tac);
a(lemma_tac¨Map (Map g) (MakeGroups g rlâ0) = Map (Map g) (MakeGroups g list2)Æ
	THEN1 all_asm_fc_tac[MakeGroups_lemma2]);
a(lemma_tac¨∂l0 ∑ MakeGroups g rlâ0 = l0ÆTHEN1 prove_∂_tac);
a(lemma_tac¨∂l1 ∑ MakeGroups g list2 = l1ÆTHEN1 prove_∂_tac);
=TEX
=SML
a(ante_tac(list_µ_elim[¨rlâ0Æ,¨gÆ]MakeGroups_lemma1));
a(ante_tac(list_µ_elim[¨list2Æ,¨gÆ]MakeGroups_lemma1));
a(DROP_NTH_ASM_T 4 ante_tac THEN DROP_NTH_ASM_T 3 ante_tac THEN
	POP_ASM_T rewrite_thm_tac THEN POP_ASM_T rewrite_thm_tac);
a(intro_µ_tac(¨l1Æ,¨l1Æ));
a(list_induction_tac¨l0Æ);
(* *** Goal "2.2.1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨l1Ælist_cases_thm));
(* *** Goal "2.2.1.1" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(rewrite_tac[get_spec¨PutInGroupÆ,get_spec¨MapÆ]);
a(asm_rewrite_tac[]);
(* *** Goal "2.2.1.2" *** *)
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
=TEX
=SML
(* *** Goal "2.2.2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨l1Ælist_cases_thm));
(* *** Goal "2.2.2.1" *** *)
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2.2.2.2" *** *)
a(var_elim_nth_asm_tac 1);
a(LIST_DROP_NTH_ASM_T [1,2,3,4](MAP_EVERY ante_tac) THEN 
	rewrite_tac(map get_spec[¨MapÆ,¨ElemsÆ,¨PutInGroupÆ])); 
a(REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(strip_asm_tac(µ_elim¨x''Ælist_cases_thm));
(* *** Goal "2.2.2.2.1" *** *)
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a(strip_asm_tac(µ_elim¨x'''Ælist_cases_thm));
=TEX
=SML
(* *** Goal "2.2.2.2.2.1" *** *)
a(DROP_NTH_ASM_T 7 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.2" *** *)
a(var_elim_nth_asm_tac 1);
a(var_elim_nth_asm_tac 1);
a(LIST_DROP_NTH_ASM_T [2,3,4,5,10](MAP_EVERY discard_tac));
a(DROP_NTH_ASM_T 3 (strip_asm_tac o rewrite_rule[get_spec¨MapÆ]));
a(DROP_NTH_ASM_T 6 (strip_asm_tac o rewrite_rule[get_spec¨MapÆ]));
a(rewrite_tac[]);
a(cases_tac¨g x = g x''''ÆTHEN cases_tac¨g x' = g x'''''Æ
	THEN asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2.2.2.2.2.2.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.2.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
val €MakeGroups_lemma3› = save_pop_thm"MakeGroups_lemma3";
=TEX
=SML
push_goal([],¨µ rlâ0 rlâ1 c gbsterling gbclass ∑
	c dominates lubl (Map (Ã row∑ lubl 
		(ListNth gbsterling (Map Fst (DTR_cols row)))) rlâ0)
±	Map (HideDerTableRow c) rlâ0 = Map (HideDerTableRow c) rlâ1
¥	Map (Ã row ∑ (ListNth gbsterling (Map Snd (DTR_cols row)), 
		ListNth gbclass (Map Fst (DTR_cols row)))) rlâ0 = 
	Map (Ã row ∑ (ListNth gbsterling (Map Snd (DTR_cols row)), 
		ListNth gbclass (Map Fst (DTR_cols row)))) rlâ1Æ);
a(REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [1,2](MAP_EVERY ante_tac) 
	THEN intro_µ_tac(¨rlâ1Æ,¨rlâ1Æ)); 
a(list_induction_tac¨rlâ0Æ);
=TEX
=SML
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨rlâ1Ælist_cases_thm));
(* *** Goal "1.1" *** *)
a(POP_ASM_T rewrite_thm_tac);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨rlâ1Ælist_cases_thm));
=TEX
=SML
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2.2" *** *)
a(var_elim_nth_asm_tac 1);
a(LIST_DROP_NTH_ASM_T [1,2](MAP_EVERY ante_tac) THEN 
	rewrite_tac[get_spec¨MapÆ,lubl_lemma,dominates_lub_lemma]); 
a(REPEAT ¥_tac);
a(all_asm_fc_tac[]);
a(DROP_NTH_ASM_T 6 discard_tac);
a(POP_ASM_T rewrite_thm_tac);
a(all_asm_fc_tac[GroupA_cols_lemma1]);
a(all_asm_fc_tac[GroupA_cols_lemma2]);
a(asm_rewrite_tac[]);
val €GroupA_lemma› = save_pop_thm"GroupA_lemma";
=TEX
\subsubsection{Data OKness lemmas}
First, proofs of $GroupA\_conj1$ and $GroupB\_conj1$.
=SML
push_goal([], GroupA_conj1);
a(rewrite_tac[get_spec¨GroupAÆ, let_def]
	THEN REPEAT strip_tac);
a(swap_nth_asm_concl_tac 1);
a(all_asm_fc_tac[GroupA_lemma]);
a(bc_tac[MakeGroups_lemma3]THEN_TRY asm_rewrite_tac[]);
val €GroupA_OKâd_lemma› = save_pop_thm"GroupA_OKâd_lemma";
=TEX
=SML
push_goal([], GroupB_conj1);
a(rewrite_tac[get_spec¨GroupBÆ, let_def]
	THEN REPEAT strip_tac);
a(swap_nth_asm_concl_tac 1);
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac);
a(intro_µ_tac(¨gpsâ1Æ,¨gpsâ1Æ));
a(list_induction_tac¨gpsâ0Æ);
=TEX
=SML
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨gpsâ1Ælist_cases_thm));
(* *** Goal "1.1" *** *)
a(asm_rewrite_tac[]THEN rewrite_tac[get_spec¨$˘Æ]);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨gpsâ1Ælist_cases_thm));
=TEX
=SML
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2.2" *** *)
a(var_elim_nth_asm_tac 1);
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac);
a(rewrite_tac(lubl_lemma :: dominates_lub_lemma :: map get_spec[¨MapÆ,¨$˘Æ]));
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(all_asm_fc_tac[CommonValue_OKâd_lemma]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[get_spec¨OK_VCâdÆ]));
a(all_asm_fc_tac[CommonValue_OKâc_lemma]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[get_spec¨OK_VCâcÆ]));
a(LEMMA_T¨HideDerTableRow c Arbitrary = HideDerTableRow c ArbitraryÆasm_tac 
	THEN_LIST[rewrite_tac[],all_asm_fc_tac[]]);
a(lemma_tac¨Snd (CommonValue having tlâ0 x Arbitrary)
	= Snd (CommonValue having tlâ1 x' Arbitrary)Æ
	THEN1 contr_tac THEN all_asm_fc_tac[]);
a(cases_tac¨ItemBool (Snd (CommonValue having tlâ1 x' Arbitrary))Æ
	THEN asm_rewrite_tac[get_spec¨MapÆ]);
val €GroupB_OKâd_lemma› = save_pop_thm"GroupB_OKâd_lemma";
=TEX
Finally, a proof of the Data OKness $Group$ conjecture, the main proof of this section.
=SML
push_goal([], Group_conj1);
a(MAP_EVERY (ante_tac o all_¥_intro) [
	Group_lemma2,
	GroupA_OKâd_lemma,
	GroupB_OKâd_lemma]
	THEN taut_tac);
val €Group_OKâd_lemma› = save_pop_thm"Group_OKâd_lemma";
=TEX
\subsubsection{Classification OKness lemmas}
First, proofs of $GroupA\_conj2$ and $GroupB\_conj2$.
=SML
push_goal([],GroupA_conj2);
a(rewrite_tac[get_spec¨GroupAÆ, let_def]
	THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨rlâ1Æ,¨rlâ1Æ)); 
a(list_induction_tac¨rlâ0Æ);
=TEX
=SML
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨rlâ1Ælist_cases_thm));
(* *** Goal "1.1" *** *)
a(POP_ASM_T rewrite_thm_tac);
(* *** Goal "1.2" *** *)
a(var_elim_nth_asm_tac 1);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[get_spec¨MapÆ]));
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨rlâ1Ælist_cases_thm));
=TEX
=SML
(* *** Goal "2.1" *** *)
a(var_elim_nth_asm_tac 1);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[get_spec¨MapÆ]));
(* *** Goal "2.2" *** *)
a(var_elim_nth_asm_tac 1);
a(POP_ASM_T ante_tac THEN 
	rewrite_tac[dominates_lub_lemma,lubl_lemma,get_spec¨MapÆ]); 
a(REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(all_asm_fc_tac[GroupA_cols_lemma1]);
a(asm_rewrite_tac[]);
val €GroupA_OKâc_lemma› = save_pop_thm"GroupA_OKâc_lemma";
=TEX
=SML
push_goal([],GroupB_conj2);
a(rewrite_tac[get_spec¨GroupBÆ, let_def]
	THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨gpsâ1Æ,¨gpsâ1Æ));
a(list_induction_tac¨gpsâ0Æ);
=TEX
=SML
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨gpsâ1Ælist_cases_thm));
(* *** Goal "1.1" *** *)
a(asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨gpsâ1Ælist_cases_thm));
=TEX
=SML
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2.2" *** *)
a(var_elim_nth_asm_tac 1);
a(POP_ASM_T ante_tac);
a(rewrite_tac[lubl_lemma,dominates_lub_lemma,get_spec¨MapÆ]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(all_asm_fc_tac[CommonValue_OKâc_lemma]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[get_spec¨OK_VCâcÆ]));
a(LEMMA_T¨HideDerTableRow c Arbitrary = HideDerTableRow c ArbitraryÆasm_tac 
	THEN_LIST[rewrite_tac[],all_asm_fc_tac[]]);
a(asm_rewrite_tac[]);
val €GroupB_OKâc_lemma› = save_pop_thm"GroupB_OKâc_lemma";
=TEX
Finally, a proof of the Classification OKness $Group$ conjecture, the main proof of this section.
=SML
push_goal([],Group_conj2);
a(rewrite_tac[Group_lemma1, let_def]THEN REPEAT strip_tac);
a(all_asm_fc_tac[GroupA_OKâc_lemma]);
a(lemma_tac¨Fst (GroupA rlâ1 ml nl) = Fst (GroupA rlâ0 ml nl)Æ THEN1 asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 2 discard_tac);
a(cases_tac¨c dominates Fst (GroupA rlâ0 ml nl)Æ THEN asm_rewrite_tac[]);
a(bc_tac[GroupB_OKâc_lemma] THEN_TRY asm_rewrite_tac[]);
a(∂_tac¨cÆTHEN asm_rewrite_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac(map get_spec[¨LetÆ,¨GroupAÆ]));
a(strip_tac THEN bc_tac[MakeGroups_lemma3] THEN_TRY asm_rewrite_tac[]);
a(all_asm_fc_tac[GroupA_lemma]);
a(asm_rewrite_tac[]);
val €Group_OKâc_lemma› = save_pop_thm"Group_OKâc_lemma";
=TEX
\subsection{$ProjectData$}
=SML
push_goal([],ProjectData_conj);
a(REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨gpsâ1Æ,¨gpsâ1Æ));
a(list_induction_tac¨gpsâ0Æ);
(* *** Goal "1" *** *)
a µ_tac;
a(strip_asm_tac (µ_elim¨gpsâ1Ælist_cases_thm));
(* *** Goal "1.1" *** *)
a(asm_rewrite_tac(map get_spec[¨LetÆ,¨ProjectDataÆ,¨MapÆ]));
(* *** Goal "1.2" *** *)
a(asm_rewrite_tac[get_spec¨MapÆ]);
=TEX
=SML
(* *** Goal "2" *** *)
a(REPEAT µ_tac);
a(strip_asm_tac (µ_elim¨gpsâ1Ælist_cases_thm));
(* *** Goal "2.1" *** *)
a(asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2.2" *** *)
a(var_elim_nth_asm_tac 1);
a(¥_T (strip_asm_tac o rewrite_rule(map get_spec[¨MapÆ])));
a(all_asm_fc_tac[]);
a(rewrite_tac[ProjectData_lemma]);
=TEX
=SML
a(lemma_tac¨µ x1 x2 x' ∑
	Map (HideDerTableRow c) x = Map (HideDerTableRow c) x'
±	Map (HideDerTableRow c) x1 = Map (HideDerTableRow c) x2
¥
	Map
               (HideDerTableRow c)
               (Map (Ã r∑ MkDerTableRow (DTR_where r) (DTR_row r) 
			(Map (Ã e∑ e tlâ0 x1 r) sl)) x
                   Î ProjectData tlâ0 sl gpsâ0)
             = Map
               (HideDerTableRow c)
               (Map (Ã r∑ MkDerTableRow (DTR_where r) (DTR_row r) 
			(Map (Ã e∑ e tlâ1 x2 r) sl)) x'
                   Î ProjectData tlâ1 sl list2)ÆTHEN_LIST[id_tac, all_asm_fc_tac[]]);
a(DROP_NTH_ASM_T 3 discard_tac);
a(list_induction_tac¨xÆ);
=TEX
=SML
(* *** Goal "2.2.1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim¨x'Ælist_cases_thm));
(* *** Goal "2.2.1.1" *** *)
a(asm_rewrite_tac(map get_spec[¨MapÆ,¨$ÎÆ]));
(* *** Goal "2.2.1.2" *** *)
a(var_elim_nth_asm_tac 1);
a(DROP_NTH_ASM_T 2(strip_asm_tac o rewrite_rule[get_spec¨MapÆ]));
(* *** Goal "2.2.2" *** *)
a(REPEAT µ_tac);
a(strip_asm_tac(µ_elim¨x''Ælist_cases_thm));
(* *** Goal "2.2.2.1" *** *)
a(asm_rewrite_tac[get_spec¨MapÆ]);
(* *** Goal "2.2.2.2" *** *)
a(asm_rewrite_tac(map get_spec[¨MapÆ,¨$ÎÆ]));
a(REPEAT strip_tac THEN all_asm_fc_tac[ProjectData_lemma1]);
val €ProjectData_OKâd_lemma› = save_pop_thm"ProjectData_OKâd_lemma";
=TEX
\section{DATA OKNESS PROOFS}
\subsection{$TableContents$}
=SML
set_goal([], ¨µc i∑ TableContents i ç OK_TCâd cÆ);
a(rewrite_tac(map get_spec[¨OK_TCâdÆ, ¨TableContentsÆ])
	THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac);
a(lemma_tac¨# (Map (HideDerTable c) tlâ1)
             = # (Map (HideDerTable c) tlâ0)Æ
	THEN1 asm_rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule [length_map_thm]));
a(cases_tac ¨1 º i ± i º # tlâ0Æ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(all_fc_tac[fun_nth_map_lemma1]);
val €TableContents_OKâd_lemma› = save_pop_thm"TableContents_OKâd_lemma";
=TEX
\subsection{$AllTuples$}
=SML
push_goal([], ¨µc esl tel e1 ml nl e2 ∑ 
	Elems (Map Fst esl) Ä OK_VCâd c ° OK_VCâc c ±
	Elems tel Ä OK_TCâd c ±
	e1 ç OK_VCâd c ° OK_VCâc c±
	e2 ç OK_VCâd c ° OK_VCâc c ¥
	AllTuples c esl tel e1 ml nl e2 ç OK_TCâd cÆ);
a(rewrite_tac[get_spec¨OK_TCâdÆ]);
a(REPEAT strip_tac);
a(swap_nth_asm_concl_tac 1);
a(lemma_tac¨c dominates lubl (Fst (Split (Map (Ã te∑ te tlâ0) tel)))Æ);
(* *** Goal "1" *** *)
a(swap_nth_asm_concl_tac 1);
a(asm_rewrite_tac(map get_spec [¨LetÆ,¨AllTuplesÆ]));
=TEX
=SML
(* *** Goal "2" *** *)
a(lemma_tac¨Map
               (HideDerTable c)
               (Snd (Split (Map (Ã te∑ te tlâ0) tel)))
             = Map
               (HideDerTable c)
               (Snd (Split (Map (Ã te∑ te tlâ1) tel)))Æ
	THEN1 bc_tac[AllTuples_lemma1]THEN_TRY asm_rewrite_tac[]);
a(all_fc_tac[Join_OKâd_lemma]);
a(POP_ASM_T discard_tac);
a(POP_ASM_T ante_tac);
a(POP_ASM_T discard_tac);
a(DROP_NTH_ASM_T 2 ante_tac);
a(asm_rewrite_tac(MkDerTable_lemma :: map get_spec
	[¨AllTuplesÆ,¨LetÆ,¨HideDerTableÆ,¨ProjectÆ,¨DT_specÆ]));
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
=TEX
=SML
a(lemma_tac¨Map
               (HideDerTableRow c)
               (Where c tlâ0 (Snd (Join (Snd (Split (Map (Ã te∑ te tlâ0) tel))))) e1)
             = Map
               (HideDerTableRow c)
               (Where c tlâ1 (Snd (Join (Snd (Split (Map (Ã te∑ te tlâ1) tel))))) e1)Æ
	 THEN_LIST[all_asm_fc_tac[Where_OKâd_lemma],id_tac]);
a(lemma_tac¨c dominates lubl (Map DTR_row 
	(Where c tlâ0 (Snd (Join (Snd (Split (Map (Ã te∑ te tlâ0) tel))))) e1))
± 	c dominates lubl (Map DTR_row 
	(Where c tlâ1 (Snd (Join (Snd (Split (Map (Ã te∑ te tlâ1) tel))))) e1))Æ
		THEN1 rewrite_tac[Where_dominates_lemma]);
=TEX
=SML
a(lemma_tac¨Map (Map (HideDerTableRow c)) 
 (Snd (Group c tlâ0 (Where c tlâ0 (Snd (Join (Snd (
	Split (Map (Ã te∑ te tlâ0) tel))))) e1) ml nl e2))
            = Map (Map (HideDerTableRow c)) 
 (Snd (Group c tlâ1 (Where c tlâ1 (Snd (Join (Snd (
	Split (Map (Ã te∑ te tlâ1) tel))))) e1) ml nl e2))Æ
	THEN1 contr_tac THEN all_asm_fc_tac[Group_OKâd_lemma]);
a(all_asm_fc_tac[ProjectData_OKâd_lemma]);
a(bc_tac[HideDerTableData_lemma1]THEN asm_rewrite_tac[]);
val €AllTuples_OKâd_lemma› = save_pop_thm"AllTuples_OKâd_lemma";
=TEX
\section{CLASSIFICATION OKNESS PROOFS}
\subsection{$TableContents$}
=SML
set_goal([], ¨µc i∑ TableContents i ç OK_TCâc cÆ);
a(rewrite_tac(map get_spec[¨OK_TCâcÆ, ¨TableContentsÆ])
	THEN REPEAT strip_tac);
a(lemma_tac¨# (Map (HideDerTable c) tlâ1)
             = # (Map (HideDerTable c) tlâ0)Æ
	THEN1 asm_rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule [length_map_thm]));
a(cases_tac ¨1 º i ± i º # tlâ0Æ THEN asm_rewrite_tac[]);
val €TableContents_OKâc_lemma› = save_pop_thm"TableContents_OKâc_lemma";
=TEX
\subsection{$AllTuples$}
=SML
push_goal([],¨µ c tlâ0 tlâ1 tel
∑ Elems tel Ä OK_TCâc c
      ± Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1
    ¥ lubl (Fst (Split (Map (Ã te∑ te tlâ0) tel)))
      = lubl (Fst (Split (Map (Ã te∑ te tlâ1) tel)))Æ);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 ante_tac);
a(list_induction_tac¨telÆ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac(map get_spec[¨MapÆ]));
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext" asm_prove_tac[get_spec¨ElemsÆ]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac
	[fst_snd_split_thm,map_o_lemma,lubl_lemma,get_spec¨MapÆ,get_spec¨ElemsÆ]);
a(REPEAT strip_tac);
a(lemma_tac¨x ç OK_TCâc cÆTHEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[get_spec¨OK_TCâcÆ]));
a(all_asm_fc_tac[]);
a(asm_rewrite_tac[]);
val €AllTuples_lemma2› = save_pop_thm"AllTuples_lemma2";
=TEX
=SML
push_goal([], ¨µc esl tel e1 ml nl e2 ∑ 
	e1 ç OK_VCâc c ° OK_VCâd c ±
	Elems tel Ä OK_TCâd c ° OK_TCâc c ±
	e2 ç OK_VCâc c ¥
	AllTuples c esl tel e1 ml nl e2 ç OK_TCâc cÆ);
a(rewrite_tac[get_spec¨OK_TCâcÆ]);
a(REPEAT strip_tac);
a(lemma_tac¨Elems tel Ä OK_TCâc c ± Elems tel Ä OK_TCâd cÆ
	THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(all_asm_fc_tac[AllTuples_lemma2]);
a(rewrite_tac(map get_spec[¨LetÆ,¨AllTuplesÆ]));
=TEX
=SML
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(cases_tac¨c dominates lubl (Fst (Split (Map (Ã te∑ te tlâ0) tel)))Æ
	THEN asm_rewrite_tac[]);
a(bc_tac[Group_OKâc_lemma]THEN_TRY asm_rewrite_tac[]);
a(bc_tac[Where_OKâd_lemma]THEN_TRY PC_T1 "sets_ext" asm_rewrite_tac[]);
a(all_fc_tac[AllTuples_lemma1]);
a(all_asm_fc_tac[Join_OKâd_lemma]);
a(POP_ASM_T discard_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule(MkDerTable_lemma :: 
	map get_spec[¨HideDerTableÆ,¨MkDerTableÆ])));
val €AllTuples_OKâc_lemma› = save_pop_thm"AllTuples_OKâc_lemma";
=TEX
\section{CLOSING DOWN}
=TEX

\newpage
\HOLindexOff
\input{fef035th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}
