=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Table Computation Security Proofs}  %% Mandatory field
\TPPref{DS/FMU/FEF/035}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.B.~Jones & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document completes the formal proofs relating to 
DS/FMU/FEF/033; it forms part of the Phase II proofs for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion(\FormatDate{$Date$
})] First draft.
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document provides a formal proof relating
to the specifications in ``An Execution Model for SWORD'' \cite{DS/FMU/FEF/026}.
It constitutes part of deliverable D13 of work package 3, as given
in section 3 of the Proposal for Phase 2, \cite{DS/FMU/FEF/018}.


(The current version is a rough draft of proofs of some of the propositions
produced as pilot work during the third stage of phase 2.)

\subsection{Introduction}
\section{PRELIMINARIES}
The following \Product{} instructions set up a new theory $fef035$
to hold the theorems to be proved and set up a proof context in which
to carry out the proofs. 

=SML 
open_theory "fef033";
new_theory€"fef035"›;
set_pc"hol";
=TEX
\section{LEMMAS}
=SML
push_goal([],¨µ l s ∑ l ˘ s = [] § s = {} ≤ (µ x ∑ x ç Elems l ¥ ≥ x ç s)Æ);
a(REPEAT µ_tac);
a(list_induction_tac¨lÆ);
(* *** Goal "1" *** *)
a(rewrite_tac(map get_spec[¨$˘Æ,¨ElemsÆ]));
(* *** Goal "2" *** *)
a(rewrite_tac(map get_spec[¨$˘Æ,¨ElemsÆ]));
a(PC_T1 "sets_ext" REPEAT strip_tac);
=TEX
=SML
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac);
a(cases_tac¨x' ç sÆTHEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 3 ante_tac);
a(cases_tac¨x' ç sÆTHEN asm_rewrite_tac[]);
(* *** Goal "2.3" *** *)
a(PC_T1 "sets_ext" all_asm_fc_tac[]);
(* *** Goal "2.4" *** *)
a(spec_nth_asm_tac 1 ¨xÆ);
=TEX
=SML
(* *** Goal "3" *** *)
a(asm_rewrite_tac[get_spec¨$˘Æ]);
(* *** Goal "4" *** *)
a(asm_rewrite_tac[]);
a(rewrite_tac(map get_spec[¨ElemsÆ,¨$˘Æ]));
a(REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(var_elim_nth_asm_tac 1);
a(swap_nth_asm_concl_tac 1);
a(asm_rewrite_tac[]);
(* *** Goal "4.2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "4.3" *** *)
a(all_asm_fc_tac[]);
=TEX
=SML
(* *** Goal "5" *** *)
a(rewrite_tac(map get_spec[¨ElemsÆ,¨$˘Æ]));
a(REPEAT strip_tac);
(* *** Goal "5.1" *** *)
a(var_elim_nth_asm_tac 1);
a(swap_nth_asm_concl_tac 2);
a(asm_rewrite_tac[]);
(* *** Goal "5.2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "5.3" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "5.4" *** *)
a(cases_tac¨x ç sÆTHEN asm_rewrite_tac[]);
a(spec_nth_asm_tac 2¨xÆ);
val €˘_null_lemma› = save_pop_thm"˘_null_lemma";
=TEX
=SML
push_goal([],¨µ tl el gp gps ∑
	ProjectData tl el [] = []
±	ProjectData tl el (Cons gp gps) = 
	Map (Ã r∑ MkDerTableRow (DTR_where r) (DTR_row r) (Map (Ã e∑ e tl gp r) el)) gp
	Î ProjectData tl el gpsÆ);
a(rewrite_tac(map get_spec[¨MapÆ,¨ProjectDataÆ,¨FlatÆ,¨LetÆ]) THEN REPEAT strip_tac);
val €ProjectData_lemma› = save_pop_thm"ProjectData_lemma";
=TEX
=SML
set_goal([], ¨µx1 x2 x3 y1 y2 y3∑
	MkDerTableSpec x1 x2 x3 = MkDerTableSpec y1 y2 y3
		 § x1 = y1 ± x2 = y2 ± x3 = y3Æ);
a(REPEAT_UNTIL is_§ strip_tac THEN §_tac THEN_TRY asm_rewrite_tac[]);
a(LEMMA_T¨y1 = DTS_name (MkDerTableSpec x1 x2 x3) ± 
	y2 = DTS_maxRow (MkDerTableSpec x1 x2 x3) ± 
	y3 = DTS_colSpecs(MkDerTableSpec x1 x2 x3)Æ
	rewrite_thm_tac
	THEN1 (asm_rewrite_tac[]THEN rewrite_tac[get_spec¨MkDerTableSpecÆ]));
a(rewrite_tac[get_spec¨MkDerTableSpecÆ]);
val €MkDerTableSpec_lemma› = save_pop_thm"MkDerTableSpec_lemma";
=TEX
=SML
push_goal([],¨µ l1 l2 ∑ [] = l1 Î l2  § l1 = [] ± l2 = []Æ);
a(REPEAT µ_tac THEN §_tac THEN_TRY asm_rewrite_tac[get_spec¨$ÎÆ]);
a(POP_ASM_T ante_tac THEN list_induction_tac¨l1ÆTHEN rewrite_tac[get_spec¨$ÎÆ]);
val €Î_null_lemma1› = save_pop_thm"Î_null_lemma1";
=TEX
=SML
(* **** stuff from fef031 **** *)
set_goal([], ¨µc t∑ DT_spec (HideDerTable c t) = DT_spec tÆ);
a(rewrite_tac (map get_spec[¨HideDerTableÆ, ¨DT_specÆ, ¨LetÆ]));
val €DT_spec_HideDerTable_lemma› = save_pop_thm"DT_spec_HideDerTable_lemma";
=TEX
=SML
set_goal([], ¨µc ts1 ts2∑
	Map (HideDerTable c) ts1 = Map (HideDerTable c) ts2
¥	(Map DT_spec ts1) = (Map DT_spec ts2)Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨
	Map DT_spec(Map (HideDerTable c) ts1) =
	Map DT_spec(Map (HideDerTable c) ts2)Æ
	ante_tac THEN1 asm_rewrite_tac[]);
a(lemma_tac¨DT_spec o HideDerTable c = DT_specÆ
	THEN1 PC_T1 "hol2" rewrite_tac[DT_spec_HideDerTable_lemma]);
a(asm_rewrite_tac[map_o_lemma]);
val €map_HideDerTable_map_DT_spec_lemma› =
	save_pop_thm"map_HideDerTable_map_DT_spec_lemma";
=TEX
=SML
push_goal([], ¨µc r rs∑
	HideDerTableData c [] = []
±	HideDerTableData c (Cons r rs) = 
		if	c dominates (DTR_row r lub DTR_where r)
		then	Cons (HideDerTableRow c r) (HideDerTableData c rs)
		else	HideDerTableData c rs
Æ);
a(rewrite_tac(map get_spec[¨HideDerTableDataÆ, ¨$˘Æ, ¨MapÆ, ¨LetÆ]));
a(REPEAT strip_tac);
a(cases_tac¨c dominates (DTR_row r lub DTR_where r)Æ THEN asm_rewrite_tac[]);
a(rewrite_tac(map get_spec[¨MapÆ]));
val €HideDerTableData_lemma› = save_pop_thm"HideDerTableData_lemma";
=TEX
=SML
push_goal([], ¨µc r1 r2 rs∑
	JoinRows r1 [] = []
±	JoinRows r1 (Cons r2 rs) = 
	Cons
	(MkDerTableRow
		(DTR_where r1 lub DTR_where r2)
		(DTR_row r1 lub DTR_row r2)
		(DTR_cols r1 Î DTR_cols r2))
	(JoinRows r1 rs)
Æ);
a(rewrite_tac(map get_spec[¨JoinRowsÆ, ¨MapÆ, ¨LetÆ]));
val €JoinRows_lemma› = save_pop_thm"JoinRows_lemma";
=TEX
=SML
push_goal([], ¨µc blks∑
	HideDerTableData c (Flat blks) = Flat (Map (HideDerTableData c) blks)
Æ);
a(REPEAT strip_tac);
a(list_induction_tac¨blksÆ THEN asm_rewrite_tac(map get_spec[¨FlatÆ, ¨MapÆ]));
(* *** Goal "1" *** *)
a(rewrite_tac(map get_spec[¨HideDerTableDataÆ, ¨MapÆ, ¨LetÆ, ¨$˘Æ]));
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(list_induction_tac¨xÆ);
(* *** Goal "1" *** *)
a(lemma_tac¨HideDerTableData c [] = []Æ
	THEN1 rewrite_tac(map get_spec[¨HideDerTableDataÆ, ¨MapÆ, ¨LetÆ, ¨$˘Æ]));
a(asm_rewrite_tac(map get_spec[¨$AppendÆ, ¨MapÆ, ¨FlatÆ]));
(* *** Goal "2.2" *** *)
a(rewrite_tac(map get_spec[¨$AppendÆ, ¨MapÆ, ¨FlatÆ]));
a(all_asm_ante_tac
	THEN rewrite_tac(map get_spec[¨HideDerTableDataÆ, ¨MapÆ, ¨LetÆ])
	THEN REPEAT strip_tac);
a(rewrite_tac[get_spec¨$˘Æ]);
a(cases_tac ¨c dominates DTR_row x' lub DTR_where x'Æ THEN
	TOP_ASM_T rewrite_thm_tac
	THEN asm_rewrite_tac(map get_spec[¨MapÆ, ¨$AppendÆ]));
val €HideDerTable_flat_lemma› =
	save_pop_thm"HideDerTable_flat_lemma";
=TEX
=SML
val €conj1› = ¨µtlâ0  tlâ1 c∑
	Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1 ¥
	HideDerTable
               c
               (MkDerTable
                   (Fst (Join tlâ0))
                   (Snd (Join tlâ0)))
             = HideDerTable
               c
               (MkDerTable
                   (Fst (Join tlâ1))
                   (Snd (Join tlâ1)))Æ;
val €conj2› = ¨µc ts1 ts2∑
	Map (HideDerTable c) ts1 = Map (HideDerTable c) ts2
¥	HideDerTableData c (JoinData (Map DT_rows ts1)) =
	HideDerTableData c (JoinData (Map DT_rows ts2))Æ;
val €conj3› = ¨µc ts1 ts2∑
	Map (HideDerTable c) ts1 = Map (HideDerTable c) ts2
¥	Map (HideDerTableData c) (Map DT_rows ts1)
	= Map (HideDerTableData c) (Map DT_rows ts2)Æ;
val €conj4› = ¨µc ds1 ds2∑
	Map (HideDerTableData c) ds1 = Map (HideDerTableData c) ds2
¥	HideDerTableData c (JoinData ds1) =
	HideDerTableData c (JoinData ds2)Æ;
val €conj5› = ¨µc rs1 rs2∑
	Flat(Map (Ãr∑ HideDerTableData c (JoinRows r rs2)) rs1) =
	Flat(Map (Ãr∑ JoinRows r (HideDerTableData c rs2)) (HideDerTableData c rs1))Æ;
val €conj6› = ¨µc r rs∑
		HideDerTableData c (JoinRows r rs)
	=	if	c dominates DTR_row r lub DTR_where r
		then	JoinRows (HideDerTableRow c r) (HideDerTableData c rs)
		else []Æ;
=TEX
=SML
set_goal([conj2], conj1);
a(REPEAT strip_tac);
a(rewrite_tac(MkDerTable_lemma :: map get_spec[¨JoinÆ, ¨HideDerTableÆ, ¨MkDerTableÆ]));
a(ALL_ASM_FC_T rewrite_tac [map_HideDerTable_map_DT_spec_lemma]);
val €Join_lemma1› = save_pop_thm"Join_lemma1";
=TEX
=SML
set_goal([conj3, conj4], conj2);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(all_asm_fc_tac[]);
val €Join_lemma2› = save_pop_thm"Join_lemma2";
=TEX
=SML
set_goal([], conj3);
a(REPEAT_N 2 strip_tac);
a(list_induction_tac¨ts1Æ);
(* *** Goal "1" *** *)
a(strip_tac);
a(strip_asm_tac(µ_elim¨ts2Æ list_cases_thm)
	THEN asm_rewrite_tac[map_def]);
(* *** Goal "2" *** *)
a(REPEAT_N 2 strip_tac);
a(strip_asm_tac(µ_elim¨ts2Æ list_cases_thm)
	THEN asm_rewrite_tac[map_def]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(asm_ante_tac ¨HideDerTable c x = HideDerTable c x'Æ
	THEN rewrite_tac[MkDerTable_lemma, get_spec¨HideDerTableÆ]);
a(REPEAT strip_tac);
val €Join_lemma3› = save_pop_thm"Join_lemma3";
=TEX
=SML
set_goal([conj5], conj4);
a(strip_tac THEN strip_tac);
a(list_induction_tac ¨ds1Æ);
(* *** Goal "1" *** *)
a(rewrite_tac[get_spec¨MapÆ, map_null_thm]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[get_spec¨MapÆ] THEN REPEAT µ_tac);
a(strip_asm_tac(µ_elim¨ds2Ælist_cases_thm) THEN 
	asm_rewrite_tac[get_spec¨MapÆ, map_null_thm]);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim¨ds1Ælist_cases_thm));
=TEX
=SML
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[get_spec¨MapÆ, map_null_thm]);
a(REPEAT strip_tac THEN var_elim_asm_tac¨list2 = []Æ);
a(asm_rewrite_tac(map get_spec [¨JoinDataÆ, ¨LetÆ]));
(* *** Goal "2.2" *** *)
a(lemma_tac¨≥ds1 = [] ± ≥list2 = []Æ THEN1 asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
a(swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[get_spec¨MapÆ, map_null_thm]);
(* *** Goal "2.2.2" *** *)
a(LIST_DROP_NTH_ASM_T [3, 6] (Combinators.K id_tac));
a(asm_rewrite_tac(let_def::HideDerTable_flat_lemma::map get_spec [¨JoinDataÆ]));
a(asm_rewrite_tac[map_o_lemma,
	pc_rule1"hol2"prove_rule[]¨µf g z∑(f o (Ãx∑g x z)) = (Ãx∑f(g x z))Æ]);
a(ALL_ASM_FC_T rewrite_tac[]);
val €Join_lemma4› = save_pop_thm"Join_lemma4";
=TEX
=SML
set_goal([conj6], conj5);
a(REPEAT strip_tac);
a(list_induction_tac ¨rs1Æ);
(* *** Goal "1" *** *)
a(rewrite_tac(map get_spec[¨HideDerTableDataÆ, ¨FlatÆ, ¨MapÆ, ¨LetÆ, ¨$˘Æ]));
(* *** Goal "2" *** *)
a(rewrite_tac(HideDerTableData_lemma :: map get_spec[¨FlatÆ, ¨MapÆ]));
a(strip_tac);
a(cases_tac¨c dominates (DTR_row x lub DTR_where x)Æ
	THEN asm_rewrite_tac(map get_spec[¨$ÎÆ, ¨MapÆ, ¨FlatÆ]));
val €Join_lemma5› = save_pop_thm"Join_lemma5";
=TEX
=SML
set_goal([], conj6);
a(REPEAT strip_tac);
a(list_induction_tac¨rsÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[HideDerTableData_lemma, JoinRows_lemma]);
a(CASES_T ¨c dominates (DTR_row r lub DTR_where r)Æ rewrite_thm_tac);
(* *** Goal "2" *** *)
a(strip_tac);
a(cases_tac ¨c dominates (DTR_row r lub DTR_where r)Æ THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "2.1" *** *)
a(swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[] THEN swap_nth_asm_concl_tac 1);
a(DROP_NTH_ASM_T 2 ante_tac);
a(rewrite_tac[HideDerTableData_lemma, JoinRows_lemma,
	dominates_lub_lemma, get_spec¨MkDerTableRowÆ]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
a(cases_tac ¨c dominates DTR_row x ± c dominates DTR_where xÆ
	THEN asm_rewrite_tac[]);
a(rewrite_tac[JoinRows_lemma]);
a(asm_rewrite_tac(MkDerTableRow_lemma:: map_Î_thm1::
	map get_spec[¨HideDerTableRowÆ, ¨MkDerTableRowÆ, ¨LetÆ]));
(* *** Goal "2.2" *** *)
a(POP_ASM_T ante_tac);
a(asm_rewrite_tac[HideDerTableData_lemma, JoinRows_lemma,
	dominates_lub_lemma, get_spec¨MkDerTableRowÆ]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val €Join_lemma6› = save_pop_thm"Join_lemma6";
=TEX
=SML
set_goal([], conj1);
a(MAP_EVERY (ante_tac o all_¥_intro) [
	Join_lemma1,
	Join_lemma2,
	Join_lemma3,
	Join_lemma4,
	Join_lemma5,
	Join_lemma6]
	THEN taut_tac);
val €Join_OK_lemma› = save_pop_thm"Join_OK_lemma";
=TEX
=SML
push_goal([],¨µ c tlâ0 tlâ1 tel
∑ Elems tel Ä OK_TC c
      ± c dominates lubl (Fst (Split (Map (Ã te∑ te tlâ0) tel)))
      ± Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1
    ¥ Map (HideDerTable c) (Snd (Split (Map (Ã te∑ te tlâ0) tel)))
      = Map (HideDerTable c) (Snd (Split (Map (Ã te∑ te tlâ1) tel)))Æ);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN DROP_NTH_ASM_T 2 ante_tac);
a(list_induction_tac¨telÆ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac(map get_spec[¨MapÆ]));
(* *** Goal "2" *** *)
a(rewrite_tac[dominates_lub_lemma,lubl_lemma,split_thm,get_spec¨MapÆ]);
a(REPEAT strip_tac);
=TEX
=SML
(* *** Goal "3" *** *)
a(PC_T1 "sets_ext" asm_prove_tac[get_spec¨ElemsÆ]);
(* *** Goal "4" *** *)
a(REPEAT strip_tac);
a(asm_rewrite_tac[split_thm,get_spec¨MapÆ]);
a(lemma_tac¨x ç OK_TC cÆ);
(* *** Goal "4.1" *** *)
a(PC_T1 "sets_ext" asm_prove_tac[get_spec¨ElemsÆ]);
(* *** Goal "4.2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[get_spec¨OK_TCÆ]));
a(DROP_NTH_ASM_T 3 (strip_asm_tac o rewrite_rule[dominates_lub_lemma,lubl_lemma,
	split_thm,get_spec¨MapÆ]));
a(list_spec_nth_asm_tac 3 [¨tlâ0Æ,¨tlâ1Æ]);
val €AllTuples_lemma› = save_pop_thm"AllTuples_lemma";
=TEX

\subsection{Conjectures required for $AllTuples$}
=SML
val €where_conj1› = ¨µtl rl c e ∑
	 c dominates lubl (Map DTR_row (Where c tl rl e))Æ;
=TEX

=SML
val €where_conj2› = ¨µtlâ0  tlâ1 rlâ0 rlâ1 c e ∑
	e ç OK_VC c
±	Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1 
±	HideDerTableData c rlâ0 = HideDerTableData c rlâ1
¥
	HideDerTableData c (Where c tlâ0 rlâ0 e) = HideDerTableData c (Where c tlâ1 rlâ1 e)Æ;
=TEX
=SML
val €projectdata_conj› = ¨µtlâ0  tlâ1 rlâ0 rlâ1 c sl ∑
	Elems sl Ä OK_VC c
±	Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1 
±	Map (HideDerTableData c) rlâ0 = Map (HideDerTableData c) rlâ1
¥
	HideDerTableData c (ProjectData tlâ0 sl rlâ0) 
	= 
	HideDerTableData c (ProjectData tlâ1 sl rlâ1)Æ;
=TEX
=SML
val €group_conj› = ¨µtlâ0  tlâ1 rlâ0 rlâ1 c e ml nl ∑
	e ç OK_VC c
±	c dominates lubl (Map DTR_row rlâ0)
±	c dominates lubl (Map DTR_row rlâ1)
±	Map (HideDerTable c) tlâ0 = Map (HideDerTable c) tlâ1 
±	HideDerTableData c rlâ0 = HideDerTableData c rlâ1
±	≥ Map (HideDerTableData c) (Snd(Group tlâ0 rlâ0 ml nl e)) 
	= 
	Map (HideDerTableData c) (Snd(Group tlâ1 rlâ1 ml nl e))
¥	≥ c dominates Fst(Group tlâ0 rlâ0 ml nl e)Æ ;
=TEX


\section{OKNESS PROOFS}
\subsection{$TableContents$}
=SML
set_goal([], ¨µc i∑ TableContents i ç OK_TC cÆ);
a(rewrite_tac(map get_spec[¨OK_TCÆ, ¨TableContentsÆ])
	THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac);
a(lemma_tac¨# (Map (HideDerTable c) tlâ1)
             = # (Map (HideDerTable c) tlâ0)Æ
	THEN1 asm_rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule [length_map_thm]));
a(cases_tac ¨1 º i ± i º # tlâ0Æ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(all_fc_tac[fun_nth_map_lemma1]);
val €TableContents_OK_lemma› = save_pop_thm"TableContents_OK_lemma";
=TEX
\subsection{$AllTuples$}
=SML
push_goal([where_conj1,where_conj2,group_conj,projectdata_conj], ¨µc esl tel e1 ml nl e2 ∑ 
	Elems (Map Fst esl) Ä OK_VC c ±
	Elems tel Ä OK_TC c ±
	e1 ç OK_VC c ±
	e2 ç OK_VC c ¥
	AllTuples c esl tel e1 ml nl e2 ç OK_TC cÆ);
a(rewrite_tac[get_spec¨OK_TCÆ]);
a(REPEAT strip_tac);
a(swap_nth_asm_concl_tac 1);
a(lemma_tac¨Map
               (HideDerTable c)
               (Snd (Split (Map (Ã te∑ te tlâ0) tel)))
             = Map
               (HideDerTable c)
               (Snd (Split (Map (Ã te∑ te tlâ1) tel)))Æ);
(* *** Goal "1" *** *)
a(bc_tac[AllTuples_lemma]THEN_TRY asm_rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule(dominates_lub_lemma :: lubl_lemma :: 
	map get_spec [¨LetÆ,¨AllTuplesÆ,¨MapÆ,¨GroupÆ])));
=TEX
=SML
(* *** Goal "2" *** *)
a(all_fc_tac[Join_OK_lemma]);
a(POP_ASM_T (fn x => id_tac));
a(POP_ASM_T ante_tac);
a(DROP_NTH_ASM_T 2 ante_tac);
a(rewrite_tac(MkDerTable_lemma :: dominates_lub_lemma :: map get_spec
	[¨AllTuplesÆ,¨LetÆ,¨HideDerTableÆ,¨ProjectÆ,¨DT_specÆ]));
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 12 (ante_tac o list_µ_elim[¨tlâ0Æ,¨tlâ1Æ,
	¨Snd (Join (Snd (Split (Map (Ã te∑ te tlâ0) tel))))Æ,
	¨Snd (Join (Snd (Split (Map (Ã te∑ te tlâ1) tel))))Æ,
	¨cÆ,¨e1Æ]));
a(asm_rewrite_tac[]);
a strip_tac;
a(DROP_NTH_ASM_T 13 (ante_tac o list_µ_elim[¨tlâ0Æ,¨tlâ1Æ,
	¨Where c tlâ0 (Snd (Join (Snd (Split (Map (Ã te∑ te tlâ0) tel))))) e1Æ,
	¨Where c tlâ1 (Snd (Join (Snd (Split (Map (Ã te∑ te tlâ1) tel))))) e1Æ,
	¨cÆ,¨e2Æ,¨mlÆ,¨nlÆ]));
a(asm_rewrite_tac[]);
a strip_tac;
=TEX
=SML
a(DROP_NTH_ASM_T 14 (ante_tac o list_µ_elim[¨tlâ0Æ,¨tlâ1Æ,
	¨Snd(Group
                           tlâ0
                           (Where c tlâ0 (Snd (Join (Snd (Split (Map (Ã te∑ te tlâ0) tel))))) e1)
                           ml
                           nl
                           e2)Æ,
	¨Snd(Group
                           tlâ1
                           (Where c tlâ1 (Snd (Join (Snd (Split (Map (Ã te∑ te tlâ1) tel))))) e1)
                           ml
                           nl
                           e2)Æ,
	¨cÆ,¨Map Fst eslÆ]));
a(REPEAT strip_tac);
val €AllTuples_lemma1› =	save_pop_thm"AllTuples_lemma1";
=TEX
\section{CLOSING DOWN}
=TEX

\newpage
\HOLindexOff
\input{fef035th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}
  
