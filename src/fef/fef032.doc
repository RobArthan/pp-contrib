=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Table Computations for SWORD}  %% Mandatory field
\TPPref{DS/FMU/FEF/032}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.~D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{A specification of the table computations allowed in the Front End
implementation of SWORD for the DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents

\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$%
}}) ] Corrected $Condition\_E$ in light of pilot proof work.
\end{description}

\subsection{Changes Forecast}
The current issue is a partial draft to promote discussion about the approach.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document gives a formal specification of part of the SWORD Front
End reducing the security properties given in \cite{DS/FMU/FEF/026}
to lower level properties more closely related to the detailed transformations
of \cite{trans}.  It constitutes part of deliverable D12 of work package 3, as
given in the Phase 2 Technical Proposal, \cite{DS/FMU/017}.

Some of the material in this document was previously included in
\cite{DS/FMU/FEF/026}. Now that the formal development has been further
advanced it was felt more appropriate to collect this level of the
treatment into a separate document.

\subsection{Introduction}

\cite{DS/FMU/FEF/026} gives a formal description of an Execution Model
for the Front End Implementation of SWORD. The Execution Model affords
a rather more concrete formulation of the critical requirements on the
major subsystems of SWORD than the architectural model of \cite{DS/FMU/FEF/022}.
In particular, it separates out the critical requirements
(as regards the $select$ query) on the
SSQL Query Transformation Processor of \cite{DS/FMU/FEF/022} so that they
are completely determined by a model of a ``compiler'' for TSQL which
maps a TSQL query onto the function on tables which it computes.

The purpose of this document is to complete the formal treatment for the
Phase 2 work by further reducing the critical requirements on the SSQL
Query Transformation Processor by placing a bound on the allowed TSQL
queries it produces. This is done using what is in effect a reformulation
of the classification computations which underlie the transformations
defined in \cite{trans} in terms of a relational algebra model of TSQL
execution.


\section{PRELIMINARIES}
The following \Product{} instructions set the context for the proof
tools and set up the new theory $fef032$, with parent the theory
$fef026$ in which the Execution Model is defined.
=SML 
open_theory "fef026";
new_theoryÛ"fef032"İ;
push_pc "hol";
=TEX
\section{DISCUSSION}
The objective of this document is to define a set of operations on the
derived tables of \cite{DS/FMU/FEF/026} in terms
of which it is possible to characterise the allowable results of
compiling the queries produced by the SSQL Transformation processor.
This is intended to give some insight into the intuitions about operations
on tables which motivate the transformations.

The idea is to identify the primitive operations on tables and on the
security information in them which underlie the semantics of SSQL and
its implementation via the transformations. This amounts to something like
an SSQL analogue of the relational algebra in which clearances are
computed along with the required data operations.

The clearance computations are, at least informally, fairly directly
related to the clearance computations which are implicit in the
transformations of \cite{trans}.  The definitions are formally related to the
security policy by using them to characterise a class of table
computations for which the risk inputs are either empty or have a known
form. This is then used to give a sufficient condition for the truth
of the assertion
=INLINEFT
STP  STP_secure_E compile
=TEX
\ which plays an important role in \cite{DS/FMU/FEF/026}.
This sufficient condition can be seen to relate more closely, at least informally,
to the internal details of the transformations than the definition
of $STP\_secure$ itself.

It turns out to be convenient to organise the SSQL constructs into
three levels.

To handle nested selects, we need to pass around a list of derived
tables to be selected from.
The simpler forms of expression are therefore covered by the following
type abbreviation:
=SML
declare_type_abbrev(Û"EXPR"İ, [],
	”	(DerTable LIST ­ DerTableRow ­ (Class ¸ Item))®);
=TEX
We use the following type abbreviation for aggregate expressions.

=SML
declare_type_abbrev(Û"AGGREG_EXPR"İ, [],
	”	(DerTable LIST ­ DerTableRow LIST ­ (Class ¸ Item))®);
=TEX
We use the term {\em table expression} for the various building blocks of the
$SELECT$ query and the following type abbreviation reflects this:
=SML
declare_type_abbrev(Û"TABLE_EXPR"İ, [],
	”	DerTable LIST ­ DerTable®);
=TEX
\section{SIMPLE EXPRESSIONS}\label{SIMPLEEXPRESSIONS}
We view the semantics of most expression forms as functions from table
rows to class-item pairs.  E.g., if a table includes columns called $a$
and $b$, the semantics of $a + b$ will be the function which given a
row in which the values of $a$ and $b$ are $\alpha$ and $\beta$ say,
and the classifications of $a$ and $b$ are $c$ and $d$ say, returns
$(c\,\hbox{lub}\,d, \alpha + \beta)$.

Certain operations such as the set functions take
on a list of rows as their operand.
These are covered in section \ref{AGGREGATEEXPRESSIONS} below.


The particular expression forms which model those of TSQL
are given in sections \ref{DenoteConstant} to \ref{Contents} below.
The classifications follow those assigned in \cite{trans}.
The classification information is taken from $internal\_value\sb{class}$
in \cite{trans} unless otherwise noted below.
The order of the treatment is also taken from $internal\_value\sb{class}$.


=TEX

\subsection{Constant Expression}\label{DenoteConstant}
The function giving constant expressions is parameterised by the classification and value
of the constant.
¹HOLCONST
Ü	ÛDenoteConstantİ	: (Class ¸ Item) ­ EXPR
÷üüüüüüüüüüüüüüüüüü
Üµci ·	DenoteConstant ci = Ìtl r· ci
°

\subsection{Monadic}\label{MonOp}
The monadic forms are parameterised here by the actual item computation
to perform and the expression which computes the operand.

¹HOLCONST
Ü	ÛMonOpİ	: (Item ­ Item) ­ EXPR ­ EXPR
÷üüüüüüüüüüüüüüüüüü
Üµf e·	MonOp f e = Ìtl r· let (c, v) = e tl r in (c, f v)
°
\subsection{Binary}\label{BinOp}
The logical binary operators are treated specially. In particular, iterated
$and$s and $or$s are effectively treated by $simplify\sb{ands}$ and
$simplify\sb{ors}$in \cite{trans} as composite operators
on lists of expressions, for the purpose of computing the classification.
We model this directly here (althought this makes the name a misnomer).
Thus $BinOpAnd$ and $BinOpOr$ below are parameterised by lists of
expresions to compute the operands to be combined.

We use the following to coerce $Item$s into truth values and vice versa:

¹HOLCONST
Ü	ÛItemBoolİ	: Item ­ Bool
÷üüüüüüüüüüüüüüüüüü
Üµv·	ItemBool v = (v = ValuedItemItem(MkValuedItem sterling (BoolVal true)))
°
¹HOLCONST
Ü	ÛBoolItemİ	: Bool ­ Item
÷üüüüüüüüüüüüüüüüüü
Üµv·	BoolItem v = ValuedItemItem(MkValuedItem sterling (BoolVal v))
°
We use the following to compute iterated conjunctions and disjunctions:
¹HOLCONST
Ü	ÛListAndİ	: Bool LIST ­ Bool
÷üüüüüüüüüüüüüüüüüü
Üµb bs·	(ListAnd [] ¤ true)
Ü±	(ListAnd (Cons b bs) ¤ b ± ListAnd bs)
°
¹HOLCONST
Ü	ÛListOrİ	: Bool LIST ­ Bool
÷üüüüüüüüüüüüüüüüüü
Üµb bs·	(ListOr [] ¤ false)
Ü±	(ListOr (Cons b bs) ¤ b ² ListOr bs)
°
Now, we define $BinOpAnd$ which embodies the algorithm of $simplify\sb{ands}$.
As described in \cite{trans}, the idea is that if the expression evaluates
to $true$, then the client knows that all the operands are $true$ and the class
is the l.u.b. of the classes of the operands, whereas if the expression evaluates
to $false$ then the client knows that some operand is $false$ and the class
can be taken to be the g.l.b. of the classes of the operands which are
$false$.
¹HOLCONST
Ü	ÛBinOpAndİ	: EXPR LIST ­ EXPR
÷üüüüüüüüüüüüüüüüüü
Üµel·	BinOpAnd el =
Ü		Ìtl r·	let	cvl = Map (Ìe·e tl r) el
Ü			in let	v = ListAnd(Map (ItemBool o Snd) cvl)
Ü			in let	makecase(c, u) =
Ü				if ItemBool u then lattice_top else c
Ü			in	((if	v
Ü				  then	lubl (Map Fst cvl)
Ü				  else	glbl (Map makecase cvl)),
Ü				BoolItem v)
°
Now $BinOpOr$ which embodies the algorithm of $simplify\sb{ors}$.
This is ``dual'' to $BinOpAnd$: if the expression evaluates
to $false$, then the client knows that all the operands are $false$ and the class
is the l.u.b. of the classes of the operands, whereas if the expression evaluates
to $true$ then the client knows that some operand is $true$ and the class
can be taken to be the g.l.b. of the classes of the operands which are
$true$.
¹HOLCONST
Ü	ÛBinOpOrİ	: EXPR LIST ­ EXPR
÷üüüüüüüüüüüüüüüüüü
Üµel·	BinOpOr el =
Ü		Ìtl r·	let	cvl = Map (Ìe·e tl r) el
Ü			in let	v = ListAnd(Map (ItemBool o Snd) cvl)
Ü			in let	makecase(c, u) =
Ü				if ItemBool u then c else lattice_top
Ü			in	((if	v
Ü				  then	glbl (Map makecase cvl)
Ü				  else	lubl (Map Fst cvl)),
Ü				BoolItem v)
°

\subsection{Triadic}\label{TriOp}

The triadic forms all use an unoptimised treatment of
classifications and are parameterised by the actual item computation
to perform and three expressions giving the operands.

¹HOLCONST
Ü	ÛTriOpİ	: (Item ­ Item ­ Item ­ Item) ­ EXPR ­ EXPR ­ EXPR ­ EXPR
÷üüüüüüüüüüüüüüüüüü
Üµf e1 e2 e3 ·	TriOp f e1 e2 e3 =
Ü		Ìtl r·	let	(c1, v1) = e1 tl r
Ü			in let	(c2, v2) = e2 tl r
Ü			in let	(c3, v3) = e3 tl r
Ü			in	(c1 lub (c2 lub c3), f v1 v2 v3)
°
\subsection{Conversions}\label{Convert}
TBA
\subsection{Sterling}\label{Sterling}
TBA
\subsection{Dinary}\label{Dinary}
TBA
\subsection{Declaration}\label{Declare}
Since we are constructing a model of the semantics of expressions rather
than the syntax, we do not model declarations.

\subsection{Case Expressions}\label{Case}
The class computation for case expressions
is a little complicated. The idea is that evaluation of a case
expression gives some information about all of the test conditions
up to and including the one (if any) corresponding to the branch
which is actually taken; if the client is not cleared to evaluate one of these
test conditions, then the class of the whole expression is
taken to be the class of the first such condition (which ensures that the client
will not be cleared to see the result), otherwise the class of the
whole expression is taken to be the class of the expression in the branch
which is taken. 

The two sorts of case expression are parameterised by the client clearance,
and expressions and lists of pairs of expressions giving the operands.
Lists of pairs are used rather than pairs of lists as in \cite{trans}
to avoid the anomalous case where the two lists have different lengths
(which is prohibited by the syntactic rules for TSQL in the context of \cite{trans}).

The following two auxiliary functions are used to compute the class for
the $caseVal$ form. They correspond to the calculations performed by
the queries $check\_list$ and $check\_test$ defined in
$internal\_value\sb{class}$ in \cite{trans} (with the work performed
by the $limb$ functions expanded out).

¹HOLCONST
Ü	ÛCheckListİ	: Class ­ Item ­
Ü			((Class ¸ Item) ¸ (Class ¸ Item)) LIST
Ü			­ Class ­ Class 
÷üüüüüüüüüüüüüüüüüü
Üµcc ti cv cvs elsec ·
Ü	CheckList cc ti [] elsec = elsec
Ü±	CheckList cc ti (Cons cv cvs) elsec =
Ü	let ((cec, cei), (vec, vei)) = cv
Ü	in	if	³cc dom cec
Ü		then	cec
Ü		else if ti = cei
Ü		then	vec
Ü		else	CheckList cc ti cvs elsec	
°


¹HOLCONST
Ü	ÛCheckTestİ	: Class ­ (Class ¸ Item) ­
Ü			((Class ¸ Item) ¸ (Class ¸ Item)) LIST
Ü			­ Class ­ Class 
÷üüüüüüüüüüüüüüüüüü
Üµcc ti tc cvs elsec ·
Ü	CheckTest cc (tc, ti) cvs elsec =
Ü	if	cc dom tc
Ü	then	CheckList cc ti cvs elsec
Ü	else	tc
°
The following function computes the value returned by the $caseVal$ form
of case expression.
¹HOLCONST
Ü	ÛCaseValValueİ	: Item ­ ((Class ¸ Item) ¸ (Class ¸ Item)) LIST
Ü			­ Item ­ Item 
÷üüüüüüüüüüüüüüüüüü
Üµti cv cvs elsev ·
Ü	CaseValValue ti [] elsev = elsev
Ü±	CaseValValue ti (Cons cv cvs) elsev =
Ü	let ((cec, cei), (vec, vei)) = cv
Ü	in	if	ti = cei
Ü		then	vei
Ü		else	CaseValValue ti cvs elsev	
°

¹HOLCONST
Ü	ÛCaseValİ	: Class ­ EXPR ­ (EXPR ¸ EXPR) LIST ­ EXPR ­ EXPR 
÷üüüüüüüüüüüüüüüüüü
Üµcc tst casevals elseval ·
Ü	CaseVal cc tst casevals elseval =
Ü	Ìtl r·
Ü	let	(tc, ti) = tst tl r
Ü	in let	cvs = Map (Ì(c, v)· (c tl r, v tl r)) casevals
Ü	in let	(ec, ei) = elseval tl r
Ü	in let	c = CheckTest cc (tc, ti) cvs ec
Ü	in let	v = CaseValValue ti cvs ei
Ü	in	(c, v)
°


The following auxiliary functions is used to compute the class for
the $case$ form. It corresponds to the calculations performed by
the query $c$ $internal\_value\sb{class}$ in \cite{trans}
(with the work performed by the $limb$ functions expanded out).

¹HOLCONST
Ü	ÛCaseCİ	: Class ­
Ü			((Class ¸ Item) ¸ (Class ¸ Item)) LIST
Ü			­ Class ­ Class 
÷üüüüüüüüüüüüüüüüüü
Üµcc cv cvs elsec ·
Ü	CaseC cc [] elsec = elsec
Ü±	CaseC cc (Cons cv cvs) elsec =
Ü	let ((cec, cei), (vec, vei)) = cv
Ü	in	if	³cc dom cec
Ü		then	cec
Ü		else if ItemBool cei
Ü		then	vec
Ü		else	CaseC cc cvs elsec	
°

The following function computes the value returned by the $case$ form
of case expression.
¹HOLCONST
Ü	ÛCaseValueİ	: ((Class ¸ Item) ¸ (Class ¸ Item)) LIST
Ü			­ Item ­ Item 
÷üüüüüüüüüüüüüüüüüü
Üµcv cvs elsev ·
Ü	CaseValue [] elsev = elsev
Ü±	CaseValue (Cons cv cvs) elsev =
Ü	let ((cec, cei), (vec, vei)) = cv
Ü	in	if	ItemBool cei
Ü		then	vei
Ü		else	CaseValue cvs elsev	
°

¹HOLCONST
Ü	ÛCaseİ	: Class ­ (EXPR ¸ EXPR) LIST ­ EXPR ­ EXPR 
÷üüüüüüüüüüüüüüüüüü
Üµcc casevals elseval ·
Ü	Case cc casevals elseval =
Ü	Ìtl r·
Ü	let	cvs = Map (Ì(c, v)· (c tl r, v tl r)) casevals
Ü	in let	(ec, ei) = elseval tl r
Ü	in let	c = CaseC cc cvs ec
Ü	in let	v = CaseValue cvs ei
Ü	in	(c, v)
°
\subsection{$AllBinOp$}\label{AllBinOp}
TBA
\subsection{$SomeBinOp$}\label{SomeBinOp}
TBA
\subsection{$ExistsTuples$}\label{ExistsTuples}
This construct is parameterised by a table expression to compute
the operand. The classification below is intended to be in the spirit
of $tuple\_list\sb{max\_row\_class}$ from \cite{trans}.
¹HOLCONST
Ü	ÛExistsTuplesİ	: TABLE_EXPR ­ EXPR
÷üüüüüüüüüüüüüüüüüü
Üµte ·	ExistsTuples te =
Ü	Ìtl r·
Ü	let	rl = DT_rows (te tl)
Ü	in	(lubl (Map DTR_row rl), BoolItem (³rl = []))
°
\subsection{$SingleValue$}\label{SingleValue}
This construct is parameterised by a table expression to compute
the operand. The classification below is probably more generous than that in
$internal\_value\sb{class}$ from \cite{trans}.

¹HOLCONST
Ü	ÛSingleValueİ	: TABLE_EXPR ­ EXPR
÷üüüüüüüüüüüüüüüüüü
Üµte ·	SingleValue te =
Ü	Ìtl r·
Ü	let	rl = DT_rows (te tl)
Ü	in let	cil = DTR_cols (Hd rl)
Ü	in	if	Length rl = 1 ± Length cil = 1
Ü		then	Hd cil
Ü		else	Arbitrary
°

\subsection{Contents}\label{Contents}
Since we have not upgraded to the new SSQL specification we only supply
one contents operator rather than separate sterling and dinary ones.

The contents operator is parameterised by a number telling us which
column to select. We must return a fixed value if this is out of range
(a situation which never arises in the actual SWORD implementation
since the column is identified by name rather than number and it is
known at compile/transformation time whether or not the name is
valid).

¹HOLCONST
Ü	ÛContentsİ	: î ­ EXPR
÷üüüüüüüüüüüüüüüüüü
Üµi ·	Contents i =
Ü	Ìtl r·
Ü	if	i < Length (DTR_cols r)
Ü	then	Nth (DTR_cols r) i
Ü	else	Arbitrary
°
\subsection{$Classification$}\label{Classification}
This construct is parameterised by a number telling
us which classification column. The classification below is as in
$internal\_value\sb{class}$ from \cite{trans}.

¹HOLCONST
Ü	ÛClassItemİ	: Class ­ Item
÷üüüüüüüüüüüüüüüüüü
Üµv·	ClassItem v = ValuedItemItem(MkValuedItem sterling (ClassVal v))
°

¹HOLCONST
Ü	ÛClassificationİ	: î ­ EXPR
÷üüüüüüüüüüüüüüüüüü
Üµi ·	Classification i =
Ü	Ìtl r·
Ü	if	i < Length (DTR_cols r)
Ü	then	(DTR_row r, ClassItem(Fst (Nth (DTR_cols r) i)))
Ü	else	Arbitrary
°
\subsection{$RowExistence$ Etc.}\label{RowExistence}
TBA
\section{AGGREGATE EXPRESSIONS}\label{AGGREGATEEXPRESSIONS}
The aggregate expressions such as the set functions
have a list of rows as one of their operands. This list will either
be the complete contents of a table or a group of rows selected from
a table. As with simple expressions we must pass in the list of derived
tables for use in nested selects.

\subsection{Set Functions}\label{SetFunctions}
The logical set functions are treated in a similar fashion to
the logical binary operators.

¹HOLCONST
Ü	ÛSetFuncAllAndİ		: EXPR ­ AGGREG_EXPR
÷üüüüüüüüüüüüüüüüüü
Üµe ·	SetFuncAllAnd e =
Ü	Ìtl rl·
Ü	let	cil = Map (e tl) rl
Ü	in let	(cl, il) = Split cil
Ü	in let	ri = ListAnd (Map ItemBool il)
Ü	in let	makecase (c, u) = if ItemBool u then lattice_top else c
Ü	in	if	ri
Ü		then	(lubl cl, BoolItem ri)
Ü		else	(glbl (Map makecase cil), BoolItem ri)
°

¹HOLCONST
Ü	ÛSetFuncAllOrİ		: EXPR ­ AGGREG_EXPR
÷üüüüüüüüüüüüüüüüüü
Üµe ·	SetFuncAllOr e =
Ü	Ìtl rl·
Ü	let	cil = Map (e tl) rl
Ü	in let	(cl, il) = Split cil
Ü	in let	ri = ListOr (Map ItemBool il)
Ü	in let	makecase (c, u) = if ItemBool u then c else lattice_top
Ü	in	if	ri
Ü		then	(glbl (Map makecase cil), BoolItem ri)
Ü		else	(lubl cl, BoolItem ri)
°


The general set functions are parameterised by the operation on
lists or sets of item pairs to be computed and by the expression to
be computed for each row.
¹HOLCONST
Ü	ÛSetFuncAllİ		: (Item LIST ­ Item) ­ EXPR ­ AGGREG_EXPR
÷üüüüüüüüüüüüüüüüüü
Üµf e ·	SetFuncAll f e =
Ü	Ìtl rl·
Ü	let	(cl, il) = Split (Map (e tl) rl)
Ü	in	(lubl cl, f il)
°
¹HOLCONST
Ü	ÛSetFuncDistinctİ	: (Item SET ­ Item) ­ EXPR ­ AGGREG_EXPR
÷üüüüüüüüüüüüüüüüüü
Üµf e ·	SetFuncDistinct f e =
Ü	Ìtl rl·
Ü	let	(cl, il) = Split (Map (e tl) rl)
Ü	in	(lubl cl, f (Elems il))
°

The ``distinct'' option of the logical set functions would appear
to be semantically identical with the ``all'' option and so has
not been given here.
\subsection{Count Functions}\label{Count}
For simplicity, we ignore the numeric type prescription which is
associated with the count functions.

Examination of \cite{trans} reveals that the first
two count functions may be treated
as instances of the general set functions for present purposes, although to
do this we need the function which converts an HOL natural number into
a TSQL item, the precise details being unimportant:


¹HOLCONST
Ü	ÛNatItemİ	: î ­ Item
÷üüüüüüüüüüüüüüüüüü
Ü	true
°

¹HOLCONST
Ü	ÛCountNonNullİ	: EXPR ­ AGGREG_EXPR
÷üüüüüüüüüüüüüüüüüü
Üµe ·	CountNonNull e =
Ü	let	counter il = NatItem(Length (il ù {i | isValuedItem i}))
Ü	in	SetFuncAll counter e
°

¹HOLCONST
Ü	ÛCountDistinctİ	: EXPR ­ AGGREG_EXPR
÷üüüüüüüüüüüüüüüüüü
Üµe ·	CountDistinct e =
Ü	let	counter is = NatItem(Size (is ¡ {i | isValuedItem i}))
Ü	in	SetFuncDistinct counter e
°

The $count\_all$ function uses a somewhat different classification
computation taking into account row existence classes.

¹HOLCONST
Ü	ÛCountAllİ	: AGGREG_EXPR
÷üüüüüüüüüüüüüüüüüü
Ü	CountAll =
Ü	Ìtl rl·
Ü	let	cl = Map DTR_row rl
Ü	in	(lubl cl, NatItem(Length rl))
°

We also require the following additional aggregate expression form
which is not contained in SSQL. It is how we think of the expressions
which appear in $HAVING$ clauses which take the contents of the columns
which appear in the $GROUPBY$ clause. If the (item part of the) expression
parameter gives the same value in each row then that value is returned
classified with the l.u.b. of the classes returned for the rows; otherwise,
a fixed arbitrary value is returned (modelling a compile/transformation-time error). 

¹HOLCONST
Ü	ÛCommonValueİ	: EXPR ­ AGGREG_EXPR
÷üüüüüüüüüüüüüüüüüü
Üµe ·	CommonValue e =
Ü	Ìtl rl·
Ü	let	(cl, il) = Split (Map (e tl) rl)
Ü	in	if	Size (Elems il) = 1
Ü		then	(lubl cl, Hd il)
Ü		else	Arbitrary
°

\section{SELECT QUERY}\label{SELECT}
To simplify matters, we will consider the $SELECT$ query to be broken
down into more primitive operations. In this section,
we give the top-level building blocks.
These are parameterised by the lower-level constructs (values and the like)
which are discussed in sections \ref{SIMPLEEXPRESSIONS} and
\ref{AGGREGATEEXPRESSIONS} below.
=TEX

In each case, we identify the origin in the specification of
the transformations of the computation of the relevant classifications.

\subsection{Join}
The TSQL join operation is just cartesian product. The row class
and where clause class in each tuple in the product is the least upper
bound of the corresponding classes in each component tuple which contributes to
that tuple. The joined table has no name and the maximum
row class is the least upper bound of those in the component tables.


Cf. $tuple\_list\sb{make\_outer}$ in \cite{trans}.


¹HOLCONST
Ü	ÛJoinSpecsİ : DerTableSpec LIST ­ DerTableSpec
÷üüüüüüüüüüüüüüüüüü
Ü	µsl·
Ü	JoinSpecs sl =
Ü	let	n = []
Ü	and	mr = lubl (Map DTS_maxRow sl)
Ü	and	csl = Flat (Map DTS_colSpecs sl)
Ü	in	MkDerTableSpec n mr csl
°
¹HOLCONST
Ü	ÛJoinRowsİ : DerTableRow ­ DerTableRow LIST ­ DerTableRow LIST
÷üüüüüüüüüüüüüüüüüü
Ü	µr rs·
Ü	JoinRows r rs =
Ü	let	join2 rr = (
Ü			MkDerTableRow
Ü			(DTR_where r lub DTR_where rr)
Ü			(DTR_row r lub DTR_row rr)
Ü			(DTR_cols r ë DTR_cols rr))
Ü	in	Map join2 rs
°
¹HOLCONST
Ü	ÛJoinDataİ : DerTableRow LIST LIST ­ DerTableRow LIST
÷üüüüüüüüüüüüüüüüüü
Ü	JoinData [] = []
Ü±	µtab rest·
Ü	JoinData (Cons tab rest) =
Ü	if	rest = []
Ü	then	tab
Ü	else	let	jrest = JoinData rest
Ü		in let	join_blk r = JoinRows r jrest
Ü		in	Flat (Map join_blk tab)
°
The join operation itself is parameterised by the table expressions
which compute the tables to be joined.
¹HOLCONST
Ü	ÛJoinİ : TABLE_EXPR LIST ­ TABLE_EXPR
÷üüüüüüüüüüüüüüüüüü
Üµtel·	Join tel =
Ü	Ìtl·
Ü	let	jl = Map (Ìte· te tl) tel
Ü	in	MkDerTable
Ü		(JoinSpecs (Map DT_spec jl))
Ü		(JoinData (Map DT_rows jl))
°
\subsection{Projection}
The projection operation is parameterised by a list
of functions which compute class-item pairs from a row of a table,
together with column specifications to use for the computed fields.
(Note this is a more general than projection of a single field to form
a one-column table but includes that as a special case).

In the SWORD implementation the column specifications are effectively
computed during the transformations as required. In the formalisation
here, the column specifications are not in fact significant, but have been
left in to allow for possible further development to model some of
the optimisations performed by the transformations.

The operation acts on a table computed by a table expression given as
a parameter. The parameter expressions are expected to assign
appropriate classifications to the resulting fields.
The computed table is anonymous.

Cf. $tuple\_list\sb{make\_outer}$ in \cite{trans}.

¹HOLCONST
Ü	ÛProjectSpecİ	: DerColSpec LIST
Ü			 ­ DerTableSpec
Ü			 ­ DerTableSpec
÷üüüüüüüüüüüüüüüüüü
Üµsl s·	ProjectSpec sl s =
Ü	MkDerTableSpec [] (DTS_maxRow s) sl
°
¹HOLCONST
Ü	ÛProjectDataİ	: EXPR LIST
Ü			 ­ DerTable LIST
Ü			 ­ DerTableRow LIST
Ü			 ­ DerTableRow LIST
÷üüüüüüüüüüüüüüüüüü
Ü	µel tl rl·
Ü	ProjectData el tl rl =
Ü	let	h r = MkDerTableRow (DTR_where r) (DTR_row r) (Map (Ìe·e tl r) el)
Ü	in	Map h rl
°
¹HOLCONST
Ü	ÛProjectİ : (EXPR  ¸ DerColSpec) LIST ­ TABLE_EXPR ­ TABLE_EXPR
÷üüüüüüüüüüüüüüüüüü
Üµesl te·
Ü	Project esl te =
Ü	Ìtl·
Ü	let	p = te tl
Ü	in	MkDerTable
Ü		(ProjectSpec (Map Snd esl) (DT_spec p))
Ü		(ProjectData (Map Fst esl) tl (DT_rows p))
°
\subsection{$WHERE$}
The $WHERE$ operation is parameterised by a
function to compute a class and a truth value from a row of a table.
The operation acts on the first table in the argument list. 
The argument expression is expected to give an appropriate classification
for the where clause class. The specification of the computed table is
the same as the original.

Cf. $tuple\_list\sb{make\_outer}$ in \cite{trans}.

=TEX
¹HOLCONST
Ü	ÛWhereDataİ	: EXPR
Ü			 ­ DerTable LIST
Ü			 ­ DerTableRow LIST
Ü			 ­ DerTableRow LIST
÷üüüüüüüüüüüüüüüüüü
Ü	µe tl rl·
Ü	WhereData e tl rl =
Ü	let	w r = (DTR_where r lub Fst (e tl r))
Ü	in let	h r = (ItemBool(Snd (e tl r)),
Ü				MkDerTableRow (w r) (DTR_row r) (DTR_cols r))
Ü	in	Map Snd (Map h rl ù {(t, r) | t})
°
¹HOLCONST
Ü	ÛWhereİ : EXPR ­ TABLE_EXPR ­ TABLE_EXPR
÷üüüüüüüüüüüüüüüüüü
Üµe te·
Ü	Where e te =
Ü	Ìtl·
Ü	let	tab = te tl
Ü	in	MkDerTable
Ü		(DT_spec tab)
Ü		(WhereData e tl (DT_rows tab))
°

\subsection{$GROUPBY$/$HAVING$}
The $GROUPBY$ and $HAVING$ operations are most naturally treated together.
The combined operation is parameterised by four things in addition
to the parameter giving the table to be grouped:
{\em (i)}, a list of aggregate expressions, $eval$, used to compute a row
in the result table from each group;
{\em (ii)}, a list of numbers, $inds$, giving the column indices by which
the table is to be grouped;
{\em (iii)}, an aggregate expression, $hasit$,
to compute a truth value (the $HAVING$ condition) from a list of rows;
and, {\em (iv)}, a table specification, $ts$,
the table specification for the result table.


Cf. $tuple\_list\sb{make\_outer}$ in \cite{trans}.

=SML
declare_type_abbrev(Û"GROUPBY_PAR"İ, [],
	”	(DerTableRow ­ DerTableRow)
	¸	(DerTableRow LIST ­ DerTableRow)
	¸	(DerTableRow LIST ­ BOOL)
	¸	DerTableSpec®);
=TEX
To define the grouping part of the operation, we need some list processing
preliminaries. 
¹HOLCONST
Ü	ÛPutInGroupİ :  ('a ­ 'b) ­ 'a ­ ('a LIST) LIST ­ ('a LIST) LIST
÷üüüüüüüüüüüüüüüüüü
Üµgpby x gp gps·
Ü	PutInGroup gpby x [] = [[x]]
Ü±	PutInGroup gpby x (Cons gp gps) =
Ü	if	gpby x = gpby (Hd gp)
Ü	then	Cons (Cons x gp) gps
Ü	else	Cons gp (PutInGroup gpby x gps)
°

¹HOLCONST
Ü	ÛMakeGroupsİ	: ('a ­ 'b)
Ü			 ­ 'a LIST
Ü			 ­ ('a LIST) LIST
÷üüüüüüüüüüüüüüüüüü
Üµgpby x xs·
Ü	MakeGroups gpby [] = []
Ü±	MakeGroups gpby (Cons x xs) = PutInGroup gpby x (MakeGroups gpby xs)
°
The following function is used to supply the $gpby$ parameter to the above.
It ensures that indices which are out of range are mapped to a fixed arbitrary
value to handle securely an error condition which is detected at
compile/transformation time in the SWORD implementation (where names
rather than numbers are used for the columns and the scope rules detect
invalid names).
¹HOLCONST
Ü	ÛListNthİ	: î LIST ­ 'a LIST ­ 'a LIST
÷üüüüüüüüüüüüüüüüüü
Üµn nl list·
Ü	ListNth [] list = []
Ü±	ListNth (Cons n nl) list =
Ü	Cons
Ü	(if	n < Length list
Ü	then	Nth list n
Ü	else	Arbitrary)
Ü	(ListNth nl list)
°
The classification computations below are suggestions/guesses on the
basis of current information.
¹HOLCONST
Ü	ÛGroupByDataİ	: DerTable LIST
Ü			 ­ AGGREG_EXPR LIST
Ü			 ­ î LIST
Ü			 ­ AGGREG_EXPR
Ü			 ­ DerTableRow LIST
Ü			 ­ DerTableRow LIST
÷üüüüüüüüüüüüüüüüüü
Üµtl eval inds hasit rl·
Ü	GroupByData tl eval inds hasit rl =
Ü	let	gpby = (ListNth inds o DTR_cols)
Ü	in let	gps = MakeGroups gpby rl
Ü	in let	where_class gp = lubl (Map DTR_where gp)
Ü	in let	row_class gp = lubl (Map DTR_row gp)
Ü	in let	col_data gp  = Map (Ìae·ae tl gp) eval
Ü	in	Map
Ü		(Ìgp·MkDerTableRow (where_class gp) (row_class gp) (col_data gp))
Ü		(gps ù {r | ItemBool(Snd (hasit tl r))})
°

¹HOLCONST
Ü	ÛGroupByİ	: AGGREG_EXPR LIST
Ü			 ­ î LIST
Ü			 ­ AGGREG_EXPR
Ü			 ­ DerTableSpec
Ü			 ­ TABLE_EXPR
Ü			 ­ TABLE_EXPR
÷üüüüüüüüüüüüüüüüüü
Üµeval inds hasit ts te·
Ü	GroupBy eval inds hasit ts te =
Ü	Ìtl·
Ü	let	tab = te tl
Ü	in let	newrl = GroupByData tl eval inds hasit (DT_rows tab)
Ü	in	MkDerTable ts newrl
°

\subsection{$TableContents$}\label{TableContents}
This is parameterised by a number giving the index into the list of tables:

¹HOLCONST
Ü	ÛTableContentsİ	: î ­ TABLE_EXPR
÷üüüüüüüüüüüüüüüüüü
Üµi·
Ü	TableContents i =
Ü	Ìtl·
Ü	if	i < Length tl
Ü	then	Nth tl i
Ü	else	Arbitrary
°

\subsection{$DistinctTuples$}\label{DistinctTuples}
This is parameterised by a table expression giving the table whose duplicate
rows are to be removed. We need a list processing auxiliary:



¹HOLCONST
Ü	ÛRemoveDuplicatesİ	: 'a LIST ­ 'a LIST
÷üüüüüüüüüüüüüüüüüü
Üµx xs·
Ü	RemoveDuplicates [] = []
Ü±	RemoveDuplicates (Cons x xs)
Ü	= Cons x (RemoveDuplicates xs ù {y | ³y = x})
°

¹HOLCONST
Ü	ÛDistinctTuplesİ	: TABLE_EXPR ­ TABLE_EXPR
÷üüüüüüüüüüüüüüüüüü
Üµte·
Ü	DistinctTuples te =
Ü	Ìtl·
Ü	let	tab = te tl
Ü	in let	ts = DT_spec tab
Ü	in let	rl = RemoveDuplicates (DT_rows tab)
Ü	in	MkDerTable ts rl
°



\section{CLOSING DOWN}
The following \Product{} instruction restores the previous proof context.
=SML
pop_pc();
=TEX

=IGN
output_theory{theory = "fef026",out_file = "fef026th.doc"};
output_theory{theory = "fef032",out_file = "fef032th.doc"};
=TEX

\newpage
\HOLindexOff
\ftlinepenalty=9999
\input{fef032th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex
=TEX
\end{document}
=IGN



The set of computations on tables which are allowed to be produced
when queries generates by the SQL Transformation Processor are
compiled will essentially be defined
by taking the closure under composition
of a finite set of particular
operations adequate to represent the primitive constructs of TSQL.
The closure is formed using the following function:

 ¹HOLCONST
 Ü	ÛCompClosureİ	:	('a LIST ­ 'a) SET
 Ü			­	('a LIST ­ 'a) SET
 ÷üüüüüüüüüüüüüüüüüü
 Ü	µfs·	CompClosure fs
 Ü	=	¥
 Ü		{	a
 Ü		|	fs € a
 Ü		±	µh gl il·
 Ü				h  a ± Elems gl € a ± Elems il € 1 .. Length gl
 Ü			´	let	irl tl = Map (Ìg·g tl) gl
 Ü				in let	comp tl = h (Map (Nth(irl tl)) il)
 Ü				in	comp  a}
 °
That is to say, the closure under composition of a set of functions, $fs$,
is the smallest set of functions which contains $fs$ and is closed
under the operation which given a function $h$, a list of functions $gl$,
and a list of numbers $il$, returns the function which first applies
each function in $gl$ to produce a list of intermediate results, uses
$il$ as indices to select some or all of the intermediate results in some
order and then applies $h$ to the result. For example, if
=INLINEFT
gl = [g‰1; g‰2; g‰3]
=TEX
\ and
=INLINEFT
il = [3; 1; 1; 2]
=TEX
, the composite function is
=INLINEFT
Ì tl· h [g‰3 tl; g‰1 tl; g‰1 tl; g‰2 tl]
=TEX
.
=IGN
PC_C1 "hol1" rewrite_conv(map get_spec[¬Map®, ¬Nth®, ¬Let®])
¬let	irl tl = Map (Ìg·g tl) [g‰1; g‰2; g‰3]
in let	comp tl = h (Map (Nth(irl tl)) [3; 1; 1; 2])
in	comp®;
=TEX


As with operations on tables, we define the {\em risk inputs} of
an expression $e$ at a class $c$ to be the set inputs for which $e$
reveals information which should not be visible at class $c$.

 ¹HOLCONST
 Ü	ÛExpRiskInputsİ	: Class ­ EXPR ­ DerTableRow ğ
 ÷üüüüüüüüüüüüüüüüüü
 Üµcc e ·	ExpRiskInputs cc e
 Ü	=	{	r
 Ü		|	¶r‰0 ·
 Ü			HideDerTableRow cc r‰0 = HideDerTableRow cc r
 Ü		±	let	(c, i) = e r
 Ü			in let	(c‰0, i‰0) = e r‰0
 Ü			in	³i = i‰0
 Ü			±	³(c dominates cc ± c‰0 dom cc)}
 °


=IGN

val conv = PC_C1 "hol2" rewrite_conv(map get_spec[¬$ù®, ¬RemoveDuplicates®]);


conv ¬RemoveDuplicates []®;
conv ¬RemoveDuplicates [x]®;
conv ¬RemoveDuplicates [1;2;1;2;1]®;
conv ¬RemoveDuplicates [1;3;2;1;2;3;1]®;
