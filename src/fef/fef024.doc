=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{A HOL Specification of the Output Filter}  %% Mandatory field
\TPPref{DS/FMU/FEF/024}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{A specification of the SWORD output filter in \ProductHOL{} for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}})]  Assumed `internalError' cannot happen.
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document gives a formal specification in \ProductHOL{} of the SWORD front end output filter of \cite{output}.

\subsection{Introduction}
\section{PRELIMINARIES}
=SML
open_theory"fef015";
new_theory"fef024";
=TEX


\section{FILTER FUNCTIONS FOR SELECT QUERIES}
The type of values is left as generic. The function 
$class\_of\_value$ returns the classification of a  value that is to
 be treated as a classification.
¹HOLCONST
Ü	Ûclass_of_valueÝ: 'Value  ­ Class
÷üüüüüüüüüüüüüü
Ü	T
°

The user's clearance is supplied as parameter to the following functions.


The function $filter\_where\_row$ takes a non-empty  list of values whose 
 first element is the classification 
of the where clause, removes the classification 
of the where clause from the head of the list and also 
returns a boolean which is $true$ if the user is not cleared to see the where clause. 

We have chosen to model the filter in such a way that it only receives `possible' inputs i.e.
 an $internalError$ cannot be raised.

¹HOLCONST
Ü	Ûfilter_where_rowÝ: 'Value LIST ¸ Class  ­ 'Value LIST  ¸ BOOL
÷üüüüüüüüüüüüüü
Ü	µ v vs uc ·
Ü	filter_where_row 	(Cons v vs,uc) = (vs, ³(uc dominates (class_of_value v)))
°
The function $filter\_where$ discards rows  where the user is not cleared to see the where clause and also returns a boolean $true$ if any rows have been discarded. 

¹HOLCONST
Ü	Ûfilter_whereÝ: 'Value LIST LIST ¸ Class  
Ü					­ 'Value LIST LIST ¸ BOOL
÷üüüüüüüüüüüüüü
Ü	µ vs vss uc ·
Ü	filter_where ([],uc) = ([],F)
Ü±	filter_where 	(Cons vs vss,uc) = 	
Ü		let (fvs,msg) = filter_where_row(vs,uc)
Ü		in 
Ü		let (fvss,msgs) = filter_where(vss,uc)
Ü		in 	if msg then (fvss,T)
Ü			else (Cons fvs fvss,msgs)
°
If the user is not cleared to see the value in a particular field, the string $not\_cleared$ is returned. We have modelled $filter\_cols$ on the assumption that  the input lists of value and `class' pair and boolean 
are the same length.
¹HOLCONST
Ü	Ûfilter_colsÝ: Class ­ (('Value ¸ 'Value) LIST ¸ BOOL LIST)  
Ü					­ ('Value + STRING) LIST
÷üüüüüüüüüüüüüü
Ü	µ vc b vcs bs uc ·
Ü	filter_cols uc ([],[]) = []
Ü±	(filter_cols uc (Cons vc vcs,Cons b bs) = 
Ü		if  b then 
Ü			(let fv = 	if uc dominates class_of_value (Snd vc)
Ü					then giveVal (Fst vc)
Ü					else giveError"not_cleared"
Ü			in 	Cons fv (filter_cols uc (vcs,bs)))
Ü		else	Cons(giveVal (Fst vc))(filter_cols uc (vcs,bs)))
°

The boolean parameter to the function $filter\_select$ 
 is $true$ 
if the lists of values contain the class of the where clause 
as first elements. The boolean list parameter provides 
information as to whether it is necessary to check if the 
user's clearance dominates the classification of the value
selected. $filter\_select$ returns the filtered value 
together with a boolean which determine whether or not the 
$mayNotBeComplete$ 
message should be issued.
¹HOLCONST
Ü	Ûfilter_selectÝ: (BOOL ¸ BOOL LIST ¸ ('Value  ¸ 'Value) LIST LIST ¸ Class)
Ü			  ­ ('Value + STRING) LIST LIST ¸ BOOL
÷üüüüüüüüüüüüüü
Ü	µ b cls vcss uc ·
Ü	filter_select (b,cls ,vcss ,uc) = 
Ü	if b then
Ü		let (fvcss,nc) =  filter_where(vcss,uc)
Ü		in 
Ü		(Map (filter_cols uc)(Combine fvcss (seq (# fvcss) cls)),nc)
Ü	else  
Ü		(Map (filter_cols uc)(Combine vcss (seq (# vcss) cls)),F)
°


\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}

