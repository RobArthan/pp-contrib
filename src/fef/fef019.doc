=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Specification of Query Transformations in SML (I)}  %% Mandatory field
\TPPref{DS/FMU/FEF/019}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{Preliminaries to a Standard ML specification of the SSQL Query Transformations  for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}})]  SSQL and TSQL specs separated from transformations.
\end{description}

\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document gives  specifications in Standard ML (\cite{milner90}, \cite{paulson91}) of the SSQL and TSQL abstract syntax  and preliminary specifications from \cite{trans} to support a formal specification in Standard ML of the SSQL query transformations of \cite{trans}. 

It constitutes part of
 deliverable D8 of work package 3, as given
in the Proposal for Phase~2, \cite{DS/FMU/FEF/018}.

\subsection{Introduction}
We proposed in \cite{DS/FMU/FEF/018} to formalise the 
SSQL query transformations of \cite{trans} in Standard ML. 
Here we provide Standard ML specifications of the SSQL 
and TSQL datatypes together with specifications of the transformation notation,  
generic functions, primitive routines, transformation types 
and symbol table from \cite{trans}. Standard ML specifications of the 
transformations may be found in \cite{DS/FMU/FEF/020}.

In order to avoid overloading of Standard ML identifiers, 
subscripts have been used 
to distinguish between constructors of SSQL types and TSQL 
types. Subscripts or abbreviations have also been used in the case where 
an identifier used in \cite{trans} is a reserved word in Standard ML (e.g. $val$).


\section{UNIVERSAL TYPES} \label{UNI}
We will use SML type $int$, $bool$, $unit$, $list$ and $string$ where appropriate. At this stage, the rest of the types are 
defined each with a single constructor.
=SML
datatype ÛFixedÝ = mk_fixed;
datatype ÛFloatingÝ = mk_floating;
datatype ÛEnumÝ = mk_enum;
datatype ÛTimeÝ = mk_time;
datatype ÛIntervalÝ = mk_interval;
datatype ÛClassÝ = mk_class;
datatype ÛCodeÝ = mk_code;
=TEX
We define a datatype $Op$, rather than use type $Integer$.
=SML
datatype ÛOpÝ =	  not_op
			| definitely_op
			| possibly_op
			| minus_op
			| ord_op
			| char_op
			| upper_op
			| lower_op
			| plus_op
			| minusd_op
			| times_op
			| divide_op
			| concat_op
			| and_op
			| or_op
			| less_than_op
			| less_or_equal_op
			| greater_or_equal_op
			| greater_than_op
			| equal_op
			| not_equal_op
			| lub_op
			| glb_op
			| dom_op
			| dom_by_op
			| liked_op
			| maximum_op
			| minimum_op
			| between_op
			| liket_op;
=TEX
\section{SSQL ABSTRACT SYNTAX}
\subsection{Sorts}
=SML
datatype ÛCol_specèssqlêÝ =	  denote_col_spec‰s of string
				| absolute_col_spec‰s of string list * string * string
				| default_col_spec‰s of int * string list * string * string;


datatype ÛTable_specèssqlêÝ =	  absolute_table_spec‰s of string list * string
				| default_table_spec‰s of int * string list * string;
=SML
datatype ÛTypeèssqlêÝ =	  monolean_type‰s 
			| boolean_type‰s
			| string_type‰s of int * int
			| fixed_type‰s of int * int
			| floating_type‰s of int * int * int
			| enum_type‰s of int * Table_specèssqlê
			| time_type‰s of string
			| interval_type‰s of string
			| class_type‰s
			| code_type‰s
			| any_type‰s;
=TEX		
=SML
datatype ÛClauseèssqlêÝ =	  where_clause‰s 
				| group_by_clause‰s
				| having_clause‰s
				| set_clause‰s
				| select_clause‰s
				| constraint_clause‰s;
=TEX
=SML
datatype ÛConstant_valueèssqlêÝ =	  denote_null‰s 
					| denote_void‰s
					| denote_true‰s
					| denote_false‰s
					| denote_string‰s of string * Typeèssqlê
					| denote_fixed‰s of Fixed * Typeèssqlê
					| denote_floating‰s of Floating * Typeèssqlê			
					| denote_enum‰s of Enum * Typeèssqlê			
					| denote_time‰s of Time * Typeèssqlê			
					| denote_interval‰s of Interval * Typeèssqlê			
					| denote_class‰s of Class
					| denote_code‰s of Code;
=TEX
=SML
datatype ÛValueèssqlêÝ =	  denote_constant‰s of Constant_valueèssqlê
			| monop‰s of Op * Valueèssqlê
			| binop‰s of Op * (Valueèssqlê * Valueèssqlê)
			| triop‰s of Op * (Valueèssqlê * Valueèssqlê * Valueèssqlê)
			| convert‰s of Valueèssqlê * Typeèssqlê
			| convert_domain‰s of Valueèssqlê * Table_specèssqlê * Typeèssqlê
			| make_sterling‰s of Valueèssqlê
			| make_dinary‰s of Valueèssqlê
			| declare‰s of string * (Valueèssqlê * Valueèssqlê)
			| caseVal‰s of Valueèssqlê * Valueèssqlê list * Valueèssqlê list * Valueèssqlê
			| case‰s of Valueèssqlê list * Valueèssqlê list * Valueèssqlê
			| set_func_all‰s of Op * Valueèssqlê
			| set_func_distinct‰s of Op * Valueèssqlê
			| count_non_null‰s of Valueèssqlê * Typeèssqlê
			| count_distinct‰s of Valueèssqlê * Typeèssqlê
			| count_all‰s of Typeèssqlê
			| all_binop‰s of Op * (Valueèssqlê * Tuple_listèssqlê)
			| some_binop‰s of Op * (Valueèssqlê * Tuple_listèssqlê)
			| all_binop_list‰s of Op * (Valueèssqlê * Valueèssqlê list)
			| some_binop_list‰s of Op * (Valueèssqlê * Valueèssqlê list)
			| exists_tuples‰s of Tuple_listèssqlê
			| single_value‰s of Tuple_listèssqlê
			| contents‰s of Col_specèssqlê
			| sterling_contents‰s of Col_specèssqlê
			| dinary_contents‰s of Col_specèssqlê
			| classification‰s of Col_specèssqlê
			| row_existence‰s of Table_specèssqlê
			| joined_row_existence‰s
			| classify‰s of Valueèssqlê * Valueèssqlê
			| classify_default‰s of Valueèssqlê
			| observed‰s of Col_specèssqlê * Clauseèssqlê
			| modified‰s of Col_specèssqlê
			| context‰s of string
			| parameter‰s of string
=TEX
=SML
and ÛFrom_specèssqlêÝ =	  from‰s of Tuple_listèssqlê
				| correlate_from‰s of string * Tuple_listèssqlê
and ÛTuple_listèssqlêÝ =		  table_contents‰s of Table_specèssqlê
				| all_tuples‰s of Select_listèssqlê * From_specèssqlê list * Valueèssqlê 
				* Col_specèssqlê list * Col_specèssqlê list * Col_specèssqlê list * Valueèssqlê
				| distinct_tuples‰s of Select_listèssqlê * From_specèssqlê list * Valueèssqlê 
				* Col_specèssqlê list * Col_specèssqlê list * Col_specèssqlê list * Valueèssqlê
				| evaluate‰s of Select_listèssqlê * From_specèssqlê list * Valueèssqlê 
				* Col_specèssqlê list * Col_specèssqlê list * Col_specèssqlê list * Valueèssqlê
				| tuple‰s of Valueèssqlê list
				| union‰s of Tuple_listèssqlê list
				| name_columns‰s of string list * Tuple_listèssqlê
and ÛSelect_listèssqlêÝ =		  all_columns‰s
				| select_values‰s of Select_valueèssqlê list
and ÛSelect_valueèssqlêÝ =	  anonymous_value‰s of Valueèssqlê
				| named_value‰s of string * Valueèssqlê
				| anonymous_pair‰s of Valueèssqlê * Valueèssqlê
				| named_pair‰s of string * (Valueèssqlê * Valueèssqlê);
=TEX
=SML
datatype ÛCol_nameèssqlêÝ =	  denote_col_name‰s of string;
datatype ÛTarget_specèssqlêÝ =	  target‰s of Table_specèssqlê
				| correlate_target‰s of string * Table_specèssqlê;
=TEX
=SML
datatype ÛSet_clauseèssqlêÝ =	  set_value‰s of Col_nameèssqlê * Valueèssqlê
				| set_class‰s of Col_nameèssqlê * Valueèssqlê
				| set_class_and_value‰s of Col_nameèssqlê * Valueèssqlê * Valueèssqlê;
=TEX
=SML
datatype ÛQueryèssqlêÝ =	  insert‰s of Table_specèssqlê	 * Col_nameèssqlê list * Tuple_listèssqlê
				| delete‰s of Target_specèssqlê * Valueèssqlê * Col_specèssqlê list 
					* Col_specèssqlê list * Col_specèssqlê list * Valueèssqlê
				| update‰s of  Target_specèssqlê * Set_clauseèssqlê list * Valueèssqlê 
					* Col_specèssqlê list * Col_specèssqlê list * Col_specèssqlê list 
					* Valueèssqlê
				| select‰s of Tuple_listèssqlê
				| positioned_delete‰s of Target_specèssqlê * Select_listèssqlê 
					* Valueèssqlê * Col_specèssqlê list * Col_specèssqlê list 
					* Col_specèssqlê list * Valueèssqlê
				| positioned_update‰s of  Target_specèssqlê * Col_nameèssqlê list 
					* Col_nameèssqlê list * Select_listèssqlê * Valueèssqlê 
					* Col_specèssqlê list * Col_specèssqlê list * Col_specèssqlê list 
					* Valueèssqlê
				| commit
				| rollback;
=TEX
=SML
datatype ÛBoundQueryèssqlêÝ =	bind‰s of string list * Class list * Constant_valueèssqlê list 
					* Queryèssqlê
				
=TEX
\section{TSQL ABSTRACT SYNTAX}
\subsection{Sorts}
=SML
datatype ÛCol_specètsqlêÝ =	  denote_col_spec‰t of string
				| absolute_col_spec‰t of string list * string * string;

datatype ÛTable_specètsqlêÝ = absolute_table_spec‰t of string list * string;
=TEX
=SML
datatype ÛTypeètsqlêÝ =	  monolean_type‰t 
			| boolean_type‰t
			| string_type‰t of int * int
			| fixed_type‰t of int * int
			| floating_type‰t of int * int * int
			| enum_type‰t of int * string
			| time_type‰t of string
			| interval_type‰t of string
			| class_type‰t
			| code_type‰t
			| any_type‰t;
=TEX
=SML
datatype ÛValueètsqlêÝ =		  denote_null‰t 
				| denote_void‰t
				| denote_true‰t
				| denote_false‰t
				| denote_string‰t of string * Typeètsqlê
				| denote_fixed‰t of Fixed * Typeètsqlê
				| denote_floating‰t of Floating * Typeètsqlê			
				| denote_enum‰t of Enum * Typeètsqlê			
				| denote_time‰t of Time * Typeètsqlê			
				| denote_interval‰t of Interval * Typeètsqlê			
				| denote_class‰t of Class
				| denote_code‰t of Code
				| monop‰t of Op * Valueètsqlê
				| binop‰t of Op * (Valueètsqlê * Valueètsqlê)
				| triop‰t of Op * (Valueètsqlê * Valueètsqlê * Valueètsqlê)
				| convert‰t of Valueètsqlê * Typeètsqlê
				| convert_domain‰t of string * (Valueètsqlê * Typeètsqlê)
				| declare‰t of string * (Valueètsqlê * Valueètsqlê)
				| caseVal‰t of Valueètsqlê * Valueètsqlê list * Valueètsqlê list * Valueètsqlê
				| case‰t of Valueètsqlê list * Valueètsqlê list * Valueètsqlê
				| set_func_all‰t of Op * Valueètsqlê
				| set_func_distinct‰t of Op * Valueètsqlê
				| count_non_null‰t of Valueètsqlê * Typeètsqlê
				| count_distinct‰t of Valueètsqlê * Typeètsqlê
				| count_all‰t of Typeètsqlê
				| all_binop‰t of Op * (Valueètsqlê * Tuple_listètsqlê)
				| some_binop‰t of Op * (Valueètsqlê * Tuple_listètsqlê)
				| all_binop_list‰t of Op * (Valueètsqlê * Valueètsqlê list)
				| some_binop_list‰t of Op * (Valueètsqlê * Valueètsqlê list)
				| exists_tuples‰t of Tuple_listètsqlê
				| single_value‰t of Tuple_listètsqlê
				| contents‰t of Col_specètsqlê
=TEX
=SML
and ÛFrom_specètsqlêÝ =	  from‰t of Tuple_listètsqlê
				| correlate_from‰t of string * Tuple_listètsqlê
and ÛTuple_listètsqlêÝ =		  table_contents‰t of Table_specètsqlê
				| all_tuples‰t of Select_listètsqlê * From_specètsqlê list * Valueètsqlê 
					* Col_specètsqlê list * Valueètsqlê
				| distinct_tuples‰t of Select_listètsqlê * From_specètsqlê list * Valueètsqlê 
					* Col_specètsqlê list * Valueètsqlê
				| evaluate‰t of Select_listètsqlê * From_specètsqlê list * Valueètsqlê 
					* Col_specètsqlê list * Valueètsqlê
				| tuple‰t of Valueètsqlê list
				| union‰t of Tuple_listètsqlê list
				| name_columns‰t of string list * Tuple_listètsqlê
=TEX
=SML
and ÛSelect_listètsqlêÝ =		  all_columns‰t
				| select_values‰t of Select_valueètsqlê list
and ÛSelect_valueètsqlêÝ =	  anonymous_value‰t of Valueètsqlê
				| named_value‰t of string * Valueètsqlê;
=TEX	
=SML
datatype ÛCol_nameètsqlêÝ =	  denote_col_name‰t of string;
datatype ÛTarget_specètsqlêÝ =	  target‰t of Table_specètsqlê
				| correlate_target‰t of string * Table_specètsqlê;
=TEX
=SML
datatype ÛSet_clauseètsqlêÝ =	  set_value‰t of Col_nameètsqlê * Valueètsqlê;
=TEX
=SML
datatype ÛQueryètsqlêÝ =	  insert‰t of Table_specètsqlê * Col_nameètsqlê list * Tuple_listètsqlê
				| delete‰t of Target_specètsqlê * Valueètsqlê * Col_specètsqlê list
					* Valueètsqlê
				| update‰t of  Target_specètsqlê * Set_clauseètsqlê list * Valueètsqlê 
					* Col_specètsqlê list * Valueètsqlê
				| select‰t of Tuple_listètsqlê
				| positioned_delete‰t of Target_specètsqlê * Select_listètsqlê 
					* Valueètsqlê * Col_specètsqlê list * Valueètsqlê
				| positioned_update‰t of  Target_specètsqlê * Col_specètsqlê list 
					* Select_listètsqlê * Valueètsqlê * Col_specètsqlê list * Valueètsqlê
				| commit
				| rollback;
=TEX
\section{SSQL TRANSFORMATIONS}
\subsection{Generic Functions and Primitive Routines}
We will use the standard ML functions \verb+^+ for 
concatenation of strings, $implode$ and $explode$ for handling strings as lists of characters (and vice versa), $size$ for the
 number of characters in a string,  $@$ for 
concatenation of lists (\verb+&+ in \cite{trans}), $rev$ for reversing a list and $map$ to apply a function to all 
the elements of a list (\verb+*+ in \cite{trans}).
=GFT
Û_^_Ý 		: string * string -> string
ÛimplodeÝ	: string list -> string
ÛexplodeÝ	: string -> string list
ÛsizeÝ 		: string -> int
Û_@_Ý 		: 'a list * 'a list -> 'a list
ÛrevÝ		: 'a list -> 'a list
ÛmapÝ		: ('a -> 'b) -> 'a list -> 'b list
=TEX
The function $seq$.
=SML
exception negative of string;
fun	(ÛseqÝ : int * 'a -> 'a list) (0,x) = []
|	seq (n,x) = if n > 0 then (x :: (seq (n-1,x))) else raise negative "seq";
=TEX
We will use the function $length$ for the length of a list, (\verb+#+ in \cite{trans}) and $fold$ to fold a list into a single value ($\sp{\&}$ in \cite{trans}).
=SML
fun 	(ÛlengthÝ : 'a list -> int) (x :: xs) = 1 + (length xs)
|	length [] = 0;
=TEX
=SML
exception emptylist;
fun 	(ÛfoldÝ : ('a * 'a -> 'a) -> 'a list -> 'a) f [] = raise emptylist
|	fold f [x] = x
|	fold f (h :: t) = f(h,fold f t);
=TEX
We define a function $curry$:
=SML
fun 	(ÛcurryÝ : ('a * 'b -> 'c) -> 'a -> 'b -> 'c) f = (
	fn a => (fn b => f(a,b)));
=TEX
Now a function $combine2$ (and $combine3$ and $combine4$), which takes a pair (triple,..) of lists and 
returns a list of pairs (triples,..). An error is raised if the lists are of different lengths.
=SML
exception diffLengths of string;
=SML
fun 	(Ûcombine2Ý : 'a list -> 'b list -> ('a * 'b) list)
		[][] =[]
|	combine2 (h1::t1)(h2::t2) = (h1,h2)::(combine2 t1 t2)
|	combine2 _ _= raise diffLengths  "combine2";
=TEX
=SML
fun 	(Ûcombine3Ý : 'a list -> 'b list -> 'c list -> ('a * 'b * 'c) list)
		[][][]=[]
|	combine3 (h1::t1)(h2::t2)(h3::t3) = (h1,h2,h3)::(combine3 t1 t2 t3)
|	combine3 _ _ _ = raise diffLengths  "combine3";
=TEX
=SML
fun 	(Ûcombine4Ý : 'a list -> 'b list -> 'c list -> 'd list -> ('a * 'b * 'c * 'd) list)
		[][][][]=[]
|	combine4 (h1::t1)(h2::t2)(h3::t3)(h4::t4) = (h1,h2,h3,h4)::(combine4 t1 t2 t3 t4)
|	combine4 _ _ _ _ = raise diffLengths  "combine4";
=TEX
Now the function $at2$ (and $at3$ and $at4$) ($@$ in \cite{trans}) 
which turns a function taking a sequence of pairs (triples,..) into 
one taking a pair (triple,..) of sequences.
=SML
fun 	(Ûat2Ý : (('a * 'b ) list -> 'c) -> ('a list * 'b list -> 'c)) f = (
	fn (a,b) => f(combine2 a b));
=TEX
=SML
fun 	(Ûat3Ý : (('a * 'b * 'c ) list -> 'd) -> ('a list * 'b list * 'c list -> 'd)) f = (
	fn (a,b,c) => f(combine3 a b c));
=TEX
=SML
fun 	(Ûat4Ý : (('a * 'b * 'c * 'd ) list -> 'e) -> 
			('a list * 'b list * 'c list  * 'd list-> 'e)) f = (
	fn (a,b,c,d) => f(combine4 a b c d));
=TEX
Classifications are partially ordered by $dom$.
The exception $notDefined$ will be used in definitions of functions from \cite{trans}
 which are incompletely specified.
=SML
exception notDefined of string;
=TEX
=SML
fun 	(ÛdomÝ: Class * Class -> bool) (a,b)  = raise notDefined "dom";
infix dom;
=TEX
=SML
fun 	(ÛlubÝ: Class * Class -> Class) (a,b)  = raise notDefined "lub";
infix lub;
=TEX
=SML
fun 	(Ûlattice_topÝ: unit -> Class) ()  = raise notDefined "lattice_top";
=TEX
=SML
fun 	(Ûlattice_bottomÝ: unit -> Class) ()  = raise notDefined "lattice_bottom";
=TEX
We define infix functions $max$ and $min$ on integers.
=SML
infix min;
fun 	(a : int) ÛminÝ (b : int) = if a < b then a else b;
infix max;
fun 	(a : int) ÛmaxÝ (b : int) = if a > b then a else b;
=TEX
Head and Tail of a list.
=SML
exception Hd;
fun	(ÛhdÝ : 'a list -> 'a)
	[] = raise Hd
|	hd(h::t) =h;
exception Tl;
fun	(ÛtlÝ : 'a list -> 'a list)
	[] = raise Tl
|	tl(h::t) =t;

=TEX
The functions $invert$ and $split$.
=SML
fun	(ÛinvertÝ : 'a list list -> 'a list list)
		([] :: _) = []
|	invert x = map hd x :: invert (map tl x);
=TEX
=SML
fun 	(ÛsplitÝ: ('a * 'b) list -> 'a list * 'b list) [] = ([],[])
|	split ((h1,h2):: t) = 	let val (t1,t2) = split t
				in (h1 ::  t1,h2 :: t2)
				end;
=TEX
=SML
fun 	(Ûsplit3Ý: ('a * 'b * 'c) list -> 'a list * 'b list * 'c list) [] = ([],[],[])
|	split3 ((h1,h2,h3):: t) = 	let val (t1,t2,t3) = split3 t
					in (h1 ::  t1,h2 :: t2,h3 :: t3)
					end;
=TEX
=SML
fun 	(Ûsplit4Ý: ('a * 'b * 'c * 'd) list -> 'a list * 'b list * 'c list * 'd list) [] = ([],[],[],[])
|	split4 ((h1,h2,h3,h4):: t) = 	let val (t1,t2,t3,t4) = split4 t
					in (h1 ::  t1,h2 :: t2,h3 :: t3,h4 :: t4)
					end;
=TEX
=SML
fun 	(Ûsplit5Ý: ('a * 'b * 'c * 'd * 'e) list -> 'a list * 'b list * 'c list * 'd list * 'e list) [] 
					= ([],[],[],[],[])
|	split5 ((h1,h2,h3,h4,h5):: t) 	= 	let val (t1,t2,t3,t4,t5) = split5 t
						in (h1 ::  t1,h2 :: t2,h3 :: t3,h4 :: t4,h5 :: t5)
						end;
=TEX
Finally, the function $or$.
=SML
fun 	(ÛorÝ : bool * bool -> bool) (b1,b2) = b1 orelse b2;
=TEX
\subsection{Transformation Notation}
The primitive types are 
given in section \ref{UNI}. We will use the standard ML type $unit$ in place of $Null$. We give a datatype $Sum$ to allow us to form the disjoint
 sum of two types.
=SML
datatype ('a ,'b)ÛSumÝ = inL of 'a | inR of 'b;
=TEX
Then  discriminator and destructor functions for a sum type.
=SML
=SML
fun (ÛisLÝ: ('a ,'b)Sum -> bool) (inL x) = true
| 	isL _ = false;
fun (ÛisRÝ: ('a ,'b)Sum -> bool) (inR x) = true
| 	isR _ = false;
exception notLeft;
fun (ÛgetLÝ: ('a ,'b)Sum -> 'a) (inL x) = x
| 	getL _ = raise notLeft;
exception notRight;
fun (ÛgetRÝ: ('a ,'b)Sum -> 'b) (inR x) = x
| 	getR _ = raise notRight;
=TEX


=SML
datatype ÛMonoleanÝ = void;
=TEX
\subsection{Types}
=SML
datatype ÛTableSpecificationÝ =	  absolute of string list * string
					| default of int * string list * string;


datatype ÛSwordTypeÝ =	  nullType
				| monoleanType
				| booleanType
				| stringType of int * int
				| fixedType of int * int
				| floatingType of int * int * int
				| enumType of int * TableSpecification
				| timeType of string
				| intervalType of string
				| classType
				| codeType
				| anyType;
=TEX
=SML
datatype ÛWorthÝ =	  priceless
			| worthless
			| sterling
			| dinary;
=TEX
=SML
datatype ÛSsqlNameÝ =	  anon‰s
				| name‰s of string;
datatype ÛTsqlNameÝ =	  none‰t
				| anon‰t
				| name‰t of string;
=TEX
=SML
type ÛColTypeÝ = SwordType * SwordType;
=TEX
=SML
datatype ÛBoundInfoÝ =	  upb of Class
				| constant of Class;
=TEX
=SML
type ÛSsqlColÝ =	{name:SsqlName,
			 type_field:ColType,
			 col_exist:Class,
			 col_class:BoundInfo};
=TEX
=SML
datatype ÛTsqlClassNameÝ =	  anonètcê
				| nameètcê of string
				| constantètcê of Class;
=TEX
=SML
type ÛTsqlColÝ = 	{sterling_name:TsqlName,
			 dinary_name:TsqlName,
			 class_name:TsqlClassName};
=TEX
=SML
type ÛTableInfoÝ = 	{table_exist_class:Class,
			 table_class:Class,
		   	 row_class:BoundInfo};

=TEX
=SML
type ÛConstraintInfoÝ = 	{null_allowed:bool list,
				 lwb:Class list,
				 unique:int list list,
				 uniform:int list list,
				 index:int list list};
=TEX
=SML
datatype ÛColumnSpecificationÝ =	  anonymous_column of string 
					| specific of TableSpecification * string;
=TEX
=SML
datatype ÛTsqlReprÝ =	  local_identifier of string 
				| column of string * string
				| constant_class of Class
				| constant_null;
=TEX
=SML
type ÛExpTypeÝ = SwordType * Worth;
=TEX
=SML
datatype ÛExpClassÝ =	  variable of Valueètsqlê  * Class
			| constantèecê of Class 
=TEX
=SML
datatype ÛInternalExpClassÝ =	  ands of Valueètsqlê  list * ExpClass list
					| ors of Valueètsqlê  list * ExpClass list
					| simple of ExpClass;
=TEX
We give a new type for use in entering details of tables to the symbol table.
=SML
datatype ÛTableNameÝ =	  anonètnê
				| nameètnê of TableSpecification;
=TEX
\subsection{The Symbol Table}
=SML
type ÛTableDetailÝ =	{tableName : TableName,
			corrName : SsqlName,
			genCorr : string,
			info : TableInfo,
			columns : SsqlCol list,
			rowClass : TsqlClassName,
			implementation : TsqlCol list,
			constraints : ConstraintInfo};
=TEX
=SML
type ÛIdentDetailÝ =	{identName : string,
			info : ExpType,
			lubèidê : Class,
			vName : string,
			cName : TsqlName};
=TEX
=SML
type ÛScopeÝ =	{tables : TableDetail list,
		identifiers : IdentDetail list};
=TEX
=SML
type ÛParamInfoÝ =	{name : string,
			val‰p : Constant_valueèssqlê,
			clasf : Class};
=TEX
=SML
val symbolTable = ref ([]:Scope list);
val parameterTable = ref ([]:ParamInfo list);
=TEX

\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}



