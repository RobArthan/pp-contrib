=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Specification of Query Transformations in SML (I)}  %% Mandatory field
\TPPref{DS/FMU/FEF/019}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{Preliminaries to a Standard ML specification of the SSQL Query Transformations  for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}})]  SSQL and TSQL specs separated from transformations.
\end{description}

\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document gives  specifications in Standard ML (\cite{milner90}, \cite{paulson91}) of the SSQL and TSQL abstract syntax  and preliminary specifications from \cite{trans} to support a formal specification in Standard ML of the SSQL query transformations of \cite{trans}. 

It constitutes part of
 deliverable D8 of work package 3, as given
in the Proposal for Phase~2, \cite{DS/FMU/FEF/018}.

\subsection{Introduction}
We proposed in \cite{DS/FMU/FEF/018} to formalise the 
SSQL query transformations of \cite{trans} in Standard ML. 
Here we provide Standard ML specifications of the SSQL 
and TSQL datatypes together with specifications of the transformation notation,  
generic functions, primitive routines, transformation types 
and symbol table from \cite{trans}. Standard ML specifications of the 
transformations may be found in \cite{DS/FMU/FEF/020}.

In order to avoid overloading of Standard ML identifiers, 
subscripts have been used 
to distinguish between constructors of SSQL types and TSQL 
types. Subscripts or abbreviations have also been used in the case where 
an identifier used in \cite{trans} is a reserved word in Standard ML (e.g. $val$).


\section{UNIVERSAL TYPES} \label{UNI}
We will use SML type $int$, $bool$, $unit$, $list$ and $string$ where appropriate. At this stage, the rest of the types are 
defined each with a single constructor.
=SML
datatype €Fixed› = mk_fixed;
datatype €Floating› = mk_floating;
datatype €Enum› = mk_enum;
datatype €Time› = mk_time;
datatype €Interval› = mk_interval;
datatype €Class› = mk_class;
datatype €Code› = mk_code;
=TEX
We define a datatype $Op$, rather than use type $Integer$.
=SML
datatype €Op› =	  not_op
			| definitely_op
			| possibly_op
			| minus_op
			| ord_op
			| char_op
			| upper_op
			| lower_op
			| plus_op
			| minusd_op
			| times_op
			| divide_op
			| concat_op
			| and_op
			| or_op
			| less_than_op
			| less_or_equal_op
			| greater_or_equal_op
			| greater_than_op
			| equal_op
			| not_equal_op
			| lub_op
			| glb_op
			| dom_op
			| dom_by_op
			| liked_op
			| maximum_op
			| minimum_op
			| between_op
			| liket_op;
=TEX
\section{SSQL ABSTRACT SYNTAX}
\subsection{Sorts}
=SML
datatype €Col_specËssqlÍ› =	  denote_col_specâs of string
				| absolute_col_specâs of string list * string * string
				| default_col_specâs of int * string list * string * string;


datatype €Table_specËssqlÍ› =	  absolute_table_specâs of string list * string
				| default_table_specâs of int * string list * string;
=SML
datatype €TypeËssqlÍ› =	  monolean_typeâs 
			| boolean_typeâs
			| string_typeâs of int * int
			| fixed_typeâs of int * int
			| floating_typeâs of int * int * int
			| enum_typeâs of int * Table_specËssqlÍ
			| time_typeâs of string
			| interval_typeâs of string
			| class_typeâs
			| code_typeâs
			| any_typeâs;
=TEX		
=SML
datatype €ClauseËssqlÍ› =	  where_clauseâs 
				| group_by_clauseâs
				| having_clauseâs
				| set_clauseâs
				| select_clauseâs
				| constraint_clauseâs;
=TEX
=SML
datatype €Constant_valueËssqlÍ› =	  denote_nullâs 
					| denote_voidâs
					| denote_trueâs
					| denote_falseâs
					| denote_stringâs of string * TypeËssqlÍ
					| denote_fixedâs of Fixed * TypeËssqlÍ
					| denote_floatingâs of Floating * TypeËssqlÍ			
					| denote_enumâs of Enum * TypeËssqlÍ			
					| denote_timeâs of Time * TypeËssqlÍ			
					| denote_intervalâs of Interval * TypeËssqlÍ			
					| denote_classâs of Class
					| denote_codeâs of Code;
=TEX
=SML
datatype €ValueËssqlÍ› =	  denote_constantâs of Constant_valueËssqlÍ
			| monopâs of Op * ValueËssqlÍ
			| binopâs of Op * (ValueËssqlÍ * ValueËssqlÍ)
			| triopâs of Op * (ValueËssqlÍ * ValueËssqlÍ * ValueËssqlÍ)
			| convertâs of ValueËssqlÍ * TypeËssqlÍ
			| convert_domainâs of ValueËssqlÍ * Table_specËssqlÍ * TypeËssqlÍ
			| make_sterlingâs of ValueËssqlÍ
			| make_dinaryâs of ValueËssqlÍ
			| declareâs of string * (ValueËssqlÍ * ValueËssqlÍ)
			| caseValâs of ValueËssqlÍ * ValueËssqlÍ list * ValueËssqlÍ list * ValueËssqlÍ
			| caseâs of ValueËssqlÍ list * ValueËssqlÍ list * ValueËssqlÍ
			| set_func_allâs of Op * ValueËssqlÍ
			| set_func_distinctâs of Op * ValueËssqlÍ
			| count_non_nullâs of ValueËssqlÍ * TypeËssqlÍ
			| count_distinctâs of ValueËssqlÍ * TypeËssqlÍ
			| count_allâs of TypeËssqlÍ
			| all_binopâs of Op * (ValueËssqlÍ * Tuple_listËssqlÍ)
			| some_binopâs of Op * (ValueËssqlÍ * Tuple_listËssqlÍ)
			| all_binop_listâs of Op * (ValueËssqlÍ * ValueËssqlÍ list)
			| some_binop_listâs of Op * (ValueËssqlÍ * ValueËssqlÍ list)
			| exists_tuplesâs of Tuple_listËssqlÍ
			| single_valueâs of Tuple_listËssqlÍ
			| contentsâs of Col_specËssqlÍ
			| sterling_contentsâs of Col_specËssqlÍ
			| dinary_contentsâs of Col_specËssqlÍ
			| classificationâs of Col_specËssqlÍ
			| row_existenceâs of Table_specËssqlÍ
			| joined_row_existenceâs
			| classifyâs of ValueËssqlÍ * ValueËssqlÍ
			| classify_defaultâs of ValueËssqlÍ
			| observedâs of Col_specËssqlÍ * ClauseËssqlÍ
			| modifiedâs of Col_specËssqlÍ
			| contextâs of string
			| parameterâs of string
=TEX
=SML
and €From_specËssqlÍ› =	  fromâs of Tuple_listËssqlÍ
				| correlate_fromâs of string * Tuple_listËssqlÍ
and €Tuple_listËssqlÍ› =		  table_contentsâs of Table_specËssqlÍ
				| all_tuplesâs of Select_listËssqlÍ * From_specËssqlÍ list * ValueËssqlÍ 
				* Col_specËssqlÍ list * Col_specËssqlÍ list * Col_specËssqlÍ list * ValueËssqlÍ
				| distinct_tuplesâs of Select_listËssqlÍ * From_specËssqlÍ list * ValueËssqlÍ 
				* Col_specËssqlÍ list * Col_specËssqlÍ list * Col_specËssqlÍ list * ValueËssqlÍ
				| evaluateâs of Select_listËssqlÍ * From_specËssqlÍ list * ValueËssqlÍ 
				* Col_specËssqlÍ list * Col_specËssqlÍ list * Col_specËssqlÍ list * ValueËssqlÍ
				| tupleâs of ValueËssqlÍ list
				| unionâs of Tuple_listËssqlÍ list
				| name_columnsâs of string list * Tuple_listËssqlÍ
and €Select_listËssqlÍ› =		  all_columnsâs
				| select_valuesâs of Select_valueËssqlÍ list
and €Select_valueËssqlÍ› =	  anonymous_valueâs of ValueËssqlÍ
				| named_valueâs of string * ValueËssqlÍ
				| anonymous_pairâs of ValueËssqlÍ * ValueËssqlÍ
				| named_pairâs of string * (ValueËssqlÍ * ValueËssqlÍ);
=TEX
=SML
datatype €Col_nameËssqlÍ› =	  denote_col_nameâs of string;
datatype €Target_specËssqlÍ› =	  targetâs of Table_specËssqlÍ
				| correlate_targetâs of string * Table_specËssqlÍ;
=TEX
=SML
datatype €Set_clauseËssqlÍ› =	  set_valueâs of Col_nameËssqlÍ * ValueËssqlÍ
				| set_classâs of Col_nameËssqlÍ * ValueËssqlÍ
				| set_class_and_valueâs of Col_nameËssqlÍ * ValueËssqlÍ * ValueËssqlÍ;
=TEX
=SML
datatype €QueryËssqlÍ› =	  insertâs of Table_specËssqlÍ	 * Col_nameËssqlÍ list * Tuple_listËssqlÍ
				| deleteâs of Target_specËssqlÍ * ValueËssqlÍ * Col_specËssqlÍ list 
					* Col_specËssqlÍ list * Col_specËssqlÍ list * ValueËssqlÍ
				| updateâs of  Target_specËssqlÍ * Set_clauseËssqlÍ list * ValueËssqlÍ 
					* Col_specËssqlÍ list * Col_specËssqlÍ list * Col_specËssqlÍ list 
					* ValueËssqlÍ
				| selectâs of Tuple_listËssqlÍ
				| positioned_deleteâs of Target_specËssqlÍ * Select_listËssqlÍ 
					* ValueËssqlÍ * Col_specËssqlÍ list * Col_specËssqlÍ list 
					* Col_specËssqlÍ list * ValueËssqlÍ
				| positioned_updateâs of  Target_specËssqlÍ * Col_nameËssqlÍ list 
					* Col_nameËssqlÍ list * Select_listËssqlÍ * ValueËssqlÍ 
					* Col_specËssqlÍ list * Col_specËssqlÍ list * Col_specËssqlÍ list 
					* ValueËssqlÍ
				| commit
				| rollback;
=TEX
=SML
datatype €BoundQueryËssqlÍ› =	bindâs of string list * Class list * Constant_valueËssqlÍ list 
					* QueryËssqlÍ
				
=TEX
\section{TSQL ABSTRACT SYNTAX}
\subsection{Sorts}
=SML
datatype €Col_specËtsqlÍ› =	  denote_col_specât of string
				| absolute_col_specât of string list * string * string;

datatype €Table_specËtsqlÍ› = absolute_table_specât of string list * string;
=TEX
=SML
datatype €TypeËtsqlÍ› =	  monolean_typeât 
			| boolean_typeât
			| string_typeât of int * int
			| fixed_typeât of int * int
			| floating_typeât of int * int * int
			| enum_typeât of int * string
			| time_typeât of string
			| interval_typeât of string
			| class_typeât
			| code_typeât
			| any_typeât;
=TEX
=SML
datatype €ValueËtsqlÍ› =		  denote_nullât 
				| denote_voidât
				| denote_trueât
				| denote_falseât
				| denote_stringât of string * TypeËtsqlÍ
				| denote_fixedât of Fixed * TypeËtsqlÍ
				| denote_floatingât of Floating * TypeËtsqlÍ			
				| denote_enumât of Enum * TypeËtsqlÍ			
				| denote_timeât of Time * TypeËtsqlÍ			
				| denote_intervalât of Interval * TypeËtsqlÍ			
				| denote_classât of Class
				| denote_codeât of Code
				| monopât of Op * ValueËtsqlÍ
				| binopât of Op * (ValueËtsqlÍ * ValueËtsqlÍ)
				| triopât of Op * (ValueËtsqlÍ * ValueËtsqlÍ * ValueËtsqlÍ)
				| convertât of ValueËtsqlÍ * TypeËtsqlÍ
				| convert_domainât of string * (ValueËtsqlÍ * TypeËtsqlÍ)
				| declareât of string * (ValueËtsqlÍ * ValueËtsqlÍ)
				| caseValât of ValueËtsqlÍ * ValueËtsqlÍ list * ValueËtsqlÍ list * ValueËtsqlÍ
				| caseât of ValueËtsqlÍ list * ValueËtsqlÍ list * ValueËtsqlÍ
				| set_func_allât of Op * ValueËtsqlÍ
				| set_func_distinctât of Op * ValueËtsqlÍ
				| count_non_nullât of ValueËtsqlÍ * TypeËtsqlÍ
				| count_distinctât of ValueËtsqlÍ * TypeËtsqlÍ
				| count_allât of TypeËtsqlÍ
				| all_binopât of Op * (ValueËtsqlÍ * Tuple_listËtsqlÍ)
				| some_binopât of Op * (ValueËtsqlÍ * Tuple_listËtsqlÍ)
				| all_binop_listât of Op * (ValueËtsqlÍ * ValueËtsqlÍ list)
				| some_binop_listât of Op * (ValueËtsqlÍ * ValueËtsqlÍ list)
				| exists_tuplesât of Tuple_listËtsqlÍ
				| single_valueât of Tuple_listËtsqlÍ
				| contentsât of Col_specËtsqlÍ
=TEX
=SML
and €From_specËtsqlÍ› =	  fromât of Tuple_listËtsqlÍ
				| correlate_fromât of string * Tuple_listËtsqlÍ
and €Tuple_listËtsqlÍ› =		  table_contentsât of Table_specËtsqlÍ
				| all_tuplesât of Select_listËtsqlÍ * From_specËtsqlÍ list * ValueËtsqlÍ 
					* Col_specËtsqlÍ list * ValueËtsqlÍ
				| distinct_tuplesât of Select_listËtsqlÍ * From_specËtsqlÍ list * ValueËtsqlÍ 
					* Col_specËtsqlÍ list * ValueËtsqlÍ
				| evaluateât of Select_listËtsqlÍ * From_specËtsqlÍ list * ValueËtsqlÍ 
					* Col_specËtsqlÍ list * ValueËtsqlÍ
				| tupleât of ValueËtsqlÍ list
				| unionât of Tuple_listËtsqlÍ list
				| name_columnsât of string list * Tuple_listËtsqlÍ
=TEX
=SML
and €Select_listËtsqlÍ› =		  all_columnsât
				| select_valuesât of Select_valueËtsqlÍ list
and €Select_valueËtsqlÍ› =	  anonymous_valueât of ValueËtsqlÍ
				| named_valueât of string * ValueËtsqlÍ;
=TEX	
=SML
datatype €Col_nameËtsqlÍ› =	  denote_col_nameât of string;
datatype €Target_specËtsqlÍ› =	  targetât of Table_specËtsqlÍ
				| correlate_targetât of string * Table_specËtsqlÍ;
=TEX
=SML
datatype €Set_clauseËtsqlÍ› =	  set_valueât of Col_nameËtsqlÍ * ValueËtsqlÍ;
=TEX
=SML
datatype €QueryËtsqlÍ› =	  insertât of Table_specËtsqlÍ * Col_nameËtsqlÍ list * Tuple_listËtsqlÍ
				| deleteât of Target_specËtsqlÍ * ValueËtsqlÍ * Col_specËtsqlÍ list
					* ValueËtsqlÍ
				| updateât of  Target_specËtsqlÍ * Set_clauseËtsqlÍ list * ValueËtsqlÍ 
					* Col_specËtsqlÍ list * ValueËtsqlÍ
				| selectât of Tuple_listËtsqlÍ
				| positioned_deleteât of Target_specËtsqlÍ * Select_listËtsqlÍ 
					* ValueËtsqlÍ * Col_specËtsqlÍ list * ValueËtsqlÍ
				| positioned_updateât of  Target_specËtsqlÍ * Col_specËtsqlÍ list 
					* Select_listËtsqlÍ * ValueËtsqlÍ * Col_specËtsqlÍ list * ValueËtsqlÍ
				| commit
				| rollback;
=TEX
\section{SSQL TRANSFORMATIONS}
\subsection{Generic Functions and Primitive Routines}
We will use the standard ML functions \verb+^+ for 
concatenation of strings, $implode$ and $explode$ for handling strings as lists of characters (and vice versa), $size$ for the
 number of characters in a string,  $@$ for 
concatenation of lists (\verb+&+ in \cite{trans}), $rev$ for reversing a list and $map$ to apply a function to all 
the elements of a list (\verb+*+ in \cite{trans}).
=GFT
€_^_› 		: string * string -> string
€implode›	: string list -> string
€explode›	: string -> string list
€size› 		: string -> int
€_@_› 		: 'a list * 'a list -> 'a list
€rev›		: 'a list -> 'a list
€map›		: ('a -> 'b) -> 'a list -> 'b list
=TEX
The function $seq$.
=SML
exception negative of string;
fun	(€seq› : int * 'a -> 'a list) (0,x) = []
|	seq (n,x) = if n > 0 then (x :: (seq (n-1,x))) else raise negative "seq";
=TEX
We will use the function $length$ for the length of a list, (\verb+#+ in \cite{trans}) and $fold$ to fold a list into a single value ($\sp{\&}$ in \cite{trans}).
=SML
fun 	(€length› : 'a list -> int) (x :: xs) = 1 + (length xs)
|	length [] = 0;
=TEX
=SML
exception emptylist;
fun 	(€fold› : ('a * 'a -> 'a) -> 'a list -> 'a) f [] = raise emptylist
|	fold f [x] = x
|	fold f (h :: t) = f(h,fold f t);
=TEX
We define a function $curry$:
=SML
fun 	(€curry› : ('a * 'b -> 'c) -> 'a -> 'b -> 'c) f = (
	fn a => (fn b => f(a,b)));
=TEX
Now a function $combine2$ (and $combine3$ and $combine4$), which takes a pair (triple,..) of lists and 
returns a list of pairs (triples,..). An error is raised if the lists are of different lengths.
=SML
exception diffLengths of string;
=SML
fun 	(€combine2› : 'a list -> 'b list -> ('a * 'b) list)
		[][] =[]
|	combine2 (h1::t1)(h2::t2) = (h1,h2)::(combine2 t1 t2)
|	combine2 _ _= raise diffLengths  "combine2";
=TEX
=SML
fun 	(€combine3› : 'a list -> 'b list -> 'c list -> ('a * 'b * 'c) list)
		[][][]=[]
|	combine3 (h1::t1)(h2::t2)(h3::t3) = (h1,h2,h3)::(combine3 t1 t2 t3)
|	combine3 _ _ _ = raise diffLengths  "combine3";
=TEX
=SML
fun 	(€combine4› : 'a list -> 'b list -> 'c list -> 'd list -> ('a * 'b * 'c * 'd) list)
		[][][][]=[]
|	combine4 (h1::t1)(h2::t2)(h3::t3)(h4::t4) = (h1,h2,h3,h4)::(combine4 t1 t2 t3 t4)
|	combine4 _ _ _ _ = raise diffLengths  "combine4";
=TEX
Now the function $at2$ (and $at3$ and $at4$) ($@$ in \cite{trans}) 
which turns a function taking a sequence of pairs (triples,..) into 
one taking a pair (triple,..) of sequences.
=SML
fun 	(€at2› : (('a * 'b ) list -> 'c) -> ('a list * 'b list -> 'c)) f = (
	fn (a,b) => f(combine2 a b));
=TEX
=SML
fun 	(€at3› : (('a * 'b * 'c ) list -> 'd) -> ('a list * 'b list * 'c list -> 'd)) f = (
	fn (a,b,c) => f(combine3 a b c));
=TEX
=SML
fun 	(€at4› : (('a * 'b * 'c * 'd ) list -> 'e) -> 
			('a list * 'b list * 'c list  * 'd list-> 'e)) f = (
	fn (a,b,c,d) => f(combine4 a b c d));
=TEX
Classifications are partially ordered by $dom$.
The exception $notDefined$ will be used in definitions of functions from \cite{trans}
 which are incompletely specified.
=SML
exception notDefined of string;
=TEX
=SML
fun 	(€dom›: Class * Class -> bool) (a,b)  = raise notDefined "dom";
infix dom;
=TEX
=SML
fun 	(€lub›: Class * Class -> Class) (a,b)  = raise notDefined "lub";
infix lub;
=TEX
=SML
fun 	(€lattice_top›: unit -> Class) ()  = raise notDefined "lattice_top";
=TEX
=SML
fun 	(€lattice_bottom›: unit -> Class) ()  = raise notDefined "lattice_bottom";
=TEX
We define infix functions $max$ and $min$ on integers.
=SML
infix min;
fun 	(a : int) €min› (b : int) = if a < b then a else b;
infix max;
fun 	(a : int) €max› (b : int) = if a > b then a else b;
=TEX
Head and Tail of a list.
=SML
exception Hd;
fun	(€hd› : 'a list -> 'a)
	[] = raise Hd
|	hd(h::t) =h;
exception Tl;
fun	(€tl› : 'a list -> 'a list)
	[] = raise Tl
|	tl(h::t) =t;

=TEX
The functions $invert$ and $split$.
=SML
fun	(€invert› : 'a list list -> 'a list list)
		([] :: _) = []
|	invert x = map hd x :: invert (map tl x);
=TEX
=SML
fun 	(€split›: ('a * 'b) list -> 'a list * 'b list) [] = ([],[])
|	split ((h1,h2):: t) = 	let val (t1,t2) = split t
				in (h1 ::  t1,h2 :: t2)
				end;
=TEX
=SML
fun 	(€split3›: ('a * 'b * 'c) list -> 'a list * 'b list * 'c list) [] = ([],[],[])
|	split3 ((h1,h2,h3):: t) = 	let val (t1,t2,t3) = split3 t
					in (h1 ::  t1,h2 :: t2,h3 :: t3)
					end;
=TEX
=SML
fun 	(€split4›: ('a * 'b * 'c * 'd) list -> 'a list * 'b list * 'c list * 'd list) [] = ([],[],[],[])
|	split4 ((h1,h2,h3,h4):: t) = 	let val (t1,t2,t3,t4) = split4 t
					in (h1 ::  t1,h2 :: t2,h3 :: t3,h4 :: t4)
					end;
=TEX
=SML
fun 	(€split5›: ('a * 'b * 'c * 'd * 'e) list -> 'a list * 'b list * 'c list * 'd list * 'e list) [] 
					= ([],[],[],[],[])
|	split5 ((h1,h2,h3,h4,h5):: t) 	= 	let val (t1,t2,t3,t4,t5) = split5 t
						in (h1 ::  t1,h2 :: t2,h3 :: t3,h4 :: t4,h5 :: t5)
						end;
=TEX
Finally, the function $or$.
=SML
fun 	(€or› : bool * bool -> bool) (b1,b2) = b1 orelse b2;
=TEX
\subsection{Transformation Notation}
The primitive types are 
given in section \ref{UNI}. We will use the standard ML type $unit$ in place of $Null$. We give a datatype $Sum$ to allow us to form the disjoint
 sum of two types.
=SML
datatype ('a ,'b)€Sum› = inL of 'a | inR of 'b;
=TEX
Then  discriminator and destructor functions for a sum type.
=SML
=SML
fun (€isL›: ('a ,'b)Sum -> bool) (inL x) = true
| 	isL _ = false;
fun (€isR›: ('a ,'b)Sum -> bool) (inR x) = true
| 	isR _ = false;
exception notLeft;
fun (€getL›: ('a ,'b)Sum -> 'a) (inL x) = x
| 	getL _ = raise notLeft;
exception notRight;
fun (€getR›: ('a ,'b)Sum -> 'b) (inR x) = x
| 	getR _ = raise notRight;
=TEX


=SML
datatype €Monolean› = void;
=TEX
\subsection{Types}
=SML
datatype €TableSpecification› =	  absolute of string list * string
					| default of int * string list * string;


datatype €SwordType› =	  nullType
				| monoleanType
				| booleanType
				| stringType of int * int
				| fixedType of int * int
				| floatingType of int * int * int
				| enumType of int * TableSpecification
				| timeType of string
				| intervalType of string
				| classType
				| codeType
				| anyType;
=TEX
=SML
datatype €Worth› =	  priceless
			| worthless
			| sterling
			| dinary;
=TEX
=SML
datatype €SsqlName› =	  anonâs
				| nameâs of string;
datatype €TsqlName› =	  noneât
				| anonât
				| nameât of string;
=TEX
=SML
type €ColType› = SwordType * SwordType;
=TEX
=SML
datatype €BoundInfo› =	  upb of Class
				| constant of Class;
=TEX
=SML
type €SsqlCol› =	{name:SsqlName,
			 type_field:ColType,
			 col_exist:Class,
			 col_class:BoundInfo};
=TEX
=SML
datatype €TsqlClassName› =	  anonËtcÍ
				| nameËtcÍ of string
				| constantËtcÍ of Class;
=TEX
=SML
type €TsqlCol› = 	{sterling_name:TsqlName,
			 dinary_name:TsqlName,
			 class_name:TsqlClassName};
=TEX
=SML
type €TableInfo› = 	{table_exist_class:Class,
			 table_class:Class,
		   	 row_class:BoundInfo};

=TEX
=SML
type €ConstraintInfo› = 	{null_allowed:bool list,
				 lwb:Class list,
				 unique:int list list,
				 uniform:int list list,
				 index:int list list};
=TEX
=SML
datatype €ColumnSpecification› =	  anonymous_column of string 
					| specific of TableSpecification * string;
=TEX
=SML
datatype €TsqlRepr› =	  local_identifier of string 
				| column of string * string
				| constant_class of Class
				| constant_null;
=TEX
=SML
type €ExpType› = SwordType * Worth;
=TEX
=SML
datatype €ExpClass› =	  variable of ValueËtsqlÍ  * Class
			| constantËecÍ of Class 
=TEX
=SML
datatype €InternalExpClass› =	  ands of ValueËtsqlÍ  list * ExpClass list
					| ors of ValueËtsqlÍ  list * ExpClass list
					| simple of ExpClass;
=TEX
We give a new type for use in entering details of tables to the symbol table.
=SML
datatype €TableName› =	  anonËtnÍ
				| nameËtnÍ of TableSpecification;
=TEX
\subsection{The Symbol Table}
=SML
type €TableDetail› =	{tableName : TableName,
			corrName : SsqlName,
			genCorr : string,
			info : TableInfo,
			columns : SsqlCol list,
			rowClass : TsqlClassName,
			implementation : TsqlCol list,
			constraints : ConstraintInfo};
=TEX
=SML
type €IdentDetail› =	{identName : string,
			info : ExpType,
			lubËidÍ : Class,
			vName : string,
			cName : TsqlName};
=TEX
=SML
type €Scope› =	{tables : TableDetail list,
		identifiers : IdentDetail list};
=TEX
=SML
type €ParamInfo› =	{name : string,
			valâp : Constant_valueËssqlÍ,
			clasf : Class};
=TEX
=SML
val symbolTable = ref ([]:Scope list);
val parameterTable = ref ([]:ParamInfo list);
=TEX

\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}



