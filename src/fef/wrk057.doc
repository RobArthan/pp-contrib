=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\def\Note#1{{\small\bf[Note: #1]}}
\makeindex
\TPPproject{{\Product}}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Examples of HOL Type Definitions}  %% Mandatory field
\TPPref{DS/FMU/IED/WRK057}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.~D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPabstract{Examples of HOL Type Definitions.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library \\
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}}) ] First draft. 

\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}

\subsection{Introduction}


\subsection{Setting Up}
The following \Product{} instructions set up the new theory $wrk057$ and set the context 
for the proof tools..
=SML
open_theory"lib_thms";
(force_delete_theory "wrk057" handle _ => ());
new_theory €"wrk057"›;
push_pc "hol";
=TEX
\section{LEMMAS ABOUT LISTS}
=TEX
=SML
push_goal([], ¨µl1 l2∑ l1 Î l2 = [] § l1 = [] ± l2 = []Æ);
a(µ_tac);
a(list_induction_tac¨l1Æ THEN rewrite_tac[append_def]);
val €Î_empty_thm› = save_pop_thm"Î_empty_thm";
=TEX
=SML
push_goal([], ¨µls∑ Flat ls = [] § Elems ls Ä {[]}Æ);
a(µ_tac);
a(list_induction_tac¨lsÆ THEN
	asm_rewrite_tac(Î_empty_thm :: map get_spec[¨ElemsÆ, ¨FlatÆ]));
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
val €flat_empty_thm› = save_pop_thm"flat_empty_thm";
=TEX
=SML
push_goal([], ¨µl1 l2 l3∑ (l1 Î l2) Î l3 = l1 Î l2 Î l3Æ);
a(µ_tac);
a(list_induction_tac¨l1Æ THEN asm_rewrite_tac(map get_spec[¨AppendÆ]));
val €append_assoc_thm› = save_pop_thm"append_assoc_thm";
=TEX
=SML
push_goal([], ¨µls1 ls2∑ Flat (ls1 Î ls2)  = Flat ls1 Î Flat ls2Æ);
a(µ_tac);
a(list_induction_tac¨ls1Æ THEN
	asm_rewrite_tac(append_assoc_thm :: map get_spec[¨FlatÆ, ¨AppendÆ]));
val €flat_append_thm› = save_pop_thm"flat_append_thm";
=TEX
=SML
push_goal([], ¨µls1 ls2∑ Length (ls1 Î ls2)  = Length ls1 + Length ls2Æ);
a(µ_tac);
a(list_induction_tac¨ls1Æ THEN
	asm_rewrite_tac(plus_assoc_thm :: map get_spec[¨LengthÆ, ¨AppendÆ]));
val €length_append_thm› = save_pop_thm"length_append_thm";
=TEX
=SML
push_goal([], ¨µl1 l2∑ Elems (l1 Î l2)  = Elems l1 ¿ Elems l2Æ);
a(µ_tac);
a(list_induction_tac¨l1Æ THEN
	asm_rewrite_tac(map get_spec[¨FlatÆ, ¨ElemsÆ, ¨AppendÆ]));
a(PC_T1 "sets_ext" prove_tac[]);
val €elems_append_thm› = save_pop_thm"elems_append_thm";
=TEX
=SML
push_goal([], ¨µl∑ l Î []  = lÆ);
a(µ_tac);
a(list_induction_tac¨lÆ THEN
	asm_rewrite_tac(map get_spec[¨AppendÆ]));
val €append_empty_thm› = save_pop_thm"append_empty_thm";
=TEX
=SML
push_goal([], ¨µl1 l2 l3∑ l1 Î l2  = l1 Î l3 § l2 = l3Æ);
a(µ_tac);
a(list_induction_tac¨l1Æ THEN
	asm_rewrite_tac(map get_spec[¨AppendÆ]));
val €append_cancel_thm› = save_pop_thm"append_cancel_thm";
push_goal([], ¨µf g l∑(µx∑x ç Elems l ¥ f(g x) = x) ¥ Map f(Map g l) = lÆ);
a(REPEAT µ_tac);
a(list_induction_tac¨lÆ THEN PC_T1 "sets_ext1" asm_rewrite_tac(map get_spec
	[¨ElemsÆ, ¨MapÆ]));
(* *** Goal "1" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨xÆ THEN asm_rewrite_tac[]);
val €map_map_id_thm› = save_pop_thm"map_map_id_thm";
=TEX
=SML
push_goal([], ¨µll l∑ l ç Elems ll ¥ Length l º Length (Flat ll)Æ);
a(µ_tac);
a(list_induction_tac¨llÆ THEN
	rewrite_tac(length_Î_thm :: map get_spec[¨ElemsÆ, ¨FlatÆ, ¨LengthÆ])
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
a(PC_T1 "lin_arith" asm_prove_tac[]);
val €length_length_flat_thm› = save_pop_thm"length_length_flat_thm";
=TEX
=SML
push_goal([], ¨µf l∑Elems (Map f l) = {y | ∂x∑ x ç Elems l ± f x = y}Æ);
a(REPEAT strip_tac);
a(list_induction_tac¨lÆ THEN PC_T1 "sets_ext1" asm_rewrite_tac(map get_spec
	[¨ElemsÆ, ¨MapÆ]) THEN PC_T1 "sets_ext1" REPEAT strip_tac
	THEN all_var_elim_asm_tac1 THEN asm_prove_tac[]);
val €elems_map_thm› = save_pop_thm"elems_map_thm";
=TEX
=SML
push_goal([], ¨µl∑ Length l = 0 § l = []Æ);
a(µ_tac);
a(list_induction_tac¨lÆ THEN asm_rewrite_tac(map get_spec[¨LengthÆ]));
val €length_0_thm› = save_pop_thm"length_0_thm";
=TEX
\section{LEMMAS ABOUT FUNCTIONS}
=TEX
=SML
push_goal([], ¨µf∑ OneOne f ¥ ∂g∑ µx∑ g(f x) = xÆ);
a(rewrite_tac(map get_spec[¨OneOneÆ]) THEN REPEAT strip_tac);
a(∂_tac¨Ãy∑≈ x∑ f x = yÆ);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(≈_tac¨≈ x'∑ f x' = f xÆ);
(* *** Goal "1" *** *)
a(prove_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
val €one_one_left_inv_thm› = save_pop_thm"one_one_left_inv_thm";
=TEX
=SML
push_goal([], ¨µf∑ Onto f ¥ ∂g∑ µy∑ f(g y) = yÆ);
a(rewrite_tac(map get_spec[¨OntoÆ]) THEN REPEAT strip_tac);
a(∂_tac¨Ãx∑≈ y∑ x = f yÆ);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(≈_tac¨≈ y'∑ y = f y'Æ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
val €onto_right_inv_thm› = save_pop_thm"onto_right_inv_thm";
=TEX
=SML
push_goal([], ¨µf∑ OneOne f ± Onto f ¥
	∂g∑ (µx∑ g(f x) = x) ± (µy∑ f(g y) = y)Æ);
a(rewrite_tac(map get_spec[¨OntoÆ]) THEN REPEAT strip_tac);
a(all_fc_tac[one_one_left_inv_thm]);
a(∂_tac¨gÆ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(lemma_tac¨∂z∑ y = f zÆ THEN asm_rewrite_tac[]);
val €one_one_onto_inv_thm› = save_pop_thm"one_one_onto_inv_thm";
=TEX
\section{LEMMAS CONCERNED WITH DEFINING RECURSIVE TYPES}
This section supplies some lemmas which assist in defining recursive types.
We are concerned with providing guidelines supported by theorems rather than a fully automatic approach.
The point of view we take is more like that of \cite{Arthan91} than the universal-algebraic view of \cite{Melham89}.
Both of those references are mainly concerned with recursive types which arise from what are called finitary inductive definitions (this is explicit in \cite{Arthan91} and implicit in \cite{Melham89}).
The advantage of Melham's universal algebra point of view is that it leads directly to principles justifying definitions over the recursive type (indeed it begins from such principles);
unfortunately, it is not particularly easy to represent the universal algebra concepts in HOL and even when one has done so, the rules for introduction of new constants in HOL prohibit one from using a universal mapping property as a defining property, so one must use explicit abstraction and representation functions to define the constructors etc. even though there definitions are never needed later.

For the present treatment, we make full use of the assumption that the recursive type is defined by a finitary inductive definition.
Intuitively, finitariness means that if we start owning nothing and iterate the process of of applying the constructor functions for the type to everything we own already, we end up acquiring each element of the free type after some {\em finite} number of iterations (although we will need to iterate for ever to get everything).
So, to begin with, we assume that we are given the data shown in the following diagrams:


{\def\normalisebaselines{\baselineskip20pt
  \lineskip3pt \lineskiplimit3pt}
\def\mapright#1{\smash{
    \mathop{\longrightarrow}\limits^{#1}}}
\def\mapdown#1{\Big\downarrow
    \rlap{$\vcenter{\hbox{$\scriptstyle#1$}}$}}

$$\matrix{%
	'T		& \mapright{k}	& 'D\cr
\mapdown{c}			&		& \mapdown{w}\cr
	'T\,SET		& 		& Ó}$$
$$\matrix{%
	('T \rightarrow\ 'y)	& \mapright{M}	& ('D \rightarrow\ 'Y)}$$}

In the first diagram, $k$ is intended to be the constructor function for the free type.
Thus $'T$ is the free type itself, and $'D$ is the domain type of the constructor function.
If we are concerned with free types given as disjoint unions, then $'D$ is to be the relevant disjoint union, so that there is just {\em one} constructor function.
In {\ProductML} terms, $k$ is analogous, for example, to the generalised constructor function $mk\_simple\_type$ rather than the pair of constructors $mk\_vartype$ and $mk\_ctype$.
$c$ is to be a function which maps an element, $x$ say, in the domain of the constructor function to the set of elements of $'a$ out of which $x$ is constructed
(cf. the function {\sf contents} used in \cite{Arthan91}).
In terms in the iterative construction of the free type described abov,
$w(t)$ tells when we are going to acquire $t$.
We refer to $c$ and $w$ as the {\em content} and {\em weight} functions, respectively.

In the second diagram, $'y$ represents a type to serve as the codomain of a recursive function on $'T$.
In the applications, $'D$, will in fact be obtained from $'T$ by applying some combination of type constructors (typically, constant types, product, disjoint union and the list type constructor).
$'Y$ stands for the corresponding type construction applied to $'Y$.
$M$ is intended to be the functional which lifts a function, $f$, from $'T$ to $'y$ to the corresponding function $M(f)$, from $'D$ to $'Y$, where $M(f)$ works by applying $f$ to the $'T$ components of an element of $'D$. (N.B. in general, no appropriate $M$ need exist, however, there will be a suitable $M$ in the case of all the typical type constructors we have just listed).

In fact, the theory we will develop below does not very much on the fine tuning of the weight and content functions. For example, $c(x)$ may give either every constituent of $x$ or just the immediate constituents.
The following polymorphic set of quadruples describes what we will require:


πHOLCONST
‹	FinitaryRecType : (
‹			('D ≠ 'T)
‹		∏	('D ≠ 'T SET)
‹		∏	('T ≠ Ó)
‹		∏	(('T ≠ 'y) ≠ ('D ≠ 'Y))) SET
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	FinitaryRecType =
‹	{	(k, c, w, M)
‹	|	OneOne k
‹	±	(µt:'T∑ ∂x:'D∑ c(x) Ä {z | w(z) < w(t)} ± t = k(x))
‹	±	(µi gâ1 gâ2∑ (µy∑ w(y) < i ¥ gâ1(y) = gâ2(y))
‹			¥ µx∑ c(x) Ä {y | w(y) < i} ¥ M(gâ1)(x) = M(gâ2)(x))}
∞

I.e., to we will require the constructor function to be one-to-one and that every element, $t$, of $'T$ can be obtained by applying the constructor function to some $x$ whose contents have strictly smaller weight than that of $t$.
We also require a kind of monotonicity property on $M$, telling us that if two functions agree on elements up to a certain weight then so does their lifting under $M$.

We can derive an induction principle from the above assumptions by course-of-values induction on the value of the weight function:

=SML
set_goal([], ¨µk c w∑ (k, c, w, M) ç FinitaryRecType ¥
	µX: 'T SET∑
		(µx: 'D∑ c(x) Ä X ¥ k(x) ç X)
	¥	µt : 'T∑ t ç X
Æ);
a(rewrite_tac[get_spec¨FinitaryRecTypeÆ] THEN REPEAT strip_tac);
a(lemma_tac¨∂i∑ w(t) = iÆ THEN1 prove_∂_tac);
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨tÆ, ¨tÆ) THEN cov_induction_tac¨iÆ);
a(REPEAT strip_tac);
a(spec_nth_asm_tac 5 ¨tÆ THEN all_var_elim_asm_tac1);
a(lemma_tac¨c x Ä XÆ);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
a(spec_nth_asm_tac 4 ¨w x'Æ);
a(spec_nth_asm_tac 1 ¨x'Æ);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
val €fin_rec_type_induction_thm› = save_pop_thm"fin_rec_type_induction_thm";
=TEX
Somewhat analogously, we can use the principle of definition by primitive recursion for the natural numbers to derive a definitional principle for the recursive type.
Just to keep the proofs short we prove a lemma first.
The function $d$ here is the data for a primitive recursive definition.

=SML
set_goal([], ¨µk c w∑ (k, c, w, M) ç FinitaryRecType ¥
	∂ƒ∑
	(µ x∑ ƒ (k x) = x)
±	(µ y∑ k (ƒ y) = y)
±	µd: 'D  ∏'Y ≠ 'y∑
	∂ H : Ó ≠ 'T ≠ 'y ∑
	(µy∑	H 0 y = d(ƒ(y), M Arbitrary (ƒ y)))
±	(µi y∑	H(i + 1) y = if w(y) º i then H(i)(y) else d(ƒ(y), M (H i) (ƒ y)))
±	(µj∑ µ y∑ (H (w y + j)) y = H (w y) y)Æ);
a(rewrite_tac[get_spec¨FinitaryRecTypeÆ] THEN REPEAT strip_tac);
a(lemma_tac¨Onto kÆ THEN1 (rewrite_tac[get_spec¨OntoÆ] THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 2 ¨yÆ);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(all_fc_tac[one_one_onto_inv_thm]);
a(∂_tac¨gÆ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(lemma_tac¨∂H∑µy∑
	H 0 y = d(g(y), M Arbitrary (g y)) ±
µi∑	H(i + 1) y = if w(y) º i then H(i)(y) else d(g(y), M (H i) (g y))Æ
	THEN1 prove_∂_tac);
a(∂_tac¨HÆ THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(induction_tac ¨jÆ);
(* *** Goal "2.1" *** *)
a(PC_T1 "hol2" rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[plus_assoc_thm1]);
val €fin_rec_type_prim_rec_lemma1› = save_pop_thm"fin_rec_type_prim_rec_lemma1";
=TEX
=SML
set_goal([], ¨µk c w∑ (k, c, w, M) ç FinitaryRecType ¥
	µd: 'D  ∏'Y ≠ 'y∑
	∂ h : 'T ≠ 'y ∑ µx:'D∑ h(k(x)) = d(x, M h x)
Æ);
a(REPEAT strip_tac THEN all_fc_tac[fin_rec_type_prim_rec_lemma1]);
a(POP_ASM_T (strip_asm_tac o µ_elim¨dÆ));
a(DROP_ASM_T ¨(k, c, w, M) ç FinitaryRecTypeÆ
	(strip_asm_tac o rewrite_rule[get_spec¨FinitaryRecTypeÆ]));
a(∂_tac¨Ãy∑H (w(y)) yÆ THEN rewrite_tac[] THEN REPEAT strip_tac);
a(spec_nth_asm_tac 2 ¨k xÆ);
a(POP_ASM_T (strip_asm_tac o eq_sym_rule));
a(lemma_tac¨OneOne k ¥ k x' = k x ¥ x' = xÆ THEN1 prove_tac[get_spec¨OneOneÆ]);
a(var_elim_nth_asm_tac 1);
a(strip_asm_tac(µ_elim¨w (k x)Æ Ó_cases_thm));
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
a(SPEC_NTH_ASM_T 3 ¨0Æ ante_tac);
a(PC_T1 "hol2" rewrite_tac[]);
a(lemma_tac¨c x Ä {z|w z < w (k x)} ¥ c x = {}Æ
	THEN1 (LIST_GET_NTH_ASM_T [1] (PC_T1 "hol2" prove_tac)));
a strip_tac;
a(LIST_SPEC_NTH_ASM_T 1 [¨Arbitrary: 'T ≠ 'yÆ, ¨Ã y∑ H (w y) yÆ, ¨xÆ] ante_tac);
a(GET_NTH_ASM_T 2 rewrite_thm_tac THEN STRIP_T rewrite_thm_tac);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
a(LEMMA_T ¨M (H i) x = M (Ã y∑ H (w y) y) xÆ rewrite_thm_tac);
a(LIST_SPEC_NTH_ASM_T 3 [¨w(k x)Æ, ¨H iÆ, ¨Ã y∑ H (w y) yÆ] ante_tac);
a(LEMMA_T¨µ y∑ w y < w (k x) ¥ H i y = (Ã y∑ H (w y) y) yÆ rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(TOP_ASM_T rewrite_thm_tac THEN REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule(map get_spec[¨$<Æ, ¨$ºÆ])));
a(POP_ASM_T (asm_rewrite_thm_tac o eq_sym_rule));
(* *** Goal "2.2" *** *)
a strip_tac;
a(spec_nth_asm_tac 1 ¨xÆ);
val €fin_rec_type_prim_rec_thm› = save_pop_thm"fin_rec_type_prim_rec_thm";
=TEX
\section{TREES}
=TEX
πHOLCONST
‹	Tree : (Ó ∏ 'a) LIST 
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Tree =
‹	•{	A
‹	|	µlab : 'a; trees : (Ó ∏ 'a) LIST LIST∑
‹			Elems trees Ä A ¥
‹			Cons (Length trees, lab) (Flat trees) ç A}
∞

=SML
set_goal([], ¨µX∑
	(µx ts∑ (Elems ts Ä  X)
			¥ (Cons (Length ts, x) (Flat ts)) ç X)
	¥	Tree Ä X
Æ);
a(PC_T1 "sets_ext" rewrite_tac[get_spec¨TreeÆ] THEN REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨XÆ);
a(list_spec_nth_asm_tac 4 [¨labÆ, ¨treesÆ]);
a(all_asm_fc_tac[]);
val €tree_induction_lemma1› = save_pop_thm"tree_induction_lemma1";
=TEX
=SML
set_goal([], ¨
	µx ts∑ Elems ts Ä Tree ¥ Cons (Length ts, x) (Flat ts) ç Tree
Æ);
a(PC_T1 "sets_ext" rewrite_tac[get_spec¨TreeÆ] THEN REPEAT strip_tac);
a(list_spec_nth_asm_tac 1 [¨xÆ, ¨tsÆ]);
a(all_asm_fc_tac[]);
val €tree_induction_lemma2› = save_pop_thm"tree_induction_lemma2";
=TEX
=SML
set_goal([], ¨µX∑
	(µx ts∑ Elems ts Ä Tree ° X ¥ (Cons(Length ts, x) (Flat ts)) ç X)
	¥	Tree Ä X
Æ);
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨Tree ° XÆ tree_induction_lemma1));
(* *** Goal "1" *** *)
a(lemma_tac¨Elems ts Ä Tree ° X ¥ Elems ts Ä TreeÆ THEN1 
	PC_T1 "sets_ext" prove_tac[]);
a(all_fc_tac[tree_induction_lemma2] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext" prove_tac[]);
val €tree_induction_lemma› = save_pop_thm"tree_induction_lemma";
=TEX
Now recast the above for use with the induction tactic generating function.
=SML
set_goal([], ¨µP∑
	(µx ts∑ (µt∑ t ç Elems ts ¥ t ç Tree ± P t)
		¥ P (Cons(Length ts, x) (Flat ts)))
	¥	µt∑t ç Tree ¥ P t
Æ);
a(strip_tac);
a(ante_tac(µ_elim¨{t | P t}Æ tree_induction_lemma));
a(PC_T1 "sets_ext" rewrite_tac[]);
val €tree_induction_thm› = save_pop_thm"tree_induction_thm";
=TEX
=SML
set_goal([], ¨µt∑ t ç Tree ¥
	∂x; ts∑ Elems ts Ä Tree ± t = Cons (Length ts, x) (Flat ts)Æ);
a(µ_tac THEN gen_induction_tac1 tree_induction_thm);
a(∂_tac¨xÆ THEN ∂_tac¨tsÆ THEN PC_T "sets_ext" contr_tac THEN all_asm_fc_tac[]);
val €tree_cases_lemma› = save_pop_thm"tree_cases_lemma";
=TEX
=SML
set_goal([], ¨≥ [] ç TreeÆ);
a(lemma_tac¨µt∑t ç Tree ¥ ≥t = []Æ THEN_LIST[id_tac, asm_prove_tac[]]);
a(µ_tac THEN gen_induction_tac1 tree_induction_thm);
a(rewrite_tac[]);
val €≥_empty_list_tree_lemma› = save_pop_thm"≥_empty_list_tree_lemma";
=TEX
πHOLCONST
‹	Unparse : (Ó ∏ 'a) LIST ≠ Ó ≠ (Ó ∏ 'a) LIST
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹µi nv more∑
‹	Unparse [] i = []
‹±	Unparse (Cons nv more) i =
‹	if	i = 0
‹	then	[]
‹	else	Cons nv (Unparse more ((Fst nv + i) - 1))
∞
=TEX
=SML
set_goal([], ¨µts more∑
	Elems ts Ä Tree ¥
	Unparse (Flat ts Î more) (Length ts) = Flat ts
Æ);
a(REPEAT µ_tac);
a(lemma_tac¨∂tm∑ Flat ts Î more = tmÆ THEN_LIST [prove_∂_tac, all_asm_ante_tac]);
a(intro_µ_tac(¨tsÆ, ¨tsÆ) THEN list_induction_tac¨tmÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[Î_empty_thm, flat_empty_thm] THEN REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨tsÆ list_cases_thm) THEN all_var_elim_asm_tac1
	THEN rewrite_tac(map get_spec[¨UnparseÆ, ¨LengthÆ, ¨$AppendÆ, ¨FlatÆ]));
a(i_contr_tac THEN all_asm_ante_tac);
a(PC_T1 "sets_ext1" rewrite_tac(map get_spec[¨ElemsÆ]) THEN REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨xÆ);
a(∂_tac ¨xÆ THEN asm_rewrite_tac[≥_empty_list_tree_lemma]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨tsÆ list_cases_thm) THEN all_var_elim_asm_tac1
	THEN rewrite_tac(map get_spec[¨UnparseÆ, ¨LengthÆ, ¨$AppendÆ, ¨FlatÆ]));
(* *** Goal "2.1" *** *)
a(strip_asm_tac(µ_elim¨moreÆ list_cases_thm) THEN all_var_elim_asm_tac1
	THEN rewrite_tac(map get_spec[¨UnparseÆ]));
(* *** Goal "2.2" *** *)
a(lemma_tac¨Elems (Cons x' list2) Ä Tree ¥ x' ç TreeÆ
	THEN1 PC_T1 "sets_ext1" prove_tac[get_spec¨ElemsÆ]);
a(all_fc_tac[tree_cases_lemma]);
a(var_elim_nth_asm_tac 1);
a(all_asm_ante_tac THEN
	rewrite_tac(map get_spec[¨$AppendÆ, ¨FlatÆ, ¨ElemsÆ, ¨UnparseÆ]));
a(rewrite_tac[prove_rule[flat_append_thm]
	¨Flat ts Î Flat list2 = Flat(ts Î list2)Æ]);
a(REPEAT strip_tac);
a(lemma_tac¨Elems(ts Î list2) Ä TreeÆ
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[elems_append_thm]);
a(all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac[plus_assoc_thm1, length_append_thm]);
val €unparse_thm› = save_pop_thm"unparse_thm";
=TEX
=SML
set_goal([], ¨µt more∑ t ç Tree ¥ Unparse (t Î more) 1 = tÆ);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨[t]Æ, ¨moreÆ] unparse_thm));
a(rewrite_tac(append_empty_thm :: map get_spec[¨ElemsÆ, ¨LengthÆ, ¨FlatÆ]));
a(PC_T1 "sets_ext1" asm_prove_tac[]);
val €unparse_thm1› = save_pop_thm"unparse_thm1";
=TEX
=SML
set_goal([], ¨µt∑ t ç Tree ¥
	∂â1(x, ts)∑ Elems ts Ä Tree ± t = Cons (Length ts, x) (Flat ts)Æ);
a(REPEAT strip_tac THEN all_fc_tac[tree_cases_lemma]);
a(∂â1_tac¨(x, ts)Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(REPEAT all_var_elim_asm_tac1);
a(REPEAT strip_tac);
(* *** Goal "2" *** *)
a(REPEAT all_var_elim_asm_tac1);
a(REPEAT_N 4 (POP_ASM_T ante_tac) THEN POP_ASM_T discard_tac);
a(intro_µ_tac(¨tsÆ, ¨tsÆ) THEN list_induction_tac¨ts'Æ);
(* *** Goal "2.1" *** *)
a(rewrite_tac[get_spec¨LengthÆ, length_0_thm]);
a(prove_tac[]);
(* *** Goal "2.2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨tsÆ list_cases_thm) THEN all_var_elim_asm_tac1);
(* *** Goal "2.2.1" *** *)
a(GET_NTH_ASM_T 2 ante_tac THEN rewrite_tac[get_spec¨LengthÆ, length_0_thm]);
(* *** Goal "2.2.2" *** *)
a(lemma_tac¨x = x'Æ THEN all_asm_ante_tac
	THEN rewrite_tac(
		pc_rule1"sets_ext1" prove_rule[]
			¨µz a b∑ {z} ¿ a Ä b § z ç b ± a Ä bÆ ::
		map get_spec[¨FlatÆ, ¨ElemsÆ, ¨LengthÆ])
	THEN REPEAT strip_tac);
(* *** Goal "2.2.2.1" *** *)
a(LEMMA_T ¨Unparse(x Î Flat ts') 1 = Unparse(x' Î Flat list2) 1Æ ante_tac THEN1
		asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[unparse_thm1]);
(* *** Goal "2.2.2.2" *** *)
a(var_elim_nth_asm_tac 1);
a(POP_ASM_T ante_tac THEN rewrite_tac[append_cancel_thm] THEN strip_tac);
a(all_asm_fc_tac[]);
val €tree_cases_lemma1› = save_pop_thm"tree_cases_lemma1";
=TEX
=SML
set_goal([], ¨µx∑[(0, x)] ç TreeÆ);
a(rewrite_tac[get_spec¨TreeÆ] THEN REPEAT strip_tac);
a(POP_ASM_T (ante_tac o list_µ_elim[¨xÆ, ¨[]: (Ó ∏ 'a) LIST LISTÆ]));
a(PC_T1 "sets_ext" rewrite_tac(map get_spec [¨ElemsÆ, ¨FlatÆ, ¨LengthÆ]));
val €leaf_is_a_tree_thm› = save_pop_thm"leaf_is_a_tree_thm";
=TEX
=IGN =SML
=IGN set_goal([], ¨∂con args∑µt∑
=IGN 	t ç Tree ¥
=IGN 	Elems (args t) Ä Tree ± Cons (Length (args t), con t) (Flat (args t)) = t
=IGN Æ);
=IGN a(prove_∂_tac THEN REPEAT strip_tac);
=IGN a(cases_tac¨t'' ç TreeÆ THEN asm_rewrite_tac[]);
=IGN a(all_fc_tac[tree_cases_lemma]);
=IGN a(all_var_elim_asm_tac1);
=IGN a(∂_tac¨tsÆ THEN ∂_tac¨xÆ THEN REPEAT strip_tac);
=IGN val €con_args_lemma› = save_pop_thm"con_args_lemma";
=TEX
\section{DEFINING THE TYPE OF TREES}
=SML
val €tree_def› = new_type_defn(["TREE", "tree_def"], "TREE", ["'a"],
	tac_proof( ([], ¨∂tr∑ (Ãt∑ t ç Tree) trÆ), 
		asm_tac leaf_is_a_tree_thm THEN asm_prove_tac[]));
=TEX
πHOLCONST
‹	MkTree : ('a ∏ ('a TREE LIST)) ≠ 'a TREE
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	OneOne MkTree ±
‹	(∂w: 'a TREE ≠ Ó∑
‹		µt∑ ∂x∑ (µz∑ z ç Elems(Snd x) ¥ w z < w t) ± t = MkTree x)
∞
=TEX
=SML
=IGN
push_consistency_goal¨MkTreeÆ;
a((strip_asm_tac o rewrite_rule[]) (¥_match_mp_rule type_lemmas_thm tree_def));
a(∂_tac¨Ã(x, ts)∑ abs(Cons (Length ts, x) (Flat (Map rep ts)))Æ
	THEN rewrite_tac[get_spec¨OneOneÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨µl∑ Elems (Map rep l) Ä TreeÆ THEN1 strip_tac);
(* *** Goal "1.1" *** *)
a(list_induction_tac ¨lÆ THEN
	rewrite_tac(map get_spec[¨ElemsÆ, ¨MapÆ]));
a(strip_tac THEN asm_rewrite_tac[
	pc_rule1"sets_ext" prove_rule[]¨µa b c∑a ¿ b Ä c § a Ä c ± b Ä cÆ]);
a(PC_T1 "sets_ext" REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(spec_nth_asm_tac 1 ¨Snd x2Æ);
a(spec_nth_asm_tac 2 ¨Snd x1Æ);
a(all_fc_tac[tree_induction_lemma2]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[length_map_thm] o µ_elim¨Fst x2Æ));
a(all_fc_tac[tree_cases_lemma1]);
a(DROP_NTH_ASM_T 7
	(strip_asm_tac o rewrite_rule[length_map_thm] o µ_elim¨Fst x1Æ));
a(LIST_GET_NTH_ASM_T [12] all_fc_tac);
a(LEMMA_T¨rep(abs (Cons (# (Snd x1), Fst x1) (Flat (Map rep (Snd x1)))))
             = rep(abs (Cons (# (Snd x2), Fst x2) (Flat (Map rep (Snd x2)))))Æ
	ante_tac THEN1 LIST_GET_NTH_ASM_T [13] rewrite_tac);
a(LIST_GET_NTH_ASM_T [1,2] rewrite_tac THEN strip_tac);
a(GET_NTH_ASM_T 7 (ante_tac o list_µ_elim[¨Fst x2Æ, ¨Map rep (Snd x2)Æ]));
a(DROP_NTH_ASM_T 7 (ante_tac o list_µ_elim[¨Fst x1Æ, ¨Map rep (Snd x1)Æ]));
a(asm_rewrite_tac[length_map_thm] THEN REPEAT strip_tac);
a(LEMMA_T¨Map abs(Map rep (Snd x1)) = Map abs(Map rep (Snd x2))Æ
	ante_tac THEN1 asm_rewrite_tac[]);
a(lemma_tac¨
	(µx∑x ç Elems (Snd x1) ¥ abs(rep x) = x) ±
	(µx∑x ç Elems (Snd x2) ¥ abs(rep x) = x)Æ THEN1 asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac [map_map_id_thm]);
a(asm_ante_tac¨Fst x1 = Fst x2Æ THEN PC_T1 "prop_eq_pair" prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨Ãt∑ Length(rep t)Æ THEN rewrite_tac[] THEN REPEAT strip_tac);
a(lemma_tac¨rep t ç TreeÆ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[tree_cases_lemma]);
a(∂_tac¨(x, Map abs ts)Æ THEN rewrite_tac[length_map_thm]);
a(DROP_ASM_T ¨Elems ts Ä TreeÆ ante_tac THEN PC_T1 "sets_ext1" asm_rewrite_tac[]);
a(strip_tac THEN ALL_FC_T rewrite_tac[map_map_id_thm]);
a(GET_NTH_ASM_T 2 (rewrite_thm_tac o eq_sym_rule));
a(GET_NTH_ASM_T 5 rewrite_thm_tac);
a(rewrite_tac[elems_map_thm]);
a(REPEAT strip_tac);
a(var_elim_nth_asm_tac 1);
a(ALL_ASM_FC_T asm_rewrite_tac[]);
a(rewrite_tac[get_spec¨LengthÆ]);
a(all_fc_tac[length_length_flat_thm]);
a(PC_T1 "lin_arith" asm_prove_tac[]);
val _ = save_consistency_thm ¨MkTreeÆ (pop_thm());
=TEX
=SML
=TEX
\section{CLOSING DOWN}
The following \Product{} instruction restores the previous proof context.
=SML
pop_pc();
=TEX
=IGN
output_theory{theory = "wrk057",out_file = "wrk057th.doc"};
=TEX
\newpage
\HOLindexOff
\input{wrk057th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}

=SML
val up_conv = PC_C1 "hol2" rewrite_conv[get_spec¨UnparseÆ];

up_conv¨Unparse [(0, x)] 1Æ			(* x --> x *);
up_conv¨Unparse [(0, x)] 0Æ			(* x --> () *);
up_conv¨Unparse [(1, x); (0, y)] 1Æ		(* x(y) --> x(y) *);
up_conv¨Unparse [(1, x); (0, y); (0, z)] 1Æ	(* x(y); z() --> x(y) *);
up_conv¨Unparse [(2, x); (0, y); (1, z); (0, y); (0, a)] 1Æ
				(* x(y, z(y)); a --> x(y, z(y)) *);
up_conv¨Unparse [(3, x); (0, y); (1, z); (0, y); (0, a); (0, c); (0, d)] 1Æ
				(* x(y, z(y), a); c; d --> c; d *);
up_conv¨Unparse [(3, x); (0, y); (1, z); (0, y); (0, a); (0, c); (0, d)] 2Æ
				(* x(y, z(y), a); c; d --> x(y, z(y), a); c *);
up_conv¨Unparse [(3, x); (0, y); (1, z); (0, y); (0, a); (1, c); (1, e); (0, f); (0, d)] 2Æ
				(* x(y, z(y), a); c(e(f)); d --> x(y, z(y), a); c(e(f)) *);
a(LIST_GET_NTH_ASM_T [5] rewrite_tac);
a(∂_tac¨(x, list2)Æ THEN rewrite_tac[]);
a(∂_tac¨(x, Map abs ts)Æ THEN rewrite_tac[]);
a(asm_rewrite_tac[] THEN strip_tac);
a(POP_ASM_T (asm_rewrite_thm_tac o eq_sym_rule));
