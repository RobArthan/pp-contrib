=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\def\Note#1{{\small\bf[Note: #1]}}
\makeindex
\TPPproject{{\Product}}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Examples of HOL Type Definitions}  %% Mandatory field
\TPPref{DS/FMU/IED/WRK057}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.~D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPabstract{Examples of HOL Type Definitions.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library \\
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}}) ] First draft. 

\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}

\subsection{Introduction}


\subsection{Setting Up}
The following \Product{} instructions set up the new theory $wrk057$ and set the context 
for the proof tools..
=SML
open_theory"fin_thms";
(force_delete_theory "wrk057" handle _ => ());
new_theory €"wrk057"›;
push_pc "hol";
=TEX
\section{SOME GENERAL THEOREMS}
=SML
set_goal([], ¨µp j∑
	TypeDefn p j ¥
	(∂ abs∑ (µ a∑ abs (j a) = a) ± (µ r∑ p r § j (abs r) = r))
Æ);
a(rewrite_tac(map get_spec[¨TypeDefnÆ, ¨OneOneÆ]) THEN REPEAT strip_tac);
a(lemma_tac¨∂abs∑ µx∑ p x ¥ j(abs x) = xÆ);
(* *** Goal "1" *** *)
a(prove_∂_tac THEN REPEAT strip_tac);
a(cases_tac¨p x'Æ THEN asm_rewrite_tac[]);
a(all_asm_fc_tac[]);
a(∂_tac¨yÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨absÆ THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(lemma_tac ¨j(abs (j a)) = j aÆ THEN_LIST
	[POP_ASM_T bc_thm_tac, all_asm_fc_tac[]]);
a(asm_rewrite_tac[] THEN prove_tac[]);
(* *** Goal "2.2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.3" *** *)
a(asm_rewrite_tac[]);
a(∂_tac ¨abs rÆ THEN asm_rewrite_tac[]);
val €type_defn_abs_thm› = save_pop_thm"type_defn_abs_thm";
=SML
set_goal([], ¨
	µP : 'B ≠ BOOL; p : 'b ≠ BOOL; J : 'A ≠ 'B; j : 'a ≠ 'b; k : 'B ≠ 'b∑
		TypeDefn P J ± TypeDefn p j ± (µx∑ P x ¥ p(k x)) ¥
		∂â1 K : 'A ≠ 'a∑ µz∑ j(K z) = k (J z)
Æ);
a(REPEAT strip_tac);
a(all_fc_tac[type_defn_abs_thm]);
a(rename_tac[(¨abs'Æ, "ABS")]);
a(∂â1_tac¨abs o k o JÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[]);
a(lemma_tac¨p(k (J z))Æ THEN_LIST [id_tac, ALL_ASM_FC_T rewrite_tac[]]);
a(lemma_tac¨P (J z)Æ THEN_LIST [asm_rewrite_tac[], ALL_ASM_FC_T rewrite_tac[]]);
(* *** Goal "2" *** *)
a(PC_T1 "hol2" rewrite_tac[] THEN REPEAT strip_tac);
a(LEMMA_T¨abs(j (K' x)) = abs(j(abs (k (J x))))Æ
	(fn th => ante_tac th THEN asm_rewrite_tac[]));
a(POP_ASM_T rewrite_thm_tac);
a(asm_rewrite_tac[]);
val €type_defn_constructor_thm› = save_pop_thm"type_defn_constructor_thm";
=TEX
=SML
set_goal([], ¨
µ	P : 'B ≠ BOOL; p : 'b ≠ BOOL;
	J : 'A ≠ 'B; j : 'a ≠ 'b; K : 'A ≠ 'a; k : 'B ≠ 'b;
	Mâbây : ('b ≠ 'y) ≠ ('B ≠ 'Y); Mâaây : ('a ≠ 'y) ≠ ('A ≠ 'Y);
	Mâaâb : ('a ≠ 'b) ≠ ('A ≠ 'B)∑
	TypeDefn P J ± TypeDefn p j ±
	Mâaâb j = J ±
	(µe : 'b ≠ 'y;  f : 'a ≠ 'b∑ Mâaây(e o f) = Mâbây e o Mâaâb f) ±
	(µx∑ P x ¥ p(k x)) ± (µz∑ j(K z) = k (J z)) ±
	(µc : 'B ∏ 'Y ≠ 'y∑ ∂g : 'b ≠ 'y∑
		(µz : 'B∑P z ¥ g (k z) = c(z, Mâbây g z)) ±
		(µG∑	(µz : 'B∑P z ¥ G (k z) = c(z, Mâbây G z))
		¥	(µv : 'b∑p v ¥ G v = g v)))
¥	(µd : 'A ∏ 'Y ≠ 'y∑
		∂â1h : 'a ≠ 'y∑ µx : 'A∑ h(K x) = d(x, Mâaây h x))
Æ);
a(REPEAT strip_tac);
a(all_fc_tac[type_defn_abs_thm]);
a(rename_tac[(¨abs'Æ, "ABS")]);
a(spec_nth_asm_tac 5 ¨Ã(v, w)∑ d(ABS v, w)Æ);
a(∂â1_tac¨g o jÆ THEN POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN
	asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨J(ABS (J x)) = J xÆ THEN1 asm_rewrite_tac[]);
a(ALL_ASM_FC_T rewrite_tac[]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T¨Mâaây ((h' o abs) o j) = Mâbây(h' o abs) o JÆ ante_tac
	THEN1 asm_rewrite_tac[]);
a(LEMMA_T¨(h' o abs) o j = h'Æ rewrite_thm_tac
	THEN1 PC_T1 "hol2" asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(lemma_tac¨µz : 'B∑J (ABS z) = z ¥ (h' o abs) (k z) = d(ABS z, Mâbây (h' o abs) z)Æ);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(rewrite_tac[]);
a(LEMMA_T¨abs(k z) = abs(k(J(ABS z)))Æ rewrite_thm_tac
	THEN1 asm_rewrite_tac[]);
a(LEMMA_T¨k(J(ABS z)) = j(K(ABS z))Æ rewrite_thm_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 4 (ante_tac o µ_elim¨h' o absÆ));
a(TOP_ASM_T rewrite_thm_tac);
a(PC_T1 "hol2" REPEAT strip_tac);
a(POP_ASM_T (ante_tac o µ_elim¨j xÆ));
a(asm_rewrite_tac[]);
val €type_defn_rec_thm› = save_pop_thm"type_defn_rec_thm";
=TEX
=SML
set_goal([], ¨
µ	P : 'B ≠ BOOL; p : 'b ≠ BOOL;
	J : 'A ≠ 'B; j : 'a ≠ 'b; k : 'B ≠ 'b;
	Mâbây : ('b ≠ 'y) ≠ ('B ≠ 'Y); Mâaây : ('a ≠ 'y) ≠ ('A ≠ 'Y);
	Mâaâb : ('a ≠ 'b) ≠ ('A ≠ 'B)∑
	TypeDefn P J ± TypeDefn p j ±
	Mâaâb j = J ±
	(µe : 'b ≠ 'y;  f : 'a ≠ 'b∑ Mâaây(e o f) = Mâbây e o Mâaâb f) ±
	(µx∑ P x ¥ p(k x)) ±
	(µc : 'B ∏ 'Y ≠ 'y∑ ∂g : 'b ≠ 'y∑
		(µz : 'B∑P z ¥ g (k z) = c(z, Mâbây g z)) ±
		(µG∑	(µz : 'B∑P z ¥ G (k z) = c(z, Mâbây G z))
		¥	(µv : 'b∑p v ¥ G v = g v)))
¥	∂rec : ('A ∏ 'Y ≠ 'y) ≠ ('a ≠ 'y)∑
	∂K : 'A ≠ 'a∑
	µd : 'A ∏ 'Y ≠ 'y∑
		(µx∑ rec d (K x) = d(x, Mâaây (rec d) x)) ±
		µh : 'a ≠ 'y∑ (µx∑ h (K x) = d(x, Mâaây h x)) ¥ h = rec d
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨
	∂K : 'A ≠ 'a∑
	∂rec : ('A ∏ 'Y ≠ 'y) ≠ ('a ≠ 'y)∑
	µd : 'A ∏ 'Y ≠ 'y∑
		(µx∑ rec d (K x) = d(x, Mâaây (rec d) x)) ±
		µh : 'a ≠ 'y∑ (µx∑ h (K x) = d(x, Mâaây h x)) ¥ h = rec dÆ
	THEN_LIST [id_tac, ∂_tac¨recÆ THEN ∂_tac¨KÆ THEN asm_rewrite_tac[]]);
a(all_fc_tac[type_defn_constructor_thm]);
a(∂_tac¨KÆ THEN prove_∂_tac THEN REPEAT strip_tac);
a(all_fc_tac[type_defn_rec_thm]);
a(POP_ASM_T (strip_asm_tac o µ_elim¨d'Æ));
a(∂_tac¨hÆ THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(all_asm_fc_tac[]);
val €type_defn_rec_fun_thm› = save_pop_thm"type_defn_rec_fun_thm";
=TEX
\section{TREES}
=TEX
πHOLCONST
‹	Unparse : (Ó ∏ 'a) LIST ≠ Ó ≠ (Ó ∏ 'a) LIST
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹µi nv more∑
‹	Unparse [] i = []
‹±	Unparse (Cons nv more) i =
‹	if	i = 0
‹	then	[]
‹	else	Cons nv (Unparse more ((Fst nv + i) - 1))
∞

πHOLCONST
‹	Tree : (Ó ∏ 'a) LIST 
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Tree =
‹	•{	A
‹	|	µlab : 'a; trees : (Ó ∏ 'a) LIST LIST∑
‹			Elems trees Ä A ¥
‹			Cons (Length trees, lab) (Flat trees) ç A}
∞

=SML
set_goal([], ¨µP∑
	(µx ts∑ (µt∑ t ç Elems ts ¥  P t)
			¥ P (Cons (Length ts, x) (Flat ts)))
	¥	µt∑ t ç Tree ¥ P t
Æ);
a(rewrite_tac[get_spec¨TreeÆ] THEN REPEAT strip_tac);
a(PC_T1 "sets_ext" (spec_nth_asm_tac 1) ¨{x | P x}Æ);
a(list_spec_nth_asm_tac 4 [¨labÆ, ¨treesÆ]);
a(all_asm_fc_tac[]);
val €tree_induction_lemma1› = save_pop_thm"tree_induction_lemma1";
=TEX
=SML
set_goal([], ¨
	µx ts∑ (µt∑ t ç Elems ts ¥ t ç Tree)
			¥ Cons (Length ts, x) (Flat ts) ç Tree
Æ);
a(rewrite_tac[get_spec¨TreeÆ] THEN REPEAT strip_tac);
a(PC_T1 "sets_ext" (list_spec_nth_asm_tac 1) [¨xÆ, ¨tsÆ]);
a(all_asm_fc_tac[]);
val €tree_induction_lemma2› = save_pop_thm"tree_induction_lemma2";
=TEX
=SML
set_goal([], ¨µP∑
	(µx ts∑ (µt∑ t ç Elems ts ¥ t ç Tree ± P t)
			¥ P (Cons(Length ts, x) (Flat ts)))
	¥	µt∑ t ç Tree ¥ P t
Æ);
a(REPEAT strip_tac);
a(strip_asm_tac(rewrite_rule[](µ_elim¨Ãx∑ x ç Tree ± P xÆ tree_induction_lemma1)));
(* *** Goal "1" *** *)
a(lemma_tac¨µ t∑ t ç Elems ts ¥ t ç TreeÆ THEN1 (contr_tac THEN all_asm_fc_tac[]));
a(all_fc_tac[tree_induction_lemma2]);
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
val €tree_induction_lemma› = save_pop_thm"tree_induction_lemma";
=TEX
=SML
set_goal([], ¨µt∑ t ç Tree ¥
	∂x; ts∑ Elems ts Ä Tree ± t = Cons (Length ts, x) (Flat ts)Æ);
a(µ_tac THEN gen_induction_tac1 tree_induction_lemma);
a(∂_tac¨xÆ THEN ∂_tac¨tsÆ THEN PC_T "sets_ext" contr_tac THEN all_asm_fc_tac[]);
val €tree_cases_lemma› = save_pop_thm"tree_cases_lemma";
=TEX
=SML
set_goal([], ¨≥ [] ç TreeÆ);
a(lemma_tac¨µt∑t ç Tree ¥ ≥t = []Æ THEN_LIST[id_tac, asm_prove_tac[]]);
a(µ_tac THEN gen_induction_tac1 tree_induction_lemma);
a(rewrite_tac[]);
val €≥_empty_list_tree_lemma› = save_pop_thm"≥_empty_list_tree_lemma";
=TEX
=SML
push_goal([], ¨µl1 l2∑ l1 Î l2 = [] § l1 = [] ± l2 = []Æ);
a(µ_tac);
a(list_induction_tac¨l1Æ THEN rewrite_tac[append_def]);
val €Î_empty_thm› = save_pop_thm"Î_empty_thm";
=TEX
=SML
push_goal([], ¨µls∑ Flat ls = [] § Elems ls Ä {[]}Æ);
a(µ_tac);
a(list_induction_tac¨lsÆ THEN
	asm_rewrite_tac(Î_empty_thm :: map get_spec[¨ElemsÆ, ¨FlatÆ]));
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
val €flat_empty_thm› = save_pop_thm"flat_empty_thm";
=TEX
=SML
push_goal([], ¨µl1 l2 l3∑ (l1 Î l2) Î l3 = l1 Î l2 Î l3Æ);
a(µ_tac);
a(list_induction_tac¨l1Æ THEN asm_rewrite_tac(map get_spec[¨AppendÆ]));
val €append_assoc_thm› = save_pop_thm"append_assoc_thm";
=TEX
=SML
push_goal([], ¨µls1 ls2∑ Flat (ls1 Î ls2)  = Flat ls1 Î Flat ls2Æ);
a(µ_tac);
a(list_induction_tac¨ls1Æ THEN
	asm_rewrite_tac(append_assoc_thm :: map get_spec[¨FlatÆ, ¨AppendÆ]));
val €flat_append_thm› = save_pop_thm"flat_append_thm";
=TEX
=SML
push_goal([], ¨µls1 ls2∑ Length (ls1 Î ls2)  = Length ls1 + Length ls2Æ);
a(µ_tac);
a(list_induction_tac¨ls1Æ THEN
	asm_rewrite_tac(plus_assoc_thm :: map get_spec[¨LengthÆ, ¨AppendÆ]));
val €length_append_thm› = save_pop_thm"length_append_thm";
=TEX
=SML
push_goal([], ¨µl1 l2∑ Elems (l1 Î l2)  = Elems l1 ¿ Elems l2Æ);
a(µ_tac);
a(list_induction_tac¨l1Æ THEN
	asm_rewrite_tac(map get_spec[¨FlatÆ, ¨ElemsÆ, ¨AppendÆ]));
a(PC_T1 "sets_ext" prove_tac[]);
val €elems_append_thm› = save_pop_thm"elems_append_thm";
=TEX
=SML
push_goal([], ¨µl∑ l Î []  = lÆ);
a(µ_tac);
a(list_induction_tac¨lÆ THEN
	asm_rewrite_tac(map get_spec[¨AppendÆ]));
val €append_empty_thm› = save_pop_thm"append_empty_thm";
=TEX
=SML
push_goal([], ¨µl1 l2 l3∑ l1 Î l2  = l1 Î l3 § l2 = l3Æ);
a(µ_tac);
a(list_induction_tac¨l1Æ THEN
	asm_rewrite_tac(map get_spec[¨AppendÆ]));
val €append_cancel_thm› = save_pop_thm"append_cancel_thm";
=TEX
Following may not be needed:
=SML
push_goal([], ¨µl∑ Length l = 0 § l = []Æ);
a(µ_tac);
a(list_induction_tac¨lÆ THEN asm_rewrite_tac(map get_spec[¨LengthÆ]));
val €length_0_thm› = save_pop_thm"length_0_thm";
=TEX
=SML
set_goal([], ¨µts more∑
	Elems ts Ä Tree ¥
	Unparse (Flat ts Î more) (Length ts) = Flat ts
Æ);
a(REPEAT µ_tac);
a(lemma_tac¨∂tm∑ Flat ts Î more = tmÆ THEN_LIST [prove_∂_tac, all_asm_ante_tac]);
a(intro_µ_tac(¨tsÆ, ¨tsÆ) THEN list_induction_tac¨tmÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[Î_empty_thm, flat_empty_thm] THEN REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨tsÆ list_cases_thm) THEN all_var_elim_asm_tac1
	THEN rewrite_tac(map get_spec[¨UnparseÆ, ¨LengthÆ, ¨$AppendÆ, ¨FlatÆ]));
a(i_contr_tac THEN all_asm_ante_tac);
a(PC_T1 "sets_ext1" rewrite_tac(map get_spec[¨ElemsÆ]) THEN REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨xÆ);
a(∂_tac ¨xÆ THEN asm_rewrite_tac[≥_empty_list_tree_lemma]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨tsÆ list_cases_thm) THEN all_var_elim_asm_tac1
	THEN rewrite_tac(map get_spec[¨UnparseÆ, ¨LengthÆ, ¨$AppendÆ, ¨FlatÆ]));
(* *** Goal "2.1" *** *)
a(strip_asm_tac(µ_elim¨moreÆ list_cases_thm) THEN all_var_elim_asm_tac1
	THEN rewrite_tac(map get_spec[¨UnparseÆ]));
(* *** Goal "2.2" *** *)
a(lemma_tac¨Elems (Cons x' list2) Ä Tree ¥ x' ç TreeÆ
	THEN1 PC_T1 "sets_ext1" prove_tac[get_spec¨ElemsÆ]);
a(all_fc_tac[tree_cases_lemma]);
a(var_elim_nth_asm_tac 1);
a(all_asm_ante_tac THEN
	rewrite_tac(map get_spec[¨$AppendÆ, ¨FlatÆ, ¨ElemsÆ, ¨UnparseÆ]));
a(rewrite_tac[prove_rule[flat_append_thm]
	¨Flat ts Î Flat list2 = Flat(ts Î list2)Æ]);
a(REPEAT strip_tac);
a(lemma_tac¨Elems(ts Î list2) Ä TreeÆ
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[elems_append_thm]);
a(all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac[plus_assoc_thm1, length_append_thm]);
val €unparse_thm› = save_pop_thm"unparse_thm";
=TEX
=SML
set_goal([], ¨µt more∑ t ç Tree ¥ Unparse (t Î more) 1 = tÆ);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨[t]Æ, ¨moreÆ] unparse_thm));
a(rewrite_tac(append_empty_thm :: map get_spec[¨ElemsÆ, ¨LengthÆ, ¨FlatÆ]));
a(PC_T1 "sets_ext1" asm_prove_tac[]);
val €unparse_thm1› = save_pop_thm"unparse_thm1";
=TEX
=SML
set_goal([], ¨µt∑ t ç Tree ¥
	∂â1(x, ts)∑ Elems ts Ä Tree ± t = Cons (Length ts, x) (Flat ts)Æ);
a(REPEAT strip_tac THEN all_fc_tac[tree_cases_lemma]);
a(∂â1_tac¨(x, ts)Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(REPEAT all_var_elim_asm_tac1);
a(REPEAT strip_tac);
(* *** Goal "2" *** *)
a(REPEAT all_var_elim_asm_tac1);
a(REPEAT_N 4 (POP_ASM_T ante_tac) THEN POP_ASM_T discard_tac);
a(intro_µ_tac(¨tsÆ, ¨tsÆ) THEN list_induction_tac¨ts'Æ);
(* *** Goal "2.1" *** *)
a(rewrite_tac[get_spec¨LengthÆ, length_0_thm]);
a(prove_tac[]);
(* *** Goal "2.2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨tsÆ list_cases_thm) THEN all_var_elim_asm_tac1);
(* *** Goal "2.2.1" *** *)
a(GET_NTH_ASM_T 2 ante_tac THEN rewrite_tac[get_spec¨LengthÆ, length_0_thm]);
(* *** Goal "2.2.2" *** *)
a(lemma_tac¨x = x'Æ THEN all_asm_ante_tac
	THEN rewrite_tac(
		pc_rule1"sets_ext1" prove_rule[]
			¨µz a b∑ {z} ¿ a Ä b § z ç b ± a Ä bÆ ::
		map get_spec[¨FlatÆ, ¨ElemsÆ, ¨LengthÆ])
	THEN REPEAT strip_tac);
(* *** Goal "2.2.2.1" *** *)
a(LEMMA_T ¨Unparse(x Î Flat ts') 1 = Unparse(x' Î Flat list2) 1Æ ante_tac THEN1
		asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[unparse_thm1]);
(* *** Goal "2.2.2.2" *** *)
a(var_elim_nth_asm_tac 1);
a(POP_ASM_T ante_tac THEN rewrite_tac[append_cancel_thm] THEN strip_tac);
a(all_asm_fc_tac[]);
val €tree_cases_lemma1› = save_pop_thm"tree_cases_lemma1";
=TEX
=SML
set_goal([], ¨µx∑[(0, x)] ç TreeÆ);
a(rewrite_tac[get_spec¨TreeÆ] THEN REPEAT strip_tac);
a(POP_ASM_T (ante_tac o list_µ_elim[¨xÆ, ¨[]: (Ó ∏ 'a) LIST LISTÆ]));
a(PC_T1 "sets_ext" rewrite_tac(map get_spec [¨ElemsÆ, ¨FlatÆ, ¨LengthÆ]));
val €leaf_is_a_tree_thm› = save_pop_thm"leaf_is_a_tree_thm";
=TEX
=SML
set_goal([], ¨∂con args∑µt∑
	t ç Tree ¥
	Elems (args t) Ä Tree ± Cons (Length (args t), con t) (Flat (args t)) = t
Æ);
a(prove_∂_tac THEN REPEAT strip_tac);
a(cases_tac¨t'' ç TreeÆ THEN asm_rewrite_tac[]);
a(all_fc_tac[tree_cases_lemma]);
a(all_var_elim_asm_tac1);
a(∂_tac¨tsÆ THEN ∂_tac¨xÆ THEN REPEAT strip_tac);
val €con_args_lemma› = save_pop_thm"con_args_lemma";
=TEX
\section{DEFINING THE TYPE OF TREES}
=SML
val €tree_def› = new_type_defn(["TREE", "tree_def"], "TREE", ["'a"],
	tac_proof( ([], ¨∂tr∑ (Ãt∑ t ç Tree) trÆ), 
		asm_tac leaf_is_a_tree_thm THEN asm_prove_tac[]));
=TEX
=IGN πHOLCONST
=IGN ‹	AbsTree : (Ó ∏ 'a) LIST ≠ 'a TREE;
=IGN ‹	RepTree : 'a TREE ≠ (Ó ∏ 'a) LIST
=IGN ˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=IGN ‹	(µ a∑ AbsTree (RepTree a) = a) ±
=IGN ‹	(µ r∑ r ç Tree § RepTree (AbsTree r) = r)
=IGN ∞
πHOLCONST
‹	TreeRec : (('a ∏ ('a TREE LIST)) ∏ 'b LIST ≠ 'b) ≠ ('a TREE ≠ 'b)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	∂MkTree : ('a ∏ ('a TREE LIST)) ≠ 'a TREE∑
‹	µd : ('a ∏ ('a TREE LIST)) ∏ 'b LIST ≠ 'b∑
‹	(µx∑ TreeRec d (MkTree x) = d(x, Map (TreeRec d) (Snd x))) ±
‹	(µh∑ (µx∑ h (MkTree x) = d(x, Map h (Snd x))) ¥ h = TreeRec d)
∞
=IGN πHOLCONST
=IGN ‹	MkTree : ('a ∏ ('a TREE LIST)) ≠ 'a TREE;
=IGN ‹	DestTree : 'a TREE ≠ ('a ∏ ('a TREE LIST))
=IGN ˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=IGN ‹	(µ t∑ MkTree (DestTree t) = t) ±
=IGN ‹	(µ r∑ DestTree (MkTree r) = r) ±
=IGN ‹	µA: 'a TREE SET∑ (µx ts∑ Elems ts Ä A ¥ MkTree(x, ts) ç A) ¥ µt∑t ç A
=IGN ∞
=TEX
=SML
push_goal([], ¨µf g l∑(µx∑x ç Elems l ¥ f(g x) = x) ¥ Map f(Map g l) = lÆ);
a(REPEAT µ_tac);
a(list_induction_tac¨lÆ THEN PC_T1 "sets_ext1" asm_rewrite_tac(map get_spec
	[¨ElemsÆ, ¨MapÆ]));
(* *** Goal "1" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨xÆ THEN asm_rewrite_tac[]);
val €map_map_id_thm› = save_pop_thm"map_map_id_thm";
=TEX
=SML
push_goal([], ¨µf g A∑Elems (Map f l) = {y | ∂x∑ x ç Elems l ± f x = y}Æ);
a(REPEAT strip_tac);
a(list_induction_tac¨lÆ THEN PC_T1 "sets_ext1" asm_rewrite_tac(map get_spec
	[¨ElemsÆ, ¨MapÆ]) THEN PC_T1 "sets_ext1" REPEAT strip_tac
	THEN all_var_elim_asm_tac1 THEN asm_prove_tac[]);
val €elems_map_thm› = save_pop_thm"elems_map_thm";
=IGN
push_consistency_goal¨MkTreeÆ;
a((strip_asm_tac o rewrite_rule[]) (¥_match_mp_rule type_lemmas_thm tree_def));
a(strip_asm_tac(con_args_lemma));
a(∂_tac¨(
	(Ã(x, ts)∑ abs(Cons (Length ts, x) (Flat (Map rep ts)))),
	(Ãt∑ (con(rep t), Map abs (args (rep t)))))Æ
	THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T¨Cons
	(# (Map abs (args (rep t))), con (rep t))
	(Flat (Map rep (Map abs (args (rep t))))) =
	rep tÆ asm_rewrite_thm_tac);
a(lemma_tac¨rep t ç TreeÆ THEN1 asm_rewrite_tac[]);
a(LIST_GET_NTH_ASM_T [2] all_fc_tac);
a(DROP_NTH_ASM_T 2 ante_tac THEN PC_T1 "sets_ext" asm_rewrite_tac[]);
a(REPEAT strip_tac THEN ALL_FC_T rewrite_tac[map_map_id_thm]);
a(asm_rewrite_tac[length_map_thm]);
(* *** Goal "2" *** *)
a(lemma_tac¨∂(x, ts)∑r = (x, ts)Æ THEN1 (∂_tac ¨rÆ THEN rewrite_tac[]));
a(var_elim_nth_asm_tac 1 THEN rewrite_tac[]);
a(lemma_tac¨Elems (Map rep ts) Ä TreeÆ THEN1 asm_rewrite_tac[elems_map_thm]);
(* *** Goal "2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac
	THEN var_elim_nth_asm_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(TOP_ASM_T (PC_T1 "sets_ext1" strip_asm_tac));
a(all_fc_tac[tree_induction_lemma2]);
a(POP_ASM_T (ante_tac o µ_elim¨xÆ) THEN rewrite_tac[length_map_thm]
	THEN strip_tac);
a(LIST_GET_NTH_ASM_T [5] (ALL_FC_T rewrite_tac));
a(LIST_GET_NTH_ASM_T [4] all_fc_tac);
a(asm_rewrite_tac[]);
a(LEMMA_T ¨args (Cons (# ts, x) (Flat (Map rep ts))) = (Map rep ts)Æ
	rewrite_thm_tac);
(* *** Goal "2.2.1" *** *)
a(strip_asm_tac(µ_elim¨Cons (# ts, x) (Flat (Map rep ts))Æ tree_cases_lemma1));
a(var_elim_nth_asm_tac 3);
a(POP_ASM_T (ante_tac o list_µ_elim[¨con (Cons (# ts, x') (Flat (Map rep ts)))Æ,
	¨(args (Cons (# ts, x') (Flat (Map rep ts))))Æ]));
a(LIST_GET_NTH_ASM_T [7] rewrite_tac);
a(LIST_GET_NTH_ASM_T [6] rewrite_tac);
a(LIST_GET_NTH_ASM_T [5] rewrite_tac);
a(LIST_GET_NTH_ASM_T [4] rewrite_tac);


a(asm_rewrite_tac[]);


a(DROP_NTH_ASM_T 4 ante_tac THEN PC_T1 "sets_ext" asm_rewrite_tac[]);



a(REPEAT strip_tac THEN all_fc_tac[
(* *** Goal "1.1" *** *)
a(lemma_tac ¨Elems(Map rep (Map abs (args (rep t)))) Ä TreeÆ);
a(rewrite_tac[elems_map_thm] THEN PC_T1 "hol2" REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN asm_rewrite_tac[]);


a(lemma_tac ¨∂l∑ args (rep t) = lÆ THEN1 prove_∂_tac);
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN intro_µ_tac(¨tÆ, ¨tÆ)
	THEN list_induction_tac¨lÆ
	THEN REPEAT strip_tac
	THEN PC_T1 "sets_ext1" asm_rewrite_tac(map get_spec[¨ElemsÆ, ¨MapÆ]));

	
val _ = save_consistency_thm ¨AbsTreeÆ (pop_thm());
=TEX
=SML
push_consistency_goal¨MkTreeÆ;
a((strip_asm_tac o rewrite_rule[]) (¥_match_mp_rule type_lemmas_thm tree_def));
a(∂_tac¨(abs, rep)Æ THEN asm_rewrite_tac[]);
val _ = save_consistency_thm ¨AbsTreeÆ (pop_thm());
=TEX
\section{CLOSING DOWN}
The following \Product{} instruction restores the previous proof context.
=SML
pop_pc();
=TEX
=IGN
output_theory{theory = "wrk057",out_file = "wrk057th.doc"};
=TEX
\newpage
\HOLindexOff
\input{wrk057th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}

=SML
val up_conv = PC_C1 "hol2" rewrite_conv[get_spec¨UnparseÆ];

up_conv¨Unparse [(0, x)] 1Æ			(* x --> x *);
up_conv¨Unparse [(0, x)] 0Æ			(* x --> () *);
up_conv¨Unparse [(1, x); (0, y)] 1Æ		(* x(y) --> x(y) *);
up_conv¨Unparse [(1, x); (0, y); (0, z)] 1Æ	(* x(y); z() --> x(y) *);
up_conv¨Unparse [(2, x); (0, y); (1, z); (0, y); (0, a)] 1Æ
				(* x(y, z(y)); a --> x(y, z(y)) *);
up_conv¨Unparse [(3, x); (0, y); (1, z); (0, y); (0, a); (0, c); (0, d)] 1Æ
				(* x(y, z(y), a); c; d --> c; d *);
up_conv¨Unparse [(3, x); (0, y); (1, z); (0, y); (0, a); (0, c); (0, d)] 2Æ
				(* x(y, z(y), a); c; d --> x(y, z(y), a); c *);
up_conv¨Unparse [(3, x); (0, y); (1, z); (0, y); (0, a); (1, c); (1, e); (0, f); (0, d)] 2Æ
				(* x(y, z(y), a); c(e(f)); d --> x(y, z(y), a); c(e(f)) *);
a(LIST_GET_NTH_ASM_T [5] rewrite_tac);
