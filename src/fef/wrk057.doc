=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\def\Note#1{{\small\bf[Note: #1]}}
\makeindex
\TPPproject{{\Product}}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Examples of HOL Type Definitions}  %% Mandatory field
\TPPref{DS/FMU/IED/WRK057}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.~D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPabstract{Examples of HOL Type Definitions.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library \\
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}}) ] First draft. 

\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}

\subsection{Introduction}


\subsection{Setting Up}
The following \Product{} instructions set up the new theory $wrk057$ and set the context 
for the proof tools..
=SML
open_theory"lib_thms";
(force_delete_theory "wrk057" handle _ => ());
new_theory €"wrk057"›;
push_pc "hol";
=TEX
\section{LEMMAS ABOUT LISTS}
=TEX
We willl need a number of simple facts about lists.
These lemmas are collected together in this section.
=SML
push_goal([], ¨µl1 l2∑ l1 Î l2 = [] § l1 = [] ± l2 = []Æ);
a(µ_tac);
a(list_induction_tac¨l1Æ THEN rewrite_tac[append_def]);
val €Î_empty_thm› = save_pop_thm"Î_empty_thm";
=TEX
=SML
push_goal([], ¨µls∑ Flat ls = [] § Elems ls Ä {[]}Æ);
a(µ_tac);
a(list_induction_tac¨lsÆ THEN
	asm_rewrite_tac(Î_empty_thm :: map get_spec[¨ElemsÆ, ¨FlatÆ]));
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
val €flat_empty_thm› = save_pop_thm"flat_empty_thm";
=TEX
=SML
push_goal([], ¨µl1 l2 l3∑ (l1 Î l2) Î l3 = l1 Î l2 Î l3Æ);
a(µ_tac);
a(list_induction_tac¨l1Æ THEN asm_rewrite_tac(map get_spec[¨AppendÆ]));
val €append_assoc_thm› = save_pop_thm"append_assoc_thm";
=TEX
=SML
push_goal([], ¨µls1 ls2∑ Flat (ls1 Î ls2)  = Flat ls1 Î Flat ls2Æ);
a(µ_tac);
a(list_induction_tac¨ls1Æ THEN
	asm_rewrite_tac(append_assoc_thm :: map get_spec[¨FlatÆ, ¨AppendÆ]));
val €flat_append_thm› = save_pop_thm"flat_append_thm";
=TEX
=SML
push_goal([], ¨µls1 ls2∑ Length (ls1 Î ls2)  = Length ls1 + Length ls2Æ);
a(µ_tac);
a(list_induction_tac¨ls1Æ THEN
	asm_rewrite_tac(plus_assoc_thm :: map get_spec[¨LengthÆ, ¨AppendÆ]));
val €length_append_thm› = save_pop_thm"length_append_thm";
=TEX
=SML
push_goal([], ¨µl1 l2∑ Elems (l1 Î l2)  = Elems l1 ¿ Elems l2Æ);
a(µ_tac);
a(list_induction_tac¨l1Æ THEN
	asm_rewrite_tac(map get_spec[¨FlatÆ, ¨ElemsÆ, ¨AppendÆ]));
a(PC_T1 "sets_ext" prove_tac[]);
val €elems_append_thm› = save_pop_thm"elems_append_thm";
=TEX
=SML
push_goal([], ¨µl∑ l Î []  = lÆ);
a(µ_tac);
a(list_induction_tac¨lÆ THEN
	asm_rewrite_tac(map get_spec[¨AppendÆ]));
val €append_empty_thm› = save_pop_thm"append_empty_thm";
=TEX
=SML
push_goal([], ¨µl1 l2 l3∑ l1 Î l2  = l1 Î l3 § l2 = l3Æ);
a(µ_tac);
a(list_induction_tac¨l1Æ THEN
	asm_rewrite_tac(map get_spec[¨AppendÆ]));
val €append_cancel_thm› = save_pop_thm"append_cancel_thm";
push_goal([], ¨µf g l∑(µx∑x ç Elems l ¥ f(g x) = x) ¥ Map f(Map g l) = lÆ);
a(REPEAT µ_tac);
a(list_induction_tac¨lÆ THEN PC_T1 "sets_ext1" asm_rewrite_tac(map get_spec
	[¨ElemsÆ, ¨MapÆ]));
(* *** Goal "1" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨xÆ THEN asm_rewrite_tac[]);
val €map_map_id_thm› = save_pop_thm"map_map_id_thm";
=TEX
=SML
push_goal([], ¨µll l∑ l ç Elems ll ¥ Length l º Length (Flat ll)Æ);
a(µ_tac);
a(list_induction_tac¨llÆ THEN
	rewrite_tac(length_Î_thm :: map get_spec[¨ElemsÆ, ¨FlatÆ, ¨LengthÆ])
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
a(PC_T1 "lin_arith" asm_prove_tac[]);
val €length_length_flat_thm› = save_pop_thm"length_length_flat_thm";
=TEX
=SML
push_goal([], ¨µf l∑Elems (Map f l) = {y | ∂x∑ x ç Elems l ± f x = y}Æ);
a(REPEAT strip_tac);
a(list_induction_tac¨lÆ THEN PC_T1 "sets_ext1" asm_rewrite_tac(map get_spec
	[¨ElemsÆ, ¨MapÆ]) THEN PC_T1 "sets_ext1" REPEAT strip_tac
	THEN all_var_elim_asm_tac1 THEN asm_prove_tac[]);
val €elems_map_thm› = save_pop_thm"elems_map_thm";
=TEX
=SML
push_goal([], ¨µl∑ Length l = 0 § l = []Æ);
a(µ_tac);
a(list_induction_tac¨lÆ THEN asm_rewrite_tac(map get_spec[¨LengthÆ]));
val €length_0_thm› = save_pop_thm"length_0_thm";
=TEX
\section{LEMMAS ABOUT FUNCTIONS}
=TEX
We need a few lemmas about 1-1 and onto functions.
=SML
push_goal([], ¨µf∑ OneOne f ¥ ∂g∑ µx∑ g(f x) = xÆ);
a(rewrite_tac(map get_spec[¨OneOneÆ]) THEN REPEAT strip_tac);
a(∂_tac¨Ãy∑≈ x∑ f x = yÆ);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(≈_tac¨≈ x'∑ f x' = f xÆ);
(* *** Goal "1" *** *)
a(prove_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
val €one_one_left_inv_thm› = save_pop_thm"one_one_left_inv_thm";
=TEX
=SML
push_goal([], ¨µf∑ Onto f ¥ ∂g∑ µy∑ f(g y) = yÆ);
a(rewrite_tac(map get_spec[¨OntoÆ]) THEN REPEAT strip_tac);
a(∂_tac¨Ãx∑≈ y∑ x = f yÆ);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(≈_tac¨≈ y'∑ y = f y'Æ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
val €onto_right_inv_thm› = save_pop_thm"onto_right_inv_thm";
=TEX
=SML
push_goal([], ¨µf∑ OneOne f ± Onto f ¥
	∂g∑ (µx∑ g(f x) = x) ± (µy∑ f(g y) = y)Æ);
a(rewrite_tac(map get_spec[¨OntoÆ]) THEN REPEAT strip_tac);
a(all_fc_tac[one_one_left_inv_thm]);
a(∂_tac¨gÆ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(lemma_tac¨∂z∑ y = f zÆ THEN asm_rewrite_tac[]);
val €one_one_onto_inv_thm› = save_pop_thm"one_one_onto_inv_thm";
=TEX
\section{LEMMAS CONCERNED WITH DEFINING RECURSIVE TYPES}
This section supplies some lemmas which assist in defining recursive types.
We are concerned with providing guidelines supported by theorems rather than a fully automatic approach.
The point of view we take is more like that of \cite{Arthan91} than the universal-algebraic view of \cite{Melham89}.
Both of those references are mainly concerned with recursive types which arise from what are called finitary inductive definitions (this is explicit in \cite{Arthan91} and implicit in \cite{Melham89}).
The advantage of Melham's universal algebra point of view is that it leads directly to principles justifying definitions over the recursive type (indeed it begins from such principles);
unfortunately, it is not particularly easy to represent the general universal algebra concepts in HOL; even if one does so, the rules for introduction of new constants in HOL prohibit one from using a universal mapping property as a defining property, so one must use explicit abstraction and representation functions to define the constructors etc. even though their definitions are never needed later.

For the present treatment, we make full use of the assumption that the recursive type is defined by a finitary inductive definition.
Intuitively, finitariness means that if we start owning nothing and iterate the process of of applying the constructor functions for the type to everything we own already, we end up acquiring each element of the free type after some {\em finite} number of iterations (although we will need to iterate for ever to get everything).
So, to begin with, we assume that we are given the data shown in the following diagrams:


{\def\normalisebaselines{\baselineskip20pt
  \lineskip3pt \lineskiplimit3pt}
\def\mapright#1{\smash{
    \mathop{\longrightarrow}\limits^{#1}}}
\def\mapdown#1{\Big\downarrow
    \rlap{$\vcenter{\hbox{$\scriptstyle#1$}}$}}

$$\matrix{%
	'T		& \mapright{k}	& 'D\cr
\mapdown{c}			&		& \mapdown{w}\cr
	'T\,SET		& 		& Ó}$$
$$\matrix{%
	('T \rightarrow\ 'y)	& \mapright{M}	& ('D \rightarrow\ 'Y)}$$}

In the first diagram, $k$ is intended to be the constructor function for the free type.
Thus $'T$ is the free type itself, and $'D$ is the domain type of the constructor function.
If we are concerned with free types given as disjoint unions, then $'D$ is to be the relevant disjoint union, so that there is just {\em one} constructor function.
In {\ProductML} terms, $k$ is analogous, for example, to the generalised constructor function $mk\_simple\_type$ rather than the pair of constructors $mk\_vartype$ and $mk\_ctype$.
$c$ is to be a function which maps an element, $x$ say, in the domain of the constructor function to the set of elements of $'a$ out of which $x$ is constructed
(cf. the function {\sf contents} used in \cite{Arthan91}).
In terms in the iterative construction of the free type described abov,
$w(t)$ tells when we are going to acquire $t$.
We refer to $c$ and $w$ as the {\em content} and {\em weight} functions, respectively.

In the second diagram, $'y$ represents a type to serve as the codomain of a recursive function on $'T$.
In the applications, $'D$, will in fact be obtained from $'T$ by applying some combination of type constructors (typically, constant types, product, disjoint union and the list type constructor).
$'Y$ stands for the corresponding type construction applied to $'Y$.
$M$ is intended to be the functional which lifts a function, $f$, from $'T$ to $'y$ to the corresponding function $M(f)$, from $'D$ to $'Y$, where $M(f)$ works by applying $f$ to the $'T$ components of an element of $'D$. (N.B. in general, no appropriate $M$ need exist, however, there will be a suitable $M$ in the case of all the typical type constructors we have just listed).

In fact, the theory we will develop below does not very much on the fine tuning of the weight and content functions. For example, $c(x)$ may give either every constituent of $x$ or just the immediate constituents.
The following polymorphic set of quadruples describes what we will require:


πHOLCONST
‹	FinitaryRecType : (
‹			('D ≠ 'T)
‹		∏	('D ≠ 'T SET)
‹		∏	('T ≠ Ó)
‹		∏	(('T ≠ 'y) ≠ ('D ≠ 'Y))) SET
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	FinitaryRecType =
‹	{	(k, c, w, M)
‹	|	OneOne k
‹	±	(µt:'T∑ ∂x:'D∑ c(x) Ä {z | w(z) < w(t)} ± t = k(x))
‹	±	(µi gâ1 gâ2∑ (µy∑ w(y) < i ¥ gâ1(y) = gâ2(y))
‹			¥ µx∑ c(x) Ä {y | w(y) < i} ¥ M(gâ1)(x) = M(gâ2)(x))}
∞

I.e., to we will require the constructor function to be one-to-one and that every element, $t$, of $'T$ can be obtained by applying the constructor function to some $x$ whose contents have strictly smaller weight than that of $t$.
We also require a kind of monotonicity property on $M$, telling us that if two functions agree on elements up to a certain weight then so does their lifting under $M$.

We can derive an induction principle from the above assumptions by course-of-values induction on the value of the weight function:

=SML
set_goal([], ¨µk c w M∑ (k, c, w, M) ç FinitaryRecType ¥
	µX: 'T SET∑
		(µx: 'D∑ c(x) Ä X ¥ k(x) ç X)
	¥	µt : 'T∑ t ç X
Æ);
a(rewrite_tac[get_spec¨FinitaryRecTypeÆ] THEN REPEAT strip_tac);
a(lemma_tac¨∂i∑ w(t) = iÆ THEN1 prove_∂_tac);
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨tÆ, ¨tÆ) THEN cov_induction_tac¨iÆ);
a(REPEAT strip_tac);
a(spec_nth_asm_tac 5 ¨tÆ THEN all_var_elim_asm_tac1);
a(lemma_tac¨c x Ä XÆ);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
a(spec_nth_asm_tac 4 ¨w x'Æ);
a(spec_nth_asm_tac 1 ¨x'Æ);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
val €fin_rec_type_induction_thm› = save_pop_thm"fin_rec_type_induction_thm";
=TEX
For use with the HOL induction tactics we need the above formulated for properties rather than sets:
=SML
set_goal([], ¨µk c w M∑ (k, c, w, M) ç FinitaryRecType ¥
	µP: 'T ≠ BOOL∑
		(µx: 'D∑ (µt∑ t ç c(x) ¥ P t) ¥ P(k(x)))
	¥	µt : 'T∑ P(t)
Æ);
a(REPEAT strip_tac);
a(fc_tac[fin_rec_type_induction_thm]);
a(SPEC_NTH_ASM_T 1 ¨{t | P t}Æ ante_tac);
a(PC_T1 "sets_ext1" rewrite_tac[]);
a(REPEAT strip_tac);
a(ALL_ASM_FC_T rewrite_tac[]);
val €fin_rec_type_induction_thm1› = save_pop_thm"fin_rec_type_induction_thm1";
=TEX
Somewhat analogously to the proof of the inductino principle, we can use the principle of definition by primitive recursion for the natural numbers to derive a definitional principle for the recursive type.
The function $d$ here is the data for a primitive recursive definition;
it is a function from $'D ∏ 'Y$ to $'y$.
The claim is that for any such function there is a function $h$ from $'T$ to $'y$ satisfying the recursion equation:
=GFT
µx:'D∑ h(k(x)) = d(x, M h x)
∞
We construct $h$ as follows.
First of all we observe that the constructor function, $k$, is both one-to-one and onto (by the second clause in the definition of $FinitaryRecType$).
Therefore $k$ has a two-sided inverse, $ƒ$ say.
That is to say we can assume the existence of a function
=INLINEFT
ƒ: 'T ≠ 'D
=TEX
\ satisfying:
=GFT
	ƒ (k x) = x
	k (ƒ y) = y
∞
for any $x$ and $y$.
Now we can use the principle of definition by primitive recursion for the natural numbers to construct a function
=INLINEFT
H: Ó ≠ 'T ≠ 'y
=TEX
\ satisfying the equations:
=GFT
	H 0 y = d(ƒ(y), M Arbitrary (ƒ y)))
	H(i + 1) y = if w(y) º i then H(i)(y) else d(ƒ(y), M (H i) (ƒ y))
∞
The idea here is that, for each $i$, $H(i)$ is an approximation to the desired function $h$, and, in fact, agrees with $h$ for all elements of weight no greater than $i$.
We can prove (by induction on $j$) that $H$ enjoys the following monotonicity property.
=GFT
µj∑ µ y∑ H (w y + j) y = H (w y) y
∞
We then define $h$ by
=GFT
µ y∑ h  y = H (w y) y
∞
\ and check, using the monotonicity properties of $H$ and $M$ that $h$ has the required property.

To formalise the above, we first prove the lemma that there exists $ƒ$ and $H$ satisfying the salient conditions.

=SML
set_goal([], ¨µk c w∑ (k, c, w, M) ç FinitaryRecType ¥
	∂ƒ∑
	(µ x∑ ƒ (k x) = x)
±	(µ y∑ k (ƒ y) = y)
±	µd: 'D  ∏'Y ≠ 'y∑
	∂ H : Ó ≠ 'T ≠ 'y ∑
	(µy∑	H 0 y = d(ƒ(y), M Arbitrary (ƒ y)))
±	(µi y∑	H(i + 1) y = if w(y) º i then H(i)(y) else d(ƒ(y), M (H i) (ƒ y)))
±	(µj∑ µ y∑ H (w y + j) y = H (w y) y)Æ);
a(rewrite_tac[get_spec¨FinitaryRecTypeÆ] THEN REPEAT strip_tac);
a(lemma_tac¨Onto kÆ THEN1 (rewrite_tac[get_spec¨OntoÆ] THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 2 ¨yÆ);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(all_fc_tac[one_one_onto_inv_thm]);
a(∂_tac¨gÆ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(lemma_tac¨∂H∑µy∑
	H 0 y = d(g(y), M Arbitrary (g y)) ±
µi∑	H(i + 1) y = if w(y) º i then H(i)(y) else d(g(y), M (H i) (g y))Æ
	THEN1 prove_∂_tac);
a(∂_tac¨HÆ THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(induction_tac ¨jÆ);
(* *** Goal "2.1" *** *)
a(PC_T1 "hol2" rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[plus_assoc_thm1]);
val €fin_rec_type_prim_rec_lemma1› = save_pop_thm"fin_rec_type_prim_rec_lemma1";
=TEX
Using this lemma we can the existence part of the principle of definition by primitive recursion.
Note that goals 1 and 2 here come from a case split, not a proof by induction: induction would actually be harmful here because it would introduce an irrelevant equation into the assumptions.
=SML
set_goal([], ¨µk c w M∑ (k, c, w, M) ç FinitaryRecType ¥
	µd: 'D  ∏'Y ≠ 'y∑
	∂ h : 'T ≠ 'y ∑ µx:'D∑ h(k(x)) = d(x, M h x)
Æ);
a(REPEAT strip_tac THEN all_fc_tac[fin_rec_type_prim_rec_lemma1]);
a(POP_ASM_T (strip_asm_tac o µ_elim¨dÆ));
a(DROP_ASM_T ¨(k, c, w, M) ç FinitaryRecTypeÆ
	(strip_asm_tac o rewrite_rule[get_spec¨FinitaryRecTypeÆ]));
a(∂_tac¨Ãy∑H (w(y)) yÆ THEN rewrite_tac[] THEN REPEAT strip_tac);
a(spec_nth_asm_tac 2 ¨k xÆ);
a(POP_ASM_T (strip_asm_tac o eq_sym_rule));
a(lemma_tac¨OneOne k ¥ k x' = k x ¥ x' = xÆ THEN1 prove_tac[get_spec¨OneOneÆ]);
a(var_elim_nth_asm_tac 1);
a(strip_asm_tac(µ_elim¨w (k x)Æ Ó_cases_thm));
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
a(SPEC_NTH_ASM_T 3 ¨0Æ ante_tac);
a(PC_T1 "hol2" rewrite_tac[]);
a(lemma_tac¨c x Ä {z|w z < w (k x)} ¥ c x = {}Æ
	THEN1 (LIST_GET_NTH_ASM_T [1] (PC_T1 "hol2" prove_tac)));
a strip_tac;
a(LIST_SPEC_NTH_ASM_T 1 [¨Arbitrary: 'T ≠ 'yÆ, ¨Ã y∑ H (w y) yÆ, ¨xÆ] ante_tac);
a(GET_NTH_ASM_T 2 rewrite_thm_tac THEN STRIP_T rewrite_thm_tac);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
a(LEMMA_T ¨M (H i) x = M (Ã y∑ H (w y) y) xÆ rewrite_thm_tac);
a(LIST_SPEC_NTH_ASM_T 3 [¨w(k x)Æ, ¨H iÆ, ¨Ã y∑ H (w y) yÆ] ante_tac);
a(LEMMA_T¨µ y∑ w y < w (k x) ¥ H i y = (Ã y∑ H (w y) y) yÆ rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(TOP_ASM_T rewrite_thm_tac THEN REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule(map get_spec[¨$<Æ, ¨$ºÆ])));
a(POP_ASM_T (asm_rewrite_thm_tac o eq_sym_rule));
(* *** Goal "2.2" *** *)
a strip_tac;
a(spec_nth_asm_tac 1 ¨xÆ);
val €fin_rec_type_prim_rec_exists_thm› = save_pop_thm"fin_rec_type_prim_rec_exists_thm";
=TEX
It is fairly straightforward to show that the functions $h$ whose existence is given by the principle of definition by primitive recursion are uniquely determined by their recursion equations.
Note that, perhaps a little inelegantly, it seems to be easier to prove this using course-of-values induction for the natural numbers rather than by dint of the induction principle for the recursive data type.
=SML
set_goal([], ¨µk c w M∑ (k, c, w, M) ç FinitaryRecType ¥
	µd: 'D  ∏'Y ≠ 'y∑
	µ hâ1 hâ2 : 'T ≠ 'y ∑
		(µx:'D∑ hâ1(k(x)) = d(x, M hâ1 x)) ±
		(µx:'D∑ hâ2(k(x)) = d(x, M hâ2 x)) ¥
		hâ1 = hâ2
Æ);
a(rewrite_tac[get_spec¨FinitaryRecTypeÆ] THEN REPEAT strip_tac);
a(PC_T1 "hol2" REPEAT strip_tac);
a(lemma_tac¨Onto kÆ THEN1 (rewrite_tac[get_spec¨OntoÆ] THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 4 ¨yÆ);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(all_fc_tac[one_one_onto_inv_thm]);
a(lemma_tac¨∂i∑ w x = iÆ THEN1 prove_∂_tac);
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨xÆ, ¨xÆ) THEN cov_induction_tac¨iÆ);
a(lemma_tac¨µ y∑ w y < i ¥ hâ1 y = hâ2 yÆ);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(spec_nth_asm_tac 2 ¨w yÆ THEN spec_nth_asm_tac 1 ¨yÆ);
(* *** Goal "2.2" *** *)
a(list_spec_nth_asm_tac 8 [¨iÆ, ¨hâ1Æ, ¨hâ2Æ] THEN1 all_asm_fc_tac[]);
a(REPEAT strip_tac);
a(spec_nth_asm_tac 11 ¨xÆ);
a(all_var_elim_asm_tac1);
a(spec_nth_asm_tac 2 ¨x'Æ);
a(asm_rewrite_tac[]);
val €fin_rec_type_prim_rec_unique_thm› =
	save_pop_thm"fin_rec_type_prim_rec_unique_thm";
=TEX
The previous two theorems may now be fitted together to give the principle of definition by primitive recursion in its final form.
=SML
set_goal([], ¨µk c w M∑ (k, c, w, M) ç FinitaryRecType ¥
	µd: 'D  ∏'Y ≠ 'y∑
	∂â1 h : 'T ≠ 'y ∑ µx:'D∑ h(k(x)) = d(x, M h x)
Æ);
a(REPEAT strip_tac);
a(all_fc_tac[fin_rec_type_prim_rec_exists_thm]);
a(spec_nth_asm_tac 1 ¨dÆ);
a(∂â1_tac¨hÆ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(all_fc_tac[fin_rec_type_prim_rec_unique_thm]);
val €fin_rec_type_prim_rec_thm› =
	save_pop_thm"fin_rec_type_prim_rec_thm";
=TEX
The condition on $M$ in the definition of $FinitaryRecType$ has been chosen to be the weakest condition for which the above proofs go through conveniently.
The following shows that a somewhat stronger condition which will often be easy to prove is also sufficient.
This condition has the advantage of only involving $c$ and $M$.
We say that $M$ is a {\em local functional} with respect to $c$ when the condition holds.
πHOLCONST
‹	LocalFunctional : ((('T ≠ 'y) ≠ ('D ≠ 'Y)) ∏ ('D ≠ 'T SET)) SET
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	LocalFunctional =
‹	{	(M, c)
‹	|	µI gâ1 gâ2∑ (µy∑ y ç I ¥ gâ1(y) = gâ2(y))
‹			¥ µx∑ c(x) Ä I ¥ M(gâ1)(x) = M(gâ2)(x)}
∞
=SML
set_goal([], ¨µc w M∑
	(M, c) ç LocalFunctional ¥
	µi gâ1 gâ2∑ (µy∑ w(y) < i ¥ gâ1(y) = gâ2(y))
		¥ µx∑ c(x) Ä {y | w(y) < i} ¥ M(gâ1)(x) = M(gâ2)(x)
Æ);
a(rewrite_tac [get_spec¨LocalFunctionalÆ] THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨{y | w y < i}Æ);
a(list_spec_nth_asm_tac 1 [¨gâ1Æ, ¨gâ2Æ] THEN1 all_asm_fc_tac[]);
a(spec_nth_asm_tac 1 ¨xÆ);
val €local_functional_thm› = save_pop_thm "local_functional_thm";
=TEX
We can now show that for various useful values of $c$ and $M$, $M$ is local with respect to $c$.
=SML
set_goal([], ¨((Ãf∑ f), (Ãx∑{x})) ç LocalFunctionalÆ);
a(rewrite_tac[get_spec¨LocalFunctionalÆ] THEN REPEAT strip_tac);
a(lemma_tac¨{x} Ä I ¥ x ç IÆ THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(all_asm_fc_tac[]);
val €i_local_thm› = save_pop_thm "i_local_thm";
=TEX
=SML
set_goal([], ¨((Ãf∑ (Ãx∑ {})), (Ãx∑{x})) ç LocalFunctionalÆ);
a(rewrite_tac[get_spec¨LocalFunctionalÆ] THEN REPEAT strip_tac);
val €k_local_thm› = save_pop_thm "k_local_thm";
=TEX
=SML
set_goal([], ¨ µ Mâ1 câ1 Mâ2 câ2∑
	(Mâ1, câ1) ç LocalFunctional ± 
	(Mâ2, câ2) ç LocalFunctional ¥
	((Ãf∑Ã(x, y)∑ (Mâ1 f x, Mâ2 f y)), (Ã(x, y)∑ câ1 x ¿ câ2 y)) ç LocalFunctional
Æ);
a(rewrite_tac[get_spec¨LocalFunctionalÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨câ1 (Fst x) ¿ câ2 (Snd x) Ä I ¥ câ1 (Fst x) Ä IÆ THEN1
	PC_T1 "sets_ext" prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨câ1 (Fst x) ¿ câ2 (Snd x) Ä I ¥ câ2 (Snd x) Ä IÆ THEN1
	PC_T1 "sets_ext" prove_tac[]);
a(all_asm_fc_tac[]);
val €∏_local_thm› = save_pop_thm "∏_local_thm";
=TEX
=SML
set_goal([], ¨ µ Mâ1 câ1 Mâ2 câ2∑
	(Mâ1, câ1) ç LocalFunctional ± 
	(Mâ2, câ2) ç LocalFunctional ¥
	((Ãf∑Ãx∑ if IsL x then Mâ1 f (OutL x) else Mâ2 f (OutR x)),
	(Ãx∑ if IsL x then câ1 (OutL x) else câ2 (OutR x))) ç LocalFunctional
Æ);
a(rewrite_tac[get_spec¨LocalFunctionalÆ] THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN strip_asm_tac(µ_elim¨xÆ sum_cases_thm)
	THEN asm_rewrite_tac[] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val €sum_local_thm› = save_pop_thm "sum_local_thm";
=TEX
=SML
set_goal([], ¨ µ M c∑
	(M, c) ç LocalFunctional  ¥
	((Ãf∑ Map (M f)),(Ãx∑ ﬁ(Elems (Map c x)))) ç LocalFunctional
Æ);
a(rewrite_tac[get_spec¨LocalFunctionalÆ] THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN list_induction_tac¨xÆ THEN
	rewrite_tac(map get_spec[¨MapÆ, ¨ElemsÆ]));
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[pc_rule1 "sets_ext1" prove_rule[]
	¨µa b c∑ ≥ﬁ a Ä b ¥ ≥ﬁ(c ¿ a) Ä bÆ]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(lemma_tac¨c x' Ä ﬁ ({c x'} ¿ Elems (Map c x))Æ THEN
	PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(∂_tac¨c x'Æ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]
	¨µa b c∑ a Ä b ± b Ä c ¥ a Ä cÆ]);
a(all_asm_fc_tac[]);
val €list_local_thm› = save_pop_thm "list_local_thm";
=TEX
=SML
set_goal([], ¨ (Map, Elems) ç LocalFunctional Æ);
a(rewrite_tac[get_spec¨LocalFunctionalÆ] THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN list_induction_tac¨xÆ THEN
	rewrite_tac(map get_spec[¨MapÆ, ¨ElemsÆ]));
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[pc_rule1 "sets_ext1" prove_rule[]
	¨µa b c∑ ≥ a Ä b ¥ ≥(c ¿ a) Ä bÆ]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(lemma_tac¨{x'} ¿ Elems x Ä I ¥ x' ç IÆ THEN1 PC_T1 "sets_ext" prove_tac[]);
a(all_asm_fc_tac[]);
val €list_local_thm1› = save_pop_thm "list_local_thm1";
=TEX
=SML
set_goal([], ¨ µ M c∑
	(M, c) ç LocalFunctional  ¥
	((Ãf∑ M f o Snd),(c o Snd)) ç LocalFunctional
Æ);
a(rewrite_tac[get_spec¨LocalFunctionalÆ] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
val €o_snd_local_thm› = save_pop_thm "o_snd_local_thm";
=TEX
=SML
set_goal([], ¨ µ M c∑
	(M, c) ç LocalFunctional  ¥
	((Ãf∑ M f o Fst),(c o Fst)) ç LocalFunctional
Æ);
a(rewrite_tac[get_spec¨LocalFunctionalÆ] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
val €o_fst_local_thm› = save_pop_thm "o_fst_local_thm";
=TEX
\section{TREES}
We are now going to use the material of the previous sections to construct a specific recursive type.
What we are going to construct is the HOL analogue of the type defined in ML as follows:

=GFT Standard ML Example
	datatype 'a TREE = MkTree of ('a * (('a TREE) list));
=TEX
The elements of the type may be thought of as trees.
At each node in one of these trees there is an element of the type parameter $'a$ and a list of sub-trees.
Alternatively, one can think of the trees as formal expressions formed using the elements of $'a$ as operator symbols.


We need a type in which to represent the type of trees.
Our choice is lists of number-$'a$ pairs.
Viewing the trees as formal expressions, an expression formed using an element $x:'a$ as an operator with $n$ operands will be represented by the list comprising $(n, x)$ followed by the representations of the operands.
IThis is essentially just the usual prefix way of writing the expression but with the arities of operators marked to make the representation unambiguous.
For example, the expression $x(y, z(y))$ would be represented as:

=GFT ProofPower-HOL Example
[(2, x); (0, y); (1, z); (0, y)]
=TEX
Note that not every list corresponds to a tree; e.g. the empty list does not.
Given a list, $[l_1; \ldots; l_k]$ of lists representing trees, $t_1, \ldots, t_k$, and an element $x:'a$, the representation of $x(t_1, \ldots, t_k)$ will  be the list $Cons k (Flat [l_1; \ldots; l_k])$.
We can formally define the set of those lists which do represent trees as the smallest set of lists which is closed under this construction of new representatives from old:

πHOLCONST
‹	Tree : (Ó ∏ 'a) LIST 
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Tree =
‹	•{	A
‹	|	µlab : 'a; trees : (Ó ∏ 'a) LIST LIST∑
‹			Elems trees Ä A ¥
‹			Cons (Length trees, lab) (Flat trees) ç A}
∞
=TEX
To develop a recursive type represented the above set of trees, we first derive an induction principle.
We do this in three steps.
The induction hypothesis for the induction principle needs
=SML
set_goal([], ¨µX∑
	(µx ts∑ (Elems ts Ä X)
			¥ (Cons (Length ts, x) (Flat ts)) ç X)
	¥	Tree Ä X
Æ);
a(PC_T1 "sets_ext" rewrite_tac[get_spec¨TreeÆ] THEN REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨XÆ);
a(list_spec_nth_asm_tac 4 [¨labÆ, ¨treesÆ]);
a(all_asm_fc_tac[]);
val €tree_induction_lemma1› = save_pop_thm"tree_induction_lemma1";
=TEX
=SML
set_goal([], ¨
	µx ts∑ Elems ts Ä Tree ¥ Cons (Length ts, x) (Flat ts) ç Tree
Æ);
a(PC_T1 "sets_ext" rewrite_tac[get_spec¨TreeÆ] THEN REPEAT strip_tac);
a(list_spec_nth_asm_tac 1 [¨xÆ, ¨tsÆ]);
a(all_asm_fc_tac[]);
val €tree_induction_lemma2› = save_pop_thm"tree_induction_lemma2";
=TEX
=SML
set_goal([], ¨µX∑
	(µx ts∑ Elems ts Ä Tree ° X ¥ (Cons(Length ts, x) (Flat ts)) ç X)
	¥	Tree Ä X
Æ);
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨Tree ° XÆ tree_induction_lemma1));
(* *** Goal "1" *** *)
a(lemma_tac¨Elems ts Ä Tree ° X ¥ Elems ts Ä TreeÆ THEN1 
	PC_T1 "sets_ext" prove_tac[]);
a(all_fc_tac[tree_induction_lemma2] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext" prove_tac[]);
val €tree_induction_lemma› = save_pop_thm"tree_induction_lemma";
=TEX
It is convenient to recast the above in terms of properties for use with the induction tactic generating function.
=SML
set_goal([], ¨µP∑
	(µx ts∑ (µt∑ t ç Elems ts ¥ t ç Tree ± P t)
		¥ P (Cons(Length ts, x) (Flat ts)))
	¥	µt∑t ç Tree ¥ P t
Æ);
a(strip_tac);
a(ante_tac(µ_elim¨{t | P t}Æ tree_induction_lemma));
a(PC_T1 "sets_ext" rewrite_tac[]);
val €tree_induction_tac_lemma› = save_pop_thm"tree_induction_tac_lemma";
=TEX
=SML
set_goal([], ¨µt∑ t ç Tree ¥
	∂x; ts∑ Elems ts Ä Tree ± t = Cons (Length ts, x) (Flat ts)Æ);
a(µ_tac THEN gen_induction_tac1 tree_induction_tac_lemma);
a(∂_tac¨xÆ THEN ∂_tac¨tsÆ THEN PC_T "sets_ext" contr_tac THEN all_asm_fc_tac[]);
val €tree_cases_lemma› = save_pop_thm"tree_cases_lemma";
=TEX
=SML
set_goal([], ¨≥ [] ç TreeÆ);
a(lemma_tac¨µt∑t ç Tree ¥ ≥t = []Æ THEN_LIST[id_tac, asm_prove_tac[]]);
a(µ_tac THEN gen_induction_tac1 tree_induction_tac_lemma);
a(rewrite_tac[]);
val €≥_empty_list_tree_lemma› = save_pop_thm"≥_empty_list_tree_lemma";
=TEX
πHOLCONST
‹	Unparse : (Ó ∏ 'a) LIST ≠ Ó ≠ (Ó ∏ 'a) LIST
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹µi nv more∑
‹	Unparse [] i = []
‹±	Unparse (Cons nv more) i =
‹	if	i = 0
‹	then	[]
‹	else	Cons nv (Unparse more ((Fst nv + i) - 1))
∞
=TEX
=SML
set_goal([], ¨µts more∑
	Elems ts Ä Tree ¥
	Unparse (Flat ts Î more) (Length ts) = Flat ts
Æ);
a(REPEAT µ_tac);
a(lemma_tac¨∂tm∑ Flat ts Î more = tmÆ THEN_LIST [prove_∂_tac, all_asm_ante_tac]);
a(intro_µ_tac(¨tsÆ, ¨tsÆ) THEN list_induction_tac¨tmÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[Î_empty_thm, flat_empty_thm] THEN REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨tsÆ list_cases_thm) THEN all_var_elim_asm_tac1
	THEN rewrite_tac(map get_spec[¨UnparseÆ, ¨LengthÆ, ¨$AppendÆ, ¨FlatÆ]));
a(i_contr_tac THEN all_asm_ante_tac);
a(PC_T1 "sets_ext1" rewrite_tac(map get_spec[¨ElemsÆ]) THEN REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨xÆ);
a(∂_tac ¨xÆ THEN asm_rewrite_tac[≥_empty_list_tree_lemma]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨tsÆ list_cases_thm) THEN all_var_elim_asm_tac1
	THEN rewrite_tac(map get_spec[¨UnparseÆ, ¨LengthÆ, ¨$AppendÆ, ¨FlatÆ]));
(* *** Goal "2.1" *** *)
a(strip_asm_tac(µ_elim¨moreÆ list_cases_thm) THEN all_var_elim_asm_tac1
	THEN rewrite_tac(map get_spec[¨UnparseÆ]));
(* *** Goal "2.2" *** *)
a(lemma_tac¨Elems (Cons x' list2) Ä Tree ¥ x' ç TreeÆ
	THEN1 PC_T1 "sets_ext1" prove_tac[get_spec¨ElemsÆ]);
a(all_fc_tac[tree_cases_lemma]);
a(var_elim_nth_asm_tac 1);
a(all_asm_ante_tac THEN
	rewrite_tac(map get_spec[¨$AppendÆ, ¨FlatÆ, ¨ElemsÆ, ¨UnparseÆ]));
a(rewrite_tac[prove_rule[flat_append_thm]
	¨Flat ts Î Flat list2 = Flat(ts Î list2)Æ]);
a(REPEAT strip_tac);
a(lemma_tac¨Elems(ts Î list2) Ä TreeÆ
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[elems_append_thm]);
a(all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac[plus_assoc_thm1, length_append_thm]);
val €unparse_thm› = save_pop_thm"unparse_thm";
=TEX
=SML
set_goal([], ¨µt more∑ t ç Tree ¥ Unparse (t Î more) 1 = tÆ);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨[t]Æ, ¨moreÆ] unparse_thm));
a(rewrite_tac(append_empty_thm :: map get_spec[¨ElemsÆ, ¨LengthÆ, ¨FlatÆ]));
a(PC_T1 "sets_ext1" asm_prove_tac[]);
val €unparse_thm1› = save_pop_thm"unparse_thm1";
=TEX
=SML
set_goal([], ¨µt∑ t ç Tree ¥
	∂â1(x, ts)∑ Elems ts Ä Tree ± t = Cons (Length ts, x) (Flat ts)Æ);
a(REPEAT strip_tac THEN all_fc_tac[tree_cases_lemma]);
a(∂â1_tac¨(x, ts)Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(REPEAT all_var_elim_asm_tac1);
a(REPEAT strip_tac);
(* *** Goal "2" *** *)
a(REPEAT all_var_elim_asm_tac1);
a(REPEAT_N 4 (POP_ASM_T ante_tac) THEN POP_ASM_T discard_tac);
a(intro_µ_tac(¨tsÆ, ¨tsÆ) THEN list_induction_tac¨ts'Æ);
(* *** Goal "2.1" *** *)
a(rewrite_tac[get_spec¨LengthÆ, length_0_thm]);
a(prove_tac[]);
(* *** Goal "2.2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨tsÆ list_cases_thm) THEN all_var_elim_asm_tac1);
(* *** Goal "2.2.1" *** *)
a(GET_NTH_ASM_T 2 ante_tac THEN rewrite_tac[get_spec¨LengthÆ, length_0_thm]);
(* *** Goal "2.2.2" *** *)
a(lemma_tac¨x = x'Æ THEN all_asm_ante_tac
	THEN rewrite_tac(
		pc_rule1"sets_ext1" prove_rule[]
			¨µz a b∑ {z} ¿ a Ä b § z ç b ± a Ä bÆ ::
		map get_spec[¨FlatÆ, ¨ElemsÆ, ¨LengthÆ])
	THEN REPEAT strip_tac);
(* *** Goal "2.2.2.1" *** *)
a(LEMMA_T ¨Unparse(x Î Flat ts') 1 = Unparse(x' Î Flat list2) 1Æ ante_tac THEN1
		asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[unparse_thm1]);
(* *** Goal "2.2.2.2" *** *)
a(var_elim_nth_asm_tac 1);
a(POP_ASM_T ante_tac THEN rewrite_tac[append_cancel_thm] THEN strip_tac);
a(all_asm_fc_tac[]);
val €tree_cases_lemma1› = save_pop_thm"tree_cases_lemma1";
=TEX
=SML
set_goal([], ¨µx∑[(0, x)] ç TreeÆ);
a(rewrite_tac[get_spec¨TreeÆ] THEN REPEAT strip_tac);
a(POP_ASM_T (ante_tac o list_µ_elim[¨xÆ, ¨[]: (Ó ∏ 'a) LIST LISTÆ]));
a(PC_T1 "sets_ext" rewrite_tac(map get_spec [¨ElemsÆ, ¨FlatÆ, ¨LengthÆ]));
val €leaf_is_a_tree_thm› = save_pop_thm"leaf_is_a_tree_thm";
=TEX
=TEX
\section{DEFINING THE TYPE OF TREES}
=SML
val €tree_def› = new_type_defn(["TREE", "tree_def"], "TREE", ["'a"],
	tac_proof( ([], ¨∂tr∑ (Ãt∑ t ç Tree) trÆ), 
		asm_tac leaf_is_a_tree_thm THEN asm_prove_tac[]));
=TEX
πHOLCONST
‹	MkTree : ('a ∏ ('a TREE LIST)) ≠ 'a TREE
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	OneOne MkTree ±
‹	(∂w: 'a TREE ≠ Ó∑
‹		µt∑ ∂x∑ (µz∑ z ç Elems(Snd x) ¥ w z < w t) ± t = MkTree x)
∞
=TEX
=SML
push_consistency_goal¨MkTreeÆ;
a((strip_asm_tac o rewrite_rule[]) (¥_match_mp_rule type_lemmas_thm tree_def));
a(∂_tac¨Ã(x, ts)∑ abs(Cons (Length ts, x) (Flat (Map rep ts)))Æ
	THEN rewrite_tac[get_spec¨OneOneÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨µl∑ Elems (Map rep l) Ä TreeÆ THEN1 strip_tac);
(* *** Goal "1.1" *** *)
a(list_induction_tac ¨lÆ THEN
	rewrite_tac(map get_spec[¨ElemsÆ, ¨MapÆ]));
a(strip_tac THEN asm_rewrite_tac[
	pc_rule1"sets_ext" prove_rule[]¨µa b c∑a ¿ b Ä c § a Ä c ± b Ä cÆ]);
a(PC_T1 "sets_ext" REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(spec_nth_asm_tac 1 ¨Snd x2Æ);
a(spec_nth_asm_tac 2 ¨Snd x1Æ);
a(all_fc_tac[tree_induction_lemma2]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[length_map_thm] o µ_elim¨Fst x2Æ));
a(all_fc_tac[tree_cases_lemma1]);
a(DROP_NTH_ASM_T 7
	(strip_asm_tac o rewrite_rule[length_map_thm] o µ_elim¨Fst x1Æ));
a(LIST_GET_NTH_ASM_T [12] all_fc_tac);
a(LEMMA_T¨rep(abs (Cons (# (Snd x1), Fst x1) (Flat (Map rep (Snd x1)))))
             = rep(abs (Cons (# (Snd x2), Fst x2) (Flat (Map rep (Snd x2)))))Æ
	ante_tac THEN1 LIST_GET_NTH_ASM_T [13] rewrite_tac);
a(LIST_GET_NTH_ASM_T [1,2] rewrite_tac THEN strip_tac);
a(GET_NTH_ASM_T 7 (ante_tac o list_µ_elim[¨Fst x2Æ, ¨Map rep (Snd x2)Æ]));
a(DROP_NTH_ASM_T 7 (ante_tac o list_µ_elim[¨Fst x1Æ, ¨Map rep (Snd x1)Æ]));
a(asm_rewrite_tac[length_map_thm] THEN REPEAT strip_tac);
a(LEMMA_T¨Map abs(Map rep (Snd x1)) = Map abs(Map rep (Snd x2))Æ
	ante_tac THEN1 asm_rewrite_tac[]);
a(lemma_tac¨
	(µx∑x ç Elems (Snd x1) ¥ abs(rep x) = x) ±
	(µx∑x ç Elems (Snd x2) ¥ abs(rep x) = x)Æ THEN1 asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac [map_map_id_thm]);
a(asm_ante_tac¨Fst x1 = Fst x2Æ THEN PC_T1 "prop_eq_pair" prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨Ãt∑ Length(rep t)Æ THEN rewrite_tac[] THEN REPEAT strip_tac);
a(lemma_tac¨rep t ç TreeÆ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[tree_cases_lemma]);
a(∂_tac¨(x, Map abs ts)Æ THEN rewrite_tac[length_map_thm]);
a(DROP_ASM_T ¨Elems ts Ä TreeÆ ante_tac THEN PC_T1 "sets_ext1" asm_rewrite_tac[]);
a(strip_tac THEN ALL_FC_T rewrite_tac[map_map_id_thm]);
a(GET_NTH_ASM_T 2 (rewrite_thm_tac o eq_sym_rule));
a(GET_NTH_ASM_T 5 rewrite_thm_tac);
a(rewrite_tac[elems_map_thm]);
a(REPEAT strip_tac);
a(var_elim_nth_asm_tac 1);
a(ALL_ASM_FC_T asm_rewrite_tac[]);
a(rewrite_tac[get_spec¨LengthÆ]);
a(all_fc_tac[length_length_flat_thm]);
a(PC_T1 "lin_arith" asm_prove_tac[]);
val _ = save_consistency_thm ¨MkTreeÆ (pop_thm());
=TEX
=SML
set_goal([], ¨((Ãf∑ Map f o Snd), (Elems o Snd)) ç LocalFunctionalÆ);
a(bc_tac[o_snd_local_thm]);
a(rewrite_tac[list_local_thm1]);
val €tree_local_thm› = save_pop_thm "tree_local_thm";
=TEX
=SML
set_goal([], ¨∂w∑ (MkTree, Elems o Snd, w, (Ãf∑ Map f o Snd)) ç FinitaryRecTypeÆ);
a(strip_asm_tac(get_spec¨MkTreeÆ));
a(∂_tac¨wÆ THEN rewrite_tac[get_spec¨FinitaryRecTypeÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 1 ¨tÆ THEN var_elim_nth_asm_tac 1);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac (list_µ_elim[
	¨Elems o (Snd :  'a ∏ 'a TREE LIST ≠ 'a TREE LIST)Æ, ¨wÆ,
	¨Ãf:'a TREE ≠ 'b∑ Map f o (Snd :  'a ∏ 'a TREE LIST ≠ 'a TREE LIST)Æ]
	local_functional_thm));
(* *** Goal "2.1" *** *)
a(all_fc_tac[tree_local_thm]);
(* *** Goal "2.2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[]));
a(all_asm_fc_tac[]);
val €tree_fin_rec_thm› = save_pop_thm "tree_fin_rec_thm";
=TEX
=SML
fun  €simple_∂_¥_match_rule› (thm1 : THM) (thm2 : THM) : THM = (
	let	val (v, b) = dest_∂ (concl thm2);
		val thm3 = asm_rule b;
		val thm4 = ¥_match_mp_rule thm1 thm3;
	in	simple_∂_elim v thm2 thm4
	end
);
=TEX
=SML
val €tree_induction_thm› = rewrite_rule[]
	(simple_∂_¥_match_rule fin_rec_type_induction_thm1 tree_fin_rec_thm);
val €tree_prim_rec_thm› = rewrite_rule[]
	(simple_∂_¥_match_rule fin_rec_type_prim_rec_thm tree_fin_rec_thm);
=TEX
\section{CLOSING DOWN}
The following \Product{} instruction restores the previous proof context.
=SML
pop_pc();
=TEX
=IGN
output_theory{theory = "wrk057",out_file = "wrk057th.doc"};
=TEX
\newpage
\HOLindexOff
\input{wrk057th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}

=IGN
val up_conv = PC_C1 "hol2" rewrite_conv[get_spec¨UnparseÆ];

up_conv¨Unparse [(0, x)] 1Æ			(* x --> x *);
up_conv¨Unparse [(0, x)] 0Æ			(* x --> () *);
up_conv¨Unparse [(1, x); (0, y)] 1Æ		(* x(y) --> x(y) *);
up_conv¨Unparse [(1, x); (0, y); (0, z)] 1Æ	(* x(y); z() --> x(y) *);
up_conv¨Unparse [(2, x); (0, y); (1, z); (0, y); (0, a)] 1Æ
				(* x(y, z(y)); a --> x(y, z(y)) *);
up_conv¨Unparse [(3, x); (0, y); (1, z); (0, y); (0, a); (0, c); (0, d)] 1Æ
				(* x(y, z(y), a); c; d --> c; d *);
up_conv¨Unparse [(3, x); (0, y); (1, z); (0, y); (0, a); (0, c); (0, d)] 2Æ
				(* x(y, z(y), a); c; d --> x(y, z(y), a); c *);
up_conv¨Unparse [(3, x); (0, y); (1, z); (0, y); (0, a); (1, c); (1, e); (0, f); (0, d)] 2Æ
				(* x(y, z(y), a); c(e(f)); d --> x(y, z(y), a); c(e(f)) *);
set_goal([], ¨TÆ);
