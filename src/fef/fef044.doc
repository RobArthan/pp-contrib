=TEX
% $Date$ $Id$ $Revision$
\documentstyle[hol1,11pt,TQ]{article}
\long\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\def\Note#1{{\small\bf[Note: #1]}}
\makeindex
\underscoreoff
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Proofs About Labelling}  %% Mandatory field
\TPPref{DS/FMU/FEF/044}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Approved}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.~D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{Formal proofs establishing various results about the multi-level policy and the labelling property for SWORD (for DRA Front End Filter project RSRE 1C/6130).}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}}) ] First draft. 

\end{description}

\subsection{Changes Forecast}
None.

\pagebreak
\section{GENERAL}

\subsection{Scope}

This document contains proofs relating to the specifications in documnets \cite{DS/FMU/FEF/040,DS/FMU/FEF/042,DS/FMU/FEF/044}.

\subsection{Introduction}

The proofs are presented in sections which correspond to the earliest theory in which they can be conducted, which is the theory in which the proven theorems are stored, with one subsection for each result proven.

\section{PROOFS FOR FEF040}

The following \Product{} instructions open the theory $fef040$.

=SML
open_theory "fef040";
map delete_thm (map (hd o fst) (get_thms "fef040"));
push_pc "hol";
=TEX

\subsection{Proof of thm_040_1}

First a general result about filtering:
=SML
set_pc"hol";
set_goal([], ¨µl a b∑ (l ˘ a) ˘ b = l ˘ (a ° b)Æ);
a(REPEAT strip_tac);
a(list_induction_tac ¨lÆ THEN asm_rewrite_tac[get_spec¨$˘Æ]);
a(REPEAT strip_tac);
a(cases_tac¨x ç aÆ THEN asm_rewrite_tac[get_spec¨$˘Æ]);
(* *** Goal "1" *** *)
a(cases_tac¨x ç bÆ THEN asm_rewrite_tac[get_spec¨$˘Æ]);
(* *** Goal "1.1" *** *)
a(LEMMA_T ¨x ç a ° bÆ rewrite_thm_tac THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(LEMMA_T ¨≥x ç a ° bÆ rewrite_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_T ¨≥x ç a ° bÆ rewrite_thm_tac THEN REPEAT strip_tac);
val €˘_˘_thm› = save_pop_thm"˘_˘_thm";
=TEX
If a lattice has more than one element then {\it lattice_top} differs from {\it lattice_bottom}:
=SML
set_goal([], ¨µc∑ ≥c = lattice_top ¥ ≥lattice_top = lattice_bottomÆ);
a(contr_tac);
a(lemma_tac¨lattice_top dominates cÆ
	THEN1 rewrite_tac[get_spec¨lattice_topÆ]);
a(lemma_tac¨c dominates lattice_topÆ
	THEN1 asm_rewrite_tac[get_spec¨lattice_topÆ]);
a(all_fc_tac[get_spec¨lattice_topÆ]);
val €not_lattice_top_thm› = save_pop_thm"not_lattice_top_thm";
=TEX
The down-set from the top and the up-set from the bottom both include all elements of the type:
=SML
set_goal([], ¨
	lattice_bottom %uparrow% = Universe
±	lattice_top %downarrow% = Universe
Æ);
a(PC_T1 "sets_ext" prove_tac(map get_spec
	[¨$%uparrow%Æ, ¨$%downarrow%Æ, ¨lattice_bottomÆ]));
val €up_down_thm1› = save_pop_thm"up_down_thm1";
=TEX
Any class is a member of its own up-set and down-set.
{\it lattice_bottom} is a member of every down-set and {\it lattice_top} is amember of every up-set.
=SML
set_goal([], ¨
µc∑	c ç c %downarrow%
± 	c ç c %uparrow%
± 	lattice_bottom ç c %downarrow%
± 	lattice_top ç c %uparrow%
Æ);
a(PC_T1 "sets_ext" prove_tac(map get_spec
	[¨$%uparrow%Æ, ¨$%downarrow%Æ, ¨lattice_bottomÆ]));
val €up_down_thm2› = save_pop_thm"up_down_thm2";
=TEX
These are combined together to form a useful package of results:
=SML
val €up_down_clauses› = save_thm("up_down_clauses",
	(all_µ_intro o list_±_intro o map all_µ_elim)[up_down_thm1, up_down_thm2]);
=TEX
If class {\it d} does not dominate class {\it c} then the down-set from {\it d} is contained in the complement of the up-set from {\it c}.
=SML
set_goal([], ¨
µc d∑	≥ d dominates c ¥ d %downarrow% Ä ~(c %uparrow%)
Æ);
a(PC_T1 "sets_ext" prove_tac(map get_spec
	[¨~Æ, ¨$%uparrow%Æ, ¨$%downarrow%Æ, ¨lattice_bottomÆ]));
a(contr_tac THEN all_fc_tac[get_spec¨lattice_bottomÆ]);
val €up_down_thm3› = save_pop_thm"up_down_thm3";
=TEX
If {\it R} is a family of equivalence relations indexed by classes then {\it LiftRel R} is an {\it IndexedEquiv}.
=SML
set_merge_pcs["'bin_rel", "hol2"];
set_goal([], ¨
µR∑	(µc∑ R c ç Equivalence) ¥
	(LiftRel R) ç IndexedEquiv
Æ);
a(rewrite_tac(map get_spec[¨LiftRelÆ, ¨IndexedEquivÆ, ¨EquivalenceÆ]) THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
a(spec_nth_asm_tac 3 ¨sÆ THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
a(spec_nth_asm_tac 4 ¨sÆ THEN1 all_asm_fc_tac[]);
a(spec_nth_asm_tac 4 ¨sÆ THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(spec_nth_asm_tac 3 ¨sÆ THEN1 all_asm_fc_tac[]);
val €lift_rel_indexed_equiv_thm› = save_pop_thm"lift_rel_indexed_equiv_thm";
=TEX
{\it same_ins} is an indexed family of equivalence relations.
=SML
set_goal([], ¨
	µc∑ same_ins c ç Equivalence
Æ);
a(rewrite_tac(map get_spec[¨same_insÆ, ¨EquivalenceÆ, ¨LetÆ]) THEN
	REPEAT strip_tac THEN asm_rewrite_tac[]);
val €same_ins_equiv_thm› = save_pop_thm"same_ins_equiv_thm";
=TEX
{\it same_outs} is an indexed family of equivalence relations.
=SML
set_goal([], ¨
	µc∑ same_outs c ç Equivalence
Æ);
a(rewrite_tac(map get_spec[¨same_outsÆ, ¨EquivalenceÆ, ¨LetÆ]) THEN
	REPEAT strip_tac THEN asm_rewrite_tac[]);
val €same_outs_equiv_thm› = save_pop_thm"same_outs_equiv_thm";
=TEX
When lifted they are therefore both {\it IndexedEquiv}s.
=SML
set_goal([], ¨
	LiftRel same_ins ç IndexedEquiv
±	LiftRel same_outs ç IndexedEquiv
Æ);
a(REPEAT strip_tac THEN
	bc_tac[lift_rel_indexed_equiv_thm] THEN
	rewrite_tac[same_ins_equiv_thm, same_outs_equiv_thm]);
val €same_ins_same_outs_indexed_equiv_thm› =
	save_pop_thm"same_ins_same_outs_indexed_equiv_thm";
=TEX
In uses of the following result {\it R} will be something like {\it same_ins} or {\it same_outs} from fef003 i.e. a family of equivalence relations indexed by individual classes where R c denotes the relation ``same at or below c''.
The result says that, under a certain anti-monotonicity condition, the family {\it R} embeds in {\it LiftRel R} as the subfamily indexed by the set of all down-sets.
=SML
set_pc"hol";
set_goal([], ¨
µR∑	(µc∑ R c ç Equivalence) ±
	(µc d∑c dominates d ¥ R c Ä R d) ¥
	µc∑ (LiftRel R)(c %downarrow%) = R c
Æ);
a(rewrite_tac[get_spec¨LiftRelÆ] THEN REPEAT strip_tac);
a(PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 1 ¨R cÆ);
a(spec_nth_asm_tac 1 ¨cÆ);
a(all_fc_tac[up_down_clauses]);
(* *** Goal "2" *** *)
a(asm_ante_tac ¨c' ç c %downarrow%Æ THEN asm_rewrite_tac[get_spec¨$%downarrow%Æ]);
a(strip_tac THEN all_asm_fc_tac[] THEN PC_T1 "sets_ext" all_asm_fc_tac[]);
val €equiv_anti_mono_lift_rel_thm› = save_pop_thm"equiv_anti_mono_lift_rel_thm";
=TEX
{\it same_ins} is anti-montonic in an appropriate sense. 
=SML
set_pc"hol2";
set_goal([], ¨
	µc d∑c dominates d ¥ same_ins c Ä same_ins d
Æ);
a(rewrite_tac(map get_spec[¨same_insÆ, ¨LetÆ]) THEN
	REPEAT strip_tac THEN rename_tac[]);
a(LEMMA_T¨µx∑
	x ˘ {(q, c')|d dominates c'} =
	(x ˘ {(q, c')|c dominates c'}) ˘ {(q, c')|d dominates c'}Æ
	(fn th => once_rewrite_tac [th] THEN asm_rewrite_tac[]));
a(rewrite_tac[˘_˘_thm]);
a(LEMMA_T¨{(q, c')|c dominates c'} ° {(q, c')|d dominates c'} =
	{(q, c')|d dominates c'}Æ rewrite_thm_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(all_fc_tac[get_spec¨$dominatesÆ]);
val €same_ins_anti_mono_thm› = save_pop_thm"same_ins_anti_mono_thm";
=TEX
{\it same_outs} is anti-montonic in an appropriate sense. 
=SML
set_pc"hol2";
set_goal([], ¨
	µc d∑ c dominates d ¥ same_outs c Ä same_outs d
Æ);
a(rewrite_tac(map get_spec[¨same_outsÆ, ¨LetÆ]) THEN
	REPEAT strip_tac THEN rename_tac[]);
a(LEMMA_T¨µx∑
	x ˘ {(c', d')|d dominates c'} =
	(x ˘ {(c', d')|c dominates c'}) ˘ {(c', d')|d dominates c'}Æ
	(fn th => once_rewrite_tac [th] THEN asm_rewrite_tac[]));
a(rewrite_tac[˘_˘_thm]);
a(LEMMA_T¨{(c', d')|c dominates c'} ° {(c', d')|d dominates c'} =
	{(c', d')|d dominates c'}Æ rewrite_thm_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(all_fc_tac[get_spec¨$dominatesÆ]);
val €same_outs_anti_mono_thm› = save_pop_thm"same_outs_anti_mono_thm";
=TEX
The result says that the family {\it same_ins} embeds in {\it LiftRel same_ins} as the subfamily indexed by the set of all down-sets and similarly for {\it same_outs}
=SML
set_pc"hol";
set_goal([], ¨
µc∑	(LiftRel same_ins)(c %downarrow%) = same_ins c
±	(LiftRel same_outs)(c %downarrow%) = same_outs c
Æ);
a(REPEAT strip_tac THEN intro_µ_tac(¨c:ClassÆ, ¨c:ClassÆ) THEN
	bc_tac[equiv_anti_mono_lift_rel_thm] THEN
	rewrite_tac
	[same_ins_equiv_thm, same_outs_equiv_thm,
	same_ins_anti_mono_thm, same_outs_anti_mono_thm]);
val €lift_rel_same_ins_same_outs_down_set_thm› =
	save_pop_thm"lift_rel_same_ins_same_outs_down_set_thm";
=TEX
We are now in a position to prove {\it conj_040_1} which shows that the original security policy in \cite{DS/FMU/FEF/003} is a special case of the more generic flow policy given in \cite{DS/FMU/FEF/040}.
=SML
set_pc"hol";
set_goal([], conj_040_1);
a(rewrite_tac(map get_spec[¨secureÆ, ¨ml_secureÆ, ¨x_ml_secureÆ]) THEN
	REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[same_ins_same_outs_indexed_equiv_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[same_ins_same_outs_indexed_equiv_thm]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN
	asm_rewrite_tac[lift_rel_same_ins_same_outs_down_set_thm]);
(* *** Goal "4" *** *)
a(swap_nth_asm_concl_tac 2 THEN
	asm_rewrite_tac[lift_rel_same_ins_same_outs_down_set_thm]);
a(contr_tac THEN all_asm_fc_tac[]);
val €thm_040_1› = save_pop_thm"thm_040_1";
=TEX
\subsection{Proof of thm_040_2}
First an elementary result about disrtibuted union.
=SML
val €ﬁ_Ä_thm› = pc_rule1 "sets_ext" prove_rule[]¨µa b∑ a Ä b ¥ ﬁa Ä ﬁbÆ;
=TEX

=SML
set_merge_pcs["'bin_rel", "hol2"];
set_goal([], ¨µc∑ SameLabVal c ç EquivalenceÆ);
a(rewrite_tac(map get_spec[¨SameLabValÆ, ¨EquivalenceÆ])
	THEN REPEAT strip_tac THEN PC_T1 "prop_eq" asm_prove_tac[]);
val €same_lab_val_equiv_thm› = save_pop_thm"same_lab_val_equiv_thm";
=TEX 
=SML
set_pc"hol";
set_goal([], ¨LiftRel SameLabVal ç IndexedEquivÆ);
a(bc_tac[lift_rel_indexed_equiv_thm] THEN rewrite_tac[same_lab_val_equiv_thm]);
val €lift_rel_same_lab_val_equiv_thm› =
	save_pop_thm"lift_rel_same_lab_val_equiv_thm";
=TEX
=SML
set_pc"hol2";
set_goal([], ¨
	µc d∑c dominates d ¥ SameLabVal c Ä SameLabVal d
Æ);
a(rewrite_tac(map get_spec[¨SameLabValÆ]) THEN REPEAT strip_tac);
a(all_fc_tac[get_spec¨$dominatesÆ]);
val €same_lab_val_anti_mono_thm› = save_pop_thm"same_lab_val_anti_mono_thm";
=TEX
=SML
set_pc"hol";
set_goal([], ¨
µc∑	(LiftRel SameLabVal)(c %downarrow%) = SameLabVal c
Æ);
a(bc_tac[equiv_anti_mono_lift_rel_thm] THEN
	rewrite_tac[same_lab_val_equiv_thm, same_lab_val_anti_mono_thm]);
val €lift_rel_same_lab_val_down_set_thm› =
	save_pop_thm"lift_rel_same_lab_val_down_set_thm";
=TEX 
=SML
set_pc"hol";
set_goal([], conj_040_2);
a(rewrite_tac(lift_rel_same_lab_val_down_set_thm:: map get_spec
	[¨BoundedObsÆ, ¨ObservedValueÆ, ¨SameLabValÆ,
	¨x_ml_secureÆ, ¨InfluencedÆ]) THEN
	PC_T1 "hol2" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rename_tac[(¨x'Æ, "d")] THEN rewrite_tac[get_spec¨$%downarrow%Æ]);
a(cases_tac¨µe∑e dominates dÆ THEN1 asm_rewrite_tac[]);
a(list_spec_nth_asm_tac 4 [¨eÆ, ¨xÆ, ¨yÆ]);
a(all_fc_tac[up_down_thm3]);
a(LIST_GET_NTH_ASM_T [8]
	(ALL_FC_T (PC_T1 "sets_ext" all_fc_tac) o
		map (rewrite_rule[get_spec¨IndexedEquivÆ])));
(* *** Goal "2" *** *)
a(rename_tac[(¨x'Æ, "d")] THEN rewrite_tac[get_spec¨$%downarrow%Æ]);
a(contr_tac);
a(all_fc_tac[up_down_thm3]);
a(LIST_GET_NTH_ASM_T [7]
	(ALL_FC_T (PC_T1 "sets_ext" all_fc_tac) o
		map (rewrite_rule[get_spec¨IndexedEquivÆ])));
a(list_spec_nth_asm_tac 6 [¨C xÆ, ¨xÆ, ¨yÆ]);
a(swap_nth_asm_concl_tac 1 THEN rewrite_tac[get_spec¨lattice_bottomÆ]);
val €thm_040_2› = save_pop_thm"thm_040_2";
=TEX
\subsection{Proof of Theorem thm_040_3} 
=SML
set_pc"hol";
set_goal([], ¨µc∑c %downarrow% = •{A | ∂d∑≥c dominates d ± A = ~(d %uparrow%)}Æ);
a(rewrite_tac(map get_spec[¨$%downarrow%Æ, ¨$%uparrow%Æ]) THEN
	PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[get_spec¨~Æ]);
a(contr_tac THEN all_fc_tac[get_spec¨$dominatesÆ]);
(* *** Goal "2" *** *)
a(cases_tac¨c dominates xÆ);
a(spec_nth_asm_tac 2 ¨~{y | y dominates x}Æ);
(* *** Goal "2.1" *** *)
a(spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "2.2" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac(map get_spec[¨~Æ, ¨$dominatesÆ]));
val €down_•_comp_up_thm› = save_pop_thm"down_•_comp_up_thm";
=TEX 
=IGN SML
set_pc"hol2";
set_goal([], conj_040_3);
a(rewrite_tac(lift_rel_same_lab_val_down_set_thm:: map get_spec
	[¨BoundedObsÆ, ¨ObservedValueÆ, ¨SameLabValÆ,
	¨x_ml_secureÆ, ¨InfluencedÆ]) THEN
	PC_T1 "hol2" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[lift_rel_same_lab_val_equiv_thm]);
(* *** Goal "2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[down_•_comp_up_thm]));


a(rename_tac[(¨c'Æ, "d")] THEN 
	GET_NTH_ASM_T 2
	(strip_asm_tac o µ_elim¨iâ1Æ o pc_rule1"hol2" rewrite_rule[]));
a(rename_tac[(¨x':ClassÆ, "e")]);
a(cases_tac¨c dominates dÆ);
(* *** Goal "2.1" *** *)
=IGN SML
set_pc"hol2";
set_goal([], conj_040_3);


set_goal([],
	¨ObservedValue (c, C, V) ç ml_secure s (LiftRel SameLabVal) § UNKNOWNÆ);
a(rewrite_tac(map get_spec
	[¨ObservedValueÆ, ¨SameLabValÆ,
	¨ml_secureÆ]) THEN
	PC_T1 "hol2" REPEAT strip_tac);


val €thm_040_3› = save_pop_thm"thm_040_3";

=TEX

\section{PROOFS FOR FEF042}

The following \Product{} instructions open the theory $fef042$.

=SML
open_theory "fef042";
map delete_thm ((flat o (map fst) o get_thms) "fef042");
set_pc "hol";
=TEX
=SML
(delete_pc"'tree" handle Fail _ => ());
new_pc"'tree";
set_∂_cd_thms[tree_prim_rec_thm] "'tree";
set_merge_pcs ["'tree", "hol"];
=TEX
=SML
push_goal([], ¨µx y∑ MkTree x = MkTree y ¥ x = yÆ);
a(REPEAT strip_tac);
a(lemma_tac¨∂f∑ µz∑ f(MkTree z) = zÆ THEN1 prove_∂_tac);
a(lemma_tac¨y = f(MkTree x)Æ THEN1
	(GET_NTH_ASM_T 2 rewrite_thm_tac THEN POP_ASM_T rewrite_thm_tac));
a(POP_ASM_T rewrite_thm_tac THEN POP_ASM_T rewrite_thm_tac);
val €mk_tree_one_one_thm› = save_pop_thm"mk_tree_one_one_thm";
=TEX
=SML
push_goal([], ¨µt∑ ∂x∑ t = MkTree xÆ);
a(REPEAT strip_tac);
a(gen_induction_tac tree_induction_thm ¨tÆ);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
val €mk_tree_onto_thm› = save_pop_thm"mk_tree_onto_thm";
=TEX
=SML
push_consistency_goal¨MkObjÆ;
a(lemma_tac¨∂mk_obj∑µ c: Class; t : Text; os : Obj LIST∑
	mk_obj (c, t, os) = MkTree ((c, t), os)Æ
	THEN1 prove_∂_tac);
a(lemma_tac¨∂object_class object_text object_refers∑
	µctos: (Class ∏ Text) ∏ Obj LIST∑
	object_class (MkTree (ctos)) = Fst (Fst ctos)
±	object_text (MkTree (ctos)) = Snd(Fst ctos)
±	object_refers (MkTree (ctos)) = Snd ctosÆ
	THEN1 prove_∂_tac);
a(∂_tac ¨(mk_obj, object_class, object_text, object_refers)Æ);
a(asm_rewrite_tac[]);
save_consistency_thm¨MkObjÆ(pop_thm());
=TEX
=SML
push_goal([], ¨µ d∑ ∂â1 h∑ µ c t os∑
	h (MkObj (c, t, os)) = d c t (Map h os)Æ);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim ¨(Ãx:(Class ∏ Text) ∏ Obj LIST; y∑
	d (Fst(Fst x)) (Snd(Fst x)) y)Æ tree_prim_rec_thm));
a(∂â1_tac¨hÆ THEN asm_rewrite_tac[get_spec¨MkObjÆ]);
a(REPEAT strip_tac);
a(lemma_tac¨µ ctos∑ h' (MkTree ctos) =
		d (Fst (Fst ctos)) (Snd (Fst ctos)) (Map h' (Snd ctos))Æ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T¨ctos = ((Fst (Fst ctos), Snd (Fst ctos)), Snd ctos)Æ
	once_rewrite_thm_tac THEN1 rewrite_tac[]);
a(TOP_ASM_T pure_rewrite_thm_tac);
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨µ x
           ∑ h' (MkTree x)
               = (Ã x y∑ d (Fst (Fst x)) (Snd (Fst x)) y) x (Map h' (Snd x))Æ
	THEN1 asm_rewrite_tac[]);
a(all_asm_fc_tac[]);
val €obj_prim_rec_thm› = save_pop_thm"obj_prim_rec_thm";
=TEX
=SML
push_goal([], ¨
(µ x∑ MkObj x = MkTree ((Fst x, Fst(Snd x)), Snd(Snd x))) ±
µ ctos∑	objectClass(MkTree ctos) = Fst (Fst ctos)
±	 objectContains(MkTree ctos) = Snd (Fst ctos)
±	 objectRefers(MkTree ctos) = Snd ctos
Æ);
a(lemma_tac ¨µ x∑ MkObj x = MkTree ((Fst x, Fst(Snd x)), Snd(Snd x))Æ);
(* *** Goal "1" *** *)
a(strip_tac);
a(LEMMA_T ¨x = (Fst x, (Fst(Snd x)), Snd(Snd x))Æ once_rewrite_thm_tac
	THEN1 rewrite_tac[]);
a(pure_rewrite_tac[get_spec¨MkObjÆ]);
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(ante_tac (get_spec¨MkObjÆ) THEN asm_rewrite_tac[]);
a(strip_tac THEN strip_tac);
a(LEMMA_T ¨ctos = ((Fst (Fst ctos), Snd (Fst ctos)), Snd ctos)Æ once_rewrite_thm_tac
	THEN1 rewrite_tac[]);
a(pure_asm_rewrite_tac[]);
a(rewrite_tac[]);
val €object_clauses› = save_pop_thm"object_clauses";
=TEX
=SML
=TEX
\subsection{Consistency of {\it list_machine}}

=SML
push_consistency_goal¨lift_machineÆ;
a (prove_∂_tac THEN strip_tac);
a (lemma_tac ¨∂ lm ∑ 
	(lm [] = Ãs∑([], s))
 ± (µ r rl ∑
	lm (Cons r rl) =
	Ã s ∑ (let out = Output mch' (s, r) and s' = Next mch' (s, r)
             in let (outl, final_state) = lm rl s'
                in (Cons out outl, final_state)))Æ
	THEN1 prove_∂_tac);
a (∂_tac ¨Ãs rl∑ lm rl sÆ);
a (asm_rewrite_tac[]);
save_consistency_thm¨lift_machineÆ(pop_thm());
=TEX
=IGN
push_consistency_goal¨output_seqÆ;
a(lemma_tac ¨∂os : Req LIST ≠ 'State Machine ≠ 'State ≠ Obj LIST∑
	µr rs mch s∑
	os [] mch s = []
±	os (Cons r rs) mch s =
	Cons
	(Output mch (s, r))
	(os rs mch (Next mch (s, r)))Æ
	THEN1 prove_∂_tac);
a(∂_tac¨Ãmch (s, rs)∑ os rs mch sÆ);
a(asm_rewrite_tac[]);
save_consistency_thm¨output_seqÆ(pop_thm());
=TEX
Following is lengthy but not really difficult.
The basic idea is to define a propositional function by primitive recursion over trees which represents the set function required for the witness.
The proof is then just a check that the formula defining the propositional function is essentially the same as the one the witness is required to satisfy.
This involves (inter alia) two inductive proofs of two little lemmas about the formulae which are used to ``combine the recursive applications''.
=SML
push_consistency_goal¨identicalObjÆ;
a(lemma_tac ¨∂io : Obj ≠ Class ≠ Obj ≠ BOOL∑ µctos c oâ2∑
	io (MkTree ctos) c oâ2 §
	∂ câ1 tâ1 osâ1 câ2 tâ2 osâ2∑
		(MkTree ctos) = MkObj (câ1, tâ1, osâ1)
	±	oâ2 = MkObj (câ2, tâ2, osâ2)
	±	câ1 = câ2
	±	(	c dominates câ1
		¥	tâ1 = tâ2
		±	Length osâ1 = Length osâ2
		±	µp o2∑ (p, o2) ç
			Elems (Combine (Map io (Snd ctos)) osâ2)
			¥	p c o2)Æ
	THEN1 prove_∂_tac);
a(∂_tac¨Ãc∑ {(o1, o2) | io o1 c o2}Æ THEN
	PC_T1 "sets_ext1" asm_rewrite_tac[object_clauses]);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(µ_elim¨x1Æ mk_tree_onto_thm) THEN var_elim_nth_asm_tac 1);
a(strip_asm_tac(µ_elim¨x2Æ mk_tree_onto_thm) THEN var_elim_nth_asm_tac 1);
a(MAP_EVERY ∂_tac[
	¨Fst(Fst x)Æ, ¨Snd(Fst x)Æ, ¨Snd xÆ,
	¨Fst(Fst x')Æ, ¨Snd(Fst x')Æ, ¨Snd x'Æ]
	THEN rewrite_tac[]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[object_clauses]);
a(strip_tac);
(* *** Goal "1.1" *** *)
a(all_fc_tac[mk_tree_one_one_thm]);
a(MAP_EVERY var_elim_nth_asm_tac [1,1,2]);
a(asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(all_fc_tac[mk_tree_one_one_thm]);
a(MAP_EVERY var_elim_nth_asm_tac [1,1,3,3]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(POP_ASM_T ante_tac);
a(intro_µ_tac(¨osâ1Æ, ¨osâ1Æ));
a(list_induction_tac¨osâ2Æ);
(* *** Goal "1.2.1" *** *)
a(rewrite_tac[get_spec¨LengthÆ, length_0_thm]);
a(REPEAT_N 2 strip_tac THEN asm_rewrite_tac(map get_spec
	[¨CombineÆ, ¨MapÆ, ¨ElemsÆ]));
(* *** Goal "1.2.2" *** *)
a(rewrite_tac[get_spec¨LengthÆ, length_0_thm]);
a(REPEAT µ_tac);
a(strip_asm_tac(µ_elim¨osâ1Æ list_cases_thm) THEN var_elim_nth_asm_tac 1
	THEN rewrite_tac[get_spec¨LengthÆ]);
a(PC_T1 "sets_ext1" rewrite_tac(map get_spec [¨CombineÆ, ¨MapÆ, ¨ElemsÆ]));
a(REPEAT strip_tac);
(* *** Goal "1.2.2.1" *** *)
a(MAP_EVERY var_elim_nth_asm_tac [1,1]);
a(list_spec_nth_asm_tac 2 [¨io x'Æ, ¨xÆ]);
(* *** Goal "1.2.2.2" *** *)
a(lemma_tac¨µ p o2∑ (p, o2) ç Elems (Combine (Map io list2) osâ2) ¥ p c o2Æ
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
a(rename_tac[] THEN rewrite_tac[object_clauses]);
a(MAP_EVERY ∂_tac[
	¨câ1Æ, ¨tâ1Æ, ¨osâ1Æ,
	¨câ2Æ, ¨tâ2Æ, ¨osâ2Æ]
	THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
a(MAP_EVERY ∂_tac[
	¨câ2Æ, ¨tâ2Æ, ¨osâ1Æ,
	¨câ2Æ, ¨tâ2Æ, ¨osâ2Æ]
	THEN asm_rewrite_tac[]);
a(rewrite_tac[object_clauses]);
a(REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [1,3,4] (MAP_EVERY ante_tac));
a(LIST_DROP_NTH_ASM_T [1,2,3,4,5,6] discard_tac);
a(intro_µ_tac(¨osâ1Æ, ¨osâ1Æ));
a(list_induction_tac¨osâ2Æ);
(* *** Goal "3.1" *** *)
a(rewrite_tac[get_spec¨LengthÆ, length_0_thm]);
a(REPEAT µ_tac);
a(strip_asm_tac(µ_elim¨osâ1Æ list_cases_thm) THEN var_elim_nth_asm_tac 1
	THEN rewrite_tac[get_spec¨LengthÆ]);
a(PC_T1 "sets_ext1" rewrite_tac(map get_spec [¨CombineÆ, ¨MapÆ, ¨ElemsÆ]));
(* *** Goal "3.2" *** *)
a(rewrite_tac[get_spec¨LengthÆ, length_0_thm]);
a(REPEAT µ_tac);
a(strip_asm_tac(µ_elim¨osâ1Æ list_cases_thm) THEN var_elim_nth_asm_tac 1
	THEN rewrite_tac[get_spec¨LengthÆ]);
a(PC_T1 "sets_ext1" rewrite_tac(map get_spec [¨CombineÆ, ¨MapÆ, ¨ElemsÆ]));
a(REPEAT strip_tac);
(* *** Goal "3.2.1" *** *)
a(MAP_EVERY var_elim_nth_asm_tac [1,1]);
a(list_spec_nth_asm_tac 1 [¨x'Æ, ¨xÆ]);
(* *** Goal "3.2.2" *** *)
a(lemma_tac¨µ x1 x2∑ (x1, x2) ç Elems (Combine list2 osâ2) ¥ io x1 c x2Æ
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
a(all_asm_fc_tac[]);
save_consistency_thm¨identicalObjÆ(pop_thm());
=TEX
=SML
push_consistency_goal¨FilterObjÆ;
a(rewrite_tac[object_clauses]);
a(lemma_tac ¨∂f : Class ≠ Obj ≠ Obj∑ µ c dtos∑
	f c (MkTree dtos) =
	let (d, t) = Fst dtos
	in	if c dominates d
                   then MkTree ((d, t), Map (f c) (Snd dtos))
                   else MkTree ((d, Arbitrary), Arbitrary)Æ
	THEN1 prove_∂_tac);
a(∂_tac¨fÆ THEN asm_rewrite_tac[let_def]);
save_consistency_thm¨FilterObjÆ(pop_thm());
=IGN
Some results about {\it sameRequests}
set_goal ([], ¨LiftRel sameRequests ç IndexedEquivÆ);
a (rewrite_tac (map get_spec [¨LiftRelÆ,¨IndexedEquivÆ]));
a (rewrite_tac (map get_spec [¨LiftRelÆ,¨sameRequestsÆ,¨IndexedEquivÆ]));
=SML

=SML
set_merge_pcs["'bin_rel", "hol2"];
=TEX
=SML
val conj_042_1_1 = ¨
µc ob1 ob2∑
	(ob1, ob2) ç identicalObj c
§	FilterObj c ob1 = FilterObj c ob2Æ;
=TEX
=SML
push_goal([], ¨µl x y∑ (x, y) ç Elems(Combine l l) §  y ç Elems l ± x = yÆ);
a(strip_tac);
a(list_induction_tac¨lÆ THEN asm_rewrite_tac(map get_spec[¨ElemsÆ, ¨CombineÆ]));
a(REPEAT strip_tac THEN_TRY all_var_elim_asm_tac1 THEN REPEAT strip_tac);
val €elems_combine_thm› = save_pop_thm"elems_combine_thm";
=TEX
=SML
push_goal([], ¨µl1 l2 x y∑
	Length l1 = Length l2 ± (x, y) ç Elems(Combine l1 l2)
	¥ x ç Elems l1Æ);
a(strip_tac);
a(list_induction_tac¨l1Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(all_asm_ante_tac THEN
	strip_asm_tac(µ_elim¨l2Æ list_cases_thm) THEN var_elim_nth_asm_tac 1
	THEN rewrite_tac(map get_spec[¨ElemsÆ, ¨CombineÆ, ¨LengthÆ]));
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(all_asm_ante_tac THEN
	strip_asm_tac(µ_elim¨l2Æ list_cases_thm) THEN var_elim_nth_asm_tac 1
	THEN rewrite_tac(map get_spec[¨ElemsÆ, ¨CombineÆ, ¨LengthÆ]));
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
val €elems_combine_elems_thm› = save_pop_thm"elems_combine_elems_thm";
=TEX
=SML
push_goal([], ¨µl1 l2 x1 x2∑
	Length l1 = Length l2 ±
	(x1, x2) ç Elems(Combine l1 l2) ¥ (x2, x1) ç Elems(Combine l2 l1)  Æ);
a(strip_tac);
a(list_induction_tac¨l1Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(all_asm_ante_tac THEN
	strip_asm_tac(µ_elim¨l2Æ list_cases_thm) THEN var_elim_nth_asm_tac 1
	THEN rewrite_tac(map get_spec[¨ElemsÆ, ¨CombineÆ, ¨LengthÆ]));
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(all_asm_ante_tac THEN
	strip_asm_tac(µ_elim¨l2Æ list_cases_thm) THEN var_elim_nth_asm_tac 1
	THEN rewrite_tac(map get_spec[¨ElemsÆ, ¨CombineÆ, ¨LengthÆ]));
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
val €elems_combine_swap_thm› = save_pop_thm"elems_combine_swap_thm";
=TEX
=SML
push_goal([], ¨µf l1 l2 x1 x2∑
	Length l1 = Length l2 ±
	(x1, x2) ç Elems(Combine l1 l2) ±
	Map f l1 = Map f l2 ¥
	f x1 = f x2Æ);
a(REPEAT_N 2 strip_tac);
a(list_induction_tac¨l1Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(all_asm_ante_tac THEN
	strip_asm_tac(µ_elim¨l2Æ list_cases_thm) THEN var_elim_nth_asm_tac 1
	THEN rewrite_tac(map get_spec[¨ElemsÆ, ¨CombineÆ, ¨LengthÆ]));
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(all_asm_ante_tac THEN
	strip_asm_tac(µ_elim¨l2Æ list_cases_thm) THEN var_elim_nth_asm_tac 1
	THEN rewrite_tac(map get_spec[¨MapÆ, ¨ElemsÆ, ¨CombineÆ, ¨LengthÆ]));
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(all_var_elim_asm_tac1);
val €elems_combine_map_thm› = save_pop_thm"elems_combine_map_thm";
=TEX
=SML
push_goal([], ¨µf l1 l2∑
	Length l1 = Length l2 ±
	(µy1 y2∑ (y1, y2) ç Elems(Combine l1 l2) ¥ f y1 = f y2) ¥
	Map f l1 = Map f l2Æ);
a(REPEAT_N 2 strip_tac);
a(list_induction_tac¨l1Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(all_asm_ante_tac THEN
	strip_asm_tac(µ_elim¨l2Æ list_cases_thm) THEN var_elim_nth_asm_tac 1
	THEN rewrite_tac(map get_spec[¨ElemsÆ, ¨CombineÆ, ¨LengthÆ]));
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(all_asm_ante_tac THEN
	strip_asm_tac(µ_elim¨l2Æ list_cases_thm) THEN var_elim_nth_asm_tac 1
	THEN rewrite_tac(map get_spec[¨MapÆ, ¨ElemsÆ, ¨CombineÆ, ¨LengthÆ]));
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.1" *** *)
a(list_spec_nth_asm_tac 1 [¨xÆ, ¨x'Æ]);
(* *** Goal "2.2" *** *)
a(list_spec_nth_asm_tac 3 [¨list2Æ]);
a(all_asm_fc_tac[]);
val €elems_combine_map_thm1› = save_pop_thm"elems_combine_map_thm1";
=TEX
=SML
push_goal([], ¨µ P
  ∑ (µ c t ts∑ (µ t∑ t ç Elems ts ¥ P t) ¥ P (MkObj(c, t, ts))) ¥ (µ t∑ P t)Æ);
a(rewrite_tac[object_clauses] THEN REPEAT strip_tac);
a(gen_induction_tac tree_induction_thm ¨tÆ);
a(POP_ASM_T ante_tac);
a(PC_T1 "predicates" lemma_tac¨∂c t ts∑ x = ((c, t), ts)Æ 
	THEN1 (MAP_EVERY ∂_tac[¨Fst (Fst x)Æ, ¨Snd (Fst x)Æ, ¨Snd xÆ]
			THEN REPEAT strip_tac));
a(asm_rewrite_tac[]);
val €obj_induction_thm› = save_pop_thm"obj_induction_thm";
=TEX
=SML
set_goal([], ¨µ c ob1 ob2∑
	(ob1, ob2) ç identicalObj c ¥ FilterObj c ob1 = FilterObj c ob2Æ);
a(REPEAT_N 2 strip_tac);
a(gen_induction_tac obj_induction_thm ¨ob1Æ);
a(rewrite_tac(map get_spec[¨FilterObjÆ]));
a(once_rewrite_tac(map get_spec[¨identicalObjÆ]));
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1);
a(rewrite_tac(map get_spec[¨FilterObjÆ]));
a(DROP_NTH_ASM_T 2 ante_tac
	THEN rewrite_tac[object_clauses]);
a(REPEAT strip_tac THEN all_fc_tac[mk_tree_one_one_thm]);
a(all_var_elim_asm_tac1);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(rewrite_tac(map get_spec[¨FilterObjÆ]));
a(DROP_NTH_ASM_T 3 ante_tac
	THEN rewrite_tac[object_clauses]);
a(REPEAT strip_tac THEN all_fc_tac[mk_tree_one_one_thm]);
a(all_var_elim_asm_tac1);
a(cases_tac ¨c dominates câ2Æ THEN asm_rewrite_tac[]);
a(LEMMA_T ¨Map (FilterObj c) ob1s = Map (FilterObj c) osâ2Æ rewrite_thm_tac);
a(POP_ASM_T discard_tac THEN all_asm_ante_tac THEN
	intro_µ_tac(¨osâ2Æ, ¨osâ2Æ)
	THEN list_induction_tac ¨ob1sÆ);
(* *** Goal "2.1" *** *)
a(strip_tac);
a(strip_asm_tac(µ_elim¨osâ2Æ list_cases_thm) THEN var_elim_nth_asm_tac 1
	THEN rewrite_tac(map get_spec[¨ElemsÆ, ¨CombineÆ, ¨LengthÆ]));
(* *** Goal "2.2" *** *)
a(REPEAT_N 2 strip_tac);
a(strip_asm_tac(µ_elim¨osâ2Æ list_cases_thm) THEN var_elim_nth_asm_tac 1
	THEN rewrite_tac(map get_spec[¨ElemsÆ, ¨CombineÆ, ¨LengthÆ]));
a(REPEAT strip_tac);
a(rewrite_tac[get_spec¨MapÆ]);
a(list_spec_nth_asm_tac 1 [¨xÆ, ¨x'Æ]);
a(list_spec_nth_asm_tac 4 [¨xÆ]);
a(list_spec_nth_asm_tac 1 [¨x'Æ]);
a(POP_ASM_T rewrite_thm_tac);
a(list_spec_nth_asm_tac 6 [¨list2Æ] THEN all_asm_fc_tac[]);
val €identical_obj_filter_obj_thm1› = save_pop_thm"identical_obj_filter_obj_thm1";
=TEX
=SML
set_goal([], ¨µ c ob1 ob2∑
	FilterObj c ob1 = FilterObj c ob2 ¥ (ob1, ob2) ç identicalObj cÆ);
a(REPEAT_N 2 strip_tac);
a(gen_induction_tac obj_induction_thm ¨ob1Æ);
a(rewrite_tac(map get_spec[¨FilterObjÆ]));
a(once_rewrite_tac(map get_spec[¨identicalObjÆ]));
a(REPEAT strip_tac);
a(rewrite_tac[object_clauses]);
a(strip_asm_tac(µ_elim¨ob2Æ mk_tree_onto_thm) THEN var_elim_nth_asm_tac 1);
a(PC_T1 "predicates" lemma_tac¨∂d u us∑ x = ((d, u), us)Æ
	THEN1 (MAP_EVERY ∂_tac[¨Fst (Fst x)Æ, ¨Snd (Fst x)Æ, ¨Snd xÆ]
			THEN REPEAT strip_tac));
a(var_elim_nth_asm_tac 1);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[object_clauses,
	rewrite_rule[object_clauses](get_spec¨FilterObjÆ)]));
a(lemma_tac¨c' = dÆ);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN cases_tac ¨c dominates c'Æ
	THEN cases_tac¨c dominates dÆ THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac THEN all_fc_tac[mk_tree_one_one_thm]);
(* *** Goal "2" *** *)
a(var_elim_nth_asm_tac 1);
a(MAP_EVERY ∂_tac[¨dÆ, ¨ob1Æ, ¨ob1sÆ, ¨dÆ, ¨uÆ, ¨usÆ]);
a(POP_ASM_T ante_tac THEN cases_tac¨c dominates dÆ THEN asm_rewrite_tac[]);
a(strip_tac THEN all_fc_tac[mk_tree_one_one_thm]);
a(var_elim_nth_asm_tac 2);
a(LEMMA_T¨Length(Map (FilterObj c) ob1s) = Length(Map (FilterObj c) us)Æ
	(strip_asm_tac o rewrite_rule[length_map_thm]) THEN1 asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(all_fc_tac[elems_combine_map_thm, elems_combine_elems_thm]);
a(all_asm_fc_tac[]);
val €identical_obj_filter_obj_thm2› = save_pop_thm"identical_obj_filter_obj_thm2";
=TEX
=SML
set_goal([], ¨
	µ c∑ identicalObj c = {(ob1, ob2) | FilterObj c ob1 = FilterObj c ob2} Æ);
a(REPEAT strip_tac THEN
	all_fc_tac[identical_obj_filter_obj_thm1, identical_obj_filter_obj_thm2]);
val €identical_obj_filter_obj_thm› = save_pop_thm"identical_obj_filter_obj_thm";
=TEX
=SML
push_goal([], ¨µc ob∑ (ob, ob) ç identicalObj cÆ);
a(rewrite_tac[identical_obj_filter_obj_thm]);
val €identical_obj_refl_thm› = save_pop_thm"identical_obj_refl_thm";
=TEX
=SML
push_goal([], ¨µc ob1 ob2∑
	(ob1, ob2) ç identicalObj c ¥ (ob2, ob1) ç identicalObj cÆ);
a(rewrite_tac[identical_obj_filter_obj_thm]);
a(PC_T1 "prop_eq" prove_tac[]);
val €identical_obj_sym_thm› = save_pop_thm"identical_obj_sym_thm";
=TEX
=SML
push_goal([], ¨µc ob1 ob2 ob3∑
	(ob1, ob2) ç identicalObj c ± (ob2, ob3) ç identicalObj c
	¥ (ob1, ob3) ç identicalObj cÆ);
a(rewrite_tac[identical_obj_filter_obj_thm]);
a(PC_T1 "prop_eq" prove_tac[]);
val €identical_obj_trans_thm› = save_pop_thm"identical_obj_trans_thm";
=TEX
=SML
push_goal([], ¨µ c
           ∑ identicalObj c ç Reflexive
               ± identicalObj c ç Symmetric
               ± identicalObj c ç TransitiveÆ);
a (rewrite_tac ([identical_obj_refl_thm, identical_obj_sym_thm,
	identical_obj_trans_thm] @ (map get_spec
	[¨ReflexiveÆ, ¨SymmetricÆ, ¨TransitiveÆ])));
val €identical_obj_rft_thm› = save_pop_thm "identical_obj_rft_thm";
=TEX
=SML
push_goal([], ¨µ c∑ identicalObj c ç EquivalenceÆ);
a(PC_T1 "hol2" rewrite_tac[get_spec ¨EquivalenceÆ, identical_obj_rft_thm]);
val €identical_obj_equiv_thm› = save_pop_thm"identical_obj_equiv_thm";
=TEX
=SML
set_goal([], ¨µc∑
	sameRequests c =
	{	(rs1, rs2)
	|	Map (FilterObj c o reqSsql) (rs1 ˘ VisibleReq c)
	=	Map (FilterObj c o reqSsql) (rs2 ˘ VisibleReq c)}
Æ);
a(rewrite_tac(identical_obj_filter_obj_thm::
	map get_spec[¨sameRequestsÆ, ¨sameRequestÆ, ¨LetÆ]));
a(REPEAT strip_tac);
a(lemma_tac ¨µ x1' x2'
           ∑ (x1', x2') ç Elems (Combine (x1 ˘ VisibleReq c) (x2 ˘ VisibleReq c))
               ¥ (FilterObj c o reqSsql) x1' = (FilterObj c o reqSsql) x2'Æ);
(* *** Goal "1.1" *** *)
a(rewrite_tac[] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a(all_fc_tac[elems_combine_map_thm1]);
(* *** Goal "2" *** *)
a(LEMMA_T¨Length(Map (FilterObj c o reqSsql) (x1 ˘ VisibleReq c)) =
	Length(Map (FilterObj c o reqSsql) (x2 ˘ VisibleReq c))Æ
	(strip_asm_tac o rewrite_rule[length_map_thm]) THEN1 asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(LEMMA_T¨(FilterObj c o reqSsql) x1' = (FilterObj c o reqSsql) x2'Æ
	(rewrite_thm_tac o rewrite_rule[]));
a(LEMMA_T¨Length(Map (FilterObj c o reqSsql) (x1 ˘ VisibleReq c)) =
	Length(Map (FilterObj c o reqSsql) (x2 ˘ VisibleReq c))Æ
	(strip_asm_tac o rewrite_rule[length_map_thm]) THEN1 asm_rewrite_tac[]);
a(all_fc_tac[elems_combine_map_thm]);
val €same_requests_filter_obj_thm› = save_pop_thm "same_requests_filter_obj_thm";
=TEX
=SML
set_goal([], ¨µc∑ sameRequests c ç EquivalenceÆ);
a(rewrite_tac(same_requests_filter_obj_thm::map get_spec[¨EquivalenceÆ])
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[]);
val €same_requests_equiv_thm› = save_pop_thm "same_requests_equiv_thm";
=TEX
=SML
set_goal([], ¨µc∑ sameOutputs c ç EquivalenceÆ);
a(rewrite_tac(map get_spec[¨sameOutputsÆ, ¨EquivalenceÆ])
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[]);
val €same_outputs_equiv_thm› = save_pop_thm "same_outputs_equiv_thm";
=TEX
=SML
set_goal([], ¨LiftRel sameRequests ç IndexedEquivÆ);
a(bc_tac[lift_rel_indexed_equiv_thm] THEN rewrite_tac[same_requests_equiv_thm]);
val €same_requests_indexed_equiv_thm› = save_pop_thm "same_requests_indexed_equiv_thm";
=TEX
=SML
set_goal([], ¨LiftRel sameOutputs ç IndexedEquivÆ);
a(bc_tac[lift_rel_indexed_equiv_thm] THEN rewrite_tac[same_outputs_equiv_thm]);
val €same_outputs_indexed_equiv_thm› = save_pop_thm "same_outputs_indexed_equiv_thm";
=TEX
\section{PROOFS ABOUT FEF043}

The following \Product{} instructions open the theory $fef043$.

=SML
open_theory "fef043";
map delete_thm (map (hd o fst) (get_thms "fef043"));
set_pc "hol2";
=TEX

\subsection{Consistency Proof}

The simplest consistency proof is obtained by using a constant function as follows.

πHOLCONST
‹	€simplest_witness› : 'State FactoredMachine
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹    simplest_witness =
‹	let next = Ã sr ∑ Arbitrary
‹	and output = Ã sr ∑  Arbitrary
‹	and init = Arbitrary
‹	and f0 = Ã c ob s ∑ Arbitrary
‹	in	let (f1,f2,f3) = (f0,f0,f0)
‹	in	let	mach = MkMachine next output init
‹		and	facs = MkFactorisation f0 f1 f2 f3
‹		in	MkFactoredMachine mach facs
∞

=SML
set_goal([],¨
	machine simplest_witness =
		MkMachine (Ã sr ∑  Arbitrary) (Ã sr ∑  Arbitrary) Arbitrary
 ±	factors simplest_witness =
		MkFactorisation (Ã c ob s ∑ Arbitrary) (Ã c ob s ∑ Arbitrary)
		(Ã c ob s ∑ Arbitrary) (Ã c ob s ∑ Arbitrary)
 Æ);
a (rewrite_tac (let_def::(map get_spec [¨simplest_witnessÆ,¨machineÆ])));
val lemma_043_1 = save_pop_thm "lemma_043_1";
=TEX
set_labelled_goal "2";

=IGN SML
set_goal([],¨LiftRel (same_at_c_below_level 1) ç IndexedEquivÆ);
set_goal([],¨µn c∑ (same_at_c_below_level n c) ç EquivalenceÆ);
a (REPEAT strip_tac);
a (induction_tac ¨nÆ);
(* *** Goal "1" *** *)
a (rewrite_tac (
	(map get_spec [
	¨same_at_c_below_levelÆ, ¨EquivalenceÆ, ¨ReflexiveÆ,
	¨SymmetricÆ, ¨TransitiveÆ])
	@
	[identical_obj_refl_thm, identical_obj_sym_thm,
	identical_obj_trans_thm]));
(* *** Goal "2" *** *)
a (asm_rewrite_tac (
	(map get_spec [
	¨same_at_c_below_levelÆ, ¨EquivalenceÆ])
	@
	[identical_obj_refl_thm, identical_obj_sym_thm,
	identical_obj_trans_thm]));
a (REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (rewrite_tac [get_spec ¨ReflexiveÆ]);
a (REPEAT strip_tac
	THEN all_fc_tac [elems_combine_thm]
	THEN asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 4 ante_tac
	THEN rewrite_tac (map get_spec [¨EquivalenceÆ, ¨ReflexiveÆ,
	¨SymmetricÆ, ¨TransitiveÆ]));
a (REPEAT strip_tac THEN asm_rewrite_tac[]);	
(* *** Goal "2.2" *** *)
a (rewrite_tac [get_spec ¨SymmetricÆ]);
a (REPEAT_N 3 strip_tac
	THEN asm_rewrite_tac[]);
a (REPEAT strip_tac);
a (DROP_NTH_ASM_T 4
	(strip_asm_tac o
	(rewrite_rule (map get_spec [¨EquivalenceÆ, ¨SymmetricÆ]))));
a (all_asm_fc_tac[]);

	THEN all_fc_tac [elems_combine_thm]
	THEN asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 4 ante_tac
	THEN rewrite_tac (map get_spec [¨EquivalenceÆ, ¨ReflexiveÆ,
	¨SymmetricÆ, ¨TransitiveÆ]));
a (REPEAT strip_tac THEN asm_rewrite_tac[]);	


¨same_at_c_below_levelÆ,
	THEN_TRY asm_rewrite_tac[identical_obj_rft_thm]);
(* *** Goal "2" *** *)
=TEX
=IGN SML
set_goal([],¨LiftRel (same_at_c_below_level 2) ç IndexedEquivÆ);
=TEX
=IGN SML
set_goal([],¨LiftRel (same_at_c_below_level 3) ç IndexedEquivÆ);
=IGN SML
set_goal([],¨simplest_witness ç label_secureÆ);
a (rewrite_tac ((map get_spec [
	¨label_secureÆ , ¨label_secure_toÆ, ¨factor0Æ
	])@[let_def, lemma_043_1]));
a (rewrite_tac ([let_def, same_requests_indexed_equiv_thm]@(map get_spec [
	¨ml_secureÆ,¨x_ml_secureÆ,¨special_machineÆ,¨machineÆ,¨NextÆ,¨$ªâfÆ])));
=GFT
(* *** Goal "" *** *)

(* ?Ù *)  ¨(LiftRel (same_at_c_below_level 1) ç IndexedEquiv
               ± (µ c iâ1 iâ2
               ∑ (iâ1, iâ2) ç LiftRel sameRequests (c %downarrow%)
                   ¥ (Arbitrary, Arbitrary)
                     ç LiftRel (same_at_c_below_level 1) (c %downarrow%)))
             ± (LiftRel (same_at_c_below_level 2) ç IndexedEquiv
               ± (µ c iâ1 iâ2
               ∑ (iâ1, iâ2) ç LiftRel sameRequests (c %downarrow%)
                   ¥ (Arbitrary, Arbitrary)
                     ç LiftRel (same_at_c_below_level 2) (c %downarrow%)))
             ± LiftRel (same_at_c_below_level 3) ç IndexedEquiv
             ± (µ c iâ1 iâ2
             ∑ (iâ1, iâ2) ç LiftRel sameRequests (c %downarrow%)
                 ¥ (Arbitrary, Arbitrary)
                   ç LiftRel (same_at_c_below_level 3) (c %downarrow%))Æ
=IGN SML
(* *** Goal "1" *** *)
(* a (REPEAT strip_tac);
a (rewrite_tac [let_def]);
a (rewrite_tac (map get_spec [¨LiftRelÆ]));
a (rewrite_tac (map get_spec [¨lift_machineÆ]));
*)
=TEX


\section{CLOSING DOWN}

The following \Product{} instruction restores the previous proof context.

=SML
pop_pc();
=TEX
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}
