=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Specifications of $hide$ and $updateState$}  %% Mandatory field
\TPPref{DS/FMU/FEF/005}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{92/05/28
}}  %% Mandatory field (with sensible default)
\TPPstatus{Approved}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{The formal specifications of the functions $hide$ and $updateState$  for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{92/05/28
}}) ]  First approved version.
\end{description}

\subsection{Changes Forecast}
Changes  may be necessary  as a result of issues raised
during  the transcription of the specification.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document gives a formal specification of the functions $hide$ and $updateState$. It constitutes deliverable D2 of work package 1a, as given
in section 7 of the Secure Database Technical Proposal, \cite{DS/FMU/017}.

\subsection{Introduction}
In the introduction to \cite{DS/FMU/FEF/004} we stated that
 the formalisation of the semantics of
SSQL is to be presented in three main parts. Two of these parts, the functions
 $hide$ and $updateState$, are concerned with the security 
aspects of the SSQL semantics. The functions
 $hide$ and $updateState$ are formalised in this document.
\section{PRELIMINARIES}
The following ICL HOL instructions set up the new theory $fef005$ and set the context 
for the proof tools.
=SML 
open_theory "fef004";
new_theoryÛ"fef005"İ;
push_pc "hol2";
=TEX

\section{THE FUNCTION $hide$}

The purpose of the $hide$ function is to return a  version of the database that does not
include any information the existence
of which the user is not cleared to know, nor does it contain the true value of any field which the user is not cleared to see. This is achieved as follows :
\begin{description}
\item[Section \ref{CLEANTABLE}]
A function $cleanTable$ is defined which takes a table and
a clearance and returns a table which has been cleaned in the following way: 
A table that the user is not permitted to access is replaced by an `empty' table; otherwise,
  all the rows and columns  about whose 
existence the user is not cleared to know are removed, and all the data the user is
not cleared to see is replaced by dummy data.
\item[Section \ref{CLEANDIRECTORY}]
A function $cleanDirectory$ is defined which takes a directory and
a clearance and returns a directory which has been cleaned in the following way: if the user is 
not permitted to know of the existence of the tables in the directory
then a directory with no tables in it is returned; otherwise
the tables in the directory are cleaned by $cleanTable$.
\item[Section \ref{CLEANSTATE}]
Finally, the function $hide$ is defined which takes a state and a clearance
and returns a state which has been cleaned in the following way: all directories about whose 
existence the user is not cleared to know are removed and the rest are cleaned by $cleanDirectory$.
\end{description}
\subsection{Cleaning a Table} \label{CLEANTABLE}
In the case where the user is permitted to know of the existence of a table, but is not permitted
to access it, i.e. his clearance does not dominate the table class, an `empty' table, $stubTable$,
 is left in the 
directory in place of that table. We define a classification $stubClass$ for such tables.

¹HOLCONST
Ü	ÛstubClassİ : Class
÷üüüüüüüüüüüüüü
Ü	T
°

¹HOLCONST
Ü	ÛstubTableİ : TableSpec
÷üüüüüüüüüüüüüü
Ü	stubTable = MkTableSpec stubClass stubClass{}{}[]
°

All other tables are cleaned in the following way
\begin{itemize}
\item
Remove from the column constraints those groups
of columns about whose existence the user is 
not cleared to know.
\item
Remove any  columns about whose existence the user is 
not cleared to know. 
\item
Remove any  rows about whose existence the user is 
not cleared to know. 
\item
Remove data from columns of remaining rows about whose existence the user is 
not cleared to know.
\item
Replace data that the user is
not cleared to see by  dummy values.
\end{itemize}

\subsubsection{Clean Column Constraints}

A function that takes a clearance and a table
and returns a pair: the column constraints for columns whose
existence is dominated by the clearance,  and the corresponding set of columns.


¹HOLCONST
Ü	ÛcleanColConsİ : Class ­ TableSpec ­ (ColCons ¸ ColSpec ğ)
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; ts: TableSpec
Ü	· 	cleanColCons clear ts 
Ü		=
Ü		let 	ccs = TS_cons ts ’ {cc|clear dominates (CC_exist cc)}
Ü		in 
Ü		(ccs,{col : ColSpec|(CS_consGroup col)  Dom ccs})
°

\subsubsection{Filter all Data in a Row}
Filter out the data in columns about whose existence the user is cleared to know.

¹HOLCONST
Ü	ÛfilterRowİ :  ColSpec ğ ­ (Num ª Data) ­ (Num ª Data)
÷üüüüüüüüüüüüüü
Ü	µ cols : ColSpec ğ; ds : Num ª Data  
Ü	· 	filterRow cols ds
Ü		=
Ü		{n|¶c · c  cols ± CS_posn c = n} ò ds
°



\subsubsection{Replace Data in a Row with Dummy Data}

Data consists of a classification and an item of data. An item of data that a 
user is not cleared to see is replaced by a dummy string $Hidden$
(its classification remains).

¹HOLCONST
Ü	ÛHiddenİ : String
÷üüüüüüüüüüüüüü
Ü	T	
°

¹HOLCONST
Ü	ÛdummyValİ : Val
÷üüüüüüüüüüüüüü
Ü	dummyVal = StringVal Hidden	
°


A function to replace  the value of a piece of data 
 that the user is
not cleared to see by a dummy value. 

¹HOLCONST
Ü
Ü	ÛreplaceDataİ : Class ­ Data ­ Data
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; d : Data
Ü	·	replaceData clear d
Ü		=
Ü		if ³(clear dominates (Dat_class d))
Ü		then	MkData (Dat_class d)
Ü			(ValuedItemItem (MkValuedItem worthless dummyVal))
Ü		else 	d
°


\subsubsection{Clean all Data in a Row}
Filter out the data in columns about whose existence the user is cleared to know.
Replace data in fields that the user is not cleared to see by 
dummy values.

¹HOLCONST
Ü
Ü	ÛcleanRowİ : Class ­ ColSpec ğ ­ Row ­ Row
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; cols : ColSpec ğ; r: Row
Ü	·	cleanRow clear cols r 
Ü		= 
Ü		MkRow (R_exist r)((filterRow cols (R_data r)) » (replaceData clear))
°

\subsubsection{Clean all Rows in a Table}

Delete all rows about whose existence the user is not cleared to know, and then clean remaining rows.

¹HOLCONST
Ü
Ü	ÛcleanRowsİ : Class ­ ColSpec ğ ­ Row LIST ­ Row LIST
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; cols : ColSpec ğ; rs: Row LIST
Ü	·	cleanRows clear cols rs 
Ü		= 
Ü		Map (cleanRow clear cols) (rs ù {r:Row|clear dominates (R_exist r)})
°


\subsubsection{The function $cleanTable$}

The function $cleanTable$ either returns an `empty' table or a table where  the
rows and columns that the user is not cleared to see have been removed and fields that the 
user is not cleared to see have been overwritten by dummy fields.

¹HOLCONST
Ü	ÛcleanTableİ : Class ­ TableSpec ­ TableSpec
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; ts:TableSpec
Ü	·	cleanTable clear ts
Ü		=
Ü		if 	³(clear dominates (TS_class ts))
Ü		then 	stubTable
Ü		else	let (ccs,cols) = cleanColCons clear ts
Ü			in
Ü			MkTableSpec 
Ü				(TS_class ts) 
Ü				(TS_maxRow ts) 
Ü				cols
Ü				ccs
Ü				(cleanRows clear cols (TS_rows ts))
°


\subsection{Cleaning a Directory} \label{CLEANDIRECTORY}
Any tables in a directory about whose existence the user is 
not cleared to know can be removed from that directory. These are all the
tables in a directory whose $class$ component is not
dominated by the user's clearance (i.e. the user is cleared to
know the existence of the directory, but is not cleared to
see the structure of the directory). To clean a directory, the tables in that 
directory will either be hidden or modified by $cleanTable$.

¹HOLCONST
Ü	ÛcleanDirectoryİ : Class ­ Directory ­ Directory
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; dir : Directory  
Ü	·	cleanDirectory clear dir 
Ü		=
Ü		MkDirectory 
Ü		(if	(clear dominates (Dir_class dir)) 
Ü		then 	(Dir_tables dir » cleanTable clear) 
Ü		else 	{})
Ü		(Dir_exist dir)
Ü		(Dir_class dir)
°

\subsection{Cleaning a State} \label{CLEANSTATE}
Finally, any directories about whose existence the user is 
not cleared to know can be removed from the state. All remaining directories will be
cleaned by $cleanDirectory$.

¹HOLCONST
Ü	Ûhideİ : Class ¸ State ­ State
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; s : State
Ü	· 	hide(clear,s) 
Ü		= 
Ü		(s ’ {dir | clear dominates (Dir_exist dir)}) » cleanDirectory clear
°


\section{THE FUNCTION $updateState$}

In \cite{DS/FMU/FEF/004} the function $processQuery$ is defined. This function takes a query, a user's classification and a state and returns the result of the query, i.e., the output to be seen by the user,  an update to be applied to the data base and some error messages.
The effect of a query depends on the type of the query, which may be an $Insert$, a $Delete$ 
an $UpDate$ or a $Select$. 

We have not yet determined whether it is necessary to have as a state invariant
that  column existence classifications
are in ascending order.
\subsection{Auxiliary Functions}

When a user makes an update request on a row, the position of the row in
a table will be its position after rows about whose existence the user is 
not cleared to know have been hidden. We require a function that reveals the true  row position given the 
hidden row position.

¹HOLCONST
Ü	ÛrevealRowİ : Class ­ TableSpec ­ Num ª Num
÷üüüüüüüüüüüüüü
Ü	µ clear: Class; ts : TableSpec
Ü	· 	revealRow clear ts 
Ü		= 
Ü		let	visiblerows = {r:Row|clear dominates (R_exist r)}
Ü		in	
Ü		Squash(Id(Dom((ListRel(TS_rows ts)) ’ visiblerows))) 
°

We provide the auxiliary functions $replaceRows$ and $changeSpec$ from Annex 2 {\em SSQL Abstract Machine} of the ITT \cite{ittdra}. A separate function $validTable$ is given that determines whether 
or not a table name
exists in a particular state.


¹HOLCONST
Ü	ÛreplaceRowsİ : TableSpec ­ Row LIST ­ TableSpec
÷üüüüüüüüüüüüüü
Ü	µ ts : TableSpec; rs : Row LIST
Ü	·	replaceRows ts rs 
Ü		= 
Ü		MkTableSpec(TS_class ts)(TS_maxRow ts)(TS_colspecs ts)(TS_cons ts) rs
°

¹HOLCONST
Ü	ÛvalidTableİ : Tab ­ State ­ Bool
÷üüüüüüüüüüüüüü
Ü	µ i : Tab; s:State
Ü	· 	validTable i s 
Ü		=
Ü		¶‰1 dir · (Front i,dir)  s ± Last i  Dom(Dir_tables dir)
°

¹HOLCONST
Ü	ÛchangeSpecİ : Tab ­ TableSpec ­ State ­ State
÷üüüüüüüüüüüüüü
Ü	µ i : Tab; ts : TableSpec; s : State
Ü	· 	changeSpec i ts s	
Ü		= 
Ü		if	validTable i s 
Ü		then	let	dir = s @ Front i 
Ü			in
Ü			let	dir' = MkDirectory(Dir_tables dir « {(Last i,ts)}) 
Ü								(Dir_exist dir)(Dir_class dir)
Ü			in	
Ü			s « {(Front i,dir')}
Ü		else	s
°

A function that returns the visible columns of a table.

¹HOLCONST
Ü	ÛvisibleColsİ : Class ­ TableSpec ­ ColSpec ğ
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; ts: TableSpec
Ü	· 	visibleCols clear ts 
Ü		=
Ü		Snd(cleanColCons clear ts)
°


\subsection{Insert}

The function $colDefaults$ takes a  partial function from column number to data and a table
 and adds the appropriate  column number - default value  pairs which correspond to 
the  columns that were hidden to the user. The
default values are obtained from the table information.


¹HOLCONST
Ü	ÛcolDefaultsİ :  Class ­ TableSpec ­ (Num ª Data) ­  (Num ª Data)
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µ  clear : Class; ts : TableSpec; ds : Num ª Data
Ü	·	colDefaults clear ts ds
Ü		=
Ü		let hiddencols = (TS_colspecs ts) \ visibleCols clear ts
Ü		in 
Ü		ds « {(n,d)|¶c · c  hiddencols ± n = CS_posn c ± d = CS_default c}
°


An insert query will fail if the user is not permitted to access the table.


¹HOLCONST
Ü	ÛinsertQueryİ :  (Class ¸ Insert ¸ State ¸ TableSpec) ­ State ¸ Errors
÷üüüüüüüüüüüüüü
Ü	µ clear:Class; i:Tab; ds : (Num ª Data) LIST; s:State; ts : TableSpec
Ü	·	insertQuery (clear,(i,ds),s,ts)
Ü		=
Ü		if 	³(clear dominates  (TS_class ts))
Ü		then 	(s,[accessDenied])
Ü		else	let rl = Map ((MkRow clear) o (colDefaults clear ts)) ds 
Ü			in	
Ü			(changeSpec i (replaceRows ts ((TS_rows ts) ë rl)) s,[])	
°

\subsection{Delete}

Delete all rows specified by $DeleteEffect$.  The row numbers supplied by $DeleteEffect$ correspond
to the users view of the hidden state of the data base. In order to delete the correct rows from
the true state of the data base, it is necessary to take into account those rows about whose
existence the user is not cleared to know. If the user were not permitted access to the table
then the structure of the table would have been hidden from him and therefore the request would have failed.




¹HOLCONST
Ü	ÛdeleteQueryİ :  (Class ¸ Delete ¸ State ¸ TableSpec) ­  State
÷üüüüüüüüüüüüüü
Ü	µ clear:Class; i:Tab; ns : Num ğ; e:Errors; s:State; ts:TableSpec
Ü	·	deleteQuery(clear,(i,ns),s,ts)
Ü		=
Ü		let	rs = Extract (Ran(ns á (revealRow clear ts)))(TS_rows ts) 
Ü		in	
Ü		(changeSpec i (replaceRows ts rs) s)	
°	



\subsection{Update}


Perform the updates specified by $UpdateEffect$, provided that they do not
violate the security policy. A user may change the value in a field (classification stays the same) provided the
 field's classification dominates the user's clearance. A user may downgrade the classification of a field providing
that the value in the field is overwritten.

Firstly, consider an update request on a single field of data. This will either yield a new piece
of data or an error message.

¹HOLCONST
Ü	ÛupdateFieldİ :  Class ­ Class ­ (Update ¸ Data) ­ (Data + Error)
÷üüüüüüüüüüüüüü
Ü	µ clear table_class:Class; table_d:Data; u:Update
Ü	·	updateField clear table_class (u,table_d)
Ü		=
Ü		if	clear = table_class
Ü		then	if 	isItem u
Ü			then	giveVal(MkData (Dat_class table_d)(destItem u))
Ü			else if	isClass u
Ü			then	if (destClass u) dominates (Dat_class table_d)
Ü				then	giveVal(MkData (destClass u) (Dat_item table_d))
Ü				else	giveError downGrade
Ü			else	giveVal(destData u) 	(* must be Data *)
Ü		else if 	isItem u
Ü		then	if	(Dat_class table_d) dominates clear
Ü			then	giveVal(MkData (Dat_class table_d) (destItem u))
Ü			else	giveError underClassified
Ü		else	giveError classChange
°

Now the effect of an update on a row.  A new row is only returned if all updates are secure; otherwise
 a sequence of errors is returned. 

¹HOLCONST
Ü	ÛupdateRowİ :  Class ­ Class ­ ((Num ª Update) ¸ Row) ­ (Row + Errors)
÷üüüüüüüüüüüüüü
Ü	µ clear table_class:Class; us:Num ª Update; r:Row
Ü	·	updateRow clear table_class (us,r)
Ü		=
Ü		let 	us' = 	RelCombine us (R_data r) » (updateField clear table_class)
Ü		in
Ü		let 	es = RelList(Squash((us' ’ {x|isError x}) » destError))  
Ü		in
Ü		if 	es = []
Ü		then	giveVal(MkRow (R_exist r)((R_data r) « (us' » destVal)))
Ü		else	giveError es
°



Finally, the $updateQuery$ function. A check is made to prevent access to hidden columns. 

¹HOLCONST
Ü	ÛupdateQueryİ :  (Class ¸ UpDate ¸ State ¸ TableSpec)  ­ State ¸ Errors
÷üüüüüüüüüüüüüü
Ü	µ clear:Class; i:Tab; us : Num ª (Num ª Update); s:State; ts : TableSpec
Ü	·	updateQuery (clear,(i,us),s,ts)
Ü		=
Ü		let colnums = {n | ¶ c · c  visibleCols clear ts ± CS_posn c = n}
Ü		in
Ü		if	³((Dom (Ş (Ran us))) € colnums) 
Ü		then	(s,[noSuchColumn])
Ü		else 	let 	us' = InverseRelation(revealRow  clear ts) » us
Ü			in
Ü			let	pr = RelCombine us' (ListRel(TS_rows ts)) 
Ü						» (updateRow clear (TS_class ts))
Ü			in	
Ü			let 	es = RelList(Squash((pr ’ {x|isError x}) » destError))
Ü			in	if 	es = []
Ü				then	let	rs =  RelList(ListRel(TS_rows ts)
Ü								«(pr » destVal))
Ü					in 	(changeSpec i(replaceRows ts rs) s,[])
Ü				else	(s,Flatten es)
°


\subsection{Specification of $updateState$}

We first provide a function that given a full table name returns a table. 
This will only be applied in the case where the table
name is valid. (The  operator $@$ is the partial function application operator.) 

¹HOLCONST
Ü	ÛgetTableİ : Tab ­ State ­ TableSpec
÷üüüüüüüüüüüüüü
Ü	µ i : Tab; s:State
Ü	· 	
Ü	getTable i  s = (Dir_tables(s @ (Front i))) @ (Last i)
°

The function $updateState$ operates on the output from the function $processQuery$, 
defined in \cite{DS/FMU/FEF/004}. This output is a pair consisting of the
effect of the update query, which depends on whether the query was a select, 
insert, delete or update, and a sequence of errors messages.
For a select query, data is returned to the user, together with any error messages. The
state of the database remains unchanged.
For an insert, delete or update query, if an invalid table name is returned
by $processQuery$, then
 the state of the database remains unchanged and an appropriate error message is returned.
If errors were generated by $processQuery$
then
 the state of the database remains unchanged and the errors are returned.  
If a valid table name and no errors are returned
by $processQuery$ then the appropriate update to the state of the database, given by
$insertQuery$, $deleteQuery$ and $updateQuery$, is carried out after the security 
checks have been made. In the case of an insert or update query, if the security checks
identified that the output
 of $processQuery$ would result in an insecure update to the state of the database,
 then the state of the database remains unchanged and error messages
generated by the security checks are returned to the user. 


¹HOLCONST
Ü	ÛupdateStateİ : Class ¸ (Effect ¸ Errors) ¸ State ­ 
Ü				State ¸ (Class ¸ (Data LIST LIST ¸ Errors))
÷üüüüüüüüüüüüüü
Ü	µ clear:Class;ef : Effect; es : Errors; s : State
Ü	·	updateState(clear,(ef,es),s)
Ü		=	
Ü		if	isSelect ef
Ü		then	(s,(clear,(destSelect ef,es)))
Ü		else if ³(es = [])  (* delete,update and insert only valid if no errors *)
Ü		then	(s,(clear,([],es)))
Ü		else	let	i = tabFromEffect ef
Ü			in	
Ü			if	validTable i s
Ü			then	let ts = getTable i s 
Ü				in
Ü				let	(s',es') 
Ü					=	
Ü					if 	isInsert ef
Ü					then	insertQuery(clear,destInsert ef,s,ts)
Ü					else if	isDelete ef
Ü					then	(deleteQuery(clear,destDelete ef,s,ts),[])
Ü					else	updateQuery(clear,destUpdate ef,s,ts)
Ü				in	
Ü				(s',(clear,([],es')))
Ü			else	(s,(clear,([],[noSuchTable])))  (* Invalid table name *)
°

\section{CLOSING DOWN}
The following ICL HOL instruction restores the previous proof context.
=SML
pop_pc();
=TEX

\section{APPROVAL OF THE SECURITY RELATED SPECIFICATIONS} 
Comments on this document by DRA to be made  by 19th June 1992.


=IGN
output_theory{theory = "fef005",outfile = "fef005th.doc"};
=TEX

\newpage
\input{fef005th.tex}
\newpage

\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}
 
