=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Specifications of $hide$ and $updateState$}  %% Mandatory field
\TPPref{DS/FMU/FEF/005}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{The formal specifications of the functions $hide$ and $updateState$  for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}}) ]  Specification of data types moved to DS/FMU/FEF/004.
\end{description}

\subsection{Changes Forecast}
Changes  may be necessary  as a result of issues raised
during  the transcription of the specification.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document gives a formal specification of the functions $hide$ and $updateState$. It constitutes deliverable D2 of work package 1a, as given
in section 7 of the Secure Database Technical Proposal, \cite{DS/FMU/017}.

\subsection{Introduction}
In the introduction to \cite{DS/FMU/FEF/004} we stated that
 the formalisation of the semantics of
SSQL is to be presented in three main parts. Two of these parts, the functions
 $hide$ and $updateState$, are concerned with the security 
aspects of the SSQL semantics. The functions
 $hide$ and $updateState$ are formalised in this document.
\section{PRELIMINARIES}
The following ICL HOL instructions set up the new theory $fef005$ and set the context 
for the proof tools.
=SML 
open_theory "fef004";
new_theoryÛ"fef005"İ;
push_pc "hol1";
=TEX

\section{THE FUNCTION $hide$}

The purpose of the $hide$ function is to return a sanitised state of the database. This version of the database does not
include any information the existence
of which the user is not cleared to know, nor does it contain the true value of any field which the user is not cleared to see. This is achieved as follows :
\begin{description}
\item[Section \ref{CLEANTABLE}]
A function $cleanTable$ is defined which takes a table and
a clearance and returns a table which has been `cleaned'. 
A table that the user is not permitted to access is replaced by an `empty' table. Otherwise,
  all the rows and columns  about whose 
existence the user is not cleared to know are hidden, and all the data the user is
not cleared to see is replaced by dummy data.
\item[Section \ref{CLEANDIRECTORY}]
A function $cleanDirectory$ is defined which takes a directory and
a clearance and returns a directory which has been `cleaned'. If the user is 
not permitted to know of the existence of the tables in the directory
then a directory with no tables in it is returned; otherwise
the tables in the directory are `cleaned' by $cleanTable$.
\item[Section \ref{CLEANSTATE}]
Finally, the function $hide$ is defined which takes a state and a clearance
and returns a state which has been `cleaned'. All directories about whose 
existence the user is not cleared to know are hidden and the rest are cleaned by $cleanDirectory$.
\end{description}
\subsection{Sanitising a Table} \label{CLEANTABLE}
In the case where the user is permitted to know of the existence of a table, but is not permitted
to access it, i.e. his clearance does not dominate the table class, an `empty' table is left in the 
directory in place of that table. We define a classification $stubClass$ for such tables.

¹HOLCONST
Ü	ÛstubClassİ : Class
÷üüüüüüüüüüüüüü
Ü	T
°

¹HOLCONST
Ü	ÛleaveStubİ : Class ¸ TableSpec ­ TableSpec
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; ts : TableSpec
Ü	·	leaveStub(clear,ts)
Ü		=
Ü		MkTableSpec stubClass stubClass{}{}[]
°

All other tables are `sanitised' in the following way
\begin{enumerate}
\item
Remove  any rows about whose existence the user is 
not cleared to know.
\item
Remove any  columns about whose existence the user is 
not cleared to know. 
\item
Replace data that the user is
not cleared to see by  dummy values.
\end{enumerate}
\subsubsection{Remove Rows from Table}
To hide from a table any rows about whose existence the user is 
not cleared to know,  remove the relevant rows from the sequence of rows and replace the original rows of the table with this filtered sequence.

An auxiliary function which replaces the rows in a table with  given rows.

¹HOLCONST
Ü	ÛreplaceRowsİ : TableSpec ­ Row LIST ­ TableSpec
÷üüüüüüüüüüüüüü
Ü	µ ts : TableSpec; rs : Row LIST
Ü	·	replaceRows ts rs 
Ü		= 
Ü		MkTableSpec(TS_class ts)(TS_maxRow ts)(TS_colspecs ts)(TS_cons ts) rs
°

Now the function to remove the rows.

¹HOLCONST
Ü	ÛhideRowsİ : Class ¸ TableSpec ­ TableSpec
÷üüüüüüüüüüüüüü
Ü
Ü	µ clear : Class; ts : TableSpec
Ü	· 	hideRows(clear,ts) 
Ü		= 
Ü		replaceRows ts ((TS_rows ts) ù {r:Row|clear dominates (R_exist r)})
°

\subsubsection{Remove Columns from Table}

To hide columns from a table,  it is necessary to check the existence class  
of groups of columns. If the user is 
not cleared to know the existence of a group of columns, then the group of columns must be removed from the table. This means removing all reference to the 
identified columns in the $colspecs$  and $colposns$, removing the group number
from the column group constraints and removing the actual data from each row. 
First, identify which groups are to be hidden.
 
¹HOLCONST
Ü	ÛgroupsToHideİ : Class ¸ TableSpec ­ Num ğ
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; ts : TableSpec
Ü	· 	groupsToHide(clear,ts) 
Ü		=  
Ü		{n : Num|³(clear dominates (CC_exist ((TS_cons ts) @ n)))}
°


A function to remove data from  given positions in the row.

¹HOLCONST
Ü	ÛremoveDataİ :  Num ğ­ Row ­ Row
÷üüüüüüüüüüüüüü
Ü	µ r : Row; ns : Num ğ 
Ü	· 	removeData ns r
Ü		=
Ü		MkRow (R_exist r) (ns á (R_data r))
°

A function to  hide  groups of columns from a table.

¹HOLCONST
Ü	ÛhideGroupsİ : TableSpec ­ Num ğ ­ TableSpec
÷üüüüüüüüüüüüüü
Ü
Ü	µ ts : TableSpec; ns: Num ğ
Ü	·	hideGroups ts ns
Ü		=
Ü		let	colspecs = (TS_colspecs ts) \ {cs : ColSpec|(CS_consGroup cs)  ns}
Ü		and	cons = ns  á (TS_cons ts)
Ü		and 	rows = Map (removeData ns)(TS_rows ts)
Ü		in	MkTableSpec(TS_class ts) (TS_maxRow ts) colspecs cons rows
°


Finally, hide from a table all groups of columns about whose existence the user is 
not cleared to know.


¹HOLCONST
Ü	ÛhideColsİ : Class ¸ TableSpec  ­ TableSpec
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; ts: TableSpec; ns: Num ğ
Ü	· 	hideCols(clear,ts) 
Ü		=
Ü		hideGroups ts (groupsToHide(clear,ts))	
°


\subsubsection{Replace Data in a Row with Dummy Data}

Data consists of a classification and an item of data. An item of data that a 
user is not cleared to see is replaced by a dummy string $Hidden$
(its classification remains).

¹HOLCONST
Ü	ÛHiddenİ : String
÷üüüüüüüüüüüüüü
Ü	T	
°

¹HOLCONST
Ü	ÛdummyValİ : Val
÷üüüüüüüüüüüüüü
Ü	dummyVal = StringVal Hidden	
°


A function to replace  the value of a piece of data 
 that the user is
not cleared to see by a dummy value. 

¹HOLCONST
Ü
Ü	ÛcleanDataİ : Class ­ Data ­ Data
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; d : Data
Ü	·	cleanData clear d
Ü		=
Ü		if ³(clear dominates (Dat_class d))
Ü		then	MkData (Dat_class d)
Ü			(ValuedItemItem (MkValuedItem worthless dummyVal))
Ü		else 	d
°


A function to clean all the data in  a row.

¹HOLCONST
Ü
Ü	ÛcleanRowİ : Class ­ Row ­ Row
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; r: Row
Ü	·	cleanRow clear r 
Ü		= 
Ü		MkRow (R_exist r)((R_data r) » (cleanData clear))
°

\subsubsection{Clean all Data in a Table}

The function $cleanTable$ either returns an `empty' table or a table where  the
rows and columns that the user is not cleared to see have been hidden and fields that the 
user is not cleared to see have been overwritten by dummy fields.

¹HOLCONST
Ü	ÛcleanTableİ : Class ­ TableSpec ­ TableSpec
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; ts:TableSpec
Ü	·	cleanTable clear ts
Ü		=
Ü		if 	³(clear dominates (TS_class ts))
Ü		then 	leaveStub(clear,ts)
Ü		else	let ts' = hideCols(clear,hideRows(clear,ts))
Ü			in		 
Ü			replaceRows ts'(Map (cleanRow clear)(TS_rows ts'))
°

\subsection{Sanitising a Directory} \label{CLEANDIRECTORY}
Any tables in a directory about whose existence the user is 
not cleared to know can be removed from that directory. These are all the
tables in a directory whose $class$ component is not
dominated by the user's clearance (i.e. the user is cleared to
know the existence of the directory, but is not cleared to
see the structure of the directory). To `clean' a directory, the tables in that 
directory will either be hidden or modified by $cleanTable$.

¹HOLCONST
Ü	ÛcleanDirectoryİ : Class ­ Directory ­ Directory
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; dir : Directory  
Ü	·	cleanDirectory clear dir 
Ü		=
Ü		if	³(clear dominates (Dir_class dir))
Ü		then	MkDirectory {}(Dir_exist dir)(Dir_class dir)
Ü		else	
Ü			let 	newtables = Dir_tables dir » cleanTable clear
Ü			in	MkDirectory newtables(Dir_exist dir)(Dir_class dir)
°
\subsection{Sanitising a State} \label{CLEANSTATE}
Finally, any directories about whose existence the user is 
not cleared to know can be removed from the state. All remaining directories will be
`cleaned' by $cleanDirectory$.

¹HOLCONST
Ü	Ûhideİ : Class ¸ State ­ State
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; s : State
Ü	· 	hide(clear,s) 
Ü		= 
Ü		{i|clear dominates Dir_exist(s @ i)} ò s » cleanDirectory clear
°


\section{THE FUNCTION $updateState$}

In \cite{DS/FMU/FEF/004} the function $processQuery$ is defined. This function takes a query, a user's classification and a state and returns the result of the query, i.e., the output to be seen by the user,  an update to be applied to the data base and some error messages.
The effect of a query depends on the type of the query, which may be an $Insert$, a $Delete$ 
an $UpDate$ or a $Select$. The sum type $Effect$ is defined in \cite{DS/FMU/FEF/004}.


We have not taken into account that it may be necessary to have as a state invariant
that  column existence classifications
are in ascending order.
\subsection{Auxiliary Functions}

When a user makes an update request on a row, the position of the row in
a table will be its position after rows about whose existence the user is 
not cleared to know have been hidden. We require a function that reveals the true  row position given the 
hidden row position.

¹HOLCONST
Ü	Ûrevealİ : Class ­ TableSpec ­ Num ª Num
÷üüüüüüüüüüüüüü
Ü	µ clear: Class; ts : TableSpec
Ü	· 	reveal clear ts 
Ü		= 
Ü		let	visiblerows = {r:Row|clear dominates (R_exist r)}
Ü		in	Squash(Id(Dom((ListRel(TS_rows ts)) ’ visiblerows))) 
°

We provide the auxiliary function $changeSpec$ (from Annex 2 {\em SSQL Abstract Machine})  which takes a full table name and a table and gives a new state.


¹HOLCONST
Ü	ÛchangeSpecİ : Tab ­ TableSpec ­ State ­ State
÷üüüüüüüüüüüüüü
Ü	µ i : Tab; ts : TableSpec; s : State
Ü	· 	changeSpec i ts s	
Ü		= 
Ü		if	Front i  Dom s 
Ü		then	let	dir = s @ Front i 
Ü			in
Ü				if 	Last i  Dom(Dir_tables dir) 
Ü				then	let	dir' = MkDirectory(Dir_tables dir « {(Last i,ts)}) 
Ü								(Dir_exist dir)(Dir_class dir)
Ü						in	s « {(Front i,dir')}
Ü			else 	s
Ü		else	s
°

\subsection{Insert}

The function $colDefaults$ takes a   column number - data  relation and a table
 and supplies a new relation  with
appropriate default values (obtained from the table information) in  columns which were hidden to the user.


¹HOLCONST
Ü	ÛcolDefaultsİ :  Class ­ TableSpec ­ (Num ª Data) ­  (Num ª Data)
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µ  clear : Class; ts : TableSpec; d : Num ª Data
Ü	·	colDefaults clear ts d
Ü		=
Ü		let ccs = {cs : ColSpec|(CS_consGroup cs)  groupsToHide(clear,ts)}
Ü		in 
Ü		d À {(n,data) | ¶cs · cs  ccs ± n = (CS_posn cs) ± data = (CS_default cs)} 
°

An insert query will fail if the user is not permitted to access the table.


¹HOLCONST
Ü	ÛinsertQueryİ :  (Class ¸ Insert ¸ State ¸ TableSpec) ­ State ¸ Errors
÷üüüüüüüüüüüüüü
Ü	µ clear:Class; i:Tab; ds : (Num ª Data) LIST; e:Errors; s:State; ts : TableSpec
Ü	·	insertQuery (clear,(i,ds,e),s,ts)
Ü		=
Ü		if 	³(clear dominates  (TS_class ts))
Ü		then 	(s,[accessDenied] ë e)
Ü		else
Ü			let rl = Map ((MkRow clear) o (colDefaults clear ts)) ds 
Ü			in	(changeSpec i (replaceRows ts ((TS_rows ts) ë rl)) s,e)	
°

\subsection{Delete}

Delete all rows specified by $DeleteEffect$.  The row numbers supplied by $DeleteEffect$ correspond
to the users view of the hidden state of the data base. In order to delete the correct rows from
the true state of the data base, it is necessary to take into account those rows about whose
existence the user is not cleared to know. If the user were not permitted access to the table
then the structure of the table would have been hidden from him and therefore the request would have failed.




¹HOLCONST
Ü	ÛdeleteQueryİ :  (Class ¸ Delete ¸ State ¸ TableSpec) ­  State ¸ Errors
÷üüüüüüüüüüüüüü
Ü	µ clear:Class; i:Tab; ns : Num ğ; e:Errors; s:State; ts:TableSpec
Ü	·	deleteQuery(clear,(i,ns,e),s,ts)
Ü		=
Ü		let	rs = Delete (TS_rows ts)(Ran(reveal clear ts))
Ü			in	(changeSpec i (replaceRows ts rs) s,e)	
°üüüüüüüüüüüüüüüüüüüüüüüüüüüü	


\subsection{Update}


Perform the updates specified by $UpdateEffect$, provided that they do not
violate the security policy. A user may change the value in a field (classification stays the same) provided the
 field's classification dominates the user's clearance. A user may downgrade the classification of a field providing
that the value in the field is overwritten.

Firstly, consider an update request on a single field of data. This will either yield a new piece
of data or an error message.

¹HOLCONST
Ü	ÛupdateFieldİ :  Class ­ Class ­ (Update ¸ Data) ­ (Data + Error)
÷üüüüüüüüüüüüüü
Ü	µ clear table_class:Class; table_d:Data; u:Update
Ü	·	updateField clear table_class (u,table_d)
Ü		=
Ü		if	clear = table_class
Ü		then	if 	isItem u
Ü			then	giveVal(MkData (Dat_class table_d)(destItem u))
Ü			else	if	isClass u
Ü				then	if (destClass u) dominates (Dat_class table_d)
Ü					then	giveVal(MkData (destClass u) (Dat_item table_d))
Ü					else	giveError downGrade
Ü				else	giveVal(destData u) 	(* must be Data *)
Ü		else	if 	isItem u
Ü			then	if	(Dat_class table_d) dominates clear
Ü				then	giveVal(MkData (Dat_class table_d) (destItem u))
Ü				else	giveError underClassified
Ü			else	giveError classChange
°

Now the effect of an update on a row.  A new row is only returned if all updates are secure; otherwise
 a sequence of errors is returned. 

¹HOLCONST
Ü	ÛupdateRowİ :  Class ­ Class ­ ((Num ª Update) ¸ Row) ­ (Row + Errors)
÷üüüüüüüüüüüüüü
Ü	µ clear table_class:Class; us:Num ª Update; r:Row
Ü	·	updateRow clear table_class (us,r)
Ü		=
Ü		let us' = 	RelCombine us (R_data r) » (updateField clear table_class)
Ü		in
Ü			let es = RelList((us' ’ {x|isError x}) » destError)  
Ü			in
Ü			if 	es = []
Ü			then	giveVal(MkRow (R_exist r)((R_data r) 
Ü						« ((us' ’ {x|isVal x}) » destVal)))
Ü			else	giveError es
°



Finally, the $updateQuery$ function. 

¹HOLCONST
Ü	ÛupdateQueryİ :  (Class ¸ UpDate ¸ State ¸ TableSpec)  ­ State ¸ Errors
÷üüüüüüüüüüüüüü
Ü	µ clear:Class; i:Tab; us : Num ª (Num ª Update); e:Errors; s:State; ts : TableSpec
Ü	·	updateQuery (clear,(i,us,e),s,ts)
Ü		=
Ü		let 	us' = InverseRelation(reveal  clear ts) » us
Ü		in
Ü			let	pr = RelCombine us' (ListRel(TS_rows ts)) 
Ü					» (updateRow clear (TS_class ts))
Ü			in	
Ü				let es = RelList((pr ’ {x|isError x}) » destError)
Ü				in	if es = []
Ü					then	let	rs =  RelList(ListRel(TS_rows ts) 
Ü								«((pr ’ {x|isVal x}) » destVal))
Ü						in 	(changeSpec i(replaceRows ts rs) s,e)
Ü					else	(s,(Flatten es) ë e)
°

\subsection{Select}

Select all data specified by $SelectEffect$.  


¹HOLCONST
Ü	ÛselectQueryİ :  Select  ­ Data LIST LIST ¸ Errors
÷üüüüüüüüüüüüüü
Ü	µ d : Data LIST LIST; e:Errors
Ü	· 	selectQuery(d,e) = (d,e)
°

\subsection{Specification of $updateState$}
The four functions $insertQuery$, $deleteQuery$, $updateQuery$ and $selectQuery$ are put
together to give $updateState$.

We first give a function that determines whether or not a table name
exists in a particular state.
¹HOLCONST
Ü	ÛvalidTableİ : Tab ­ State ­ Bool
÷üüüüüüüüüüüüüü
Ü	µ i : Tab; s:State
Ü	· 	validTable i s 
Ü		=
Ü		(Front i  Dom s 
Ü		± 
Ü		Last i  Dom(Dir_tables(s @ (Front i))))
°

Then a function that returns a table. This will only be applied in the case where the
name is valid.

¹HOLCONST
Ü	ÛgetTableİ : Tab ­ State ­ TableSpec
÷üüüüüüüüüüüüüü
Ü	µ i : Tab; s:State
Ü	· 	
Ü	getTable i  s = (Dir_tables(s @ (Front i))) @ (Last i)
°



¹HOLCONST
Ü	ÛupdateStateİ : Class ¸ Effect ¸ State ­ 
Ü				State ¸ (Class ¸ (Data LIST LIST ¸ Errors))
÷üüüüüüüüüüüüüü
Ü	µ clear:Class;ef : Effect; s : State
Ü	· 	updateState(clear, ef, s)
Ü		=	if	isSelect ef
Ü			then	let	(d1,e1) = selectQuery (destSelect ef) 
Ü				in	
Ü				(s,(clear,(d1,e1)))
Ü			else	let	i = tabFromEffect ef
Ü				in	
Ü				if	validTable i s
Ü				then	let ts = getTable i s 
Ü					in
Ü					if	isInsert ef
Ü					then	let	(s2,e2) 
Ü							= 
Ü							insertQuery(clear,destInsert ef,s,ts)
Ü						in	
Ü						(s2,(clear,([],e2)))
Ü					else	if	isUpdate ef
Ü						then	let	(s3,e3) 
Ü								= 
Ü								deleteQuery(clear,destDelete ef,s,ts)
Ü							in	
Ü							(s3,(clear,([],e3)))
Ü						else	let	(s4,e4) 
Ü								= 
Ü								updateQuery(clear,destUpdate ef,s,ts)
Ü							in	
Ü							(s4,(clear,([],e4)))
Ü				else	(s,(clear,([],ErrorsFromEffect ef))) (* Invalid table name *)
°

\section{CLOSING DOWN}
The following ICL HOL instruction restores the previous proof context.
=SML
pop_pc();
=TEX

=IGN
output_theory{theory = "fef005",outfile = "fef005th.doc"};
=TEX

\newpage
\input{fef005th.tex}
\newpage

\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}
 
