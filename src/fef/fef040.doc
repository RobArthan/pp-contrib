=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\def\Note#1{{\small\bf[Note: #1]}}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Multi-level Formal Security Policy}  %% Mandatory field
\TPPref{DS/FMU/FEF/003}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.~D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{A formulation of a multi-level formal security policy for the DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}}) ] First draft. 

\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Phases 1 and 2 of the FEF project dealt exclusively with the formulation of the security policy defined in \cite{DS/FMU/FEF/003}.
In that formulation SSQL queries are treated as containing information at a single security clearance.
In phase 3, the intention is to generalise the policy to cater for queries which are structured objects containing components which may be at several different clearances.
This document gives a formal specification of a behavioural model of  systems
and a formal specification of a security policy allowing for such multi-level queries.

It constitutes deliverable D17 of work package 7a, as described
in section 7 of the Proposal for Phase 3, \cite{DS/FMU/FEF/039}.

\subsection{Introduction}


\subsection{Setting Up}
The following \Product{} instructions set up the new theory $fef040$ and set the context 
for the proof tools.
The parent theory is the theory $fef003$ which contains the single level security policy and, in particular, the definition of the lattice of security classes:
=SML
open_theory"fef003";
(force_delete_theory "fef040" handle _ => ());
new_theory Û"fef040"Ý;
push_pc "hol";
=TEX
\section{MULTI-LEVEL SECURITY POLICY}
=TEX
An index of the names used in the formal specification may be found in Section \ref{INDEX}. 
A listing of the theory $fef040$ created by processing this document using \Product{}
may be found at the end of this document.


\subsection{The Type of Behavioural Models of Systems}

The definition of information flow security presented here is a property
on behavioural models of systems.
The inputs and outputs of systems will be thought of as structured objects whose components may be labelled with security classes.
For example, an input might be an abstract syntax tree for an SSQL query with the nodes labelled with classes.
An output might be an SSQL table with nodes labelling the cells.
As in the single level model, a `behaviour' of a system is a single sequence of inputs and the resulting sequence of outputs.
A behavioural model is the set of all possible behaviours.
This is formalised  as a function from the sequences of inputs to sequences of outputs.
For simplicity, we model inputs and outputs as having the same type; the behavioural model is generic in the type $'OBJ$ used to represent them. 
=SML
declare_type_abbrev(Û"ML_BEHAVIOURS"Ý,["'OBJ"], ¬: ('OBJ)LIST ­ ('OBJ )LIST®);
=TEX

\subsection{Classes}
We use the lattice of security classes defined in \cite{DS/FMU/FEF/003}.
We will need the notion of the down-set of a class:

¹HOLCONST
Ü	ÛDownSetÝ : Class ­ Class ð
÷üüüüüüüüüüüüüü
Üµc·	DownSet c = { d | c dominates d}
°


\subsection{Purging Data}
In \cite{DS/FMU/FEF/003}, the security policy is expressed in terms of relations $same\_ins$, and $same\_outs$ parameterised by a security class.
In \cite{securityprops}, the non-interference property is expressed using a relation $identicalObjs$ also parameterised by a class.
\cite{securityprops} also uses a visibility predicate $visible$ again parameterised by a class.

To generalise these ideas from \cite{DS/FMU/FEF/003,securityprops}, it is convenient to define the notion of an equivalence relation.
An equivalence relation is one which is reflexive, symmetric and transitive, which we may express as follows.


¹HOLCONST
Ü	ÛEquivalenceÝ : ('a ª 'a) ð
÷üüüüüüüüüüüüüü
Ü	Equivalence = Reflexive ¡ Symmetric ¡ Transitive
°

\Note{The above assumes that we are only concerned with equivalence relations on the entire type of objects.
This would mean that if the input and output objects have to satisfy some invariant, then that invariant must be captured in a type definition.}

In \cite{DS/FMU/FEF/003,securityprops}, two objects, $x$ and $y$, are take to be identical viewed from a class, $c$, if they become the same when components whose classification is not dominated by $c$ are ``purged''.
I.e., $x$ and $y$ are taken as the same at $c$ iff. they become identical when we treat components whose classification is not in $Downset(c)$ as being equal. 
To tackle the result labelling property, it is useful to have available the analogous notion for an arbitrary set of classes, not just a down-set of some class $c$.
To do this we use the idea of a {\em filter}.
A filter is to be a function, $s$ associating with each set, $A$, of classes, an equivalence relation $s(A)$.
We require that $s$ be antimonotonic with respect to inclusion, that is to say, the bigger $A$ is, the finer is the equivalence relation $s(A)$:

¹HOLCONST
Ü	ÛFilterÝ : (Class ð ­ ('a ª 'a)) ð
÷üüüüüüüüüüüüüü
Ü	Filter =
Ü	{	s
Ü	|	(µa· s(a)  Equivalence)
Ü	±	(µa b· a € b ´ s(b) € s(a))}
°
(Here $s$ stands for ``same'' reflecting the terminology of \cite{DS/FMU/FEF/003}).

\Note{There are extra conditions one might choose to impose. E.g. that $f\{\}$ is the complete relation and that $f\,Universe$ is the identity relation.}

\subsection{Security Policy} \label{CRITICAL}

The general multi-level security policy is parameterised by a filter as defined in the previous section.

¹HOLCONST
Ü	Ûml_secureÝ: (Class ð ­ ('OBJ LIST ª 'OBJ LIST)) ­ ('OBJ) ML_BEHAVIOURS ð
÷üüüüüüüüüüüüüüüüüüüüüüü
Ü	µs b
Ü	·	b  ml_secure(s) 
Ü	¤	s  Filter
Ü		±	µc i‰1 i‰2·
Ü				(i‰1, i‰2)  s (DownSet c)
Ü			´	(b i‰1, b i‰2)  s (DownSet c)
°

Note that $ml\_secure(s)$ is empty if $s$ is not a filter.

\section{STATE MACHINES}
Behavioural models for systems are obtained from state machines.
We model a state machine as a pair comprising an initial state and a transition function:
=SML
¹HOLLABPROD ÛMACHINEÝ
Ü	Init	: 'STATE;
Ü	TrF	: 'OBJ ¸ 'STATE ­ 'STATE ¸ 'OBJ
°
=TEX
Given such a state machine, we may construct its behavioural model as follows:
¹HOLCONST
Ü	Ûml_behavioursÝ : ('OBJ, 'STATE) MACHINE ­ 'OBJ ML_BEHAVIOURS
÷üüüüüüüüüüüüüüü
Üµm : ('OBJ, 'STATE) MACHINE·
Ü	ml_behaviours m =
Ü	let	step i (st, resl) =
Ü		let	(st', res) = TrF(m)(i, st)
Ü		in	(st', resl ë [res])
Ü	in	Ìil· Snd(Fold step (Rev il) (Init m, []))
°
\section{RESULT LABELLING}
\subsection{Observations}
The general way we are modelling structured multi-level objects requires us to use indirect means to handle the idea of a component of an object labelled with a class.
We think of the component as being modelled by the function which maps an object oto the class-value pair held in the component.
A little more generally, let us say that that an {\em observation} is any function mapping objects to class-object pairs:

=SML
declare_type_abbrev(Û"OBSERVATION"Ý,["'OBJ"], ¬: 'OBJ ­ Class ¸ 'OBJ®);
=TEX
\section{CLOSING DOWN}
The following \Product{} instruction restores the previous proof context.
=SML
pop_pc();
=TEX
=IGN
output_theory{theory = "fef040",out_file = "fef040th.doc"};
=TEX
\newpage
\HOLindexOff
\input{fef040th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}




=IGN
val Ûrun_machine_convÝ =
	(rewrite_conv(map get_spec[¬Let®, ¬MkMACHINE®, ¬ml_behaviours®])
	THEN_C
	PC_C1 "hol2" rewrite_conv(map get_spec[¬Fold®, ¬Rev®, ¬Append®]));

run_machine_conv
¬	(let	counter = MkMACHINE 0 (Ì(i, s)· (s + i, s + i))
	in	ml_behaviours counter)
	[1;2;3;4]
®;


run_machine_conv
¬	(let	counter =
		MkMACHINE 0
		(Ì(i, s)· if i > s then (i, i) else (s, s))
	in	ml_behaviours counter)
	[1;3;2;4;1;5;4;3;2;7;8;0]
®;

run_machine_conv
¬	(let	counter = MkMACHINE (0, 0) (Ì(i, (acc, ct))· ((acc + i, ct + 1), (acc + i) Div (ct + 1)))
	in	ml_behaviours counter)
	[1;5;15;20]
®;

