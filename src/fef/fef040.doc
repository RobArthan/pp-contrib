=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\def\Note#1{{\small\bf[Note: #1]}}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Multi-level Formal Security Policy}  %% Mandatory field
\TPPref{DS/FMU/FEF/003}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.~D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{A formulation of a multi-level formal security policy for the DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}}) ] First draft. 

\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Phases 1 and 2 of the FEF project dealt exclusively with the formulation of the security policy defined in \cite{DS/FMU/FEF/003}.
In that formulation SSQL queries are treated as containing information at a single security clearance.
In phase 3, the intention is to generalise the policy to cater for queries which are structured objects containing components which may be at several different clearances.
This document gives a formal specification of a behavioural model of  systems
and a formal specification of a security policy allowing for such multi-level queries.

It constitutes deliverable D17 of work package 7a, as described
in section 7 of the Proposal for Phase 3, \cite{DS/FMU/FEF/039}.

\subsection{Introduction}


\subsection{Setting Up}
The following \Product{} instructions set up the new theory $fef040$ and set the context 
for the proof tools.
The parent theory is the theory $fef003$ which contains the single level security policy and, in particular, the definition of the lattice of security classes:
=SML
open_theory"fef003";
(force_delete_theory "fef040" handle _ => ());
new_theory Û"fef040"Ý;
push_pc "hol";
=TEX
\section{MULTI-LEVEL SECURITY POLICY}
=TEX
An index of the names used in the formal specification may be found in Section \ref{INDEX}. 
A listing of the theory $fef040$ created by processing this document using \Product{}
may be found at the end of this document.


\subsection{The Type of Behavioural Models of Systems}

The definition of information flow security presented here is a property
on behavioural models of systems.
The inputs and outputs of systems will be thought of as structured objects whose components may be labelled with security classes.
For example, an input might be an abstract syntax tree for an SSQL query with the nodes labelled with classes.
An output might be an SSQL table with nodes labelling the cells.
As in the single level model, a {\em behaviour} of a system is a single sequence of inputs and the resulting sequence of outputs.
The {\em behavioural model} of a system is the set of all its possible behaviours.
Since we are only concerned with deterministic systems, this is formalised  as a function from the sequences of inputs to sequences of outputs.
For simplicity, we model inputs and outputs as having the same type; the behavioural model is generic in the type $'OBJ$ used to represent them. 
=SML
declare_type_abbrev(Û"ML_BEHAVIOURS"Ý,["'OBJ"], ¬: ('OBJ)LIST ­ ('OBJ )LIST®);
=TEX

\subsection{Classes}
We use the lattice of security classes defined in \cite{DS/FMU/FEF/003} as the type $Class$ togeth with operations $dominates$, $lub$, etc.
We will need the notion of the down-set of a class:

¹HOLCONST
Ü	ÛDownSetÝ : Class ­ Class ð
÷üüüüüüüüüüüüüü
Üµc·	DownSet c = { d | c dominates d }
°


\subsection{Purging Data}
In \cite{DS/FMU/FEF/003}, the security policy is expressed in terms of relations $same\_ins$, and $same\_outs$ parameterised by a security class.
In \cite{securityprops}, the non-interference property is expressed using a relation $identicalObjs$ also parameterised by a class.
\cite{securityprops} also uses a visibility predicate $visible$ again parameterised by a class.

To generalise these ideas from \cite{DS/FMU/FEF/003,securityprops}, it is convenient to define the notion of an equivalence relation.
An equivalence relation is one which is reflexive, symmetric and transitive, which we may express as follows.


¹HOLCONST
Ü	ÛEquivalenceÝ : ('a ª 'a) ð
÷üüüüüüüüüüüüüü
Ü	Equivalence = Reflexive ¡ Symmetric ¡ Transitive
°

\Note{The above assumes that we are only concerned with equivalence relations on the entire type of objects.
This would mean that if the input and output objects have to satisfy some invariant, then that invariant must be captured in a type definition.}

In \cite{DS/FMU/FEF/003,securityprops}, two objects, $x$ and $y$, are take to be identical viewed from a class, $c$, if they become the same when components whose classification is not dominated by $c$ are ``purged''.
I.e., $x$ and $y$ are taken as the same at $c$ iff. they become identical when we treat components whose classification is not in $Downset(c)$ as being equal. 
To tackle the result labelling property, it is useful to have available the analogous notion for any set of classes, not just down-sets.
To do this we introduce the idea of an {\em indexed equivalence relation}.
This is to be a function, $s$ associating with each set, $A$, of classes, an equivalence relation $s(A)$.
We require that $s$ be antimonotonic with respect to inclusion, that is to say, the bigger $A$ is, the finer is the equivalence relation $s(A)$:

¹HOLCONST
Ü	ÛIndexedEquivÝ : (Class ð ­ ('a ª 'a)) ð
÷üüüüüüüüüüüüüü
Ü	IndexedEquiv =
Ü	{	s
Ü	|	(µa· s(a)  Equivalence)
Ü	±	(µa b· a € b ´ s(b) € s(a))}
°
(Here $s$ stands for ``same'' reflecting the terminology of \cite{DS/FMU/FEF/003}).

\Note{There are extra conditions one might choose to impose. E.g. that $f\{\}$ is the complete relation and that $f\,Universe$ is the identity relation.}

\Note{Offers for a better name than ``indexed equivalence relation'' would be gratefully received.
I have tried ``purging relation'' and ``filter'' and didn't like them much.}

\subsection{Security Policy} \label{CRITICAL}

The general multi-level security policy is parameterised by an indexed equivalence relation as defined in the previous section.

¹HOLCONST
Ü	Ûml_secureÝ: (Class ð ­ ('OBJ LIST ª 'OBJ LIST)) ­ 'OBJ ML_BEHAVIOURS ð
÷üüüüüüüüüüüüüüüüüüüüüüü
Ü	µs b
Ü	·	b  ml_secure(s) 
Ü	¤	s  IndexedEquiv
Ü		±	µc i‰1 i‰2·
Ü				(i‰1, i‰2)  s (DownSet c)
Ü			´	(b i‰1, b i‰2)  s (DownSet c)
°

Note that $ml\_secure(s)$ is empty if $s$ is not a indexed equivalence relation.

\section{RESULT LABELLING}
\subsection{Observations}
The general way we are modelling structured multi-level objects requires us to use indirect means to handle the idea of a component of an object labelled with a class.
We think of the component as being modelled by the function which maps an object, or a sequence of same, to the class-value pair held in the component.
For present purposes, it is convenient to think of such a function as a pair of functions, one returning a class and the other as a value.

In general, given an arbitrary function on a set endowed with an indexed equivalence relation, we consider the set of (minimal) sets of classes which may influence the value taken by the function on a particular element of its domain.
This notion may be formalised as follows:

¹HOLCONST
Ü	ÛInfluencesÝ: (Class ð ­ ('a ª 'a)) ­ 'a ­ ('a ­ 'b) ­ Class ð ð
÷üüüüüüüüüüüüüüüüüüüüüüü
Üµs x f·
Ü	Influences s x f =
Ü	{	A : Class ð
Ü	| 	(¶y· (x, y)  s(A) ± ³f(x) = f(y))
Ü	±	µB· B   A ´ ³¶y· (x, y)  s(B) ± ³f(x) = f(y)}
°

\Note{Should one be using uncurried functions here: $Influences(s, x, f)$?}

We model the process of examining a labelled component of an object in the output of a system by a pair of functions, $(C, V)$: $C$ computing the class; and $V$ computing the value.
We will call such a pair an observation:
=SML
declare_type_abbrev(Û"OBSERVATION"Ý,["'a", "'b"], ¬: ('a ­ Class) ¸ ('a ­ 'b)®);
=TEX

We can now consider the question of when the process of making an observation is secure.
When a client makes an observation, we assume that some trusted part of the overall system will check the class which is returned and will prevent revelation of the value to clients who are not cleared to see it.
Thus the value may depend on information a client is not cleared to see, but this does not matter provided the class returned is such as to prevent the client being given the value.
However, since the class is itself intended to be part of what the client making the observation sees, the class must not depend on information the client is not allowed to know.
These ideas may be formalised as follows:

¹HOLCONST
Ü	SecureObs : (Class ð ­ ('a ª 'a)) ­ ('a, 'b) OBSERVATION ð
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Üµs·	SecureObs s =
Ü	{	(C, V) : ('a, 'b) OBSERVATION
Ü	|	µx·	Þ(Influences s x C) = {}
Ü		±	Þ(Influences s x V) € DownSet(C x) }
Ü
°
\Note{In some sense, it is having to use $Þ$ above which ``fixes'' the problem with using greatest lower bounds in \cite{securityprops}; the extent to which it usefully saves the situation is yet to be seen.}

We now make a conjecture:
=SML
val Ûml_secure_conjÝ = ¬
µs: (Class ð ­ ('OBJ LIST ª 'OBJ LIST)); b : 'OBJ ML_BEHAVIOURS·
	b  ml_secure s ¤
	s  IndexedEquiv
	±	µ(C, V)· (C, V)  SecureObs s ´ (C o b, V o b)  SecureObs s
®;
=TEX
\section{CLOSING DOWN}
The following \Product{} instruction restores the previous proof context.
=SML
pop_pc();
=TEX
=IGN
output_theory{theory = "fef040",out_file = "fef040th.doc"};
=TEX
\newpage
\HOLindexOff
\input{fef040th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}
=IGN SML
=TEX 
=IGN SML
set_goal([], ¬µs x f g·
	Graph g Image Influences s x (f o g) € Influences s x f®);
a(rewrite_tac(map get_spec[¬Influences®, ¬Graph®, ¬$Image®]) THEN
	REPEAT strip_tac);
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)`
a(var_elim_nth_asm_tac 1);

a(¶_tac¬y® ]);

val Ûinfluences_o_thmÝ = save_pop_thm"influences_o_thm";

=TEX 
=IGN SML
val ÛÞ_€_thmÝ = pc_rule1 "sets_ext" prove_rule[]¬µa b· a € b ´ Þa € Þb®;
=IGN SML
set_goal([], ml_secure_conj);
a(rewrite_tac(map get_spec[¬ml_secure®, ¬SecureObs®]) THEN REPEAT strip_tac);
a(lemma_tac¬Influences s x (C o b) € Influences s x C®
	THEN1 rewrite_tac[influences_o_thm]);
 
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 1 ¬b x®);
a(PC_T "sets_ext" contr_tac);
a(rename_tac[(¬s'®, "D")]);
a(GET_NTH_ASM_T 6 (PC_T1 "sets_ext" strip_asm_tac));
a(spec_nth_asm_tac 1 ¬b x®);

);

=IGN
\section{STATE MACHINES}
Behavioural models for systems are obtained from state machines.
We model a state machine as a pair comprising an initial state and a transition function:
=SML
=IGN ¹HOLLABPROD ÛMACHINEÝ
Ü	Init	: 'STATE;
Ü	TrF	: 'OBJ ¸ 'STATE ­ 'STATE ¸ 'OBJ
°
=IGN
Given such a state machine, we may construct its behavioural model as follows:
=IGN ¹HOLCONST
Ü	Ûml_behavioursÝ : ('OBJ, 'STATE) MACHINE ­ 'OBJ ML_BEHAVIOURS
÷üüüüüüüüüüüüüüü
Üµm : ('OBJ, 'STATE) MACHINE·
Ü	ml_behaviours m =
Ü	let	step i (st, resl) =
Ü		let	(st', res) = TrF(m)(i, st)
Ü		in	(st', resl ë [res])
Ü	in	Ìil· Snd(Fold step (Rev il) (Init m, []))
°



=IGN
val Ûrun_machine_convÝ =
	(rewrite_conv(map get_spec[¬Let®, ¬MkMACHINE®, ¬ml_behaviours®])
	THEN_C
	PC_C1 "hol2" rewrite_conv(map get_spec[¬Fold®, ¬Rev®, ¬Append®]));

run_machine_conv
¬	(let	counter = MkMACHINE 0 (Ì(i, s)· (s + i, s + i))
	in	ml_behaviours counter)
	[1;2;3;4]
®;


run_machine_conv
¬	(let	counter =
		MkMACHINE 0
		(Ì(i, s)· if i > s then (i, i) else (s, s))
	in	ml_behaviours counter)
	[1;3;2;4;1;5;4;3;2;7;8;0]
®;

run_machine_conv
¬	(let	counter = MkMACHINE (0, 0) (Ì(i, (acc, ct))· ((acc + i, ct + 1), (acc + i) Div (ct + 1)))
	in	ml_behaviours counter)
	[1;5;15;20]
®;

