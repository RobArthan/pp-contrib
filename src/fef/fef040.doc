=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\def\Note#1{{\small\bf[Note: #1]}}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Multi-level Formal Security Policy}  %% Mandatory field
\TPPref{DS/FMU/FEF/040}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.~D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{A formulation of a multi-level formal security policy for the DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}}) ] First draft. 

\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Phases 1 and 2 of the FEF project dealt exclusively with the formulation of the security policy defined in \cite{DS/FMU/FEF/003}.
In that formulation SSQL queries are treated as containing information at a single security clearance.
In phase 3, the intention is to generalise the policy to cater for queries which are structured objects containing components which may be at several different clearances.
This document gives a formal specification of a behavioural model of  systems
and a formal specification of a security policy allowing for such multi-level queries.

It constitutes deliverable D17 of work package 7a, as described
in section 7 of the Proposal for Phase 3, \cite{DS/FMU/FEF/039}.

\subsection{Introduction}


\subsection{Setting Up}
The following \Product{} instructions set up the new theory $fef040$ and set the context 
for the proof tools.
The parent theory is the theory $fef003$ which contains the single level security policy and, in particular, the definition of the lattice of security classes.
=SML
open_theory"fef003";
(force_delete_theory "fef040" handle _ => ());
new_theory Û"fef040"Ý;
new_parent Û"fef010"Ý;
push_pc "hol";
=TEX
\Note{{\it Pro tem.} $fef010$ which contains the consistency result for the dominance relation is made a parent to permit its use in proofs in this theory.}

\section{MULTI-LEVEL SECURITY POLICY}
=TEX
An index of the names used in the formal specification may be found in Section \ref{INDEX}. 
A listing of the theory $fef040$ created by processing this document using \Product{}
may be found at the end of this document.


\subsection{The Type of Behavioural Models of Systems}

The definition of information flow security presented here is a property
on behavioural models of systems.
The inputs and outputs of systems will be thought of as structured objects whose components may be labelled with security classes.
For example, an input might be an abstract syntax tree for an SSQL query with the nodes labelled with classes.
An output might be an SSQL table with nodes labelling the cells.
As in the single level model, a {\em behaviour} of a system is a single sequence of inputs and the resulting sequence of outputs.
The {\em behavioural model} of a system is the set of all its possible behaviours.
Since we are only concerned with deterministic systems, this is formalised  as a function from the sequences of inputs to sequences of outputs.
The behavioural model is generic in the types $'IP$ and $OP$ used to represent inputs and outputs. 
=SML
declare_type_abbrev(Û"ML_BEHAVIOURS"Ý,["'IP", "'OP"], ¬: ('IP)LIST ­ ('OP )LIST®);
=TEX

\subsection{Classes}
We use the lattice of security classes defined in \cite{DS/FMU/FEF/003} as the type $Class$ together with operations $dominates$, $lub$, etc.
We will need the notions of the down-set,
=INLINEFT
c%downarrow%
=TEX
, and the up-set,
=INLINEFT
c%uparrow%
=TEX
, of a class $c$.
We write these operators with postfix syntax:
=SML
declare_postfix(300, "%downarrow%");
declare_postfix(300, "%uparrow%");
=TEX
¹HOLCONST
Ü	Û$%downarrow%Ý : Class ­ Class ð
÷üüüüüüüüüüüüüü
Üµc·	c %downarrow% = { d | c dominates d }
°

¹HOLCONST
Ü	Û$%uparrow%Ý : Class ­ Class ð
÷üüüüüüüüüüüüüü
Üµc·	c %uparrow% = { d | d dominates c }
°

We need the idea of the ``orthogonal complement'' of a set $A$ of classes, which we shall write as
=INLINEFT
A ç%bottom%ê
=TEX
.
=INLINEFT
A ç%bottom%ê
=TEX
\ is to be the set of classes which are are not comparable with any element of $A$.
=SML
declare_postfix(300, "ç%bottom%ê");
=TEX
¹HOLCONST
Ü	Û$ç%bottom%êÝ : Class ð­ Class ð
÷üüüüüüüüüüüüüü
ÜµA·	A ç%bottom%ê = { c | µd·d  A ´ ³ c dominates d ± ³ d dominates c }
°


\subsection{Purging Data}
In \cite{DS/FMU/FEF/003}, the security policy is expressed in terms of relations $same\_ins$, and $same\_outs$ parameterised by a security class.
In \cite{securityprops}, the non-interference property is expressed using a relation $identicalObjs$ also parameterised by a class.
\cite{securityprops} also uses a visibility predicate $visible$ again parameterised by a class.

To generalise these ideas from \cite{DS/FMU/FEF/003,securityprops}, it is convenient to define the notion of an equivalence relation,
(an equivalence relation being one which is reflexive, symmetric and transitive).


¹HOLCONST
Ü	ÛEquivalenceÝ : ('a ª 'a) ð
÷üüüüüüüüüüüüüü
Ü	Equivalence = Reflexive ¡ Symmetric ¡ Transitive
°

\Note{The above assumes that we are only concerned with equivalence relations on the entire type of objects.
This may mean that if the input and output objects have to satisfy some invariant, then it has to be captured in a type definition.}

In \cite{DS/FMU/FEF/003,securityprops}, two objects, $x$ and $y$, are take to be identical viewed from a class, $c$, if they become the same when components whose classification is not dominated by $c$ are ``purged''.
I.e., $x$ and $y$ are taken as the same at $c$ iff. they become identical when we treat components whose classification is not in
=INLINEFT
c %downarrow%
=TEX
\ as being equal. 
To tackle the result labelling property, it is useful to have available the analogous notion for any set of classes, not just down-sets.
To do this we introduce the idea of an {\em indexed equivalence relation}.
This is to be a function, $s$ associating with each set, $A$, of classes, an equivalence relation $s(A)$.
We require that $s$ be antimonotonic with respect to inclusion, i.e., the bigger the set $A$, the finer the equivalence relation $s(A)$:

¹HOLCONST
Ü	ÛIndexedEquivÝ : (Class ð ­ ('a ª 'a)) ð
÷üüüüüüüüüüüüüü
Ü	IndexedEquiv =
Ü	{	s
Ü	|	(µA· s(A)  Equivalence)
Ü	±	(µA B· A € B ´ s(B) € s(A))}
°
(Here $s$ stands for ``same'' reflecting the terminology of \cite{DS/FMU/FEF/003}).

\Note{There are extra conditions one might choose to impose. E.g. that $f\{\}$ is the complete relation and that $f\,Universe$ is the identity relation.}

\Note{Offers for a better name than ``indexed equivalence relation'' would be gratefully received.
I have tried ``purging relation'' and ``filter'' and didn't like them much.}

Given a relation parameterised by individual classes we may lift it to an indexed relation.
In the next section, this allows us to relate the multi-level security policy with the single level one of \cite{DS/FMU/FEF/003}.
The lifting function is defined as follows:

¹HOLCONST
Ü	ÛLiftRelÝ : (Class ­ ('a ª 'a)) ­ (Class ð ­ ('a ª 'a))
÷üüüüüüüüüüüüüü
ÜµR·	LiftRel R = (ÌA·¥{ r | ¶c· c  A ± r = R c })
°

We will say that an indexed equivalence relation is {\em independent} if the following criterion holds:

¹HOLCONST
Ü	ÛIndependentÝ : (Class ð ­ ('a ª 'a)) ð
÷üüüüüüüüüüüüüü
Ü	Independent =
Ü	{	s
Ü	|	µA x· (¶y· ³(x, y)  s(A)) ´ ¶z· ³(x, z)  s(A) ± (x, z)  s(A ç%bottom%ê)}
°

\subsection{Security Policy} \label{CRITICAL}

The general multi-level security policy is parameterised by indexed equivalence relations on the inputs and outputs as defined in the previous section.
It is convenient to have the policy as a property of arbitrary functions rather than just of functions mapping input lists to output lists. 

¹HOLCONST
Ü	Ûml_secureÝ :	(Class ð ­ ('I ª 'I)) ­
Ü			(Class ð ­ ('O ª 'O)) ­
Ü			('I ­ 'O) ð
÷üüüüüüüüüüüüüüüüüüüüüüü
Ü	µs‰I s‰O b
Ü	·	b  ml_secure s‰I s‰O 
Ü	¤		s‰I  IndexedEquiv
Ü		±	s‰O  IndexedEquiv
Ü		±	µc i‰1 i‰2·
Ü				(i‰1, i‰2)  s‰I (c %downarrow%)
Ü			´	(b i‰1, b i‰2)  s‰O (c %downarrow%)
°

The following conjecture, which is fairly straightforward to prove once a few lemmas about dwon-sets etc. have been established, shows that the above multi-leve security policy does generalise the single level one of \cite{DS/FMU/FEF/003}.
=SML
val Ûconj_040_1Ý = ¬
	µbm· bm  secure ¤ bm  ml_secure (LiftRel same_ins) (LiftRel same_outs)
®;
=TEX
\section{RESULT LABELLING}
\subsection{Observations}
The general way we are modelling structured multi-level objects requires us to use indirect means to handle the idea of a component of an object labelled with a class.
We think of the component as being modelled by the function which maps an object to the class-value pair held in the component.
Because the class component is itself a potential source of information flows it will often be more convenient to think of such a function as a pair of functions, one to returning the class and the other the value.


Given an arbitrary function on a set endowed with an indexed equivalence relation, we consider the classes at or above which information has flowed into the result of applying the function.
This notion may be formalised as follows:

¹HOLCONST
Ü	ÛInfluencedÝ: (Class ð ­ ('a ª 'a)) ­ 'a ­ ('a ­ 'b) ­ Class ð
÷üüüüüüüüüüüüüüüüüüüüüüü
Üµs x f·
Ü	Influenced s x f =
Ü	{ c | ¶y· (x, y)  s(~(c %uparrow%)) ± ³f(x) = f(y) }
°

(Here
=INLINEFT
~A
=TEX
\ is ProofPower-HOL notation for the complement of the set $A$.)

That is to say
=INLINEFT
Influenced s x f
=TEX
\ is the set of classes $c$ for which there is some state $y$, such that $f$ distinguishes $x$ and $y$, but $x$ and $y$ appear to be identical when viewed from any class which does not dominate $c$.


\Note{Should one be using uncurried functions here: $Influenced(s, x, f)$?}

We model the process of examining a labelled component of an object in the output of a system by a pair of functions, $(C, V)$: $C$ computing the class; and $V$ computing the value.
We will call such a pair an {\em observation}:
=SML
declare_type_abbrev(Û"OBSERVATION"Ý,["'a", "'b"], ¬: ('a ­ Class) ¸ ('a ­ 'b)®);
=TEX
The labelled value produced when an object is observed is defined by the following function (which converts a pair of functions into a function returning pairs):

¹HOLCONST
Ü	ÛObservedValueÝ : ('a, 'b) OBSERVATION ­ 'a ­ (Class ¸ 'b)
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
ÜµC V x·
Ü	ObservedValue (C, V) x = (C x, V x)
°

We can think of the labelled values resulting from observations as (single-level) classified objects using the following parameterised equivalence relation, (cf. the filtering operation which are performed on database cells in the single-level formulation of SWORD).
For the time being, despite earlier remarks, we take it that the class in a labelled value is {\em not} part of the information revealed to the user.

¹HOLCONST
Ü	ÛSameLabValÝ : Class ­ (Class ¸ 'b) ª (Class ¸ 'b)
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Üµc·	SameLabVal c =
Ü	{	((c‰1, v‰1), (c‰2, v‰2))
Ü	|	(c dominates c‰1 ¤ c dominates c‰2)
Ü	±	(c dominates c‰1 ´ v‰1 = v‰2) }
°

We can now consider the question of when the process of making an observation is secure.
When a client makes an observation, we assume that some trusted part of the overall system will check the class which is returned and will withhold the value from clients who are not cleared to see it.
Thus the value may depend on information a client is not cleared to see, but this does not matter provided the class prevents the client from seeing the value.
However, since the class is itself intended to be part of what the client making the observation sees, the class must not depend on information the client is not allowed to know.
We will call an observation {\em bounded} if the following holds of it:

¹HOLCONST
Ü	ÛBoundedObsÝ : (Class ð ­ ('a ª 'a)) ­ ('a, 'b) OBSERVATION ð
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Üµs·	BoundedObs s =
Ü	{	(C, V) : ('a, 'b) OBSERVATION
Ü	|	µx·	Influenced s x V € (C x)%downarrow% }
°

The above definition is necessary for an observation to be secure in a certain sense, as asserted in the following conjecture:
=SML
val Ûconj_040_2Ý = ¬
µs·		s  IndexedEquiv
	´	µC V·	ObservedValue (C, V)  ml_secure s (LiftRel SameLabVal)
		´	(C, V)  BoundedObs s
®;
=TEX
=IGN
val Ûconj_040_3Ý = ¬
µs·		s  IndexedEquiv ± s(Universe) = Id Universe
	´	µC V·	(C, V)  BoundedObs s
		´	ObservedValue (C, V)  ml_secure s (LiftRel SameLabVal)
®;
=TEX
\section{CLOSING DOWN}
The following \Product{} instruction restores the previous proof context.
=SML
pop_pc();
=TEX
=IGN
output_theory{theory = "fef040",out_file = "fef040th.doc"};
=TEX
\newpage
\HOLindexOff
\input{fef040th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}

=SML
set_pc"hol";
set_goal([], ¬µl a b· (l ù a) ù b = l ù (a ¡ b)®);
a(REPEAT strip_tac);
a(list_induction_tac ¬l® THEN asm_rewrite_tac[get_spec¬$ù®]);
a(REPEAT strip_tac);
a(cases_tac¬x  a® THEN asm_rewrite_tac[get_spec¬$ù®]);
(* *** Goal "1" *** *)
a(cases_tac¬x  b® THEN asm_rewrite_tac[get_spec¬$ù®]);
(* *** Goal "1.1" *** *)
a(LEMMA_T ¬x  a ¡ b® rewrite_thm_tac THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(LEMMA_T ¬³x  a ¡ b® rewrite_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_T ¬³x  a ¡ b® rewrite_thm_tac THEN REPEAT strip_tac);
val Ûù_ù_thmÝ = save_pop_thm"ù_ù_thm";
=TEX
=SML
set_goal([], ¬µc· ³c = lattice_top ´ ³lattice_top = lattice_bottom®);
a(contr_tac);
a(lemma_tac¬lattice_top dominates c®
	THEN1 rewrite_tac[get_spec¬lattice_top®]);
a(lemma_tac¬c dominates lattice_top®
	THEN1 asm_rewrite_tac[get_spec¬lattice_top®]);
a(all_fc_tac[get_spec¬lattice_top®]);
val Ûnot_lattice_top_thmÝ = save_pop_thm"not_lattice_top_thm";
=TEX
=SML
set_goal([], ¬
	lattice_bottom %uparrow% = Universe
±	lattice_top %downarrow% = Universe
®);
a(PC_T1 "sets_ext" prove_tac(map get_spec
	[¬$%uparrow%®, ¬$%downarrow%®, ¬lattice_bottom®]));
val Ûup_down_thm1Ý = save_pop_thm"up_down_thm1";
=TEX
=SML
set_goal([], ¬
µc·	c  c %downarrow%
± 	c  c %uparrow%
± 	lattice_bottom  c %downarrow%
± 	lattice_top  c %uparrow%
®);
a(PC_T1 "sets_ext" prove_tac(map get_spec
	[¬$%uparrow%®, ¬$%downarrow%®, ¬lattice_bottom®]));
val Ûup_down_thm2Ý = save_pop_thm"up_down_thm2";
=TEX
=SML
val Ûup_down_clausesÝ = save_thm("up_down_clauses",
	(all_µ_intro o list_±_intro o map all_µ_elim)[up_down_thm1, up_down_thm2]);
=TEX
=SML
set_goal([], ¬
µc d·	³ d dominates c ´ d %downarrow% € ~(c %uparrow%)
®);
a(PC_T1 "sets_ext" prove_tac(map get_spec
	[¬~®, ¬$%uparrow%®, ¬$%downarrow%®, ¬lattice_bottom®]));
a(contr_tac THEN all_fc_tac[get_spec¬lattice_bottom®]);
val Ûup_down_thm3Ý = save_pop_thm"up_down_thm3";
=SML
set_merge_pcs["'bin_rel", "hol2"];
set_goal([], ¬
µR·	(µc· R c  Equivalence) ´
	(LiftRel R)  IndexedEquiv
®);
a(rewrite_tac(map get_spec[¬LiftRel®, ¬IndexedEquiv®, ¬Equivalence®]) THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
a(spec_nth_asm_tac 3 ¬s® THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
a(spec_nth_asm_tac 4 ¬s® THEN1 all_asm_fc_tac[]);
a(spec_nth_asm_tac 4 ¬s® THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(spec_nth_asm_tac 3 ¬s® THEN1 all_asm_fc_tac[]);
val Ûlift_rel_indexed_equiv_thmÝ = save_pop_thm"lift_rel_indexed_equiv_thm";
=TEX
=SML
set_goal([], ¬
	µc· same_ins c  Equivalence
®);
a(rewrite_tac(map get_spec[¬same_ins®, ¬Equivalence®, ¬Let®]) THEN
	REPEAT strip_tac THEN asm_rewrite_tac[]);
val Ûsame_ins_equiv_thmÝ = save_pop_thm"same_ins_equiv_thm";
=TEX
=SML
set_goal([], ¬
	µc· same_outs c  Equivalence
®);
a(rewrite_tac(map get_spec[¬same_outs®, ¬Equivalence®, ¬Let®]) THEN
	REPEAT strip_tac THEN asm_rewrite_tac[]);
val Ûsame_outs_equiv_thmÝ = save_pop_thm"same_outs_equiv_thm";
=TEX
=SML
set_goal([], ¬
	LiftRel same_ins  IndexedEquiv
±	LiftRel same_outs  IndexedEquiv
®);
a(REPEAT strip_tac THEN
	bc_tac[lift_rel_indexed_equiv_thm] THEN
	rewrite_tac[same_ins_equiv_thm, same_outs_equiv_thm]);
val Ûsame_ins_same_outs_indexed_equiv_thmÝ =
	save_pop_thm"same_ins_same_outs_indexed_equiv_thm";
=TEX
=SML
set_pc"hol";
set_goal([], ¬
µR·	(µc· R c  Equivalence) ±
	(µc d·c dominates d ´ R c € R d) ´
	µc· (LiftRel R)(c %downarrow%) = R c
®);
a(rewrite_tac[get_spec¬LiftRel®] THEN REPEAT strip_tac);
a(PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 1 ¬R c®);
a(spec_nth_asm_tac 1 ¬c®);
a(all_fc_tac[up_down_clauses]);
(* *** Goal "2" *** *)
a(asm_ante_tac ¬c'  c %downarrow%® THEN asm_rewrite_tac[get_spec¬$%downarrow%®]);
a(strip_tac THEN all_asm_fc_tac[] THEN PC_T1 "sets_ext" all_asm_fc_tac[]);
val Ûequiv_anti_mono_lift_rel_thmÝ = save_pop_thm"equiv_anti_mono_lift_rel_thm";
=TEX
=SML
set_pc"hol2";
set_goal([], ¬
	µc d·c dominates d ´ same_ins c € same_ins d
®);
a(rewrite_tac(map get_spec[¬same_ins®, ¬Let®]) THEN
	REPEAT strip_tac THEN rename_tac[]);
a(LEMMA_T¬µx·
	x ù {(q, c')|d dominates c'} =
	(x ù {(q, c')|c dominates c'}) ù {(q, c')|d dominates c'}®
	(fn th => once_rewrite_tac [th] THEN asm_rewrite_tac[]));
a(rewrite_tac[ù_ù_thm]);
a(LEMMA_T¬{(q, c')|c dominates c'} ¡ {(q, c')|d dominates c'} =
	{(q, c')|d dominates c'}® rewrite_thm_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(all_fc_tac[get_spec¬$dominates®]);
val Ûsame_ins_anti_mono_thmÝ = save_pop_thm"same_ins_anti_mono_thm";
=TEX
=SML
set_pc"hol2";
set_goal([], ¬
	µc d·c dominates d ´ same_outs c € same_outs d
®);
a(rewrite_tac(map get_spec[¬same_outs®, ¬Let®]) THEN
	REPEAT strip_tac THEN rename_tac[]);
a(LEMMA_T¬µx·
	x ù {(c', d')|d dominates c'} =
	(x ù {(c', d')|c dominates c'}) ù {(c', d')|d dominates c'}®
	(fn th => once_rewrite_tac [th] THEN asm_rewrite_tac[]));
a(rewrite_tac[ù_ù_thm]);
a(LEMMA_T¬{(c', d')|c dominates c'} ¡ {(c', d')|d dominates c'} =
	{(c', d')|d dominates c'}® rewrite_thm_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(all_fc_tac[get_spec¬$dominates®]);
val Ûsame_outs_anti_mono_thmÝ = save_pop_thm"same_outs_anti_mono_thm";
=TEX
=SML
set_pc"hol";
set_goal([], ¬
µc·	(LiftRel same_ins)(c %downarrow%) = same_ins c
±	(LiftRel same_outs)(c %downarrow%) = same_outs c
®);
a(REPEAT strip_tac THEN intro_µ_tac(¬c:Class®, ¬c:Class®) THEN
	bc_tac[equiv_anti_mono_lift_rel_thm] THEN
	rewrite_tac
	[same_ins_equiv_thm, same_outs_equiv_thm,
	same_ins_anti_mono_thm, same_outs_anti_mono_thm]);
val Ûlift_rel_same_ins_same_outs_down_set_thmÝ =
	save_pop_thm"lift_rel_same_ins_same_outs_down_set_thm";
=TEX 
=SML
set_pc"hol";
set_goal([], conj_040_1);
a(rewrite_tac(map get_spec[¬secure®, ¬ml_secure®]) THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[same_ins_same_outs_indexed_equiv_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[same_ins_same_outs_indexed_equiv_thm]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN
	asm_rewrite_tac[lift_rel_same_ins_same_outs_down_set_thm]);
(* *** Goal "4" *** *)
a(swap_nth_asm_concl_tac 2 THEN
	asm_rewrite_tac[lift_rel_same_ins_same_outs_down_set_thm]);
a(contr_tac THEN all_asm_fc_tac[]);
val Ûthm_040_1Ý = save_pop_thm"thm_040_1";
=TEX 
=SML
val ÛÞ_€_thmÝ = pc_rule1 "sets_ext" prove_rule[]¬µa b· a € b ´ Þa € Þb®;
=SML
=TEX 
=SML
set_merge_pcs["'bin_rel", "hol2"];
set_goal([], ¬µc· SameLabVal c  Equivalence®);
a(rewrite_tac(map get_spec[¬SameLabVal®, ¬Equivalence®])
	THEN REPEAT strip_tac THEN PC_T1 "prop_eq" asm_prove_tac[]);
val Ûsame_lab_val_equiv_thmÝ = save_pop_thm"same_lab_val_equiv_thm";
=TEX 
=SML
set_pc"hol";
set_goal([], ¬LiftRel SameLabVal  IndexedEquiv®);
a(bc_tac[lift_rel_indexed_equiv_thm] THEN rewrite_tac[same_lab_val_equiv_thm]);
val Ûlift_rel_same_lab_val_equiv_thmÝ =
	save_pop_thm"lift_rel_same_lab_val_equiv_thm";
=TEX 
=IGN SML
set_pc"hol";
set_goal([], conj_040_2);
a(rewrite_tac(lift_rel_same_lab_down_thm:: map get_spec
	[¬BoundedObs®, ¬ObservedValue®, ¬SameLabVal®,
	¬ml_secure®, ¬Influenced®]) THEN
	PC_T1 "hol2" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rename_tac[(¬x'®, "c")] THEN cases_tac¬µd·d dominates c®);
(* *** Goal "1.1" *** *)
a(lemma_tac ¬c dominates lattice_bottom ± lattice_bottom dominates c®
	THEN1 asm_rewrite_tac[get_spec¬lattice_bottom®]);
a(all_fc_tac[get_spec¬lattice_bottom®]);
(* *** Goal "1.2" *** *)
a(list_spec_nth_asm_tac 5 [¬d®, ¬x®, ¬y®]);
a(all_fc_tac[up_down_thm3]);
a(LIST_GET_NTH_ASM_T [9]
	(ALL_FC_T (PC_T1 "sets_ext" all_fc_tac) o
		map (rewrite_rule[get_spec¬IndexedEquiv®])));
(* *** Goal "2" *** *)
a(rename_tac[(¬x'®, "c")] THEN rewrite_tac[get_spec¬$%downarrow%®]);
a(contr_tac);
a(lemma_tac¬C x dominates C x® THEN1 rewrite_tac[get_spec¬lattice_bottom®]);
a(list_spec_nth_asm_tac 5 [¬C x®, ¬x®, ¬y®]);
a(all_fc_tac[up_down_thm3]);
a(LIST_GET_NTH_ASM_T [9]
	(ALL_FC_T (PC_T1 "sets_ext" all_fc_tac) o
		map (rewrite_rule[get_spec¬IndexedEquiv®])));
val Ûthm_040_2Ý = save_pop_thm"thm_040_2";
=TEX 
=SML
set_pc"hol";
set_goal([], ¬µx·c %downarrow% = ¥{A | ¶d·³c dominates d ± A = ~(d %uparrow%)}®);
a(rewrite_tac(map get_spec[¬$%downarrow%®, ¬$%uparrow%®]) THEN
	PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[get_spec¬~®]);
a(contr_tac THEN all_fc_tac[get_spec¬$dominates®]);
(* *** Goal "2" *** *)
a(cases_tac¬c dominates x®);
a(spec_nth_asm_tac 2 ¬~{y | y dominates x}®);
(* *** Goal "2.1" *** *)
a(spec_nth_asm_tac 1 ¬x®);
(* *** Goal "2.2" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac(map get_spec[¬~®, ¬$dominates®]));
val Ûdown_¥_comp_up_thmÝ = save_pop_thm"down_¥_comp_up_thm";
=TEX 
=IGN SML
set_pc"hol";
set_goal([], conj_040_3);
a(rewrite_tac(lift_rel_same_lab_down_thm:: map get_spec
	[¬BoundedObs®, ¬ObservedValue®, ¬SameLabVal®,
	¬ml_secure®, ¬Influenced®]) THEN
	PC_T1 "hol2" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[lift_rel_same_lab_val_equiv_thm]);
(* *** Goal "2" *** *)
a(cases_tac¬c = lattice_top®);
(* *** Goal "2.1" *** *)
a(var_elim_nth_asm_tac 1);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[up_down_clauses]));
a(all_asm_fc_tac[]);
a(POP_ASM_T (rewrite_thm_tac o rewrite_rule[get_spec¬Id®]));
(* *** Goal "2.2" *** *)



val Ûthm_040_3Ý = save_pop_thm"thm_040_3";

=IGN
\section{STATE MACHINES}
Behavioural models for systems are obtained from state machines.
We model a state machine as a pair comprising an initial state and a transition function:
=SML
=IGN ¹HOLLABPROD ÛMACHINEÝ
Ü	Init	: 'STATE;
Ü	TrF	: 'OBJ ¸ 'STATE ­ 'STATE ¸ 'OBJ
°
=IGN
Given such a state machine, we may construct its behavioural model as follows:
=IGN ¹HOLCONST
Ü	Ûml_behavioursÝ : ('OBJ, 'STATE) MACHINE ­ 'OBJ ML_BEHAVIOURS
÷üüüüüüüüüüüüüüü
Üµm : ('OBJ, 'STATE) MACHINE·
Ü	ml_behaviours m =
Ü	let	step i (st, resl) =
Ü		let	(st', res) = TrF(m)(i, st)
Ü		in	(st', resl ë [res])
Ü	in	Ìil· Snd(Fold step (Rev il) (Init m, []))
°



=IGN
val Ûrun_machine_convÝ =
	(rewrite_conv(map get_spec[¬Let®, ¬MkMACHINE®, ¬ml_behaviours®])
	THEN_C
	PC_C1 "hol2" rewrite_conv(map get_spec[¬Fold®, ¬Rev®, ¬Append®]));

run_machine_conv
¬	(let	counter = MkMACHINE 0 (Ì(i, s)· (s + i, s + i))
	in	ml_behaviours counter)
	[1;2;3;4]
®;


run_machine_conv
¬	(let	counter =
		MkMACHINE 0
		(Ì(i, s)· if i > s then (i, i) else (s, s))
	in	ml_behaviours counter)
	[1;3;2;4;1;5;4;3;2;7;8;0]
®;

run_machine_conv
¬	(let	counter = MkMACHINE (0, 0) (Ì(i, (acc, ct))· ((acc + i, ct + 1), (acc + i) Div (ct + 1)))
	in	ml_behaviours counter)
	[1;5;15;20]
®;

