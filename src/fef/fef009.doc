=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Proof of Security (I)}  %% Mandatory field
\TPPref{DS/FMU/FEF/009}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Approved}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document contains the formal proof of 
the unwinding result, part of the proof of security of 
the SSQL Abstract Machine for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion(\FormatDate{$Date$
})] First approved version.
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document provides a formal proof of the unwinding result as specified in 
the proof strategy \cite{DS/FMU/FEF/007}. It constitutes part of deliverable D5 
of work package 1a, as given
in section 7 of the Secure Database Technical Proposal, \cite{DS/FMU/017}.



\subsection{Introduction}
This document is a proof script which provides a formal proof of
the unwinding result described in the proof strategy document \cite{DS/FMU/FEF/007}.
Proof of the unwinding result comprises proofs of the lemmas 3,4 and 5 
from \cite{DS/FMU/FEF/007}:

{\bf Lemma3}
=GFT
	?Ù 	(hide ç secureHide 
		± 
		(hide,updateState) ç secureUpdate) 
		¥
		SSQLtf ç secureStf 
=TEX
{\bf Lemma4}
=GFT
	?Ù 	SSQLtf ç secureStf 
		¥ 
		(iterate SSQLtf) ç secureItf 
=TEX
{\bf Lemma5}
=GFT
	?Ù 	(iterate SSQLtf) ç secureItf 
		¥ 
		behaviours SSQLam ç secure
=TEX
where $hide$ and $updateState$ are defined in \cite{DS/FMU/FEF/005}, $secureHide$, 
$secureUpdate$, $SSQLtf$, $secureStf$ and $secureItf$ are defined in \cite{DS/FMU/FEF/007},
$iterate$, $behaviours$ and $SSQLam$ are defined in \cite{DS/FMU/FEF/006}, and $secure$
is defined in \cite{DS/FMU/FEF/003}.
\section{PRELIMINARIES}
The following ICL HOL instructions set up the new theory $fef009$.

=SML 
open_theory "fef007";
new_theory€"fef009"›;
push_merge_pcs["hol","fefhol","'pair1"] ;
=TEX

In the proof script that follows, some output from the proof tool has been included for clarity
where top level goals are split into subgoals.  The proof script proper is in Standard ML, 
and is marked by a vertical bar on the left starting with the characters ``SML''. Output
from the proof tool is distinguished by a vertical bar on the left headed by ``HOL output''.
The subgoals consist of a {\it conclusion} to be proven and a number of {\it assumptions}
which are available for use in the proof. The assumptions are listed first,  followed
by the conclusion. 
\subsection{Retrieving the Constants}
The definitions of constants used in the specifications are retrieved 
from their defining theories.
=SML
val €secureHide_def› = get_spec¨secureHideÆ;
val €secureUpdate_def› = conv_rule(MAP_C let_conv)(get_spec¨secureUpdateÆ);
val €SSQLtf_def› = get_spec¨SSQLtfÆ;
val €secureStf_def› = conv_rule(MAP_C let_conv)(get_spec¨secureStfÆ);
val €same_ins_def› = conv_rule(MAP_C let_conv)(get_spec¨same_insÆ);
val €same_outs_def› = conv_rule(MAP_C let_conv)(get_spec¨same_outsÆ);
val €mkTf_def› = get_spec¨mkTfÆ;
val €secureItf_def› = conv_rule(MAP_C let_conv)(get_spec¨secureItfÆ);
val €behaviours_def› = get_spec¨behavioursÆ;
val €SSQLam_def› = get_spec¨SSQLamÆ;
val €secure_def› = get_spec¨secureÆ;
=TEX
\section{PROOF OF $Lemma3$}

=SML
push_goal([],¨Lemma3Æ);
a(rewrite_tac[Lemma3,secureHide_def,secureUpdate_def,SSQLtf_def,secureStf_def,
	same_ins_def,same_outs_def]);
a(strip_tac THEN strip_tac);
=TEX
=GFT HOL output
Tactic produced 2 subgoals:

(* *** Goal "1" *** *)

(*  7 *)  ¨µ câ1 câ2 sâ1 sâ2
           ∑ hide (câ1, sâ1) = hide (câ1, sâ2) ± câ1 dominates câ2
               ¥ hide (câ2, sâ1) = hide (câ2, sâ2)Æ
(*  6 *)  ¨µ câ1 câ2 s e
           ∑ ≥ hide (câ2, s) = hide (câ2, Fst (updateState (câ1, e, s)))
               ¥ câ2 dominates câ1Æ
(*  5 *)  ¨µ câ1 câ2 sâ1 sâ2 e
           ∑ hide (câ1, sâ1) = hide (câ1, sâ2) ± câ1 dominates câ2
               ¥ hide (câ1, Fst (updateState (câ2, e, sâ1)))
                 = hide (câ1, Fst (updateState (câ2, e, sâ2)))Æ
(*  4 *)  ¨µ c sâ1 sâ2 e
           ∑ hide (c, sâ1) = hide (c, sâ2)
               ¥ Snd (updateState (c, e, sâ1)) = Snd (updateState (c, e, sâ2))Æ
(*  3 *)  ¨µ c s e∑ Fst (Snd (updateState (c, e, s))) = cÆ
(*  2 *)  ¨hide (c, sâ1) = hide (c, sâ2)Æ
(*  1 *)  ¨[iâ1] ˘ {(q, c')|c dominates c'}
             = [iâ2] ˘ {(q, c')|c dominates c'}Æ

(* ?Ù *)  ¨µ sâ1 sâ2 iâ1 iâ2 c
           ∑ hide (c, sâ1) = hide (c, sâ2)
                 ± [iâ1] ˘ {(q, c')|c dominates c'} = [iâ2] ˘ {(q, c')|c dominates c'}
               ¥ hide(c, Fst(mkTf hide processQuery updateState(iâ1, sâ1)))
                   = hide(c,Fst(mkTf hide processQuery updateState(iâ2, sâ2)))
                 ± [Snd (mkTf hide processQuery updateState (iâ1, sâ1))]
                     ˘ {(c', d)|c dominates c'}
                   = [Snd (mkTf hide processQuery updateState (iâ2, sâ2))]
                     ˘ {(c', d)|c dominates c'}Æ
=TEX
=SML
a(REPEAT µ_tac THEN  strip_tac);
a(POP_ASM_T ante_tac THEN rewrite_tac[˘_thm6]);
a ¥_tac;
=TEX
=GFT HOL output
Tactic produced 2 subgoals:

(* *** Goal "1.1" *** *)

(*  7 *)  ¨µ câ1 câ2 sâ1 sâ2
           ∑ hide (câ1, sâ1) = hide (câ1, sâ2) ± câ1 dominates câ2
               ¥ hide (câ2, sâ1) = hide (câ2, sâ2)Æ
(*  6 *)  ¨µ câ1 câ2 s e
           ∑ ≥ hide (câ2, s) = hide (câ2, Fst (updateState (câ1, e, s)))
               ¥ câ2 dominates câ1Æ
(*  5 *)  ¨µ câ1 câ2 sâ1 sâ2 e
           ∑ hide (câ1, sâ1) = hide (câ1, sâ2) ± câ1 dominates câ2
               ¥ hide (câ1, Fst (updateState (câ2, e, sâ1)))
                 = hide (câ1, Fst (updateState (câ2, e, sâ2)))Æ
(*  4 *)  ¨µ c sâ1 sâ2 e
           ∑ hide (c, sâ1) = hide (c, sâ2)
               ¥ Snd (updateState (c, e, sâ1)) = Snd (updateState (c, e, sâ2))Æ
(*  3 *)  ¨µ c s e∑ Fst (Snd (updateState (c, e, s))) = cÆ
(*  2 *)  ¨hide (c, sâ1) = hide (c, sâ2)Æ
(*  1 *)  ¨iâ1 = iâ2Æ

(* ?Ù *)  ¨hide (c, Fst (mkTf hide processQuery updateState (iâ1, sâ1)))
               = hide
                 (c, Fst (mkTf hide processQuery updateState (iâ2, sâ2)))
             ± (Snd (mkTf hide processQuery updateState (iâ1, sâ1))
                 = Snd (mkTf hide processQuery updateState (iâ2, sâ2))
               ≤ ≥ c dominates Fst
                       (Snd (mkTf hide processQuery updateState (iâ1, sâ1)))
                 ± ≥ c dominates Fst (Snd(mkTf hide processQuery updateState(iâ2, sâ2))))Æ
=TEX
=SML
a(POP_ASM_T rewrite_thm_tac);
a(LEMMA_T¨iâ2 = (Fst iâ2,Snd iâ2)Æ pure_once_rewrite_thm_tac 
	THEN_LIST[rewrite_tac[],asm_rewrite_tac[mkTf_def]]);
a(cases_tac¨c dominates Snd iâ2Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1.1.1" *** *)
a(lemma_tac¨hide (Snd iâ2, sâ1) = hide (Snd iâ2, sâ2)Æ
	THEN_LIST[list_asm_ante_tac (map get_asm[1,2,7])THEN prove_tac[],
	TOP_ASM_T rewrite_thm_tac]);
a(list_asm_ante_tac (map get_asm[1,2,3,5,6])THEN prove_tac[]);
(* *** Goal "1.1.2" *** *)
a(list_spec_nth_asm_tac 6[¨Snd iâ2Æ,¨cÆ,¨sâ1Æ,
	¨processQuery (Fst iâ2, Snd iâ2, hide (Snd iâ2, sâ1))Æ]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(list_spec_nth_asm_tac 6[¨Snd iâ2:ClassÆ,¨cÆ,¨sâ2Æ,
	¨processQuery (Fst iâ2, Snd iâ2, hide (Snd iâ2, sâ2))Æ]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(DROP_NTH_ASM_T 2 rewrite_thm_tac);
=TEX
=GFT HOL output
(* *** Goal "1.2" *** *)

(*  8 *)  ¨µ câ1 câ2 sâ1 sâ2
           ∑ hide (câ1, sâ1) = hide (câ1, sâ2) ± câ1 dominates câ2
               ¥ hide (câ2, sâ1) = hide (câ2, sâ2)Æ
(*  7 *)  ¨µ câ1 câ2 s e
           ∑ ≥ hide (câ2, s) = hide (câ2, Fst (updateState (câ1, e, s)))
               ¥ câ2 dominates câ1Æ
(*  6 *)  ¨µ câ1 câ2 sâ1 sâ2 e
           ∑ hide (câ1, sâ1) = hide (câ1, sâ2) ± câ1 dominates câ2
               ¥ hide (câ1, Fst (updateState (câ2, e, sâ1)))
                 = hide (câ1, Fst (updateState (câ2, e, sâ2)))Æ
(*  5 *)  ¨µ c sâ1 sâ2 e
           ∑ hide (c, sâ1) = hide (c, sâ2)
               ¥ Snd (updateState (c, e, sâ1)) = Snd (updateState (c, e, sâ2))Æ
(*  4 *)  ¨µ c s e∑ Fst (Snd (updateState (c, e, s))) = cÆ
(*  3 *)  ¨hide (c, sâ1) = hide (c, sâ2)Æ
(*  2 *)  ¨≥ c dominates Snd iâ1Æ
(*  1 *)  ¨≥ c dominates Snd iâ2Æ

(* ?Ù *)  ¨hide (c, Fst (mkTf hide processQuery updateState (iâ1, sâ1)))
               = hide
                 (c, Fst (mkTf hide processQuery updateState (iâ2, sâ2)))
             ± (Snd (mkTf hide processQuery updateState (iâ1, sâ1))
                 = Snd (mkTf hide processQuery updateState (iâ2, sâ2))
               ≤ ≥ c dominates Fst
                       (Snd (mkTf hide processQuery updateState (iâ1, sâ1)))
                 ± ≥ c dominates Fst(Snd(mkTf hide processQuery updateState(iâ2, sâ2))))Æ
=TEX

=SML
a(LEMMA_T¨iâ1 = (Fst iâ1,Snd iâ1)Æ pure_once_rewrite_thm_tac 
	THEN_LIST[rewrite_tac[],id_tac]);
a(LEMMA_T¨iâ2 = (Fst iâ2,Snd iâ2)Æ pure_once_rewrite_thm_tac 
	THEN_LIST[rewrite_tac[],asm_rewrite_tac[mkTf_def]]);
a(list_spec_nth_asm_tac 7[¨Snd iâ1Æ,¨cÆ,¨sâ1Æ,
	¨processQuery (Fst iâ1, Snd iâ1, hide (Snd iâ1, sâ1))Æ]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(list_spec_nth_asm_tac 7[¨Snd iâ2Æ,¨cÆ,¨sâ2Æ,
	¨processQuery (Fst iâ2, Snd iâ2, hide (Snd iâ2, sâ2))Æ]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(DROP_NTH_ASM_T 3 rewrite_thm_tac);
=TEX
=GFT HOL output
(* *** Goal "2" *** *)

(*  5 *)  ¨µ câ1 câ2 sâ1 sâ2
           ∑ hide (câ1, sâ1) = hide (câ1, sâ2) ± câ1 dominates câ2
               ¥ hide (câ2, sâ1) = hide (câ2, sâ2)Æ
(*  4 *)  ¨µ câ1 câ2 s e
           ∑ ≥ hide (câ2, s) = hide (câ2, Fst (updateState (câ1, e, s)))
               ¥ câ2 dominates câ1Æ
(*  3 *)  ¨µ câ1 câ2 sâ1 sâ2 e
           ∑ hide (câ1, sâ1) = hide (câ1, sâ2) ± câ1 dominates câ2
               ¥ hide (câ1, Fst (updateState (câ2, e, sâ1)))
                 = hide (câ1, Fst (updateState (câ2, e, sâ2)))Æ
(*  2 *)  ¨µ c sâ1 sâ2 e
           ∑ hide (c, sâ1) = hide (c, sâ2)
               ¥ Snd (updateState (c, e, sâ1)) = Snd (updateState (c, e, sâ2))Æ
(*  1 *)  ¨µ c s e∑ Fst (Snd (updateState (c, e, s))) = cÆ

(* ?Ù *)  ¨µ s i c ∑ ≥ c dominates Snd i
               ¥ hide (c, s) = hide(c, Fst (mkTf hide processQuery updateState (i, s)))
                 ± ≥ c dominates Fst(Snd (mkTf hide processQuery updateState (i, s)))Æ
=TEX
=SML
a(REPEAT µ_tac THEN  strip_tac);
a(LEMMA_T¨i = (Fst i,Snd i)Æ pure_once_rewrite_thm_tac 
	THEN_LIST[rewrite_tac[],asm_rewrite_tac[mkTf_def]]);
a(list_asm_ante_tac (map get_asm[1,5])THEN prove_tac[]);
val lemma3_thm = save_pop_thm"Lemma3";
=TEX
\section{PROOF OF $Lemma4$}
\subsection{Auxiliary Results}

We first prove the consistency of $iterate$ by providing
 a witness  $iterate\_witness$, for use in the consistency proof. This definition
is a primitive recursive definition whose consistency is automatically
proven by the system.

πHOLCONST
‹	€iterate_witness› : ((('QUERY ∏ Class) ∏ 'STATE) ≠ ('STATE ∏ (Class ∏ 'DATA)))
‹				≠ 'STATE ≠ ('QUERY ∏ Class)LIST 
‹				≠ ('STATE ∏ ((Class ∏ 'DATA)LIST))
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µs:'STATE;i:'QUERY ∏ Class;si:('QUERY ∏ Class) LIST;
‹	f:(('QUERY ∏ Class) ∏ 'STATE) ≠ ('STATE ∏ (Class ∏ 'DATA))
‹	∑	iterate_witness f s [] = (s,[])
‹	±
‹		iterate_witness f s (Cons i si)
‹			= 
‹			(Fst(f(i,Fst(iterate_witness f s si))),
‹			(Snd(iterate_witness f s si) Î 
‹				[Snd(f(i,Fst(iterate_witness f s si)))] ))
∞

=SML
push_consistency_goal¨iterateÆ;
a(conv_tac(MAP_C let_conv));
a(∂_tac¨Ãx (y,z) ∑ iterate_witness x z (Rev y)Æ);
a(rewrite_tac[Î_Cons_thm,rev_def,rev_sym_thm,get_spec¨iterate_witnessÆ]);
val iterate_consistent = save_consistency_thm¨iterateÆ (pop_thm());
=TEX

=GFT HOL output
iterate_consistent = Ù Consistent
    (Ã iterate'
      ∑ µ s i si f
        ∑ iterate' f ([], s) = (s, [])
            ± (let sso = iterate' f (si, s)
            in iterate' f (si Î [i], s)
              = (Fst (f (i, Fst sso)), Snd sso Î [Snd (f (i, Fst sso))]))) : THM
=TEX 
Now the definition of $iterate$ is retrieved with its consistency proof obligation discharged.
=SML
val iterate_def = conv_rule(MAP_C let_conv)(get_spec¨iterateÆ);
=TEX
=GFT HOL output
iterate_def = Ù µ s i si f
  ∑ iterate f ([], s) = (s, [])
      ± iterate f (si Î [i], s)
        = (Fst (f (i, Fst (iterate f (si, s)))),
          Snd (iterate f (si, s)) Î [Snd (f (i, Fst (iterate f (si, s))))])
=TEX

\subsection{Lemma4}
=SML
push_goal([],¨Lemma4Æ); 
a(rewrite_tac[Lemma4,secureStf_def,secureItf_def]);
a strip_tac;
(** need to reorder variables **)
a(REPEAT µ_tac);
a(MAP_EVERY intro_µ_tac[(¨sâ2Æ,¨sâ2Æ),(¨sâ1Æ,¨sâ1Æ),(¨cÆ,¨cÆ),(¨siâ2Æ,¨siâ2Æ)]);
a(REV_LIST_INDUCTION_T¨siâ1Æasm_tac);
=TEX
=GFT HOL output
Tactic produced 2 subgoals:

(* *** Goal "1" *** *)

(*  2 *)  ¨µ sâ1 sâ2 iâ1 iâ2 c
           ∑ hide (c, sâ1) = hide (c, sâ2) ± ([iâ1], [iâ2]) ç same_ins c
               ¥ hide (c, Fst (SSQLtf (iâ1, sâ1)))
                   = hide (c, Fst (SSQLtf (iâ2, sâ2)))
                 ± ([Snd (SSQLtf (iâ1, sâ1))], [Snd (SSQLtf (iâ2, sâ2))]) ç same_outs cÆ
(*  1 *)  ¨µ s i c
           ∑ ≥ c dominates Snd i
               ¥ hide (c, s) = hide (c, Fst (SSQLtf (i, s)))
                 ± ≥ c dominates Fst (Snd (SSQLtf (i, s)))Æ

(* ?Ù *)  ¨µ siâ2 c sâ1 sâ2
           ∑ hide (c, sâ1) = hide (c, sâ2) ± ([], siâ2) ç same_ins c
               ¥ hide (c, Fst (iterate SSQLtf ([], sâ1)))
                   = hide (c, Fst (iterate SSQLtf (siâ2, sâ2)))
                 ± (Snd (iterate SSQLtf ([], sâ1)),
                     Snd (iterate SSQLtf (siâ2, sâ2))) ç same_outs cÆ
=TEX
=SML
a µ_tac;
a(REV_LIST_INDUCTION_T¨siâ2Æasm_tac);
(* *** Goal "1.1"  *** *)
(* *** siâ1, siâ2 both empty *** *)
a(rewrite_tac[iterate_def,same_ins_def,same_outs_def]);
(* *** Goal "1.2" *** *)
(* *** siâ1 empty, siâ2 non empty *** *)
a(REPEAT µ_tac);
a(POP_ASM_T ante_tac);
a(rewrite_tac[iterate_def,same_ins_def,same_outs_def]);
a(cases_tac¨c dominates Snd lastÆTHEN asm_rewrite_tac[]);
a(lemma_tac¨(hide (c, Fst (iterate SSQLtf (siâ2, sâ2)))
             = hide (c, Fst (SSQLtf (last, Fst (iterate SSQLtf (siâ2, sâ2))))))
	± ≥(c dominates Fst
                         (Snd (SSQLtf (last, Fst (iterate SSQLtf (siâ2, sâ2))))))Æ
	THEN_LIST[asm_prove_tac[],asm_rewrite_tac[]]);
a ¥_tac;
a(¥_tac THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 3 (ante_tac o list_µ_elim[¨cÆ,¨sâ1Æ,¨sâ2Æ]) THEN asm_rewrite_tac[]);
=TEX
=GFT HOL output
(* *** Goal "2" *** *)

(*  3 *)  ¨µ sâ1 sâ2 iâ1 iâ2 c
           ∑ hide (c, sâ1) = hide (c, sâ2) ± ([iâ1], [iâ2]) ç same_ins c
               ¥ hide (c, Fst (SSQLtf (iâ1, sâ1)))
                   = hide (c, Fst (SSQLtf (iâ2, sâ2)))
                 ± ([Snd (SSQLtf (iâ1, sâ1))], [Snd (SSQLtf (iâ2, sâ2))])
                   ç same_outs cÆ
(*  2 *)  ¨µ s i c
           ∑ ≥ c dominates Snd i
               ¥ hide (c, s) = hide (c, Fst (SSQLtf (i, s)))
                 ± ≥ c dominates Fst (Snd (SSQLtf (i, s)))Æ
(*  1 *)  ¨µ siâ2 c sâ1 sâ2
           ∑ hide (c, sâ1) = hide (c, sâ2) ± (siâ1, siâ2) ç same_ins c
               ¥ hide (c, Fst (iterate SSQLtf (siâ1, sâ1)))
                   = hide (c, Fst (iterate SSQLtf (siâ2, sâ2)))
                 ± (Snd (iterate SSQLtf (siâ1, sâ1)),
                     Snd (iterate SSQLtf (siâ2, sâ2))) ç same_outs cÆ

(* ?Ù *)  ¨µ last siâ2 c sâ1 sâ2
           ∑ hide (c, sâ1) = hide (c, sâ2) ± (siâ1 Î [last], siâ2) ç same_ins c
               ¥ hide (c, Fst (iterate SSQLtf (siâ1 Î [last], sâ1)))
                   = hide (c, Fst (iterate SSQLtf (siâ2, sâ2)))
                 ± (Snd (iterate SSQLtf (siâ1 Î [last], sâ1)),
                     Snd (iterate SSQLtf (siâ2, sâ2))) ç same_outs cÆ
=TEX

=SML
(** need to reorder variables **)
a(REPEAT µ_tac);
a(MAP_EVERY intro_µ_tac[(¨sâ2Æ,¨sâ2Æ),(¨sâ1Æ,¨sâ1Æ),(¨cÆ,¨cÆ),(¨lastÆ,¨lastÆ)]);
a(POP_ASM_T ante_tac);
a(REV_LIST_INDUCTION_T¨siâ2Æasm_tac);
(* *** Goal "2.1" *** *)
(* *** siâ1 non empty, siâ2 empty *** *)
a(rewrite_tac[iterate_def,same_ins_def,same_outs_def]);
a(¥_tac THEN REPEAT µ_tac);
a(cases_tac¨c dominates Snd lastÆTHEN asm_rewrite_tac[]);
a(lemma_tac¨(hide (c, Fst (iterate SSQLtf (siâ1, sâ1)))
             = hide (c, Fst (SSQLtf (last, Fst (iterate SSQLtf (siâ1, sâ1))))))
	± ≥(c dominates Fst
                         (Snd (SSQLtf (last, Fst (iterate SSQLtf (siâ1, sâ1))))))Æ
	THEN_LIST[list_asm_ante_tac (map get_asm[1,3])THEN prove_tac[],
		asm_rewrite_tac[]]);
a ¥_tac;
a(DROP_NTH_ASM_T 6 (ante_tac o list_µ_elim[¨[]:(Query ∏ Class)LISTÆ,¨cÆ,¨sâ1Æ,¨sâ2Æ]) 
	THEN asm_rewrite_tac[iterate_def]);
=TEX
=SML
(* *** Goal "2.2" *** *)
(* *** siâ1, siâ2 both non empty *** *)
a (µ_tac THEN POP_ASM_T ante_tac);
a(rewrite_tac[iterate_def,same_ins_def,same_outs_def]);
a(¥_T asm_tac THEN ¥_tac);
a(REPEAT µ_tac);
a(cases_tac¨c dominates Snd lastÆTHEN cases_tac¨c dominates Snd last'Æ
	THEN asm_rewrite_tac[] THEN ¥_tac);
=TEX
=GFT HOL output
Tactic produced 4 subgoals:

(* *** Goal "2.2.1" *** *)

(*  9 *)  ¨µ sâ1 sâ2 iâ1 iâ2 c
           ∑ hide (c, sâ1) = hide (c, sâ2) ± ([iâ1], [iâ2]) ç same_ins c
               ¥ hide (c, Fst (SSQLtf (iâ1, sâ1))) = hide (c, Fst (SSQLtf (iâ2, sâ2)))
                 ± ([Snd (SSQLtf (iâ1, sâ1))], [Snd (SSQLtf (iâ2, sâ2))]) ç same_outs cÆ
(*  8 *)  ¨µ s i c ∑ ≥ c dominates Snd i
               ¥ hide (c, s) = hide (c, Fst (SSQLtf (i, s)))
                 ± ≥ c dominates Fst (Snd (SSQLtf (i, s)))Æ
(*  7 *)  ¨(µ siâ2 c sâ1 sâ2 ∑ hide (c, sâ1) = hide (c, sâ2)
                   ± siâ1 ˘ {(q, c')|c dominates c'}
                     = siâ2 ˘ {(q, c')|c dominates c'}
                 ¥ hide (c, Fst (iterate SSQLtf (siâ1, sâ1)))
                     = hide (c, Fst (iterate SSQLtf (siâ2, sâ2)))
                   ± Snd (iterate SSQLtf (siâ1, sâ1)) ˘ {(c', d)|c dominates c'}
                     = Snd (iterate SSQLtf (siâ2, sâ2)) ˘ {(c', d)|c dominates c'})
             ¥ (µ last c sâ1 sâ2 ∑ hide (c, sâ1) = hide (c, sâ2)
                   ± (if c dominates Snd last
                       then (siâ1 ˘ {(q, c')|c dominates c'}) Î [last]
                       else siâ1 ˘ {(q, c')|c dominates c'})
                     = siâ2 ˘ {(q, c')|c dominates c'}
                 ¥ hide(c,Fst(SSQLtf(last,Fst (iterate SSQLtf (siâ1, sâ1)))))
                     = hide (c, Fst (iterate SSQLtf (siâ2, sâ2)))
                   ± (if c dominates Fst(Snd(SSQLtf(last,
                                         Fst (iterate SSQLtf (siâ1, sâ1)))))
                       then
                         (Snd (iterate SSQLtf (siâ1, sâ1)) ˘ {(c', d)|c dominates c'})
                           Î [Snd(SSQLtf(last,Fst (iterate SSQLtf (siâ1, sâ1))))]
                       else
                         Snd (iterate SSQLtf (siâ1, sâ1)) ˘ {(c', d)|c dominates c'})
                     = Snd (iterate SSQLtf (siâ2, sâ2)) ˘ {(c', d)|c dominates c'})Æ
(*  6 *)  ¨µ siâ2 c sâ1 sâ2 ∑ hide (c, sâ1) = hide (c, sâ2)
                 ± siâ1 ˘ {(q, c')|c dominates c'} = siâ2 ˘ {(q, c')|c dominates c'}
               ¥ hide (c, Fst (iterate SSQLtf (siâ1, sâ1)))
                   = hide (c, Fst (iterate SSQLtf (siâ2, sâ2)))
                 ± Snd (iterate SSQLtf (siâ1, sâ1)) ˘ {(c', d)|c dominates c'}
                   = Snd (iterate SSQLtf (siâ2, sâ2)) ˘ {(c', d)|c dominates c'}Æ
(*  5 *)  ¨c dominates Snd lastÆ
(*  4 *)  ¨c dominates Snd last'Æ
(*  3 *)  ¨hide (c, sâ1) = hide (c, sâ2)Æ
(*  2 *)  ¨siâ1 ˘ {(q, c')|c dominates c'} = siâ2 ˘ {(q, c')|c dominates c'}Æ
(*  1 *)  ¨last' = lastÆ
=TEX
=GFT HOL output

(* ?Ù *)  ¨hide(c,Fst(SSQLtf(last', Fst (iterate SSQLtf (siâ1, sâ1)))))
            = hide(c,Fst(SSQLtf(last, Fst (iterate SSQLtf (siâ2, sâ2)))))
             ± (if c dominates Fst(Snd(SSQLtf(last',Fst(iterate SSQLtf (siâ1, sâ1)))))
                 then
                   (Snd (iterate SSQLtf (siâ1, sâ1)) ˘ {(c', d)|c dominates c'})
                     Î [Snd(SSQLtf
                             (last', Fst (iterate SSQLtf (siâ1, sâ1))))]
                 else
                   Snd (iterate SSQLtf (siâ1, sâ1)) ˘ {(c', d)|c dominates c'})
               = (if c dominates Fst(Snd(SSQLtf(last, Fst (iterate SSQLtf (siâ2, sâ2)))))
                 then
                   (Snd (iterate SSQLtf (siâ2, sâ2)) ˘ {(c', d)|c dominates c'})
                     Î [Snd(SSQLtf(last, Fst (iterate SSQLtf (siâ2, sâ2))))]
                 else
                   Snd (iterate SSQLtf (siâ2, sâ2)) ˘ {(c', d)|c dominates c'})Æ
=TEX
=SML
a(POP_ASM_T rewrite_thm_tac);
a(DROP_NTH_ASM_T 5(ante_tac o list_µ_elim[¨siâ2Æ,¨cÆ,¨sâ1Æ,¨sâ2Æ]));
a(asm_rewrite_tac[] THEN ¥_tac);
a(DROP_NTH_ASM_T 9(asm_tac o rewrite_rule[same_ins_def,same_outs_def]));
a(list_spec_nth_asm_tac 1 [¨Fst (iterate SSQLtf (siâ1, sâ1))Æ,
	¨Fst (iterate SSQLtf (siâ2, sâ2))Æ,¨lastÆ,¨lastÆ,¨cÆ]);
a(POP_ASM_T (ante_tac o rewrite_rule[˘_thm6]));
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
=TEX
=GFT HOL output

(* *** Goal "2.2.2" *** *)

(*  8 *)  ¨µ sâ1 sâ2 iâ1 iâ2 c
           ∑ hide (c, sâ1) = hide (c, sâ2) ± ([iâ1], [iâ2]) ç same_ins c
               ¥ hide (c, Fst (SSQLtf (iâ1, sâ1))) = hide (c, Fst (SSQLtf (iâ2, sâ2)))
                 ± ([Snd (SSQLtf (iâ1, sâ1))], [Snd (SSQLtf (iâ2, sâ2))]) ç same_outs cÆ
.
.
.
(*  4 *)  ¨c dominates Snd lastÆ
(*  3 *)  ¨≥ c dominates Snd last'Æ
(*  2 *)  ¨hide (c, sâ1) = hide (c, sâ2)Æ
(*  1 *)  ¨siâ1 ˘ {(q, c')|c dominates c'}
             = (siâ2 ˘ {(q, c')|c dominates c'}) Î [last]Æ


(* ?Ù *)  ¨hide(c,Fst(SSQLtf(last', Fst (iterate SSQLtf (siâ1, sâ1)))))
            = hide(c,Fst(SSQLtf(last, Fst (iterate SSQLtf (siâ2, sâ2)))))
             ± (if c dominates Fst(Snd(SSQLtf(last',Fst(iterate SSQLtf (siâ1, sâ1)))))
                 then
                   (Snd (iterate SSQLtf (siâ1, sâ1)) ˘ {(c', d)|c dominates c'})
                     Î [Snd(SSQLtf
                             (last', Fst (iterate SSQLtf (siâ1, sâ1))))]
                 else
                   Snd (iterate SSQLtf (siâ1, sâ1)) ˘ {(c', d)|c dominates c'})
               = (if c dominates Fst(Snd(SSQLtf(last, Fst (iterate SSQLtf (siâ2, sâ2)))))
                 then
                   (Snd (iterate SSQLtf (siâ2, sâ2)) ˘ {(c', d)|c dominates c'})
                     Î [Snd(SSQLtf(last, Fst (iterate SSQLtf (siâ2, sâ2))))]
                 else
                   Snd (iterate SSQLtf (siâ2, sâ2)) ˘ {(c', d)|c dominates c'})Æ
=TEX

=SML
a(lemma_tac¨(hide (c, Fst (iterate SSQLtf (siâ1, sâ1))) 
	= hide (c, Fst (SSQLtf (last', Fst (iterate SSQLtf (siâ1, sâ1))))))	
	± ≥(c dominates Fst
                         (Snd (SSQLtf (last', Fst (iterate SSQLtf (siâ1, sâ1))))))Æ 
	THEN_LIST[list_asm_ante_tac (map get_asm[3,7])THEN prove_tac[],
		asm_rewrite_tac[]]);
a(DROP_NTH_ASM_T 7 (ante_tac o list_µ_elim[¨siâ2 Î [last]Æ,¨cÆ,¨sâ1Æ,¨sâ2Æ]));
a(asm_rewrite_tac[iterate_def]);
=TEX
=GFT HOL output
(* *** Goal "2.2.3" *** *)

(*  8 *)  ¨µ sâ1 sâ2 iâ1 iâ2 c
           ∑ hide (c, sâ1) = hide (c, sâ2) ± ([iâ1], [iâ2]) ç same_ins c
               ¥ hide (c, Fst (SSQLtf (iâ1, sâ1))) = hide (c, Fst (SSQLtf (iâ2, sâ2)))
                 ± ([Snd (SSQLtf (iâ1, sâ1))], [Snd (SSQLtf (iâ2, sâ2))]) ç same_outs cÆ
.
.
.
(*  4 *)  ¨≥ c dominates Snd lastÆ
(*  3 *)  ¨c dominates Snd last'Æ
(*  2 *)  ¨hide (c, sâ1) = hide (c, sâ2)Æ
(*  1 *)  ¨(siâ1 ˘ {(q, c')|c dominates c'}) Î [last'] = siâ2 ˘ {(q, c')|c dominates c'}Æ


(* ?Ù *)  ¨hide(c,Fst(SSQLtf(last', Fst (iterate SSQLtf (siâ1, sâ1)))))
            = hide(c,Fst(SSQLtf(last, Fst (iterate SSQLtf (siâ2, sâ2)))))
             ± (if c dominates Fst(Snd(SSQLtf(last',Fst(iterate SSQLtf (siâ1, sâ1)))))
                 then
                   (Snd (iterate SSQLtf (siâ1, sâ1)) ˘ {(c', d)|c dominates c'})
                     Î [Snd(SSQLtf
                             (last', Fst (iterate SSQLtf (siâ1, sâ1))))]
                 else
                   Snd (iterate SSQLtf (siâ1, sâ1)) ˘ {(c', d)|c dominates c'})
               = (if c dominates Fst(Snd(SSQLtf(last, Fst (iterate SSQLtf (siâ2, sâ2)))))
                 then
                   (Snd (iterate SSQLtf (siâ2, sâ2)) ˘ {(c', d)|c dominates c'})
                     Î [Snd(SSQLtf(last, Fst (iterate SSQLtf (siâ2, sâ2))))]
                 else
                   Snd (iterate SSQLtf (siâ2, sâ2)) ˘ {(c', d)|c dominates c'})Æ
=TEX


=SML
a(lemma_tac¨(hide (c, Fst (iterate SSQLtf (siâ2, sâ2))) 
	= hide (c, Fst (SSQLtf (last, Fst (iterate SSQLtf (siâ2, sâ2))))))	
	± ≥(c dominates Fst
                         (Snd (SSQLtf (last, Fst (iterate SSQLtf (siâ2, sâ2))))))Æ 
	THEN_LIST[list_asm_ante_tac (map get_asm[4,7])THEN prove_tac[],
		asm_rewrite_tac[]]);
a(DROP_NTH_ASM_T 8 ante_tac THEN DROP_NTH_ASM_T 7 rewrite_thm_tac);
a(¥_T (ante_tac o list_µ_elim[¨last'Æ,¨cÆ,¨sâ1Æ,¨sâ2Æ]));
a(asm_rewrite_tac[]);
=TEX
=GFT HOL output
(* *** Goal "2.2.4" *** *)

(*  8 *)  ¨µ sâ1 sâ2 iâ1 iâ2 c
           ∑ hide (c, sâ1) = hide (c, sâ2) ± ([iâ1], [iâ2]) ç same_ins c
               ¥ hide (c, Fst (SSQLtf (iâ1, sâ1))) = hide (c, Fst (SSQLtf (iâ2, sâ2)))
                 ± ([Snd (SSQLtf (iâ1, sâ1))], [Snd (SSQLtf (iâ2, sâ2))]) ç same_outs cÆ
.
.
.
(*  4 *)  ¨≥ c dominates Snd lastÆ
(*  3 *)  ¨≥ c dominates Snd last'Æ
(*  2 *)  ¨hide (c, sâ1) = hide (c, sâ2)Æ
(*  1 *)  ¨siâ1 ˘ {(q, c')|c dominates c'} = siâ2 ˘ {(q, c')|c dominates c'}Æ


(* ?Ù *)  ¨hide(c,Fst(SSQLtf(last', Fst (iterate SSQLtf (siâ1, sâ1)))))
            = hide(c,Fst(SSQLtf(last, Fst (iterate SSQLtf (siâ2, sâ2)))))
             ± (if c dominates Fst(Snd(SSQLtf(last',Fst(iterate SSQLtf (siâ1, sâ1)))))
                 then (Snd (iterate SSQLtf (siâ1, sâ1)) ˘ {(c', d)|c dominates c'})
                     Î [Snd(SSQLtf(last', Fst (iterate SSQLtf (siâ1, sâ1))))]
                 else  Snd (iterate SSQLtf (siâ1, sâ1)) ˘ {(c', d)|c dominates c'})
               = (if c dominates Fst(Snd(SSQLtf(last, Fst (iterate SSQLtf (siâ2, sâ2)))))
                 then (Snd (iterate SSQLtf (siâ2, sâ2)) ˘ {(c', d)|c dominates c'})
                     Î [Snd(SSQLtf(last, Fst (iterate SSQLtf (siâ2, sâ2))))]
                 else Snd (iterate SSQLtf (siâ2, sâ2)) ˘ {(c', d)|c dominates c'})Æ
=TEX

=SML
a(lemma_tac ¨(hide (c, Fst (iterate SSQLtf (siâ1, sâ1))) 
	= hide (c, Fst (SSQLtf (last', Fst (iterate SSQLtf (siâ1, sâ1))))))	
	± ≥(c dominates Fst
                         (Snd (SSQLtf (last', Fst (iterate SSQLtf (siâ1, sâ1))))))
	± (hide (c, Fst (iterate SSQLtf (siâ2, sâ2))) 
	= hide (c, Fst (SSQLtf (last, Fst (iterate SSQLtf (siâ2, sâ2))))))	
	± ≥(c dominates Fst
                         (Snd (SSQLtf (last, Fst (iterate SSQLtf (siâ2, sâ2))))))Æ
	THEN_LIST[list_asm_ante_tac (map get_asm[3,4,7])THEN prove_tac[],
		asm_rewrite_tac[]]);
a(DROP_NTH_ASM_T 2 (rewrite_thm_tac o eq_sym_rule));
a(DROP_NTH_ASM_T 3 (rewrite_thm_tac o eq_sym_rule));
a(list_asm_ante_tac (map get_asm[3,4,7])THEN prove_tac[]);
val lemma4_thm = save_pop_thm"Lemma4";
=TEX

\section{PROOF OF $Lemma5$}

=SML
push_goal([],¨Lemma5Æ);
a(rewrite_tac[Lemma5,secureItf_def,behaviours_def,SSQLam_def,
	secure_def,eq_sym_rule SSQLtf_def]);
a(REPEAT strip_tac);
a(list_spec_nth_asm_tac 2 [¨isstateÆ,¨isstateÆ,¨si1Æ,¨si2Æ,¨clearÆ]);
val lemma5_thm = save_pop_thm"Lemma5";
=TEX
\section{REMAINING PROOF}
Taking the main theorem to be proven, from the proof strategy document,\cite{DS/FMU/FEF/007},
we can simplify the result using the proofs of $Lemma3$, $Lemma4$ and $Lemma5$.
=SML
val €main_thm1› = save_thm("main_thm1",
	rewrite_rule[lemma3_thm,lemma4_thm,lemma5_thm]main_thm);
=TEX
=GFT HOL output
main_thm1 = Ù  Lemma1 ¥ behaviours SSQLam ç secure
=TEX

where $Lemma1$, from the proof strategy document \cite{DS/FMU/FEF/007}, is:

=GFT
	?Ù 	hide ç secureHide ± (hide,updateState) ç secureUpdate 
=TEX

\section{CLOSING DOWN}
The following ICL HOL instruction restores the previous proof context.
=SML
pop_pc();
=TEX

\newpage
\input{fef009th.tex}
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}
