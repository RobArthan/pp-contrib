=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Proof of Security (IIa)}  %% Mandatory field
\TPPref{DS/FMU/FEF/010}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document provides a formal proof for the security property
on $hide$ for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion(\FormatDate{$Date$
})] Changes made due to new type $State$, see DS/FMU/FEF/004. 
Library results moved to DS/FMU/FEF/LIB1.

\end{description}

\subsection{Changes Forecast}
Changes  may be necessary  as a result of issues raised
during  the transcription of the specification.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document provides a formal proof  that the component $hide$ satisfies its critical 
requirement, as specified in 
the proof strategy \cite{DS/FMU/FEF/007}. It constitutes part of deliverable D5 
of work package 1a, as given
in section 7 of the Secure Database Technical Proposal, \cite{DS/FMU/017}.

\subsection{Introduction}

This document is a proof script which provides a formal proof of  the first conjunct
of $Lemma1$,
the requirement on the critical components  $hide$ and $updateState$, described in the proof strategy document \cite{DS/FMU/FEF/007}.

{\bf Lemma1}
=GFT
	?Ù 	hide ç secureHide ± (hide,updateState) ç secureUpdate
=TEX

In this document, we give a proof of
=GFT

	?Ù 	hide ç secureHide
=TEX

First, we define a property $secureHideR$ on the representation type, and then prove

=GFT

	?Ù 	hideR ç secureHideR
=TEX

We then prove that $hideR$ maintains the state invariant. From these two results, we prove
that hide is secure.

\section{PRELIMINARIES}
The following ICL HOL instructions set up the new theory $fef010$.

=SML 
open_theory "fef009";
new_theory€"fef010"›;
push_merge_pcs["hol","fefhol","'pair1"] ;
=TEX
\section{SETTING UP FOR THE SECURITY PROOF}
\subsection{Consistency Proof for $dominates$}
We prove the consistency of $dominates$ and retrieve the definiton of $dominates$ with
the consistency obligation satisfied.
=SML
push_consistency_goal¨$dominatesÆ;
a(∂_tac¨$=Æ);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
save_consistency_thm¨$dominatesÆ(top_thm());
val €dominates_def› = get_spec¨$dominatesÆ;
=TEX
A theorem which just states the transitivity property of $dominates$.
=SML
val €dominates_trans› = prove_rule[dominates_def]
	¨µ x y z ∑x dominates y ± y dominates z ¥ x dominates zÆ;
=TEX
=GFT
dominates_trans = Ù µ x y z∑ x dominates y ± y dominates z ¥ x dominates z 
=TEX
\subsection{Consistency Proof for $repState$ and $absState$}
We prove the consistency of $repState$ and $absState$ and retrieve their definitons  with
the consistency obligation satisfied.
=SML
push_consistency_goal¨repStateÆ;
a(strip_asm_tac (simple_¥_match_mp_rule type_lemmas_thm state_type_def));
a(∂_tac¨(rep,abs)Æ THEN asm_rewrite_tac[]);
a ±_tac;
=TEX
=SML
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(POP_ASM_T (ante_tac o app_fun_rule¨absÆ) THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(REPEAT µ_tac THEN ¥_tac);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(POP_ASM_T (ante_tac o app_fun_rule¨repÆ) THEN asm_rewrite_tac[]);
save_consistency_thm¨repStateÆ(top_thm());
val €repState_absState_def› = get_spec¨repStateÆ;
=TEX
\subsection{Retrieving the Remaining Definitions of Constants}
=SML
val €hide_def› = get_spec¨hideÆ;
val €hideR_def› = get_spec¨hideRÆ;
val €secureHide_def› = get_spec¨secureHideÆ;
val €cleanDirectory_def› = get_spec¨cleanDirectoryÆ;
val €cleanTable_def› = conv_rule(MAP_C let_conv)(get_spec¨cleanTableÆ);
val €cleanColCons_def› = conv_rule(MAP_C let_conv)(get_spec¨cleanColConsÆ);
val €stubTable_def› = get_spec¨stubTableÆ;
val €cleanRows_def› = get_spec¨cleanRowsÆ;
val €cleanRow_def› = get_spec¨cleanRowÆ;
val €replaceData_def› = get_spec¨replaceDataÆ;
val €filterRow_def› = get_spec¨filterRowÆ;
=TEX

\subsection{Components of Labelled Products}
These theorems state that if two things of labelled product type are equal, then their components 
must be equal.
\subsubsection{Type $Directory$}
=SML
push_goal([],¨µ dirâ1 dirâ2 ∑
	dirâ1 = dirâ2 § 
	Dir_tables dirâ1 = Dir_tables dirâ2
±	Dir_exist dirâ1 = Dir_exist dirâ2
±	Dir_class dirâ1 = Dir_class dirâ2Æ);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(lemma_tac¨(dirâ1 = MkDirectory (Dir_tables dirâ1) (Dir_exist dirâ1) (Dir_class dirâ1))
	± (dirâ2 = MkDirectory (Dir_tables dirâ2) (Dir_exist dirâ2) (Dir_class dirâ2))Æ);
(* *** Goal "1" *** *)
a(rewrite_tac[get_spec¨MkDirectoryÆ]);
(* *** Goal "2" *** *)
a(POP_ASM_T once_rewrite_thm_tac); 
a(POP_ASM_T once_rewrite_thm_tac); 
a(asm_rewrite_tac[]);
val €dir_components› = save_pop_thm"dir_components";
=TEX
=GFT
dir_components =
Ù µ dirâ1 dirâ2
  ∑ dirâ1 = dirâ2
      § Dir_tables dirâ1 = Dir_tables dirâ2
        ± Dir_exist dirâ1 = Dir_exist dirâ2
        ± Dir_class dirâ1 = Dir_class dirâ2 
=TEX
\subsubsection{Type $TableSpec$}

=SML
push_goal([],¨µ tâ1 tâ2 ∑
	tâ1 = tâ2 § 
	TS_class tâ1 = TS_class tâ2
±	TS_maxRow tâ1 = TS_maxRow tâ2
±	TS_colspecs tâ1 = TS_colspecs tâ2
±	TS_cons tâ1 = TS_cons tâ2
±	TS_rows tâ1 = TS_rows tâ2Æ);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(lemma_tac¨(tâ1 = MkTableSpec(TS_class tâ1) (TS_maxRow tâ1) (TS_colspecs tâ1)
	(TS_cons tâ1)(TS_rows tâ1))
	± (tâ2 = MkTableSpec(TS_class tâ2) (TS_maxRow tâ2) (TS_colspecs tâ2)
	(TS_cons tâ2)(TS_rows tâ2))Æ);
(* *** Goal "1" *** *)
a(rewrite_tac[get_spec¨MkTableSpecÆ]);
(* *** Goal "2" *** *)
a(POP_ASM_T once_rewrite_thm_tac); 
a(POP_ASM_T once_rewrite_thm_tac); 
a(asm_rewrite_tac[]);
val €tab_components› = save_pop_thm"tab_components";
=TEX
=GFT
tab_components = 
Ù µ tâ1 tâ2
  ∑ tâ1 = tâ2
      § TS_class tâ1 = TS_class tâ2
        ± TS_maxRow tâ1 = TS_maxRow tâ2
        ± TS_colspecs tâ1 = TS_colspecs tâ2
        ± TS_cons tâ1 = TS_cons tâ2
        ± TS_rows tâ1 = TS_rows tâ2
=TEX
\subsubsection{Type $Row$}

=SML
push_goal([],¨µ râ1 râ2 ∑
	râ1 = râ2 § 
	R_exist râ1 = R_exist râ2
±	R_data râ1 = R_data râ2Æ);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(lemma_tac¨(râ1 = MkRow(R_exist râ1) (R_data râ1))
	± (râ2 = MkRow(R_exist râ2) (R_data râ2))Æ);
(* *** Goal "1" *** *)
a(rewrite_tac[get_spec¨MkRowÆ]);
(* *** Goal "2" *** *)
a(POP_ASM_T once_rewrite_thm_tac); 
a(POP_ASM_T once_rewrite_thm_tac); 
a(asm_rewrite_tac[]);
val €row_components› = save_pop_thm"row_components";
=TEX
=GFT
row_components = 
Ù µ râ1 râ2
  ∑ râ1 = râ2 § R_exist râ1 = R_exist râ2 ± R_data râ1 = R_data râ2
=TEX
\subsubsection{Type $Data$}

=SML
push_goal([],¨µ dâ1 dâ2 ∑
	dâ1 = dâ2 § 
	Dat_class dâ1 = Dat_class dâ2
±	Dat_item dâ1 = Dat_item dâ2Æ);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(lemma_tac¨(dâ1 = MkData(Dat_class dâ1) (Dat_item dâ1))
	± (dâ2 = MkData(Dat_class dâ2) (Dat_item dâ2))Æ);
(* *** Goal "1" *** *)
a(rewrite_tac[get_spec¨MkDataÆ]);
(* *** Goal "2" *** *)
a(POP_ASM_T once_rewrite_thm_tac); 
a(POP_ASM_T once_rewrite_thm_tac); 
a(asm_rewrite_tac[]);
val €data_components› = save_pop_thm"data_components";
=TEX
=GFT
val data_components = 
Ù µ dâ1 dâ2
  ∑ dâ1 = dâ2 § Dat_class dâ1 = Dat_class dâ2 ± Dat_item dâ1 = Dat_item dâ2 
=TEX
\section{PROOF OF SECURITY OF $hide$} 
\subsection{Proof Strategy}\label{STRATEGY}

First we define $secureHideR$ a property on things of type 
=INLINEFT
Class ∏ StateR ≠ StateR
=TEX

πHOLCONST
‹	€secureHideR› : (Class ∏ StateR ≠ StateR) 
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ h : Class ∏ StateR ≠ StateR ∑ 
‹		h ç secureHideR
‹		§
‹		µcâ1 câ2 : Class; sâ1 sâ2 : StateR ∑	
‹			h(câ1,sâ1) = h(câ1,sâ2)
‹			±
‹			câ1 dominates câ2	
‹			¥
‹			h(câ2,sâ1) = h(câ2,sâ2)
∞

We simplify some of the properties of the representation and abstraction functions.
=SML
val isState_lemma = all_µ_intro(nth 4 (strip_±_rule(all_µ_elim repState_absState_def)));
=TEX

=GFT
isState_lemma = Ù µ s∑ isState (repState s)
=TEX

=SML
val isState_lemma1 = all_µ_intro(nth 1 (strip_±_rule(all_µ_elim repState_absState_def)));
=TEX

=GFT
isState_lemma1 = Ù isState r ¥ repState (absState r) = r
=TEX

=SML
val isState_lemma2 = all_µ_intro(nth 3 (strip_±_rule(all_µ_elim repState_absState_def)));
=TEX

=GFT
isState_lemma2 =  
Ù µ râ1 râ2
  ∑ isState râ1 ± isState râ2 ¥ (absState râ1 = absState râ2 § râ1 = râ2)
=TEX


Next, we prove that if $hideR$ is a member of $secureHideR$ and $hideR$ maintains the invariant
on the representation state, then $hide$ is a member of $secureHide$.
=SML
push_goal([],¨(hideR ç secureHideR ± µ clear s ∑ isState s ¥ isState(hideR(clear,s))) 
	¥ hide ç secureHideÆ);
a(rewrite_tac[secureHide_def,hide_def,get_spec¨secureHideRÆ] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (ante_tac o list_µ_elim[¨câ1Æ,¨câ2Æ,¨repState sâ1Æ,¨repState sâ2Æ]));
a(asm_rewrite_tac[] THEN ¥_T asm_tac);
a(GET_NTH_ASM_T 4 (asm_tac o rewrite_rule[isState_lemma] o 
	list_µ_elim[¨câ1Æ,¨repState sâ1Æ]));
a(GET_NTH_ASM_T 5 (asm_tac o rewrite_rule[isState_lemma] o 
	list_µ_elim[¨câ1Æ,¨repState sâ2Æ]));
a(strip_asm_tac (list_µ_elim[¨hideR (câ1, repState sâ1)Æ,¨hideR (câ1, repState sâ2)Æ]
	isState_lemma2));
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[] THEN ¥_tac);
a(GET_NTH_ASM_T 7 (asm_tac o rewrite_rule[isState_lemma] o 
	list_µ_elim[¨câ2Æ,¨repState sâ1Æ]));
a(GET_NTH_ASM_T 8 (asm_tac o rewrite_rule[isState_lemma] o 
	list_µ_elim[¨câ2Æ,¨repState sâ2Æ]));
a(strip_asm_tac (list_µ_elim[¨hideR (câ2, repState sâ1)Æ,¨hideR (câ2, repState sâ2)Æ]
	isState_lemma2));
val hideR_hide_lemma = save_pop_thm"hideR_hide_lemma";
=TEX

=GFT
hideR_hide_lemma =
Ù hideR ç secureHideR
      ± (µ clear s∑ isState s ¥ isState (hideR (clear, s)))
    ¥ hide ç secureHide  
=TEX

\subsection{Proof of Security of $hideR$} \label{HIDER}


The proof is broken down into a series of lemmas.

\subsubsection{$replaceData$ Lemma}

=SML
push_goal([],¨µ câ1 câ2 ∑ câ1 dominates câ2
	¥ µ dâ1 dâ2 ∑
		replaceData câ1 dâ1 = replaceData câ1 dâ2
		¥ 
		replaceData câ2 dâ1 = replaceData câ2 dâ2Æ);
a(REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN rewrite_tac[replaceData_def]);
a(cases_tac¨câ2 dominates Dat_class dâ1Æ THEN cases_tac¨câ2 dominates Dat_class dâ2Æ
	THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(lemma_tac¨(câ1 dominates Dat_class dâ1) ± (câ1 dominates Dat_class dâ2)Æ
	THEN_LIST[basic_res_tac2 3[dominates_trans],asm_rewrite_tac[]]);
=TEX
=SML
(* *** Goal "2" *** *)
a(lemma_tac¨câ1 dominates Dat_class dâ1Æ THEN_LIST
	[contr_tac THEN basic_res_tac4 2 [1][3,4][][dominates_trans],asm_rewrite_tac[]]);
a(cases_tac¨câ1 dominates Dat_class dâ2Æ THEN asm_rewrite_tac[]);
a ¥_tac;
a(DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨câ1 dominates Dat_class dâ2Æ THEN_LIST
[contr_tac THEN basic_res_tac4 2 [1][2,4][][dominates_trans],asm_rewrite_tac[]]);
a(cases_tac¨câ1 dominates Dat_class dâ1Æ THEN asm_rewrite_tac[]);
a ¥_tac;
a(DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "4" *** *)
a(cases_tac¨câ1 dominates Dat_class dâ1Æ THEN cases_tac¨câ1 dominates Dat_class dâ2Æ
	THEN asm_rewrite_tac[]);
(* *** Goal "4.1" *** *)
a ¥_tac;
a(DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "4.2" *** *)
a(¥_T(strip_asm_tac o rewrite_rule[data_components,get_spec¨MkDataÆ])); ;
a(asm_rewrite_tac[]);
(* *** Goal "4.3" *** *)
a(¥_T(strip_asm_tac o rewrite_rule[data_components,get_spec¨MkDataÆ])); ;
a(asm_rewrite_tac[]);
val €replaceData_lemma› = save_pop_thm"replaceData_lemma";
=TEX
=GFT
replaceData_lemma = 
Ù µ câ1 câ2
  ∑ câ1 dominates câ2
      ¥ (µ dâ1 dâ2
      ∑ replaceData câ1 dâ1 = replaceData câ1 dâ2
          ¥ replaceData câ2 dâ1 = replaceData câ2 dâ2)
=TEX
\subsubsection{$cleanColCons$ Lemma}
=SML
push_goal([],¨µ câ1 câ2 tâ1 tâ2 ∑
	(câ1 dominates câ2
	± cleanColCons câ1 tâ1 = cleanColCons câ1 tâ2)
	¥ cleanColCons câ2 tâ1 = cleanColCons câ2 tâ2Æ);
a(REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN rewrite_tac[cleanColCons_def,í_def,dom_def]);
a(PC_T "hol1"(REPEAT strip_tac));
(* *** Goal "1" *** *)
a(lemma_tac ¨câ1 dominates  CC_exist (Snd x)Æ);
(* *** Goal "1.1" *** *)
a(ante_tac(list_µ_elim[¨câ1Æ,¨câ2Æ,¨CC_exist (Snd x)Æ]dominates_def) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(PC_T"hol1"(DROP_NTH_ASM_T 5 (strip_asm_tac o µ_elim¨xÆ)));
=TEX
=SML
(* *** Goal "2" *** *)
a(lemma_tac ¨câ1 dominates  CC_exist (Snd x)Æ);
(* *** Goal "2.1" *** *)
a(ante_tac(list_µ_elim[¨câ1Æ,¨câ2Æ,¨CC_exist (Snd x)Æ]dominates_def) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(PC_T"hol1"(DROP_NTH_ASM_T 5 (strip_asm_tac o µ_elim¨xÆ)));
(* *** Goal "3" *** *)
a(∂_tac¨yÆ THEN asm_rewrite_tac[]);
a(lemma_tac ¨câ1 dominates  CC_exist yÆ);
(* *** Goal "3.1" *** *)
a(ante_tac(list_µ_elim[¨câ1Æ,¨câ2Æ,¨CC_exist yÆ]dominates_def) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "3.2" *** *)
a(PC_T"hol1"(DROP_NTH_ASM_T 5 (strip_asm_tac o µ_elim¨(CS_consGroup x, y)Æ)));
=TEX
=SML
(* *** Goal "4" *** *)
a(∂_tac¨yÆ THEN asm_rewrite_tac[]);
a(lemma_tac ¨câ1 dominates  CC_exist yÆ);
(* *** Goal "4.1" *** *)
a(ante_tac(list_µ_elim[¨câ1Æ,¨câ2Æ,¨CC_exist yÆ]dominates_def) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "4.2" *** *)
a(PC_T"hol1"(DROP_NTH_ASM_T 5 (strip_asm_tac o µ_elim¨(CS_consGroup x, y)Æ)));
val €cleanColCons_lemma› = save_pop_thm"cleanColCons_lemma";
=TEX
=GFT
cleanColCons_lemma =
Ù µ câ1 câ2 tâ1 tâ2
  ∑ câ1 dominates câ2 ± cleanColCons câ1 tâ1 = cleanColCons câ1 tâ2
      ¥ cleanColCons câ2 tâ1 = cleanColCons câ2 tâ2
=TEX
\subsubsection{$cleanRow$ Lemma}
First, two results about $cleanColCons$.
=SML
push_goal([],¨µ câ1 câ2 t∑ câ1 dominates câ2
	¥ (Fst(cleanColCons câ2 t) Ä Fst(cleanColCons câ1 t)
	± Snd(cleanColCons câ2 t) Ä Snd(cleanColCons câ1 t))Æ);
a(rewrite_tac[rel_ext_clauses,sets_ext_clauses,cleanColCons_def,í_thm,dom_def]
	 THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(contr_tac THEN basic_res_tac4 2 [1][3,4][][dominates_trans]);
(* *** Goal "2" *** *)
a(∂_tac¨yÆTHEN asm_rewrite_tac[]);
a(contr_tac THEN basic_res_tac4 2 [1][3,4][][dominates_trans]);
val €Ä_cleanColCons_lemma› = save_pop_thm"Ä_cleanColCons_lemma";
=TEX
=GFT
Ä_cleanColCons_lemma =
Ù µ câ1 câ2 t
  ∑ câ1 dominates câ2
      ¥ Fst (cleanColCons câ2 t) Ä Fst (cleanColCons câ1 t)
        ± Snd (cleanColCons câ2 t) Ä Snd (cleanColCons câ1 t)
=TEX
=SML
push_goal([],¨µ câ1 câ2 t col ∑ câ1 dominates câ2
	¥ (col ç Snd(cleanColCons câ2 t) ¥ col ç Snd(cleanColCons câ1 t))Æ);
a(REPEAT strip_tac);
a(basic_res_tac 2 [rewrite_rule[sets_ext_clauses]Ä_cleanColCons_lemma]);
val €Ä_cleanColCons_lemma1› = save_pop_thm"Ä_cleanColCons_lemma1";
=TEX
=GFT
Ä_cleanColCons_lemma1 = 
Ù µ câ1 câ2 t col
  ∑ câ1 dominates câ2
      ¥ col ç Snd (cleanColCons câ2 t)
      ¥ col ç Snd (cleanColCons câ1 t)
=TEX
The main result about $CleanRow$.
=SML
push_goal([],¨µ câ1 câ2  ∑ câ1 dominates câ2
	¥ µ tâ1 tâ2 râ1 râ2 ∑
		(cleanColCons câ1 tâ1 = cleanColCons câ1 tâ2
		± cleanColCons câ2 tâ1 = cleanColCons câ2 tâ2
		± cleanRow câ1 (Snd (cleanColCons câ1 tâ1)) râ1
              		= cleanRow câ1 (Snd (cleanColCons câ1 tâ2)) râ2)
		¥ 
		cleanRow câ2 (Snd (cleanColCons câ2 tâ1)) râ1
                 = cleanRow câ2 (Snd (cleanColCons câ2 tâ2)) râ2Æ);
a(REPEAT µ_tac THEN strip_tac);
a(strip_asm_tac (list_µ_elim[¨câ1Æ,¨câ2Æ]replaceData_lemma));
a(rewrite_tac[cleanRow_def,row_components,get_spec¨MkRowÆ,filterRow_def,
	rel_ext_clauses,Ú_thm,r_ª_r_thm,graph_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac (list_µ_elim[¨câ1Æ,¨câ2Æ,¨tâ1Æ,¨cÆ]Ä_cleanColCons_lemma1));
a(DROP_NTH_ASM_T 6 (asm_tac o list_µ_elim[¨xÆ,¨replaceData câ1 zÆ]));
a(LEMMA_T¨∂ z'
             ∑ ((∂ c∑ c ç Snd (cleanColCons câ1 tâ1) ± CS_posn c = x)
                   ± (x, z') ç R_data râ1)
                 ± replaceData câ1 z = replaceData câ1 z'Æasm_tac);
(* *** Goal "1.1" *** *)
a(∂_tac¨zÆ THEN asm_prove_tac[]);
=TEX
=SML
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN POP_ASM_T rewrite_thm_tac);
a ¥_tac;
a(DROP_NTH_ASM_T 13(strip_asm_tac o list_µ_elim[¨zÆ,¨z'Æ]));
a(∂_tac¨z'Æ THEN asm_rewrite_tac[]);
a(∂_tac¨cÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 10 ante_tac THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "2" *** *)
a(strip_asm_tac (list_µ_elim[¨câ1Æ,¨câ2Æ,¨tâ2Æ,¨cÆ]Ä_cleanColCons_lemma1));
a(DROP_NTH_ASM_T 6 (asm_tac o list_µ_elim[¨xÆ,¨replaceData câ1 zÆ]));
a(LEMMA_T¨∂ z'
             ∑ ((∂ c∑ c ç Snd (cleanColCons câ1 tâ2) ± CS_posn c = x)
                   ± (x, z') ç R_data râ2)
                 ± replaceData câ1 z = replaceData câ1 z'Æasm_tac);
(* *** Goal "2.1" *** *)
a(∂_tac¨zÆ THEN asm_prove_tac[]);
=TEX
=SML
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN POP_ASM_T rewrite_thm_tac);
a ¥_tac;
a(DROP_NTH_ASM_T 13(strip_asm_tac o list_µ_elim[¨zÆ,¨z'Æ]));
a(∂_tac¨z'Æ THEN asm_rewrite_tac[]);
a(∂_tac¨cÆ THEN asm_rewrite_tac[]);
val €cleanRow_lemma› = save_pop_thm"cleanRow_lemma";
=TEX
=GFT
cleanRow_lemma = 
Ù µ câ1 câ2
  ∑ câ1 dominates câ2
      ¥ (µ tâ1 tâ2 râ1 râ2
      ∑ cleanColCons câ1 tâ1 = cleanColCons câ1 tâ2
            ± cleanColCons câ2 tâ1 = cleanColCons câ2 tâ2
            ± cleanRow câ1 (Snd (cleanColCons câ1 tâ1)) râ1
              = cleanRow câ1 (Snd (cleanColCons câ1 tâ2)) râ2
          ¥ cleanRow câ2 (Snd (cleanColCons câ2 tâ1)) râ1
            = cleanRow câ2 (Snd (cleanColCons câ2 tâ2)) râ2) 
=TEX


\subsubsection{$cleanTable$ Lemma}
=SML
push_goal([],¨µ câ1 câ2 ∑ câ1 dominates câ2 ¥ µ tâ1 tâ2 ∑ 
	cleanTable câ1 tâ1 = cleanTable câ1 tâ2 ¥ cleanTable câ2 tâ1 = cleanTable câ2 tâ2Æ);
a(rewrite_tac[cleanTable_def] THEN REPEAT µ_tac THEN strip_tac THEN REPEAT µ_tac);
a(cases_tac¨câ2 dominates TS_class tâ1Æ THEN cases_tac ¨câ2 dominates TS_class tâ2Æ
	 THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "1" *** *)
a(lemma_tac¨câ1 dominates TS_class tâ1Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,4][][dominates_trans],asm_rewrite_tac[]]);
a(lemma_tac¨câ1 dominates TS_class tâ2Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,5][][dominates_trans],asm_rewrite_tac[]]);
a(rewrite_tac[tab_components,get_spec¨MkTableSpecÆ]);
a(strip_tac THEN asm_rewrite_tac[]);
a(strip_asm_tac (list_µ_elim[¨cleanColCons câ1 tâ1Æ,¨cleanColCons câ1 tâ2Æ]pair_eq_thm));
a(rewrite_tac[taut_rule¨µ a b c∑(a ± (b ± c)) = ((b ± a) ± c)Æ,pair_eq_thm]);
a(DROP_NTH_ASM_T 4 (fn _ => id_tac)
	THEN DROP_NTH_ASM_T 3 (fn _ => id_tac));
a(strip_asm_tac(list_µ_elim[¨câ1Æ,¨câ2Æ,¨tâ1Æ,¨tâ2Æ]cleanColCons_lemma));
a(±_tac THEN_LIST[asm_rewrite_tac[],id_tac]);
=TEX
=SML
a(DROP_NTH_ASM_T 3 ante_tac);
a(lemma_tac¨∂ l ∑ TS_rows tâ1 = lÆTHEN_LIST
	[prove_∂_tac,POP_ASM_T rewrite_thm_tac]);
a(lemma_tac¨∂ l1 ∑ TS_rows tâ2 = l1ÆTHEN_LIST
	[prove_∂_tac,POP_ASM_T rewrite_thm_tac]);
a(intro_µ_tac(¨l1Æ,¨l':Row LISTÆ));
a(rewrite_tac[cleanRows_def]);
a(LIST_INDUCTION_T¨lÆasm_tac);
(* *** Goal "1.1" *** *)
a(rewrite_tac[map_def,map_null_thm]);
a µ_tac;
a(LIST_INDUCTION_T¨l'Æasm_tac);
=TEX
=SML
(* *** Goal "1.1.1" *** *)
a(rewrite_tac[˘_def]);
(* *** Goal "1.1.2" *** *)
a(rewrite_tac[˘_def]);
a strip_tac;
a(cases_tac¨câ2 dominates R_exist xÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.1.2.1" *** *)
a(lemma_tac¨câ1 dominates R_exist xÆ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][2,11][][dominates_trans],asm_rewrite_tac[]]);
(* *** Goal "1.1.2.2" *** *)
a(cases_tac¨câ1 dominates R_exist xÆ THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "1.2" *** *)
a(rewrite_tac[µ_reorder_conv¨µ l' x 
           ∑ Map
                   (cleanRow câ1 (Snd (cleanColCons câ1 tâ1)))
                   (Cons x l ˘ {r|câ1 dominates R_exist r})
                 = Map
                   (cleanRow câ1 (Snd (cleanColCons câ1 tâ2)))
                   (l' ˘ {r|câ1 dominates R_exist r})
               ¥ Map
                   (cleanRow câ2 (Snd (cleanColCons câ2 tâ1)))
                   (Cons x l ˘ {r|câ2 dominates R_exist r})
                 = Map
                   (cleanRow câ2 (Snd (cleanColCons câ2 tâ2)))
                   (l' ˘ {r|câ2 dominates R_exist r})Æ¨µ x l'
           ∑ Map
                   (cleanRow câ1 (Snd (cleanColCons câ1 tâ1)))
                   (Cons x l ˘ {r|câ1 dominates R_exist r})
                 = Map
                   (cleanRow câ1 (Snd (cleanColCons câ1 tâ2)))
                   (l' ˘ {r|câ1 dominates R_exist r})
               ¥ Map
                   (cleanRow câ2 (Snd (cleanColCons câ2 tâ1)))
                   (Cons x l ˘ {r|câ2 dominates R_exist r})
                 = Map
                   (cleanRow câ2 (Snd (cleanColCons câ2 tâ2)))
                   (l' ˘ {r|câ2 dominates R_exist r})Æ]);
=TEX
=SML
a µ_tac;
a(LIST_INDUCTION_T¨l'Æasm_tac);
(* *** Goal "1.2.1" *** *)
a(rewrite_tac[˘_def] THEN µ_tac);
a(cases_tac¨câ2 dominates R_exist xÆ THEN TOP_ASM_T rewrite_thm_tac);
(* *** Goal "1.2.1.1" *** *)
a(lemma_tac¨câ1 dominates R_exist xÆ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][2,4][][dominates_trans],
	TOP_ASM_T rewrite_thm_tac]);
a(rewrite_tac[map_def]);
(* *** Goal "1.2.1.2" *** *)
a(cases_tac¨câ1 dominates R_exist xÆ THEN TOP_ASM_T rewrite_thm_tac);
(* *** Goal "1.2.1.2.1" *** *)
a(rewrite_tac[map_def]);
(* *** Goal "1.2.1.2.2" *** *)
a(DROP_NTH_ASM_T 3(ante_tac o µ_elim¨[]:Row LISTÆ));
a(rewrite_tac[map_def]);
=TEX
=SML
(* *** Goal "1.2.2" *** *)
a(rewrite_tac[˘_def]);
a(REPEAT µ_tac);
a(cases_tac¨câ2 dominates R_exist xÆ 
	THEN TOP_ASM_T rewrite_thm_tac THEN cases_tac¨câ2 dominates R_exist x'Æ 
	THEN TOP_ASM_T rewrite_thm_tac);
(* *** Goal "1.2.2.1" *** *)
a(lemma_tac¨câ1 dominates R_exist xÆ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,14][][dominates_trans],
	TOP_ASM_T rewrite_thm_tac]);
a(lemma_tac¨câ1 dominates R_exist x'Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,14][][dominates_trans],
	TOP_ASM_T rewrite_thm_tac]);
a(rewrite_tac[map_def]);
=TEX
=SML
a(DROP_NTH_ASM_T 6 (asm_tac o µ_elim¨l'Æ));
a(strip_asm_tac(list_µ_elim[¨câ1Æ,¨câ2Æ]cleanRow_lemma));
a(POP_ASM_T (ante_tac o list_µ_elim[¨tâ1Æ,¨tâ2Æ,¨x'Æ,¨xÆ]));
a(asm_rewrite_tac[] THEN ¥_T asm_tac);
a strip_tac;
a(DROP_NTH_ASM_T 4 ante_tac THEN DROP_NTH_ASM_T 3 ante_tac
	THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1.2.2.2" *** *)
a(lemma_tac¨câ1 dominates R_exist xÆ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,14][][dominates_trans],
	TOP_ASM_T rewrite_thm_tac]);
a(cases_tac ¨câ1 dominates R_exist x'ÆTHEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.2.1" *** *)
a(rewrite_tac[map_def] THEN strip_tac);
a(DROP_NTH_ASM_T 2
	(ante_tac o rewrite_rule[cleanRow_def,row_components,get_spec¨MkRowÆ]));
a strip_tac;
a(DROP_NTH_ASM_T 6 ante_tac THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "1.2.2.2.2" *** *)
a(rewrite_tac[map_def] THEN strip_tac);
a(DROP_NTH_ASM_T 7(ante_tac o µ_elim¨Cons x l'Æ));
a(asm_rewrite_tac[map_def,˘_def]);
(* *** Goal "1.2.2.3" *** *)
a(lemma_tac¨câ1 dominates R_exist x'Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][2,14][][dominates_trans],
	TOP_ASM_T rewrite_thm_tac]);
a(cases_tac ¨câ1 dominates R_exist xÆTHEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.3.1" *** *)
a(rewrite_tac[map_def] THEN strip_tac);
a(DROP_NTH_ASM_T 2(ante_tac o 
	rewrite_rule[cleanRow_def,row_components,get_spec¨MkRowÆ]));
a strip_tac;
a(DROP_NTH_ASM_T 6 ante_tac THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "1.2.2.3.2" *** *)
a(rewrite_tac[map_def] THEN strip_tac);
a(DROP_NTH_ASM_T 6(ante_tac o µ_elim¨x'Æ));
a(asm_rewrite_tac[map_def,˘_def]);
(* *** Goal "1.2.2.4" *** *)
a(cases_tac ¨câ1 dominates R_exist xÆTHEN cases_tac ¨câ1 dominates R_exist x'Æ
	THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.4.1" *** *)
a(rewrite_tac[map_def] THEN strip_tac);
a(DROP_NTH_ASM_T 8 (ante_tac o µ_elim¨l'Æ)THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "1.2.2.4.2" *** *)
a(rewrite_tac[map_def] THEN strip_tac);
a(DROP_NTH_ASM_T 7(ante_tac o µ_elim¨Cons x l'Æ));
a(asm_rewrite_tac[map_def,˘_def]);
(* *** Goal "1.2.2.4.3" *** *)
a(rewrite_tac[map_def] THEN strip_tac);
a(DROP_NTH_ASM_T 6(ante_tac o µ_elim¨x'Æ));
a(asm_rewrite_tac[map_def,˘_def]);
(* *** Goal "1.2.2.4.4" *** *)
a(strip_tac THEN  DROP_NTH_ASM_T 7(ante_tac o µ_elim¨l'Æ) THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "2" *** *)
a(lemma_tac¨câ1 dominates TS_class tâ1Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,4][][dominates_trans],asm_rewrite_tac[]]);
a(cases_tac¨câ1 dominates TS_class tâ2ÆTHEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a(rewrite_tac[tab_components,get_spec¨MkTableSpecÆ]);
a strip_tac;
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[tab_components,get_spec¨MkTableSpecÆ,stubTable_def]);
a(strip_tac THEN asm_rewrite_tac[]);
a(rewrite_tac[taut_rule¨µ a b c∑(a ± (b ± c)) = ((b ± a) ± c)Æ]);
a strip_tac;
=TEX
=SML
(* *** Goal "2.2.1" *** *)
a(ante_tac(list_µ_elim[¨câ1Æ,¨câ2Æ,¨tâ1Æ]Ä_cleanColCons_lemma));
a(asm_rewrite_tac[Ä_ö_thm] THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(POP_ASM_T ante_tac THEN 
	rewrite_tac[cleanRows_def,map_null_thm,˘_thm4,sets_ext_clauses]);
a(REPEAT strip_tac);
=TEX
=SML
(* *** Goal "2.2.2.1" *** *)
a(lemma_tac¨câ1 dominates R_exist xÆ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,13][][dominates_trans],id_tac]);
a(DROP_NTH_ASM_T 4 (strip_asm_tac o µ_elim¨xÆ));
(* *** Goal "2.2.2.2" *** *)
a(lemma_tac¨câ1 dominates R_exist x'Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][2,13][][dominates_trans],basic_res_tac1 1[]]);
=TEX
=SML
(* *** Goal "3" *** *)
a(lemma_tac¨câ1 dominates TS_class tâ2Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][2,4][][dominates_trans],asm_rewrite_tac[]]);
a(cases_tac¨câ1 dominates TS_class tâ1ÆTHEN asm_rewrite_tac[]);
(* *** Goal "3.1" *** *)
a(rewrite_tac[tab_components,get_spec¨MkTableSpecÆ]);
a strip_tac;
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "3.2" *** *)
a(rewrite_tac[tab_components,get_spec¨MkTableSpecÆ,stubTable_def]);
a strip_tac;
a(DROP_NTH_ASM_T 5(rewrite_thm_tac o eq_sym_rule));
a(DROP_NTH_ASM_T 4(rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[taut_rule¨µ a b c∑(a ± (b ± c)) = ((b ± a) ± c)Æ] THEN strip_tac);
(* *** Goal "3.2.1" *** *)
a(ante_tac(list_µ_elim[¨câ1Æ,¨câ2Æ,¨tâ2Æ]Ä_cleanColCons_lemma));
a(DROP_NTH_ASM_T 3 (rewrite_thm_tac o eq_sym_rule));
a(DROP_NTH_ASM_T 2 (rewrite_thm_tac o eq_sym_rule));
a(asm_rewrite_tac[Ä_ö_thm1] THEN REPEAT strip_tac);
=TEX
=SML
(* *** Goal "3.2.2" *** *)
a(POP_ASM_T ante_tac THEN 
	rewrite_tac[cleanRows_def,map_null_thm,˘_thm4,sets_ext_clauses]);
a(REPEAT strip_tac);
(* *** Goal "3.2.2.1" *** *)
a(lemma_tac¨câ1 dominates R_exist xÆ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,11][][dominates_trans],id_tac]);
a(DROP_NTH_ASM_T 4 (strip_asm_tac o µ_elim¨xÆ));
=TEX
=SML
(* *** Goal "3.2.2.2" *** *)
a(lemma_tac¨câ1 dominates R_exist x'Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][2,11][][dominates_trans],basic_res_tac1 1[]]);
val €cleanTable_lemma› = save_pop_thm"cleanTable_lemma";
=TEX
=GFT
cleanTable_lemma =
Ù µ câ1 câ2
  ∑ câ1 dominates câ2
      ¥ (µ tâ1 tâ2
      ∑ cleanTable câ1 tâ1 = cleanTable câ1 tâ2
          ¥ cleanTable câ2 tâ1 = cleanTable câ2 tâ2)
=TEX
\subsubsection{$cleanDirectory$ Lemma}

=SML
push_goal([],¨µ câ1 câ2 ∑ câ1 dominates câ2 ¥ µ dâ1 dâ2 ∑ 
	cleanDirectory câ1 dâ1 = cleanDirectory câ1 dâ2 
	¥ cleanDirectory câ2 dâ1 = cleanDirectory câ2 dâ2Æ);
a(REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN rewrite_tac[cleanDirectory_def]);
a(cases_tac¨câ2 dominates Dir_class dâ1Æ THEN cases_tac ¨câ2 dominates Dir_class dâ2Æ
	 THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "1" *** *)
a(lemma_tac¨câ1 dominates Dir_class dâ1Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,4][][dominates_trans],asm_rewrite_tac[]]);
a(lemma_tac¨câ1 dominates Dir_class dâ2Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,5][][dominates_trans],asm_rewrite_tac[]]);
a(rewrite_tac[dir_components,get_spec¨MkDirectoryÆ]THEN REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨câ1Æ,¨câ2Æ]cleanTable_lemma));
a(ante_tac (list_µ_elim[¨cleanTable câ1Æ,¨cleanTable câ2Æ,
	¨Dir_tables dâ1Æ,¨Dir_tables dâ2Æ]rel_thm) THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "2" *** *)
a(lemma_tac¨câ1 dominates Dir_class dâ1Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,4][][dominates_trans],asm_rewrite_tac[]]);
a(cases_tac¨câ1 dominates Dir_class dâ2ÆTHEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a(rewrite_tac[dir_components,get_spec¨MkDirectoryÆ]THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 7 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[dir_components,get_spec¨MkDirectoryÆ]THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN rewrite_tac[graph_thm,r_ª_r_thm,rel_ext_clauses]);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o list_µ_elim[¨xÆ,¨cleanTable câ1 zÆ]));
a(POP_ASM_T (strip_asm_tac o µ_elim¨zÆ));
=TEX
=SML
(* *** Goal "3" *** *)
a(lemma_tac¨câ1 dominates Dir_class dâ2Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][2,4][][dominates_trans],asm_rewrite_tac[]]);
a(cases_tac¨câ1 dominates Dir_class dâ1ÆTHEN asm_rewrite_tac[]);
(* *** Goal "3.1" *** *)
a(rewrite_tac[dir_components,get_spec¨MkDirectoryÆ]THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 7 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(rewrite_tac[dir_components,get_spec¨MkDirectoryÆ]THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN rewrite_tac[graph_thm,r_ª_r_thm,rel_ext_clauses]);
=TEX
=SML
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o list_µ_elim[¨xÆ,¨cleanTable câ1 zÆ]));
a(POP_ASM_T (strip_asm_tac o µ_elim¨zÆ));
(* *** Goal "4" *** *)
a(cases_tac¨câ1 dominates Dir_class dâ1ÆTHEN cases_tac¨câ1 dominates Dir_class dâ2Æ 
	THEN asm_rewrite_tac[dir_components,get_spec¨MkDirectoryÆ]
	THEN REPEAT strip_tac);
val €cleanDirectory_lemma› = save_pop_thm"cleanDirectory_lemma";
=TEX
=GFT
cleanDirectory_lemma = 
Ù µ câ1 câ2
  ∑ câ1 dominates câ2
      ¥ (µ dâ1 dâ2
      ∑ cleanDirectory câ1 dâ1 = cleanDirectory câ1 dâ2
          ¥ cleanDirectory câ2 dâ1 = cleanDirectory câ2 dâ2)
=TEX
\subsubsection{$hideR$ Lemma}
First, two lemmas about directories.
=SML
push_goal([],¨µ câ1 câ2 s x y ∑ câ1 dominates câ2 ¥ 
	((x,y) ç s í {dir|câ2 dominates Dir_exist dir} 
	¥ (x,y) ç s í {dir|câ1 dominates Dir_exist dir})Æ);
a(rewrite_tac[í_thm]THEN REPEAT strip_tac);
a(contr_tac THEN basic_res_tac4 2 [1][3,4][][dominates_trans]);
val Ä_dir_lemma = save_pop_thm"Ä_dir_lemma";
=TEX
=GFT
Ä_dir_lemma = 
Ù µ câ1 câ2 s x y
  ∑ câ1 dominates câ2
      ¥ (x, y) ç s í {dir|câ2 dominates Dir_exist dir}
      ¥ (x, y) ç s í {dir|câ1 dominates Dir_exist dir}
=TEX
=SML
push_goal([],¨µ c câ1 s  sâ1 x z zâ1
    ∑ (cleanDirectory câ1 z = cleanDirectory câ1 zâ1
	± (x, z) ç s í {dir|câ1 dominates Dir_exist dir}
	± (x, zâ1) ç sâ1 í {dir|c dominates Dir_exist dir})
	¥ (x, zâ1) ç sâ1 í {dir|câ1 dominates Dir_exist dir}Æ);
a(rewrite_tac[cleanDirectory_def,dir_components,get_spec¨MkDirectoryÆ,í_thm]
	THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
val dir_class_preserved_lemma = save_pop_thm"dir_class_preserved_lemma";
=GFT
dir_class_preserved_lemma =
Ù µ c câ1 s sâ1 x z zâ1
  ∑ cleanDirectory câ1 z = cleanDirectory câ1 zâ1
        ± (x, z) ç s í {dir|câ1 dominates Dir_exist dir}
        ± (x, zâ1) ç sâ1 í {dir|c dominates Dir_exist dir}
      ¥ (x, zâ1) ç sâ1 í {dir|câ1 dominates Dir_exist dir}
=TEX
Now the main result of this section that $hideR$ is a member of $secureHideR$.

=SML
push_goal([],¨hideR ç secureHideRÆ);
a(rewrite_tac[get_spec¨hideRÆ,get_spec¨secureHideRÆ]);
a(REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨câ1Æ,¨câ2Æ]cleanDirectory_lemma));
a(DROP_NTH_ASM_T 3 ante_tac);
a(rewrite_tac[r_ª_r_thm,rel_ext_clauses,graph_thm]THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(list_µ_elim[¨câ1Æ,¨câ2Æ,¨sâ1Æ,¨xÆ,¨zÆ]Ä_dir_lemma));
a(DROP_NTH_ASM_T 4 (asm_tac o list_µ_elim[¨xÆ,¨cleanDirectory câ1 zÆ]));
a(LEMMA_T¨∂ z'
             ∑ (x, z') ç sâ1 í {dir|câ1 dominates Dir_exist dir}
                 ± cleanDirectory câ1 z = cleanDirectory câ1 z'Æasm_tac);
(* *** Goal "1.1" *** *)
a(∂_tac¨zÆ THEN asm_prove_tac[]);
=TEX
=SML
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN POP_ASM_T rewrite_thm_tac);
a ¥_tac;
a(DROP_NTH_ASM_T 6(strip_asm_tac o list_µ_elim[¨zÆ,¨z'Æ]));
a(∂_tac¨z'Æ THEN asm_rewrite_tac[]);
a(strip_asm_tac (list_µ_elim[¨câ1Æ,¨câ2Æ,¨sâ1Æ,¨sâ2Æ,¨xÆ,¨zÆ,¨z'Æ]
	dir_class_preserved_lemma));
(* *** Goal "2" *** *)
a(strip_asm_tac (list_µ_elim[¨câ1Æ,¨câ2Æ,¨sâ2Æ,¨xÆ,¨zÆ]Ä_dir_lemma));
a(DROP_NTH_ASM_T 4 (asm_tac o list_µ_elim[¨xÆ,¨cleanDirectory câ1 zÆ]));
a(LEMMA_T¨∂ z'
             ∑ (x, z') ç sâ2 í {dir|câ1 dominates Dir_exist dir}
                 ± cleanDirectory câ1 z = cleanDirectory câ1 z'Æasm_tac);
(* *** Goal "2.1" *** *)
a(∂_tac¨zÆ THEN asm_prove_tac[]);
=TEX
=SML
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN POP_ASM_T rewrite_thm_tac);
a ¥_tac;
a(DROP_NTH_ASM_T 6(strip_asm_tac o list_µ_elim[¨zÆ,¨z'Æ]));
a(∂_tac¨z'Æ THEN asm_rewrite_tac[]);
a(strip_asm_tac (list_µ_elim[¨câ1Æ,¨câ2Æ,¨sâ2Æ,¨sâ1Æ,¨xÆ,¨zÆ,¨z'Æ]
	dir_class_preserved_lemma));
val €secureHideR_lemma› = save_pop_thm"secureHideR_lemma";
=TEX
=GFT
secureHideR_lemma = Ù hideR ç secureHideR
=TEX

\subsection{Proof that the Invariant on the State is Maintained} \label{INVARIANT}
We need a series of auxiliary results of the form $replaceData$  etc, are partial.

=SML
push_goal([],¨µ clear ∑ Graph (cleanDirectory clear) ç FunctionalÆ);
a(rewrite_tac[cleanDirectory_def,graph_thm,functional_def,dir_components,
	get_spec¨MkDirectoryÆ] THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
val cleanDir_fun_thm = save_pop_thm"cleanDir_fun_thm";
=TEX
=GFT
cleanDir_fun_thm = Ù µ clear∑ Graph (cleanDirectory clear) ç Functional
=TEX
=SML
push_goal([],¨µ clear ∑ Graph (replaceData clear) ç FunctionalÆ);
a(rewrite_tac[replaceData_def,graph_thm,functional_def,data_components,get_spec¨MkDataÆ]
	THEN  REPEAT strip_tac THEN asm_rewrite_tac[]);
val replaceData_fun_thm = save_pop_thm"replaceData_fun_thm";
=TEX
=GFT
replaceData_fun_thm = Ù µ clear∑ Graph (replaceData clear) ç Functional
=TEX
=SML
push_goal([],¨µ clear tab ∑ TS_cons tab ç Functional 
	¥ Fst (cleanColCons clear tab) ç FunctionalÆ);
a(rewrite_tac[cleanColCons_def,functional_def,í_thm]THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 5 (strip_asm_tac o list_µ_elim[¨xÆ,¨wÆ,¨zÆ]));
val cleanColCons_fun_thm = save_pop_thm"cleanColCons_fun_thm";
=TEX

=GFT
cleanColCons_fun_thm =
Ù µ clear tab
  ∑ TS_cons tab ç Functional ¥ Fst (cleanColCons clear tab) ç Functional
=TEX
=SML
push_goal([],¨µ clear  dir∑ Dir_tables dir ç Functional
             ¥ Dir_tables (cleanDirectory clear dir) ç FunctionalÆ);
a(rewrite_tac[cleanDirectory_def,functional_def]THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac 
	THEN rewrite_tac[get_spec¨MkDirectoryÆ]);
a(cases_tac¨clear dominates Dir_class dirÆ THEN asm_rewrite_tac[]);
a(rewrite_tac[r_ª_r_thm,graph_thm]);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 6 (strip_asm_tac o list_µ_elim[¨xÆ,¨z'Æ,¨z''Æ]));
a(asm_rewrite_tac[]);
val tables_fun_thm = save_pop_thm"tables_fun_thm";
=TEX



=GFT
tables_fun_thm =
Ù µ clear dir
  ∑ Dir_tables dir ç Functional
      ¥ Dir_tables (cleanDirectory clear dir) ç Functional
=TEX
Now the main result of this section that $hideR$ preserves the invariant on states.
=SML
push_goal([],¨µ clear s ∑ isState s ¥ isState(hideR(clear,s))Æ);
a(rewrite_tac[get_spec¨hideRÆ] THEN REPEAT µ_tac);
a(rewrite_tac[get_spec¨isStateÆ,get_spec¨StateSÆ,ﬂ_def,°_def] THEN strip_tac);
a(lemma_tac¨(s í {dir|clear dominates Dir_exist dir}) ª Graph (cleanDirectory clear)
               ç FunctionalÆ);
(* *** Goal "1" *** *)
a(strip_asm_tac(list_µ_elim[¨{dir|clear dominates Dir_exist dir}Æ,¨sÆ]í_fun_thm));
a(strip_asm_tac(µ_elim¨clearÆcleanDir_fun_thm));
a(strip_asm_tac(list_µ_elim[¨(s í {dir|clear dominates Dir_exist dir})Æ,
	¨cleanDirectory clearÆ]ª_fun_thm));
=TEX
=SML
(* *** Goal "2" *** *)
a(TOP_ASM_T rewrite_thm_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN rewrite_tac[™_def,get_spec¨IdeLÆ,
	get_spec¨DirectorySÆ,°_def,∏_def,get_spec¨UniverseÆ,dom_def,
	í_thm,r_ª_r_thm,graph_thm,rel_ext_clauses,get_spec¨$Æ]);
a(REPEAT strip_tac);
a(asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 4(strip_asm_tac o list_µ_elim[¨xÆ,¨zÆ]));
a(POP_ASM_T ante_tac THEN rewrite_tac[ﬂ_def,°_def] THEN strip_tac);
a(strip_asm_tac(list_µ_elim[¨clearÆ,¨zÆ]tables_fun_thm));
a(POP_ASM_T rewrite_thm_tac);
a(DROP_NTH_ASM_T 2 ante_tac);
=TEX
=SML
a(DROP_NTH_ASM_T 2 ante_tac 
	THEN rewrite_tac[cleanDirectory_def,get_spec¨MkDirectoryÆ]	
	THEN cases_tac¨clear dominates Dir_class zÆ
	THEN asm_rewrite_tac[™_def,∏_def] THEN strip_tac);
a(rewrite_tac[ç_in_clauses,rel_ext_clauses,get_spec¨TableSpecSÆ,
	get_spec¨IdeÆ,ﬂ_def,°_def,r_ª_r_thm,graph_thm,cleanTable_def] 
	THEN conv_tac(MAP_C let_conv)THEN strip_tac THEN strip_tac 
	THEN strip_tac THEN strip_tac);
a(DROP_NTH_ASM_T 3(strip_asm_tac o list_µ_elim[¨x'Æ,¨z'Æ]));
a(DROP_NTH_ASM_T 4 ante_tac THEN cases_tac¨clear dominates TS_class z'Æ
	THEN asm_rewrite_tac[stubTable_def,tab_components,get_spec¨MkTableSpecÆ]
	THEN strip_tac 
	THEN asm_rewrite_tac[™_def,∏_def,prove_rule[functional_def]¨{} ç FunctionalÆ]);
=TEX
=SML
a(PC_T1 "hol1"rewrite_tac[get_spec¨ColConSÆ,get_spec¨NumÆ]);
a(strip_asm_tac (list_µ_elim[¨clearÆ,¨z'Æ]cleanColCons_fun_thm));
a(POP_ASM_T rewrite_thm_tac);
a(µ_tac THEN rewrite_tac[cleanRows_def]);
a(DROP_NTH_ASM_T 7 ante_tac);
a(rewrite_tac[get_spec¨RowSÆ]THEN conv_tac(MAP_C let_conv) 
	THEN PC_T1 "hol1"rewrite_tac[™_def,∏_def,get_spec¨NumÆ,get_spec¨DataSÆ,ﬂ_def]);
a(lemma_tac¨∂ l ∑ TS_rows z' = lÆTHEN_LIST
	[prove_∂_tac,POP_ASM_T rewrite_thm_tac]);
=TEX
=SML
a(LIST_INDUCTION_T¨lÆasm_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[˘_def,map_def,map_null_thm,çâl_def]);
(* *** Goal "2.2" *** *)
a(µ_tac THEN rewrite_tac[map_def,˘_def,çâl_def]);
a strip_tac;
a(lemma_tac¨µ r∑ r çâl l ¥ R_data r ç FunctionalÆ);
(* *** Goal "2.2.1" *** *)
a(REPEAT strip_tac);
a(cases_tac¨r' = x''Æ);
=TEX
=SML
(* *** Goal "2.2.1.1" *** *)
a(DROP_NTH_ASM_T 3(ante_tac o µ_elim¨x''Æ) THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1.2" *** *)
a(DROP_NTH_ASM_T 3(ante_tac o µ_elim¨r'Æ) THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a(cases_tac¨clear dominates R_exist x''ÆTHEN asm_rewrite_tac[map_def,çâl_def] 
	THEN strip_tac );
(* *** Goal "2.2.2.1" *** *)
a(POP_ASM_T rewrite_thm_tac THEN 
	rewrite_tac[cleanRow_def,row_components,get_spec¨MkRowÆ]);
a(lemma_tac¨filterRow (Snd (cleanColCons clear z')) (R_data x'') ç FunctionalÆ);
(* *** Goal "2.2.2.1.1" *** *)
a(DROP_NTH_ASM_T 3 (ante_tac o µ_elim¨x''Æ));
a(rewrite_tac[functional_def] THEN strip_tac);
a(strip_tac THEN rewrite_tac[filterRow_def,cleanColCons_def,í_thm,Ú_thm,dom_def]);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o list_µ_elim[¨x'''Æ,¨wÆ,¨z''Æ]));
(* *** Goal "2.2.2.1.2" *** *)
a(strip_asm_tac(µ_elim¨clearÆreplaceData_fun_thm));
a(strip_asm_tac(list_µ_elim[¨filterRow (Snd (cleanColCons clear z')) (R_data x'')Æ,
	¨replaceData clearÆ]ª_fun_thm));
=TEX
=SML
(* *** Goal "2.2.2.2" *** *)
a(DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.3" *** *)
a(DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
val hideR_lemma = save_pop_thm"hideR_lemma";
=TEX
\subsection{$hide$ Lemma}

We now use the results of sections \ref{STRATEGY}, \ref{HIDER} and \ref{INVARIANT} to  prove that $hide$ is a member of $SecureHide$.

=SML
val secureHide_lemma = rewrite_rule[secureHideR_lemma,hideR_lemma]hideR_hide_lemma;
=TEX

=GFT
secureHide_lemma = Ù hide ç secureHide
=TEX

\section{CLOSING DOWN}
The following ICL HOL instruction restores the previous proof context.
=SML
pop_pc();
=TEX

\newpage
\input{fef010th.tex}

\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}

