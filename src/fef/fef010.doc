=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Proof of Security (IIa)}  %% Mandatory field
\TPPref{DS/FMU/FEF/010}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document provides a formal proof for the security property
on $hide$ for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue 1.1] First draft version.
\item[Issue 1.2] Name of proof context $pair1$ changed to $'pair1$.
\item[Issue \SCCSversion(\FormatDate{$Date$
})] Removed partial function axioms for $TableSpecs$, $State$ and $R\_Data$.
\end{description}

\subsection{Changes Forecast}
Changes  may be necessary  as a result of issues raised
during  the transcription of the specification.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document provides a formal proof  that the component $hide$ satisfies its critical 
requirement, as specified in 
the proof strategy \cite{DS/FMU/FEF/007}. It constitutes part of deliverable D5 
of work package 1a, as given
in section 7 of the Secure Database Technical Proposal, \cite{DS/FMU/017}.

\subsection{Introduction}

This document is a proof script which provides a formal proof of  the first conjunct
of $Lemma1$,
the requirement on the critical components  $hide$ and $updateState$, described in the proof strategy document \cite{DS/FMU/FEF/007}.

{\bf Lemma1}
=GFT
	?Ù 	hide ç secureHide ± (hide,updateState) ç secureUpdate
=TEX

In this document, we give a proof of
=GFT

	?Ù 	hide ç secureHide
=TEX

\section{PRELIMINARIES}
The following ICL HOL instructions set up the new theory $fef010$.

=SML 
open_theory "fef009";
new_theory€"fef010"›;
push_merge_pcs["hol","fefhol","'pair1"] ;
=TEX
\section{AUXILIARY RESULTS}
Two theorems about lists.
=SML
push_goal([],¨µf l ∑ (Map f l = [] § l = []) ± ([] = Map f l § l = [])Æ);
a(REPEAT µ_tac);
a(list_induction_tac¨lÆ THEN rewrite_tac[map_def]);
val €map_null_thm› = save_pop_thm"map_null_thm";
=TEX
=GFT
map_null_thm = Ù µ f l∑ (Map f l = [] § l = []) ± ([] = Map f l § l = [])
=TEX
=SML
push_goal([],¨µ l x ∑ ≥ (Cons x l = l)Æ);
a µ_tac;
a(list_induction_tac¨lÆ THEN rewrite_tac[]);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 2(strip_asm_tac o µ_elim¨xÆ));
val €≥_cons_thm› = save_pop_thm"≥_cons_thm";
=TEX
=GFT
≥_cons_thm= Ù µ l x∑ ≥ Cons x l = l
=TEX
Two theorems which state that any subset of the empty set must be empty.
=SML
val €Ä_ö_thm› = pc_rule"hol1"(prove_rule[]) ¨µ s ∑ s Ä {} § s = {}Æ;
=TEX
=SML
val €Ä_ö_thm1› = pc_rule"hol1"(prove_rule[]) ¨µ s ∑ s Ä {}
 § {} = sÆ;
=TEX
=GFT
Ä_ö_thm =	Ù µ s∑ s Ä {} § s = {}
Ä_ö_thm1 =	Ù µ s∑ s Ä {} § {} = s
=TEX
An equivalent to $sets\_ext\_clauses$ for relations.
=SML
push_goal([],¨µ a b∑(a Ä b § (µ x y∑ (x,y) ç a ¥ (x,y) ç b))
      ± (a = b § (µ x y∑ (x,y)ç a § (x,y) ç b))Æ);
a(rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 2 (strip_asm_tac o µ_elim¨(x, y)Æ));
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac);
a(LEMMA_T¨x = (Fst x,Snd x)Æpure_once_rewrite_thm_tac 
	THEN_LIST[rewrite_tac[],¥_T asm_tac THEN basic_res_tac1 1 []]); 
(* *** Goal "3" *** *)
a(DROP_NTH_ASM_T 2 (strip_asm_tac o µ_elim¨(x, y)Æ));
(* *** Goal "4" *** *)
a(POP_ASM_T ante_tac);
a(LEMMA_T¨x = (Fst x,Snd x)Æpure_once_rewrite_thm_tac 
	THEN_LIST[rewrite_tac[],¥_T asm_tac THEN basic_res_tac1 1 []]); 
(* *** Goal "5" *** *)
a(POP_ASM_T ante_tac);
a(LEMMA_T¨x = (Fst x,Snd x)Æpure_once_rewrite_thm_tac 
	THEN_LIST[rewrite_tac[],¥_T asm_tac THEN basic_res_tac1 1 []]); 
val €rel_ext_clauses› = save_pop_thm"rel_ext_clauses";
=TEX

=GFT
rel_ext_clauses = 
Ù µ a b
  ∑ (a Ä b § (µ x y∑ (x, y) ç a ¥ (x, y) ç b))
      ± (a = b § (µ x y∑ (x, y) ç a § (x, y) ç b))
=TEX
A result about equality of pairs.
=SML
push_goal([],¨µ x y ∑ (Fst x = Fst y) ± (Snd x = Snd y) § (x = y)Æ);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(LEMMA_T¨(x = (Fst x,Snd x)) ± (y = (Fst y,Snd y))Æ 
	pure_once_rewrite_thm_tac THEN_LIST[rewrite_tac[],asm_rewrite_tac[]]);
val €pair_eq_thm› = save_pop_thm"pair_eq_thm";
=TEX

=GFT
pair_eq_thm = Ù µ x y∑ Fst x = Fst y ± Snd x = Snd y § x = y
=TEX
Four relation results .

=SML
val €Ú_thm› = prove_rule[Ú_def]¨µ x s r ∑x ç s Ú r § Fst x ç s ± x ç rÆ;
=TEX

=SML
val €í_thm› = prove_rule[í_def]¨µ x y s r ∑(x,y) ç r í s § y ç s ± (x,y) ç rÆ;
=TEX


=SML
val €graph_thm› = prove_rule[graph_def]¨µ x f ∑ x ç Graph f § Snd x = f (Fst x)Æ;
=TEX

=SML
val €r_ª_r_thm› = prove_rule[r_ª_r_def]
	¨µ x y r s ∑ (x,y) ç r ª s § ∂ z∑ (x, z) ç r ± (z, y) ç sÆ;
=TEX
=GFT
Ú_thm =		Ù µ x s r∑ x ç s Ú r § Fst x ç s ± x ç r
í_thm =		Ù µ x y s r∑ (x, y) ç r í s § y ç s ± (x, y) ç r
graph_thm =	Ù µ x f∑ x ç Graph f § Snd x = f (Fst x)
r_ª_r_thm = 	Ù µ x y r s∑ (x, y) ç r ª s § (∂ z∑ (x, z) ç r ± (z, y) ç s)
=TEX

A tactic for introducing universals.
=SML
fun €intro_µ_tac› ((t1, x) : (TERM * TERM)) : TACTIC = (fn (seqasms, conc) =>
	let	val t' = subst[(x, t1)] conc;
	in	if t' =$ conc
		then	term_fail "intro_µ_tac" 28082 [t1]
		else	([(seqasms, mk_simple_µ(x, t'))],
			(fn [thm] => simple_µ_elim t1 thm | _ => bad_proof "intro_µ_tac"))
	end handle ex => (
		let val area = area_of ex;
		in	if area = "subst" orelse area = "mk_simple_µ"
			then reraise ex "intro_µ_tac" 
			else raise ex
		end
	)
);
=TEX
A result about equality of relational composition.
=SML
push_goal([],¨µ r râ1 a b 
           ∑ (a ª Graph r = b ª Graph r
              ±    (µx xâ1 ∑ r x = r xâ1 ¥ râ1 x = râ1 xâ1))
               ¥ a ª Graph râ1 = b ª Graph râ1Æ);
a(rewrite_tac[r_ª_r_thm,rel_ext_clauses,graph_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 (asm_tac o list_µ_elim[¨xÆ,¨r zÆ]));
a(LEMMA_T¨∂ z'∑ (x, z') ç a ± r z = r z'Æasm_tac);
(* *** Goal "1.1" *** *)
a(∂_tac¨zÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN POP_ASM_T rewrite_thm_tac);
a ¥_tac;
a(DROP_NTH_ASM_T 5(strip_asm_tac o list_µ_elim[¨zÆ,¨z'Æ]));
a(∂_tac¨z'Æ THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 (asm_tac o list_µ_elim[¨xÆ,¨r zÆ]));
a(LEMMA_T¨∂ z'∑ (x, z') ç b ± r z = r z'Æasm_tac);
(* *** Goal "2.1" *** *)
a(∂_tac¨zÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN POP_ASM_T rewrite_thm_tac);
a ¥_tac;
a(DROP_NTH_ASM_T 5(strip_asm_tac o list_µ_elim[¨zÆ,¨z'Æ]));
a(∂_tac¨z'Æ THEN asm_rewrite_tac[]);
val €rel_thm› = save_pop_thm"rel_thm";
=TEX
=GFT
rel_thm = 
Ù µ r râ1 a b
  ∑ a ª Graph r = b ª Graph r ± (µ x xâ1∑ r x = r xâ1 ¥ râ1 x = râ1 xâ1)
      ¥ a ª Graph râ1 = b ª Graph râ1
=TEX

\section{SETTING UP FOR THE SECURITY PROOF}
\subsection{Consistency Proof for $dominates$}
We prove the consistency of $dominates$ and retrieve the definiton of $dominates$ with
the consistency obligation satisfied.
=SML
push_consistency_goal¨$dominatesÆ;
a(∂_tac¨$=Æ);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
save_consistency_thm¨$dominatesÆ(top_thm());
val €dominates_def› = get_spec¨$dominatesÆ;
=TEX
A theorem which just states the transitivity property of $dominates$.
=SML
val €dominates_trans› = prove_rule[dominates_def]
	¨µ x y z ∑x dominates y ± y dominates z ¥ x dominates zÆ;
=TEX
=GFT
dominates_trans = Ù µ x y z∑ x dominates y ± y dominates z ¥ x dominates z 
=TEX
\subsection{Retrieving the Remaining Definitions of Constants}
=SML
val €hide_def› = get_spec¨hideÆ;
val €secureHide_def› = get_spec¨secureHideÆ;
val €cleanDirectory_def› = get_spec¨cleanDirectoryÆ;
val €cleanTable_def› = conv_rule(MAP_C let_conv)(get_spec¨cleanTableÆ);
val €cleanColCons_def› = conv_rule(MAP_C let_conv)(get_spec¨cleanColConsÆ);
val €stubTable_def› = get_spec¨stubTableÆ;
val €cleanRows_def› = get_spec¨cleanRowsÆ;
val €cleanRow_def› = get_spec¨cleanRowÆ;
val €replaceData_def› = get_spec¨replaceDataÆ;
val €filterRow_def› = get_spec¨filterRowÆ;
=TEX

\subsection{Components of Labelled Products}
These theorems state that if two things of labelled product type are equal, then their components 
must be equal.
\subsubsection{Type $Directory$}
=SML
push_goal([],¨µ dirâ1 dirâ2 ∑
	dirâ1 = dirâ2 § 
	Dir_tables dirâ1 = Dir_tables dirâ2
±	Dir_exist dirâ1 = Dir_exist dirâ2
±	Dir_class dirâ1 = Dir_class dirâ2Æ);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(lemma_tac¨(dirâ1 = MkDirectory (Dir_tables dirâ1) (Dir_exist dirâ1) (Dir_class dirâ1))
	± (dirâ2 = MkDirectory (Dir_tables dirâ2) (Dir_exist dirâ2) (Dir_class dirâ2))Æ);
(* *** Goal "1" *** *)
a(rewrite_tac[get_spec¨MkDirectoryÆ]);
(* *** Goal "2" *** *)
a(POP_ASM_T once_rewrite_thm_tac); 
a(POP_ASM_T once_rewrite_thm_tac); 
a(asm_rewrite_tac[]);
val €dir_components› = save_pop_thm"dir_components";
=TEX
=GFT
dir_components =
Ù µ dirâ1 dirâ2
  ∑ dirâ1 = dirâ2
      § Dir_tables dirâ1 = Dir_tables dirâ2
        ± Dir_exist dirâ1 = Dir_exist dirâ2
        ± Dir_class dirâ1 = Dir_class dirâ2 
=TEX
\subsubsection{Type $TableSpec$}

=SML
push_goal([],¨µ tâ1 tâ2 ∑
	tâ1 = tâ2 § 
	TS_class tâ1 = TS_class tâ2
±	TS_maxRow tâ1 = TS_maxRow tâ2
±	TS_colspecs tâ1 = TS_colspecs tâ2
±	TS_cons tâ1 = TS_cons tâ2
±	TS_rows tâ1 = TS_rows tâ2Æ);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(lemma_tac¨(tâ1 = MkTableSpec(TS_class tâ1) (TS_maxRow tâ1) (TS_colspecs tâ1)
	(TS_cons tâ1)(TS_rows tâ1))
	± (tâ2 = MkTableSpec(TS_class tâ2) (TS_maxRow tâ2) (TS_colspecs tâ2)
	(TS_cons tâ2)(TS_rows tâ2))Æ);
(* *** Goal "1" *** *)
a(rewrite_tac[get_spec¨MkTableSpecÆ]);
(* *** Goal "2" *** *)
a(POP_ASM_T once_rewrite_thm_tac); 
a(POP_ASM_T once_rewrite_thm_tac); 
a(asm_rewrite_tac[]);
val €tab_components› = save_pop_thm"tab_components";
=TEX
=GFT
tab_components = 
Ù µ tâ1 tâ2
  ∑ tâ1 = tâ2
      § TS_class tâ1 = TS_class tâ2
        ± TS_maxRow tâ1 = TS_maxRow tâ2
        ± TS_colspecs tâ1 = TS_colspecs tâ2
        ± TS_cons tâ1 = TS_cons tâ2
        ± TS_rows tâ1 = TS_rows tâ2
=TEX
\subsubsection{Type $Row$}

=SML
push_goal([],¨µ râ1 râ2 ∑
	râ1 = râ2 § 
	R_exist râ1 = R_exist râ2
±	R_data râ1 = R_data râ2Æ);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(lemma_tac¨(râ1 = MkRow(R_exist râ1) (R_data râ1))
	± (râ2 = MkRow(R_exist râ2) (R_data râ2))Æ);
(* *** Goal "1" *** *)
a(rewrite_tac[get_spec¨MkRowÆ]);
(* *** Goal "2" *** *)
a(POP_ASM_T once_rewrite_thm_tac); 
a(POP_ASM_T once_rewrite_thm_tac); 
a(asm_rewrite_tac[]);
val €row_components› = save_pop_thm"row_components";
=TEX
=GFT
row_components = 
Ù µ râ1 râ2
  ∑ râ1 = râ2 § R_exist râ1 = R_exist râ2 ± R_data râ1 = R_data râ2
=TEX
\subsubsection{Type $Data$}

=SML
push_goal([],¨µ dâ1 dâ2 ∑
	dâ1 = dâ2 § 
	Dat_class dâ1 = Dat_class dâ2
±	Dat_item dâ1 = Dat_item dâ2Æ);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(lemma_tac¨(dâ1 = MkData(Dat_class dâ1) (Dat_item dâ1))
	± (dâ2 = MkData(Dat_class dâ2) (Dat_item dâ2))Æ);
(* *** Goal "1" *** *)
a(rewrite_tac[get_spec¨MkDataÆ]);
(* *** Goal "2" *** *)
a(POP_ASM_T once_rewrite_thm_tac); 
a(POP_ASM_T once_rewrite_thm_tac); 
a(asm_rewrite_tac[]);
val €data_components› = save_pop_thm"data_components";
=TEX
=GFT
val data_components = 
Ù µ dâ1 dâ2
  ∑ dâ1 = dâ2 § Dat_class dâ1 = Dat_class dâ2 ± Dat_item dâ1 = Dat_item dâ2 
=TEX
\section{PROOF OF SECURITY OF $hide$}
The proof is broken down into a series of lemmas.

\subsection{$replaceData$ Lemma}

=SML
push_goal([],¨µ câ1 câ2 ∑ câ1 dominates câ2
	¥ µ dâ1 dâ2 ∑
		replaceData câ1 dâ1 = replaceData câ1 dâ2
		¥ 
		replaceData câ2 dâ1 = replaceData câ2 dâ2Æ);
a(REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN rewrite_tac[replaceData_def]);
a(cases_tac¨câ2 dominates Dat_class dâ1Æ THEN cases_tac¨câ2 dominates Dat_class dâ2Æ
	THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(lemma_tac¨(câ1 dominates Dat_class dâ1) ± (câ1 dominates Dat_class dâ2)Æ
	THEN_LIST[basic_res_tac2 3[dominates_trans],asm_rewrite_tac[]]);
=TEX
=SML
(* *** Goal "2" *** *)
a(lemma_tac¨câ1 dominates Dat_class dâ1Æ THEN_LIST
	[contr_tac THEN basic_res_tac4 2 [1][3,4][][dominates_trans],asm_rewrite_tac[]]);
a(cases_tac¨câ1 dominates Dat_class dâ2Æ THEN asm_rewrite_tac[]);
a ¥_tac;
a(DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨câ1 dominates Dat_class dâ2Æ THEN_LIST
[contr_tac THEN basic_res_tac4 2 [1][2,4][][dominates_trans],asm_rewrite_tac[]]);
a(cases_tac¨câ1 dominates Dat_class dâ1Æ THEN asm_rewrite_tac[]);
a ¥_tac;
a(DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "4" *** *)
a(cases_tac¨câ1 dominates Dat_class dâ1Æ THEN cases_tac¨câ1 dominates Dat_class dâ2Æ
	THEN asm_rewrite_tac[]);
(* *** Goal "4.1" *** *)
a ¥_tac;
a(DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "4.2" *** *)
a(¥_T(strip_asm_tac o rewrite_rule[data_components,get_spec¨MkDataÆ])); ;
a(asm_rewrite_tac[]);
(* *** Goal "4.3" *** *)
a(¥_T(strip_asm_tac o rewrite_rule[data_components,get_spec¨MkDataÆ])); ;
a(asm_rewrite_tac[]);
val €replaceData_lemma› = save_pop_thm"replaceData_lemma";
=TEX
=GFT
replaceData_lemma = 
Ù µ câ1 câ2
  ∑ câ1 dominates câ2
      ¥ (µ dâ1 dâ2
      ∑ replaceData câ1 dâ1 = replaceData câ1 dâ2
          ¥ replaceData câ2 dâ1 = replaceData câ2 dâ2)
=TEX
\subsection{$cleanColCons$ Lemma}
=SML
push_goal([],¨µ câ1 câ2 tâ1 tâ2 ∑
	(câ1 dominates câ2
	± cleanColCons câ1 tâ1 = cleanColCons câ1 tâ2)
	¥ cleanColCons câ2 tâ1 = cleanColCons câ2 tâ2Æ);
a(REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN rewrite_tac[cleanColCons_def,í_def,dom_def]);
a(PC_T "hol1"(REPEAT strip_tac));
(* *** Goal "1" *** *)
a(lemma_tac ¨câ1 dominates  CC_exist (Snd x)Æ);
(* *** Goal "1.1" *** *)
a(ante_tac(list_µ_elim[¨câ1Æ,¨câ2Æ,¨CC_exist (Snd x)Æ]dominates_def) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(PC_T"hol1"(DROP_NTH_ASM_T 5 (strip_asm_tac o µ_elim¨xÆ)));
=TEX
=SML
(* *** Goal "2" *** *)
a(lemma_tac ¨câ1 dominates  CC_exist (Snd x)Æ);
(* *** Goal "2.1" *** *)
a(ante_tac(list_µ_elim[¨câ1Æ,¨câ2Æ,¨CC_exist (Snd x)Æ]dominates_def) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(PC_T"hol1"(DROP_NTH_ASM_T 5 (strip_asm_tac o µ_elim¨xÆ)));
(* *** Goal "3" *** *)
a(∂_tac¨yÆ THEN asm_rewrite_tac[]);
a(lemma_tac ¨câ1 dominates  CC_exist yÆ);
(* *** Goal "3.1" *** *)
a(ante_tac(list_µ_elim[¨câ1Æ,¨câ2Æ,¨CC_exist yÆ]dominates_def) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "3.2" *** *)
a(PC_T"hol1"(DROP_NTH_ASM_T 5 (strip_asm_tac o µ_elim¨(CS_consGroup x, y)Æ)));
=TEX
=SML
(* *** Goal "4" *** *)
a(∂_tac¨yÆ THEN asm_rewrite_tac[]);
a(lemma_tac ¨câ1 dominates  CC_exist yÆ);
(* *** Goal "4.1" *** *)
a(ante_tac(list_µ_elim[¨câ1Æ,¨câ2Æ,¨CC_exist yÆ]dominates_def) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "4.2" *** *)
a(PC_T"hol1"(DROP_NTH_ASM_T 5 (strip_asm_tac o µ_elim¨(CS_consGroup x, y)Æ)));
val €cleanColCons_lemma› = save_pop_thm"cleanColCons_lemma";
=TEX
=GFT
cleanColCons_lemma =
Ù µ câ1 câ2 tâ1 tâ2
  ∑ câ1 dominates câ2 ± cleanColCons câ1 tâ1 = cleanColCons câ1 tâ2
      ¥ cleanColCons câ2 tâ1 = cleanColCons câ2 tâ2
=TEX
\subsection{$cleanRow$ Lemma}
First, two lemmas about $cleanColCons$.
=SML
push_goal([],¨µ câ1 câ2 t∑ câ1 dominates câ2
	¥ (Fst(cleanColCons câ2 t) Ä Fst(cleanColCons câ1 t)
	± Snd(cleanColCons câ2 t) Ä Snd(cleanColCons câ1 t))Æ);
a(rewrite_tac[rel_ext_clauses,sets_ext_clauses,cleanColCons_def,í_thm,dom_def]
	 THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(contr_tac THEN basic_res_tac4 2 [1][3,4][][dominates_trans]);
(* *** Goal "2" *** *)
a(∂_tac¨yÆTHEN asm_rewrite_tac[]);
a(contr_tac THEN basic_res_tac4 2 [1][3,4][][dominates_trans]);
val €Ä_cleanColCons_lemma› = save_pop_thm"Ä_cleanColCons_lemma";
=TEX
=GFT
Ä_cleanColCons_lemma =
Ù µ câ1 câ2 t
  ∑ câ1 dominates câ2
      ¥ Fst (cleanColCons câ2 t) Ä Fst (cleanColCons câ1 t)
        ± Snd (cleanColCons câ2 t) Ä Snd (cleanColCons câ1 t)
=TEX
=SML
push_goal([],¨µ câ1 câ2 t col ∑ câ1 dominates câ2
	¥ (col ç Snd(cleanColCons câ2 t) ¥ col ç Snd(cleanColCons câ1 t))Æ);
a(REPEAT strip_tac);
a(basic_res_tac 2 [rewrite_rule[sets_ext_clauses]Ä_cleanColCons_lemma]);
val €Ä_cleanColCons_lemma1› = save_pop_thm"Ä_cleanColCons_lemma1";
=TEX
=GFT
Ä_cleanColCons_lemma1 = 
Ù µ câ1 câ2 t col
  ∑ câ1 dominates câ2
      ¥ col ç Snd (cleanColCons câ2 t)
      ¥ col ç Snd (cleanColCons câ1 t)
=TEX
The main result about $CleanRow$.
=SML
push_goal([],¨µ câ1 câ2  ∑ câ1 dominates câ2
	¥ µ tâ1 tâ2 râ1 râ2 ∑
		(cleanColCons câ1 tâ1 = cleanColCons câ1 tâ2
		± cleanColCons câ2 tâ1 = cleanColCons câ2 tâ2
		± cleanRow câ1 (Snd (cleanColCons câ1 tâ1)) râ1
              		= cleanRow câ1 (Snd (cleanColCons câ1 tâ2)) râ2)
		¥ 
		cleanRow câ2 (Snd (cleanColCons câ2 tâ1)) râ1
                 = cleanRow câ2 (Snd (cleanColCons câ2 tâ2)) râ2Æ);
a(REPEAT µ_tac THEN strip_tac);
a(strip_asm_tac (list_µ_elim[¨câ1Æ,¨câ2Æ]replaceData_lemma));
a(rewrite_tac[cleanRow_def,row_components,get_spec¨MkRowÆ,filterRow_def,
	rel_ext_clauses,Ú_thm,r_ª_r_thm,graph_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac (list_µ_elim[¨câ1Æ,¨câ2Æ,¨tâ1Æ,¨cÆ]Ä_cleanColCons_lemma1));
a(DROP_NTH_ASM_T 6 (asm_tac o list_µ_elim[¨xÆ,¨replaceData câ1 zÆ]));
a(LEMMA_T¨∂ z'
             ∑ ((∂ c∑ c ç Snd (cleanColCons câ1 tâ1) ± CS_posn c = x)
                   ± (x, z') ç R_data râ1)
                 ± replaceData câ1 z = replaceData câ1 z'Æasm_tac);
(* *** Goal "1.1" *** *)
a(∂_tac¨zÆ THEN asm_prove_tac[]);
=TEX
=SML
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN POP_ASM_T rewrite_thm_tac);
a ¥_tac;
a(DROP_NTH_ASM_T 13(strip_asm_tac o list_µ_elim[¨zÆ,¨z'Æ]));
a(∂_tac¨z'Æ THEN asm_rewrite_tac[]);
a(∂_tac¨cÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 10 ante_tac THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "2" *** *)
a(strip_asm_tac (list_µ_elim[¨câ1Æ,¨câ2Æ,¨tâ2Æ,¨cÆ]Ä_cleanColCons_lemma1));
a(DROP_NTH_ASM_T 6 (asm_tac o list_µ_elim[¨xÆ,¨replaceData câ1 zÆ]));
a(LEMMA_T¨∂ z'
             ∑ ((∂ c∑ c ç Snd (cleanColCons câ1 tâ2) ± CS_posn c = x)
                   ± (x, z') ç R_data râ2)
                 ± replaceData câ1 z = replaceData câ1 z'Æasm_tac);
(* *** Goal "2.1" *** *)
a(∂_tac¨zÆ THEN asm_prove_tac[]);
=TEX
=SML
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN POP_ASM_T rewrite_thm_tac);
a ¥_tac;
a(DROP_NTH_ASM_T 13(strip_asm_tac o list_µ_elim[¨zÆ,¨z'Æ]));
a(∂_tac¨z'Æ THEN asm_rewrite_tac[]);
a(∂_tac¨cÆ THEN asm_rewrite_tac[]);
val €cleanRow_lemma› = save_pop_thm"cleanRow_lemma";
=TEX
=GFT
cleanRow_lemma = 
Ù µ câ1 câ2
  ∑ câ1 dominates câ2
      ¥ (µ tâ1 tâ2 râ1 râ2
      ∑ cleanColCons câ1 tâ1 = cleanColCons câ1 tâ2
            ± cleanColCons câ2 tâ1 = cleanColCons câ2 tâ2
            ± cleanRow câ1 (Snd (cleanColCons câ1 tâ1)) râ1
              = cleanRow câ1 (Snd (cleanColCons câ1 tâ2)) râ2
          ¥ cleanRow câ2 (Snd (cleanColCons câ2 tâ1)) râ1
            = cleanRow câ2 (Snd (cleanColCons câ2 tâ2)) râ2) 
=TEX


\subsection{$cleanTable$ Lemma}
=SML
push_goal([],¨µ câ1 câ2 ∑ câ1 dominates câ2 ¥ µ tâ1 tâ2 ∑ 
	cleanTable câ1 tâ1 = cleanTable câ1 tâ2 ¥ cleanTable câ2 tâ1 = cleanTable câ2 tâ2Æ);
a(rewrite_tac[cleanTable_def] THEN REPEAT µ_tac THEN strip_tac THEN REPEAT µ_tac);
a(cases_tac¨câ2 dominates TS_class tâ1Æ THEN cases_tac ¨câ2 dominates TS_class tâ2Æ
	 THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "1" *** *)
a(lemma_tac¨câ1 dominates TS_class tâ1Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,4][][dominates_trans],asm_rewrite_tac[]]);
a(lemma_tac¨câ1 dominates TS_class tâ2Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,5][][dominates_trans],asm_rewrite_tac[]]);
a(rewrite_tac[tab_components,get_spec¨MkTableSpecÆ]);
a(strip_tac THEN asm_rewrite_tac[]);
a(strip_asm_tac (list_µ_elim[¨cleanColCons câ1 tâ1Æ,¨cleanColCons câ1 tâ2Æ]pair_eq_thm));
a(rewrite_tac[taut_rule¨µ a b c∑(a ± (b ± c)) = ((b ± a) ± c)Æ,pair_eq_thm]);
a(DROP_NTH_ASM_T 4 (fn _ => id_tac)
	THEN DROP_NTH_ASM_T 3 (fn _ => id_tac));
a(strip_asm_tac(list_µ_elim[¨câ1Æ,¨câ2Æ,¨tâ1Æ,¨tâ2Æ]cleanColCons_lemma));
a(±_tac THEN_LIST[asm_rewrite_tac[],id_tac]);
=TEX
=SML
a(DROP_NTH_ASM_T 3 ante_tac);
a(lemma_tac¨∂ l ∑ TS_rows tâ1 = lÆTHEN_LIST
	[prove_∂_tac,POP_ASM_T rewrite_thm_tac]);
a(lemma_tac¨∂ l1 ∑ TS_rows tâ2 = l1ÆTHEN_LIST
	[prove_∂_tac,POP_ASM_T rewrite_thm_tac]);
a(intro_µ_tac(¨l1Æ,¨l':Row LISTÆ));
a(rewrite_tac[cleanRows_def]);
a(LIST_INDUCTION_T¨lÆasm_tac);
(* *** Goal "1.1" *** *)
a(rewrite_tac[map_def,map_null_thm]);
a µ_tac;
a(LIST_INDUCTION_T¨l'Æasm_tac);
=TEX
=SML
(* *** Goal "1.1.1" *** *)
a(rewrite_tac[˘_def]);
(* *** Goal "1.1.2" *** *)
a(rewrite_tac[˘_def]);
a strip_tac;
a(cases_tac¨câ2 dominates R_exist xÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.1.2.1" *** *)
a(lemma_tac¨câ1 dominates R_exist xÆ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][2,11][][dominates_trans],asm_rewrite_tac[]]);
(* *** Goal "1.1.2.2" *** *)
a(cases_tac¨câ1 dominates R_exist xÆ THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "1.2" *** *)
a(rewrite_tac[µ_reorder_conv¨µ l' x 
           ∑ Map
                   (cleanRow câ1 (Snd (cleanColCons câ1 tâ1)))
                   (Cons x l ˘ {r|câ1 dominates R_exist r})
                 = Map
                   (cleanRow câ1 (Snd (cleanColCons câ1 tâ2)))
                   (l' ˘ {r|câ1 dominates R_exist r})
               ¥ Map
                   (cleanRow câ2 (Snd (cleanColCons câ2 tâ1)))
                   (Cons x l ˘ {r|câ2 dominates R_exist r})
                 = Map
                   (cleanRow câ2 (Snd (cleanColCons câ2 tâ2)))
                   (l' ˘ {r|câ2 dominates R_exist r})Æ¨µ x l'
           ∑ Map
                   (cleanRow câ1 (Snd (cleanColCons câ1 tâ1)))
                   (Cons x l ˘ {r|câ1 dominates R_exist r})
                 = Map
                   (cleanRow câ1 (Snd (cleanColCons câ1 tâ2)))
                   (l' ˘ {r|câ1 dominates R_exist r})
               ¥ Map
                   (cleanRow câ2 (Snd (cleanColCons câ2 tâ1)))
                   (Cons x l ˘ {r|câ2 dominates R_exist r})
                 = Map
                   (cleanRow câ2 (Snd (cleanColCons câ2 tâ2)))
                   (l' ˘ {r|câ2 dominates R_exist r})Æ]);
=TEX
=SML
a µ_tac;
a(LIST_INDUCTION_T¨l'Æasm_tac);
(* *** Goal "1.2.1" *** *)
a(rewrite_tac[˘_def] THEN µ_tac);
a(cases_tac¨câ2 dominates R_exist xÆ THEN TOP_ASM_T rewrite_thm_tac);
(* *** Goal "1.2.1.1" *** *)
a(lemma_tac¨câ1 dominates R_exist xÆ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][2,4][][dominates_trans],
	TOP_ASM_T rewrite_thm_tac]);
a(rewrite_tac[map_def]);
(* *** Goal "1.2.1.2" *** *)
a(cases_tac¨câ1 dominates R_exist xÆ THEN TOP_ASM_T rewrite_thm_tac);
(* *** Goal "1.2.1.2.1" *** *)
a(rewrite_tac[map_def]);
(* *** Goal "1.2.1.2.2" *** *)
a(DROP_NTH_ASM_T 3(ante_tac o µ_elim¨[]:Row LISTÆ));
a(rewrite_tac[map_def]);
=TEX
=SML
(* *** Goal "1.2.2" *** *)
a(rewrite_tac[˘_def]);
a(REPEAT µ_tac);
a(cases_tac¨câ2 dominates R_exist xÆ 
	THEN TOP_ASM_T rewrite_thm_tac THEN cases_tac¨câ2 dominates R_exist x'Æ 
	THEN TOP_ASM_T rewrite_thm_tac);
(* *** Goal "1.2.2.1" *** *)
a(lemma_tac¨câ1 dominates R_exist xÆ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,14][][dominates_trans],
	TOP_ASM_T rewrite_thm_tac]);
a(lemma_tac¨câ1 dominates R_exist x'Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,14][][dominates_trans],
	TOP_ASM_T rewrite_thm_tac]);
a(rewrite_tac[map_def]);
=TEX
=SML
a(DROP_NTH_ASM_T 6 (asm_tac o µ_elim¨l'Æ));
a(strip_asm_tac(list_µ_elim[¨câ1Æ,¨câ2Æ]cleanRow_lemma));
a(POP_ASM_T (ante_tac o list_µ_elim[¨tâ1Æ,¨tâ2Æ,¨x'Æ,¨xÆ]));
a(asm_rewrite_tac[] THEN ¥_T asm_tac);
a strip_tac;
a(DROP_NTH_ASM_T 4 ante_tac THEN DROP_NTH_ASM_T 3 ante_tac
	THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1.2.2.2" *** *)
a(lemma_tac¨câ1 dominates R_exist xÆ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,14][][dominates_trans],
	TOP_ASM_T rewrite_thm_tac]);
a(cases_tac ¨câ1 dominates R_exist x'ÆTHEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.2.1" *** *)
a(rewrite_tac[map_def] THEN strip_tac);
a(DROP_NTH_ASM_T 2
	(ante_tac o rewrite_rule[cleanRow_def,row_components,get_spec¨MkRowÆ]));
a strip_tac;
a(DROP_NTH_ASM_T 6 ante_tac THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "1.2.2.2.2" *** *)
a(rewrite_tac[map_def] THEN strip_tac);
a(DROP_NTH_ASM_T 7(ante_tac o µ_elim¨Cons x l'Æ));
a(asm_rewrite_tac[map_def,˘_def]);
(* *** Goal "1.2.2.3" *** *)
a(lemma_tac¨câ1 dominates R_exist x'Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][2,14][][dominates_trans],
	TOP_ASM_T rewrite_thm_tac]);
a(cases_tac ¨câ1 dominates R_exist xÆTHEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.3.1" *** *)
a(rewrite_tac[map_def] THEN strip_tac);
a(DROP_NTH_ASM_T 2(ante_tac o 
	rewrite_rule[cleanRow_def,row_components,get_spec¨MkRowÆ]));
a strip_tac;
a(DROP_NTH_ASM_T 6 ante_tac THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "1.2.2.3.2" *** *)
a(rewrite_tac[map_def] THEN strip_tac);
a(DROP_NTH_ASM_T 6(ante_tac o µ_elim¨x'Æ));
a(asm_rewrite_tac[map_def,˘_def]);
(* *** Goal "1.2.2.4" *** *)
a(cases_tac ¨câ1 dominates R_exist xÆTHEN cases_tac ¨câ1 dominates R_exist x'Æ
	THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.4.1" *** *)
a(rewrite_tac[map_def] THEN strip_tac);
a(DROP_NTH_ASM_T 8 (ante_tac o µ_elim¨l'Æ)THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "1.2.2.4.2" *** *)
a(rewrite_tac[map_def] THEN strip_tac);
a(DROP_NTH_ASM_T 7(ante_tac o µ_elim¨Cons x l'Æ));
a(asm_rewrite_tac[map_def,˘_def]);
(* *** Goal "1.2.2.4.3" *** *)
a(rewrite_tac[map_def] THEN strip_tac);
a(DROP_NTH_ASM_T 6(ante_tac o µ_elim¨x'Æ));
a(asm_rewrite_tac[map_def,˘_def]);
(* *** Goal "1.2.2.4.4" *** *)
a(strip_tac THEN  DROP_NTH_ASM_T 7(ante_tac o µ_elim¨l'Æ) THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "2" *** *)
a(lemma_tac¨câ1 dominates TS_class tâ1Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,4][][dominates_trans],asm_rewrite_tac[]]);
a(cases_tac¨câ1 dominates TS_class tâ2ÆTHEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a(rewrite_tac[tab_components,get_spec¨MkTableSpecÆ]);
a strip_tac;
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[tab_components,get_spec¨MkTableSpecÆ,stubTable_def]);
a(strip_tac THEN asm_rewrite_tac[]);
a(rewrite_tac[taut_rule¨µ a b c∑(a ± (b ± c)) = ((b ± a) ± c)Æ]);
a strip_tac;
=TEX
=SML
(* *** Goal "2.2.1" *** *)
a(ante_tac(list_µ_elim[¨câ1Æ,¨câ2Æ,¨tâ1Æ]Ä_cleanColCons_lemma));
a(asm_rewrite_tac[Ä_ö_thm] THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(POP_ASM_T ante_tac THEN 
	rewrite_tac[cleanRows_def,map_null_thm,˘_thm4,sets_ext_clauses]);
a(REPEAT strip_tac);
=TEX
=SML
(* *** Goal "2.2.2.1" *** *)
a(lemma_tac¨câ1 dominates R_exist xÆ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,13][][dominates_trans],id_tac]);
a(DROP_NTH_ASM_T 4 (strip_asm_tac o µ_elim¨xÆ));
(* *** Goal "2.2.2.2" *** *)
a(lemma_tac¨câ1 dominates R_exist x'Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][2,13][][dominates_trans],basic_res_tac1 1[]]);
=TEX
=SML
(* *** Goal "3" *** *)
a(lemma_tac¨câ1 dominates TS_class tâ2Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][2,4][][dominates_trans],asm_rewrite_tac[]]);
a(cases_tac¨câ1 dominates TS_class tâ1ÆTHEN asm_rewrite_tac[]);
(* *** Goal "3.1" *** *)
a(rewrite_tac[tab_components,get_spec¨MkTableSpecÆ]);
a strip_tac;
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "3.2" *** *)
a(rewrite_tac[tab_components,get_spec¨MkTableSpecÆ,stubTable_def]);
a strip_tac;
a(DROP_NTH_ASM_T 5(rewrite_thm_tac o eq_sym_rule));
a(DROP_NTH_ASM_T 4(rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[taut_rule¨µ a b c∑(a ± (b ± c)) = ((b ± a) ± c)Æ] THEN strip_tac);
(* *** Goal "3.2.1" *** *)
a(ante_tac(list_µ_elim[¨câ1Æ,¨câ2Æ,¨tâ2Æ]Ä_cleanColCons_lemma));
a(DROP_NTH_ASM_T 3 (rewrite_thm_tac o eq_sym_rule));
a(DROP_NTH_ASM_T 2 (rewrite_thm_tac o eq_sym_rule));
a(asm_rewrite_tac[Ä_ö_thm1] THEN REPEAT strip_tac);
=TEX
=SML
(* *** Goal "3.2.2" *** *)
a(POP_ASM_T ante_tac THEN 
	rewrite_tac[cleanRows_def,map_null_thm,˘_thm4,sets_ext_clauses]);
a(REPEAT strip_tac);
(* *** Goal "3.2.2.1" *** *)
a(lemma_tac¨câ1 dominates R_exist xÆ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,11][][dominates_trans],id_tac]);
a(DROP_NTH_ASM_T 4 (strip_asm_tac o µ_elim¨xÆ));
=TEX
=SML
(* *** Goal "3.2.2.2" *** *)
a(lemma_tac¨câ1 dominates R_exist x'Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][2,11][][dominates_trans],basic_res_tac1 1[]]);
val €cleanTable_lemma› = save_pop_thm"cleanTable_lemma";
=TEX
=GFT
cleanTable_lemma =
Ù µ câ1 câ2
  ∑ câ1 dominates câ2
      ¥ (µ tâ1 tâ2
      ∑ cleanTable câ1 tâ1 = cleanTable câ1 tâ2
          ¥ cleanTable câ2 tâ1 = cleanTable câ2 tâ2)
=TEX
\subsection{$cleanDirectory$ Lemma}

=SML
push_goal([],¨µ câ1 câ2 ∑ câ1 dominates câ2 ¥ µ dâ1 dâ2 ∑ 
	cleanDirectory câ1 dâ1 = cleanDirectory câ1 dâ2 
	¥ cleanDirectory câ2 dâ1 = cleanDirectory câ2 dâ2Æ);
a(REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN rewrite_tac[cleanDirectory_def]);
a(cases_tac¨câ2 dominates Dir_class dâ1Æ THEN cases_tac ¨câ2 dominates Dir_class dâ2Æ
	 THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "1" *** *)
a(lemma_tac¨câ1 dominates Dir_class dâ1Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,4][][dominates_trans],asm_rewrite_tac[]]);
a(lemma_tac¨câ1 dominates Dir_class dâ2Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,5][][dominates_trans],asm_rewrite_tac[]]);
a(rewrite_tac[dir_components,get_spec¨MkDirectoryÆ]THEN REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨câ1Æ,¨câ2Æ]cleanTable_lemma));
a(ante_tac (list_µ_elim[¨cleanTable câ1Æ,¨cleanTable câ2Æ,
	¨Dir_tables dâ1Æ,¨Dir_tables dâ2Æ]rel_thm) THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "2" *** *)
a(lemma_tac¨câ1 dominates Dir_class dâ1Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][3,4][][dominates_trans],asm_rewrite_tac[]]);
a(cases_tac¨câ1 dominates Dir_class dâ2ÆTHEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a(rewrite_tac[dir_components,get_spec¨MkDirectoryÆ]THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 7 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[dir_components,get_spec¨MkDirectoryÆ]THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN rewrite_tac[graph_thm,r_ª_r_thm,rel_ext_clauses]);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o list_µ_elim[¨xÆ,¨cleanTable câ1 zÆ]));
a(POP_ASM_T (strip_asm_tac o µ_elim¨zÆ));
=TEX
=SML
(* *** Goal "3" *** *)
a(lemma_tac¨câ1 dominates Dir_class dâ2Æ THEN_LIST 
	[contr_tac THEN basic_res_tac4 2 [1][2,4][][dominates_trans],asm_rewrite_tac[]]);
a(cases_tac¨câ1 dominates Dir_class dâ1ÆTHEN asm_rewrite_tac[]);
(* *** Goal "3.1" *** *)
a(rewrite_tac[dir_components,get_spec¨MkDirectoryÆ]THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 7 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(rewrite_tac[dir_components,get_spec¨MkDirectoryÆ]THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN rewrite_tac[graph_thm,r_ª_r_thm,rel_ext_clauses]);
=TEX
=SML
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o list_µ_elim[¨xÆ,¨cleanTable câ1 zÆ]));
a(POP_ASM_T (strip_asm_tac o µ_elim¨zÆ));
(* *** Goal "4" *** *)
a(cases_tac¨câ1 dominates Dir_class dâ1ÆTHEN cases_tac¨câ1 dominates Dir_class dâ2Æ 
	THEN asm_rewrite_tac[dir_components,get_spec¨MkDirectoryÆ]
	THEN REPEAT strip_tac);
val €cleanDirectory_lemma› = save_pop_thm"cleanDirectory_lemma";
=TEX
=GFT
cleanDirectory_lemma = 
Ù µ câ1 câ2
  ∑ câ1 dominates câ2
      ¥ (µ dâ1 dâ2
      ∑ cleanDirectory câ1 dâ1 = cleanDirectory câ1 dâ2
          ¥ cleanDirectory câ2 dâ1 = cleanDirectory câ2 dâ2)
=TEX
\subsection{$hide$ Lemma}
First, two lemmas about directories.
=SML
push_goal([],¨µ câ1 câ2 s x y ∑ câ1 dominates câ2 ¥ 
	((x,y) ç s í {dir|câ2 dominates Dir_exist dir} 
	¥ (x,y) ç s í {dir|câ1 dominates Dir_exist dir})Æ);
a(rewrite_tac[í_thm]THEN REPEAT strip_tac);
a(contr_tac THEN basic_res_tac4 2 [1][3,4][][dominates_trans]);
val Ä_dir_lemma = save_pop_thm"Ä_dir_lemma";
=TEX
=GFT
Ä_dir_lemma = 
Ù µ câ1 câ2 s x y
  ∑ câ1 dominates câ2
      ¥ (x, y) ç s í {dir|câ2 dominates Dir_exist dir}
      ¥ (x, y) ç s í {dir|câ1 dominates Dir_exist dir}
=TEX
=SML
push_goal([],¨µ c câ1 s  sâ1 x z zâ1
    ∑ (cleanDirectory câ1 z = cleanDirectory câ1 zâ1
	± (x, z) ç s í {dir|câ1 dominates Dir_exist dir}
	± (x, zâ1) ç sâ1 í {dir|c dominates Dir_exist dir})
	¥ (x, zâ1) ç sâ1 í {dir|câ1 dominates Dir_exist dir}Æ);
a(rewrite_tac[cleanDirectory_def,dir_components,get_spec¨MkDirectoryÆ,í_thm]
	THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
val dir_class_preserved_lemma = save_pop_thm"dir_class_preserved_lemma";
=GFT
dir_class_preserved_lemma =
Ù µ c câ1 s sâ1 x z zâ1
  ∑ cleanDirectory câ1 z = cleanDirectory câ1 zâ1
        ± (x, z) ç s í {dir|câ1 dominates Dir_exist dir}
        ± (x, zâ1) ç sâ1 í {dir|c dominates Dir_exist dir}
      ¥ (x, zâ1) ç sâ1 í {dir|câ1 dominates Dir_exist dir}
=TEX
Now the main result that $hide$ is a member of $secureHide$.

=SML
push_goal([],¨hide ç secureHideÆ);
a(rewrite_tac[hide_def,secureHide_def]);
a(REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨câ1Æ,¨câ2Æ]cleanDirectory_lemma));
a(DROP_NTH_ASM_T 3 ante_tac);
a(rewrite_tac[r_ª_r_thm,rel_ext_clauses,graph_thm]THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(list_µ_elim[¨câ1Æ,¨câ2Æ,¨sâ1Æ,¨xÆ,¨zÆ]Ä_dir_lemma));
a(DROP_NTH_ASM_T 4 (asm_tac o list_µ_elim[¨xÆ,¨cleanDirectory câ1 zÆ]));
a(LEMMA_T¨∂ z'
             ∑ (x, z') ç sâ1 í {dir|câ1 dominates Dir_exist dir}
                 ± cleanDirectory câ1 z = cleanDirectory câ1 z'Æasm_tac);
(* *** Goal "1.1" *** *)
a(∂_tac¨zÆ THEN asm_prove_tac[]);
=TEX
=SML
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN POP_ASM_T rewrite_thm_tac);
a ¥_tac;
a(DROP_NTH_ASM_T 6(strip_asm_tac o list_µ_elim[¨zÆ,¨z'Æ]));
a(∂_tac¨z'Æ THEN asm_rewrite_tac[]);
a(strip_asm_tac (list_µ_elim[¨câ1Æ,¨câ2Æ,¨sâ1Æ,¨sâ2Æ,¨xÆ,¨zÆ,¨z'Æ]dir_class_preserved_lemma));
(* *** Goal "2" *** *)
a(strip_asm_tac (list_µ_elim[¨câ1Æ,¨câ2Æ,¨sâ2Æ,¨xÆ,¨zÆ]Ä_dir_lemma));
a(DROP_NTH_ASM_T 4 (asm_tac o list_µ_elim[¨xÆ,¨cleanDirectory câ1 zÆ]));
a(LEMMA_T¨∂ z'
             ∑ (x, z') ç sâ2 í {dir|câ1 dominates Dir_exist dir}
                 ± cleanDirectory câ1 z = cleanDirectory câ1 z'Æasm_tac);
(* *** Goal "2.1" *** *)
a(∂_tac¨zÆ THEN asm_prove_tac[]);
=TEX
=SML
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN POP_ASM_T rewrite_thm_tac);
a ¥_tac;
a(DROP_NTH_ASM_T 6(strip_asm_tac o list_µ_elim[¨zÆ,¨z'Æ]));
a(∂_tac¨z'Æ THEN asm_rewrite_tac[]);
a(strip_asm_tac (list_µ_elim[¨câ1Æ,¨câ2Æ,¨sâ2Æ,¨sâ1Æ,¨xÆ,¨zÆ,¨z'Æ]dir_class_preserved_lemma));
val €secureHide_lemma› = save_pop_thm"secureHide_lemma";
=TEX
=GFT
secureHide_lemma = Ù hide ç secureHide
=TEX
\section{CLOSING DOWN}
The following ICL HOL instruction restores the previous proof context.
=SML
pop_pc();
=TEX

\newpage
\input{fef010th.tex}

\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}

