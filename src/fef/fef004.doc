=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Specifications of $hide$ and $updateState$}  %% Mandatory field
\TPPref{DS/FMU/FEF/004}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{The formal specifications of the functions $hide$ and $updateState$  for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[1.1] First draft version.
\item[Issue \SCCSversion ({\FormatDate{$Date$
}}) ] Changes made after review. Translation into ICL HOL.
\end{description}

\subsection{Changes Forecast}
Changes  may be necessary  as a result of issues raised
during  the transcription of the specification.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document gives a formal specification of the functions $hide$ and $updateState$. It constitutes deliverable D2 of work package 1a, as given
in section 7 of the Secure Database Technical Proposal, \cite{DS/FMU/017}.

\subsection{Introduction}
In the Secure Database Technical Proposal, \cite{DS/FMU/017}, we stated that we propose to formalise the semantics of SSQL, supplied initially in Annex 2, {\em SSQL Abstract Machine}, to the ITT \cite{ittdra}, in a manner suitable for the required security proof, as 
outlined in \cite{DS/FMU/017}.  This involves the specific
features of the semantics which ensure that query 
processing is $secure$ be clearly separated from the purely functional aspects. This results in the formalisation of the semantics of
SSQL being presented in three main parts:
\begin{enumerate}
\item
A function $hide$ on the state of the database which returns a sanitised state of the database. This version of the database does not
include any information the existence
of which the user is not cleared to know, nor does it contain the true value of any field which the user is not cleared to see.
\item
The main functionality of SSQL, i.e. how the 
result of a query is computed from the state of the database.
\item
A function $updateState$ which applies the update determined in (2) to the database.This function is responsible for capturing the security
constraints associated with updates.
\end{enumerate}

This document provides the functions $hide$ and $updateState$ described above.
\subsection{Terminology}

Labelled products with names of the form $Xxxx$ will have labels prefixed by $X\_$; labelled products with
 names of the form $XxxxYyyy$ will have labels prefixed by $XY\_$. The only exceptions to this
will be in the case where two labelled products would have identical labels, e.g.
$Data$ and $Directory$ will have labels prefixed by $Dat\_$ and $Dir\_$ respectively.
\section{PRELIMINARIES}
The following ICL HOL instructions set up the new theory $fef004$.
=SML 
open_theory "fef003";
new_theoryÛ"fef004"İ;
set_cache_theories ["hol"];
push_merge_pcs ["sets_ext","prove_¶"];
=TEX
\section{DATA TYPES IN THE STATE}
In this section, we provide formal specifications of enough of the SSQL semantics to enable the state of the system to be defined.


The types $CHAR$, $STRING$, $î$ and $BOOL$ are already defined in the system.

=SML
declare_type_abbrev(Û"Char"İ,[],” CHAR®);
=TEX

=SML
declare_type_abbrev(Û"String"İ,[],” STRING®);
=TEX

=SML
declare_type_abbrev(Û"Num"İ,[],” î®);
=TEX

=SML
declare_type_abbrev(Û"Bool"İ,[],” BOOL®);
=TEX

=SML
declare_type_abbrev(Û"Ide"İ,[],” String®);
=TEX

¹HOLLABPROD ÛIntİüüüüüüüüüüü
Ü	ÛI_mantissaİ 	: Num;
Ü	ÛI_exponentİ	: Num
°üüüüüüüüüüüüüüüüüüüüü


¹HOLLABPROD ÛFloatİüüüüüüüüüüüüü
Ü	ÛF_mantissaİ 	: Num;
Ü	ÛF_exponentİ	: Num
°üüüüüüüüüüüüüüüüüüüüüüüüü



We introduce new types $Time$, $Interval$ and $Code$.

=SML
new_type(Û"Time"İ,0);
=TEX

=SML
new_type(Û"Interval"İ,0);
=TEX

=SML
new_type(Û"Code"İ,0);
=TEX


We have removed `error' from the domain of possible errors
since things that are partial functions
will be modelled as partial functions. The different `sorts' of errors are modelled
as natural numbers.

¹HOLCONST
Ü	ÛnotClearedİ ÛtooWideİ ÛtooTallİ ÛwrongTypeİ
Ü	ÛnullValueİ ÛnoSuchColumnİ ÛambigiousColumnİ
Ü	ÛambigiousUpdateİ ÛmayNotBeCompleteİ 
Ü	ÛunderClassifiedİ ÛdownGradeİ ÛclassChangeİ
Ü	ÛnoSuchTableİ ÛnoSuchDirectoryİ 
Ü	ÛambiguousEvaluateİ ÛambiguousHavingİ
Ü	ÛnonUniformValuesİ ÛnonUniqueValuesİ 
Ü	ÛnoNullsİ ÛfieldClassOutOfRangeİ
Ü	ÛrowClassTooLowİ ÛaccessDeniedİ		: Num
÷üüüüüüüüüüüüüü
Ü	notCleared		= 1 
Ü±	tooWide		= 2
Ü±	tooTall			= 3
Ü±	wrongType		= 4
Ü± 	nullValue		= 5
Ü± 	noSuchColumn	= 6
Ü±	ambigiousColumn	= 7 	
Ü±	ambigiousUpdate	= 8
Ü±	mayNotBeComplete	= 9
Ü±	underClassified	= 10
Ü±	downGrade   		= 11 
Ü±	classChange  		= 12
Ü±	noSuchTable  		= 13
Ü±	noSuchDirectory 	= 14
Ü±	ambiguousEvaluate 	= 15
Ü±	ambiguousHaving 	= 16 
Ü±	nonUniformValues 	= 17
Ü±	nonUniqueValues 	= 18 
Ü±	noNulls 		= 19 
Ü±	fieldClassOutOfRange = 20
Ü±	rowClassTooLow	= 21
Ü±	accessDenied 		= 22
°

=SML
declare_type_abbrev(Û"Error"İ,[],” Num®);
=TEX


The different `sorts' of worth are also modelled
as natural numbers.

¹HOLCONST
Ü	Ûworthlessİ Ûdinaryİ Ûsterlingİ Ûpricelessİ	: Num
÷üüüüüüüüüüüüüü
Ü	worthless	= 1 
Ü±	dinary		= 2
Ü±	sterling		= 3
Ü±	priceless	= 4
°

=SML
declare_type_abbrev(Û"Worth"İ,[],” Num®);
=TEX


$Val$ is declared as a sum type (i.e. binary disjoint union). The `types' ${void}$ and ${exception}$ are given as one-point types. 

=SML
declare_type_abbrev(Û"Val"İ,[],
	” ONE + Bool + String + Int + Float + Time + Interval + Class + ONE®);
=TEX
We give constructors for type $Val$.


¹HOLCONST
Ü	ÛVoidValİ 		: ONE ­ Val;
Ü	ÛBoolValİ 		: Bool ­ Val;
Ü	ÛStringValİ 		: String ­ Val;
Ü	ÛIntValİ			: Int ­ Val;
Ü	ÛFloatValİ		: Float ­ Val;
Ü	ÛTimeValİ		: Time ­ Val;
Ü	ÛIntervalValİ		: Interval ­ Val;
Ü	ÛClassValİ		: Class ­ Val;
Ü	ÛExceptionValİ	: ONE ­ Val
÷üüüüüüüüüüüüüü
Ü	µx‰1 ·	VoidVal x‰1		= InL x‰1
Ü±	µx‰2·	BoolVal	x‰2 	= InR (InL x‰2)
Ü±	µx‰3 ·	StringVal x‰3 	 	= InR (InR (InL x‰3))
Ü±	µx‰4 · 	IntVal x‰4 		= InR (InR (InR (InL x‰4)))
Ü±	µx‰5 ·	FloatVal x‰5		= InR (InR (InR (InR (InL x‰5))))
Ü±	µx‰6 ·	TimeVal x‰6		= InR (InR (InR (InR (InR (InL x‰6)))))
Ü±	µx‰7 ·	IntervalVal x‰7		= InR (InR (InR (InR (InR (InR (InL x‰7))))))
Ü±	µx‰8 · 	ClassVal x‰8		= InR (InR (InR (InR (InR (InR (InR (InL x‰8)))))))
Ü±	µx‰9 ·	ExceptionVal x‰9	= InR (InR (InR (InR (InR (InR (InR (InR x‰9)))))))
°


¹HOLLABPROD ÛValuedItemİüüüüüüüüüüüüü
Ü	ÛVI_worthİ 	: Num;
Ü	ÛVI_valİ	: Val
°üüüüüüüüüüüüüüüüüüüüüüüüüü

The type ${NullItem}$ is given as a one-point type.

=SML
declare_type_abbrev(Û"NullItem"İ,[],” ONE®);
declare_alias(Û"null"İ,¬One®);
=TEX

$Item$ is declared as a sum type.
=SML
declare_type_abbrev(Û"Item"İ,[],” ValuedItem + NullItem®);
=TEX
We give constructors for type $Item$.

¹HOLCONST
Ü	ÛValuedItemItemİ 	: ValuedItem ­ Item;
Ü	ÛNullItemItemİ 	: NullItem ­ Item
÷üüüüüüüüüüüüüü
Ü	ValuedItemItem	= InL
Ü±	NullItemItem		=InR 
°

¹HOLLABPROD ÛDataİüüüüüüüüü
Ü	ÛDat_classİ 	: Class;
Ü	ÛDat_itemİ	: Item
°üüüüüüüüüüüüüüüüüüü

=SML
declare_type_abbrev(Û"Update"İ,[],” Item + Class + Data®);
=TEX
We need constructor and discriminator functions for $Update$.

¹HOLCONST
Ü	ÛItemUpdateİ 		: Item ­ Update;
Ü	ÛClassUpdateİ 	: Class ­ Update;
Ü	ÛDataUpdateİ 		: Data ­ Update
÷üüüüüüüüüüüüüü
Ü	µ x·	ItemUpdate x	= InL x
Ü±	µ x·	ClassUpdate x	= InR (InL x)
Ü±	µ x·	DataUpdate  x	= InR (InR x)
°

¹HOLCONST
Ü	ÛisItemİ 	: Update ­ Bool;
Ü	ÛisClassİ 	: Update ­ Bool;
Ü	ÛisDataİ 	: Update ­ Bool
÷üüüüüüüüüüüüüü
Ü	µ	u:Update
Ü	·	isItem	 u	= ¶ i:Item 	· u = ItemUpdate i
Ü	±	isClass u	= ¶ c:Class 	· u = ClassUpdate c
Ü	±	isData u	= ¶ d:Data 	· u = DataUpdate d 
°

¹HOLCONST
Ü	ÛdestItemİ 	: Update ­ Item;
Ü	ÛdestClassİ 	: Update ­ Class;
Ü	ÛdestDataİ 	: Update ­ Data
÷üüüüüüüüüüüüüü
Ü	µ	i:Item;c:Class;d:Data
Ü	·	destItem (ItemUpdate i) = i 
Ü	±	destClass(ClassUpdate c) = c
Ü	±	destData (DataUpdate d) = d 
°



¹HOLLABPROD ÛCharsİüüüüüüüüü
Ü	ÛC_minLengthİ 	: Num;
Ü	ÛC_maxLengthİ	: Num
°üüüüüüüüüüüüüüüüüüü

¹HOLLABPROD ÛIntegerİüüüüüüü
Ü	ÛI_minİ 	: Int;
Ü	ÛI_maxİ	: Int;
Ü	ÛI_scaleİ	: Int
°üüüüüüüüüüüüüüüüüü

¹HOLLABPROD ÛFloatingİüüüüüüüüüüüüü
Ü	ÛF_minMantİ	: Int;
Ü	ÛF_maxMantİ	: Int;
Ü	ÛF_minExpİ	: Int;
Ü	ÛF_maxExpİ	: Int
°üüüüüüüüüüüüüüüüüüüüüüüüü


We give $monolean$, $boolean$, $time$, $interval$ and $class$ as elements of one-point types.
=SML
declare_alias(Û"monolean"İ,¬One®);
declare_alias(Û"boolean"İ,¬One®);
declare_alias(Û"time"İ,¬One®);
declare_alias(Û"interval"İ,¬One®);
declare_alias(Û"class"İ,¬One®);
=TEX



=SML
declare_type_abbrev(Û"Type"İ,[],
	” ONE + ONE + Chars + Integer + Floating + ONE + ONE + ONE®);
=TEX

=SML
declare_type_abbrev(Û"Errors"İ,[],” Error LIST®);
=TEX

¹HOLLABPROD ÛColSpecİüüüüüüüüüüüüüü
Ü	ÛCS_ideİ 		: Ide;
Ü	ÛCS_posnİ		: Num;
Ü	ÛCS_dinaryTypeİ	: Type;
Ü	ÛCS_sterlingTypeİ	: Type;
Ü	ÛCS_nullTypeİ		: Bool;
Ü	ÛCS_defaultİ		: Data;
Ü	ÛCS_consGroupİ		: Num;
Ü	ÛCS_minİ		: Class;
Ü	ÛCS_maxİ		: Class
°üüüüüüüüüüüüüüüüüü





We have removed $Error$ from the state of the data base and will
 provide 
access functions  which return either a data type or an error.

=SML
declare_type_abbrev(Û"Tab"İ,[],” Ide LIST®);
=TEX

¹HOLLABPROD ÛReferenceİüüüüüüüüüüüüüü
Ü	ÛR_tableİ 	: Tab;
Ü	ÛR_groupİ	: Num
°üüüüüüüüüüüüüüüüüü



¹HOLLABPROD ÛColConİüüüüüüüüüüüüüü
Ü	ÛCC_existİ 		: Class;
Ü	ÛCC_uniformİ		: Bool;
Ü	ÛCC_uniqueİ		: Bool;
Ü	ÛCC_classLimitedİ	: Bool;
Ü	ÛCC_primaryİ		: Bool;
Ü	ÛCC_secondaryİ		: Bool;
Ü	ÛCC_referentialİ		: Reference LIST
°üüüüüüüüüüüüüüüüüü



=SML
declare_type_abbrev(Û"ColCons"İ,[],” Num ª ColCon®);
=TEX

¹HOLLABPROD ÛRowİüüüüüüüüüüüüüü
Ü	ÛR_existİ 	: Class;
Ü	ÛR_dataİ		: Num ª Data
°üüüüüüüüüüüüüüüüüü

¹HOLLABPROD ÛTableSpecİüüüüüüüüü
Ü	ÛTS_classİ 		: Class;
Ü	ÛTS_maxRowİ		: Class;
Ü	ÛTS_colspecsİ		: ColSpec ğ;
Ü	ÛTS_consİ		: ColCons;
Ü	ÛTS_rowsİ		: Row LIST
°üüüüüüüüüüüüüüüüüü

=SML
declare_type_abbrev(Û"TableSpecs"İ,[],” Ide ª TableSpec®);
=TEX


¹HOLLABPROD ÛDirectoryİüüüüüüüüüüüüüü
Ü	ÛDir_tablesİ 		: TableSpecs;
Ü	ÛDir_existİ		: Class;
Ü	ÛDir_classİ		: Class
°üüüüüüüüüüüüüüüüüü

=SML
declare_type_abbrev(Û"State"İ,[],” Ide LIST ª Directory®);
=TEX

We have chosen not to model $Result$. A $Result$ is either some $Data$
or just a $Class$ (when the user is not cleared to 
observe the actual value). In effect, we always have some $Data$; in
the case when the user is not cleared to see the value, the value will be $Hidden$ anyway.


\section{$hide$}
\subsection{Hiding a Directory within a State}
Any directories about whose existence the user is 
not classified to know can be removed from the state.



¹HOLCONST
Ü	ÛhideDirectoryİ : Class ¸ State ­ State
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; s : State
Ü	· 	hideDirectory(clear,s) 
Ü		= 
Ü		{i|clear dominates Dir_exist(s @ i)} ò s 
°

NOTE - it may be necessary to introduce a state invariant
to ensure that all sub-directories of a directory about 
whose existence the user is 
not classified to know are also removed from the state.

\subsection{Replacing a Table within a Directory}

A function which replaces a table in a directory with a given table:

¹HOLCONST
Ü	ÛreplaceTableİ : Directory ­ TableSpec ­ Ide ­ Directory
÷üüüüüüüüüüüüüü
Ü	µ dir : Directory;ts : TableSpec;i : Ide
Ü	·	replaceTable dir ts i = 
Ü		MkDirectory ((Dir_tables dir) « {(i,ts)})(Dir_exist dir)(Dir_class dir)
°
\subsection{Hiding a Table within a State}
Any tables  about whose existence the user is 
not classified to know can be hidden from the state. These are all the
tables in a directory whose $class$ component is not
dominated by the user's clearance (i.e. the user is classified to
know the existence of the directory, but is not classified to
see the structure of the directory).
First  these tables  are removed from the directory, then the state
 is amended by replacing the directory with the new directory that has had the tables removed from it.



¹HOLCONST
Ü	ÛhideTableİ : Class ¸ State ­ State
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; s : State;il : Ide LIST  
Ü	·	il  dom s
Ü		´
Ü		hideTable(clear,s) 
Ü		=
Ü		if 	 ³(clear dominates (Dir_class (s @ il)))
Ü		then 	let dir' = MkDirectory {}(Dir_exist (s @ il))(Dir_class (s @ il))
Ü			in 
Ü			s « {(il,dir')}
Ü		else	s
°

In the case where the user is permitted to know of the existence of a table, but is not permitted
to access it, i.e. his clearance does not dominate the table class, an `empty' table is left in the 
directory in place of that table.

¹HOLCONST
Ü	ÛleaveStubİ : Class ¸ State ­ State
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; s : State; il : Ide LIST; i : Ide; dir : Directory
Ü	·	il  dom s ± dir = s @ il ± i  dom (Dir_tables dir)
Ü		´
Ü		leaveStub(clear,s)
Ü		=
Ü		let ts = (Dir_tables dir) @ i
Ü		in
Ü		if	³(clear dominates (TS_class ts))
Ü		then 	let ts' = MkTableSpec(TS_class ts)(TS_maxRow ts){}{}[]
Ü			in
Ü			s « {(il,(replaceTable dir ts' i))}
Ü		else	s
°

		
\subsection{Sanitising a Table}

To `sanitise' a table:
\begin{enumerate}
\item
Remove  any rows about whose existence the user is 
not classified to know.
\item
Remove any  columns about whose existence the user is 
not classified to know. 
\item
Replace data that the user is
not classified to see by  dummy values.
\end{enumerate}
\subsubsection{Remove Rows from Table}
To hide from a table any rows about whose existence the user is 
not classified to know,  remove the relevant rows from the sequence of rows and replace the original rows of the table with this filtered sequence.

An auxiliary function which replaces the rows in a table with  given rows.

¹HOLCONST
Ü	ÛreplaceRowsİ : TableSpec ­ Row LIST ­ TableSpec
÷üüüüüüüüüüüüüü
Ü	µ ts : TableSpec; rs : Row LIST
Ü	·	replaceRows ts rs 
Ü		= 
Ü		MkTableSpec(TS_class ts)(TS_maxRow ts)(TS_colspecs ts)(TS_cons ts) rs
°

Now the function to remove the rows.

¹HOLCONST
Ü	ÛhideRowsİ : Class ¸ TableSpec ­ TableSpec
÷üüüüüüüüüüüüüü
Ü
Ü	µ clear : Class; ts : TableSpec
Ü	· 	hideRows(clear,ts) 
Ü		= 
Ü		replaceRows ts ((TS_rows ts) ù {r:Row|clear dominates (R_exist r)})
°

\subsubsection{Remove Columns from Table}

To hide columns from a table,  it is necessary to check the existence class  
of groups of columns. If the user is 
not classified to know the existence of a group of columns, then the group of columns must be removed from the table. This means removing all reference to the 
identified columns in the $colspecs$  and $colposns$, removing the group number
from the column group constraints and removing the actual data from each row. 
First, identify which groups are to be hidden.
 
¹HOLCONST
Ü	ÛgroupsToHideİ : Class ¸ TableSpec ­ Num ğ
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; ts : TableSpec
Ü	· 	groupsToHide(clear,ts) 
Ü		=  
Ü		{n : Num|³(clear dominates (CC_exist ((TS_cons ts) @ n)))}
°


A function to remove data from  given positions in the row.

¹HOLCONST
Ü	ÛremoveDataİ :  Num ğ­ Row ­ Row
÷üüüüüüüüüüüüüü
Ü	µ r : Row; ns : Num ğ 
Ü	· 	removeData ns r
Ü		=
Ü		MkRow (R_exist r) ({n : Num | n  ns} á (R_data r))
°

A function to  hide  groups of columns from a table.

¹HOLCONST
Ü	ÛhideGroupsİ : TableSpec ­ Num ğ ­ TableSpec
÷üüüüüüüüüüüüüü
Ü
Ü	µ ts : TableSpec;ns: Num ğ
Ü	·	hideGroups ts ns
Ü		=
Ü		let	colspecs = (TS_colspecs ts) \ {cs : ColSpec|(CS_consGroup cs)  ns}
Ü		and	cons = ns  á (TS_cons ts)
Ü		and 	rows = Map (removeData ns)(TS_rows ts)
Ü		in	MkTableSpec(TS_class ts) (TS_maxRow ts) colspecs cons rows
°


Finally, hide from a table all groups of columns about whose existence the user is 
not classified to know.


¹HOLCONST
Ü	ÛhideColsİ : Class ¸ TableSpec  ­ TableSpec
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; ts: TableSpec; ns: Num ğ
Ü	· 	hideCols(clear,ts) 
Ü		=
Ü		hideGroups ts (groupsToHide(clear,ts))	
°


\subsubsection{Replace Data in a Row with Dummy Data}

Data consists of a classification and an item of data. An item of data that a 
user is not cleared to see is replaced by a dummy string $Hidden$
(its classification remains).

¹HOLCONST
Ü	ÛHiddenİ : String
÷üüüüüüüüüüüüüü
Ü	T	
°

¹HOLCONST
Ü	ÛdummyValİ : Val
÷üüüüüüüüüüüüüü
Ü	dummyVal = StringVal Hidden	
°


A function to replace  the value of a piece of data 
 that the user is
not cleared to see by a dummy value. 

¹HOLCONST
Ü
Ü	ÛcleanDataİ : Class ­ Data ­ Data
÷üüüüüüüüüüüüüü
Ü	µ clear : Class;d : Data
Ü	·	cleanData clear d
Ü		=
Ü		if ³(clear dominates (Dat_class d))
Ü		then	MkData (Dat_class d)
Ü			(ValuedItemItem (MkValuedItem worthless dummyVal))
Ü		else 	d
°


A function to clean all the data in  a row.

¹HOLCONST
Ü
Ü	ÛcleanRowİ : Class ­ Row ­ Row
÷üüüüüüüüüüüüüü
Ü	µ clear : Class;r: Row
Ü	·	cleanRow clear r 
Ü		= 
Ü		MkRow (R_exist r)((R_data r) o (cleanData clear))
°

\subsubsection{Clean all Data in a Table}

$cleanTable$ brings together the functions from the above three subsections.

¹HOLCONST
Ü	ÛcleanTableİ : Class ¸ TableSpec ­ TableSpec
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; ts:TableSpec
Ü	·	cleanTable(clear,ts)
Ü		=
Ü		let ts' = hideCols(clear,hideRows(clear,ts))
Ü		in		 
Ü		replaceRows ts'(Map (cleanRow clear)(TS_rows ts'))
°

\subsection{Specification of $hide$}

The $hide$ function takes a state and :
\begin{itemize}
\item
Hides all directories about whose existence the user is not classified to know.
\item
Hides all tables about whose existence the user is not classified to know.
\item
Replaces all tables the user is not permitted to access by `empty' tables.
\item
Replaces all directories by directories whose tables have been `cleaned'. i.e. have
been replaced by tables where all rows and columns  about whose 
existence the user is not classified to know are hidden, and all data the user is
not classified to see has been replaced by dummy data.
\end{itemize}

¹HOLCONST
Ü	Ûhideİ : Class ¸ State ­ State
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; s: State; il : Ide LIST;i : Ide; dir : Directory
Ü	·	il  dom s ± dir = s @ il ± i  dom (Dir_tables dir)
Ü		´			
Ü		hide(clear,s)   
Ü		=  
Ü		let ts = (Dir_tables dir) @ i
Ü		and s' = leaveStub(clear,hideTable(clear,hideDirectory(clear,s)))
Ü		in		
Ü		s' « {(il,(replaceTable dir (cleanTable(clear,ts))i))}
°

\section{$updateState$}
We have not taken into account that it may be necessary to have as a state invariant
that  column existence classifications
are in ascending order.
\subsection{Auxiliary Functions}


When a user makes an update request on a row, the position of the row in
a table will be its position after rows about whose existence the user is 
not classified to know have been hidden. We require a function that reveals the true  row position given the 
hidden row position.
=SML
declare_alias("#",¬Length®);
=TEX

¹HOLCONST
Ü	Ûrevealİ : Class ­ TableSpec ­ Num ª Num
÷üüüüüüüüüüüüüü
Ü	µ clear: Class;ts : TableSpec
Ü	· 	reveal clear ts 
Ü		= 
Ü		Squash(id(dom((listrel (TS_rows ts)) ’ {r:Row|clear dominates (R_exist r)}))) 
°

We provide the auxiliary function $changeSpec$ (from Annex 2 {\em SSQL Abstract Machine})  which takes a full table name and a table and gives a new state.

¹HOLCONST
Ü	ÛchangeSpecİ : Tab ­ TableSpec ­ State ­ State
÷üüüüüüüüüüüüüü
Ü	µ clear : Class; s : State; il : Ide LIST;i : Tab; dir : Directory;ts : TableSpec
Ü	· 	il  dom s ± dir = s @ il ± 
Ü		Last i  dom (Dir_tables dir) ± ts = (Dir_tables dir) @ (Last i)
Ü		´
Ü		changeSpec i ts s	
Ü		= 
Ü		s « {(il,(replaceTable dir ts (Last i)))}
°

General constructor, discriminator and destructor functions for a sum type where one component is  an error or sequence of errors.

¹HOLCONST
Ü	ÛgiveValİ 	: 'a ­ 'a + 'Error;
Ü	ÛgiveErrorİ 	: 'Error ­ 'a + 'Error;
Ü	ÛdestValİ	: 'a + 'Error ­ 'a;
Ü	ÛdestErrorİ	: 'a + 'Error ­ 'Error;
Ü	ÛisValİ		: 'a + 'Error ­ Bool;
Ü	ÛisErrorİ	: 'a + 'Error ­ Bool
÷üüüüüüüüüüüüüü
Ü	µ v; e; ve 
Ü	·	giveVal v			= InL v
Ü	±	giveError e			= InR e
Ü	±	destVal (giveVal v)		= v 
Ü	±	destError(giveError e)	= e	
Ü	±	isVal ve 			= ¶ v‰1 · ve = giveVal v‰1
Ü	±	isError ve			= ¶ e‰1 · ve = giveError e‰1
°


\subsection{Type of $Effect$}
The functionality of the semantics of SSQL will be captured by the function $process\_query$ ,described in \cite{DS/FMU/017}.
This function takes a query, a user's classification and a state and returns the result of the query, i.e., the output to be seen by the user,  an update to be applied to the data base and some error messages.
The effect of a query depends on the type of the query.
Insertions, deletions and updates either all succeed or all fail. i.e. any
$mayNotbeComplete$ on inner selects result in no change to the data base.


The `effect' of an insert query is a sequence of  relations between column number and data , 
together with a full table name and (possibly) some errors. 
Each element in the sequence will give a new row whose
existence classification is the same as the user's clearance. Missing
columns (i.e. columns that were hidden from the user) will be supplied with the default data for that column.

=SML
declare_type_abbrev(Û"Insert"İ,[],” Tab ¸ (Num ª Data) LIST ¸ Errors®);
=TEX

The `effect' of a delete query is a  full table name, a set of non-negative
integers corresponding to which rows in the table's sequence of rows are to be deleted and (possibly) some errors. Note, these row positions will be relative to the hidden state of the database that the user sees, not
its actual state. 

=SML
declare_type_abbrev(Û"Delete"İ,[],” Tab ¸ Num ğ ¸ Errors®);
=TEX

The `effect' of an update query is a  full table name,  a relation from row number
to a relation from column number to actual update and (possibly) some errors. Again, the row positions will be relative to the hidden state of the database that the user sees, not
its actual state. (We use the identifier $UpDate$ because $Update$ has already been used.)

=SML
declare_type_abbrev(Û"UpDate"İ,[],” Tab ¸ (Num ª (Num ª Update)) ¸ Errors®);
=TEX

The `effect' of a select query is some data to be returned to the user (in fact, a sequence of sequence of $Data$) and (possibly) some errors.
=SML
declare_type_abbrev(Û"Select"İ,[],” Data LIST LIST ¸ Errors®);
=TEX

This gives us the sum type $Effect$.

=SML
declare_type_abbrev(Û"Effect"İ,[],” Insert + Delete + UpDate + Select®);
=TEX
We give constructors for type $Effect$.

¹HOLCONST
Ü	ÛInsertEffectİ 	: Insert ­ Effect;
Ü	ÛDeleteEffectİ 	: Delete ­ Effect;
Ü	ÛUpdateEffectİ 	: UpDate ­ Effect;
Ü	ÛSelectEffectİ	: Select ­ Effect
÷üüüüüüüüüüüüüü
Ü	µ x ·	InsertEffect x		= InL x
Ü±	µ x ·	DeleteEffect x		= InR (InL x)
Ü±	µ x ·	UpdateEffect x		= InR (InR (InL x))
Ü±	µ x ·	SelectEffect x	 	= InR (InR (InR x))
°


\subsection{Insert}

A function which takes a set of pairs of natural number and  data and inserts the data at the appropriate
positions in the list.

The function $colDefaults$ takes a   column number - data  relation and a table
 and supplies a new relation  with
appropriate default values (obtained from the table information) in  columns which were hidden to the user.


¹HOLCONST
Ü	ÛcolDefaultsİ :  Class ­ TableSpec ­ (Num ª Data) ­  (Num ª Data)
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µ  clear : Class; ts : TableSpec; d : Num ª Data
Ü	·	colDefaults clear ts d
Ü		=
Ü		let ccs = {cs : ColSpec|(CS_consGroup cs)  groupsToHide(clear,ts)}
Ü		in 
Ü		d À {(n,data) | ¶cs · cs  ccs ± n = (CS_posn cs) ± data = (CS_default cs)} 
°

An insert query will fail if the user is not permitted to access the table.


¹HOLCONST
Ü	ÛinsertQueryİ :  (Class ¸ Insert ¸ State ¸ TableSpec) ­ State ¸ Errors
÷üüüüüüüüüüüüüü
Ü	µ clear:Class; i:Tab; ds : (Num ª Data) LIST; e:Errors; s:State;ts : TableSpec
Ü	·	insertQuery (clear,(i,ds,e),s,ts)
Ü		=
Ü		if 	³(clear dominates  (TS_class ts))
Ü		then 	(s,Append [accessDenied] e)
Ü		else
Ü			let rl = Map ((MkRow clear) o (colDefaults clear ts)) ds 
Ü			in	(changeSpec i (replaceRows ts (Append (TS_rows ts) rl)) s,e)	
°

\subsection{Delete}

Delete all rows specified by $DeleteEffect$.  The row numbers supplied by $DeleteEffect$ correspond
to the users view of the hidden state of the data base. In order to delete the correct rows from
the true state of the data base, it is necessary to take into account those rows about whose
existence the user is not cleared to know. If the user were not permitted access to the table
then the structure of the table would have been hidden from him and therefore the request would have failed.



¹HOLCONST
Ü	ÛDeleteİ : 'a LIST ­ Num ğ ­ 'a LIST
÷üüüüüüüüüüüüüü
ÜT   
°

¹HOLCONST
Ü	ÛdeleteQueryİ :  (Class ¸ Delete ¸ State ¸ TableSpec) ­  State ¸ Errors
÷üüüüüüüüüüüüüü
Ü	µ clear:Class; i:Tab; ns : Num ğ; e:Errors; s:State;ts:TableSpec
Ü	·	deleteQuery(clear,(i,ns,e),s,ts)
Ü		=
Ü		let	rs = Delete (TS_rows ts)(ran(reveal clear ts))
Ü			in	(changeSpec i (replaceRows ts rs) s,e)	
°üüüüüüüüüüüüüüüüüüüüüüüüüüüü	


\subsection{Update}


Perform the updates specified by $UpdateEffect$, provided that they do not
violate the security policy. A user may change the value in a field (classification stays the same) provided the
 field's classification dominates the user's clearance. A user may downgrade the classification of a field providing
that the value in the field is overwritten.

Firstly, consider an update request on a single field of data. This will either yield a new piece
of data or an error message.

¹HOLCONST
Ü	ÛupdateFieldİ :  Class ­ Class ­ (Update ¸ Data) ­ (Data + Error)
÷üüüüüüüüüüüüüü
Ü	µ clear table_class:Class; table_d:Data;u:Update
Ü	·	updateField clear table_class (u,table_d)
Ü		=
Ü		if	clear = table_class
Ü		then	if 	isItem u
Ü			then	giveVal(MkData (Dat_class table_d)(destItem u))
Ü			else	if	isClass u
Ü				then	if (destClass u) dominates (Dat_class table_d)
Ü					then	giveVal(MkData (destClass u) (Dat_item table_d))
Ü					else	giveError downGrade
Ü				else	giveVal(destData u) 	(* must be Data *)
Ü		else	if 	isItem u
Ü			then	if	(Dat_class table_d) dominates clear
Ü				then	giveVal(MkData (Dat_class table_d) (destItem u))
Ü				else	giveError underClassified
Ü			else	giveError classChange
°

A function that takes a relation and returns a list.

¹HOLCONST
Ü	ÛRelListİ :  (î ¸ 'a) SET ­ 'a LIST
÷üüüüüüüüüüüüüü
Ü	T
°

Then $Combine$ for lists.

¹HOLCONST
Ü	ÛRelCombineİ :  ('a ª 'b) ­ ('a ª 'c) ­ ('a  ª ('b ¸ 'c))
÷üüüüüüüüüüüüüü
Ü	T
°



Now the effect of an update on a row.  A new row is only returned if all updates are secure; otherwise
 a sequence of errors is returned. 

¹HOLCONST
Ü	ÛupdateRowİ :  Class ­ Class ­ ((Num ª Update) ¸ Row) ­ (Row + Errors)
÷üüüüüüüüüüüüüü
Ü	µ clear table_class:Class; us:Num ª Update;r:Row
Ü	·	updateRow clear table_class (us,r)
Ü		=
Ü		let us' = 	RelCombine us (R_data r) o (updateField clear table_class)
Ü		in
Ü			let es = RelList((us' ’ {x|isError x}) » destError)  
Ü			in
Ü			if 	es = []
Ü			then	giveVal(MkRow (R_exist r)((R_data r) 
Ü						« ((us' ’ {x|isVal x}) » destVal)))
Ü			else	giveError es
°



Finally, the $updateQuery$ function. 

¹HOLCONST
Ü	ÛupdateQueryİ :  (Class ¸ UpDate ¸ State ¸ TableSpec)  ­ State ¸ Errors
÷üüüüüüüüüüüüüü
Ü	µ clear:Class; i:Tab; us : Num ª (Num ª Update);e:Errors;s:State;ts : TableSpec
Ü	·	updateQuery (clear,(i,us,e),s,ts)
Ü		=
Ü		let 	us' = inverse_relation(reveal  clear ts) » us
Ü		in
Ü			let	pr = RelCombine us' (listrel(TS_rows ts)) 
Ü					o (updateRow clear (TS_class ts))
Ü			in	
Ü				let es = RelList((pr ’ {x|isError x}) » destError)
Ü				in	if es = []
Ü					then	let	rs =  RelList(listrel(TS_rows ts) 
Ü								«((pr ’ {x|isVal x}) » destVal))
Ü						in 	(changeSpec i(replaceRows ts rs) s,e)
Ü					else	(s,Append (Flatten es) e)
°

\subsection{Select}

Select all data specified by $SelectEffect$.  


¹HOLCONST
Ü	ÛselectQueryİ :  Select  ­ Data LIST LIST ¸ Errors
÷üüüüüüüüüüüüüü
Ü	µ d : Data LIST LIST; e:Errors
Ü	· 	selectQuery(d,e) = (d,e)
°

\subsection{Specification of $updateState$}
The four functions $insertQuery$, $deleteQuery$, $updateQuery$ and $selectQuery$ are put
together to give $updateState$.



¹HOLCONST
Ü	ÛupdateStateİ : Class ¸ Effect ¸ State ­ 
Ü				State ¸ (Class ¸ (Data LIST LIST ¸ Errors))
÷üüüüüüüüüüüüüü
Ü	µ clear:Class; i:Tab; ds : (Num ª Data) LIST;ns : Num ğ;
Ü	us:Num ª (Num ª Update);d:Data LIST LIST; e:Errors; s:State
Ü	· 	Front i  dom s ± Last i  dom (Dir_tables(s @ (Front i)))
Ü		´
Ü		let 	ts = (Dir_tables(s @ (Front i))) @ (Last i)
Ü		in
Ü		(updateState(clear,InsertEffect(i,ds,e),s) 
Ü		= 
Ü			let 	(s1,e1) = insertQuery(clear,(i,ds,e),s,ts)
Ü			in	(s1,(clear,([],e1))))
Ü	±	(updateState(clear,DeleteEffect(i,ns,e),s) 
Ü		= 
Ü			let 	(s2,e2) = deleteQuery(clear,(i,ns,e),s,ts)
Ü			in 	(s2,(clear,([],e2))))
Ü	±	(updateState(clear,UpdateEffect(i,us,e),s) 
Ü		=
Ü			let 	(s3,e3) = updateQuery(clear,(i,us,e),s,ts)
Ü			in 	(s3,(clear,([],e3))))
Ü	±	(updateState(clear,SelectEffect(d,e),s) 
Ü		= 
Ü			let 	(d4,e4) = selectQuery(d,e)
Ü			in	(s,(clear,(d4,e4))))
°


\newpage
=IGN
\input{fef004th.tex}
=TEX
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}
 
