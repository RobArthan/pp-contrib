=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Specification of SSQL Semantics}  %% Mandatory field
\TPPref{DS/FMU/FEF/004}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{The formal specifications of the main functionality of the SSQL semantics  for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[2.1] First approved version. 
\item[Issue \SCCSversion ({\FormatDate{$Date$
}}) ] Errors corrected in $Val$. New proof context.
\end{description}

\subsection{Changes Forecast}
This version only gives formal specifications of enough of the SSQL semantics to enable the state of the 
abstract machine to be defined. The remainder of the formal specifications will be provided
in due course. Changes  may be necessary  as a result of issues raised
during  the transcription of the specification.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document gives a formal specification of the SSQL semantics. It constitutes deliverable D3 of work package 1a, as given
in section 7 of the Secure Database Technical Proposal, \cite{DS/FMU/017}.

\subsection{Introduction}


In the Secure Database Technical Proposal, \cite{DS/FMU/017}, we stated that we propose to formalise the semantics of SSQL, supplied initially in Annex 2, {\em SSQL Abstract Machine}, to the ITT \cite{ittdra}, in a manner suitable for the required security proof, as 
outlined in \cite{DS/FMU/017}.  This involves the specific
features of the semantics which ensure that query 
processing is $secure$ be clearly separated from the purely functional aspects. This results in the formalisation of the semantics of
SSQL being presented in three main parts:
\begin{enumerate}
\item
A function $hide$ on the state of the database which returns a sanitised state of the database. This version of the database does not
include any information the existence
of which the user is not cleared to know, nor does it contain the true value of any field which the user is not cleared to see.
\item
The main functionality of SSQL, i.e. how the 
result of a query is computed from the state of the database.
\item
A function $updateState$ which applies the update determined in (2) to the database.This function is responsible for capturing the security
constraints associated with updates.
\end{enumerate}

This document provides the  specification
of the main functionality of the semantics
of SSQL. The functions $hide$ and $updateState$
are formalised in \cite{DS/FMU/FEF/005}.
\subsection{Terminology}

Labelled products with names of the form $Xxxx$ will have labels prefixed by $X\_$; labelled products with
 names of the form $XxxxYyyy$ will have labels prefixed by $XY\_$. The only exceptions to this
will be in the case where two labelled products would have identical labels, e.g.
$Data$ and $Directory$ will have labels prefixed by $Dat\_$ and $Dir\_$ respectively. Constructors
for labelled products are automatically generated by the ICL HOL system; names of constructors
for labelled products take the form of the name of the labelled product prefixed by $Mk$.

\section{PRELIMINARIES}
The following ICL HOL instructions set up the new theory $fef004$  and set the context 
for the proof tools.
=SML 
open_theory "fef003";
new_theoryÛ"fef004"İ;
set_cache_theories ["hol"];
push_pc "hol1";
=TEX


\section{DATA TYPES IN THE STATE}


The types $CHAR$, $STRING$, $î$ and $BOOL$ are already defined in the system.

=SML
declare_type_abbrev(Û"Char"İ,[],” CHAR®);
=TEX

=SML
declare_type_abbrev(Û"String"İ,[],” STRING®);
=TEX

=SML
declare_type_abbrev(Û"Num"İ,[],” î®);
=TEX

=SML
declare_type_abbrev(Û"Bool"İ,[],” BOOL®);
=TEX

=SML
declare_type_abbrev(Û"Ide"İ,[],” String®);
=TEX
\HOLindexEntry{Int}
¹HOLLABPROD Intüüüüüüüüüüü
Ü	ÛI_mantissaİ 	: Num;
Ü	ÛI_exponentİ	: Num
°üüüüüüüüüüüüüüüüüüüüü

\HOLindexEntry{Float}
¹HOLLABPROD Floatüüüüüüüüüüüüü
Ü	ÛF_mantissaİ 	: Num;
Ü	ÛF_exponentİ	: Num
°üüüüüüüüüüüüüüüüüüüüüüüüü



We introduce new types $Time$, $Interval$ and $Code$.

=SML
new_type(Û"Time"İ,0);
=TEX

=SML
new_type(Û"Interval"İ,0);
=TEX

=SML
new_type(Û"Code"İ,0);
=TEX


We have removed `error' from the domain of possible errors
since things that are partial functions
will be modelled as partial functions. The different `sorts' of errors are modelled
as natural numbers.

¹HOLCONST
Ü	ÛnotClearedİ ÛtooWideİ ÛtooTallİ ÛwrongTypeİ
Ü	ÛnullValueİ ÛnoSuchColumnİ ÛambigiousColumnİ
Ü	ÛambigiousUpdateİ ÛmayNotBeCompleteİ 
Ü	ÛunderClassifiedİ ÛdownGradeİ ÛclassChangeİ
Ü	ÛnoSuchTableİ ÛnoSuchDirectoryİ 
Ü	ÛambiguousEvaluateİ ÛambiguousHavingİ
Ü	ÛnonUniformValuesİ ÛnonUniqueValuesİ 
Ü	ÛnoNullsİ ÛfieldClassOutOfRangeİ
Ü	ÛrowClassTooLowİ ÛaccessDeniedİ		: Num
÷üüüüüüüüüüüüüü
Ü	notCleared		= 1 
Ü±	tooWide		= 2
Ü±	tooTall			= 3
Ü±	wrongType		= 4
Ü± 	nullValue		= 5
Ü± 	noSuchColumn	= 6
Ü±	ambigiousColumn	= 7 	
Ü±	ambigiousUpdate	= 8
Ü±	mayNotBeComplete	= 9
Ü±	underClassified	= 10
Ü±	downGrade   		= 11 
Ü±	classChange  		= 12
Ü±	noSuchTable  		= 13
Ü±	noSuchDirectory 	= 14
Ü±	ambiguousEvaluate 	= 15
Ü±	ambiguousHaving 	= 16 
Ü±	nonUniformValues 	= 17
Ü±	nonUniqueValues 	= 18 
Ü±	noNulls 		= 19 
Ü±	fieldClassOutOfRange = 20
Ü±	rowClassTooLow	= 21
Ü±	accessDenied 		= 22
°

=SML
declare_type_abbrev(Û"Error"İ,[],” Num®);
=TEX


The different `sorts' of worth are also modelled
as natural numbers.

¹HOLCONST
Ü	Ûworthlessİ Ûdinaryİ Ûsterlingİ Ûpricelessİ	: Num
÷üüüüüüüüüüüüüü
Ü	worthless	= 1 
Ü±	dinary		= 2
Ü±	sterling		= 3
Ü±	priceless	= 4
°

=SML
declare_type_abbrev(Û"Worth"İ,[],” Num®);
=TEX

$Val$ is declared as a sum type (i.e. binary disjoint union). The `types' ${void}$ and ${exception}$ are given as one-point types. 

=SML
declare_type_abbrev(Û"Val"İ,[],
	” ONE + Bool + String + Int + Float + Time + Interval + Class + ONE®);
=TEX
We give constructors for type $Val$.


¹HOLCONST
Ü	ÛVoidValİ 		: Val;
Ü	ÛBoolValİ 		: Bool ­ Val;
Ü	ÛStringValİ 		: String ­ Val;
Ü	ÛIntValİ			: Int ­ Val;
Ü	ÛFloatValİ		: Float ­ Val;
Ü	ÛTimeValİ		: Time ­ Val;
Ü	ÛIntervalValİ		: Interval ­ Val;
Ü	ÛClassValİ		: Class ­ Val;
Ü	ÛExceptionValİ	: Val 
÷üüüüüüüüüüüüüü
Ü	µ b:Bool; s:String; i:Int; f:Float; t:Time; n:Interval; c:Class
Ü	·	VoidVal 		= InL One
Ü	±	BoolVal b 		= InR (InL b)
Ü	±	StringVal s 	 	= InR (InR (InL s))
Ü	±	IntVal i 		= InR (InR (InR (InL i)))
Ü	±	FloatVal f		= InR (InR (InR (InR (InL f))))
Ü	±	TimeVal t		= InR (InR (InR (InR (InR (InL t)))))
Ü	±	IntervalVal n		= InR (InR (InR (InR (InR (InR (InL n))))))
Ü	±	ClassVal c		= InR (InR (InR (InR (InR (InR (InR (InL c)))))))
Ü	±	ExceptionVal 		= InR (InR (InR (InR (InR (InR (InR (InR One)))))))
°

\HOLindexEntry{ValuedItem}
¹HOLLABPROD ValuedItemüüüüüüüüüüüüü
Ü	ÛVI_worthİ 	: Num;
Ü	ÛVI_valİ		: Val
°üüüüüüüüüüüüüüüüüüüüüüüüüü

The type ${NullItem}$ is given as a one-point type.

=SML
declare_type_abbrev(Û"NullItem"İ,[],” ONE®);
declare_alias(Û"null"İ,¬One®);
=TEX

$Item$ is declared as a sum type.
=SML
declare_type_abbrev(Û"Item"İ,[],” ValuedItem + NullItem®);
=TEX
We give constructors for type $Item$.

¹HOLCONST
Ü	ÛValuedItemItemİ 	: ValuedItem ­ Item;
Ü	ÛNullItemItemİ 	: NullItem ­ Item
÷üüüüüüüüüüüüüü
Ü	µ v:ValuedItem; n:NullItem
Ü	·	ValuedItemItem v	= InL v
Ü	±	NullItemItem n	= InR n
°

\HOLindexEntry{Data}
¹HOLLABPROD Dataüüüüüüüüü
Ü	ÛDat_classİ 	: Class;
Ü	ÛDat_itemİ	: Item
°üüüüüüüüüüüüüüüüüüü

=SML
declare_type_abbrev(Û"Update"İ,[],” Item + Class + Data®);
=TEX
We need constructor, discriminator and destructor functions for $Update$.

¹HOLCONST
Ü	ÛItemUpdateİ 		: Item ­ Update;
Ü	ÛClassUpdateİ 	: Class ­ Update;
Ü	ÛDataUpdateİ 		: Data ­ Update
÷üüüüüüüüüüüüüü
Ü	µ i:Item; c:Class; d:Data
Ü	·	ItemUpdate i	= InL i
Ü	±	ClassUpdate c	= InR (InL c)
Ü	±	DataUpdate d	= InR (InR d)
°

¹HOLCONST
Ü	ÛisItemİ 	: Update ­ Bool;
Ü	ÛisClassİ 	: Update ­ Bool;
Ü	ÛisDataİ 	: Update ­ Bool
÷üüüüüüüüüüüüüü
Ü	µ	u:Update
Ü	·	(isItem	 u	= ¶ i:Item 	· u = ItemUpdate i)
Ü	±	(isClass u	= ¶ c:Class 	· u = ClassUpdate c)
Ü	±	(isData u	= ¶ d:Data 	· u = DataUpdate d) 
°

¹HOLCONST
Ü	ÛdestItemİ 	: Update ­ Item;
Ü	ÛdestClassİ 	: Update ­ Class;
Ü	ÛdestDataİ 	: Update ­ Data
÷üüüüüüüüüüüüüü
Ü	µ	i:Item; c:Class; d:Data
Ü	·	destItem (ItemUpdate i)	= i 
Ü	±	destClass(ClassUpdate c)	= c
Ü	±	destData (DataUpdate d)	= d 
°


\HOLindexEntry{Chars}
¹HOLLABPROD Charsüüüüüüüüü
Ü	ÛC_minLengthİ 	: Num;
Ü	ÛC_maxLengthİ	: Num
°üüüüüüüüüüüüüüüüüüü

\HOLindexEntry{Integer}
¹HOLLABPROD Integerüüüüüüü
Ü	ÛI_minİ 		: Int;
Ü	ÛI_maxİ		: Int;
Ü	ÛI_scaleİ	: Int
°üüüüüüüüüüüüüüüüüü

\HOLindexEntry{Floating}
¹HOLLABPROD Floatingüüüüüüüüüüüüü
Ü	ÛF_minMantİ	: Int;
Ü	ÛF_maxMantİ	: Int;
Ü	ÛF_minExpİ	: Int;
Ü	ÛF_maxExpİ	: Int
°üüüüüüüüüüüüüüüüüüüüüüüüü


We give $monolean$, $boolean$, $time$, $interval$ and $class$ as elements of one-point types.
=SML
declare_alias(Û"monolean"İ,¬One®);
declare_alias(Û"boolean"İ,¬One®);
declare_alias(Û"time"İ,¬One®);
declare_alias(Û"interval"İ,¬One®);
declare_alias(Û"class"İ,¬One®);
=TEX



=SML
declare_type_abbrev(Û"Type"İ,[],
	” ONE + ONE + Chars + Integer + Floating + ONE + ONE + ONE®);
=TEX

=SML
declare_type_abbrev(Û"Errors"İ,[],” Error LIST®);
=TEX

\HOLindexEntry{ColSpec}
¹HOLLABPROD ColSpecüüüüüüüüüüüüüü
Ü	ÛCS_ideİ 		: Ide;
Ü	ÛCS_posnİ		: Num;
Ü	ÛCS_dinaryTypeİ	: Type;
Ü	ÛCS_sterlingTypeİ	: Type;
Ü	ÛCS_nullTypeİ		: Bool;
Ü	ÛCS_defaultİ		: Data;
Ü	ÛCS_consGroupİ	: Num;
Ü	ÛCS_minİ		: Class;
Ü	ÛCS_maxİ		: Class
°üüüüüüüüüüüüüüüüüü





We have removed $Error$ from the state of the data base and will
 provide 
access functions  which return either a data type or an error.

=SML
declare_type_abbrev(Û"Tab"İ,[],” Ide LIST®);
=TEX

\HOLindexEntry{Reference}
¹HOLLABPROD Referenceüüüüüüüüüüüüüü
Ü	ÛR_tableİ 	: Tab;
Ü	ÛR_groupİ	: Num
°üüüüüüüüüüüüüüüüüü


\HOLindexEntry{ColCon}
¹HOLLABPROD ColConüüüüüüüüüüüüüü
Ü	ÛCC_existİ 		: Class;
Ü	ÛCC_uniformİ		: Bool;
Ü	ÛCC_uniqueİ		: Bool;
Ü	ÛCC_classLimitedİ	: Bool;
Ü	ÛCC_primaryİ		: Bool;
Ü	ÛCC_secondaryİ	: Bool;
Ü	ÛCC_referentialİ	: Reference LIST
°üüüüüüüüüüüüüüüüüü



=SML
declare_type_abbrev(Û"ColCons"İ,[],” Num ª ColCon®);
=TEX

\HOLindexEntry{Row}
¹HOLLABPROD Rowüüüüüüüüüüüüüü
Ü	ÛR_existİ 	: Class;
Ü	ÛR_dataİ	: Num ª Data
°üüüüüüüüüüüüüüüüüü

\HOLindexEntry{TableSpec}
¹HOLLABPROD TableSpecüüüüüüüüü
Ü	ÛTS_classİ 		: Class;
Ü	ÛTS_maxRowİ		: Class;
Ü	ÛTS_colspecsİ		: ColSpec ğ;
Ü	ÛTS_consİ		: ColCons;
Ü	ÛTS_rowsİ		: Row LIST
°üüüüüüüüüüüüüüüüüü

=SML
declare_type_abbrev(Û"TableSpecs"İ,[],” Ide ª TableSpec®);
=TEX

\HOLindexEntry{Directory}
¹HOLLABPROD Directoryüüüüüüüüüüüüüü
Ü	ÛDir_tablesİ 		: TableSpecs;
Ü	ÛDir_existİ		: Class;
Ü	ÛDir_classİ		: Class
°üüüüüüüüüüüüüüüüüü

=SML
declare_type_abbrev(Û"State"İ,[],” Ide LIST ª Directory®);
=TEX

We have chosen not to model $Result$. A $Result$ is either some $Data$
or just a $Class$ (when the user is not cleared to 
observe the actual value). In effect, we always have some $Data$; in
the case when the user is not cleared to see the value, the value will be $Hidden$ anyway.

\section{FUNCTIONALITY OF THE QUERY PROCESSING}
\subsection{Auxiliary Functions}
General constructor, discriminator and destructor functions for a sum type where one component is  an error or sequence of errors.

¹HOLCONST
Ü	ÛgiveValİ 	: 'a ­ 'a + 'Error;
Ü	ÛgiveErrorİ 	: 'Error ­ 'a + 'Error;
Ü	ÛdestValİ	: 'a + 'Error ­ 'a;
Ü	ÛdestErrorİ	: 'a + 'Error ­ 'Error;
Ü	ÛisValİ		: 'a + 'Error ­ Bool;
Ü	ÛisErrorİ	: 'a + 'Error ­ Bool
÷üüüüüüüüüüüüüü
Ü	µ v; e; ve 
Ü	·	giveVal v			= InL v
Ü	±	giveError e			= InR e
Ü	±	destVal (giveVal v)		= v 
Ü	±	destError(giveError e)	= e	
Ü	±	(isVal ve 			= ¶ v‰1 · ve = giveVal v‰1)
Ü	±	(isError ve			= ¶ e‰1 · ve = giveError e‰1)
°


\subsection{Type of $Effect$}
The functionality of the semantics of SSQL will be captured by the function $processQuery$ ,described in section \ref{PROCESS}.
This function takes a query, a user's clearance and a state and returns the result of the query, i.e., the output to be seen by the user,  an update to be applied to the data base and some error messages.
The effect of a query depends on the type of the query.
Insertions, deletions and updates either all succeed or all fail. i.e. any
$mayNotbeComplete$ on inner selects result in no change to the data base.


The `effect' of an insert query is a sequence of  relations between column number and data , 
together with a full table name. 
Each element in the sequence will give a new row whose
existence classification is the same as the user's clearance. Missing
columns (i.e. columns that were hidden from the user) will be supplied with the default data for that column.

=SML
declare_type_abbrev(Û"Insert"İ,[],” Tab ¸ (Num ª Data) LIST®);
=TEX

The `effect' of a delete query is a  full table name and  a set of non-negative
integers corresponding to which rows in the table's sequence of rows are to be deleted. Note, these row positions will be relative to the hidden state of the database that the user sees, not
its actual state. 

=SML
declare_type_abbrev(Û"Delete"İ,[],” Tab ¸ Num ğ®);
=TEX

The `effect' of an update query is a  full table name and  a relation from row number
to a relation from column number to actual update. Again, the row positions will be relative to the hidden state of the database that the user sees, not
its actual state. (We use the identifier $UpDate$ because $Update$ has already been used.)

=SML
declare_type_abbrev(Û"UpDate"İ,[],” Tab ¸ (Num ª (Num ª Update))®);
=TEX

The `effect' of a select query is some data to be returned to the user (in fact, a sequence of sequence of $Data$).
=SML
declare_type_abbrev(Û"Select"İ,[],” Data LIST LIST®);
=TEX

This gives us the sum type $Effect$.

=SML
declare_type_abbrev(Û"Effect"İ,[],” Insert + Delete + UpDate + Select®);
=TEX
We give constructor, discriminator and destructor functions for type $Effect$.

¹HOLCONST
Ü	ÛInsertEffectİ 		: Insert ­ Effect;
Ü	ÛDeleteEffectİ 		: Delete ­ Effect;
Ü	ÛUpdateEffectİ 	: UpDate ­ Effect;
Ü	ÛSelectEffectİ		: Select ­ Effect
÷üüüüüüüüüüüüüü
Ü	µ i:Insert; d:Delete; u:UpDate; s:Select
Ü	·	InsertEffect i		= InL i
Ü	±	DeleteEffect d		= InR (InL d)
Ü	±	UpdateEffect u	= InR (InR (InL u))
Ü	±	SelectEffect s	 	= InR (InR (InR s))
°

¹HOLCONST
Ü	ÛisInsertİ 	: Effect ­ Bool;
Ü	ÛisDeleteİ 	: Effect ­ Bool;
Ü	ÛisUpdateİ 	: Effect ­ Bool;
Ü	ÛisSelectİ	: Effect ­ Bool
÷üüüüüüüüüüüüüü
Ü	µ e :Effect
Ü	·	(isInsert e	= ¶ i:Insert 		· e = InsertEffect i)
Ü	± 	(isDelete e	= ¶ d:Delete 		· e = DeleteEffect d)
Ü	±	(isUpdate e	= ¶ u:UpDate		· e = UpdateEffect u)
Ü	±	(isSelect e	= ¶ s:Select 		· e = SelectEffect s)
°

¹HOLCONST
Ü	ÛdestInsertİ 	: Effect ­ Insert;
Ü	ÛdestDeleteİ 	: Effect ­ Delete;
Ü	ÛdestUpdateİ 	: Effect ­ UpDate;
Ü	ÛdestSelectİ	: Effect ­ Select
÷üüüüüüüüüüüüüü
Ü	µ 	i:Insert; d:Delete; u:UpDate; s:Select
Ü	·	destInsert(InsertEffect i)	= i
Ü	± 	destDelete(DeleteEffect d)	= d
Ü	±	destUpdate(UpdateEffect u)	= u
Ü	±	destSelect(SelectEffect s)	= s
°

We also provide a function that return the table name from an effect;
this function will not be applied to a $Select$ effect.

¹HOLCONST
Ü	ÛtabFromEffectİ 	: Effect ­ Tab
÷üüüüüüüüüüüüüü
Ü	µ 	i:Insert; d:Delete; u:UpDate	
Ü	·	tabFromEffect  (InsertEffect i)	= Fst i
Ü	± 	tabFromEffect  (DeleteEffect d)	= Fst d
Ü	±	tabFromEffect  (UpdateEffect u)	= Fst u
°

\subsection{The function $processQuery$} \label{PROCESS}

We introduce a new type $Query$.

=SML
new_type(Û"Query"İ,0);
=TEX

We model the functionality of SSQL with $processQuery$, to be specified later.

¹HOLCONST
Ü	ÛprocessQueryİ : Query ¸ Class ¸ State ­ Effect ¸ Errors
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	T
° 

\section{CLOSING DOWN}
The following ICL HOL instruction restores the previous proof context.
=SML
pop_pc();
=TEX
\section{APPROVAL OF THE SSQL SPECIFICATION} 
Comments on this document by DRA to be made  by 19th June 1992.


=IGN
output_theory{theory = "fef004",outfile = "fef004th.doc"};
=TEX

\newpage
\input{fef004th.tex}
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}





