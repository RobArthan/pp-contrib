
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Proof Strategy}  %% Mandatory field
\TPPref{DS/FMU/FEF/007}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document contains a proof strategy for proving
the SSQL Abstract Machine security conjecture for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion(\FormatDate{$Date$
})] New parent.
\end{description}

\subsection{Changes Forecast}
Changes  may be necessary  as a result of issues raised
during  the transcription of the specification.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document provides a proof strategy for proving
 the security of the SSQL semantics. 

\subsection{Introduction}
In \cite{DS/FMU/FEF/006}, the  correctness conjecture for the SSQL Abstract Machine
was given. In section 6.2.3 of the Secure Database Technical Proposal, \cite{DS/FMU/017},
we proposed that a major part of the proof of this conjecture
would be an unwinding result independent of the semantics of SSQL.
In this document, we provide 
a proof strategy for the proof of the  correctness conjecture for the SSQL Abstract Machine
which comprises the proof of an unwinding result
together with a proof about the critical components $hide$ and $updateState$, defined 
in \cite{DS/FMU/FEF/005}.



\section{PRELIMINARIES}
The following ICL HOL instructions set up the new theory $fef007$.

=SML 
open_theory "fef006";
new_theoryÛ"fef007"İ;
push_merge_pcs["hol","fefhol","'pair1"] ;
=TEX

\section{MAIN SECURITY CONJECTURE}\label{MAIN}

We reiterate the  correctness conjecture for the SSQL Abstract Machine 
given in \cite{DS/FMU/FEF/006}, i.e. 
that its behaviour, as defined in \cite{DS/FMU/FEF/006}, is secure, as defined in 
\cite{DS/FMU/FEF/003}.

=GFT
	?ô 	behaviours SSQLam  secure
=TEX

It is the intention to prove this result by proving two main lemmas:
\begin{description}
\item[Lemma1]

A result about the critical requirements on the components $hide$ and $updateState$, formalised in section \ref{COMP}.
\item[Lemma2]

An unwinding result,  formalised in section \ref{UNWIND}.
\end{description}

\section{CRITICAL REQUIREMENTS ON COMPONENTS} 
We formalise the critical requirements on the critical components $hide$
and $updateState$ of the  SSQL abstract machine. The only requirement exclusively
on the  $hide$ component
 is that it is monotonic with respect to classification. This is 
formalised as the property $secureHide$.

¹HOLCONST
Ü	ÛsecureHideİ : Hide ğ
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µ h : Hide · 
Ü		h  secureHide
Ü		¤
Ü		µc‰1 c‰2 : Class; s‰1 s‰2 : State ·	
Ü			h(c‰1,s‰1) = h(c‰1,s‰2)
Ü			±
Ü			c‰1 dominates c‰2	
Ü			´
Ü			h(c‰2,s‰1) = h(c‰2,s‰2)
°

The remaining critical requirements on $hide$ and $updateState$
are expressed as a critical requirement on the relationship between $hide$ and $updateState$.
We divide this into four components:
\begin{enumerate}
\item
If we have
two clearances $c‰1$ and $c‰2$ and we update
 the database at $c‰1$ and a change is visible when hiding w.r.t $c‰2$, then
$c‰2$ must dominate $c‰1$. 
\item
If we have
two clearances $c‰1$ and $c‰2$  where $c‰1$ dominates $c‰2$
and we update
 the database at $c‰2$ in states $s‰1$ and $s‰2$,  which are the same when viewed at $c‰1$,
then the resulting states are the same when viewed at $c‰1$.

These first two  requirements concern the security of the 
state of the database. 
\item
If we perform an update on two states
$s‰1$ and $s‰2$ that are the same when viewed at a clearance $c$,
then the outputs must be the same. 
\item
Outputs from updates performed at 
a clearance $c$ must be at clearance $c$.

These last two requirements concern the security of the 
 outputs from the database to the user.
\end{enumerate}

We define a property  $secureUpdate$ that captures these requirements


¹HOLCONST
Ü	ÛsecureUpdateİ : Hide ª Ustate
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µ h : Hide ;u : Ustate ·
Ü		(h,u)  secureUpdate
Ü		¤
Ü	(*1*)	(µc‰1 c‰2 : Class; s : State; e:Effect ¸ Errors ·	
Ü			let 	s' = Fst(u(c‰1,e,s)) 
Ü			in
Ü				³(h(c‰2,s) = h(c‰2,s'))
Ü				´ 	c‰2 dominates c‰1)	
Ü		±
Ü	(*2*)	(µc‰1 c‰2 : Class; s‰1 s‰2 : State; e:Effect ¸ Errors ·	
Ü			let 	s‰1' = Fst(u(c‰2,e,s‰1)) 
Ü			and	s‰2' = Fst(u(c‰2,e,s‰2))
Ü			in
Ü				h(c‰1,s‰1) = h(c‰1,s‰2)
Ü				±	c‰1 dominates c‰2
Ü				´	h(c‰1,s‰1') = h(c‰1,s‰2'))	
Ü		±
Ü	(*3*)	(µc : Class; s‰1 s‰2: State; e:Effect ¸ Errors ·
Ü			let	o‰1 = Snd(u(c,e,s‰1))
Ü			and 	o‰2 = Snd(u(c,e,s‰2))
Ü			in
Ü				h(c,s‰1) = h(c,s‰2) ´	o‰1 = o‰2)
Ü		±
Ü	(*4*)	(µc : Class; s: State; e:Effect ¸ Errors ·
Ü			Fst(Snd(u(c,e,s))) = c)
°


\subsection{Lemma1 : Component Correctness Conjecture} \label{COMP}

We formalise the security conjecture that $hide$ and $updateState$ are secure.

=GFT
	?ô 	hide  secureHide ± (hide,updateState)  secureUpdate
=TEX

¹HOLCONST
Ü	ÛLemma1İ : BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	Lemma1 = 
Ü		(hide  secureHide 
Ü		± 
Ü		(hide,updateState)  secureUpdate)
° 


\section{UNWINDING RESULT} \label{UNWIND}
\subsection{Lemma2}
The main unwinding result  of the proof of security of the SSQL abstract machine states that if 
we build an SSQL abstract machine
as prescribed in \cite{DS/FMU/FEF/006} from an $SSQLtf$ and an initial state $isstate$, and $hide$
 and $updateState$ satisfy  $secureHide$ and $secureUpdate$, the security properties on components,
 then the 
`behaviour' of the 
SSQL abstract machine is $secure$, as defined in \cite{DS/FMU/FEF/003}.
This is formalised as $Lemma2$.
=GFT
	?ô 	(hide  secureHide 
		± 
		(hide,updateState)  secureUpdate) 
		´ 
		behaviours SSQLam  secure
=TEX

¹HOLCONST
Ü	ÛLemma2İ : BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	Lemma2 = 
Ü		((hide  secureHide 
Ü		± 
Ü		(hide,updateState)  secureUpdate) 
Ü		´ 
Ü		behaviours SSQLam  secure)
° 

\subsection{Transition Function Property}
The critical requirement on $hide$ and $updateState$ is essentially a requirement 
on the relationship between $hide$ and $updateState$. We require a security 
property on iterated transition
functions in order to prove that the behaviour of the SSQL abstract machine
is secure.  In turn, we require a security property on transition
functions. Hence, in order to prove $Lemma2$, 
we will prove $Lemma3$, formalised in section \ref{TF}, and $Lemma4$, formalised 
in section \ref{ITF}, together with $Lemma5$, formalised in section \ref{L5}, which
is a result relating the iterated  SSQL transition
function to the bahaviour of the SSQL abstract machine. 
First, a security property on 
transition functions. 


¹HOLCONST
Ü	ÛsecureStfİ : Stf ğ
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µ stf : Stf ·
Ü		stf  secureStf
Ü		¤
Ü		(µs‰1 s‰2: State; i‰1 i‰2: Query ¸ Class;c : Class ·	
Ü			(hide(c,s‰1) = hide(c,s‰2)
Ü			±
Ü			([i‰1],[i‰2])  same_ins c)
Ü			´
Ü			let 	(s‰1',o‰1) = stf(i‰1,s‰1)
Ü			and	(s‰2',o‰2) = stf(i‰2,s‰2) 
Ü			in
Ü			(hide(c,s‰1') = hide(c,s‰2')
Ü			±
Ü			([o‰1],[o‰2])  same_outs c))
Ü		±
Ü		(µ s: State; i: Query ¸ Class; c: Class · 
Ü			³ c dominates(Snd i)
Ü			´ 
Ü			((hide (c, s) = hide (c, Fst (stf (i, s))))
Ü			± 
Ü			³ c dominates(Fst(Snd(stf (i, s))))))
° 

We define  a constant SSQLtf, the SSQL abstract machine
transition function.

¹HOLCONST
Ü	ÛSSQLtfİ : Stf 
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	SSQLtf = mkTf hide processQuery updateState
° 

\subsubsection{Lemma3} \label{TF}
We formalise a proposition that states that if $hide$ and $updateState$
satisfy their critical requirements, then $SSQLtf$ satisfies $secureStf$, the security property
on transition functions. 

=GFT
	?ô 	(hide  secureHide 
		± 
		(hide,updateState)  secureUpdate) 
		´
		SSQLtf  secureStf 
=TEX

¹HOLCONST
Ü	ÛLemma3İ : BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	Lemma3 = 
Ü		((hide  secureHide 
Ü		± 
Ü		(hide,updateState)  secureUpdate) 
Ü		´
Ü		SSQLtf  secureStf)
° 


\subsection{Iterated Transition Function Property} 
We state a property on 
iterated transition functions. 

First an abbreviation definition for the type of iterated state transition functions, $Itf$.

=SML
declare_type_abbrev(Û"Itf"İ,[],” (Query ¸ Class)LIST ¸ State 
					­ State ¸ (Class ¸ (Data LIST LIST ¸ Errors))LIST®);
=TEX

¹HOLCONST
Ü	ÛsecureItfİ : Itf ğ
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µ itf : Itf ·
Ü		itf  secureItf
Ü		¤
Ü		µs‰1 s‰2: State;si‰1 si‰2 : (Query ¸ Class)LIST; c : Class ·	
Ü			(hide(c,s‰1) = hide(c,s‰2)
Ü			±
Ü			(si‰1,si‰2)  same_ins c)
Ü			´
Ü			let 	(s‰1',so‰1) = itf(si‰1,s‰1)
Ü			and	(s‰2',so‰2) = itf(si‰2,s‰2) 
Ü			in
Ü			(hide(c,s‰1') = hide(c,s‰2')
Ü			±
Ü			(so‰1,so‰2)  same_outs c)
° 
\subsubsection{Lemma4} \label{ITF}
We formalise the proposition that if an $SSQLtf$ satisfies $secureStf$, then an iterated
$SSQLtf$ satisfies $secureItf$, the security property
on iterated transition functions. 

=GFT
	?ô 	SSQLtf  secureStf 
		´ 
		(iterate SSQLtf)  secureItf 
=TEX

¹HOLCONST
Ü	ÛLemma4İ : BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	Lemma4 = 
Ü		(SSQLtf  secureStf 
Ü		´ 
Ü		(iterate SSQLtf)  secureItf)
° 

\subsubsection{Lemma5} \label{L5}
This propostion states that if the iterated
$SSQLtf$ satisfies $secureItf$, the security property
on iterated transition functions, then the behaviour of the SSQL abstract machine is secure.

=GFT
	?ô 	(iterate SSQLtf)  secureItf 
		´ 
		behaviours SSQLam  secure
=TEX

¹HOLCONST
Ü	ÛLemma5İ : BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	Lemma5 = 
Ü		((iterate SSQLtf)  secureItf 
Ü		´ 
Ü		behaviours SSQLam  secure)
° 

\subsection{Proof of Lemma2, the  Unwinding Result}
The proof of the unwinding result, $Lemma2$, follows from the 
proofs of $Lemma3$, $Lemma4$ and  $Lemma5$.

We first retrieve the definitions of the lemmas:
=SML
val Lemma1 = get_spec¬Lemma1®;
val Lemma2 = get_spec¬Lemma2®;
val Lemma3 = get_spec¬Lemma3®;
val Lemma4 = get_spec¬Lemma4®;
val Lemma5 = get_spec¬Lemma5®;
=TEX

Then prove  $lemma2\_thm$ which states that if we can prove $Lemma3$, $Lemma4$ and  $Lemma5$, then
 we can prove $Lemma2$. 

=SML
val Ûlemma2_thmİ = save_thm("lemma2_thm",(prove_rule[Lemma2,Lemma3,Lemma4,Lemma5]
	¬Lemma3 ± Lemma4 ± Lemma5 ´ Lemma2®));
=TEX

=GFT
lemma2_thm = ô Lemma3 ± Lemma4 ± Lemma5 ´ Lemma2
=TEX

\section{MAIN PROOF OF SECURITY}

The main proof conjecture, given in section \ref{MAIN}, that:
=GFT
	?ô 	behaviours SSQLam  secure
=TEX

follows from the proofs of $Lemma1$:

=GFT
	?ô 	hide  secureHide ± (hide,updateState)  secureUpdate
=TEX

and $Lemma2$:

=GFT
	?ô 	((hide  secureHide 
		± 
		(hide,updateState)  secureUpdate) 
		´ 
		behaviours SSQLam  secure
=TEX

We prove  $lemma1\_2\_thm$ which states that if we can prove $Lemma1$ and $Lemma2$  then
 we can prove that the behaviour of the SSQL abstract machine is secure. 

=SML
val Ûlemma1_2_thmİ = save_thm("lemma1_2_thm",(prove_rule[Lemma1,Lemma2]
	¬Lemma1 ± Lemma2 ´ behaviours SSQLam  secure®));
=TEX

=GFT
lemma1_2_thm = ô Lemma1 ± Lemma2 ´ behaviours SSQLam  secure
=TEX

Finally, we prove the $main\_thm$ that states thatif we can prove $Lemma1$, $Lemma3$, $Lemma4$ and $Lemma5$ then the behaviour of the SSQL abstract machine is secure.

=SML
push_goal([],¬Lemma1 ± Lemma3 ± Lemma4 ± Lemma5 ´ behaviours SSQLam  secure®);
a(REPEAT strip_tac THEN MAP_EVERY strip_asm_tac [lemma2_thm,lemma1_2_thm]);
val Ûmain_thmİ = save_pop_thm"main_thm";
=TEX

=GFT
main_thm = ô  Lemma1 ± Lemma3 ± Lemma4 ± Lemma5 ´ behaviours SSQLam  secure
=TEX
\section{CLOSING DOWN}
=IGN
output_theory{theory = "fef007",out_file = "fef007th.doc"};
=TEX
The following ICL HOL instruction restores the previous proof context.
=SML
pop_pc();
=TEX

\newpage
\input{fef007th.tex}
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}
