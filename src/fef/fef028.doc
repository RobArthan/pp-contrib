=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Specification of Query Transformations in HOL (I)}  %% Mandatory field
\TPPref{DS/FMU/FEF/028}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{Preliminaries to a HOL specification of the SSQL Query Transformations  for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}})]  SSQL and TSQL specs separated from transformations.
\end{description}

\subsection{Changes Forecast}
As determined by comments and experience in using the specification.
\newpage
\section{GENERAL}
\subsection{Scope}
This document gives  specifications in HOL (\cite{milner90}, \cite{paulson91}) of the SSQL and TSQL abstract syntax  and preliminary specifications from \cite{trans} to support a formal specification in HOL of the SSQL query transformations of \cite{trans}. It is quite closely based on the Standard ML treatment of the
same material in \cite{DS/FMU/FEF/019}.

The present, draft, issue of this document constitutes part of
 deliverable D11 of work package 3, as given
in the Proposal for Phase~2, \cite{DS/FMU/FEF/018}.

\subsection{Introduction}
We proposed in \cite{DS/FMU/FEF/018} to formalise the 
SSQL query transformations of \cite{trans} in HOL. 
Here we provide HOL specifications of the SSQL 
and TSQL datatypes together with specifications of the transformation notation,  
generic functions, primitive routines, transformation types 
and symbol table from \cite{trans}. HOL specifications of the 
transformations may be found in \cite{DS/FMU/FEF/029}.

In order to avoid overloading of identifiers, 
subscripts have been used 
to distinguish between constructors of SSQL types and TSQL 
types.

The structure of this document is largely based on that of the Standard
ML treatment of \cite{DS/FMU/FEF/018}.
The main differences between the two treatments are as follows:

\begin{enumerate}
\item The abstract syntax of SSQL is already defined in HOL in
\cite{DS/FMU/FEF/014} and so need not be redefined here.
\item Some of the general purpose functions of \cite{DS/FMU/FEF/018}
which represent various specification idioms used and defined in \cite{trans}
are subsumed by library functions which are already defined for ProofPower-HOL
and so do not need to be defined here.
\item Both \cite{trans} and its Standard ML description in \cite{DS/FMU/FEF/020}
make much use of definition by cases over the alternatives for a data type.
To facilitate the transcription to HOL, constants and type definitions which
allow a systematic approach to defining such data types in a way which
allows definition by cases using a style similar to that
of \cite{trans}.
\end{enumerate}
\subsection{ProofPower Preamble}
The following commands initialise the ProofPower system to accept
the specifications:
=SML
open_theory"fef014";
new_theory"fef028";
set_pc"hol";
=TEX
\section{UNIVERSAL TYPES} \label{UNI}
We will use the HOL types $BOOL$, $ONE$, $LIST$ and $STRING$ where appropriate.

The primitive types of \cite{trans} may mostly be borrowed from
the SSQL semantics of \cite{DS/FMU/FEF/004}.
However, $Enum$ and $Fixed$ are not given in \cite{DS/FMU/FEF/004} and $Integer$ is
called $Int$ there.
For the time being, we take $Enum$, $Integer$  and $Fixed$ to be the same as $Int$.
=SML
declare_type_abbrev("Enum", [], ”Int®);
declare_type_abbrev("Integer", [], ”Int®);
declare_type_abbrev("Fixed", [], ”Int®);
=TEX
The values of type $Op$ are taken from \cite{DS/FMU/FEF/004}.
=TEX
=TEX
\section{SSQL ABSTRACT SYNTAX}
See \cite{DS/FMU/FEF/014}.
=TEX
\section{TSQL ABSTRACT SYNTAX}
For the time being this is being taken as the same as
the SSQL abstract syntax. 
=TEX
\section{SSQL TRANSFORMATIONS}
\subsection{Generic Functions and Primitive Functions}
Many of the functions of \cite{DS/FMU/FEF/019} are handled directly
by HOL library functions. For example,
strings are just lists of characters in HOL and the list operators
may be used to manipulate them.
Many others are already defined in \cite{DS/FMU/FEF/014}.

Functions which raise exceptions are modelled by functions which are
loosely defined in the ``error'' cases. Thus, the functions which call
them should not rely on them to report errors in any way.
=TEX
=TEX
We will use the function $length$ for the length of a list, (\verb+#+ in \cite{trans}) and $fold$ to fold a list into a single value ($\sp{\&}$ in \cite{trans}).
=TEX
$fold$ with a lower case $f$ is different from the HOL library $Fold$
(which has an extra parameter indicating what to do with an empty list
and turns out to have a slightly more general type).
=SML
¹HOLCONST
Ü	Ûfoldİ : ('a ¸ 'a ­ 'a) ­ 'a LIST ­ 'a
÷üüüüüüüüüüüüüüüüü
Üµf h t ·	fold f (Cons h t)
Ü	=	if	t = []
Ü		then	h
Ü		else	f(h, fold f t)
°
=TEX
The library function $Combine$ does for the  function $combine2$
of \cite{DS/FMU/FEF/019} and may easily be used for $combine3$, $combine4$
etc. Some of the idioms used in \cite{DS/FMU/FEF/020} are most neatly
expressed in HOL using a variant of $Combine$ which truncates the longer
of the two lists if necessary, we call this $splice$ (to suggest rope, which
can be cut):
¹HOLCONST
Ü	Ûspliceİ : 'a LIST ­ 'b LIST ­ ('a ¸ 'b) LIST
÷üüüüüüüüüüüüüüüüü
Üµh1 h2 list1 list2·
Ü	splice [] [] = []
Ü±	splice [] (Cons h2 list2) = []
Ü±	splice (Cons h1 list1) [] = []
Ü±	splice (Cons h1 list1) (Cons h2 list2) = Cons (h1, h2) (splice list1 list2)
°

=TEX
Now we define the function $at2$ (and $at3$ and $at4$) ($@$ in \cite{trans}) 
which turns a function taking a sequence of pairs (triples,..) into 
one taking a pair (triple,..) of sequences.
=SML
¹HOLCONST
Ü	Ûat2İ : (('a ¸ 'b) LIST ­ 'c) ­ ('a LIST ¸ 'b LIST) ­ 'c
÷üüüüüüüüüüüüüüüüüü
Ü	µf as bs· at2 f (as, bs) = f(Combine as bs)
°
=TEX
=SML
¹HOLCONST
Ü	Ûat3İ : (('a ¸ 'b ¸ 'c) LIST ­ 'd) ­ ('a LIST ¸ 'b LIST ¸ 'c LIST) ­ 'd
÷üüüüüüüüüüüüüüüüüü
Ü	µf as bs cs· at3 f (as, bs, cs) = f(Combine as (Combine bs cs))
°
¹HOLCONST
Ü	Ûat4İ : (('a ¸ 'b ¸ 'c ¸ 'd) LIST ­ 'e)
Ü		­ ('a LIST ¸ 'b LIST ¸ 'c LIST ¸ 'd LIST) ­ 'e
÷üüüüüüüüüüüüüüüüüü
Ü	µf as bs cs ds·
Ü		at4 f (as, bs, cs, ds)
Ü	=	f(Combine as (Combine bs (Combine cs ds)))
°
=TEX
The infix function $dom$ of \cite{DS/FMU/FEF/019} is just
the same as the function $dominates$ of \cite{DS/FMU/FEF/003}.
=SML
declare_infix (150, "dom");
¹HOLCONST
Ü	$Ûdomİ : Class ­ Class ­ BOOL
÷üüüüüüüüüüüüüüüüüü
Ü	$dom = $dominates
°

=TEX
For the function $invert$ we use a somewhat different formulation from \cite{DS/FMU/FEF/019}
to make the definition more evidently primitive recursive.
N.b. the case when the argument is an empty list is left loose (it is
an error case in the Standard ML version).
¹HOLCONST
Ü	Ûinvertİ : 'a LIST LIST ­ 'a LIST LIST
÷üüüüüüüüüüüü
Ü	µxs more·
Ü		invert (Cons xs more)
Ü	=	if	more = []
Ü		then	Map (Ìx· Cons x []) xs
Ü		else	Map (Ì(x, ys)· Cons x ys) (Combine xs (invert more))
°
=IGN
val invert_conv = rewrite_conv(map get_spec[¬invert®, ¬Map®, ¬Combine®]);
invert_conv ¬invert []®		(* no rewriting *);
invert_conv ¬invert [[1;2;3]]®;
invert_conv ¬invert [[1;2;3]; [4;5;6]]®;
invert_conv ¬invert [[1; 4]; [2; 5]; [3; 6]]®;
invert_conv ¬invert [[1; 4]; [2; 5]; [3; 6; 7]]®	(* ugly *);
invert_conv ¬invert [[1]; [1]; [1]; [1]]®;
=TEX
¹HOLCONST
Ü	Ûsplit3İ : ('a ¸ 'b ¸ 'c) LIST ­ 'a LIST ¸ 'b LIST ¸ 'c LIST
÷üüüüüüüüüüüü
Ü	µabcs·	split3 abcs = let (as, bcs) = Split abcs in (as, Split bcs)
°
¹HOLCONST
Ü	Ûsplit4İ : ('a ¸ 'b ¸ 'c ¸ 'd) LIST ­
Ü			'a LIST ¸ 'b LIST ¸ 'c LIST ¸ 'd LIST
÷üüüüüüüüüüüü
Ü	µabcds·	split4 abcds = let (as, bcds) = Split abcds in (as, split3 bcds)
°
¹HOLCONST
Ü	Ûsplit5İ : ('a ¸ 'b ¸ 'c ¸ 'd ¸ 'e) LIST ­
Ü			'a LIST ¸ 'b LIST ¸ 'c LIST ¸ 'd LIST ¸ 'e LIST
÷üüüüüüüüüüüü
Ü	µabcdes·	split5 abcdes = let (as, bcdes) = Split abcdes in (as, split4 bcdes)
°
\subsection{Transformation Notation}
The primitive types are 
discussed in section \ref{UNI}. We will use the HOL one-point type $ONE$ in place of $Null$.
\subsection{Data Types and Definition by Cases}
The HOL disjoint union type constructor $+$ will stand for the disjoint
union symbol $\vert$ used in the type definitions of \cite{trans}.
Both \cite{DS/FMU/FEF/020} and \cite{trans}  make frequent use of definition
by cases over the alternatives for a disjoint union type. We mimic the form
of these definitions using the following auxiliary definitions.

=SML
declare_type_abbrev(Û"OPT"İ, ["'a"], ”'a + ONE®);
¹HOLCONST
Ü	ÛCASEİ : 'a ­ ('a ­ 'b OPT) LIST ­ 'b
÷üüüüüüüüüüüüüüüü
Ü	µa f fs· CASE a (Cons f fs) =  if IsL(f a) then OutL (f a) else CASE a fs
°
¹HOLCONST
Ü	ÛOTHERSİ : 'b ­ ('a ­ 'b OPT)
÷üüüüüüüüüüüüüüüü
Ü	µb a· OTHERS b a = InL b
°
=SML
declare_type_abbrev(Û"MK_DEST"İ, ["'rep", "'abs"], ”('rep ­ 'abs) ¸ ('abs ­ 'rep)®);
declare_type_abbrev(Û"WHEN"İ, ["'rep", "'abs", "'a"], ”('rep ­ 'a) ­ ('abs ­ 'a OPT)®);
declare_type_abbrev(Û"WHEN_CONST"İ, ["'abs", "'a"], ”'a ­ 'abs ­ 'a OPT®);
¹HOLCONST
Ü	ÛLiftİ : ('rep, 'abs) MK_DEST ­ ('rep, 'abs, 'a) WHEN
÷üüüüüüüüüüüüüüüü
Üµ mk dest f a·
Ü		Lift (mk, dest) f a
Ü	=	if	mk(dest a) = a
Ü		then	InL (f (dest a))
Ü		else	InR One
°
¹HOLCONST
Ü	ÛLiftConstantİ : 'abs ­ 'a ­ 'abs ­ 'a OPT
÷üüüüüüüüüüüüüüüü
Ü	µ con a abs·
Ü		LiftConstant con a abs
Ü	=	if	abs = con
Ü		then	InL a
Ü		else	InR One
°
=TEX
The use of these will be illustrated and explained in subsequent sections.

The following material is used to represent the treatment of exceptions
in \cite{DS/FMU/FEF/029}. It is a variant of the treatment of data types
used in later sections, which gives more mnemonic names for the constructors
etc.

=SML
declare_type_abbrev(Û"RESULT"İ, ["'a"], ”'a + Errors®);
¹HOLCONST
Ü	(ÛOkİ, ÛOkValueİ) :
Ü		('a, 'a RESULT) MK_DEST;
Ü	(ÛExceptionİ, ÛExceptionValueİ) :
Ü		(Errors, 'a RESULT) MK_DEST
÷üüüüüü
Ü	Ok		= InL
Ü±	Exception	= InR
Ü±	OkValue		= OutL
Ü±	ExceptionValue	= OutR
°
=SML
declare_binder"WHEN_ok";
declare_binder"WHEN_exception";
¹HOLCONST
Ü	$ÛWHEN_okİ :
Ü		('a, 'a RESULT, 'b) WHEN;
Ü	$ÛWHEN_exceptionİ :
Ü		(Errors, 'a RESULT, 'b) WHEN
÷üüüüüü
Ü	$WHEN_ok = Lift (Ok, OkValue)
Ü±	$WHEN_exception = Lift (Exception, ExceptionValue)
°

=TEX
\subsection{Types}
=TEX
The definition of a (non-recursive) data type now follows a standard
pattern. First of all we define the name of the data type to
be an abbreviation for the underlying disjoint union type:
=SML
declare_type_abbrev(Û"TableSpecification"İ, [],
	”(STRING LIST ¸ STRING) + (î ¸ STRING LIST ¸ STRING)®);
=TEX
Next, we define constructor and destructor functions for the
data type:
¹HOLCONST
Ü	(Ûmk_absoluteİ, Ûdest_absoluteİ) :
Ü		((STRING LIST ¸ STRING), TableSpecification) MK_DEST;
Ü	(Ûmk_defaultİ, Ûdest_defaultİ) :
Ü		((î ¸ STRING LIST ¸ STRING), TableSpecification) MK_DEST
÷üüüüüü
Ü	mk_absolute	= InL
Ü±	mk_default	= InR
Ü±	dest_absolute	= OutL
Ü±	dest_default	= OutR
°
=TEX
Finally, we use $Lift$ to define functions which act, in effect, as
pattern-matching Ì-abstractions for the various alternatives of the
data type. We will use binder syntax for these functions.
Thus for example, we can write
=INLINEFT
WHEN_absolute (sl, s) · f(sl, s)
=TEX
, which is equivalent to applying the function
=INLINEFT
WHEN_absolute
=TEX
\ to the Ì-abstraction
=INLINEFT
(Ì(sl, s)· f(sl, s))
=TEX
, and, in effect, denotes that function on $TableSpecification$s which returns
the value $f(sl, s)$ for arguments of the form
=INLINEFT
mk_absolute(sl, s)
=TEX
\ and returns an error indicate ($InR\,One$) otherwise.
=SML
declare_binder"WHEN_absolute";
declare_binder"WHEN_default";
¹HOLCONST
Ü	$ÛWHEN_absoluteİ :
Ü		(STRING LIST ¸ STRING, TableSpecification, 'b) WHEN;
Ü	$ÛWHEN_defaultİ :
Ü		(î ¸ STRING LIST ¸ STRING, TableSpecification, 'b) WHEN
÷üüüüüü
Ü	$WHEN_absolute = Lift (mk_absolute, dest_absolute)
Ü±	$WHEN_default = Lift (mk_default, dest_default)
°
=TEX
The declaration of the above functions with binder syntax allows
operations on the data type to be defined in a style
which is similar to the $CASE$ constructs of \cite{trans}. For example,
the operation of extracting the directory part of a $TableSpecification$
called $ts$ say may be written as:

=GFT
	CASE ts [
		(WHEN_absolute (dir, tab) · dir)
	;	(WHEN_default (up, dir, tab) · dir)
	]
=TEX
The working of the $CASE$-construct may be seen in action using the
rewriting capability of the proof tool, for example, by executing:
=GFT ProofPower Input
rewrite_conv
(map get_spec [¬CASE®, ¬Lift®, ¬$WHEN_absolute®, ¬$mk_absolute®])
¬CASE (mk_default(99, ["dir1"; "dir2"], "tab")) [
	(WHEN_absolute (dir, tab) · dir);
	(WHEN_default (up, dir, tab) · dir)
]®;
=TEX
This returns the following theorem:
=GFT ProofPower Output
val it = ô CASE
      (mk_default (99, ["dir1"; "dir2"], "tab"))
      [WHEN_absolute (dir, tab)· dir; WHEN_default (up, dir, tab)· dir]
    = ["dir1"; "dir2"] : THM
=TEX
We treat the other data types for the transformations in a similar fashion.
In cases such as the following, involving constructors with no
argument, we just define the constant value and use $LiftConstant$ to
define the pattern-matching Ì-abstraction.
=SML
declare_type_abbrev(Û"SwordType"İ, [], ”
	ONE				(* nullType *)
+	ONE				(* monoleanType *)
+	ONE 				(* booleanType *)
+	(Int ¸ Int)			(* stringType *)
+	(Int ¸ Int)			(* fixedType *)
+	(Int ¸ TableSpecification)	(* enumType *)
+	STRING			(* timeType *)
+	STRING			(* intervalType *)
+	ONE				(* classType *)
+	ONE				(* codeType *)
+	ONE				(* anyType *)
®);
=TEX
¹HOLCONST
Ü	Ûc_nullTypeİ  : SwordType;
Ü	Ûc_monoleanTypeİ : SwordType;
Ü	Ûc_booleanTypeİ : SwordType;
Ü	(Ûmk_stringTypeİ , Ûdest_stringTypeİ) : (Int ¸ Int, SwordType) MK_DEST;
Ü	(Ûmk_fixedTypeİ , Ûdest_fixedTypeİ) : (Int ¸ Int, SwordType) MK_DEST;
Ü	(Ûmk_enumTypeİ , Ûdest_enumTypeİ)
Ü			: (Int ¸ TableSpecification, SwordType) MK_DEST;
Ü	(Ûmk_timeTypeİ , Ûdest_timeTypeİ) : (STRING, SwordType) MK_DEST;
Ü	(Ûmk_intervalTypeİ , Ûdest_intervalTypeİ) : (STRING, SwordType) MK_DEST;
Ü	Ûc_classTypeİ : SwordType;
Ü	Ûc_codeTypeİ : SwordType;
Ü	Ûc_anyTypeİ : SwordType
÷üüüüüü
Ü	c_nullType = InL One
Ü±	c_monoleanType = (InR o InL) One
Ü±	c_booleanType = (InR o InR o InL) One
Ü±	mk_stringType = InR o InR o InR o InL
Ü±	mk_fixedType = InR o InR o InR o InR o InL
Ü±	mk_enumType = InR o InR o InR o InR o InR o InL
Ü±	mk_timeType = InR o InR o InR o InR o InR o InR o InL
Ü±	mk_intervalType = InR o InR o InR o InR o InR o InR o InR o InL
Ü±	c_classType = (InR o InR o InR o InR o InR o InR o InR o InR o InL) One
Ü±	c_codeType = (InR o InR o InR o InR o InR o InR o InR o InR o InR o InL) One
Ü±	c_anyType = (InR o InR o InR o InR o InR o InR o InR o InR o InR o InR) One
Ü±
Ü	dest_stringType = OutL o OutR o OutR o OutR
Ü±	dest_fixedType = OutL o OutR o OutR o OutR o OutR
Ü±	dest_enumType = OutL o OutR o OutR o OutR o OutR o OutR
Ü±	dest_timeType = OutL o OutR o OutR o OutR o OutR o OutR o OutR
Ü±	dest_intervalType = OutL o OutR o OutR o OutR o OutR o OutR o OutR o OutR
Ü
°
=TEX
=SML
declare_binder"WHEN_stringType";
declare_binder"WHEN_fixedType";
declare_binder"WHEN_enumType";
declare_binder"WHEN_timeType";
declare_binder"WHEN_intervalType";
¹HOLCONST
Ü	$ÛWHEN_nullTypeİ : (SwordType, 'a) WHEN_CONST;
Ü	$ÛWHEN_monoleanTypeİ : (SwordType, 'a) WHEN_CONST;
Ü	$ÛWHEN_booleanTypeİ : (SwordType, 'a) WHEN_CONST;
Ü	$ÛWHEN_stringTypeİ : (Int ¸ Int, SwordType, 'a) WHEN;
Ü	$ÛWHEN_fixedTypeİ : (Int ¸ Int, SwordType, 'a) WHEN;
Ü	$ÛWHEN_enumTypeİ : (Int ¸ TableSpecification, SwordType, 'a) WHEN;
Ü	$ÛWHEN_timeTypeİ : (STRING, SwordType, 'a) WHEN;
Ü	$ÛWHEN_intervalTypeİ : (STRING, SwordType, 'a) WHEN;
Ü	$ÛWHEN_classTypeİ : (SwordType, 'a) WHEN_CONST;
Ü	$ÛWHEN_codeTypeİ : (SwordType, 'a) WHEN_CONST;
Ü	$ÛWHEN_anyTypeİ : (SwordType, 'a) WHEN_CONST
÷üüüüüü
Ü	$WHEN_nullType = LiftConstant c_nullType
Ü±	$WHEN_monoleanType = LiftConstant c_monoleanType
Ü±	$WHEN_booleanType = LiftConstant c_booleanType
Ü±	$WHEN_stringType = Lift (mk_stringType, dest_stringType)
Ü±	$WHEN_fixedType = Lift (mk_fixedType, dest_fixedType)
Ü±	$WHEN_enumType = Lift (mk_enumType, dest_enumType)
Ü±	$WHEN_timeType = Lift (mk_timeType, dest_timeType)
Ü±	$WHEN_intervalType = Lift (mk_intervalType, dest_intervalType)
Ü±	$WHEN_classType = LiftConstant c_classType
Ü±	$WHEN_codeType = LiftConstant c_codeType
Ü±	$WHEN_anyType = LiftConstant c_anyType
°
=IGN
rewrite_conv
(map get_spec [¬CASE®, ¬Lift®, ¬LiftConstant®, ¬$WHEN_nullType®,¬$c_nullType®])
¬CASE (c_codeType) [
	(WHEN_stringType x · "string");
	(WHEN_intervalType i · i);
	(WHEN_codeType "code");
	(OTHERS "others")
]®;
rewrite_conv
(map get_spec [¬CASE®, ¬Lift®, ¬LiftConstant®, ¬$WHEN_nullType®,¬$c_nullType®])
¬CASE (mk_intervalType "An Interval") [
	(WHEN_stringType x · "string");
	(WHEN_intervalType i · i);
	(WHEN_codeType "code");
	(OTHERS "others")
]®;
rewrite_conv
(map get_spec [¬CASE®, ¬Lift®, ¬LiftConstant®, ¬OTHERS®, ¬$WHEN_nullType®,¬$c_nullType®])
¬CASE (c_classType) [
	(WHEN_stringType x · "string");
	(WHEN_intervalType i · i);
	(WHEN_codeType "code");
	(OTHERS "others")
]®;
=TEX
=SML
declare_type_abbrev(Û"SsqlName"İ, [], ”
	ONE			(* anon‰s *)
+	STRING		(* name‰s *)
®);
=TEX
¹HOLCONST
Ü	Ûc_anon‰sİ  : SsqlName;
Ü	(Ûmk_name‰sİ , Ûdest_name‰sİ) : (STRING, SsqlName) MK_DEST
÷üüüüüü
Ü	c_anon‰s		= InL One
Ü±	mk_name‰s		= InR
Ü±	dest_name‰s		= OutR
°
=SML
declare_binder"WHEN_name‰s";
=TEX
¹HOLCONST
Ü	$ÛWHEN_anon‰sİ : (SsqlName, 'a) WHEN_CONST;
Ü	$ÛWHEN_name‰sİ : (STRING, SsqlName, 'a) WHEN
÷üüüüüü
Ü	$WHEN_anon‰s = LiftConstant c_anon‰s
Ü±	$WHEN_name‰s = Lift (mk_name‰s, dest_name‰s)
°
=TEX
=SML
declare_type_abbrev(Û"TsqlName"İ, [], ”
	ONE			(* none‰t *)
+	ONE			(* anon‰t *)
+	STRING		(* name‰t *)
®);
=TEX
¹HOLCONST
Ü	Ûc_none‰tİ  : TsqlName;
Ü	Ûc_anon‰tİ  : TsqlName;
Ü	(Ûmk_name‰tİ , Ûdest_name‰tİ) : (STRING, TsqlName) MK_DEST
÷üüüüüü
Ü	c_none‰t		= InL One
Ü±	c_anon‰t		= (InR o InL) One
Ü±	mk_name‰t		= InR o InR
Ü±	dest_name‰t		= OutR o OutR
°
=SML
declare_binder"WHEN_name‰t";
=TEX
¹HOLCONST
Ü	$ÛWHEN_none‰tİ : (TsqlName, 'a) WHEN_CONST;
Ü	$ÛWHEN_anon‰tİ : (TsqlName, 'a) WHEN_CONST;
Ü	$ÛWHEN_name‰tİ : (STRING, TsqlName, 'a) WHEN
÷üüüüüü
Ü	$WHEN_none‰t = LiftConstant c_none‰t
Ü±	$WHEN_anon‰t = LiftConstant c_anon‰t
Ü±	$WHEN_name‰t = Lift (mk_name‰t, dest_name‰t)
°
=TEX
=SML
declare_type_abbrev(Û"ColType"İ, [], ”SwordType ¸ SwordType®);
=TEX
=SML
declare_type_abbrev(Û"BoundInfo"İ, [], ”
	Class			(* upb *)
+	Class			(* constant *)
®);
=TEX
¹HOLCONST
Ü	(Ûmk_upbİ , Ûdest_upbİ) : (Class, BoundInfo) MK_DEST;
Ü	(Ûmk_constantİ , Ûdest_constantİ) : (Class, BoundInfo) MK_DEST
÷üüüüüüüüüüüüüüüüü
Ü	mk_upb	= InL
Ü±	mk_constant	= InR
Ü±	dest_upb	= OutL
Ü±	dest_constant	= OutR
°
=SML
declare_binder"WHEN_upb";
declare_binder"WHEN_constant";
=TEX
¹HOLCONST
Ü	$ÛWHEN_upbİ : (Class, BoundInfo, 'a) WHEN;
Ü	$ÛWHEN_constantİ : (Class, BoundInfo, 'a) WHEN
÷üüüüüüüüüüüüüüüüüü
Ü	$WHEN_upb = Lift (mk_upb, dest_upb)
Ü±	$WHEN_constant = Lift (mk_constant, dest_constant)
°
=TEX
¹HOLLABPROD ÛSsqlColİüüüüüüüüüüüüüüüüüüü
Ü	Ûsc_nameİ	:	SsqlName;
Ü	Ûsc_type_fieldİ	:	ColType;
Ü	Ûsc_col_existİ	:	Class;
Ü	Ûsc_col_classİ	:	BoundInfo
°üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
=TEX
=SML
declare_type_abbrev(Û"TsqlClassName"İ, [], ”
	ONE			(* anon‰t‰c *)
+	STRING		(* name‰t‰c *)
+	Class			(* constant‰t‰c *)
®);
=TEX
¹HOLCONST
Ü	Ûc_anon‰t‰cİ : TsqlClassName;
Ü	(Ûmk_name‰t‰cİ , Ûdest_name‰t‰cİ) : (STRING, TsqlClassName) MK_DEST;
Ü	(Ûmk_constant‰t‰cİ , Ûdest_constant‰t‰cİ) : (Class, TsqlClassName) MK_DEST
÷üüüüüüüüüüüüüüüüü
Ü	c_anon‰t‰c		= InL One
Ü±	mk_name‰t‰c		= InR o InL
Ü±	mk_constant‰t‰c		= InR o InR
Ü±	dest_name‰t‰c		= OutL o OutR
Ü±	dest_constant‰t‰c	= OutR o OutR
°
=SML
declare_binder"WHEN_name‰t‰c";
declare_binder"WHEN_constant‰t‰c";
=TEX
¹HOLCONST
Ü	$ÛWHEN_anon‰t‰cİ : (TsqlClassName, 'a) WHEN_CONST;
Ü	$ÛWHEN_name‰t‰cİ : (STRING, TsqlClassName, 'a) WHEN;
Ü	$ÛWHEN_constant‰t‰cİ : (Class, TsqlClassName, 'a) WHEN
÷üüüüüüüüüüüüüüüüüü
Ü	$WHEN_anon‰t‰c = LiftConstant c_anon‰t‰c
Ü±	$WHEN_name‰t‰c = Lift (mk_name‰t‰c, dest_name‰t‰c)
Ü±	$WHEN_constant‰t‰c = Lift (mk_constant‰t‰c, dest_constant‰t‰c)
°
=TEX
¹HOLLABPROD ÛTsqlColİüüüüüüüüüüüüüüüüüüü
Ü	Ûtc_sterling_nameİ	:	TsqlName;
Ü	Ûtc_dinary_nameİ	:	TsqlName;
Ü	Ûtc_class_nameİ	:	TsqlClassName
°üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
=TEX
=SML
¹HOLLABPROD ÛTableInfoİüüüüüüüüüüüüüüüüüüü
Ü	Ûti_table_exist_classİ	:	Class;
Ü	Ûti_table_classİ	:	Class;
Ü	Ûti_row_classİ		:	BoundInfo
°üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
=TEX
¹HOLLABPROD ÛConstraintInfoİüüüüüüüüüüüüüüüüüüü
Ü	Ûci_null_allowedİ	:	BOOL LIST;
Ü	Ûci_lwbİ			:	Class LIST;
Ü	Ûci_uniqueİ		:	î LIST LIST;
Ü	Ûci_uniformİ		:	î LIST LIST;
Ü	Ûci_indexİ		:	î LIST LIST
°üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
=TEX
=SML
declare_type_abbrev(Û"ColumnSpecification"İ, [], ”
	STRING					(* anonymous_column *)
+	(TableSpecification ¸ STRING)		(* specific *)
®);
=TEX
¹HOLCONST
Ü	(Ûmk_anonymous_columnİ , Ûdest_anonymous_columnİ)
Ü		: (STRING, ColumnSpecification) MK_DEST;
Ü	(Ûmk_specificİ , Ûdest_specificİ)
Ü		: (TableSpecification ¸ STRING, ColumnSpecification) MK_DEST
÷üüüüüüüüüüüüüüüüü
Ü	mk_anonymous_column	= InL
Ü±	mk_specific			= InR
Ü±	dest_anonymous_column	= OutL
Ü±	dest_specific			= OutR
°
=SML
declare_binder"WHEN_anonymous_column";
declare_binder"WHEN_specific";
=TEX
¹HOLCONST
Ü	$ÛWHEN_anonymous_columnİ : (STRING, ColumnSpecification, 'a) WHEN;
Ü	$ÛWHEN_specificİ
Ü		: (TableSpecification ¸ STRING, ColumnSpecification, 'a) WHEN
÷üüüüüüüüüüüüüüüüüü
Ü	$WHEN_anonymous_column = Lift (mk_anonymous_column, dest_anonymous_column)
Ü±	$WHEN_specific = Lift (mk_specific, dest_specific)
°
=TEX
=SML
declare_type_abbrev(Û"TsqlRepr"İ, [], ”
	STRING					(* local_identifier *)
+	(STRING ¸ STRING)			(* column *)
+	Class					(* constant_class *)
+	ONE					(* constant_null *)
®);
=TEX
¹HOLCONST
Ü	(Ûmk_local_identifierİ , Ûdest_local_identifierİ)
Ü		: (STRING, TsqlRepr) MK_DEST;
Ü	(Ûmk_columnİ , Ûdest_columnİ)
Ü		: (STRING ¸ STRING, TsqlRepr) MK_DEST;
Ü	(Ûmk_constant_classİ , Ûdest_constant_classİ)
Ü		: (Class, TsqlRepr) MK_DEST;
Ü	Ûc_constant_nullİ : TsqlRepr
÷üüüüüüüüüüüüüüüüü
Ü	mk_local_identifier	= InL
Ü±	mk_column		= InR o InL
Ü±	mk_constant_class	= InR o InR  o InL
Ü±	c_constant_null	= (InR o InR o InR) One
Ü±	dest_local_identifier	= OutL
Ü±	dest_column		= OutL o OutR
Ü±	dest_constant_class	= OutL o OutR o OutR
°
=SML
declare_binder"WHEN_local_identifier";
declare_binder"WHEN_column";
declare_binder"WHEN_constant_class";
=TEX
¹HOLCONST
Ü	$ÛWHEN_local_identifierİ : (STRING, TsqlRepr, 'a) WHEN;
Ü	$ÛWHEN_columnİ : (STRING ¸ STRING, TsqlRepr, 'a) WHEN;
Ü	$ÛWHEN_constant_classİ : (Class, TsqlRepr, 'a) WHEN;
Ü	$ÛWHEN_constant_nullİ : (TsqlRepr, 'a) WHEN_CONST
÷üüüüüüüüüüüüüüüüüü
Ü	$WHEN_local_identifier = Lift (mk_local_identifier, dest_local_identifier)
Ü±	$WHEN_column = Lift (mk_column, dest_column)
Ü±	$WHEN_constant_class = Lift (mk_constant_class, dest_constant_class)
Ü±	$WHEN_constant_null = LiftConstant c_constant_null
°
=TEX
=SML
declare_type_abbrev( Û"ExpType"İ, [], ”SwordType ¸ Worth®);
=TEX
=SML
declare_type_abbrev(Û"ExpClass"İ, [], ”
	(Value ¸ Class)			(* variable *)
+	Class					(* constant‰e‰c *)
®);
=TEX
¹HOLCONST
Ü	(Ûmk_variableİ , Ûdest_variableİ)
Ü		: (Value ¸ Class, ExpClass) MK_DEST;
Ü	(Ûmk_constant‰e‰cİ , Ûdest_constant‰e‰cİ)
Ü		: (Class, ExpClass) MK_DEST
÷üüüüüüüüüüüüüüüüü
Ü	mk_variable		= InL
Ü±	mk_constant‰e‰c		= InR
Ü±	dest_variable		= OutL
Ü±	dest_constant‰e‰c	= OutR
°
=SML
declare_binder"WHEN_variable";
declare_binder"WHEN_constant‰e‰c";
=TEX
¹HOLCONST
Ü	$ÛWHEN_variableİ : (Value ¸ Class, ExpClass, 'a) WHEN;
Ü	$ÛWHEN_constant‰e‰cİ : (Class, ExpClass, 'a) WHEN
÷üüüüüüüüüüüüüüüüüü
Ü	$WHEN_variable = Lift (mk_variable, dest_variable)
Ü±	$WHEN_constant‰e‰c = Lift (mk_constant‰e‰c, dest_constant‰e‰c)
°
=TEX
=SML
declare_type_abbrev(Û"InternalExpClass"İ, [], ”
	(Value LIST ¸ ExpClass LIST)		(* ands *)
+	(Value LIST ¸ ExpClass LIST)		(* ors *)
+	ExpClass					(* simple *)
®);
=TEX
¹HOLCONST
Ü	(Ûmk_andsİ , Ûdest_andsİ)
Ü		: (Value LIST ¸ ExpClass LIST, InternalExpClass) MK_DEST;
Ü	(Ûmk_orsİ , Ûdest_orsİ)
Ü		: (Value LIST ¸ ExpClass LIST, InternalExpClass) MK_DEST;
Ü	(Ûmk_simpleİ , Ûdest_simpleİ)
Ü		: (ExpClass, InternalExpClass) MK_DEST
÷üüüüüüüüüüüüüüüüü
Ü	mk_ands	= InL
Ü±	mk_ors		= InR o InL
Ü±	mk_simple	= InR o InR
Ü±	dest_ands	= OutL
Ü±	dest_ors	= OutL o OutR
Ü±	dest_simple	= OutR o OutR
°
=SML
declare_binder"WHEN_ands";
declare_binder"WHEN_ors";
declare_binder"WHEN_simple";
=TEX
¹HOLCONST
Ü	$ÛWHEN_andsİ : (Value LIST ¸ ExpClass LIST, InternalExpClass, 'a) WHEN;
Ü	$ÛWHEN_orsİ : (Value LIST ¸ ExpClass LIST, InternalExpClass, 'a) WHEN;
Ü	$ÛWHEN_simpleİ : (ExpClass, InternalExpClass, 'a) WHEN
÷üüüüüüüüüüüüüüüüüü
Ü	$WHEN_ands = Lift (mk_ands, dest_ands)
Ü±	$WHEN_ors = Lift (mk_ors, dest_ors)
Ü±	$WHEN_simple = Lift (mk_simple, dest_simple)
°
=TEX
=SML
declare_type_abbrev(Û"TableName"İ, [], ”
	ONE			(* anon‰t‰n *)
+	TableSpecification	(* name‰t‰n *)
®);
=TEX
¹HOLCONST
Ü	Ûc_anon‰t‰nİ  : TableName;
Ü	(Ûmk_name‰t‰nİ , Ûdest_name‰t‰nİ) : (TableSpecification, TableName) MK_DEST
÷üüüüüü
Ü	c_anon‰t‰n		= InL One
Ü±	mk_name‰t‰n		= InR
Ü±	dest_name‰t‰n		= OutR
°
=SML
declare_binder"WHEN_anon‰t‰n";
declare_binder"WHEN_name‰t‰n";
=TEX
¹HOLCONST
Ü	$ÛWHEN_anon‰t‰nİ : (TableName, 'a) WHEN_CONST;
Ü	$ÛWHEN_name‰t‰nİ : (TableSpecification, TableName, 'a) WHEN
÷üüüüüü
Ü	$WHEN_anon‰t‰n = LiftConstant c_anon‰t‰n
Ü±	$WHEN_name‰t‰n = Lift (mk_name‰t‰n, dest_name‰t‰n)
°
=TEX
\subsection{The Symbol Table}
=SML
¹HOLLABPROD ÛTableDetailİüüüüüüüüüüüüüüüüüüü
Ü	Ûtd_tableNameİ		:	TableName;
Ü	Ûtd_corrNameİ		:	SsqlName;
Ü	Ûtd_genCorrİ		:	STRING;
Ü	Ûtd_infoİ		:	TableInfo;
Ü	Ûtd_columnsİ		:	SsqlCol LIST;
Ü	Ûtd_rowClassİ		:	TsqlClassName;
Ü	Ûtd_implementationİ	:	TsqlCol LIST;
Ü	Ûtd_constraintsİ	:	ConstraintInfo
°üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
=TEX
¹HOLLABPROD ÛIdentDetailİüüüüüüüüüüüüüüüüüüü
Ü	Ûid_identNameİ	:	STRING;
Ü	Ûid_infoİ		:	ExpType;
Ü	Ûid_lub‰i‰dİ		:	Class;
Ü	Ûid_vNameİ		:	STRING;
Ü	Ûid_cNameİ		:	TsqlName
°üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
=TEX
¹HOLLABPROD ÛScopeİüüüüüüüüüüüüüüüüüüü
Ü	Ûs_tablesİ		:	TableDetail LIST;
Ü	Ûs_identifiersİ		:	IdentDetail LIST
°üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
=TEX
In the following, for the time being $Value$ (from \cite{DS/FMU/FEF/014}
is used instead of $ConstantValue$.
¹HOLLABPROD ÛParamInfoİüüüüüüüüüüüüüüüüüüü
Ü	Ûpi_nameİ		:	STRING;
Ü	Ûpi_val‰pİ		:	Value;
Ü	Ûpi_clasfİ		:	Class
°üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
=TEX
The state accessed by the symbol table routines has the following two
components. It is managed as a stack using the functions
$new\_scope$ of \cite{DS/FMU/FEF/029} (corresponding to the ``block-structured''
use of $enter\_scope$ and $leave\_scope$ in \cite{trans}). The
$enter\_ldots$ functions of \cite{DS/FMU/FEF/029} operate by updating
the top of the stack.
=TEX
¹HOLLABPROD ÛST_STACKİüüüüüüüüüüüüüüüüüüü
Ü	ÛsymbolTableİ		:	Scope LIST;
Ü	ÛparameterTableİ	:	ParamInfo LIST
°üüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
=TEX
\section{CLOSING DOWN}
=SML
output_theory{theory = "fef028",out_file = "fef028th.doc"};
=TEX
\newpage
=TEX
\HOLindexOff
\input{fef028th.tex}
\HOLindexOn
=TEX
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}



