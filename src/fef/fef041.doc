=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Briefing for CLEF}  %% Mandatory field
\TPPref{DS/FMU/FEF/041}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Project Overview}
\TPPkeywords{}
\TPPauthor{R.~Stokes & WIN01\\ R.B.~Jones}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.~B.~Jones & HAT Manager}
\TPPabstract{This document provides a briefing suitable for a CLEF on the results of the formal methods work carried out by ICL for the DRA Front End 
Filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File 
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\listoftables
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[\SCCSversion ({\FormatDate{94/01/11
}})] Current issue.
\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope} \label{scope}
This document is a report on the results of the formal specification and verification work carried out by ICL as part of the development by DRA of SWORD, a secure relational database system.
ICL's work on this project is generally referred to as the ``FEF project'' in the rest of this document.

This document is primarily produced in support of the intention of DRA to commission from a CLEF a further report.  We understand from DRA that the latter report has a number of aims.
The main aim of relevance here is to:  
\begin{quote}
Provide an  assessment of whether the SWORD Front End approach is capable of achieving a useful ITSEC rating.
\end{quote}

and the main relevant associated deliverable is taken to be:
\begin{quote}
A report which gives an assessment of the assurance levels that the approach could attain, and the likely costs of such an evaluation.
\end{quote}

The reference to evaluation costs is taken to be to costs recoverable by a CLEF in performing an evaluation, and is not in the scope of this report.
%Nor will this report be concerned with quantifying effort or costs for the FEF project. 
 
This report is written on the following assumptions derived from discussions with DRA:

\begin{itemize}

\item
It is understood that DRA are interested primarily in the possibilities for an ITSEC Assurance Correctness Level of E3.

\item
It is assumed that evaluation would be as a {\em product}, (that is, according to ITSEC 1.4,  a package which can be bought off the shelf), as opposed to a {\em system} or specific installation. 

\item
DRA have a general interest in the value of Formal Methods in the development of secure systems, both for systems intended for evaluation at E5 or E6, and also for systems intended for evaluation at lower levels for which the use of formal methods is not mandated by ITSEC.
This interest is not confined to, but does encompass, the contribution which Formal Methods might make to a successful evaluation at any particular level.

=IGN
The purpose of proof work carried out in this project is comparable with the aim of  [ITSEC 4.24], viz.: `ensuring that each representation of a design or its implementation ... can be shown to correspond correctly to the previous representation on which it is based.'
Although this is described in the ITSEC under the heading `Configuration Control', DRA's interest is understood to be in progression from one representation to the next as a design (or implementation) step, not merely an ad-hoc change to a configuration-management item.
=TEX

\end{itemize} 

The intention in writing this report is to try to assist the CLEF, by providing a first introduction to the results of the FEF project.   These results, or similar results, may be considered as possible evaluation deliverables, and so some comments are offered,  in the hope that they may be useful to the CLEF, but not with the intention of trying to pre-empt the judgement of the CLEF.  

\subsection{Introduction}

This report is divided into five further sections. 

Section \ref{objectives}, describes the objectives of the formal methods work.
 
Section \ref{performance}, describes the key achievements against the identified objectives.
 
Section \ref{descriptionofresults}, aims at describing the results of the FEF project, particularly from the point of view of describing the significance of the various formal specifications and of the theorems which have been proved about them.

Sections \ref{raede6} and \ref{raed}, aims at relating the the results of the FEF project to possible deliverables for an evaluation at various levels of the ITSEC criteria. It is recognised that the FEF project is of the nature of research, while evaluation deliverables will be produced by a development project.
Consequently, what is said in this section about the FEF results is meant to apply to some evaluation scenario in which the deliverables would be similar to the FEF results.

Section \ref{oac}, offers observations and conclusions.

\subsection{Terminology and Abbreviations}

\begin{tabular}{lp{5in}}
DBMS & database management system  \\
FEF & Front End Filter: used to describe an implementation technique for SSQL whereby SSQL queries provided by a client user or process are transformed into TSQL queries which are then executed on a standard commercial DBMS; output from the TSQL queries is filtered to remove sensitive information before it is returned to the client.
In this document the phrase `FEF project' is used to refer to ICL's work on the formal specification and verification of aspects of the FEF development being undertaken by DRA.\\
SQL  & Structured Query Language.  A standard language for querying and updating a database. \\
SSQL & a variant of the SQL database query language with features supporting  multilevel security.  SSQL differs from SQL mainly in that there is an additional data type, $Class$, for security-classifications, which is used to classify the information held in tables and their constituent rows and columns.\\
TSQL & Target SQL: a variant of SQL, augmented with a data type $Class$ which can be used to represent security-classifications, but has no other special interpretation.
%TSQL is expected to be closely approximated by standard commercial DBMS offerings.
\\
\end{tabular} 

\section{THE OBJECTIVES OF THE FORMAL METHODS WORK}\label{objectives}

The objectives of the formal methods work undertaken under contract RSRE 1C/6130 (as set out in Annex 9 to the ITT) were:

\begin{itemize}

\item
To provide an assessment of the applicability of computerised mathematical theorem proving tools to the construction of secure systems of realistic size and complexity.

\item
To result, in combination with DRA in-house work, in the production of a prototype secure DBMS capable of being evaluated to a medium level of assurance. 

\end{itemize}

The work completed to date has fallen into two distinct phases which had more specific objectives as follows.

In the first phase the primary objective (see \cite{DS/FMU/017} Section 2.1) was:

\begin{itemize}

\item
The production of a machine-checked formal proof of the security of an abstract machine modelling a secure database supporting the query language {\it SSQL} as defined by DRA in Annex~2 to the ITT.

\end{itemize}

The second phase of the work was to involve formal modeling of the design of the front end filter rather than the SSQL semantics.
After reviewing the requirements for Phase 2 in the light of the results of Phase 1 the following revised statement of objectives was agreed (see \cite{DS/FMU/FEF/018} Section 1.2):

\begin{itemize}
\begin{itemize}

\item
To use the proof process to discover flaws in the specifications.

\item
To evolve the specification during the course of the proof as necessary to render it satisfactory.

\end{itemize}

The main purpose of the requirement for Phase 2 in the original ITT was to verify the design of the Front End Filter.
The most important (if not the only) concern was that the filter would result in a secure database.

This proposal for Phase 2 therefore attempts to provide the most effective way of employing formal modelling and proof to improve confidence in the security of the Front End Filter.

\end{itemize}

The specifications referred to in the Phase 2 proposal are those of the front end filter, the relevant notion of security is that in the formal security policy \cite{DS/FMU/FEF/003}.

\section{ACHIEVEMENTS IN RELATION TO OBJECTIVES} \label{performance}

In summary, the key achievements in relation to the stated objectives were as follows.
A fuller description of the results may be found in Section \ref{descriptionofresults}, with more detailed descriptions of the errors which were detected in specifications as a result of the formal methods work in Section \ref{issuesdetected}.

\subsection{Phase 1}

The original objectives took the required Phase 1 proof to be concerned with {\it confirming} the correctness of the specifications (w.r.t. the formal security model), while acknowledging a risk that the specifications might prove not to be correct.

In fact the formal work proved more valuable than had been anticipated.
Significant numbers of minor errors were discovered in the specifications and corrected during the formalisation, syntax checking and type checking of the specifications.

During the proof work one error was discovered which rendered the SSQL asbtract machine as specified insecure.
This error was corrected and the formal proofs were completed.

Thus the primary objective of Phase 1 was fully satisfied, and in addition a number of errors were detected and corrected in the original specifications.

\subsection{Phase 2}

The objectives of the Phase 2 work were reviewed prior to the commencement of Phase 2, and re-oriented toward using the formal specification and proof work for detecting residual errors in the design specifications for the Front End Filter.

Partial formal proofs of the security of the SSQL system as implemented using the Front End Filter were then undertaken.

Though the greater complexity of the security relevant aspects of the specifications (by comparison with Phase 1) prevented completion of the relevant proofs, partial proofs were accomplished as planned.
The rate of detection of errors was similar to that in Phase 1, but the proportion of those errors which could be described as substantive errors in the security of the specifications was significantly higher in Phase 2 than in Phase 1.

\section{DESCRIPTION OF RESULTS} \label{descriptionofresults}

\subsection{Introduction}

The work under the FEF project considered in this document was commissioned and carried out in two phases.
The bulk of the work was carried out from January 1992 to December 1993 and each phase took approximately 1 year of elapsed time.

The main technical aim of Phase 1 was to produce a formal specification of the semantics of SSQL in a form suitable for processing using a computerised theorem-proving system and to provide a machine-checked proof that the SSQL semantics provided information-flow security according to an agreed formalisation of the `No Flows Down' security policy.
An important feature of the approach taken was to structure the formal specification of the SSQL semantics so that security critical aspects were clearly separated out.

The original intention in Phase 2 had been to verify that the formal model of the Front End implementation of SWORD was a `security refinement' (as defined in \cite{DS/FMU/017} Section 6.1) of the SSQL abstract machine (as specified in Phase 1) and so to demonstrate that it was secure.
However, the requirements on Phase 2 were reviewed towards the end of Phase 1, and it was agreed that the complexity of the implementation was likely to make a full correctness proof prohibitively expensive.
Moreover, complete informal specifications of the implementation were no longer scheduled to be available within the timescales which would be required for a complete formal model of the implementation to be constructed.
The actual objectives of Phase 2 were therefore to use the formal specification and  proof process to discover any security flaws in the informal specifications and to evolve the formal specifications during the course of the proof work in order to give insight into possible solutions to these flaws.

The deliverables of the FEF project mainly comprise documents containing either specifications or scripts which prove theorems.
The specifications and theorems are expressed in the {\ProductHOL} language which is supported by ICL's {\Product} tool \cite{DS/FMU/IED/USR014}.
{\ProductHOL} is a mathematical formalism for specifying models of systems, and for formulating and proving theorems about such models; the surface syntax for {\ProductHOL} specifications is in some ways similar to the Z notation \cite{Spivey89}.
The {\Product} tool gives computerised support for both specification and proof via comprehensive and programmable facilities for developing and interrogating a database of specifications and theorems.
The database is organised as an extensible hierarchy of modules referred to as ``theories''.
It also gives facilities for preparing documents containing a mixture of narrative and mathematical material optionally including theory listings giving a precise summary of the mathematical content of the objects specified in a theory and of the theorems which have been proved about them.
Most of the FEF project deliverables are documents containing both the narrative material and tool input which describe and construct a theory together with the theory listing.

The results of the formal treatment from the two phases are discussed in more detail in sections \ref{phase1results} and \ref{phase2results} below.

In addition to the formal documents themselves, a key output of the work  is the feedback to the DRA designers about security and other problems which were found during the course of the work. This is discussed briefly in Section \ref{issuesdetected}.
The document \cite{DS/FMU/FEF/002} discusses these.

\subsection{Phase 1 Results}\label{phase1results}

\subsubsection{Overview} \label{phase1resultsoverview}

In addition to the formulation of the Security Model, the main specification in Phase 1 was the formal construction of a model of a specific, although quite abstract, system to which the Security Model is formally applicable.
This system, the SSQL Abstract Machine, which could be considered as the specification of an abstract SSQL processor, is intended to serve as a formal definition of the SSQL semantics.
The main proof work in Phase 1 was to verify that the SSQL Abstract Machine is secure in the sense of the Security Model.
The specification of the SSQL Abstract Machine is constructed in such a way that the critical security features are separated out from the specification of detailed functionality, both to facilitate the proof and to make clear what is and is not essential to security.

Sections \ref{sm} to \ref{secureSSQL} below discuss the Phase 1 results and their significance in greater detail.

\subsubsection{Security Model} \label{sm}

The Security Model defines a property $secure$ as non-interference for sequences of inputs and outputs of an abstract state-machine.
The property $secure$ is documented in \cite{DS/FMU/FEF/003}.
Note that the Security Model was actually formalised and agreed in advance of Phase 1 and was taken as the common overall statement of critical security requirements for both phases of the work.

\subsubsection{SSQL Semantics}  \label{ss}

The specification of the semantics of SSQL describes how the result of an SSQL query is computed from the state of the database, covering both the response returned to the user and the new state.

This is factored into three components, two of which contain all the security relevant details and one of which provides security insensitive aspects.
This structure is described in \cite{DS/FMU/017} Section 6.3.4.

Of the two security relevant parts one (known as `hide' \cite{DS/FMU/FEF/005}) determines the constraints on read access to the database which apply at the clearance of the query submitted, and the other (`update' \cite{DS/FMU/FEF/005}) determines the constraints on write access to the database at the relevant clearance.
In the context of these constraints the detailed semantics of the query language (`process query' \cite{DS/FMU/FEF/014}) can be specified in a way which does not contribute to the complexity of the security proof.

=IGN
Note that the fact that this is an SSQL query means that a classification is computed for the result, but does not mean that the result is sanitized for the clearance at which the query is submitted.
=TEX
 
The specification of `process query' is incomplete (that is, loose), in certain respects.
Of the four kinds of query (insert, delete, update and select), it is only for select that full details of the functionality are specified.  
The specifications together contain sufficient information to establish that the SSQL Abstract Machine of Section \ref{sam} will be secure however the omitted details are filled in, as demonstrated by the completion of the proof against the formal model of the security policy.
  
\subsubsection{SSQL Abstract Machine}\label{sam}

To establish conformance of the system to the policy a `behavioural model' of the system is required.
This is constructed in two stages from the components of the SSQL semantics.

In the first stage a model of the target system as a state transition system is constructed.
This is known as the `SSQL Abstract Machine'.

In the second stage an operation of `behavioural abstraction' is performed on this abstract machine to give a behavioural model of the kind required in the security model.

The SSQL Abstract Machine consists of two parts:

\begin{itemize}
\item
The transition function.
\item
The initial state of the system.
\end{itemize}

The transition function is constructed from the three components of the SSQL semantics.
A view of the database state is constructed which hides anything not in the user's clearance (using the `hide' component of the semantics).
The query is then processed against this view (and thus with `no read up') using the `process query' component.
The results of the query are then applied to the database using the `update' component of the semantics, which also computes the output to be supplied to the user.
The `update' component is responsible for ensuring that there is no `write down'.

The initial state is loosely specified as conforming only to essential security invariants on the state.

The SSQL abstract machine is documented in \cite{DS/FMU/FEF/006} under the name of $SSQLam$. 

\subsubsection{Theorem about $SSQLam$}\label{secureSSQL}

The following theorem is proved as the key result in Phase 1:

=GFT
	Ù behaviours SSQLam ç secure
=TEX

A theorem is expressed in {\ProductHOL} as an optional list of assumptions followed by the turnstile symbol, ``Ù'', followed by a formula, called the conclusion of the theorem.
The theorem is the assertion that the conclusion is true provided all the assumptions are.
The {\Product} system ensures that the only theorems which can be computed are ones which have been derived from an identifiable list of axioms and definitions via mathematically sound rules of reasoning.
In this case, there are no assumptions, and the conclusion expresses a relationship between three named objects whose definitions form part of Phase 1 specification work.
The theorem asserts that the result of applying the behavioural abstraction operation, $behaviours$, to the SSQL Abstract Machine, $SSQLam$ produces a system which belongs to the set, $secure$, of systems which conform to the Security Model.

The proof is documented in \cite{DS/FMU/FEF/015} under the name $secureSSQL$.
The proof comprises a formal validation of the fact expressed by the above theorem, viz., that the behaviours of the abstract-state machine $SSQLam$ satisfy the information-flow constraints imposed by the Security Model of Section \ref{sm}.   
\subsection{Phase 2 Results} \label{phase2results}

\subsubsection{Overview} \label{phase2resultsoverview}

In the Phase 2 specifications, various aspects of the actual Front End implementation of SWORD were modelled with a view to doing relevant proof work to discover security problems in the design.
The specifications were structured to expose security critical aspects of the design so that proof work could be done in the areas where most benefit was likely to be derived.
At the top level a formal model is given of the overall system architecture.
This gives rise to decomposition of the critical security properties into properties of the top level subsystems of the actual Front End design, together with an opportunity to verify that the critical properties on the subsystems are sufficient for overall system security.
However, these subsystems as they are do not partition conveniently into security-critical and non-critical parts.
At the next level down the interactions between the subsystems were investigated by relating them to a slightly more abstract view of query execution.
At the third level, the constraints on query execution are re-expressed in terms of an explicit model which can be directly related to the SSQL syntax and which specifies precisely the security-relevant computations which are to be performed when a query is executed.

The main proof work was done at the third level, to prove that the model satisfies information-flow constraints which, intuitively, at least, bear a close relationship with the overall Security Model.
Proof work was also done to give a partial proof that these information-flow constraints are sufficient to ensure conformance of the system to the security requirements.
This amounts to showing that satisfaction of the information-flow constraints, together with some plausible assumptions about other aspects of the system, does entail that a system constructed according to the architectural model will conform to the Security Model.
A small amount of pilot proof work was carried out at the other two levels (however, the proof work at the top-level is not further discussed below).

Sections \ref{soa} to \ref{Thv} below discuss the Phase 2 results and their significance in greater detail.


\subsubsection{Specification of Architecture}  \label{soa}
Specification of the architecture of a DBMS, as a construction in terms of specified subsystems.  The construction itself is called $FE\_SWORD$, \cite{DS/FMU/FEF/022},  and the architectural subsystems are 
    \begin{itemize}
    \item  $TSQLtf$,  \cite{DS/FMU/FEF/021}, corresponding to a ``conventional DBMS'',
           implementing  $TSQL$.    This may or may not be implemented in reality by a ``standard commercial DBMS'', and so            to avoid taking a position on this issue this architectural component will here be called  the ``TSQL engine''.
    \item  $STP$  (``SSQL Transformation Processor'', \cite{DS/FMU/FEF/029}) which transforms queries input in SSQL to queries in TSQL to be submitted to the TSQL engine. 
    \item  $outputFilter$,   \cite{DS/FMU/FEF/024}, which sanitises results from the TSQL engine before passing them back to the user. 
\end{itemize}

The construction also requires a state-representation function, specified as $reprState$ in \cite{DS/FMU/FEF/025}.

\subsubsection{Specification of Security-Critical Properties}  \label{scp}
Specification of security-critical properties of the architectural construction and subsystems.   These are documented in \cite{DS/FMU/FEF/022} under the names:
\begin{center}
\begin{tabular}{l}
$subsys\_secure$  \\  
$subsys\_secureA$ \\
$subsys\_secureB$ \\
$subsys\_secureC$ \\
$subsys\_secureD$ \\
$subsys\_secureE$ \\
\end{tabular}
\end{center}

\subsubsection{Subsystem Lemmas} \label{subsystemlemmas}

The statement of a collection of lemmas, which may be called the `subsystem' lemmas.  Taken together, these lemmas assert that  the security-critical properties (Section \ref{scp} above) are true of the construction and subsystems of the architecture. 

Thus a proof of security assuming the lemmas will be a proof of the correctness of the architectural structuring as a first design-step. Since the lemmas are stated in terms of specifications of the individual subsystems of the architecture, they represent proof-obligations which are carried forward to later design-steps.  The subsystem lemmas are documented in \cite{DS/FMU/FEF/034} under the names:

\begin{center}
\begin{tabular}{l}
$Architecture\_Secure$  \\  
$Subsys\_SecureA$ \\
$Subsys\_SecureB$ \\
$Subsys\_SecureC$ \\
$Subsys\_SecureD$ \\
$Subsys\_SecureE$ \\
\end{tabular}
\end{center}
 
\subsubsection{Specification of $FE\_SWORD\_SYSTEM$} \label{soFESS}

$FE\_SWORD\_SYSTEM$ is a DBMS; it is  the architectural construction applied to the architectural subsystems. It is defined in \cite{DS/FMU/FEF/034}.

\subsubsection{Proof of $Theorem1$}
$Theorem1$, stated and proved in \cite{DS/FMU/FEF/034}, is  

=GFT
	Architecture_Secure,   
	Subsys_SecureA,
	Subsys_SecureB,
	Subsys_SecureC,
	Subsys_SecureD,
	Subsys_SecureE
	Ù  FE_SWORD_SYSTEM_secure
=TEX

Here there are 6 assumptions, namely the subsystem lemmas described in Section \ref{subsystemlemmas} above.
The conclusion of the theorem here is the boolean term $FE\_SWORD\_SYSTEM\_secure$.
This is defined in \cite{DS/FMU/FEF/034} to be equivalent to $FE\_SWORD\_SYSTEM \in secure$, (and so the theorem has a similar form to the main theorem, $secureSSQL$,  of Phase 1, discussed in Section \ref{secureSSQL}).
This result shows that the architecture specified is correct with regard to the Security Model. In other words,  the security-critical requirements on the subsystems and the construction have been correctly identified in that they are indeed sufficient to ensure the security of the constructed DBMS. 

\subsubsection{Specification of Execution Model}

What is called the `Execution Model' represents a conceptual step in the development process following on from the Architecture definition.  The Execution Model  may be described as a specification of a new constraint on the architectural subsystems  $TSQLtf$ and $STP$.  The purpose of the constraint is to provide an alternative to the somewhat intractable semantics of TSQL for use in the further formal modelling. 

The Execution Model is documented in \cite{DS/FMU/FEF/026} through the specification of three new objects: $EM_1$,  $compile$ and $upd$.  $EM_1$ is a constant, while $compile$ and $update$ are variables (representing subsystems whose detailed specification is not available).
$EM_1$ is a construction function for composing the two subsystems $compile$ and $upd$.
$compile$ models compilation a query to give a formal representation of a database operation; $upd$ models the use of the result of $compile$ to update a database state.
$EM_1$ composes the two subsystems by compiling and executing a query, using $update$ to modify the database state or ``outputting'' the result of a select query as appropriate. 
A loose specification for $compile$ and $upd$ is given by a definition of correctness relative to the TSQL semantics:
 
=GFT
	Correct_Compile  = {(compile, upd) | EMâ1 compile upd = TSQLtf}
=TEX

\subsubsection{Reduction of Proof-Obligations: $Theorem4$}\label{componentlemmas} \label{theoremiv}

Further development, on the familiar recursive pattern,  consists of a design-decomposition of a subsystem into components, together with further correctness-proof work to reduce the subsystem proof-obligations to component proof-obligations. 

In this case,  the subsystems in question are $TSQLtf$ and $STP$, taken together, and the components in question are $EM_1$,  $compile$ and $upd$. Use is made of the definitions of the Execution Model to show that the lemma $Subsys\_SecureE$ can be reduced to  three lemmas, called:

\begin{center}
\begin{tabular}{l}
$EM\_SecureE$   \\ 
$Correct\_Compile\_OkSTP$ \\
$TableComputationsSecure$
\end{tabular}
\end{center}

These lemmas are documented in \cite{DS/FMU/FEF/034}, and the relevant theorem is  stated and proved in \cite{DS/FMU/FEF/034} as  $Theorem4$:    
=GFT
	Architecture_Secure,   
	Subsys_SecureA,
	Subsys_SecureB,
	Subsys_SecureC,
	Subsys_SecureD,
	EM_SecureE,  
	Correct_Compile_OkSTP,
	TableComputationsSecure
	Ù  FE_SWORD_SYSTEM_secure
=TEX

which may be compared with $Theorem1$ above.
The approach here is that of so-called ``partial proofs'', in which a partial attack is made on a verification problem by successively attacking the assumptions of an initial theorem (typically vacuous: $P\,Ù\,P$).
The goal being to replace each assumption of the initial theorem with zero or more assumptions which are more plausible, or which constrain fewer or simpler components of the system.

The significance of this theorem is that assumption $Subsys\_SecureE$ of $Theorem1$  has been shown to be reducible to a condition, $EM\_SecureE$ on  $EM_1$, provided that:

\begin{itemize}
\item  $STP$ is related in a certain way to $compile$, the relationship being that specified in the definition of $Correct\_Compile\_OkSTP$.
In essence, this says the the input-output behaviour of a select query at any state could equally well be computed by interpreting the query in the state according to a set of rules captured in the definition of a set of computations called $TableComputations$.
Subject to various modelling assumptions discussed in detail in \cite{DS/FMU/FEF/032}, the details of the definition of this set are based closely on the semi-formal definition of the query transformations specified informally in \cite{trans}.
In a certain sense, $TableComputations$ embodies a description of SSQL in terms of a relational algebra augmented with security features.
\item  All the computations in the set $TableComputations$, satisfy certain natural information-flow constraints, as specified in the definition of $TableComputationsSecure$.
\end{itemize}  

\subsubsection{$Theorem5$}   \label{Thv}
Further proof work results in reducing $Theorem4$ above to $Theorem5$ below, which is documented in \cite{DS/FMU/FEF/036}.
This result is ``the best partial proof of the overall system security'' achieved under the FEF project.

=GFT
	Architecture_Secure,   
	Subsys_SecureA,
	Subsys_SecureB,
	Subsys_SecureC,
	Subsys_SecureD,
	Viewât_secureE,
	outputFilter_secureE,
	Correct_Compile_OkSTP,
	Ù  FE_SWORD_SYSTEM_secure
=TEX

$Theorem5$, in comparison with $Theorem4$, represents progress in the following respects:

\begin{itemize}
\item The assumption $TableComputationsSecure$ has disappeared, since it has been proved as a theorem, as documented in \cite{DS/FMU/FEF/036}.
This indicates that the bottom level of proof work as discussed in Section \ref{phase2resultsoverview} is complete --- the SSQL relational algebra satisfies the information-flow constraints imposed upon it.
\item The assumption $EM\_SecureE$ has been replaced by two new assumptions $View_t\_secureE$ and $outputFilter\_secureE$.
This indicates partial progress on the second level of proof work and reflects a reduction of the assumption $EM\_SecureE$ of $Theorem4$ to conditions, $View_t\_secureE$ and $outputFilter\_secureE$ on two of the constituents of $EM_1$.
\end{itemize}
    
\subsection{Issues Detected} \label{issuesdetected}.

The main issues with the SSQL and Front End designs which were detected during the project are described and discussed in \cite{DS/FMU/FEF/002}.
These fall under several classes (but are not organised in that way in \cite{DS/FMU/FEF/002}):

\begin{itemize}
\item
Syntax and type checking errors: the bulk of the design was conveyed to ICL in a semi-formal notation; transcription of this into a machine-checked formal language revealed errors such as misspellings of names, failure to pass arguments correctly, and omission of auxiliary definitions.
While none of these problems cause the system as specified to be demonstrably insecure, they are likely to prevent a proof of security from going through, and make a proper judgement about security difficult.
In some cases the correction is obvious and the problem would therefore be unlikely to result in an insecure implementation, but in other cases it is less clear how the problem should be resolved.
In these cases there is a greater risk that a misundertanding might arise which would cause the implementation to be insecure.

This type of problem is detected automatically as the design is transcribed and checked using the {\Product} tool.

Approximately 30 problems of this class were reported in Phase 1 and about the same number in Phase 2.

\item
Incompleteness: for example, security of the query transformations of \cite{trans} relies on directories and tables which the client is not cleared to see not being loaded into the transformation symbol table; this was not made explicit in the design material.
The detection of this type of error depends on whether an object is just referenced and not defined (in which case the tool will flag the omission) or whether an object is inappropriately given a dummy definition (in which case the significance off the omission may not become apparent until proof is attempted).

Some 13 problems of this class were reported in Phase 1 and 6 in Phase 2.
Perhaps 5 or 6 of the 7 Phase 2 problems were directly relevant to security in that a security check was omitted from the design in a way which would lead directly to a violation of the Security Model if reflected in the implementation.

\item
Algorithmic errors: for example, security of the overall system is crucially dependent on clearances of fields within derived tables being computed in a way which respects the possible flow of information into the field.
The functional requirements on SWORD mean that some of these computations are quite subtle.
This type of error, if it is security relevant, is certain to be exposed during a full proof of security, and has a good chance of being exposed by partial proof work as carried out in Phase 2 if the area of attack is carefully chosen.

1 problem of this type was discovered in Phase 1 and 5 were discovered in Phase 2.
All but one of these problems were discovered during the proof work rather than during formulation of the specifications, and all would lead directly to a violation of the Security Model if reflected in the implementation.

\item
Modelling errors: these are errors where the assumptions used to model a system themselves give rise to problems which would not actually arise in an implementation: an example in the FEF work was in the Phase 2 model of select query execution ($TableComputations$), which, in a sense, tries to recover from errors which cause execution to be aborted (or never initiated) in the implementation.

Only 1 significant problem of this type arose (viz., the above one).
\end{itemize}

\section{RESULTS AND EVALUATION DELIVERABLES (E4/E5/E6)} \label{raede6}

This and the following section attempts to relate the results of the FEF project to the deliverables required for an evaluation at various assurance levels according to the ITSEC criteria.
This section is in support of the aim of DRA to commission a report from a CLEF which will `provide an assessment of whether the SWORD Front End approach is capable of achieving a useful ITSEC rating'. 

The architecture of the SWORD database, as implemented using a `Front End Filter', is not expected to permit evaluation at high assurance levels, since security of the database would depend upon correct operation of the commercial database, which would not be highly assured.
Nevertheless formal methods have been extensively exploited on the project, even though fully formal specifications are not required below assurance level E4.
 
These methods were applied because they were though to be beneficial in their own right, irrespective of the target evaluation level.
A second factor motivating the use of formal methods was the desire of the Defence Research Agency to assess the feasibility of formal specification and proof in such applications.

Formal methods were exploited at a level similar to that which would have been required for evaluation at E6.
The emphasis in undertaking the formal treatment was on proving the security of the system, and on using the formal work to eliminate flaws in the design, rather than on conforming to the formal aspects of the requirements for certification.

This section gives some indication of how the formal methods work may be related to the requirements for formal treatment at E4/E5/E6.
The next section considers how the formal treatment might be interpreted in relation to the requirements for E3.

The requirements for documentation at level E6 in the ITSEC (E6.1) identify the following formal specifications:

\begin{itemize}
\item
A formally specified model of security.
\item
A formal description of the architecture of the TOE.
\end{itemize}

The formal security model is also required at E3 and E4 though a fully formal description of the architecture of the TOE is not required at these levels.
A number of informal documents are required which relate these formal specifications to other aspects of the system documentation.
The FEF project has not attempted to provide any of the associated informal documentation.

A formalisation of the ``No  Flows Down'' policy in Z was provided as a part of the proposal to DRA for the FEF contract, and was subsequently transcribed from Z to HOL with some minor adjustments for the purposes of the FEF project\cite{DS/FMU/FEF/003}.
This is offered as a ``formally specified model of security''.

The main bulk of the formal specifications produced under the FEF contract contributed to various aspects of the specification of the architectural design of the TOE.
They are in large part derived from semi-formal specifications developed at DRA Malvern.
The specifications produced in Phase 1 concerned the external interfaces.
The structure present in these specifications was intended to make visible the security characteristics of the required behaviour rather than to reflect the architecture of the proposed implementation.
The specifications produced in Phase 1 were complete in their treatment of the security aspects of the external (SSQL) interface, but omit some details of other aspects of the interface (e.g. non-sercurity relevant aspects of the behaviour of update commands).

Phase 2 of the FEF project was primarily concerned with modelling the proposed architectural structure of the TOE, and with validating its security.
The approach adopted in Phase 2 was to construct models of the key alogorithms employed in the Front End Filter, in order to validate the correctness of these algorithms.
These models do not fully reflect the architecture of the TOE, since some of the key algorithms are closely integrated with less critical aspects of the functionality of the filter.
This approach to modelling key features of the architecture of the TOE was taken to maximise exposure of the most security sensitive aspects of the proposed architecture and to permit validation of these aspects by formal proof of their required properties.

The proofs undertaken under the FEF project may suffice as the formal part of the requirements for evidence of consistency of the TOE with the formal security policy model as specified in E6.6 of the ITSEC.
No attempt was made in the FEF project to supply the informal explanations required for evaluation at E6 or below.

\section{RESULTS AND EVALUATION DELIVERABLES (E3)} \label{raed}

This section addresses the possible relevance of the formal treatment undertaken in the FEF project to an evaluation with a target assurance level of E3. 

The approach will be to consider selected deliverables, and the requirements on each, and then to discuss how results from the FEF project may be used in satisfying those requirements.

The list of E3 deliverables which are taken to be within the scope of this report is as follows:

\begin{enumerate}
\item Security Target [Ref E3.1, E3.2, E3.3]
\item Informal Description of the Architecture.[E3.1, E3.5, E3.6]
\item Informal Description of the Detailed Design. [E3.1, E3.8, E3.9].
\item %(Perhaps, because  of the issue discussed in Section \ref{scope} assumption 3 above)
Information on the Acceptance Procedure of the Configuration Control System
\end{enumerate}

Additionally, there is a requirement for an informal description of the correspondence between source code or hardware drawings and  the detailed design [Ref E3.1, E3.11].   This is relevant only in so far as it characterises a detailed design as that with which a source-code correspondence can be adequately established.

Each of these three deliverables is now considered in more detail. The ITSEC term `Target of Evaluation' (TOE) is interpreted as `DBMS'.

\subsection{Security Target}
The Security Target deliverable is the statement of security requirements. The requirements under the ITSEC headings of Content and Presentation and Evidence are:
\begin{enumerate}

\item It shall describe the security enforcing functions to be provided by the DBMS. 

\item It shall include a rationale identifying the method of use, the intended environment and  the assumed threats within that environment. 

\item The security-enforcing functions within the security target shall be specified in an informal style.

\item It shall describe how the functionality is appropriate for that method of use and is adequate to counter the assumed threats.
\end{enumerate}

The FEF Security Model of \cite{DS/FMU/FEF/003}, Section \ref{sm} above, can reasonably be part of an offering to satisfy the first of these requirements.   It describes only the security-enforcing function of the DBMS  which is the prevention of down-flows. 

Of the eight generic headings identified by the ITSEC [ref 2.31, 2.32] for possible security-enforcing functions, the Security Model concerns one, {\em Access Control}.  With regard to the Access Control function,  \cite{DS/FMU/FEF/003} assumes that `mechanisms outside the scope of this model ensure that users see only those outputs they are cleared to see'. Also, there are interesting features of the DBMS which are not in the model: one classified object may be contained in another, and information about existence of objects may be classified differently from the information contained in those objects.

%Consequently, to meet the requirements for a Security Target, the Security Model of \cite{DS/FMU/FEF/003} would need to be supplemented by other material.     

With regard to the third requirement,  the ITSEC mandates that an informal style of presentation shall be used for all security targets, any formal specification being in addition [2.66]. \cite{DS/FMU/FEF/003} contains a mixture of informal and formal text.  The opinion is offered that although \cite{DS/FMU/FEF/003} may not be quite suitable for someone to understand without special training,  it is not far from it.  
 
\subsection{Architecture}

The requirements for the Description of the Architecture, under the headings of Content and Presentation and Evidence,  are as follows. Again writing `DBMS' for `Target of Evaluation', then the Description of Architecture shall describe: 
\begin{enumerate}
\item the general structure of the DBMS.
\item the external interfaces of the DBMS .
\item any supporting hardware or firmware with statement of the functionality of supporting protection mechanisms 
\item the separation of the DBMS into security-enforcing and other components.
\item how the security-enforcing functions will be provided.
\item how the separation into security-enforcing and other components is achieved.
\end{enumerate}
\subsubsection{Requirement 1: General Structure}  \label{reqone}

The FEF project result which is the Specification of the $FE\_SWORD\_SYSTEM$ can reasonably be offered in satisfaction of (part of) the first requirement, the description of the general structure.


This specification is relatively abstract.  It is described as an Architectural Model, wherein relationships between subsystems are modelled by the composition of functions (in the mathematical sense). At more concrete level, a description of general structure might be in terms of processes,  flows of data between processes and separation between processes  (e.g. issues of physical separation or network topology). 

The basis of the approach to security is to separate the user from the TSQL engine by interposing the Front End. An account of how this separation is concretely achieved, thereby establishing the relevance of the abstract Architectural Model, is evidently fundamental for evaluation.     
Further issues arise in that, because the $FE\_SWORD\_SYSTEM$ is specified relatively abstractly, there may be further structural components not identified. Possible examples are:
\begin{itemize}
\item Processing of the concrete representations of input queries and output tables.
\item Database administrator's interface.
\item Trusted functions e.g. hardcopy labelling. 
\end{itemize}

\subsubsection{Requirement 2: External Interfaces}
The specification of the $SSQLam$  (Section \ref{ss} above) is a candidate for the specification of the main external interface of the DBMS.  This specification is not currently complete.
 
%{\em Questions: what other external interfaces might there be?  Is the SSQL semantics still valid/current? }

\subsubsection{Requirement 3}
No statement is available with regard to dependence on protection mechanisms in supporting hardware/firmware.

\subsubsection{Requirement 4}

With regard to the separation of the DBMS into security-enforcing and other components, there are various positions which might be taken, depending upon the rationale of modes of use and threats which would be supplied for evaluation as part of the security target.

Evidently one possibility is to draw the dividing line between the Front End and the TSQL engine. The latter is one of the subsystems described by the Architecture.  Since the TSQL engine has no functionality specific to multilevel security, then it may be asserted to be not a security-enforcing component.  However, this does not mean that the TSQL engine may be entirely untrusted, since its correct functioning is security-critical.

%Further consideration of this issue is a matter for the CLEF.

\subsubsection{Requirements 5 and 6}
Regarding these two requirements, there is nothing to add to the discussion in Section \ref{reqone} above.

\subsection{Detailed Design}
The requirements under the headings of Content and Presentation and Evidence, for the Description of the Detailed Design, are as follows. It shall: 
\begin{enumerate}
\item specify all basic components
\item describe the realisation of all security-enforcing mechanisms and security relevant functions
\item map security enforcing functions to mechanisms and components
\item document all interfaces of security-enforcing and security-relevant components, stating their purpose and parameters.
\item provide specifications/definitions for mechanisms, which shall be suitable for the analysis of interrelationships between the mechanisms employed.
\item show a clear and hierarchical relationship between levels of specification (if more than one level is provided).
\item describe how the security mechanisms provide the security enforcing functions specified in the security target.
\item describe why components for which no design information is provided cannot be either security-enforcing or security-relevant.
\end{enumerate}

The assumptions of $Theorem5$ show  what still remains to be accomplished before the task describable as Detailed Design would be complete.   The task would be to produce specifications for a set of components such that:
\begin{itemize}
\item The assumptions of $Theorem5$ are provably true of a set of components with these specifications.
\item It could be shown that these components meet their specifications by reference to the source code of the implementations (because this is what the ITSEC means by detailed design). 
\end{itemize}

Evidently progress has been made towards the Detailed Design, in that specifications have been produced for objects at a more detailed level than the Architecture.   It is doubtful if more than this can be said.

\pagebreak
\section{SUMMARY AND CONCLUSIONS} \label{oac}

The SWORD multi-level secure RDBMS has been subject to extensive formal modelling to validate the security aspects of the design, including the completion of a number of formal proofs about aspects of the specification and design.

This formal treatment has been valuable in providing precise specifications as a basis for implementation.
The processing of these specifications by appropriate tools has been beneficial in removing minor errors, and the completion of formal proofs relating to these specifications has detected errors of a deeper nature.

The relevance of this kind of work to the evaluation of the system against the ITSEC criteria is of interest to the Defence Research Agency, and this report provides an overview of the formal methods work to assist in an assessment of its relevance to evaluation.  
 
=IGN

\subsection{The Value of a Formal Treatment} 

One specification in particular has been troublesome, namely \cite{DS/FMU/FEF/032} (and its predecessor document, \cite{trans} which is an early specification for a prototype implementation of the SSQL Transformation Processor, $STP$).
Errors came to light over an extended period (\cite{DS/FMU/FEF/036}, Section 1.2, Section 4.1), in part discovered with the aid of a tool which checks type-correctness.  Possible covert channels were discovered in the attempt to prove a first formulation of $TableComputationsSecure$.     

There were errors in early versions of \cite{specssql},  the SSQL specification as supplied to the project, documented in \cite{DS/FMU/FEF/002}.   

\subsection{Observation}
 
Although the $SSQLam$ may be taken as a specification (of the external interfaces to the DBMS), and the theorem $secureSSQL$ has been proved, (which is of the nature of a specification-to-model correspondence proposition),  further development work has not been aimed at showing that the Architectural Design (that is, $FE\_SWORD\_system$) satisfies the specification, but rather, in every case, at showing that it satisfies the security-model directly.   Is this good or bad?

\subsection{Observation}

Can we say anything useful about Formal Methods  as a way of dealing with complexity? 

Much effort has been taken up by dealing with the complexity of SSQL in the formal treatment, and the introduction of the Execution Model represents an attempt to avoid dealing with it directly.
However, this very complexity is a major motivator for a formal treatment at E3, which does not inherently call for a formal treatment.     

=TEX



=IGN
\section{PROOF POWER}
Reference is made throughout this document to the \Product{} system. 
This is the chosen theorem proving tool for this project, referred to in the original proposal, \cite{DS/FMU/017}, as ICL HOL. The facilities 
available in \Product{} are documented in  \cite{DS/FMU/IED/USR006} 



=TEX
\end{document}




