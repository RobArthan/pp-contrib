=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Briefing for CLEF}  %% Mandatory field
\TPPref{DS/FMU/FEF/xxx}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Project Overview}
\TPPkeywords{}
\TPPauthor{R.~Stokes & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.~B.~Jones & HAT Manager}
\TPPabstract{This document provides a briefing suitable for a CLEF on the results of the DRA front end 
filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File 
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\listoftables
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[\SCCSversion ({\FormatDate{94/01/11
}})] Current issue.
\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope} \label{scope}
This document is a report on the results of the FEF project. It is produced in support of the intention of DRA to commission from a CLEF a further report.  The latter has a number of aims (\cite{SRW}): the relevant aim is here taken as to:  
\begin{quote}
Provide an  assessment of whether the SWORD Front End approach is capable of achieving a useful ITSEC rating.
\end{quote}

and the relevant associated deliverable is taken to be the one described in \cite{SRW} as giving:
\begin{quote}
an assessment of the assurance levels that the approach could attain, and the likely costs of such an evaluation.
\end{quote}

The reference to evaluation costs is taken to be to costs recoverable by a CLEF in performing an evaluation, and not in the scope of this report.  Nor will this report be concerned with quantifying effort or costs for the FEF project. 
 
This report is written on the following assumptions, which are based on informal contact with DRA  but not explicit in \cite{SRW}. :
\begin{itemize}
\item It is understood that DRA are interested primarily in the possibilities for an ITSEC Assurance Correctness Level of E3.
\item It is assumed that evaluation would be as  a {\em product}, (that is, according to ITSEC 1.4,  a package which can be bought off the shelf), as opposed to a {\em system} or   specific installation. 

\item DRA have a particular interest in an account of the value of Formal Methods in a development for evaluation at E3, where a formal treatment is not mandated.  The purpose of proof work carried out in this project comparable with the aim of  [ITSEC 4.24], `ensuring that  each representation of a design or its implementation ... can be shown to correspond correctly to  the previous representation on which it is based.'  (Although this is described in the ITSEC under the heading `Configuration Control', DRA's interest is understood to be in progression from one representation to the next as a design (or implementation) step, not merely an ad-hoc change to a configuration-management item.)    
\end{itemize} 

The intention in writing this report is to try to assist the CLEF, by providing a first introduction to the results of the FEF project.   These results, or similar results, may be considered as possible evaluation deliverables, and so some comments are offered,  in the hope that they may be useful to the CLEF, but not with the intention of trying to pre-empt the judgement of the CLEF.  


\subsection{Introduction}
This report is divided into three sections. 

The first,  section  \ref{descriptionofresults} below, aims at describing the results of the FEF project, particularly from the point of view of describing the significance of the results which are of the nature of proofs of theorems.

The second,  section \ref{raed} below,  aims at relating the the results of the FEF project to possible deliverables for an evaluation at various levels of the ITSEC criteria.  It is recognised that the FEF project is of the nature of research, while evaluation deliverables will be produced by a development project.  Consequently, what is said in this section about the FEF results is meant to apply to some evaluation scenario in which the deliverables would be similar to the FEF results.  
The third, section \ref{oac} below, offers observations and conclusions.

\subsection{Terminology and Abbreviations}

\begin{tabular}{lp{5in}}
DBMS & database management system  \\
SQL  & Structured Query Language, ref ?.  A standard language for querying and updating a database. \\
SSQL & a variant of the SQL database query language with features supporting  multilevel security.  SSQL differs from SQL  mainly in that there is an additional data type, $Class$,  for security-classifications, and that the results of queries always include a classification computed for the result.\\
TSQL & Target SQL: a variant of SQL, with a data type $Class$, where $Class$ is just a datatype.  TSQL is expected to be closely approximated by standard commercial DBMS offerings. \\
\end{tabular} 

\pagebreak
\section{DESCRIPTION OF RESULTS} \label{descriptionofresults}

The tangible results of the FEF project consist of a number of items, of which some are specifications and some are proofs of theorems.  An overview of the main results is given by the list of items in sections \ref{sm} to \ref{Thv} which follow.      


\subsection{Security Model} \label{sm}
The Security Model defines a property $secure$ as non-interference for sequences of inputs and outputs of an abstract state-machine.  The property $secure$ is documented in \cite{DS/FMU/FEF/003}.
\subsection{SSQL Semantics}  \label{ss}
The specification of the semantics of SSQL describes how the result of an SSQL query is computed from the state of the database, covering both the response returned to the user and the new state.  Note that the fact that this is an SSQL query means that a classification is computed for the result, but does not mean that the result is sanitized for the clearance at which the query is submitted. 
 
The specification is documented in  \cite{DS/FMU/FEF/014} the point of entry being the definition of $processQuery$.

The specification is incomplete (that is, loose), in certain respects.  Of the four kinds of query (insert, delete, update and select) only select is specified in full detail.  

  
\subsection{SSQL Abstract Machine}
Specification of an abstract state-machine for the secure processing of SSQL queries. The processing is in effect in three stages: 
\begin{itemize}
\item A view of the database state is constructed which hides anything not in the user's clearance.
\item The query is processed against this view (and thus with `no read up'), in accordance with the SSQL semantics.
\item If the query is an update, delete or insert, then the real database state is updated from the results of processing the view, rejecting any changes below the user's clearance (and thus with `no write down').
\end{itemize}

The SSQL abstract machine is documented in \cite{DS/FMU/FEF/006} under the name of $SSQLam$. 

\subsection{Theorem about $SSQLam$}
The following theorem  

=GFT
	Ù behaviours SSQLam ç secure
=TEX

has its proof documented in \cite{DS/FMU/FEF/015} under the name of $secureSSQL$.  The significance of the result is that it shows that whatever satisfies the specification of $SSQLam$ conforms to the policy model. .   
  
\subsection{Specification of Architecture}  \label{soa}
Specification of the architecture of a DBMS, as a construction in terms of specified subsystems.  The construction itself is called $FE\_SWORD$, \cite{DS/FMU/FEF/022},  and the architectural subsystems are 
    \begin{itemize}
    \item  $TSQLtf$,  \cite{DS/FMU/FEF/021}, corresponding to a ``conventional DBMS'',
           implementing  $TSQL$.    This may or may not be implemented in reality by a ``standard commercial DBMS'', and so            to avoid taking a position on this issue this architectural component will here be called  the ``TSQL engine''.
    \item  $STP$  (``SSQL Transformation Processor'', \cite{DS/FMU/FEF/029}) which transforms queries input in SSQL to queries in TSQL to be submitted to the TSQL engine. 
    \item  $outputFilter$,   \cite{DS/FMU/FEF/024}, which sanitises results from the TSQL engine before passing them back to the user. 
\end{itemize}

The construction also requires a state-representation function, specified as $reprState$ in \cite{DS/FMU/FEF/025}.

\subsection{Specification of Security-Critical Properties}  \label{scp}
Specification of security-critical properties of the architectural construction and subsystems.   These are documented in \cite{DS/FMU/FEF/022} under the names:
\begin{center}
\begin{tabular}{l}
$subsys\_secure$  \\  
$subsys\_secureA$ \\
$subsys\_secureB$ \\
$subsys\_secureC$ \\
$subsys\_secureD$ \\
$eubsys\_secureE$ \\
\end{tabular}
\end{center}


\subsection{Subsystem Lemmas} \label{subsystemlemmas}
The statement of a collection of lemmas, which may be called the `subsystem' lemmas.  Taken together, these lemmas assert that  the security-critical properties (section \ref{scp} above) are true of the construction and subsystems of the architecture. 

Thus a proof of security assuming the lemmas will be a proof of the correctness of the architectural structuring as a first design-step. Since the lemmas are stated in terms of specifications of the individual subsystems of the architecture, they represent proof-obligations which are carried forward to later design-steps.  The subsystem lemmas are documented in \cite{DS/FMU/FEF/034} under the names:

\begin{center}
\begin{tabular}{l}
$Architecture\_Secure$  \\  
$Subsys\_SecureA$ \\
$Subsys\_SecureB$ \\
$Subsys\_SecureC$ \\
$Subsys\_SecureD$ \\
$Subsys\_SecureE$ \\
\end{tabular}
\end{center}
 

\subsection{Specification of $FE\_SWORD\_SYSTEM$} \label{soFESS}

$FE\_SWORD\_SYSTEM$ is a DBMS; it is  the architectural construction applied to the architectural subsystems. It is defined in \cite{DS/FMU/FEF/034}.

\subsection{Proof of $Theorem1$}
$Theorem1$, stated and proved in \cite{DS/FMU/FEF/034}, is  

=GFT
	Architecture_Secure,   
	Subsys_SecureA,
	Subsys_SecureB,
	Subsys_SecureC,
	Subsys_SecureD,
	Subsys_SecureE
	Ù  FE_SWORD_SYSTEM_secure
=TEX

where $FE\_SWORD\_SYSTEM\_secure$ is simply $FE\_SWORD\_SYSTEM \in secure$.
This result shows that the architecture specified is correct with regard to security. In other words,  the security-critical requirements on the subsystems and the construction have been correctly identified in that they are indeed sufficient to ensure the security of the constructed DBMS. 

\subsection{Specification of Execution Model}

What is called the `Execution Model' represents a step in the development process following on from the Architecture definition.  The Execution Model  may be described as a specification of a new constraint on the architectural subsystems  $TSQLtf$ and $STP$.  The purpose of the constraint is to provide an alternative to the intractable semantics of TSQL for use in the  further development. 

The Execution Model is documented in \cite{DS/FMU/FEF/026} as  the specification of three new objects: $EM_1$,  $compile$ and $upd$.  $EM_1$ is a constant, while $compile$ and $update$ are variables.

$EM_1$ is a construction function, such that it constructs $TSQLtf$ when applied to  $compile$ and $update$.  Specifications for $compile$ and $upd$ are given by a correctness definition: 
 
=GFT
	Correct_Compile  = {(compile, upd) | EMâ1 compile upd = TSQLtf} 	
=TEX

  

\subsection{Reduction of Proof-Obligations: $Theorem4$} \label{componentlemmas} \label{theoremiv}

Further development, on the familiar recursive pattern,  consists of a design-decomposition of a subsystem into components, together with further correctness-proof work to reduce the subsystem proof-obligations to component proof-obligations. 

In this case,  the subsystems in question are $TSQLtf$ and $STP$, taken together, and the components in question are $EM_1$,  $compile$ and $upd$. Use is made of the definitions of the Execution Model to show that the lemma $Subsys\_SecureE$ can be reduced to  three lemmas, called:

\begin{center}
\begin{tabular}{l}
$EM\_SecureE$   \\ 
$Correct\_Compile\_OkSTP$ \\
$TableComputationsSecure$
\end{tabular}
\end{center}

These lemmas are documented in \cite{DS/FMU/FEF/034}, and the relevant theorem is  stated and proved in \cite{DS/FMU/FEF/034} as  $Theorem4$:    
 


=GFT
	Architecture_Secure,   
	Subsys_SecureA,
	Subsys_SecureB,
	Subsys_SecureC,
	Subsys_SecureD,
	EM_SecureE,  
	Correct_Compile_OkSTP,
	TableComputationsSecure
	Ù  FE_SWORD_SYSTEM ç secure
=TEX

which may be compared with $Theorem1$ above.   The significance of this theorem is that some of the conditions on $TSQLtf$  have been shown to be reducible to conditions on  $EM_1$,  $compile$ and $upd$, provided that 
\begin{itemize}
\item  $STP$ is related in a certain way to $compile$, that is, $Correct\_Compile\_OkSTP$ holds
\item  This relationship between $STP$ and $compile$ has a security-property, captured by $TableComputationsSecure$.
\end{itemize}  

\subsection{$Theorem5$}   \label{Thv}
Further proof work results in reducing $Theorem4$ above to $Theorem5$ below, which is documented in \cite{DS/FMU/FEF/036}.  This result is ``the best partial proof of the overall system security''.


=GFT
	Architecture_Secure,   
	Subsys_SecureA,
	Subsys_SecureB,
	Subsys_SecureC,
	Subsys_SecureD,
	Viewât_secureE,
	outputFilter_secureE,
	Correct_Compile_OkSTP,
	Ù  FE_SWORD_SYSTEM ç secure
=TEX

$Theorem5$, in comparison with $Theorem4$, represents progress in the following respects:

\begin{itemize}
\item The assumption $TableComputationsSecure$ has disappeared, since it has been proved as a theorem, as documented in \cite{DS/FMU/FEF/036}. 
\item The assumption $EM\_SecureE$ has been reduced to assumptions $View_t\_secureE$ and $outputFilter\_secureE$.    The significance of this is ..{\em not sure what to say here}
\end{itemize}

    

\pagebreak
\section{RESULTS AND EVALUATION DELIVERABLES} \label{raed}
This section aims at relating the the results of the FEF project to possible deliverables for an evaluation at various levels of the ITSEC criteria. This section is in support of the aim of DRA to commission a report from a CLEF which will `provide an assessment of whether the SWORD Front End approach is capable of achieving a useful ITSEC rating'. 

The approach will be to consider selected deliverables, and the requirements on each, and then to discuss how results from the FEF project may be used in satisfying those requirements. 


The list of E3 deliverables which are taken to be within the scope of this report is as follows:

\begin{enumerate}
\item Security Target [Ref E3.1, E3.2, E3.3]
\item Informal Description of the Architecture.[E3.1, E3.5, E3.6]
\item Informal Description of the Detailed Design. [E3.1, E3.8, E3.9].
\item (Perhaps, because  of the issue discussed in section \ref{scope} above) Information on the Acceptance Procedure of the Configuration Control System
\end{enumerate}

Additionally, there is a requirement for an informal description of the correspondence between source code or hardware drawings and  the detailed design [Ref E3.1, E3.11].   This is relevant only in so far as it characterises a detailed design as that with which a source-code correspondence can be adequately established.

Each of these three deliverables is now considered in more detail. The ITSEC term `Target of Evaluation' (TOE) is interpreted as `DBMS'.

\subsection{Security Target}
The Security Target deliverable is the statement of security requirements. The requirements under the ITSEC headings of Content and Presentation and Evidence are:
\begin{enumerate}

\item It shall describe the security enforcing functions to be provided by the DBMS. 

\item It shall include a rationale identifying the method of use, the intended environment and  the assumed threats within that environment. 

\item The security-enforcing functions within the security target shall be specified in an informal style.

\item It shall describe how the functionality is appropriate for that method of use and is adequate to counter the assumed threats.
\end{enumerate}

The FEF Security Model of [FEF003], section \ref{sm} above, can reasonably be part of an offering to satisfy the first of these requirements.   It describes only the security-enforcing function of the DBMS  which is the prevention of down-flows. 

Of the eight generic headings identified by the ITSEC [ref 2.31, 2.32] for possible security-enforcing functions, the Security Model concerns one, {\em Access Control}.  With regard to the Access Control function,  [FEF003] assumes that ` mechanisms outside the scope of this model ensure that users see only those outputs they are cleared to see'. Also, there are interesting features of the DBMS which are not in the model: one classified object may be contained in another, and information about existence of objects may be classified differently from the information contained in those objects.

Consequently, to meet the requirements for a Security Target, the Security Model of [FEF003] would need to be supplemented by other material.     


With regard to the third requirement,  the ITSEC mandates that an informal style of presentation shall be used for all security targets, any formal specification being in addition [2.66]. [FEF003] contains a mixture of informal and formal text.  The opinion is offered that although [FEF003] may not be quite suitable for someone to understand without special training,  it is not far from it.  
 
\subsection{Architecture}
The requirements for the Description of the Architecture, under the headings of Content and Presentation and Evidence,  are as follows. Again writing `DBMS' for `Target of Evaluation', then the Description of Architecture shall describe: 
\begin{enumerate}
\item the general structure of the DBMS.
\item the external interfaces of the DBMS .
\item any supporting hardware or firmware with statement of the functionality of supporting protection mechanisms 
\item the separation of the DBMS into security-enforcing and other components.
\item how the security-enforcing functions will be provided.
\item how the separation into security-enforcing and other components is achieved.
\end{enumerate}
\subsubsection{Requirement 1: General Structure}  \label{reqone}

The FEF project result which is the Specification of the $FE\_SWORD\_SYSTEM$ can reasonably be offered in satisfaction of (part of) the first requirement, the description of the general structure.


This specification is relatively abstract.  It is described as an Architectural Model, wherein relationships between subsystems are modelled by the composition of functions (in the mathematical sense). At more concrete level, a description of general structure might be in terms of processes,  flows of data between processes and separation between processes  (e.g. issues of physical separation or network topology). 

The basis of the approach to security is separate the user from the TSQL engine by interposing the Front End. An account of how this separation is concretely achieved, thereby establishing the relevance of the abstract Architectural Model, is evidently fundamental for evaluation.     


Further issues arise in that, because the $FE\_SWORD\_SYSTEM$ is specified relatively abstractly, there may be further structural components not identified. Possible examples are:
\begin{itemize}
\item Processing of the concrete representations of input queries and output tables.
\item Database administrator's interface.
\item Trusted functions e.g. hardcopy labelling. 
\end{itemize}

\subsubsection{Requirement 2: External Interfaces}
The specification of the $SSQLam$  ( section \ref{ss} above) is a candidate for the specification of the main external interface of the DBMS.  This specification is not currently complete.
 
{\em Questions: what other external interfaces might there be?  Is the SSQL semantics still valid/current? }

\subsubsection{Requirement 3}
No statement is available with regard to dependence on protection mechanisms in supporting hardware/firmware.

\subsubsection{Requirement 4}

With regard to the separation of the DBMS into security-enforcing and other components, there are various positions which might be taken, depending upon the rationale of modes of use and threats which would be supplied for evaluation as part of the security target.

Evidently one possibility is to draw the dividing line between the Front End and the TSQL engine. The latter is one of the subsystems described by the Architecture.  Since the TSQL engine has no functionality specific to multilevel security, then it may be asserted to be not a security-enforcing component.  However, this does not mean that the TSQL engine may be entirely untrusted, since its correct functioning is security-critical.

Further consideration of this issue is a matter for the CLEF.

\subsubsection{Requirements 5 and 6}
Regarding these two requirements, there is nothing to add to the discussion in section \ref{reqone} above.

\subsection{Detailed Design}
The requirements under the headings of Content and Presentation and Evidence, for the Description of the Detailed Design, are as follows. It shall: 
\begin{enumerate}
\item specify all basic components
\item describe the realisation of all security-enforcing mechanisms and security relevant functions
\item map security enforcing functions to mechanisms and components
\item document all interfaces of security-enforcing and security-relevant components, stating their purpose and parameters.
\item provide specifications/definitions for mechanisms, which shall be suitable for the analysis of interrelationships between the mechanisms employed.
\item [show] a clear and hierarchical relationship between levels of specification (if more than one level is provided).
\item describe how the security mechanisms provide the security enforcing functions specified in the security target.
\item describe why components for which no design information is provided cannot be either security-enforcing or security-relevant.
\end{enumerate}


The assumptions of $Theorem5$ show  what still remains to be accomplished before the task describable as Detailed Design would be complete.   The task would be to produce specifications for a set of components such that:
\begin{itemize}
\item The assumptions of $Theorem5$ are provably true of a set of components with these specifications.
\item It could be shown that these components meet their specifications by reference to the source code of the implementations (because this is what the ITSEC means by detailed design). 
\end{itemize}

Evidently progress has been made towards the Detailed Design, in that specifications have been produced for objects at a more detailed level than the Architecture.   It is doubtful if more than this can be said.

\pagebreak
\section{OBSERVATIONS AND CONCLUSIONS} \label{oac}

\subsection{The Value of a Formal Treatment} 

One specification in particular has been troublesome, namely \cite{DS/FMU/FEF/032} (and its predecessor document, \cite{trans} which is an early specification for a prototype implementation of the SSQL Transformation Processor, $STP$).
Errors came to light over an extended period (\cite{DS/FMU/FEF/036}, section 1.2, section 4.1), in part discovered with the aid of a tool which checks type-correctness.  Possible covert channels were discovered in the attempt to prove a first formulation of $TableComputationsSecure$.     

There were errors in early versions of \cite{specssql},  the SSQL specification as supplied to the project, documented in \cite{DS/FMU/FEF/002}.   


\subsection{Observation}
 
Although the $SSQLam$ may be taken as a specification (of the external interfaces to the DBMS), and the theorem $secureSSQL$ has been proved, (which is of the nature of a specification-to-model correspondence proposition),  further development work has not been aimed at showing that the Architectural Design (that is, $FE_SWORD_system$) satisfies the specification, but rather, in every case, at showing that it satisfies the security-model directly.   Is this good or bad?

\subsection{Observation}

Can we say anything useful about Formal Methods  as a way of dealing with complexity? 

Much effort has been taken up by dealing with the complexity of SSQL in the formal treatment, and the introduction of the Execution Model represents an attempt to avoid dealing with it directly.   However, this very complexity is a major motivator for a formal treatment at E3, which does not inherently call for a formal treatment.     





=IGN
\section{PROOF POWER}
Reference is made throughout this document to the \Product{} system. 
This is the chosen theorem proving tool for this project, referred to in the original proposal, \cite{DS/FMU/017}, as ICL HOL. The facilities 
available in \Product{} are documented in  \cite{DS/FMU/IED/USR006} 



=TEX
\end{document}




