=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Briefing for CLEF}  %% Mandatory field
\TPPref{DS/FMU/FEF/041}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Project Overview}
\TPPkeywords{}
\TPPauthor{R.~Stokes & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.~B.~Jones & HAT Manager}
\TPPabstract{This document provides a briefing suitable for a CLEF on the results of the formal methods work carried out by ICL for the DRA Front End 
Filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File 
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\listoftables
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[\SCCSversion ({\FormatDate{94/01/11
}})] Current issue.
\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope} \label{scope}
This document is a report on the results of the formal specification and verification work carried out by ICL as part of the development by DRA of SWORD, a secure relational database system.
ICL's work on this project is generally referred to as the ``FEF project'' in the rest of this document.

This document is primarily produced in support of the intention of DRA to commission from a CLEF a further report.  We understand from DRA that the latter report has a number of aims: the main aim of relevance here is to:  
\begin{quote}
Provide an  assessment of whether the SWORD Front End approach is capable of achieving a useful ITSEC rating.
\end{quote}

and the main relevant associated deliverable is taken to be:
\begin{quote}
an assessment of the assurance levels that the approach could attain, and the likely costs of such an evaluation.
\end{quote}

The reference to evaluation costs is taken to be to costs recoverable by a CLEF in performing an evaluation, and not in the scope of this report.  Nor will this report be concerned with quantifying effort or costs for the FEF project as a whole. 
 
This report is written on the following assumptions derived from discussions with DRA:

\begin{itemize}
\item It is understood that DRA are interested primarily in the possibilities for an ITSEC Assurance Correctness Level of E3.
\item It is assumed that evaluation would be as  a {\em product}, (that is, according to ITSEC 1.4,  a package which can be bought off the shelf), as opposed to a {\em system} or   specific installation. 

\item DRA have a particular interest in an account of the value of Formal Methods in a development for evaluation at E3, where a formal treatment is not mandated.  The purpose of proof work carried out in this project comparable with the aim of  [ITSEC 4.24], `ensuring that  each representation of a design or its implementation ... can be shown to correspond correctly to  the previous representation on which it is based.'  (Although this is described in the ITSEC under the heading `Configuration Control', DRA's interest is understood to be in progression from one representation to the next as a design (or implementation) step, not merely an ad-hoc change to a configuration-management item.)    
\end{itemize} 

The intention in writing this report is to try to assist the CLEF, by providing a first introduction to the results of the FEF project.   These results, or similar results, may be considered as possible evaluation deliverables, and so some comments are offered,  in the hope that they may be useful to the CLEF, but not with the intention of trying to pre-empt the judgement of the CLEF.  


\subsection{Introduction}
This report is divided into three sections. 

The first,  section  \ref{descriptionofresults} below, aims at describing the results of the FEF project, particularly from the point of view of describing the significance of the various formal specifications and of the theorems which have been proved about them.

The second,  section \ref{raed} below,  aims at relating the the results of the FEF project to possible deliverables for an evaluation at various levels of the ITSEC criteria.  It is recognised that the FEF project is of the nature of research, while evaluation deliverables will be produced by a development project.  Consequently, what is said in this section about the FEF results is meant to apply to some evaluation scenario in which the deliverables would be similar to the FEF results.

The third, section \ref{oac} below, offers observations and conclusions.

\subsection{Terminology and Abbreviations}

\begin{tabular}{lp{5in}}
DBMS & database management system  \\
FEF & Front End Filter: used to describe an implementation technique for SSQL whereby SSQL queries provided by a client user or process are transformed into TSQL queries which are then executed on a standard commercial DBMS; output from the TSQL queries is filtered to remove sensitive information before it is returned to the client.
In this document the phrase FEF project is used to refer to ICL's work on the formal specification and verification of aspects of the FEF development being undertakend by DRA.\\
SQL  & Structured Query Language.  A standard language for querying and updating a database. \\
SSQL & a variant of the SQL database query language with features supporting  multilevel security.  SSQL differs from SQL mainly in that there is an additional data type, $Class$, for security-classifications, which is used to classify the information held in tables and their constituent rows and columns.\\
TSQL & Target SQL: a variant of SQL, augmented with a data type $Class$ which can be used to represent security-classifications, but has no other special interpretation.  TSQL is expected to be closely approximated by standard commercial DBMS offerings. \\
\end{tabular} 

\pagebreak
\section{DESCRIPTION OF RESULTS} \label{descriptionofresults}

\subsection{Introduction}

The work under the FEF project considered in this document was commissioned and carried out in two phases.
The bulk of the work was carried out from January 1992 to December 1993 and each phase took approximately 1 year of elapsed time and a little more than 1 person/year of effort.

The main technical aim of phase 1 was to produce a formal specification of the semantics of SSQL in a form suitable for processing using a computerised theorem-proving system and to provide a machine-checked proof that the SSQL semantics provided information-flow security according to an agreed formulation of the no-flows down security policy.
The main feature of the approach taken was to factor out from DRA's semiformal specifications of SSQL semantics those features which are critical to the security policy.

The original intention in phase 2 had been to verify that formal model of the Front End implementation of SWORD correctly implemented the phase 1 SSQL semantics and so conclude that it was secure. However, the requirements on phase 2 were reviewed towards the end of phase 1 and it was agreed that the complexity of the implementation was likely to make a full correctness proof prohibitively expensive.
Moreover, the complete informal specifications of the implementation were no longer scheduled to be available within the timescales which would be required for a complete model of the implementation to be constructed.
The actual objectives of phase 2 were therefore to use the formal specification and  proof process to discover any key security flaws in the informal specifications and to evolve the formal specifications during the course of the proof work in order to give insight into possible solutions to these flaws.


The deliverables of the FEF project mainly comprise documents containing either specifications or scripts which prove theorems.
The specifications and theorems are expressed in the {\ProductHOL} language which is supported by ICL's {\Product} tool \cite{DS/FMU/IED/USR014}.
{\ProductHOL} is a mathematical formalism for specifying models of systems, and for formulating and proving theorems about such models; the surface syntax for {\ProductHOL} specifications is in many ways similar to the Z notation \cite{Spivey89}.
The {\Product} tool gives computerised support for both specification and proof via comprehensive and programmable facilities for developing and interrogating a database of specifications and theorems.
The database is organised as an extensible hierarchy of modules referred to as ``theories''.
It also gives facilities for preparing documents containing a mixture of narrative and mathematical material optionally including theory listings giving a precise summary of the mathematical content of the objects specified in a theory and of the theorems which have been proved about them.
Most of the FEF project deliverables are documents containing both the narrative material and tool input which describe and construct a theory together with the theory listing.

The results of the formal treatment from the two phases are discussed in more detail in sections \ref{phase1results} and \ref{phase2results} below.

In addition to the formal documents themselves, a key output of the work  is the feedback to the DRA designers about security and other problems which were found during the course of the work. This is discussed briefly in section \ref{issuesdetected}.
The document \cite{DS/FMU/FEF/002} discusses these.

\subsection{Phase 1 Results}\label{phase1results}
\subsubsection{Overview} \label{phase1resultsoverview}
In addition to the formulation of the Security Model, the main specification in phase 1 was the formal construction of a model of a specific, although quite abstract, system to which the Security Model is formally applicable.
This system, the SSQL Abstract Machine, which could be considered as the design for an abstract SSQL processor, is intended to serve as a formal, operational definition of the SSQL semantics.
The main proof work in phase 1 was to verify that the SSQL Abstract Machine is secure in the sense of the Security Model.
The SSQL Abstract Machine is constructed in such a way the the critical security properties are separated out from the specification of detailed functionality both to facilitate the proof and to make clear what is and is not essential to security in the construction.

Sections \ref{sm} to \ref{secureSSQL} below discuss the phase 1 results and their significance in greater detail.

\subsubsection{Security Model} \label{sm}
The Security Model defines a property $secure$ as non-interference for sequences of inputs and outputs of an abstract state-machine.
The property $secure$ is documented in \cite{DS/FMU/FEF/003}.
Note that the Security Model was actually formalised and agreed in advance of phase 1 and was taken as the common overall statement of critical security requirements for both phases of the work.


\subsubsection{SSQL Semantics}  \label{ss}
The specification of the semantics of SSQL describes how the result of an SSQL query is computed from the state of the database, covering both the response returned to the user and the new state.  Note that the fact that this is an SSQL query means that a classification is computed for the result, but does not mean that the result is sanitized for the clearance at which the query is submitted. 
 
The specification is documented in  \cite{DS/FMU/FEF/014} the point of entry being the definition of $processQuery$.

The specification is incomplete (that is, loose), in certain respects.  Of the four kinds of query (insert, delete, update and select), it is only for select that the full functionality is specified.  
(The SSQL Abstract Machine of section \ref{sam} is however, formulated so that the overall security conjecture will be insensitive to the details.)
  
\subsubsection{SSQL Abstract Machine}\label{sam}
Specification of an abstract state-machine for the secure processing of SSQL queries. The processing is in effect in three stages: 
\begin{itemize}
\item A view of the database state is constructed which hides anything not in the user's clearance.
\item The query is processed against this view (and thus with `no read up'), in accordance with the SSQL semantics.
\item If the query is an update, delete or insert, then the real database state is updated from the results of processing the view, rejecting any changes below the user's clearance (and thus with `no write down').
\end{itemize}

The SSQL abstract machine is documented in \cite{DS/FMU/FEF/006} under the name of $SSQLam$. 

\subsubsection{Theorem about $SSQLam$}\label{secureSSQL}
The following theorem is proved as the key result in phase 1:

=GFT
	Ù behaviours SSQLam ç secure
=TEX

A theorem is expressed in {\ProductHOL} as an optional list of assumptions followed by the turnstile symbol, ``Ù'', followed by a formula, called the conclusion of the theorem.
The theorem is the assertion that the conclusion is true provided all the assumptions are.
The {\Product} system ensures that the only theorems which can be computed are ones which have been derived from an identifiable list of axioms and definitions via mathematically valid rules of reasoning.
In this case, there are no assumptions, and the conclusion expresses a relationship between three named objects whose definitions form part of phase 1 specification work.
The theorem asserts that the result of applying the behavioural abstraction operation, $behaviours$, to the SSQL Abstract Machine, $SSQLam$ produces a system which belongs to the set, $secure$, of systems which conform to the Security Model.

The proof is documented in \cite{DS/FMU/FEF/015} under the name $secureSSQL$.  The proof comprises a formal validation of the fact expressed by the above theorem, viz., that all input-output sequences (behaviours) of the abstract-state machine $SSQLam$ satisfy the information-flow constraints imposed by the Security Model of section \ref{sm}.   

\subsection{Phase 2 Results} \label{phase2results}

\subsubsection{Overview} \label{phase2resultsoverview}

In the phase 2 specifications, various aspects of the actual Front End implementation of SWORD were modelled with a view to doing relevant proof work to discover security problems in the design.
The specifications were to some extent structured to expose various levels of proof opportunities for consideration by DRA, so that proof work could be done in the areas where most benefit was likely to be derived.
At the top level a formal model is described of the overall system architecture.
This gives rise to decomposition of the critical security properties into properties of the top level subsystems of the actual Front End design, together with an opportunity to verify that the critical properties on the subsystems are sufficient for overall system security.
However, these subsystems as they are do not partition conveniently into security-critical and non-critical parts.
At the next level down, then, the interactions between the subsystems were investigated by relating them to a slightly more abstract view of query execution.
At the third level, the constraints on query execution are re-expressed in terms of a quite explicit model which can be directly related to the SSQL syntax and which specifies precisely the security-relevant computations which are to be performed when a query is executed.

The main proof work was done at the third level, to prove that the model satisfies information-flow constraints which, intuitively, at least, bear a close relationship with the overall Security Model.
Proof work was also done to give a partial proof that these information-flow constraints, which amounts to showing that satisfaction of the information-flow constraints, together with some plausible assumptions about other aspects of the system, do entail that a system constructed according to the architectural model will conform to the Security Model.
A small amount of pilot proof work was carried out at the other two levels (however, the proof work at the top-level is not further discussed below).

Sections \ref{soa} to \ref{Thv} below discuss the phase 2 results and their significance in greater detail.


\subsubsection{Specification of Architecture}  \label{soa}
Specification of the architecture of a DBMS, as a construction in terms of specified subsystems.  The construction itself is called $FE\_SWORD$, \cite{DS/FMU/FEF/022},  and the architectural subsystems are 
    \begin{itemize}
    \item  $TSQLtf$,  \cite{DS/FMU/FEF/021}, corresponding to a ``conventional DBMS'',
           implementing  $TSQL$.    This may or may not be implemented in reality by a ``standard commercial DBMS'', and so            to avoid taking a position on this issue this architectural component will here be called  the ``TSQL engine''.
    \item  $STP$  (``SSQL Transformation Processor'', \cite{DS/FMU/FEF/029}) which transforms queries input in SSQL to queries in TSQL to be submitted to the TSQL engine. 
    \item  $outputFilter$,   \cite{DS/FMU/FEF/024}, which sanitises results from the TSQL engine before passing them back to the user. 
\end{itemize}

The construction also requires a state-representation function, specified as $reprState$ in \cite{DS/FMU/FEF/025}.

\subsubsection{Specification of Security-Critical Properties}  \label{scp}
Specification of security-critical properties of the architectural construction and subsystems.   These are documented in \cite{DS/FMU/FEF/022} under the names:
\begin{center}
\begin{tabular}{l}
$subsys\_secure$  \\  
$subsys\_secureA$ \\
$subsys\_secureB$ \\
$subsys\_secureC$ \\
$subsys\_secureD$ \\
$subsys\_secureE$ \\
\end{tabular}
\end{center}


\subsubsection{Subsystem Lemmas} \label{subsystemlemmas}
The statement of a collection of lemmas, which may be called the `subsystem' lemmas.  Taken together, these lemmas assert that  the security-critical properties (section \ref{scp} above) are true of the construction and subsystems of the architecture. 

Thus a proof of security assuming the lemmas will be a proof of the correctness of the architectural structuring as a first design-step. Since the lemmas are stated in terms of specifications of the individual subsystems of the architecture, they represent proof-obligations which are carried forward to later design-steps.  The subsystem lemmas are documented in \cite{DS/FMU/FEF/034} under the names:

\begin{center}
\begin{tabular}{l}
$Architecture\_Secure$  \\  
$Subsys\_SecureA$ \\
$Subsys\_SecureB$ \\
$Subsys\_SecureC$ \\
$Subsys\_SecureD$ \\
$Subsys\_SecureE$ \\
\end{tabular}
\end{center}
 

\subsubsection{Specification of $FE\_SWORD\_SYSTEM$} \label{soFESS}

$FE\_SWORD\_SYSTEM$ is a DBMS; it is  the architectural construction applied to the architectural subsystems. It is defined in \cite{DS/FMU/FEF/034}.

\subsubsection{Proof of $Theorem1$}
$Theorem1$, stated and proved in \cite{DS/FMU/FEF/034}, is  

=GFT
	Architecture_Secure,   
	Subsys_SecureA,
	Subsys_SecureB,
	Subsys_SecureC,
	Subsys_SecureD,
	Subsys_SecureE
	Ù  FE_SWORD_SYSTEM_secure
=TEX

Here there are 6 assumptions, namely the subsystem lemmas described in section \ref{subsystemlemmas} above.
The conclusion of the theorem here is the boolean term $FE\_SWORD\_SYSTEM\_secure$.
This is defined in \cite{DS/FMU/FEF/034} to be equivalent to $FE\_SWORD\_SYSTEM \in secure$, (and so the theorem has a similar form to the main theorem, $secureSSQL$,  of phase 1, discussed in section \ref{secureSSQL}).
This result shows that the architecture specified is correct with regard to the Security Model. In other words,  the security-critical requirements on the subsystems and the construction have been correctly identified in that they are indeed sufficient to ensure the security of the constructed DBMS. 

\subsubsection{Specification of Execution Model}

What is called the `Execution Model' represents a conceptual step in the development process following on from the Architecture definition.  The Execution Model  may be described as a specification of a new constraint on the architectural subsystems  $TSQLtf$ and $STP$.  The purpose of the constraint is to provide an alternative to the somewhat intractable semantics of TSQL for use in the further formal modelling. 

The Execution Model is documented in \cite{DS/FMU/FEF/026} through the specification of three new objects: $EM_1$,  $compile$ and $upd$.  $EM_1$ is a constant, while $compile$ and $update$ are variables (representing subsystems whose detailed specification is not available).
$EM_1$ is a construction function for composing the two subsystems $compile$ and $upd$.
$compile$ models compilation a query to give a formal representation of a database operation; $upd$ models the use of the result of $compile$ to update a database state.
$EM_1$ composes the two subsystems by compiling and executing a query, using $update$ to modify the database state or ``outputting'' the result of a select query as appropriate. 
A loose specification for $compile$ and $upd$ is given by a definition of correctness relative to the TSQL semantics:
 
=GFT
	Correct_Compile  = {(compile, upd) | EMâ1 compile upd = TSQLtf} 	
=TEX

\subsubsection{Reduction of Proof-Obligations: $Theorem4$} \label{componentlemmas} \label{theoremiv}

Further development, on the familiar recursive pattern,  consists of a design-decomposition of a subsystem into components, together with further correctness-proof work to reduce the subsystem proof-obligations to component proof-obligations. 

In this case,  the subsystems in question are $TSQLtf$ and $STP$, taken together, and the components in question are $EM_1$,  $compile$ and $upd$. Use is made of the definitions of the Execution Model to show that the lemma $Subsys\_SecureE$ can be reduced to  three lemmas, called:

\begin{center}
\begin{tabular}{l}
$EM\_SecureE$   \\ 
$Correct\_Compile\_OkSTP$ \\
$TableComputationsSecure$
\end{tabular}
\end{center}

These lemmas are documented in \cite{DS/FMU/FEF/034}, and the relevant theorem is  stated and proved in \cite{DS/FMU/FEF/034} as  $Theorem4$:    
 


=GFT
	Architecture_Secure,   
	Subsys_SecureA,
	Subsys_SecureB,
	Subsys_SecureC,
	Subsys_SecureD,
	EM_SecureE,  
	Correct_Compile_OkSTP,
	TableComputationsSecure
	Ù  FE_SWORD_SYSTEM_secure
=TEX

which may be compared with $Theorem1$ above.
The approach here is that of so-called ``partial proofs'', in which a partial attack is made on a verification problem by successively attacking the assumptions of an initial theorem (typically vacuous: $P\,Ù\,P$).
The goal being to replace each assumption of the initial theorem with zero or more assumptions which are more plausible, or which constrain fewer or simpler components of the system.

The significance of this theorem is that assumption $Subsys\_SecureE$ of $Theorem1$  has been shown to be reducible to a condition, $EM\_SecureE$ on  $EM_1$, provided that 
\begin{itemize}
\item  $STP$ is related in a certain way to $compile$, the relationship being that specified in the definition of $Correct\_Compile\_OkSTP$.
In essence, this says the the input-output behaviour of a select query at any state could equally well be computed by interpreting the query in the state according to a set of rules captured in the definition of a set of computations called $TableComputations$.
Subject to various modelling assumptions discussed in detail in \cite{DS/FMU/FEF/032}, the details of the definition of this set are based closely on the semi-formal definition of the query transformations specified informally in \cite{trans}.
In a certain sense, $TableComputations$ embodies a description of SSQL in terms of a relational algebra augmented with security features.
\item  All the computations in the set $TableComputations$, satisfy certain natural information-flow constraints, as specified in the definition of $TableComputationsSecure$.
\end{itemize}  

\subsubsection{$Theorem5$}   \label{Thv}
Further proof work results in reducing $Theorem4$ above to $Theorem5$ below, which is documented in \cite{DS/FMU/FEF/036}.  This result is ``the best partial proof of the overall system security''.


=GFT
	Architecture_Secure,   
	Subsys_SecureA,
	Subsys_SecureB,
	Subsys_SecureC,
	Subsys_SecureD,
	Viewât_secureE,
	outputFilter_secureE,
	Correct_Compile_OkSTP,
	Ù  FE_SWORD_SYSTEM_secure
=TEX

$Theorem5$, in comparison with $Theorem4$, represents progress in the following respects:

\begin{itemize}
\item The assumption $TableComputationsSecure$ has disappeared, since it has been proved as a theorem, as documented in \cite{DS/FMU/FEF/036}.
This indicates that the bottom level of proof work as discussed in section \ref{phase2resultsoverview} is complete --- the SSQL relational algebra satisfies the information-flow constraints imposed upon it.
\item The assumption $EM\_SecureE$ has been replaced by two new assumptions $View_t\_secureE$ and $outputFilter\_secureE$.
This indicates partial progress on the second level of proof work and reflects a reduction of the assumption $EM\_SecureE$ of $Theorem4$ to conditions, $View_t\_secureE$ and $outputFilter\_secureE$ on two of the constituents of $EM_1$.
\end{itemize}

    
\subsection{Issues Detected} \label{issuesdetected}.
The main issues with the SSQL and Front End designs which were detected during the project are described and discussed in \cite{DS/FMU/FEF/002}.
These fall under several classes (but are not organised in that way in \cite{DS/FMU/FEF/002}):

\begin{itemize}
\item
Syntax and type checking errors: the bulk of the design was conveyed to ICL in a semi-formal notation; transcription of this into a machine-checked formal language revealed errors such as misspellings of names, failure to pass arguments correctly, and omission of auxiliary definitions.
While none of these are relevant to security directly, it seems likely that knock-on problems caused by errors such as using the same name twice for two different objects could result in significant problems in implementation.
This type of problem is detected automatically as the design is transcribed and checked using the {\Product} tool.

Approximately 30 problems of this class were reported in phase 1 and about the same number in phase 2.

\item
Incompleteness: for example, security of the query transformations of \cite{trans} relies on directories and tables which the client is not cleared to see not being loaded into the transformation symbol table; this was not made explicit in the design material.
The detection of this type of error depends on whether an object is just referenced and not defined (in which case the tool will flag the omission) or whether an object is inappropriately given a dummy definition (in which case the significance off the omission may not become apparent until proof is attempted).

Some 13 problems of this class were reported in phase 1 and 6 in phase 2.
Perhaps 5 or 6 of the 7 phase 2 problems were directly relevant to security in that a security check was omitted from the design in a way which would lead directly to a violation of the Security Model if reflected in the implementation.

\item
Algorithmic errors: for example, security of the overall system is crucially dependent on clearances of fields within derived tables being computed in a way which respects the possible flow of information into the field.
The functional requirements on SWORD mean that some of these computations are quite subtle.
This type of error, if it is security relevant, is certain to be exposed during a full proof of security, and has a good chance of being exposed by partial proof work as carried out in phase 2 if the area of attack is carefully chosen.

1 major problem of this type was discovered in phase 1 and 5 were discovered in phase 2.
All but one of these problems were discovered during the proof work rather than during formulation of the specifications, and all would lead directly to a violation of the Security Model if reflected in the implementation.

\item
Modelling errors: these are errors where the assumptions used to model a system themselves give rise to problems which would not actually arise in an implementation: an example in the FEF work was in the phase 2 model of select query execution ($TableComputations$), which, in a sense, tries to recover from errors which cause execution to be aborted (or never initiated) in the implementation.

Only 1 significant problem of this type arose (viz., the above one).
\end{itemize}


\pagebreak
\section{RESULTS AND EVALUATION DELIVERABLES} \label{raed}
This section aims at relating the the results of the FEF project to possible deliverables for an evaluation at various levels of the ITSEC criteria. This section is in support of the aim of DRA to commission a report from a CLEF which will `provide an assessment of whether the SWORD Front End approach is capable of achieving a useful ITSEC rating'. 

The approach will be to consider selected deliverables, and the requirements on each, and then to discuss how results from the FEF project may be used in satisfying those requirements. 


The list of E3 deliverables which are taken to be within the scope of this report is as follows:

\begin{enumerate}
\item Security Target [Ref E3.1, E3.2, E3.3]
\item Informal Description of the Architecture.[E3.1, E3.5, E3.6]
\item Informal Description of the Detailed Design. [E3.1, E3.8, E3.9].
\item (Perhaps, because  of the issue discussed in section \ref{scope} above) Information on the Acceptance Procedure of the Configuration Control System
\end{enumerate}

Additionally, there is a requirement for an informal description of the correspondence between source code or hardware drawings and  the detailed design [Ref E3.1, E3.11].   This is relevant only in so far as it characterises a detailed design as that with which a source-code correspondence can be adequately established.

Each of these three deliverables is now considered in more detail. The ITSEC term `Target of Evaluation' (TOE) is interpreted as `DBMS'.

\subsection{Security Target}
The Security Target deliverable is the statement of security requirements. The requirements under the ITSEC headings of Content and Presentation and Evidence are:
\begin{enumerate}

\item It shall describe the security enforcing functions to be provided by the DBMS. 

\item It shall include a rationale identifying the method of use, the intended environment and  the assumed threats within that environment. 

\item The security-enforcing functions within the security target shall be specified in an informal style.

\item It shall describe how the functionality is appropriate for that method of use and is adequate to counter the assumed threats.
\end{enumerate}

The FEF Security Model of \cite{DS/FMU/FEF/003}, section \ref{sm} above, can reasonably be part of an offering to satisfy the first of these requirements.   It describes only the security-enforcing function of the DBMS  which is the prevention of down-flows. 

Of the eight generic headings identified by the ITSEC [ref 2.31, 2.32] for possible security-enforcing functions, the Security Model concerns one, {\em Access Control}.  With regard to the Access Control function,  \cite{DS/FMU/FEF/003} assumes that ` mechanisms outside the scope of this model ensure that users see only those outputs they are cleared to see'. Also, there are interesting features of the DBMS which are not in the model: one classified object may be contained in another, and information about existence of objects may be classified differently from the information contained in those objects.

Consequently, to meet the requirements for a Security Target, the Security Model of \cite{DS/FMU/FEF/003} would need to be supplemented by other material.     


With regard to the third requirement,  the ITSEC mandates that an informal style of presentation shall be used for all security targets, any formal specification being in addition [2.66]. \cite{DS/FMU/FEF/003} contains a mixture of informal and formal text.  The opinion is offered that although \cite{DS/FMU/FEF/003} may not be quite suitable for someone to understand without special training,  it is not far from it.  
 
\subsection{Architecture}
The requirements for the Description of the Architecture, under the headings of Content and Presentation and Evidence,  are as follows. Again writing `DBMS' for `Target of Evaluation', then the Description of Architecture shall describe: 
\begin{enumerate}
\item the general structure of the DBMS.
\item the external interfaces of the DBMS .
\item any supporting hardware or firmware with statement of the functionality of supporting protection mechanisms 
\item the separation of the DBMS into security-enforcing and other components.
\item how the security-enforcing functions will be provided.
\item how the separation into security-enforcing and other components is achieved.
\end{enumerate}
\subsubsection{Requirement 1: General Structure}  \label{reqone}

The FEF project result which is the Specification of the $FE\_SWORD\_SYSTEM$ can reasonably be offered in satisfaction of (part of) the first requirement, the description of the general structure.


This specification is relatively abstract.  It is described as an Architectural Model, wherein relationships between subsystems are modelled by the composition of functions (in the mathematical sense). At more concrete level, a description of general structure might be in terms of processes,  flows of data between processes and separation between processes  (e.g. issues of physical separation or network topology). 

The basis of the approach to security is separate the user from the TSQL engine by interposing the Front End. An account of how this separation is concretely achieved, thereby establishing the relevance of the abstract Architectural Model, is evidently fundamental for evaluation.     


Further issues arise in that, because the $FE\_SWORD\_SYSTEM$ is specified relatively abstractly, there may be further structural components not identified. Possible examples are:
\begin{itemize}
\item Processing of the concrete representations of input queries and output tables.
\item Database administrator's interface.
\item Trusted functions e.g. hardcopy labelling. 
\end{itemize}

\subsubsection{Requirement 2: External Interfaces}
The specification of the $SSQLam$  ( section \ref{ss} above) is a candidate for the specification of the main external interface of the DBMS.  This specification is not currently complete.
 
{\em Questions: what other external interfaces might there be?  Is the SSQL semantics still valid/current? }

\subsubsection{Requirement 3}
No statement is available with regard to dependence on protection mechanisms in supporting hardware/firmware.

\subsubsection{Requirement 4}

With regard to the separation of the DBMS into security-enforcing and other components, there are various positions which might be taken, depending upon the rationale of modes of use and threats which would be supplied for evaluation as part of the security target.

Evidently one possibility is to draw the dividing line between the Front End and the TSQL engine. The latter is one of the subsystems described by the Architecture.  Since the TSQL engine has no functionality specific to multilevel security, then it may be asserted to be not a security-enforcing component.  However, this does not mean that the TSQL engine may be entirely untrusted, since its correct functioning is security-critical.

Further consideration of this issue is a matter for the CLEF.

\subsubsection{Requirements 5 and 6}
Regarding these two requirements, there is nothing to add to the discussion in section \ref{reqone} above.

\subsection{Detailed Design}
The requirements under the headings of Content and Presentation and Evidence, for the Description of the Detailed Design, are as follows. It shall: 
\begin{enumerate}
\item specify all basic components
\item describe the realisation of all security-enforcing mechanisms and security relevant functions
\item map security enforcing functions to mechanisms and components
\item document all interfaces of security-enforcing and security-relevant components, stating their purpose and parameters.
\item provide specifications/definitions for mechanisms, which shall be suitable for the analysis of interrelationships between the mechanisms employed.
\item [show] a clear and hierarchical relationship between levels of specification (if more than one level is provided).
\item describe how the security mechanisms provide the security enforcing functions specified in the security target.
\item describe why components for which no design information is provided cannot be either security-enforcing or security-relevant.
\end{enumerate}


The assumptions of $Theorem5$ show  what still remains to be accomplished before the task describable as Detailed Design would be complete.   The task would be to produce specifications for a set of components such that:
\begin{itemize}
\item The assumptions of $Theorem5$ are provably true of a set of components with these specifications.
\item It could be shown that these components meet their specifications by reference to the source code of the implementations (because this is what the ITSEC means by detailed design). 
\end{itemize}

Evidently progress has been made towards the Detailed Design, in that specifications have been produced for objects at a more detailed level than the Architecture.   It is doubtful if more than this can be said.

\pagebreak
\section{OBSERVATIONS AND CONCLUSIONS} \label{oac}

\subsection{The Value of a Formal Treatment} 

One specification in particular has been troublesome, namely \cite{DS/FMU/FEF/032} (and its predecessor document, \cite{trans} which is an early specification for a prototype implementation of the SSQL Transformation Processor, $STP$).
Errors came to light over an extended period (\cite{DS/FMU/FEF/036}, section 1.2, section 4.1), in part discovered with the aid of a tool which checks type-correctness.  Possible covert channels were discovered in the attempt to prove a first formulation of $TableComputationsSecure$.     

There were errors in early versions of \cite{specssql},  the SSQL specification as supplied to the project, documented in \cite{DS/FMU/FEF/002}.   


\subsection{Observation}
 
Although the $SSQLam$ may be taken as a specification (of the external interfaces to the DBMS), and the theorem $secureSSQL$ has been proved, (which is of the nature of a specification-to-model correspondence proposition),  further development work has not been aimed at showing that the Architectural Design (that is, $FE_SWORD_system$) satisfies the specification, but rather, in every case, at showing that it satisfies the security-model directly.   Is this good or bad?

\subsection{Observation}

Can we say anything useful about Formal Methods  as a way of dealing with complexity? 

Much effort has been taken up by dealing with the complexity of SSQL in the formal treatment, and the introduction of the Execution Model represents an attempt to avoid dealing with it directly.   However, this very complexity is a major motivator for a formal treatment at E3, which does not inherently call for a formal treatment.     





=IGN
\section{PROOF POWER}
Reference is made throughout this document to the \Product{} system. 
This is the chosen theorem proving tool for this project, referred to in the original proposal, \cite{DS/FMU/017}, as ICL HOL. The facilities 
available in \Product{} are documented in  \cite{DS/FMU/IED/USR006} 



=TEX
\end{document}




