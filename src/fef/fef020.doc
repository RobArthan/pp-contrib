=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Specification of Query Transformations in SML (II)}  %% Mandatory field
\TPPref{DS/FMU/FEF/020}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{A specification of the SSQL Query Transformations in Standard ML for the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion ({\FormatDate{$Date$
}})]  Mutual recursion dealt with by specifying appropriate functions together.
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document gives a formal specification in Standard ML (\cite{milner90}, \cite{paulson91}) of the SSQL query transformations of \cite{trans}. It constitutes part of
 deliverable D8 of work package 3, as given
in the Proposal for Phase~2, \cite{DS/FMU/FEF/018}.

\subsection{Introduction}
We provide Standard ML specifications of the 
SSQL query transformations of \cite{trans}. Preliminary 
material needed
 to support these query 
transformation specifications may be found in \cite{DS/FMU/FEF/019}.

\section{THE TRANSFORMATIONS}
Exceptions are raised by the SSQL transformations:
=SML
exception internalError;
exception wrongType;
exception wrongWorth;
exception notTrigger;
exception onlyInTriggers;
exception notMonadic;
exception notDyadic;
exception notTriadic;
exception notSetFunction;
exception noSuchColumn;
exception noSuchTable;
exception noSuchDirectory;
exception noSuchParameter;
exception noScope;
exception wrongScope;
exception ambiguousName;
exception tooWide;
exception emptyUnionList;
=TEX
\subsection{Incompletely Specified Transformations}
The following functions have not been specified in \cite{trans}. The exception $notDefined$, from \cite{DS/FMU/FEF/019}, is raised.
=SML
fun 	(Ûcheck_enumÝ : Enum * int * Table_specèssqlê -> bool) x 
					= raise notDefined "check_enum";
=TEX
=SML
fun 	(Ûcheck_fixedÝ : Fixed * int * int -> bool) x = raise notDefined "check_fixed";
=TEX
=SML
fun 	(Ûcheck_floatingÝ : Floating * int * int * int -> bool) x 
					= raise notDefined "check_floating";
=TEX
=SML
fun 	(Ûcheck_intervalÝ : Interval * string -> bool) x = raise notDefined "check_interval";
=TEX
=SML
fun 	(Ûcheck_timeÝ : Time * string -> bool) x = raise notDefined "check_time";
=TEX
=SML
fun 	(ÛtimeFormatToIntervalÝ : string -> string) x 
					= raise notDefined "timeFormatToInterval";
=TEX
=SML
fun 	(Ûunique_nameÝ : unit -> string) () = raise notDefined "unique_name";
=TEX
=SML
fun 	(Ûclient_clearanceÝ : unit -> Class) () = raise notDefined "client_clearance";
=TEX
=SML
fun 	(Ûcontextual_dataÝ : string -> Constant_valueèssqlê * Class) s 
					= raise notDefined "contextual_data";
=TEX
=SML
fun 	(Ûquery_classÝ : unit -> Class) () = raise notDefined "query_class";
=TEX
=SML
fun 	(Ûquery_constants_classÝ : unit -> Class) () 
					= raise notDefined "query_constants_class";
=TEX
=SML
fun 	(Ûdefault_directoryÝ : unit -> string list) () = raise notDefined "default_directory";
=TEX
\subsection{Symbol Table Model}
=SML
fun 	(ÛfindècolumnêÝ : ColumnSpecification * TableDetail list -> 
						(TableDetail * SsqlCol * TsqlCol)list) 
			(cs,[]) = []
|	findècolumnê 	(cs,tdl) =
		let	fun 	(look : string * TableDetail * SsqlCol list * TsqlCol list
						->(TableDetail * SsqlCol * TsqlCol)list)
					(n,td,[],x) = []
				| look	(n,td,x,[]) = []
				| look  (n,td,scl,tcl) =
					let 	val scs = rev(tl(rev scl))
						val sc = hd(rev scl)
						val tcs = rev(tl(rev tcl))
						val tc = hd(rev tcl)
					in 	look(n,td,scs,tcs) @
						(if #name sc = name‰s n then [(td,sc,tc)]
						else [])
					end
			val tds = rev(tl(rev tdl))
			val td = hd(rev tdl)
		in 	findècolumnê(cs,tds) @
			(case cs of 
				anonymous_column col => 
					look(col,td,#columns td,#implementation td)
			|	specific(ts,col) => 
					(case (#tableName td) of
						nameètnê ts =>
						look(col,td,#columns td,#implementation td)
					|	other => []))		
		end;
=TEX
=SML
fun 	(ÛfindèidentêÝ : ColumnSpecification * IdentDetail list -> IdentDetail list) 
			(cs,[]) = []
|	findèidentê 	(specific(t,c),ids) = []
|	findèidentê 	(anonymous_column col,idl) = 
				let	val ids = rev(tl(rev idl))
					val id = hd(rev idl)
				in 	findèidentê(anonymous_column col,ids) @
						(if col = #identName  id
						then [id]
						else [])
				end;
=TEX
=SML
local	fun 	(look : ColumnSpecification  * Scope list -> TableInfo * SsqlCol)
			(cs,[]) = raise noSuchColumn
	|	look	(cs,sl) = 	let	val outer = rev(tl(rev sl))
						val {tables = t,identifiers = i} = hd(rev sl)
					in 	case findècolumnê(cs,t) of
							[] => look(cs,outer)
						|	[(td,sc,tc)] => (#info td,sc)
						|	xs => raise ambiguousName
					end
in
fun 	(Ûlookupècolumn_infoêÝ : ColumnSpecification -> TableInfo * SsqlCol) 
		cs = look(cs,!symbolTable)
end;
=TEX
=SML
fun 	(ÛmaxBoundÝ : BoundInfo -> Class) 
			(upb c) = c
|	maxBound	(constant c) = c;		
=TEX
=SML
fun 	(ÛinnermostÝ : Scope list -> Scope list) 
			[] = []
|	innermost	sl =	let 	val outer = rev(tl(rev sl))
					val inner = hd(rev sl)
					val {tables = tds,identifiers = ids} = inner
				in 
				if tds = [] then innermost outer @ [{tables = [],identifiers = ids}]
				else [inner]
				end;		
=TEX
=SML
local 	fun 	(look : ColumnSpecification  * Scope list -> TsqlRepr * Class)
			(cs,[]) = raise noSuchColumn
	|	look	(cs,sl) = 	
			let	val outer = rev(tl(rev sl))
				val {tables = t,identifiers = i} = hd(rev sl)
			in 	case (findècolumnê(cs,t),findèidentê(cs,i)) of
					([],[]) => look(cs,outer)
				|	([(td,sc,tc)],[]) => 
					let val u = maxBound(#col_class sc)
					in
					case (#class_name tc) of
						anonètcê => raise internalError
					|	nameètcê s => (column(#genCorr td,s),u)
					|	constantètcê c => (constant_class c,u)
					end
				|	([],[id]) =>
					(case (#cName id) of
						none‰t => (constant_class (#lubèidê id),#lubèidê id)
					|	anon‰t => raise internalError
					|	name‰t s => (local_identifier s,#lubèidê id))
				|	(xs,ys) => raise ambiguousName
			end
in
fun 	(Ûlookupècol_spec_classêÝ : bool * ColumnSpecification -> TsqlRepr * Class) 
				(true,cs) = look(cs,innermost (!symbolTable))
|	lookupècol_spec_classê	(false,cs) = look(cs,!symbolTable)
end;
=TEX
=SML
local 	fun 	(look : ColumnSpecification  * Scope list -> TsqlRepr)
			(cs,[]) = raise noSuchColumn
	|	look	(cs,sl) = 
			let	val outer = rev(tl(rev sl))
				val {tables = t,identifiers = i} = hd(rev sl)
			in 	case (findècolumnê(cs,t),findèidentê(cs,i)) of
					([],[]) => look(cs,outer)
				|	([(td,sc,tc)],[]) => 
						(case (#dinary_name tc) of
							none‰t => raise internalError
						|	anon‰t => raise internalError
						|name‰t s => column(#genCorr td,s))
				|	([],[id]) =>
						(case (#info id) of
							(st,dinary) => 
								(local_identifier(#vName id))
						|	(st,other) => constant_null)
				|	(xs,ys) => raise ambiguousName
					end
in
fun 	(Ûlookupècol_spec_dinaryêÝ : bool * ColumnSpecification -> TsqlRepr) 
				(true,cs) = look(cs,innermost (!symbolTable))
|	lookupècol_spec_dinaryê	(false,cs) = look(cs,!symbolTable)
end;
=TEX
=SML
local 	fun 	(look : ColumnSpecification  * Scope list -> TsqlRepr)
			(cs,[]) = raise noSuchColumn
	|	look	(cs,sl) = 
			let	val outer = rev(tl(rev sl))
				val {tables = t,identifiers = i} = hd(rev sl)
			in 	case (findècolumnê(cs,t),findèidentê(cs,i)) of
					([],[]) => look(cs,outer)
				|	([(td,sc,tc)],[]) => 
						(case (#dinary_name tc) of
							none‰t => raise internalError
						|	anon‰t => raise internalError
						|name‰t s => column(#genCorr td,s))
				|	([],[id]) =>
						(case (#info id) of
							(st,sterling) => 
								(local_identifier(#vName id))
						|	(st,other) => constant_null)
				|	(xs,ys) => raise ambiguousName
					end
in
fun 	(Ûlookupècol_spec_sterlingêÝ : bool * ColumnSpecification -> TsqlRepr) 
				(true,cs) = look(cs,innermost (!symbolTable))
|	lookupècol_spec_sterlingê	(false,cs) = look(cs,!symbolTable)
end;
=TEX
=SML
local	fun (project_implementation : TableDetail -> TsqlCol list)
		td = #implementation td
	fun (extract_implementation : Scope -> TsqlCol list)
		sc = fold (op @) (map project_implementation (#tables sc))
in
fun 	(Ûlookupèlocal_col_implementationêÝ : unit -> TsqlCol list) 
	() = 	case (fold (op @)(map extract_implementation(innermost (!symbolTable)))) of 
			[] => raise noScope
		|	trs => trs
end;
=TEX
=SML
local	fun (project_columns : TableDetail -> SsqlCol list)
		td = #columns td
	fun (extract_columns : Scope -> SsqlCol list)
		sc = fold (op @) (map project_columns (#tables sc))
in
fun 	(Ûlookupèlocal_col_infoêÝ : unit -> SsqlCol list) 
	() = 	case (fold (op @)(map extract_columns(innermost (!symbolTable)))) of 
			[] => raise noScope
		|	trs => trs
end;
=TEX
=SML
local	fun (look2 : string * SsqlCol * TsqlCol -> TsqlRepr * Class)
		(corr,sc,tc) = 	let val u = maxBound(#col_class sc)
				in	case (#class_name tc) of
						anonètcê => raise internalError
					|	nameètcê s => (column(corr,s),u)
					|	constantètcê c => (constant_class c,u)
				end
	fun (look1 : TableDetail -> (TsqlRepr * Class) list)
		td = at3 (map look2)(seq(length(#columns td),#genCorr td),
						#columns td,#implementation td)		
	fun (look : Scope -> (TsqlRepr * Class) list)
		sc = fold (op @) (map look1 (#tables sc))
in
fun 	(Ûlookupèlocal_col_spec_classesêÝ : unit -> (TsqlRepr * Class) list) 
	() = 	case (fold (op @)(map look (innermost (!symbolTable)))) of 
			[] => raise noScope
		|	trs => trs
end;
=TEX
=SML
local	fun (look2 : string * TsqlCol -> TsqlRepr)
		(corr,tc) = 	case (#sterling_name tc) of
					none‰t => constant_null
				|	anon‰t => raise internalError
				|	name‰t s => column(corr,s)
	fun (look1 : TableDetail -> TsqlRepr list)
		td = at2 (map look2)(seq(length(#columns td),#genCorr td),
							#implementation td)		
	fun (look : Scope -> TsqlRepr list)
		sc = fold (op @) (map look1 (#tables sc))
in
fun 	(Ûlookupèlocal_col_spec_sterlingsêÝ : unit -> TsqlRepr list) 
	() = 	case (fold (op @)(map look (innermost (!symbolTable)))) of 
			[] => raise noScope
		|	trs => trs
end;
=TEX
=SML
local	fun (look1 : TableDetail -> TsqlRepr)
		td = 	case (#rowClass td) of
					anonètcê => raise internalError
				|	nameètcê s => column(#genCorr td,s)
				|	constantètcê c => constant_class c
	fun (look : Scope -> TsqlRepr list)
		sc = (map look1 (#tables sc))
in
fun 	(Ûlookupèlocal_row_classesêÝ : unit -> TsqlRepr list) 
	() = 	case (fold (op @)(map look (innermost (!symbolTable)))) of 
			[] => raise noScope
		|	trs => trs
end;
=TEX
=SML
local 	fun 	(look : ColumnSpecification  * Scope list -> TsqlRepr)
			(cs,[]) = raise noSuchColumn
	|	look	(cs,sl) = 	
			let	val outer = rev(tl(rev sl))
				val {tables = t,identifiers = i} = hd(rev sl)
			in 	case (findècolumnê(cs,t),findèidentê(cs,i)) of
					([],[]) => look(cs,outer)
				|	([(td,sc,tc)],[]) => 
					(case (#rowClass td) of
						anonètcê => raise internalError
					|	nameètcê s => column(#genCorr td,s)
					|	constantètcê c => constant_class c)
				|	([],[id]) => constant_class (query_class())
				|	(xs,ys) => raise ambiguousName
			end
in
fun 	(Ûlookupècolumn_row_classêÝ : bool * ColumnSpecification -> TsqlRepr) 
				(true,cs) = look(cs,innermost (!symbolTable))
|	lookupècolumn_row_classê	(false,cs) = look(cs,!symbolTable)
end;
=TEX
=SML
local	fun (look1 : TableSpecification * TableDetail -> TsqlRepr list)
		(ts,td) = 	case (#tableName td) of
					anonètnê => []
				|	nameètnê tn => if ts = tn then 
							(case (#rowClass td) of
								anonètcê => raise internalError
							|	nameètcê s => 
									[column(#genCorr td,s)]
							|	constantètcê c => 
									[constant_class c])
							else []
	fun 	(look : TableSpecification * Scope list -> TsqlRepr)
			(ts,[]) = raise noSuchTable
		| look	(ts,sl)	= 	
			let 	val outer = rev(tl(rev sl))
				val {tables = tds,identifiers = ids} = hd(rev sl)
			in 	(case fold(op @)(at2 (map look1)(seq(length tds,ts),tds)) of
					[] => look(ts,outer)
				|	[tr] => tr
				|	trs => raise ambiguousName)
			end		
in				
fun 	(Ûlookupètable_row_classêÝ : bool * TableSpecification -> TsqlRepr) 
				(true,ts )= look(ts,innermost (!symbolTable))
|	lookupètable_row_classê (false,ts) = look(ts,!symbolTable)
end;
=TEX
=SML
local	fun (look1 : TableSpecification * TableDetail -> TableDetail list)
		(ts,td) = 	case (#tableName td) of
					anonètnê => []
				|	nameètnê tn => if ts = tn then [td]
							else []
	fun 	(look : TableSpecification * Scope list -> TableDetail)
			(ts,[]) = raise noSuchTable
		| look	(ts,sl)	= 	
			let 	val outer = rev(tl(rev sl))
				val {tables = tds,identifiers = ids} = hd(rev sl)
			in 	(case fold(op @)(at2 (map look1)(seq(length tds,ts),tds)) of
					[] => look(ts,outer)
				|	[ti] => ti
				|	tis => raise ambiguousName)
			end		
in				
fun 	(Ûlookupètable_detailêÝ : TableSpecification -> TableDetail) 
	ts = look(ts,!symbolTable)
end;
=TEX
\subsection{Symbol Table Operations}
=SML
local	fun (find : string * IdentDetail -> IdentDetail list)
		(n,id) = 	if n = #identName id
				then  [id]
				else []
in
fun 	(ÛenterèidentifierêÝ : string * ExpType * Class -> string * string)
	(name,et,up) =	
	case !symbolTable of
		[] => raise noScope
	| 	sl => 	let 	val outer = rev(tl(rev sl))
				val {tables = tds,identifiers = ids} = hd(rev sl)
			in	if tds = [] then
				let 	val 	unv = unique_name()
						val	unc = unique_name()
						val	id = 	{identName = name,
								info = et,
								lubèidê  = up,
								vName = unv,
								cName = name‰t unc}
				in	if at2(map find) (seq(length ids,name),ids) <> []
					then raise ambiguousName
					else	
					let val side_effect =  symbolTable := outer @ 
								[{tables = [],identifiers = ids @ [id]}]
					in (unv,unc)
					end
				end	
				else raise wrongScope
			end
end;
=TEX
=SML
local	fun (find : string * IdentDetail -> IdentDetail list)
		(n,id) = 	if n = #identName id
				then  [id]
				else []
in
fun 	(Ûenterèidentifier_constant_classêÝ : string * ExpType * Class -> string)
	(name,et,clasf) =	
	case !symbolTable of
		[] => raise noScope
	| 	sl => 	let 	val outer = rev(tl(rev sl))
				val {tables = tds,identifiers = ids} = hd(rev sl)
			in	if tds = [] then
				let 	val 	unv = unique_name()
						val	id = 	{identName = name,
								info = et,
								lubèidê  = clasf,
								vName = unv,
								cName = none‰t}
				in	if at2(map find) (seq(length ids,name),ids) <> []
					then raise ambiguousName
					else	
					let val side_effect =  symbolTable := outer @ 
								[{tables = [],identifiers = ids @ [id]}]
					in unv
					end
				end	
				else raise wrongScope
			end
end;
=TEX
=SML
fun 	(ÛextractèparameterêÝ : string * ParamInfo list  -> ParamInfo list) 
				(name,[]) = 	[]	
|	extractèparameterê		(name,l) = 	let	val more = rev(tl(rev l))
							val pi = hd(rev l)
						in
							if name = #name pi
							then extractèparameterê(name,more) @ [pi]
							else 	extractèparameterê(name,more)
						end;
=TEX
=SML
fun 	(ÛenterèparameterêÝ : string * Constant_valueèssqlê * Class -> unit) (name,v,clasf) =	
	if !symbolTable <> []
	then raise wrongScope
	else 	case extractèparameterê(name,!parameterTable) of
			[] => parameterTable := !parameterTable @  
						[{name =name,val‰p =v,clasf =clasf}]
		|	ps => raise ambiguousName;
=TEX
=SML
fun 	(Ûenterècorr_tableêÝ : string * TableName * TableInfo * SsqlCol list * TsqlClassName 
									* TsqlCol list -> string)
	(cn,ts,ti,scs,rcn,tcs) =	
		case !symbolTable of
				[] => raise noScope
			| 	sl => 	let 	val outer = rev(tl(rev sl))
						val {tables = tds,identifiers = ids} = hd(rev sl)
					in 	if ids = [] then
					let 	val gc = unique_name()
						val td = 	{tableName = ts,
								corrName = name‰s cn,
								genCorr = gc,
								info = ti,
								columns = scs,
								rowClass = rcn,
								implementation = tcs,
								constraints = 	{null_allowed=[],
										lwb=[],
										unique=[],
										uniform=[],
										index=[]}}
					val side_effect =  symbolTable := outer @
								[{tables = rev(td::tds),identifiers=[]}]
					in gc
					end
						else raise wrongScope
					end;
=TEX
=SML
fun 	(ÛenterètableêÝ : TableName * TableInfo * SsqlCol list 
				* TsqlClassName * TsqlCol list -> string)
		(ts,ti,scs,rcn,tcs) =	
		case !symbolTable of
				[] => raise noScope
			| 	sl => 	let 	val outer = rev(tl(rev sl))
						val {tables = tds,identifiers = ids} = hd(rev sl)
					in 	if ids = [] then
					let 	val gc = unique_name()
						val td = 	{tableName = ts,
								corrName = anon‰s,
								genCorr = gc,
								info = ti,
								columns = scs,
								rowClass = rcn,
								implementation = tcs,
								constraints = 	{null_allowed=[],
										lwb=[],
										unique=[],
										uniform=[],
										index=[]}}
					val side_effect =  symbolTable := outer @
								[{tables = rev(td::tds),identifiers=[]}]
					in gc
					end
						else raise wrongScope
					end;
=TEX
=SML
fun 	(Ûenter_scopeÝ : unit -> unit) () = 
	symbolTable := !symbolTable @ [{tables = [],identifiers = []}];
=TEX
=SML
fun 	(Ûleave_scopeÝ : unit -> unit) () = 
	case !symbolTable of
		[] => raise noScope
	|	sl => symbolTable := rev(tl(rev sl));
=TEX

=SML
fun 	(Ûgetètable_infoêÝ : TableSpecification -> TableInfo * ConstraintInfo * SsqlCol list 
						* TsqlClassName * TsqlCol list) x 
				= raise notDefined "getètable_infoê";
=TEX
=SML
fun 	(Ûlookupèlocal_table_implementationêÝ : unit -> TsqlClassName list ) () 
					= raise notDefined "lookupèlocal_table_implementationê";
=TEX
=SML
fun 	(Ûlookupèlocal_table_infoêÝ : unit -> TableInfo list ) 
	() = 	let 	fun 	(look1 : TableDetail -> TableInfo)
				td = #info td
			fun	(look : Scope -> TableInfo list)
				sc = map look1 (#tables sc)
		in
		case fold(op @)(map look(innermost (!symbolTable))) of
			[] => raise noScope
		|	trs => trs
		end;
=TEX
=SML
fun 	(Ûlookupèparam_dataêÝ : string -> Constant_valueèssqlê * Class) 
	name = case extractèparameterê(name,!parameterTable) of
			[] => raise noSuchParameter
		|	[info] => (#val‰p info,#clasf info)
		|	other => raise internalError;
=TEX
Entering and leaving scope is achieved by side effect. We define a function to  this.
=SML
fun 	(Ûin_new_scopeÝ (what : unit -> 'a):'a) = (
	let	val side_effect = enter_scope()
		val body = what()
		val side_effect = leave_scope()
	in	body
	end);
=TEX
\subsection{Transformations Proper}
=SML
fun 	(Ûrepr_colÝ : TsqlRepr -> Col_specètsqlê) 
			(local_identifier name) =  denote_col_spec‰t name
|	repr_col	(column(corr,col)) = absolute_col_spec‰t([],corr,col)
|	repr_col	(constant_class c) = raise internalError
|	repr_col	constant_null = raise internalError;
=TEX
=SML
fun 	(Ûall_data_columnsèlocalêÝ : unit -> Col_specètsqlê list) () 
					= map repr_col(lookupèlocal_col_spec_sterlingsê());
=TEX
=SML
fun 	(Ûbinop_typeÝ : Op * SwordType * SwordType -> SwordType) 
				(plus_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					fixedType(p1 max p2,s1 max s2)
| 	binop_type 		(plus_op,floatingType(m1,e1,os1),floatingType(m2,e2,os2)) = 
					if m1 = m2 andalso e1 = e2 andalso os1 = os2 
					then floatingType(m1,e1,os1)
					else raise wrongType
|	binop_type 		(plus_op,enumType(p1,t1),fixedType(p2,0)) = enumType(p1,t1)
|	binop_type 		(plus_op,timeType f1,intervalType f2) = timeType f1
|	binop_type 		(plus_op,intervalType f1,intervalType f2) = 
					if f1 = f2
					then intervalType f1
					else raise wrongType
|	binop_type 		(plus_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(minusd_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					fixedType(p1 max p2,s1 max s2)
| 	binop_type 		(minusd_op,floatingType(m1,e1,os1),floatingType(m2,e2,os2)) = 
					if m1 = m2 andalso e1 = e2 andalso os1 = os2 
					then floatingType(m1,e1,os1)
					else raise wrongType
|	binop_type 		(minusd_op,enumType(p1,t1),fixedType(p2,0)) = enumType(p1,t1)
|	binop_type 		(minusd_op,timeType f1,intervalType f2) = timeType f1
|	binop_type 		(minusd_op,intervalType f1,intervalType f2) = 
					if f1 = f2
					then intervalType f1
					else raise wrongType
|	binop_type 		(minusd_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(times_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					fixedType(p1 max p2,s1 max s2)
| 	binop_type 		(times_op,floatingType(m1,e1,os1),floatingType(m2,e2,os2)) = 
					if m1 = m2 andalso e1 = e2 andalso os1 = os2 
					then floatingType(m1,e1,os1)
					else raise wrongType
|	binop_type 		(times_op,intervalType f,fixedType(p,s)) = intervalType f
|	binop_type 		(times_op,intervalType f,floatingType(m,e,os)) =  intervalType f
|	binop_type 		(times_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(divide_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					fixedType(p1 max p2,s1 max s2)
| 	binop_type 		(divide_op,floatingType(m1,e1,os1),floatingType(m2,e2,os2)) = 
					if m1 = m2 andalso e1 = e2 andalso os1 = os2 
					then floatingType(m1,e1,os1)
					else raise wrongType
|	binop_type 		(divide_op,intervalType f,fixedType(p,s)) = intervalType f
|	binop_type 		(divide_op,intervalType f,floatingType(m,e,os)) =  intervalType f
|	binop_type 		(divide_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(concat_op,stringType(min1,max1),stringType(min2,max2)) = 
					stringType(min1 + min2,max1 + max2)
|	binop_type		(concat_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(and_op,booleanType,booleanType) = booleanType
|	binop_type		(and_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(or_op,booleanType,booleanType) = booleanType
|	binop_type		(or_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(less_than_op,stringType(min1,max1),stringType(min2,max2)) = 
					booleanType
|	binop_type		(less_than_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					booleanType
| 	binop_type 		(less_than_op,floatingType(m1,e1,os1),floatingType(m2,e2,os2)) = 
					booleanType
|	binop_type 		(less_than_op,enumType(p1,t1),enumType(p2,t2)) = 
					if p1 = p2 andalso t1 = t2 
					then booleanType
					else raise wrongType
|	binop_type 		(less_than_op,timeType f1,timeType f2) = 
					booleanType
|	binop_type 		(less_than_op,intervalType f1,intervalType f2) = 
					booleanType
|	binop_type 		(less_than_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(less_or_equal_op,stringType(min1,max1),
					stringType(min2,max2)) = 
					booleanType
|	binop_type		(less_or_equal_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					booleanType
| 	binop_type 		(less_or_equal_op,floatingType(m1,e1,os1),
					floatingType(m2,e2,os2)) = 
					booleanType
|	binop_type 		(less_or_equal_op,enumType(p1,t1),enumType(p2,t2)) = 
					if p1 = p2 andalso t1 = t2 
					then booleanType
					else raise wrongType
|	binop_type 		(less_or_equal_op,timeType f1,timeType f2) = 
					booleanType
|	binop_type 		(less_or_equal_op,intervalType f1,intervalType f2) = 
					booleanType
|	binop_type 		(less_or_equal_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(greater_or_equal_op,stringType(min1,max1),
					stringType(min2,max2)) = 
					booleanType
|	binop_type		(greater_or_equal_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					booleanType
| 	binop_type 		(greater_or_equal_op,floatingType(m1,e1,os1),
					floatingType(m2,e2,os2)) = 
					booleanType
|	binop_type 		(greater_or_equal_op,enumType(p1,t1),enumType(p2,t2)) = 
					if p1 = p2 andalso t1 = t2 
					then booleanType
					else raise wrongType
|	binop_type 		(greater_or_equal_op,timeType f1,timeType f2) = 
					booleanType
|	binop_type 		(greater_or_equal_op,intervalType f1,intervalType f2) = 
					booleanType
|	binop_type 		(greater_or_equal_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(greater_than_op,stringType(min1,max1),
					stringType(min2,max2)) = 
					booleanType
|	binop_type		(greater_than_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					booleanType
| 	binop_type 		(greater_than_op,floatingType(m1,e1,os1),
					floatingType(m2,e2,os2)) = 
					booleanType
|	binop_type 		(greater_than_op,enumType(p1,t1),enumType(p2,t2)) = 
					if p1 = p2 andalso t1 = t2 
					then booleanType
					else raise wrongType
|	binop_type 		(greater_than_op,timeType f1,timeType f2) = 
					booleanType
|	binop_type 		(greater_than_op,intervalType f1,intervalType f2) = 
					booleanType
|	binop_type 		(greater_than_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(equal_op,nullType,t) = 			booleanType
|	binop_type		(equal_op,t,nullType) = 			booleanType
|	binop_type		(equal_op,booleanType,booleanType) = 	booleanType
|	binop_type		(equal_op,stringType(min1,max1),stringType(min2,max2)) = 
					booleanType
|	binop_type		(equal_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					booleanType
|	binop_type 		(equal_op,enumType(p1,t1),enumType(p2,t2)) = 
					if p1 = p2 andalso t1 = t2 
					then booleanType
					else raise wrongType
| 	binop_type 		(equal_op,floatingType(m1,e1,os1),floatingType(m2,e2,os2)) = 
					booleanType
|	binop_type 		(equal_op,timeType f1,timeType f2) = 		booleanType
|	binop_type 		(equal_op,intervalType f1,intervalType f2) = 	booleanType
|	binop_type 		(equal_op,classType,classType) = 			booleanType
|	binop_type 		(equal_op,codeType,codeType) = 			booleanType
|	binop_type 		(equal_op,anyType,anyType) =			booleanType
|	binop_type 		(equal_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(not_equal_op,nullType,t) = 			booleanType
|	binop_type		(not_equal_op,t,nullType) = 			booleanType
|	binop_type		(not_equal_op,booleanType,booleanType) = 	booleanType
|	binop_type		(not_equal_op,stringType(min1,max1),stringType(min2,max2)) = 
					booleanType
|	binop_type		(not_equal_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					booleanType
|	binop_type 		(not_equal_op,enumType(p1,t1),enumType(p2,t2)) = 
					if p1 = p2 andalso t1 = t2 
					then booleanType
					else raise wrongType
| 	binop_type 		(not_equal_op,floatingType(m1,e1,os1),
					floatingType(m2,e2,os2)) = 
					booleanType
|	binop_type 		(not_equal_op,timeType f1,timeType f2) = 		booleanType
|	binop_type 		(not_equal_op,intervalType f1,intervalType f2) = 	booleanType
|	binop_type 		(not_equal_op,classType,classType) = 		booleanType
|	binop_type 		(not_equal_op,codeType,codeType) = 		booleanType
|	binop_type 		(not_equal_op,anyType,anyType) =			booleanType
|	binop_type 		(not_equal_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type 		(lub_op,classType,classType) = classType
|	binop_type 		(lub_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type 		(glb_op,classType,classType) = classType
|	binop_type 		(glb_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type 		(dom_op,classType,classType) = booleanType
|	binop_type 		(dom_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type 		(dom_by_op,classType,classType) = booleanType
|	binop_type 		(dom_by_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(liked_op,stringType(min1,max1),stringType(min2,max2)) = 
					booleanType
|	binop_type 		(liked_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(maximum_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					fixedType(p1 max p2,s1 max s2)
|	binop_type 		(maximum_op,enumType(p1,t1),enumType(p2,t2)) = 
					if p1 = p2 andalso t1 = t2 
					then enumType(p1,t1)
					else raise wrongType
| 	binop_type 		(maximum_op,floatingType(m1,e1,os1),
					floatingType(m2,e2,os2)) = 
					if m1 = m2 andalso e1 = e2 andalso os1 = os2
					then floatingType(m1,e1,os1)
					else raise wrongType
|	binop_type 		(maximum_op,timeType f1,timeType f2) =
					if f1 = f2
					then timeType f1
					else raise wrongType
|	binop_type 		(maximum_op,intervalType f1,intervalType f2) =
					if f1 = f2
					then intervalType f1
					else raise wrongType
|	binop_type 		(maximum_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type		(minimum_op,fixedType(p1,s1),fixedType(p2,s2)) = 
					fixedType(p1 max p2,s1 max s2)
|	binop_type 		(minimum_op,enumType(p1,t1),enumType(p2,t2)) = 
					if p1 = p2 andalso t1 = t2 
					then enumType(p1,t1)
					else raise wrongType
| 	binop_type 		(minimum_op,floatingType(m1,e1,os1),
					floatingType(m2,e2,os2)) = 
					if m1 = m2 andalso e1 = e2 andalso os1 = os2
					then floatingType(m1,e1,os1)
					else raise wrongType
|	binop_type 		(minimum_op,timeType f1,timeType f2) =
					if f1 = f2
					then timeType f1
					else raise wrongType
|	binop_type 		(minimum_op,intervalType f1,intervalType f2) =
					if f1 = f2
					then intervalType f1
					else raise wrongType
|	binop_type 		(minimum_op,t1,t2) = raise wrongType
=TEX
=SML
|	binop_type 		(opr,t1,t2) = raise notDyadic;
=TEX
=SML
fun 	(Ûmonop_typeÝ : Op * SwordType -> SwordType) 
			(not_op,booleanType) =  booleanType
|	monop_type	(not_op,t) = raise wrongType
=TEX
=SML
|	monop_type	(definitely_op,booleanType) =  booleanType
|	monop_type	(definitely_op,t) = raise wrongType
=TEX
=SML
|	monop_type	(possibly_op,booleanType) =  booleanType
|	monop_type	(possibly_op,t) = raise wrongType
=TEX
=SML
|	monop_type	(minus_op,fixedType(p,s)) = fixedType(p,s)
|	monop_type	(minus_op,floatingType(m,e,os)) = floatingType(m,e,os)
|	monop_type	(minus_op,intervalType f) = intervalType f
|	monop_type	(minus_op,t) = raise wrongType
=TEX
=SML
|	monop_type	(ord_op,enumType(p,t)) = fixedType(p,0)
|	monop_type	(ord_op,stringType(mini,maxi)) = fixedType(1,0)
|	monop_type	(ord_op,t) = raise wrongType
=TEX
=SML
|	monop_type	(char_op,fixedType(p,s)) = stringType(1,1)
|	monop_type	(char_op,t) = raise wrongType
=TEX
=SML
|	monop_type	(upper_op,stringType(mini,maxi)) = stringType(mini,maxi)
|	monop_type	(upper_op,t) = raise wrongType
=TEX
=SML
|	monop_type	(lower_op,stringType(mini,maxi)) = stringType(mini,maxi)
|	monop_type	(lower_op,t) = raise wrongType
=TEX
=SML
|	monop_type	(opr,t) = raise notMonadic;
=TEX
=SML
fun 	(Ûtriop_typeÝ : Op * SwordType  * SwordType  * SwordType -> SwordType) 
			(liket_op,stringType(min1,max1),stringType(min2,max2),
							stringType(min3,max3)) =  booleanType
|	triop_type	(liket_op,t1,t2,t3) = raise wrongType
|	triop_type	(between_op,fixedType(p1,s1),fixedType(p2,s2),
							fixedType(p3,s3)) =  booleanType
|	triop_type	(between_op,floatingType(m1,e1,os1),floatingType(m2,e2,os2),
							floatingType(m3,e3,os3)) =  booleanType
|	triop_type	(between_op,stringType(min1,max1),stringType(min2,max2),
							stringType(min3,max3)) =  booleanType
|	triop_type	(between_op,enumType(p1,t1),enumType(p2,t2),enumType(p3,t3)) =
				if p1 = p2 andalso p2 = p3 andalso t1 = t2 andalso t2 = t3
				then booleanType
				else raise wrongType
|	triop_type	(between_op,timeType(f1),timeType(f2),
							timeType(f3)) = booleanType
|	triop_type	(between_op,intervalType(f1),intervalType(f2),
							intervalType(f3)) = booleanType
|	triop_type	(between_op,classType,classType,classType) = booleanType
|	triop_type	(between_op,t1,t2,t3) = raise wrongType
|	triop_type	(opr,t1,t2,t3) = raise notTriadic;
=TEX
=SML
fun 	(Ûset_func_typeÝ : Op * SwordType -> SwordType) 
				(plus_op,fixedType(p,s)) = fixedType(p,s)
| 	set_func_type 		(plus_op,floatingType(m,e,os)) =  floatingType(m,e,os)
|	set_func_type 		(plus_op,intervalType f) = intervalType f
|	set_func_type 		(plus_op,t) = raise wrongType
=TEX
=SML
|	set_func_type 		(concat_op,stringType (mini,maxi)) = stringType (mini,maxi)
|	set_func_type 		(concat_op,t) = raise wrongType
=TEX
=SML
|	set_func_type 		(and_op,booleanType) = booleanType
|	set_func_type 		(and_op,t) = raise wrongType
=TEX
=SML
|	set_func_type 		(or_op,booleanType) = booleanType
|	set_func_type 		(or_op,t) = raise wrongType
=TEX
=SML
|	set_func_type 		(lub_op,classType) = classType
|	set_func_type 		(lub_op,t) = raise wrongType
=TEX
=SML
|	set_func_type 		(glb_op,classType) = classType
|	set_func_type 		(glb_op,t) = raise wrongType
=TEX
=SML
|	set_func_type		(maximum_op,fixedType(p,s)) = fixedType(p,s)
| 	set_func_type 		(maximum_op,floatingType(m,e,os)) = floatingType(m,e,os)
|	set_func_type 		(maximum_op,enumType(p,t)) = enumType(p,t)
|	set_func_type 		(maximum_op,intervalType f) =
  intervalType f
|	set_func_type 		(maximum_op,timeType f) =
  timeType f
|	set_func_type 		(maximum_op,t) = raise wrongType
=TEX
=SML
|	set_func_type		(minimum_op,fixedType(p,s)) = fixedType(p,s)
| 	set_func_type 		(minimum_op,floatingType(m,e,os)) = floatingType(m,e,os)
|	set_func_type 		(minimum_op,enumType(p,t)) = enumType(p,t)
|	set_func_type 		(minimum_op,intervalType f) =
  intervalType f
|	set_func_type 		(minimum_op,timeType f) = timeType f
|	set_func_type 		(minimum_op,t) = raise wrongType
=TEX
=SML
|	set_func_type		(average_op,fixedType(p,s)) = fixedType(p,s)
| 	set_func_type 		(average_op,floatingType(m,e,os)) = floatingType(m,e,os)
|	set_func_type 		(average_op,intervalType f) =
  intervalType f
|	set_func_type 		(average_op,t) = raise wrongType;
=TEX	
=SML
fun 	(Ûcheck_booleanÝ : ExpType -> ExpType) (booleanType,w) = (booleanType,w)
|	check_boolean 		(t,w) = raise wrongType;
=TEX
=SML
fun 	(Ûcheck_type_conversionÝ : SwordType * SwordType -> unit)
				(nullType,t) = ()
|	check_type_conversion	(stringType(min1,max1),stringType(min2,max2)) = ()
|	check_type_conversion	(stringType(mini,maxi),fixedType(p,s)) = ()
|	check_type_conversion	(stringType(mini,maxi),floatingType(m,e,os)) = ()
|	check_type_conversion	(stringType(mini,maxi),timeType f) = ()
|	check_type_conversion	(stringType(mini,maxi),intervalType f) = ()
|	check_type_conversion	(stringType(mini,maxi),enumType(p,t)) = ()
|	check_type_conversion	(stringType(mini,maxi),codeType) = ()
=TEX
=SML
|	check_type_conversion	(fixedType(p,s),stringType(mini,maxi)) = ()
|	check_type_conversion	(fixedType(p1,s1),fixedType(p2,s2)) = ()
|	check_type_conversion	(fixedType(p,s),floatingType(m,e,os)) = ()
=TEX
=SML
|	check_type_conversion	(floatingType(m,e,os),stringType(mini,maxi)) = ()
|	check_type_conversion	(floatingType(m,e,os),fixedType(p,s)) = ()
|	check_type_conversion	(floatingType(m1,e1,os1),floatingType(m2,e2,os2)) = ()
=TEX
=SML
|	check_type_conversion	(timeType f,stringType(mini,maxi)) = ()
|	check_type_conversion	(intervalType f,stringType(mini,maxi)) = ()
=TEX
=SML
|	check_type_conversion	(enumType(p,t),stringType(mini,maxi)) = ()
=TEX
=SML
|	check_type_conversion	(timeType f1,timeType f2) = ()
=TEX
=SML
|	check_type_conversion	(intervalType f1,intervalType f2) = ()
=TEX
=SML
|	check_type_conversion	(codeType,stringType(mini,maxi)) = ()
=TEX
=SML
|	check_type_conversion	(anyType,t) = ()
|	check_type_conversion	(t,anyType) = ()
=TEX
=SML
|	check_type_conversion 	(t1,t2) = raise wrongType;
=TEX
=SML
fun 	(Ûcheck_type_conversionèdomainêÝ : SwordType * SwordType -> unit)
						(stringType(min1,max1),timeType f) = ()
|	check_type_conversionèdomainê		(stringType(min1,max1),classType) = ()
|	check_type_conversionèdomainê		(timeType f,stringType(min1,max1)) = ()
|	check_type_conversionèdomainê		(classType,stringType(min1,max1)) = ()
|	check_type_conversionèdomainê 		(t1,t2) = raise wrongType;
=TEX
=SML
fun 	(Ûconvertècol_specêÝ : Col_specèssqlê -> ColumnSpecification) 
				(denote_col_spec‰s col) = anonymous_column col
| 	convertècol_specê 	(absolute_col_spec‰s(dir,tab,col)) = 
					specific(absolute(dir,tab),col)
| 	convertècol_specê 	(default_col_spec‰s(up,dir,tab,col)) = 
					specific(default(up,dir,tab),col);
=TEX
=SML
fun 	(Ûclass_columnÝ : Col_specèssqlê-> (Col_specètsqlê,Class)Sum) cs = 
	case 	(lookupècol_spec_classê(true,convertècol_specê cs)) of 
		(local_identifier name, lub_cl) => inL(denote_col_spec‰t name)
	|	(column(gen_corr,gen_col), lub_cl) => 
						inL(absolute_col_spec‰t([],gen_corr,gen_col))
	|	(constant_class cl, lub_cl) => inR cl
	| 	(constant_null, lub_cl) => raise internalError;		
=TEX
=SML
fun 	(Ûdenote_nameÝ : TsqlRepr -> Valueètsqlê)
			(local_identifier s) = contents‰t(denote_col_spec‰t s)
| 	denote_name	(column(cn,col)) = contents‰t(absolute_col_spec‰t ([],cn,col))
| 	denote_name	(constant_class c) = denote_class‰t c
| 	denote_name	constant_null = denote_null‰t;
=TEX	
=SML
fun 	(Ûcolumn_data_testÝ : Col_specèssqlê -> Valueètsqlê list) cs =
		let	val (tr,u) = lookupècol_spec_classê(false,convertècol_specê cs) 
		in
		if 	client_clearance()  dom u
		then []
		else	let val cc = denote_class‰t(client_clearance())
			in	[binop‰t(dom_op,(cc,denote_name tr))]
			end
		end;
=TEX	
=SML
fun 	(Ûcol_expÝ : ExpType -> ColType) 
			(t,dinary) = (nullType,t)
|	col_exp		(t,sterling) = (t,nullType)
|	col_exp		(t,worthless) = (t,nullType)	
|	col_exp		(t,priceless) = raise wrongType;
=TEX	
=SML
fun 	(Ûcol_targetÝ : SsqlCol -> TsqlCol) sc =
	let 	fun 	(bound : BoundInfo -> TsqlClassName) (upb c) =  anonètcê
		| 	bound (constant c) = constantètcê c
		fun 	(target : ColType * TsqlClassName -> TsqlCol)
				((nullType,nullType),c) = raise internalError
		| 	target	((s,nullType),c) = 	{sterling_name = anon‰t,
							dinary_name = none‰t,
							class_name = c}
		| 	target 	((nullType,d),c) = 	{sterling_name = none‰t,
							dinary_name = anon‰t,
							class_name = c}
		| 	target 	((s,d),c) = 		{sterling_name = anon‰t,
							dinary_name = anon‰t,
							class_name = c}
	in 	target(#type_field sc,bound(#col_class sc))
	end;
=TEX
=SML
fun 	(Ûconvertètable_specêÝ : Table_specèssqlê -> TableSpecification) 
				(absolute_table_spec‰s(dir,tab)) = absolute(dir,tab)
| 	convertètable_specê 	(default_table_spec‰s(up,dir,tab)) = default(up,dir,tab);
=TEX
=SML
fun 	(Ûconstant_valueètypeêÝ : Constant_valueèssqlê -> SwordType) 
				denote_null‰s = nullType
| 	constant_valueètypeê	denote_void‰s = monoleanType
| 	constant_valueètypeê	denote_true‰s = booleanType
| 	constant_valueètypeê	denote_false‰s = booleanType
| 	constant_valueètypeê	(denote_string‰s(s,string_type‰s(mini,maxi))) = 
					(if mini <= size s andalso size s <= maxi
					then stringType(mini,maxi)
					else raise wrongType)
| 	constant_valueètypeê	(denote_fixed‰s(f,fixed_type‰s(p,s))) = 
					(if check_fixed(f,p,s)
					then fixedType(p,s)
					else raise wrongType)
| 	constant_valueètypeê	(denote_floating‰s(f,floating_type‰s(m,e,os))) = 
					(if check_floating(f,m,e,os)
					then floatingType(m,e,os)
					else raise wrongType)
| 	constant_valueètypeê	(denote_enum‰s(e,enum_type‰s(p,t))) = 
					(if check_enum(e,p,t)
					then enumType(p,convertètable_specê t)
					else raise wrongType)
| 	constant_valueètypeê	(denote_time‰s(tm,time_type‰s f)) = 
					(if check_time(tm,f)
					then timeType f
					else raise wrongType)
| 	constant_valueètypeê	(denote_interval‰s(i,interval_type‰s f)) = 
					(if check_interval(i,f)
					then intervalType f
					else raise wrongType)
| 	constant_valueètypeê	(denote_class‰s c) = classType
| 	constant_valueètypeê	(denote_code‰s c) = codeType
| 	constant_valueètypeê	other = raise wrongType;
=TEX
=SML
fun 	(Ûconvertèssql_typeêÝ : Typeèssqlê -> SwordType)
	 			monolean_type‰s = monoleanType
|	convertèssql_typeê 	boolean_type‰s = booleanType
|	convertèssql_typeê 	(string_type‰s(mini,maxi)) = stringType(mini,maxi)
|	convertèssql_typeê 	(fixed_type‰s(p,s)) = fixedType(p,s)
|	convertèssql_typeê 	(floating_type‰s(m,e,os)) = floatingType(m,e,os)
|	convertèssql_typeê 	(enum_type‰s(p,t)) = enumType(p,convertètable_specê(t))
|	convertèssql_typeê 	(time_type‰s f) = timeType f
|	convertèssql_typeê 	(interval_type‰s f) = intervalType f
|	convertèssql_typeê 	class_type‰s = classType
|	convertèssql_typeê 	code_type‰s = codeType
|	convertèssql_typeê 	any_type‰s = anyType;
=TEX
=SML
fun 	(ÛconvertètableSpecificationêÝ :TableSpecification -> Table_specètsqlê)
				(absolute(directory,table)) = absolute_table_spec‰t(directory,table)
|	convertètableSpecificationê	(default(up,directory,table)) = 
		let 	fun 	(backUp : string list * int -> string list)(dir,0) = dir
			|	backUp (dir,n) = if n > 0 andalso length dir > 0
						then backUp(rev(tl(rev dir)),n - 1)
						else raise noSuchDirectory
			val 	dir = backUp(default_directory(),up) @ directory 
		in	absolute_table_spec‰t(dir,table)
		end;
=TEX
=SML
local	 fun	(dot : string -> string) s = s ^ "."
in
fun 	(Ûtable_nameÝ : TableSpecification -> string)
			(absolute([],tab)) = tab
|	table_name	(absolute(dir,tab)) = (fold  (op ^)(map dot dir)) ^ tab
|	table_name 	(default(up,[],tab)) =  implode(seq(up,"-")) ^ tab
|	table_name 	(default(up,dir,tab)) =  implode(seq(up,"-")) 
					^ (fold  (op ^)(map dot dir)) ^ tab
end;
=TEX
=SML
fun 	(Ûconvertèsword_typeêÝ : SwordType -> Typeètsqlê)
				nullType = raise internalError
|	convertèsword_typeê	monoleanType = monolean_type‰t
|	convertèsword_typeê 	booleanType = boolean_type‰t 
|	convertèsword_typeê 	(stringType(mini,maxi)) = string_type‰t(mini,maxi)
|	convertèsword_typeê 	(fixedType(p,s)) = fixed_type‰t(p,s)
|	convertèsword_typeê 	(floatingType(m,e,os)) = floating_type‰t(m,e,os)
|	convertèsword_typeê 	(enumType(p,t)) = enum_type‰t(p,table_name t)
|	convertèsword_typeê 	(timeType f) = time_type‰t f
|	convertèsword_typeê 	(intervalType f) = interval_type‰t f
|	convertèsword_typeê 	classType = class_type‰t 
|	convertèsword_typeê 	codeType = code_type‰t 
|	convertèsword_typeê 	anyType = any_type‰t;
=TEX
=SML
fun 	(ÛconvertètypeêÝ : Typeèssqlê -> Typeètsqlê) t = convertèsword_typeê(convertèssql_typeê(t));
=TEX
=SML
fun 	(Ûdenoteèclass_expêÝ : ExpClass -> Valueètsqlê) 
				(variable(v,c)) = v
|	denoteèclass_expê		(constantèecê c) = denote_class‰t c;
=TEX
=SML
fun 	(Ûlubèbound_infoêÝ : BoundInfo * BoundInfo -> BoundInfo)
				(upb c1,upb c2) = upb(c1 lub c2)
|	lubèbound_infoê		(constant c1,upb c2) = upb(c1 lub c2)
|	lubèbound_infoê		(upb c1,constant c2) = upb(c1 lub c2)
|	lubèbound_infoê		(constant c1,constant c2) =	if c1 = c2 then constant c1
								else upb(c1 lub c2);
=TEX
=SML
fun 	(Ûlubèexp_classêÝ : ExpClass * ExpClass -> ExpClass)
				(variable(v1,c1),constantèecê c2) =
					variable(binop‰t(lub_op,(v1,denote_class‰t c2)),c1 lub c2)
|	lubèexp_classê 		(constantèecê c1,constantèecê c2) =
					constantèecê(c1 lub c2)
|	lubèexp_classê 		(constantèecê c1,variable(v2,c2)) =
					variable(binop‰t(lub_op,(v2,denote_class‰t c1)),c1 lub c2)
|	lubèexp_classê 		(variable(v1,c1),variable(v2,c2)) =
					variable(binop‰t(lub_op,(v1,v2)),c1 lub c2);
=TEX
=SML
fun 	(ÛlubètypeêÝ : SwordType * SwordType -> SwordType)(t1,t2) = 	
	if t1 = t2 
	then t1
	else 	case(t1,t2) of
			(stringType(min1,max1),stringType(min2,max2)) => 
				stringType(min1 min min2,max1 max max2)
		|	(fixedType(p1,s1),fixedType(p2,s2)) => 
				fixedType(p1 max p2,s1 max s2)
		|	 _ => raise wrongType;
=TEX
=SML
fun 	(Ûlubècol_typeêÝ : ColType * ColType -> ColType)
			((s1,d1),(s2,d2)) = (lubètypeê(s1,s2),lubètypeê(d1,d2));

=TEX
The exception $designError$ is raised in the following definition. Without the last clause, pattern matching is 
not exhaustive, although the case of $(dinary,dinary)$, say, 
is caught by the $if$.
=SML
exception designError of string;
fun 	(ÛlubèworthêÝ : Worth * Worth -> Worth)(w1,w2) = 
	if w1 = w2 
	then w1
	else 	case(w1,w2) of
			(w1,worthless) => w1
		|	(worthless,w2) => w2
		|	(priceless,w2) => priceless
		|	(w1,priceless) => priceless
		|	(dinary,sterling) => priceless
		|	(sterling,dinary) => priceless
		|	_ => raise designError "lubèworthê";
=TEX
=SML
fun 	(ÛlubèexpêÝ : ExpType * ExpType -> ExpType)
			((t1,w1),(t2,w2)) = (lubètypeê(t1,t2),lubèworthê(w1,w2));
=TEX
=SML
fun 	(Ûlubèssql_nameêÝ : SsqlName * SsqlName -> SsqlName)
			(name‰s s1,name‰s s2) = 	if s1 = s2 then name‰s s1
							else anon‰s
|	lubèssql_nameê	(sn1,sn2) = anon‰s;
=TEX
=SML
fun 	(Ûlubèssql_colêÝ : SsqlCol * SsqlCol -> SsqlCol)
	({name = n1,type_field = t1,col_exist = ce1,col_class = cc1},
		{name = n2,type_field = t2,col_exist = ce2,col_class = cc2}) 
		=  
		{name = lubèssql_nameê(n1,n2),
		type_field = lubècol_typeê(t1,t2),
		col_exist = ce1 lub ce2,
		col_class = lubèbound_infoê(cc1,cc2)};
=TEX
=SML
fun 	(Ûlubètable_infoêÝ : TableInfo * TableInfo -> TableInfo)
	({table_exist_class = tec1,table_class = tc1,row_class = rc1},
		{table_exist_class = tec2,table_class = tc2,row_class = rc2}) 
		=  
		{table_exist_class = tec1 lub tec2,
		table_class = tc1 lub tc2,
		row_class = lubèbound_infoê(rc1,rc2)};
=TEX
=SML
fun 	(Ûlubètsql_class_nameêÝ : TsqlClassName * TsqlClassName -> TsqlClassName)
				(nameètcê s1,nameètcê s2) = 	if s1 = s2 then nameètcê s1
								else anonètcê
|	lubètsql_class_nameê	(constantètcê c1,constantètcê c2) = 	if c1 = c2 then constantètcê c1
									else anonètcê
|	lubètsql_class_nameê	(x,y) = anonètcê;
=TEX
=SML
fun 	(Ûlubètsql_nameêÝ : TsqlName * TsqlName -> TsqlName)
			(name‰t s1,name‰t s2) =	if s1 = s2 then name‰t s1
							else anon‰t
|	lubètsql_nameê	(none‰t,none‰t) = none‰t
|	lubètsql_nameê	(tn1,tn2) = anon‰t;
=TEX			
=SML
fun 	(Ûlubètsql_colêÝ : TsqlCol * TsqlCol -> TsqlCol)
	({sterling_name = s1,dinary_name= d1,class_name = c1},
		{sterling_name = s2,dinary_name= d2,class_name = c2}) 
		=  
		{sterling_name = lubètsql_nameê(s1,s2),
		dinary_name = lubètsql_nameê(d1,d2),
		class_name = lubètsql_class_nameê(c1,c2)};
=TEX
=SML
local	fun	(data_col : TsqlName * TsqlName -> Select_valueètsqlê list)
				(none‰t,none‰t) = []
	|	data_col	(name‰t s,anon‰t) = 
						[anonymous_value‰t(contents‰t(denote_col_spec‰t s))]
	|	data_col	(name‰t fs,name‰t ts) = 
						[anonymous_value‰t(contents‰t(denote_col_spec‰t fs))]
	|	data_col	(none‰t,anon‰t) = [anonymous_value‰t(denote_null‰t)]
	|	data_col	(anon‰t,none‰t) = [anonymous_value‰t(denote_null‰t)]
	|	data_col	(n1,n2) = raise internalError
	fun	(class_col : TsqlClassName * TsqlClassName -> Select_valueètsqlê list)
				(constantètcê fc,constantètcê tc) =	if fc = tc then []
								else raise internalError
	|	class_col	(nameètcê f,nameètcê tn) =
						[anonymous_value‰t(contents‰t(denote_col_spec‰t f))]
	|	class_col	(constantètcê fc,nameètcê tn) =
						[anonymous_value‰t(denote_class‰t fc)]
	|	class_col	(nameètcê f,anonètcê) =
						[anonymous_value‰t(contents‰t(denote_col_spec‰t f))]
	|	class_col	(constantètcê fc,anonètcê) =
						[anonymous_value‰t(denote_class‰t fc)]
	|	class_col	(c1,c2) = raise internalError
in
fun 	(ÛmakeèsvêÝ : TsqlCol * TsqlCol -> Select_valueètsqlê list)(f,t) =
		data_col(#sterling_name f,#sterling_name t) @
		data_col(#dinary_name f,#dinary_name t) @
		class_col(#class_name f,#class_name t)
end;
=TEX
=SML
fun 	(Ûremove_constantsÝ : (Col_specètsqlê,Class)Sum list -> Col_specètsqlê list) [] = []
|	remove_constants ((inL c) :: s) = c :: (remove_constants s)
|	remove_constants ((inR c) :: s) = remove_constants s;
=TEX
=SML
fun 	(Ûremove_nullsÝ : TsqlRepr list -> TsqlRepr list) [] = []
|	remove_nulls (constant_null :: trs) = remove_nulls trs
|	remove_nulls (x :: trs) = x :: (remove_nulls trs);
=TEX
=SML
fun 	(ÛupperÝ : ExpClass -> Class)
		(variable(c,u)) = u
|	upper	(constantèecê u) = u;
=TEX
=SML
local	fun	(make_case : Valueètsqlê * ExpClass -> Valueètsqlê)
			(data,variable(c,u)) = case‰t(	[data], 
							[denote_class‰t(lattice_top())],
							c)
	|	make_case(data,constantèecê c) = case‰t(	[data], 
								[denote_class‰t(lattice_top())],
								denote_class‰t c)
in		
fun 	(ÛsimplifyèandsêÝ : Valueètsqlê list * ExpClass list -> Valueètsqlê * ExpClass)
	(vs,cs) =	
		let	val v = fold(curry binop‰t and_op)vs
			val c = case‰t(	[v],
					[fold(curry binop‰t lub_op)(map denoteèclass_expê cs)],
					fold(curry binop‰t glb_op)(at2 (map make_case) (vs,cs)))
			val u = fold (op lub)(map upper cs)
		in 	(v,variable(c,u))
		end
end;
=TEX
=SML
local	fun	(make_case : Valueètsqlê * ExpClass -> Valueètsqlê)
			(data,variable(c,u)) = case‰t(	[data], 
							[denote_class‰t(lattice_top())],
							c)
	|	make_case(data,constantèecê c) = case‰t(	[data], 
								[denote_class‰t(lattice_top())],
								denote_class‰t c)
in		
fun 	(ÛsimplifyèorsêÝ : Valueètsqlê list * ExpClass list -> Valueètsqlê * ExpClass)
	(vs,cs) =	
		let	val v = fold(curry binop‰t and_op)vs
			val c = case‰t(	[v],
					[fold(curry binop‰t glb_op)(at2 (map make_case) (vs,cs))],
					fold(curry binop‰t lub_op)(map denoteèclass_expê cs))
			val u = fold (op lub)(map upper cs)
		in 	(v,variable(c,u))
		end
end;
=TEX
=SML
fun 	(Ûconstant_valueèdataêÝ : Constant_valueèssqlê -> Valueètsqlê)
				denote_null‰s = denote_null‰t
|	constant_valueèdataê 	denote_void‰s = denote_void‰t
|	constant_valueèdataê 	denote_true‰s = denote_true‰t
|	constant_valueèdataê 	denote_false‰s = denote_false‰t
|	constant_valueèdataê 	(denote_string‰s (s,t)) = 
								denote_string‰t (s,convertètypeê t)
|	constant_valueèdataê	(denote_fixed‰s (f,t)) = 
								denote_fixed‰t (f,convertètypeê t)
|	constant_valueèdataê	(denote_floating‰s (f,t)) = 
								denote_floating‰t (f,convertètypeê t)
|	constant_valueèdataê	(denote_enum‰s (e,t)) = 
								denote_enum‰t (e,convertètypeê t)
|	constant_valueèdataê	(denote_time‰s (tm,t)) = 
								denote_time‰t (tm,convertètypeê t)
|	constant_valueèdataê	(denote_interval‰s (i,t)) = 
								denote_interval‰t (i,convertètypeê t)
|	constant_valueèdataê	(denote_class‰s c) = denote_class‰t c
|	constant_valueèdataê	(denote_code‰s c) = denote_code‰t c;
=TEX
=SML
local	fun 	(look : Col_specèssqlê -> TsqlRepr)
			cs = lookupècol_spec_dinaryê(false,convertècol_specê cs)
in
fun 	(Ûdinary_columnsÝ : Col_specèssqlê list -> Col_specètsqlê list)
		css = map repr_col (remove_nulls(map look css))
end;
=TEX
=SML
local	fun 	(look : Col_specèssqlê -> TsqlRepr)
			cs = lookupècol_spec_sterlingê(false,convertècol_specê cs)
in
fun 	(Ûsterling_columnsÝ : Col_specèssqlê list -> Col_specètsqlê list)
		css = map repr_col (remove_nulls(map look css))
end;
=TEX
=SML
fun 	(Ûtuple_listèmax_row_classêÝ : Tuple_listèssqlê -> ExpClass) 
			t = constantèecê(client_clearance());
=TEX
=SML			
fun 	(Ûupb_row_classÝ : TableInfo -> Class)
			{table_exist_class=tec,table_class=tc,row_class=upb rc} = rc
|	upb_row_class	{table_exist_class=tec,table_class=tc,row_class=constant rc} = rc;
=TEX
In the following, the specifications of $internal\_valueèclassê$  and 
$value\_type$  are incomplete. ($all\_binop$, 
$some\_binop$, $all\_binop\_list$ and $some\_binop\_list$ 
are missing from $internal\_valueèclassê$ and $caseVal$ is 
missing from $value\_type$.)

=SML
fun 	(ÛvalueèdataêÝ : Valueèssqlê -> Valueètsqlê)
			(denote_constant‰s  c) = constant_valueèdataê c
=TEX
=SML
|	valueèdataê	(monop‰s (opr,v)) = monop‰t (opr,valueèdataê v)
|	valueèdataê	(binop‰s (opr,(v1,v2))) = binop‰t (opr,(valueèdataê v1,valueèdataê v2))
|	valueèdataê	(triop‰s (opr,(v1,v2,v3))) = triop‰t (opr,(valueèdataê v1,
								valueèdataê v2,valueèdataê v3))
=TEX
=SML
|	valueèdataê	(convert‰s (v,t)) = convert‰t (valueèdataê v,convertètypeê t)
|	valueèdataê	(convert_domain‰s (v,domain,t)) =
			let 	val ts = convertètable_specê domain
				val tn = table_name ts
			in convert_domain‰t (tn,(valueèdataê v,convertètypeê t))
			end
=TEX
=SML
|	valueèdataê	(make_sterling‰s v) = valueèdataê v
| 	valueèdataê	(make_dinary‰s v) = valueèdataê v
=TEX
=SML
|	valueèdataê	(declare‰s (id,(v1,v2))) =
			in_new_scope(fn () =>
			let 	val t1 = valueètypeê v1
				val data1 = valueèdataê v1
				val class1 = valueèclassê v1
				val data2 = valueèdataê v2
			in	case class1 of
					variable (c,u) => 
					let	val (cn,dn) = enterèidentifierê(id,t1,u)
					in	declare‰t (cn,(c,declare‰t(dn,(data1,data2)))) 
					end
				| 	constantèecê c =>
					let	val dn =  enterèidentifier_constant_classê(id,t1,c)
					in declare‰t(dn,(data1,data2)) 
					end
			end)
=TEX
=SML
| 	valueèdataê	(caseVal‰s (test,caseList,valList,elseVal)) = caseVal‰t(valueèdataê test,
									map valueèdataê caseList,
									map valueèdataê valList,
									valueèdataê elseVal)
| 	valueèdataê	(case‰s (caseList,valList,elseVal)) = case‰t(map valueèdataê caseList,
									map valueèdataê valList,
									valueèdataê elseVal)
=TEX
=SML
|	valueèdataê	(set_func_all‰s (opr,v)) = set_func_all‰t (opr,valueèdataê v)
|	valueèdataê	(set_func_distinct‰s (opr,v)) = set_func_distinct‰t (opr,valueèdataê v)
|	valueèdataê	(count_non_null‰s (v,t)) = count_non_null‰t (valueèdataê v,convertètypeê t)
|	valueèdataê	(count_distinct‰s (v,t)) = count_distinct‰t (valueèdataê v,convertètypeê t)
|	valueèdataê	(count_all‰s t) = count_all‰t (convertètypeê t)
=TEX
=SML
|	valueèdataê	(all_binop‰s (opr,(v,vs))) = all_binop‰t (opr,(valueèdataê v,tuple_listèdataê vs))
|	valueèdataê	(some_binop‰s (opr,(v,vs))) = 
					some_binop‰t (opr,(valueèdataê v,tuple_listèdataê vs))
|	valueèdataê	(all_binop_list‰s (opr,(v,vs))) = 
					all_binop_list‰t (opr,(valueèdataê v,map valueèdataê vs))
|	valueèdataê	(some_binop_list‰s (opr,(v,vs))) = 
					some_binop_list‰t (opr,(valueèdataê v,map valueèdataê  vs))
|	valueèdataê	(exists_tuples‰s tuples) = exists_tuples‰t (tuple_listèdataê tuples)
|	valueèdataê	(single_value‰s v) = single_value‰t (tuple_listèdataê v)
=TEX
=SML
|	valueèdataê	(contents‰s cs) = 
				(case lookupècol_spec_sterlingê(false,convertècol_specê cs) of
					constant_null => denote_null‰t
				|	tr => contents‰t(repr_col tr))
|	valueèdataê	(sterling_contents‰s cs) = 
				(case lookupècol_spec_sterlingê(false,convertècol_specê cs) of
					constant_null => denote_null‰t
				|	tr => contents‰t(repr_col tr))
|	valueèdataê	(dinary_contents‰s cs) = 
				(case lookupècol_spec_dinaryê(false,convertècol_specê cs) of
					constant_null => denote_null‰t
				|	tr => contents‰t(repr_col tr))
=TEX
=SML
|	valueèdataê	(classification‰s col) = 	let val 	cs = class_column col
							in 	if isL cs then (contents‰t(getL cs))
								else denote_class‰t (getR cs)
							end

=TEX
=SML
|	valueèdataê	(row_existence‰s t) = 	
				let 	val	ts = convertètable_specê t
 					val	rc = lookupètable_row_classê(false,ts)
				in  denote_name rc
				end
=TEX
=SML
|	valueèdataê	joined_row_existence‰s = 	
				let val 	ns = lookupèlocal_row_classesê()
				in (fold(curry binop‰t lub_op)(map denote_name ns))
				end
=TEX
=SML
|	valueèdataê	(classify‰s(v,c)) = valueèdataê v
|	valueèdataê	(classify_default‰s v) = valueèdataê v
=TEX
=SML
|	valueèdataê	(observed‰s(n,c)) = raise notTrigger
|	valueèdataê	(modified‰s n) = raise notTrigger
=TEX
=SML
|	valueèdataê	(context‰s s) = 	let val  (cv,class) = contextual_data s
						in	constant_valueèdataê cv 
						end
|	valueèdataê	(parameter‰s name) = 	let val  (cv,class) = lookupèparam_dataê name
							in	constant_valueèdataê cv 
							end
=TEX
=SML
and 	(ÛvalueètypeêÝ : Valueèssqlê -> ExpType)
			(denote_constant‰s c) = (constant_valueètypeê c,worthless)
=TEX
=SML
|	valueètypeê	(monop‰s (opr,v)) = 	let val (t,w) = valueètypeê v
						in (monop_type(opr,t),w)
						end
=TEX
=SML
|	valueètypeê	(binop‰s (opr,(v1,v2))) = 	let 	val (t1,w1) = valueètypeê v1
								val (t2,w2) = valueètypeê v2
							in (binop_type (opr,t1,t2),lubèworthê(w1,w2))
							end
=TEX
=SML
|	valueètypeê	(triop‰s (opr,(v1,v2,v3))) = 
				let 	val (t1,w1) = valueètypeê v1
					val (t2,w2) = valueètypeê v2
					val (t3,w3) = valueètypeê v3
				in (triop_type (opr,t1,t2,t3),lubèworthê(w1,lubèworthê(w2,w3)))
				end
=TEX
=SML
|	valueètypeê	(convert‰s (v,t)) = 	let 	val st = convertèssql_typeê t
							val (ty,w) = valueètypeê v
							val ok = check_type_conversionèdomainê(ty,st)
						in (st,w)
						end
=TEX
=SML
|	valueètypeê	(convert_domain‰s (v,domain,t)) =
						let 	val st = convertèssql_typeê t
							val (ty,w) = valueètypeê v
							val ok = check_type_conversionèdomainê(ty,st)
						in (st,w)
						end
=TEX
=SML
|	valueètypeê	(make_sterling‰s v) = 	let val (t,w) = valueètypeê v
						in (t,sterling)
						end
=TEX
=SML
|	valueètypeê	(make_dinary‰s v) = 	let val (t,w) = valueètypeê v
						in (t,dinary)
						end
=TEX
=SML
|	valueètypeê	(declare‰s (id,(v1,v2))) = 	
					let	val et = valueètypeê v1
						val cl = lattice_top()
					in
					in_new_scope(fn () => 
						let val i = enterèidentifier_constant_classê(id,et,cl)
						in valueètypeê v2 
						end)
					end
=TEX
=SML		
|	valueètypeê	(case‰s (caseList,valList,elseVal)) = 
				let	val  ok =  map check_boolean(map valueètypeê caseList)
				in 	fold lubèexpê(map valueètypeê (valList @ [elseVal]))
				end
=TEX
=SML
|	valueètypeê	(set_func_all‰s(opr,v)) = 	let val (t,w) = valueètypeê v
							in 
							(set_func_type(opr,t),w)
							end
|	valueètypeê	(set_func_distinct‰s(opr,v)) = 	let val (t,w) = valueètypeê v
								in 
								(set_func_type(opr,t),w)
								end
=TEX
=SML
|	valueètypeê	(count_non_null‰s(v,t))	=	
					let 	val st = convertèssql_typeê t
						val (t,w) = valueètypeê v
					in 	case st of
							fixedType(p,s) => (st,worthless)
						| 	other => raise wrongType
					end
|	valueètypeê	(count_distinct‰s(v,t))	=	
					let 	val st = convertèssql_typeê t
						val (t,w) = valueètypeê v
					in 	case st of
							fixedType(p,s) => (st,worthless)
						| 	other => raise wrongType
					end
=TEX
=SML
|	valueètypeê	(count_all‰s t)	=	let 	val st = convertèssql_typeê t
						in 	case st of
								fixedType(p,s) => (st,worthless)
							| 	other => raise wrongType
						end
=TEX
=SML						
|	valueètypeê	(all_binop‰s (opr,(v,vs))) =	
			let 	val tt = tuple_listètypeê vs
			in 	if length tt <> 1 then raise tooWide
				else	let	val (t1,w1) = valueètypeê v
						val (t2,w2) = hd tt
					in (binop_type(opr,t1,t2),lubèworthê(w1,w2))
					end
			end
					
|	valueètypeê	(some_binop‰s (opr,(v,vs))) =	
			let 	val tt = tuple_listètypeê vs
			in 	if length tt <> 1 then raise tooWide
				else	let	val (t1,w1) = valueètypeê v
						val (t2,w2) = hd tt
					in (binop_type(opr,t1,t2),lubèworthê(w1,w2))
					end
			end
=TEX
=SML	
|	valueètypeê	(all_binop_list‰s (opr,(v,vs))) =
			let	fun (binop_exp : Op * ExpType * ExpType -> ExpType)
					(opr,(t1,w1),(t2,w2)) = 
						(binop_type(opr,t1,t2),lubèworthê(w1,w2))
				val ets2 = map valueètypeê vs
				val ets1 = seq(length ets2,valueètypeê v)
			in fold lubèexpê (at3(map binop_exp) (seq(length ets2,opr),ets1,ets2))
			end
|	valueètypeê	(some_binop_list‰s (opr,(v,vs))) =
			let	fun (binop_exp : Op * ExpType * ExpType -> ExpType)
					(opr,(t1,w1),(t2,w2)) = 
						(binop_type(opr,t1,t2),lubèworthê(w1,w2))
				val ets2 = map valueètypeê vs
				val ets1 = seq(length ets2,valueètypeê v)
			in fold lubèexpê (at3(map binop_exp) (seq(length ets2,opr),ets1,ets2))
			end
=TEX
=SML	
|	valueètypeê	(exists_tuples‰s tuples) =
			let	val tt = tuple_listètypeê tuples
			in 	(booleanType,worthless)
			end
=TEX
=SML	
|	valueètypeê	(single_value‰s tuples) =
			let	val tt = tuple_listètypeê tuples
			in 	if length tt <> 1 then raise tooWide
				else	hd tt
			end
=TEX
=SML	
|	valueètypeê	(contents‰s cs) =
			let	val (ti,sc) = lookupècolumn_infoê (convertècol_specê cs)
			in 	(case (#type_field sc) of
					(nullType,nullType) => (nullType,sterling)
				|	(st,nullType) => (st,sterling)
				|	(nullType,dt) => (dt,dinary)
				|	(st,dt) => (st,sterling))
			end
=TEX
=SML	
|	valueètypeê	(sterling_contents‰s cs) =
			let	val (ti,sc) = lookupècolumn_infoê (convertècol_specê cs)
			in 	(case (#type_field sc) of
					(nullType,nullType) => (nullType,sterling)
				|	(st,nullType) => (st,sterling)
				|	(nullType,dt) => raise wrongWorth
				|	(st,dt) => (st,sterling))
			end
=TEX
=SML	
|	valueètypeê	(dinary_contents‰s cs) =
			let	val (ti,sc) = lookupècolumn_infoê (convertècol_specê cs)
			in 	(case (#type_field sc) of
					(nullType,nullType) => (nullType,dinary)
				|	(st,nullType) => raise wrongWorth
				|	(nullType,dt) => (dt,dinary)
				|	(st,dt) => (dt,dinary))
			end
=TEX
=SML
|	valueètypeê	(classification‰s col) = (classType,worthless)
|	valueètypeê	(row_existence‰s t) = (classType,worthless)
|	valueètypeê	joined_row_existence‰s = (classType,worthless)	
|	valueètypeê	(classify‰s(v,c)) = 	(case valueètypeê c of
							(classType,w) => valueètypeê v
						|	(other,w) => raise wrongType)
|	valueètypeê	(classify_default‰s v) = valueètypeê v
|	valueètypeê	(observed‰s(n,c)) = raise onlyInTriggers
|	valueètypeê	(modified‰s n) = raise onlyInTriggers
|	valueètypeê	(context‰s s) = 	let val  (cv,class) = contextual_data s
						in	(constant_valueètypeê cv,worthless) 
						end
|	valueètypeê	(parameter‰s name) = 	let val  (cv,class) = lookupèparam_dataê name
							in	(constant_valueètypeê cv,worthless) 
							end
=TEX
=SML
and 	(ÛvalueèclassêÝ : Valueèssqlê -> ExpClass)
		v = case internal_valueèclassê v of
			ands(datas,classes) => 	let val (v,c) = simplifyèandsê(datas,classes)
						in c
						end
			| ors(datas,classes) => let val (v,c) = simplifyèorsê(datas,classes)
						in c
						end
			| simple(variable(exp,up)) => variable(exp,up)
			| simple(constantèecê c) => constantèecê c
=TEX
=SML
and 	(Ûtuple_listèdataêÝ : Tuple_listèssqlê -> Tuple_listètsqlê)
			(table_contents‰s t) = in_new_scope(fn () =>
			let	val ts = convertètable_specê t
				val tn = convertètableSpecificationê ts
				val (ti,ci,scs,rc,tcs) = getètable_infoê ts
				fun (sel: TsqlCol -> Select_valueètsqlê)
					{sterling_name = name‰t n,
					dinary_name=dn,
					class_name=cn}
					= anonymous_value‰t(contents‰t(denote_col_spec‰t n))
				| sel	x = raise internalError
			in	all_tuples‰t(select_values‰t(map sel tcs),
					[from‰t(table_contents‰t tn)],denote_true‰t,[],denote_true‰t)
			end)
=TEX
=SML
|	tuple_listèdataê 	(all_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fss = map from_specèenterê fr
				val gs = sterling_columns gb_sterling
				val gd = dinary_columns gb_dinary
				val gc = map class_column gb_class
			in all_tuples‰t(select_listèdataê sel,
					fss,valueèdataê where,gs @ gd @ remove_constants gc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèdataê 	(distinct_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fss = map from_specèenterê fr
				val gs = sterling_columns gb_sterling
				val gd = dinary_columns gb_dinary
				val gc = map class_column gb_class
			in distinct_tuples‰t(select_listèdataê sel,
					fss,valueèdataê where,gs @ gd @ remove_constants gc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèdataê 	(evaluate‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fss = map from_specèenterê fr
				val gs = sterling_columns gb_sterling
				val gd = dinary_columns gb_dinary
				val gc = map class_column gb_class
			in evaluate‰t(select_listèdataê sel,
					fss,valueèdataê where,gs @ gd @ remove_constants gc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèdataê 	(tuple‰s vals) = 
				tuple‰t(map valueèdataê vals)
=TEX
=SML
|	tuple_listèdataê 	(union‰s tls) = 
				union‰t(map tuple_listèdataê tls)
=TEX
=SML
|	tuple_listèdataê 	(name_columns‰s(names,tul)) 
						= tuple_listèdataê tul
=TEX
=SML
and 	(Ûtuple_listètypeêÝ : Tuple_listèssqlê -> ExpType list) 
				(table_contents‰s ts) =
					let	fun (col_info : TableInfo * ConstraintInfo * 
							SsqlCol list * TsqlClassName * TsqlCol list 
									-> SsqlCol list)
							(ti,ci,scs,rc,tcs) = scs
						fun (t:SsqlCol -> ColType)
							c = #type_field c
						fun (f:ColType -> ExpType)
							    (nullType,nullType) = raise internalError
							| f (st,nullType) = (st,sterling)
							| f (nullType,dt) = raise internalError
							| f (st,dt) = (st,sterling)
					in map f(map t(col_info(getètable_infoê(convertètable_specê ts))))
					end
=TEX
=SML
|	tuple_listètypeê	(all_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
				= 	in_new_scope(fn () =>
					let	val fs = map from_specèenterê fr
						val where_ok = check_boolean(valueètypeê where)
						val having_ok  = check_boolean(valueètypeê having)
					in select_listètypeê sel
					end)
=TEX
=SML
|	tuple_listètypeê	(distinct_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
				= 	in_new_scope(fn () =>
					let	val fs = map from_specèenterê fr
						val where_ok = check_boolean(valueètypeê where)
						val having_ok  = check_boolean(valueètypeê having)
					in select_listètypeê sel
					end)
=TEX
=SML
|	tuple_listètypeê	(evaluate‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
				= 	in_new_scope(fn () =>
					let	val fs = map from_specèenterê fr
						val where_ok = check_boolean(valueètypeê where)
						val having_ok  = check_boolean(valueètypeê having)
					in select_listètypeê sel
					end)
=TEX
=SML
|	tuple_listètypeê	(tuple‰s vals) = map valueètypeê vals
=TEX
=SML
|	tuple_listètypeê	(union‰s tls) =	let val tiss = map tuple_listètypeê tls
						in 	if length tiss = 0
							then raise emptyUnionList
							else map (fold lubèexpê)(invert tiss)
						end
=TEX
=SML
|	tuple_listètypeê	(name_columns‰s (names,tul)) =	tuple_listètypeê tul
=TEX
=SML
and 	(Ûfrom_specèenterêÝ : From_specèssqlê -> From_specètsqlê) fs =
	let 	fun	(c_names : TsqlClassName -> string list)
				(constantètcê c) = []
		|	c_names	(nameètcê s) = [s]
		|	c_names anonètcê = raise internalError
		fun	(names : TsqlName -> string list)
				none‰t = []
		|	names	(name‰t s) = [s]
		|	names	anon‰t = raise internalError
		fun	(col_names : TsqlCol -> string list) tc
				 = names(#sterling_name tc)
				@ names(#dinary_name tc)
				@ c_names(#class_name tc)
	in
=TEX
=SML	
	(case fs of
		(from‰s t) => 
			let	val (tn,ti,scs,rc,tcs) = tuple_listèinfoê t
				val tul = tuple_listèmakeê (t,rc,tcs)
				val cor = enterètableê(tn,ti,scs,rc,tcs)
				val cns = (case rc of
						anonètcê => raise internalError
					|	nameètcê s => [s]
					|	constantètcê c => [])
					@ fold (op @) (map col_names tcs)
			in	correlate_from‰t(cor,name_columns‰t(cns,tul))
			end
=TEX
=SML
	|	(correlate_from‰s(name,t)) =>
			let	val (tn,ti,scs,rc,tcs) = tuple_listèinfoê t
				val tul = tuple_listèmakeê (t,rc,tcs)
				val cor = enterècorr_tableê(name,tn,ti,scs,rc,tcs)
				val cns = (case rc of
						anonètcê => raise internalError
					|	nameètcê s => [s]
					|	constantètcê c => [])
					@ fold (op @) (map col_names tcs)
			in	correlate_from‰t(cor,name_columns‰t(cns,tul))
			end)
	end
=TEX
=SML
and 	(Ûselect_listètypeêÝ : Select_listèssqlê -> ExpType list)
			all_columns‰s =
				let 	fun (t : SsqlCol -> ColType) c = #type_field c
					fun (f : ColType -> ExpType)
						  (nullType,nullType) = raise internalError
					| 	f (st,nullType) = (st,sterling)
					| 	f (nullType,dt) = (dt,dinary)
					|	f (st,dt) = (st,sterling)
				in map f(map t(lookupèlocal_col_infoê()))
				end
|	select_listètypeê (select_values‰s vals) = map select_valueètypeê vals
=TEX
=SML
and 	(Ûselect_valueètypeêÝ : Select_valueèssqlê -> ExpType)
				(anonymous_value‰s v) = valueètypeê v
|	select_valueètypeê	(named_value‰s(name,v)) = valueètypeê v
|	select_valueètypeê	(anonymous_pair‰s(sval,dval)) = valueètypeê sval
|	select_valueètypeê	(named_pair‰s(name,(sval,dval))) = valueètypeê sval
=TEX
=SML
and 	(Ûtuple_listèinfoêÝ : Tuple_listèssqlê -> 	TableName  * TableInfo * SsqlCol list 
								* TsqlClassName * TsqlCol list) 
			(table_contents‰s t) = 
				let 	val ts = convertètable_specê t
					val (ti,ci,scs,rc,tcs) = getètable_infoê ts
				in 	(nameètnê ts,ti,scs,rc,tcs)
				end
=TEX
=SML
|	tuple_listèinfoê	(all_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)) =
				let	val (tis,scss,rcs,tcss) = split4 (map from_specèinfoê fr)
				in 	in_new_scope(fn () =>
					let 	val fs = map from_specèenterê fr
						val sli = select_listèinfoê sel
					in	(anonètnê,fold lubètable_infoê tis,sli,
							fold lubètsql_class_nameê rcs,map col_target sli)
					end)
				end
=TEX
=SML
|	tuple_listèinfoê	(distinct_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)) =
				let	val (tis,scss,rcs,tcss) = split4 (map from_specèinfoê fr)
				in 	in_new_scope(fn () =>
					let 	val fs = map from_specèenterê fr
						val sli = select_listèinfoê sel
					in	(anonètnê,fold lubètable_infoê tis,sli,
							fold lubètsql_class_nameê rcs,map col_target sli)
					end)
				end
=TEX
=SML
|	tuple_listèinfoê	(evaluate‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)) =
				let	val (tis,scss,rcs,tcss) = split4 (map from_specèinfoê fr)
				in 	in_new_scope(fn () =>
					let 	val fs = map from_specèenterê fr
						val sli = select_listèinfoê sel
					in	(anonètnê,fold lubètable_infoê tis,sli,
							fold lubètsql_class_nameê rcs,map col_target sli)
					end)
				end
=TEX
=SML
|	tuple_listèinfoê	(tuple‰s vals) =
			let	val	ti = 	{table_exist_class = query_constants_class(),
						table_class = query_constants_class(),
						row_class = constant(query_constants_class())}
				val scs = map valueèinfoê vals
				val tcs = map col_target scs
			in	(anonètnê,ti,scs,constantètcê(query_constants_class()),tcs)
			end
=TEX
=SML
|	tuple_listèinfoê	(union‰s tls) =
			if length tls = 1
			then tuple_listèinfoê(hd tls)
			else 	let	val (tts,tis,scss,rcs,tcss) = split5 (map tuple_listèinfoê tls)
					val ti = fold lubètable_infoê tis
					val scs = map(fold lubèssql_colê)(invert scss)
					val rc = fold lubètsql_class_nameê rcs
					val tcs = map(fold lubètsql_colê) (invert tcss)
				in	(anonètnê,ti,scs,rc,tcs)
				end
=TEX					
=SML
|	tuple_listèinfoê	(name_columns‰s (names,tul)) =
		let	fun	(merge : string * SsqlCol -> SsqlCol)
				(n,{name=cn,type_field=ty,col_exist=ce,col_class=cc})
				= {name=name‰s n,type_field=ty,col_exist=ce,col_class=cc}
			val 	(tn,ti,scs,rc,tcs) = tuple_listèinfoê tul
		in	(tn,ti,at2(map merge)(names,scs),rc,tcs)
		end
=TEX
=SML
and 	(Ûtuple_listèmakeêÝ : Tuple_listèssqlê * TsqlClassName * TsqlCol list -> Tuple_listètsqlê ) 
			(table_contents‰s t,to_rc,to_tcs) = 
			let 	val (ti,ci,scs,rc,tcs) = getètable_infoê (convertètable_specê t)
				val tc = table_contents‰t(convertètableSpecificationê(convertètable_specê t))
				fun (mk : TsqlName * TsqlName -> Valueètsqlê list)
					(name‰t f,name‰t tn) = [contents‰t(denote_col_spec‰t f)]
				| 	mk	(name‰t f,anon‰t) = [contents‰t(denote_col_spec‰t f)]
				| 	mk	(name‰t f,none‰t) = raise internalError
				| 	mk	(anon‰t,name‰t tn) = raise internalError
				|	mk	(anon‰t,anon‰t) = raise internalError
				|	mk	(anon‰t,none‰t) = raise internalError
				|	mk	(none‰t,name‰t tn) = [denote_null‰t]
				|	mk	(none‰t,anon‰t) = [denote_null‰t]
				|	mk	(none‰t,none‰t) = []
				fun (mkc : TsqlClassName * TsqlClassName -> Valueètsqlê list)
					(nameètcê f,nameètcê t) = [contents‰t(denote_col_spec‰t f)]
				| 	mkc	(nameètcê f,constantètcê c) = raise internalError
				| 	mkc	(constantètcê c,nameètcê tn) = [denote_class‰t c]
				| 	mkc	(constantètcê c1,constantètcê c2) = 	
									if c1 = c2 then []
									else raise internalError
				| 	mkc	(anonètcê,x) = raise internalError
				| 	mkc	(nameètcê f,anonètcê) = [contents‰t(denote_col_spec‰t f)]
				| 	mkc	(constantètcê c,anonètcê) = [denote_class‰t c]
				fun (col : TsqlCol * TsqlCol -> Valueètsqlê list)
					({sterling_name= from_sn,dinary_name = from_dn,
						class_name = from_cn},
					{sterling_name= to_sn,dinary_name = to_dn,
						class_name = to_cn}) = 
					mk(from_sn,to_sn) @ mk(from_dn,to_dn) 
						@ mkc(from_cn,to_cn)
			in	if to_rc = rc andalso to_tcs = tcs
				then tc
				else 	let val vals = mkc(rc,to_rc) @ 
							(fold (op @)(at2(map col)(tcs,to_tcs)))
					in all_tuples‰t(select_values‰t(map anonymous_value‰t vals),
					[from‰t tc],denote_true‰t,[],denote_true‰t)
					end
			end
=TEX
=SML
|	tuple_listèmakeê 	(all_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)
						,to_rc,to_tcs)
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val gbs = sterling_columns gb_sterling
				val gbd = dinary_columns gb_dinary
				val gbc = remove_constants(map class_column gb_class)
			in all_tuples‰t(select_values‰t(select_listèmakeê(sel,to_rc,to_tcs)),
					fs,valueèdataê where,gbs @ gbd @ gbc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèmakeê 	(distinct_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)
						,to_rc,to_tcs)
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val gbs = sterling_columns gb_sterling
				val gbd = dinary_columns gb_dinary
				val gbc = remove_constants(map class_column gb_class)
			in distinct_tuples‰t(select_values‰t(select_listèmakeê(sel,to_rc,to_tcs)),
					fs,valueèdataê where,gbs @ gbd @ gbc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèmakeê 	(evaluate‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)
						,to_rc,to_tcs)
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val gbs = sterling_columns gb_sterling
				val gbd = dinary_columns gb_dinary
				val gbc = remove_constants(map class_column gb_class)
			in evaluate‰t(select_values‰t(select_listèmakeê(sel,to_rc,to_tcs)),
					fs,valueèdataê where,gbs @ gbd @ gbc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèmakeê 	(tuple‰s vals,to_rc,to_tcs) = 
			let	val tvals = (case to_rc of
					constantètcê c => []
				|	other => [(denote_class‰t (query_constants_class()))])
				@ (fold(op @)(at2(map make_col)(vals,to_tcs)))
			in tuple‰t tvals
			end	
=TEX
=SML
|	tuple_listèmakeê 	(union‰s tls,to_rc,to_tcs) = 
				if length tls <> 1
				then tuple_listèmakeê(hd tls,to_rc,to_tcs)
				else union‰t(at3(map tuple_listèmakeê)
						(tls,seq(length tls,to_rc),seq(length tls,to_tcs)))
=TEX
=SML
|	tuple_listèmakeê 	(name_columns‰s(names,tul),to_rc,to_tcs) 
						= tuple_listèmakeê(tul,to_rc,to_tcs)
=TEX
=SML
and 	(Ûfrom_specèinfoêÝ : From_specèssqlê -> 
					TableInfo * SsqlCol list * TsqlClassName * TsqlCol list)
			(from‰s t) =	let	val (tn,ti,scs,rc,tcs) = tuple_listèinfoê t
					in 	(ti,scs,rc,tcs)
					end
|	from_specèinfoê	(correlate_from‰s(cn,t)) = 	let	val (tn,ti,scs,rc,tcs) = tuple_listèinfoê t
							in 	(ti,scs,rc,tcs)
							end
=TEX		
=SML
and 	(Ûselect_listèinfoêÝ : Select_listèssqlê -> SsqlCol list)
			all_columns‰s = lookupèlocal_col_infoê()
|	select_listèinfoê (select_values‰s vals) = map select_valueèinfoê vals
=TEX
=SML
and 	(Ûselect_valueèinfoêÝ : Select_valueèssqlê -> SsqlCol)
			(anonymous_value‰s v) = valueèinfoê v

=TEX
=SML
|	select_valueèinfoê	(named_value‰s(n,v)) = 
			let 	val {name = nm,type_field = ty,col_exist = ce,col_class =cc} 
				= valueèinfoê v
			in 	{name = name‰s n,type_field = ty,col_exist = ce,col_class = cc}
			end
=TEX
=SML
|	select_valueèinfoê	(anonymous_pair‰s(sval,dval)) = 
			let 	val (stype,sw) = valueètypeê sval
				val (dtype,dw) = valueètypeê dval
				val u = upper(valueèclassê sval) 
						lub upper(valueèclassê dval)
			in	{name = anon‰s,
				type_field = (stype,dtype),
				col_exist = query_constants_class(),
				col_class = upb u}
			end
=TEX
=SML
|	select_valueèinfoê	(named_pair‰s(n,(sval,dval))) = 
			let 	val (stype,sw) = valueètypeê sval
				val (dtype,dw) = valueètypeê dval
				val u = upper(valueèclassê sval) 
						lub upper(valueèclassê dval)
			in	{name = name‰s n,
				type_field = (stype,dtype),
				col_exist = query_constants_class(),
				col_class = upb u}
			end
=TEX
=SML
and 	(ÛvalueèinfoêÝ : Valueèssqlê -> SsqlCol)
		v = 	case valueèclassê v of
				variable(exp,c) => 	{name= anon‰s,
							 type_field= col_exp(valueètypeê v),
							 col_exist=query_constants_class(),
							 col_class=upb c} 
			| 	constantèecê c => 	{name= anon‰s,
							 type_field= col_exp(valueètypeê v),
							 col_exist=query_constants_class(),
							 col_class=constant c}
=TEX
=SML
and 	(Ûinternal_valueèclassêÝ : Valueèssqlê -> InternalExpClass)
				(denote_constant‰s c) = 
						simple(constantèecê(query_constants_class()))
|	internal_valueèclassê	(monop‰s(opr,v)) = simple(valueèclassê v)
=TEX
=SML
|	internal_valueèclassê	(binop‰s(or_op,(val1,val2))) =
				let 	
				val (v1,c1) =
					(case (internal_valueèclassê val1) of
					ands(datas,classes) => 
							split[simplifyèandsê(datas,classes)]
					| ors(datas,classes) => (datas,classes)
					| simple e => ([valueèdataê val1],[e]))
				val (v2,c2) =
					(case (internal_valueèclassê val2) of
					ands(datas,classes) => 
							split[simplifyèandsê(datas,classes)]
					| ors(datas,classes) => (datas,classes)
					| simple e => ([valueèdataê val2],[e]))
				in ors(v1 @ v2,c1 @ c2)
				end
=TEX
=SML
|	internal_valueèclassê	(binop‰s(and_op,(val1,val2))) =
				let 	
				val (v1,c1) =
					(case (internal_valueèclassê val1) of
					ands(datas,classes) => (datas,classes)
					| ors(datas,classes) => 
							split[simplifyèorsê(datas,classes)]
					 
					| simple e => ([valueèdataê val1],[e]))
				val (v2,c2) =
					(case (internal_valueèclassê val2) of
					ands(datas,classes) => (datas,classes)
					| ors(datas,classes) => 
							split[simplifyèorsê(datas,classes)]
					
					| simple e => ([valueèdataê val2],[e]))
				in ors(v1 @ v2,c1 @ c2)
				end
=TEX
=SML
|	internal_valueèclassê	(binop‰s(opr,(val1,val2))) =
				let 	val vc1 = valueèclassê val1
					val vc2 = valueèclassê val2
				in 	simple(lubèexp_classê(vc1,vc2))
				end
=TEX
=SML
|	internal_valueèclassê	(triop‰s(opr,(val1,val2,val3))) =
				let 	val vc1 = valueèclassê val1
					val vc2 = valueèclassê val2
					val vc3 = valueèclassê val3
				in 	simple(lubèexp_classê(vc1,lubèexp_classê(vc2,vc3)))
				end
=TEX
=SML
|	internal_valueèclassê	(convert‰s(v,t)) = simple(valueèclassê v)
|	internal_valueèclassê	(convert_domain‰s(v,domain,t)) = simple(valueèclassê v)
|	internal_valueèclassê	(make_sterling‰s v) = simple(valueèclassê v)
|	internal_valueèclassê	(make_dinary‰s v) = simple(valueèclassê v)
=TEX
=SML
|	internal_valueèclassê	(declare‰s (id,(val1,val2))) =
			let 	val t1 = valueètypeê val1
				val data1 = valueèdataê val1
				val class1 = valueèclassê val1
				val class2 = valueèclassê val2
				val class2exp = denoteèclass_expê class2
			in					
				in_new_scope(fn () =>
				let val c =	
					case class1 of
						variable (c,u) => 
						let val (cn,dn) = enterèidentifierê(id,t1,u)
						in	declare‰t (cn,(c,
								declare‰t(dn,(data1,class2exp)))) 
						end
					| 	constantèecê c =>
						let val dn =  enterèidentifier_constant_classê(id,t1,c)
						in declare‰t(dn,(data1,class2exp)) 
						end
				in		simple(variable(c,upper class2))
				end)
			end 
=TEX
=SML
| 	internal_valueèclassê	(caseVal‰s (test,caseList,valList,elseVal)) = 
				let 	val tcn = unique_name()
					val tc = contents‰t(denote_col_spec‰t tcn)
					val tvn = unique_name()
					val tv = contents‰t(denote_col_spec‰t tvn)
					fun (limb1  : Valueèssqlê * Valueèssqlê 
							-> Valueètsqlê list * Valueètsqlê list)
						(e,v) = 
						let 	val v1 = denoteèclass_expê(valueèclassê e)
							val t1 = monop‰t(not_op,binop‰t(dom_op,
								(denote_class‰t(query_class()),v1)))
							val t2 = binop‰t(equal_op,(tv,valueèdataê e))
							val v2 = denoteèclass_expê(valueèclassê v)
						in	([t1,t2],[v1,v2])
						end
					fun (limb : Valueèssqlê list * Valueèssqlê list 
							-> Valueètsqlê list * Valueètsqlê list)
						(es,vs) = 
						let val (ess,vss) = split(at2(map limb1)(es,vs))
						in (fold(op @)ess,fold(op @)vss)
						end
					fun (uppers : ExpClass list -> Class)
						es = fold (op lub) (map upper es)	
					val (c1,v1) = limb(caseList,valList)
					val check_list = case‰t(c1,v1,
							denoteèclass_expê(valueèclassê elseVal))
					val check_test = case‰t([binop‰t(dom_op,(denote_class‰t
									(query_class()),tc))],
								[check_list],
								tc)
					val c = declare‰t(tcn,(denoteèclass_expê(valueèclassê test),
							declare‰t(tvn,(valueèdataê test,check_test))))
					val u = uppers(map valueèclassê
							(caseList @ valList @ [test,elseVal]))
				in simple(variable(c,u))
				end
=TEX
=SML								
| 	internal_valueèclassê	(case‰s (caseList,valList,elseVal)) = 
				let 	fun (limb1  : Valueèssqlê * Valueèssqlê 
							-> Valueètsqlê list * Valueètsqlê list)
						(e,v) = 
						let 	val v1 = denoteèclass_expê(valueèclassê e)
							val t1 = monop‰t(not_op,binop‰t(dom_op,
								(denote_class‰t(query_class()),v1)))
							val v2 = denoteèclass_expê(valueèclassê v)
						in	([t1,valueèdataê e],[v1,v2])
						end
					fun (limb : Valueèssqlê list * Valueèssqlê list 
							-> Valueètsqlê list * Valueètsqlê list)
						(es,vs) = 
						let val (ess,vss) = split(at2(map limb1)(es,vs))
						in (fold(op @)ess,fold(op @)vss)
						end
					fun (uppers : ExpClass list -> Class)
						es = fold (op lub) (map upper es)	
					val (c1,v1) = limb(caseList,valList)
					val c = case‰t(c1,v1,denoteèclass_expê(valueèclassê elseVal))
					val u = uppers(map valueèclassê
							(caseList @ valList @ [elseVal]))
				in simple(variable(c,u))
				end
=TEX
=SML
|	internal_valueèclassê	(set_func_all‰s (and_op,v)) = 
				(case valueèclassê v of
					variable(c,u) =>
					let	val cf = case‰t([valueèdataê v],
								[denote_class‰t(lattice_top())],
								c)
						val ce = case‰t([set_func_all‰t(and_op,valueèdataê v)],
								[set_func_all‰t(lub_op,c)],
								set_func_all‰t(glb_op,cf))
					in	simple(variable(ce,u))
					end
				|	constantèecê c => simple(constantèecê c))
=TEX
=SML
|	internal_valueèclassê	(set_func_all‰s (or_op,v)) = 
				(case valueèclassê v of
					variable(c,u) =>
					let	val ct = case‰t([valueèdataê v],
								[c],
								denote_class‰t(lattice_top()))
						val ce = case‰t([set_func_all‰t(or_op,valueèdataê v)],
								[set_func_all‰t(glb_op,ct)],
								set_func_all‰t(lub_op,c))
					in	simple(variable(ce,u))
					end
				|	constantèecê c => simple(constantèecê c))
=TEX
=SML
|	internal_valueèclassê	(set_func_all‰s (opr,v)) = 
				(case valueèclassê v of
					variable(c,u) =>
					simple(variable(set_func_all‰t(lub_op,c),u))
				|	constantèecê c => simple(constantèecê c))
=TEX
=SML
|	internal_valueèclassê	(set_func_distinct‰s (and_op,v)) = 
				(case valueèclassê v of
					variable(c,u) =>
					let	val cf = case‰t([valueèdataê v],
								[denote_class‰t(lattice_top())],
								c)
						val ce = case‰t([set_func_all‰t(and_op,valueèdataê v)],
								[set_func_all‰t(lub_op,c)],
								set_func_all‰t(glb_op,cf))
					in	simple(variable(ce,u))
					end
				|	constantèecê c => simple(constantèecê c))
=TEX
=SML
|	internal_valueèclassê	(set_func_distinct‰s (or_op,v)) = 
				(case valueèclassê v of
					variable(c,u) =>
					let	val ct = case‰t([valueèdataê v],
								[c],
								denote_class‰t(lattice_top()))
						val ce = case‰t([set_func_all‰t(or_op,valueèdataê v)],
								[set_func_all‰t(glb_op,ct)],
								set_func_all‰t(lub_op,c))
					in	simple(variable(ce,u))
					end
				|	constantèecê c => simple(constantèecê c))
=TEX
=SML
|	internal_valueèclassê	(set_func_distinct‰s (opr,v)) = 
				(case valueèclassê v of
					variable(c,u) =>
					simple(variable(set_func_all‰t(lub_op,c),u))
				|	constantèecê c => simple(constantèecê c))
=TEX
=SML
|	internal_valueèclassê	(count_non_null‰s (v,t)) = 
				(case valueèclassê v of
					variable(c,u) =>
					simple(variable(set_func_all‰t(lub_op,c),u))
				|	constantèecê c => simple(constantèecê c))
=TEX
=SML
|	internal_valueèclassê	(count_distinct‰s (v,t)) = 
				(case valueèclassê v of
					variable(c,u) =>
					simple(variable(set_func_all‰t(lub_op,c),u))
				|	constantèecê c => simple(constantèecê c))
=TEX
=SML
|	internal_valueèclassê	(count_all‰s t) = 
				let val ti = fold lubètable_infoê(lookupèlocal_table_infoê())
				in	case #row_class ti of
						upb u =>
						let	val c = fold(curry binop‰t lub_op)(map 
								denote_name(lookupèlocal_row_classesê()))
						in simple(variable(c,u))
						end
					| 	constant u => simple(constantèecê u)
				end
=TEX
=SML
|	internal_valueèclassê	(exists_tuples‰s tuples) = 
				let val (tn,ti,scs,rc,tcs) = tuple_listèinfoê tuples
				in	case #row_class ti of
						upb u =>
						let val c = denoteèclass_expê
								(tuple_listèmax_row_classê tuples)
						in simple(variable(c,u))
						end
					| 	constant u => simple(constantèecê u)
				end
=TEX
=SML
|	internal_valueèclassê	(single_value‰s v) =  
				let val (tn,ti,scs,rc,tcs) = tuple_listèinfoê v
				in	case #col_class (hd scs) of
						upb u =>
						let val c = single_value‰t (tuple_listèclassê v)
						in simple(variable(c,u))
						end
					| 	constant u => simple(constantèecê u)
				end
=TEX
=SML
|	internal_valueèclassê	(contents‰s col) = 
				let val (tr,u) = lookupècol_spec_classê(false,convertècol_specê col)
				in	case tr of
						constant_class c => simple(constantèecê c)
					| 	other => simple(variable(denote_name tr,u))
				end
=TEX
=SML
|	internal_valueèclassê	(sterling_contents‰s col) = 
				let val (tr,u) = lookupècol_spec_classê(false,convertècol_specê col)
				in	case tr of
						constant_class c => simple(constantèecê c)
					| 	other => simple(variable(denote_name tr,u))
				end
=TEX
=SML
|	internal_valueèclassê	(dinary_contents‰s col) = 
				let val (tr,u) = lookupècol_spec_classê(false,convertècol_specê col)
				in	case tr of
						constant_class c => simple(constantèecê c)
					| 	other => simple(variable(denote_name tr,u))
				end
=TEX
=SML
|	internal_valueèclassê	(classification‰s col) = 
				let val (ti,ci) = lookupècolumn_infoê(convertècol_specê col)
				in	case #row_class ti of
						upb u =>
						let 	val rc = lookupècolumn_row_classê
									(false,convertècol_specê col)
							val c = denote_name rc
						in 	simple(variable(c,u))
						end
					| 	constant c => simple(constantèecê c)
				end

=TEX
=SML
|	internal_valueèclassê	(row_existence‰s t) = 	
				let val td = lookupètable_detailê(convertètable_specê t)
				in  simple(constantèecê (#table_class(#info td)))
				end
=TEX
=SML
|	internal_valueèclassê	joined_row_existence‰s = 	
				let val ti = fold lubètable_infoê(lookupèlocal_table_infoê())
				in  simple(constantèecê (#table_class ti))
				end
=TEX
=SML
|	internal_valueèclassê	(classify‰s(v,c)) = simple(valueèclassê c)
|	internal_valueèclassê	(classify_default‰s v) = simple(constantèecê(query_class()))
=TEX
=SML
|	internal_valueèclassê	(observed‰s(n,c)) = raise notTrigger
|	internal_valueèclassê	(modified‰s n) = raise notTrigger
|	internal_valueèclassê	(context‰s t) =
				let val  (cv,class) = contextual_data t
				in simple(constantèecê class) 
				end
|	internal_valueèclassê	(parameter‰s name) = 	
				let val (cv,class) = lookupèparam_dataê name
				in simple(constantèecê class) 
				end
=TEX
=SML
and 	(Ûtuple_listèclassêÝ : Tuple_listèssqlê  -> Tuple_listètsqlê ) 
			(table_contents‰s t) = in_new_scope(fn () =>
			let	val ts = convertètable_specê t
				val tn = convertètableSpecificationê ts
				val (ti,ci,scs,rc,tcs) = getètable_infoê ts
				fun (sel: TsqlCol -> Select_valueètsqlê)
					{sterling_name = sn,
					dinary_name=dn,
					class_name=nameètcê n}
					= anonymous_value‰t(contents‰t(denote_col_spec‰t n))
				| sel 	{sterling_name = sn,
					dinary_name=dn,
					class_name=constantètcê c}
					= anonymous_value‰t(denote_class‰t c)
				| sel	x = raise internalError
			in	all_tuples‰t(select_values‰t(map sel tcs),
					[from‰t(table_contents‰t tn)],denote_true‰t,[],denote_true‰t)
			end)
=TEX
=SML
|	tuple_listèclassê 	(all_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fss = map from_specèenterê fr
				val gs = sterling_columns gb_sterling
				val gd = dinary_columns gb_dinary
				val gc = map class_column gb_class
			in all_tuples‰t(select_listèclassê sel,
					fss,valueèdataê where,gs @ gd @ remove_constants gc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèclassê 	(distinct_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fss = map from_specèenterê fr
				val gs = sterling_columns gb_sterling
				val gd = dinary_columns gb_dinary
				val gc = map class_column gb_class
			in distinct_tuples‰t(select_listèclassê sel,
					fss,valueèdataê where,gs @ gd @ remove_constants gc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèclassê 	(evaluate‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fss = map from_specèenterê fr
				val gs = sterling_columns gb_sterling
				val gd = dinary_columns gb_dinary
				val gc = map class_column gb_class
			in evaluate‰t(select_listèclassê sel,
					fss,valueèdataê where,gs @ gd @ remove_constants gc,
					valueèdataê having)
			end)
=TEX
=SML
|	tuple_listèclassê 	(tuple‰s vals) = 
				tuple‰t(map denoteèclass_expê(map valueèclassê vals))
=TEX
=SML
|	tuple_listèclassê 	(union‰s tls) = 
				union‰t(map tuple_listèclassê tls)
=TEX
=SML
|	tuple_listèclassê 	(name_columns‰s(names,tul)) 
						= tuple_listèclassê tul
and 	(Ûselect_listèclassêÝ : Select_listèssqlê -> Select_listètsqlê)
			all_columns‰s = 
				let val (trs,classes) = split(lookupèlocal_col_spec_classesê())
				in select_values‰t(map anonymous_value‰t (map denote_name trs))
				end
|	select_listèclassê (select_values‰s vals) = select_values‰t(map select_valueèclassê vals)
=TEX
=SML
and 	(Ûselect_valueèclassêÝ : Select_valueèssqlê -> Select_valueètsqlê)
				(anonymous_value‰s v) = 
					anonymous_value‰t(denoteèclass_expê(valueèclassê v))
|	select_valueèclassê	(named_value‰s(name,v)) = 
					anonymous_value‰t(denoteèclass_expê(valueèclassê v))
|	select_valueèclassê	(anonymous_pair‰s(sval,dval)) = 
					anonymous_value‰t(denoteèclass_expê(valueèclassê sval))
|	select_valueèclassê	(named_pair‰s(name,(sval,dval))) = 
					anonymous_value‰t(denoteèclass_expê(valueèclassê sval))
=TEX					
=SML
=TEX
=SML
and 	(Ûselect_listèmakeêÝ : Select_listèssqlê * TsqlClassName * TsqlCol list -> Select_valueètsqlê list)
			(all_columns‰s,to_rc,to_tcs) = 
				let	val rcs = lookupèlocal_row_classesê()
					val rc = (fold(curry binop‰t lub_op)(map denote_name rcs))
				in
				(case to_rc of
					anonètcê => [anonymous_value‰t rc]
				| 	nameètcê s => [anonymous_value‰t rc]
				|	constantètcê c => [])
				
				end
				@
				(fold (op @)(at2(map makeèsvê)
					(lookupèlocal_col_implementationê(),to_tcs)))
=TEX
=SML
|	select_listèmakeê (select_values‰s vals,to_rc,to_tcs) = 
			let	fun	 (make : TsqlRepr -> Valueètsqlê )
						(local_identifier s) = raise internalError
				|	make	(column(t,c)) = contents‰t(absolute_col_spec‰t([],t,c))
				|	make	(constant_class c) = denote_class‰t c
				|	make	constant_null = denote_null‰t
			in	(case to_rc of
						anonètcê => 
						let val rcvs = map make(lookupèlocal_row_classesê())
						in [anonymous_value‰t
							(fold(curry binop‰t lub_op)rcvs)]
						end
					|	nameètcê s => 
						let val rcvs = map make(lookupèlocal_row_classesê())
						in [anonymous_value‰t
							(fold(curry binop‰t lub_op)rcvs)]
						end
					|	constantètcê c => [])
				@
				(fold (op @)(at2(map select_valueèmakeê)(vals,to_tcs)))
			end
=TEX
=SML
and 	(Ûselect_valueèmakeêÝ : Select_valueèssqlê * TsqlCol-> Select_valueètsqlê list)
				(anonymous_value‰s v,tcol) = 
						map anonymous_value‰t(make_col(v,tcol))
|	select_valueèmakeê	(named_value‰s(name,v),tcol) = 
						map anonymous_value‰t(make_col(v,tcol))
|	select_valueèmakeê	(anonymous_pair‰s(sval,dval),tcol) = 
						let	val sv = anonymous_value‰t(valueèdataê sval)
							val sd = anonymous_value‰t(valueèdataê dval)
						in 	[sv,sd]
						end	
|	select_valueèmakeê	(named_pair‰s(name,(sval,dval)),tcol) = 
						let	val sv = anonymous_value‰t(valueèdataê sval)
							val sd = anonymous_value‰t(valueèdataê dval)
						in 	[sv,sd]
						end
=TEX
=SML
and 	(Ûmake_colÝ : Valueèssqlê * TsqlCol -> Valueètsqlê list)
		(v,tcol) =	let val et =  valueètypeê v
				in
				(case (#sterling_name tcol) of
					none‰t => []
				|	anon‰t => [makeèsterlingê(v,et)]
				|	name‰t s => [makeèsterlingê(v,et)])
				@
				(case (#dinary_name tcol) of
					none‰t => []
				|	anon‰t => [makeèdinaryê(v,et)]
				|	name‰t s => [makeèdinaryê(v,et)])
				@
				(case (#class_name tcol) of
					anonètcê => [denoteèclass_expê(valueèclassê v)]
				|	nameètcê s => [denoteèclass_expê(valueèclassê v)]
				|	constantètcê c => [])
				end
=TEX
=SML
and 	(ÛmakeèdinaryêÝ : Valueèssqlê * ExpType -> Valueètsqlê)
			(v,(t,priceless)) = raise wrongType
|	makeèdinaryê	(v,(t,sterling)) =  denote_null‰t
|	makeèdinaryê	(v,(t,dinary)) =  valueèdataê v 
|	makeèdinaryê	(v,(t,worthless)) =  denote_null‰t
=TEX
=SML
and 	(ÛmakeèsterlingêÝ : Valueèssqlê * ExpType -> Valueètsqlê)
			(v,(t,priceless)) = raise wrongType
|	makeèsterlingê	(v,(t,sterling)) =  valueèdataê v
|	makeèsterlingê	(v,(t,dinary)) =  denote_null‰t 
|	makeèsterlingê	(v,(t,worthless)) =  valueèdataê v
=TEX
=SML
and 	(Ûselect_listèdataêÝ : Select_listèssqlê -> Select_listètsqlê)
			all_columns‰s = select_values‰t(map anonymous_value‰t (map contents‰t
						(all_data_columnsèlocalê())))
|	select_listèdataê (select_values‰s vals) = select_values‰t(map select_valueèdataê vals)
=TEX
=SML
and 	(Ûselect_valueèdataêÝ : Select_valueèssqlê -> Select_valueètsqlê)
				(anonymous_value‰s v) = anonymous_value‰t(valueèdataê v)
|	select_valueèdataê	(named_value‰s(name,v)) = anonymous_value‰t(valueèdataê v)
|	select_valueèdataê	(anonymous_pair‰s(sval,dval)) = anonymous_value‰t(valueèdataê sval)
|	select_valueèdataê	(named_pair‰s(name,(sval,dval))) = 
							anonymous_value‰t(valueèdataê sval)
=TEX		
=SML
fun 	(Ûtuple_listèmake_outerêÝ : Tuple_listèssqlê * bool * TsqlClassName * TsqlCol list 
						-> Tuple_listètsqlê * Queryètsqlê list ) 
			(table_contents‰s t,scw,to_rc,to_tcs) = 
			let 	val ts = convertètable_specê t
				val (ti,ci,scs,rc,tcs) = getètable_infoê ts
				val where_class = denote_class‰t(query_constants_class())
				val sl = (case scw of
						true => [anonymous_value‰t where_class]
					|	false => [])
					@
					(case to_rc of
						constantètcê c => []
					|	other => 
						(case rc of 
							anonètcê => raise internalError
						|	nameètcê col => 
							[anonymous_value‰t(contents‰t
									(denote_col_spec‰t col))]
						|	constantètcê cl => 
							[anonymous_value‰t(denote_class‰t cl)]))
					@ (fold (op @) (at2(map makeèsvê)(tcs,to_tcs)))
				val fs = from‰t(table_contents‰t(convertètableSpecificationê ts))
				val sel_q = all_tuples‰t(select_values‰t sl,[fs],denote_true‰t,
								[],denote_true‰t)
			in	(sel_q,[])
			end
=TEX
=SML
|	tuple_listèmake_outerê 	(all_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)
						,scw,to_rc,to_tcs)
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val sel_vals = select_listèmakeê(sel,to_rc,to_tcs)
				val where_v = valueèdataê where
				val where_c = valueèclassê where
				val where_class = case where_c of
							variable(exp,c) => exp
						  |	constantèecê c => denote_class‰t c
				val sel_list = 	case scw of
						 true => [anonymous_value‰t where_class]@ sel_vals
						| false => sel_vals	
				val sl = select_values‰t sel_list
				val cc = denote_class‰t(client_clearance())
				val wchk = case where_c of
					   	variable(exp,c) => 
							if client_clearance() dom c	
							then where_v
							else 	let val ok = binop‰t(dom_op,(cc,exp))
								in binop‰t(or_op,(where_v,
									monop‰t(not_op,ok)))
								end
					    |	constantèecê c =>
							if client_clearance() dom c	
							then where_v
							else 	denote_true‰t
				val max_rc = fold (op lub)(map upb_row_class
								(lookupèlocal_table_infoê()))	
				val rcs = map denote_name(lookupèlocal_row_classesê())
				val rvis = binop‰t(dom_op,(cc,fold(curry binop‰t lub_op)rcs))
				val w = 	if client_clearance() dom max_rc
						then wchk
						else binop‰t(and_op,(wchk,rvis))
				val gbs = sterling_columns gb_sterling
				val gbd = dinary_columns gb_dinary
				val gbc = remove_constants(map class_column gb_class)
=TEX
=SML
				val groupby_test = fold(op @)(map column_data_test
								(gb_sterling @ gb_dinary))
				val having_test =	case valueèclassê having of
								constantèecê c =>
									if client_clearance() dom c	
									then []
									else 	[denote_false‰t]
							|	variable(exp,c) => 
									if client_clearance() dom c	
									then []
									else [binop‰t(dom_op,(cc,exp))]
				val tests = groupby_test @ having_test
				val checks = 	
					if length tests = 0
					then []
					else 	
					let 	val t = monop‰t(not_op,
							(fold(curry binop‰t and_op)tests))
						val bad = 	if client_clearance() dom max_rc
								then [where_v,t]
								else [rvis,where_v,t]
						val junk = anonymous_value‰t(denote_true‰t)
						val junk_sl = select_values‰t[junk]
					in [select‰t(all_tuples‰t(junk_sl,fs,
						fold(curry binop‰t and_op)bad,[],denote_true‰t))]
					end
				val sel_q = all_tuples‰t(sl,fs,w,gbs @ gbd @ gbc,valueèdataê having)
			in (sel_q,checks)
			end)		
=TEX
=SML
|	tuple_listèmake_outerê 	(distinct_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)
						,scw,to_rc,to_tcs)
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val sel_vals = select_listèmakeê(sel,to_rc,to_tcs)
				val where_v = valueèdataê where
				val where_c = valueèclassê where
				val where_class = case where_c of
							variable(exp,c) => exp
						  |	constantèecê c => denote_class‰t c
				val sel_list = 	case scw of
						 true => [anonymous_value‰t where_class]@ sel_vals
						| false => sel_vals	
				val sl = select_values‰t sel_list
				val cc = denote_class‰t(client_clearance())
				val wchk = case where_c of
					   	variable(exp,c) => 
							if client_clearance() dom c	
							then where_v
							else 	let val ok = binop‰t(dom_op,(cc,exp))
								in binop‰t(or_op,(where_v,
									monop‰t(not_op,ok)))
								end
					    |	constantèecê c =>
							if client_clearance() dom c	
							then where_v
							else 	denote_true‰t
				val max_rc = fold (op lub)(map upb_row_class
								(lookupèlocal_table_infoê()))	
				val rcs = map denote_name(lookupèlocal_row_classesê())
				val rvis = binop‰t(dom_op,(cc,fold(curry binop‰t lub_op)rcs))
				val w = 	if client_clearance() dom max_rc
						then wchk
						else binop‰t(and_op,(wchk,rvis))
				val gbs = sterling_columns gb_sterling
				val gbd = dinary_columns gb_dinary
				val gbc = remove_constants(map class_column gb_class)
=TEX
=SML
				val groupby_test = fold(op @)(map column_data_test
								(gb_sterling @ gb_dinary))
				val having_test =	case valueèclassê having of
								constantèecê c =>
									if client_clearance() dom c	
									then []
									else 	[denote_false‰t]
							|	variable(exp,c) => 
									if client_clearance() dom c	
									then []
									else [binop‰t(dom_op,(cc,exp))]
				val tests = groupby_test @ having_test
				val checks = 	
					if length tests = 0
					then []
					else 	
					let 	val t = monop‰t(not_op,
							(fold(curry binop‰t and_op)tests))
						val bad = 	if client_clearance() dom max_rc
								then [where_v,t]
								else [rvis,where_v,t]
						val junk = anonymous_value‰t(denote_true‰t)
						val junk_sl = select_values‰t[junk]
					in [select‰t(all_tuples‰t(junk_sl,fs,
						fold(curry binop‰t and_op)bad,[],denote_true‰t))]
					end
				val sel_q = distinct_tuples‰t
						(sl,fs,w,gbs @ gbd @ gbc,valueèdataê having)
			in (sel_q,checks)
			end)		
=TEX
=SML
|	tuple_listèmake_outerê 	(evaluate‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having)
						,scw,to_rc,to_tcs)
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val sel_vals = select_listèmakeê(sel,to_rc,to_tcs)
				val where_v = valueèdataê where
				val where_c = valueèclassê where
				val where_class = case where_c of
							variable(exp,c) => exp
						  |	constantèecê c => denote_class‰t c
				val sel_list = 	case scw of
						 true => [anonymous_value‰t where_class]@ sel_vals
						| false => sel_vals	
				val sl = select_values‰t sel_list
				val cc = denote_class‰t(client_clearance())
				val wchk = case where_c of
					   	variable(exp,c) => 
							if client_clearance() dom c	
							then where_v
							else 	let val ok = binop‰t(dom_op,(cc,exp))
								in binop‰t(or_op,(where_v,
									monop‰t(not_op,ok)))
								end
					    |	constantèecê c =>
							if client_clearance() dom c	
							then where_v
							else 	denote_true‰t
				val max_rc = fold (op lub)(map upb_row_class
								(lookupèlocal_table_infoê()))	
				val rcs = map denote_name(lookupèlocal_row_classesê())
				val rvis = binop‰t(dom_op,(cc,fold(curry binop‰t lub_op)rcs))
				val w = 	if client_clearance() dom max_rc
						then wchk
						else binop‰t(and_op,(wchk,rvis))
				val gbs = sterling_columns gb_sterling
				val gbd = dinary_columns gb_dinary
				val gbc = remove_constants(map class_column gb_class)
=TEX
=SML
				val groupby_test = fold(op @)(map column_data_test
								(gb_sterling @ gb_dinary))
				val having_test =	case valueèclassê having of
								constantèecê c =>
									if client_clearance() dom c	
									then []
									else 	[denote_false‰t]
							|	variable(exp,c) => 
									if client_clearance() dom c	
									then []
									else [binop‰t(dom_op,(cc,exp))]
				val tests = groupby_test @ having_test
				val checks = 	
					if length tests = 0
					then []
					else 	
					let 	val t = monop‰t(not_op,
							(fold(curry binop‰t and_op)tests))
						val bad = 	if client_clearance() dom max_rc
								then [where_v,t]
								else [rvis,where_v,t]
						val junk = anonymous_value‰t(denote_true‰t)
						val junk_sl = select_values‰t[junk]
					in [select‰t(all_tuples‰t(junk_sl,fs,
						fold(curry binop‰t and_op)bad,[],denote_true‰t))]
					end
				val sel_q = evaluate‰t(sl,fs,w,gbs @ gbd @ gbc,valueèdataê having)
			in (sel_q,checks)
			end)		
=TEX
=SML
|	tuple_listèmake_outerê 	(tuple‰s vals,scw,to_rc,to_tcs) = 
			let 	val q = denote_class‰t (query_constants_class())
				val tvals = 	(case scw of 
						true => [q]
			  			| 	false => [])
						@ (case to_rc of
						constantètcê c => []
			  			|	other => [q])
						@ (fold(op @)(at2(map make_col)(vals,to_tcs)))
			in (tuple‰t tvals,[])
			end	
=TEX
=SML
|	tuple_listèmake_outerê 	(union‰s tls,scw,to_rc,to_tcs) = 
				if length tls = 1
				then tuple_listèmake_outerê(hd tls,scw,to_rc,to_tcs)
				else 	let	val (ts,qs) = split(at4(map tuple_listèmake_outerê)
								(tls,
									seq(length tls,scw),
									seq(length tls,to_rc),
									seq(length tls,to_tcs)))
					in (union‰t ts, fold (op @) qs)
					end
=TEX
=SML
|	tuple_listèmake_outerê 	(name_columns‰s(names,tul),scw,to_rc,to_tcs) 
						= tuple_listèmake_outerê(tul,scw,to_rc,to_tcs);	
=TEX	
=SML
fun 	(Ûtuple_listèouter_infoêÝ : Tuple_listèssqlê -> bool) 
			(table_contents‰s t) =  false
=TEX
=SML
|	tuple_listèouter_infoê(all_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val where_c = valueèclassê where
			in 	case where_c of
					variable(exp,c) => not(client_clearance() dom c)
				  |	constantèecê c => not(client_clearance() dom c)
			end)
=TEX
=SML
|	tuple_listèouter_infoê(distinct_tuples‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val where_c = valueèclassê where
			in 	case where_c of
					variable(exp,c) => not(client_clearance() dom c)
				  |	constantèecê c => not(client_clearance() dom c)
			end)
=TEX
=SML
|	tuple_listèouter_infoê(evaluate‰s(sel,fr,where,gb_sterling,gb_dinary,gb_class,having))
			= in_new_scope(fn () =>
			let	val fs = map from_specèenterê fr
				val where_c = valueèclassê where
			in 	case where_c of
					variable(exp,c) => not(client_clearance() dom c)
				  |	constantèecê c => not(client_clearance() dom c)
			end)
=TEX
=SML
|	tuple_listèouter_infoê(tuple‰s vals) = false
=TEX
=SML
|	tuple_listèouter_infoê(union‰s tls) = fold or(map tuple_listèouter_infoê tls)
=TEX
=SML
|	tuple_listèouter_infoê(name_columns‰s(names,tul)) = tuple_listèouter_infoê tul;
=TEX
=SML
fun 	(Ûtransformèselect_queryêÝ : Queryèssqlê -> SsqlCol list * Queryètsqlê * bool * TsqlClassName 
							* TsqlCol list  * Queryètsqlê list)
				(select‰s vals) = 	
					let 	val scw = tuple_listèouter_infoê vals
						val (tn,ti,scs,rc,tcs) = tuple_listèinfoê vals
						val (tul,chks) = tuple_listèmake_outerê(vals,scw,rc,tcs)
					in	(scs,select‰t tul,scw,rc,tcs,chks)
					end
|	transformèselect_queryê	q = raise internalError;	
=TEX							
=SML
fun 	(Ûqueryèselect_queryêÝ : Queryèssqlê -> Queryètsqlê)
			(select‰s vals) = 	let val (tn,ti,scs,rc,tcs) = tuple_listèinfoê vals
						in select‰t(tuple_listèmakeê(vals,rc,tcs))
						end
|	queryèselect_queryê q = raise internalError;
	
=TEX	
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}

