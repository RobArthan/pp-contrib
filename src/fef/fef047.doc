=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{FEF Project Final Report}  %% Mandatory field
\TPPref{DS/FMU/FEF/047}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\def\SCCSdate{\FormatDate{$Date$%
}}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\SCCSdate}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Report}
\TPPkeywords{}
\TPPauthor{R.B.~Jones}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.~B.~Jones & HAT Manager}
\TPPabstract{This document is the final report for the DRA Front End 
Filter project RSRE 1C/6130, giving an overview of the achievements of the project.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File 
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\listoftables
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[1.2 ({\FormatDate{94/03/14}})] First draft for DRA.
\item[\SCCSversion ({\SCCSdate})] Final report.
\end{description}

\subsection{Changes Forecast}

None.

\pagebreak
\section{GENERAL}
\subsection{Scope} \label{scope}

This document is a report on the results of the formal specification and verification work carried out by ICL as part of the development by DRA of SWORD, a secure relational database system.
ICL's work on this project is generally referred to as the ``FEF project'' in the rest of this document.

\subsection{Introduction}

This report is divided into sections as follows: 

Section \ref{objectives} describes the objectives of the formal methods work.
 
Section \ref{performance} describes the key achievements against the identified objectives.

Section \ref{deliverables} tabulates the deliverables to DRA.
 
Section \ref{descriptionofresults} describes the results of the FEF project, particularly considering the significance of the various formal specifications and of the theorems which have been proved about them.

Section \ref{costeffectiveness} comments on the cost effectiveness of the work undertaken.

Section \ref{oac} offers conclusions.

\subsection{Terminology and Abbreviations}

\begin{tabular}{lp{5in}}
CLEF & Commercial Licenced Evaluation Facility  \\
 & \\
DBMS & Database Management System  \\
 & \\
FEF & Front End Filter\\
 & \\
 & This term is used to describe an implementation technique for SSQL.
SSQL queries provided by a client user or process are transformed into SQL queries which are then executed on a standard commercial DBMS.
Output from the SQL queries is filtered to remove sensitive information before it is returned to the client.
In this document the phrase `FEF project' is used to refer to ICL's work on the formal specification and verification of aspects of the FEF development being undertaken by DRA.\\
 & \\
 HAT & High Assurance Team, the unit within ICL which carried out the work described in this document.\\
& \\
ITSEC & Information Technology Security Evaluation Criteria \\
 & \\
RDBMS & Relational DBMS  \\
 & \\
SSQL & Secure SQL\\
 & \\
 & A variant of the SQL database query language with features supporting  multilevel security.
SSQL differs from SQL mainly in that there is an additional data type, $Class$, for security-classifications, which is used to classify the information held in tables and their constituent rows and columns.\\
 & \\
SQL  & Structured Query Language\\
 & \\
 & A standard relational query language for querying and updating a database. \\
 & \\
TOE & Target Of Evaluation\\
 & \\
TSQL & Target SQL\\
 & \\
 & A variant of SQL, augmented with a data type $Class$ which can be used to represent security-classifications, but which has no other special interpretation.
%TSQL is expected to be closely approximated by standard commercial DBMS offerings.
\\
\end{tabular} 

\pagebreak
\section{THE OBJECTIVES OF THE FORMAL METHODS WORK}\label{objectives}

The objectives of the formal methods work undertaken under contract RSRE 1C/6130 (as set out in Annex 9 to the ITT) were:

\begin{itemize}

\item
To provide an assessment of the applicability of computerised mathematical theorem proving tools to the construction of secure systems of realistic size and complexity.

\item
To result, in combination with DRA in-house work, in the production of a prototype secure DBMS capable of being evaluated to a medium level of assurance. 

\end{itemize}

The work has fallen into three distinct phases which had more specific objectives as follows.

\subsection{Phase 1}

In the first phase the primary objective was as given in the following extract from the {\em Secure Database Technical Proposal} \cite[section~2.1]{DS/FMU/017}:

\begin{quotation}

\em
The production of a machine-checked formal proof of the security of an abstract machine modelling a secure database supporting the query language {\it SSQL} as defined by DRA in Annex~2 to the ITT.

\end{quotation}

\subsection{Phase 2}

The second phase of the work was to involve formal modeling of the design of the front end filter rather than the SSQL semantics.
After reviewing the requirements for Phase 2 in the light of the results of Phase 1, the following revised statement of objectives was agreed  and recorded in the {\em Proposal for Phase 2}, \cite[section~1.2]{DS/FMU/FEF/018}:

\begin{quotation}

\em
To use the proof process to discover flaws in the specifications.

To evolve the specification during the course of the proof as necessary to render it satisfactory.

\end{quotation}

The following extract from \cite{DS/FMU/FEF/018} amplify these objectives:

\begin{quotation}

\em
The main purpose of the requirement for Phase 2 in the original ITT was to verify the design of the Front End Filter.
The most important (if not the only) concern was that the filter would result in a secure database.

[The] proposal for Phase 2 therefore attempts to provide the most effective way of employing formal modelling and proof to improve confidence in the security of the Front End Filter.

\end{quotation}

The specifications referred to in the {\em Proposal for Phase 2}  are those of the Front End Filter.
The relevant notion of security is that in the formal security policy \cite{DS/FMU/FEF/003}.

\subsection{Phase 3}

Phase 3 was originally to comprise solely the preparation of a final report.
Towards the end of phase 2 it was agreed to extend the scope of phase 3 to embrace an additional report and further technical work on multi-level security modelling.
The following extended requirements for Phase 3 were identified in the {\it Proposal for Phase 3} \cite{DS/FMU/FEF/039}.

\begin{quotation}
\em

Managerial Final Report:
This is to provide a managerial overview of the achievements of the FEF project and to comment on the cost-effectiveness of the formal methods work.

CLEF Report:
This is to provide a technical overview of the formal treatment of the Front End implementation of SWORD and to comment on issues such as the effectiveness of the formal methods work in exposing security-relevant problems with the design and other issues of relevance to evaluation of the SWORD implementation.


Multi-level Objects:
DRA have carried out some research, reported in \cite{securityprops}, into extensions of the security policy modelling for SWORD to embrace SSQL queries which are themselves treated as structured multi-level objects.
This work endeavours to formulate a non-interference style security policy for systems dealing with such objects and to define a result-labelling property which is intended to capture formally certain intuitions about the desired behaviour of the SWORD implementation.
However, as discussed in \cite{securityprops}, there are some technical difficulties with the proposed definition of the result-labelling property.
DRA would like ICL to give a more formal treatment of the topics discussed in \cite{securityprops} and to investigate how the intuitions behind the result-labelling property may best be formalised.

\end{quotation}

This document constitutes the Managerial Final Report mentioned above.

\section{ACHIEVEMENTS IN RELATION TO OBJECTIVES} \label{performance}

The key achievements in relation to the stated objectives are summarised in sections \ref{Phase1achievements} and \ref{Phase2achievements} below.
A more detailed description of the results may be found in Section \ref{descriptionofresults}.
A description of the errors detected in the specifications as a result of the formal methods work is given in Section \ref{issuesdetected}.

\subsection{Phase 1}\label{Phase1achievements}

The original objectives took the required Phase 1 proof to be concerned with {\it confirming} the correctness of the specifications (w.r.t. the formal security model), while acknowledging a risk that the specifications might prove not to be correct.

In fact, the formal work proved more valuable than had been anticipated.
Significant numbers of minor errors were discovered in the specifications and corrected during the formalisation, syntax checking and type checking of the specifications.

During the proof work one error was discovered which rendered the SSQL abstract machine as specified insecure.
This error was corrected and the formal proofs were completed.

Thus the primary objective of Phase 1 was fully satisfied, and in addition a number of errors were detected and corrected in the original specifications.

\subsection{Phase 2}\label{Phase2achievements}

The objectives of the Phase 2 work were reviewed prior to the commencement of Phase 2, and re-oriented toward using the formal specification and proof work for detecting errors in the design specifications for the Front End Filter.

Partial formal proofs of the security of the SSQL system as implemented using the Front End Filter were then undertaken.

Though the greater complexity of the security-relevant aspects of the specifications (by comparison with Phase 1) prevented completion of the relevant proofs, partial proofs were accomplished as planned.
The rate of detection of errors was similar to that in Phase 1, but the proportion of substantive errors in the security of the specifications was significantly higher in Phase 2 than in Phase 1.

\subsection{Phase 3}\label{Phase3achievements}

The two reports reports on overall achievements were produced, this document being one of them.

The technical component of the phase 3 work resulted in a generic formulation of a multi-level security policy.
This was used to give a formal expression of the multi-level policy for SWORD along the lines discussed in \cite{securityprops}.
Various approaches to formulating the result labelling property were considered.
The approach finally chosen was checked with some proof work and appears to solve the main technical difficulties and to provide a good basis for a possible future formal treatment of an actual system design for which this type of property is required.


\newpage
\section{DELIVERABLES}\label{deliverables}
\subsection{Phase 1}

In table \ref{PhaseOneDeliverables} are shown the deliverables from \cite{DS/FMU/017,amend1,amend2}, together with the name of the document or documents constituting each deliverable
\footnote{As a result of an oversight in preparing the revised Phase 3 proposal, deliverable codes D16 and D17 were re-used.
To disambiguate these deliverable codes they have been subscripted with the relevant phase number.
}:

\def\Docs#1{\begin{tabular}{@{}l@{}}#1\end{tabular}}

\begin{table}[hbp]
\center
\begin{tabular}{|l|l|l|l|}\hline
WP & Code	& Description & Document \\\hline \hline
WP1a	& D1 & Formal Security Policy & \Docs{fef003} \\\hline
WP1a	& D2 & Specifications of `hide' and `update' & \Docs{fef005} \\\hline
WP1a	& D3 & Specifications of SSQL semantics I& \Docs{fef004} \\\hline
WP1a	& D3 & Specifications of SSQL semantics II& \Docs{fef014} \\\hline
WP1a	& D4 & Specification of security conjecture & \Docs{fef006}  \\\hline
WP1b	& D5 & Unwinding proof scripts & \Docs{fef009} \\\hline
WP1b	& $\hbox{D16}_1$ & Informal justification for unwinding proof & \Docs{fef009} \\\hline
WP1c	& D6 & Remaining proof scripts & \Docs{fef010\\fef011\\fef012\\fef013\\fef015}  \\\hline
WP1c	& $\hbox{D17}_1$ & Informal justifications for remaining proof & \Docs{fef016} \\\hline
WP2	& D7 & Proposal for Phase 2 & \Docs{fef018} \\\hline
\end{tabular}
\caption{Phase 1 Deliverables}
\label{PhaseOneDeliverables}
\end{table}

The following have also been delivered to DRA:
\begin{table}[hbp]
\center
\begin{tabular}{|l|l|}\hline
Description & Document \\\hline \hline
Proof Strategy & \Docs{fef007} \\
Cross Reference Index & \Docs{fef008} \\
ProofPower Theory Listings & \Docs{fef017} \\\hline
\end{tabular}
\caption{Additional Phase 1 Documents}
\end{table}

\subsection{Phase 2}

Table \ref{PhaseTwoDeliverables} shows the Phase 2 deliverables, together with the description and delivery date of the material to be delivered.
These are as specified in \cite{DS/FMU/FEF/018}, amended and agreed according to a letter to DRA of 6/1/93 (ref. fef/letters/dra9).

\begin{table}[hbtp]
\center

\begin{center}
\begin{tabular}{|l|l|l|l|}\hline
WP & Code	& \multicolumn{1}{l|}{Description} & Document \\\hline\hline
WP3	& D8 & Query Transformation Specifications in SML & \Docs{fef019} \\\hline
& & & fef020 \\\hline
WP3	& D9 & TSQL abstract machine specifications & \Docs{fef021} \\\hline
WP3	& D10 & Query Transformation Specifications in HOL & \Docs{fef022\\fef024\\fef025} \\\hline
WP3	& D11 & SSQL Implementation Model Specifications & \Docs{fef028\\fef029}\\\hline
WP3	& D12 & Specification of Security Propositions & \Docs{fef026\\fef032\\fef034}\\\hline
WP3	& D13 & Phase~2 Proof Scripts & \Docs{fef031\\fef033\\fef035} \\\hline
WP4	& D14 & Report on Phase~2 Proofs & \Docs{fef036} \\\hline\end{tabular}
\end{center}

\caption{Phase 2 Deliverables}
\label{PhaseTwoDeliverables}
\end{table}

\subsection{Phase 3}

The deliverables for the extended phase 3 as described in \cite{DS/FMU/FEF/039}
are listed in table \ref{phaseThreeDeliverables}.

\begin{table}[htbp]
\center
\begin{tabular}{|l|l|p{3.5in}|l|}\hline
WP & Code       & \multicolumn{1}{l|}{Description} & Document \\\hline\hline
WP7a    & D15 & Managerial Final Report & \Docs{fef047} \\\hline
WP7b    & D$\hbox{16}_3$ & CLEF Report & \Docs{fef041} \\\hline
WP7c    & D$\hbox{17}_3$ & Formal specification of non-interference and result-labelling property for multi-level objects & \Docs{fef040\\fef042\\fef043} \\\hline
WP7d    & D18 & Report on consistency and other proof opportunities & \Docs{fef045} \\\hline
WP7e    & D19  & Report on relationship between phase~2 and phase~3 treatments & \Docs{fef046} \\\hline
\end{tabular}
\caption{Phase~3 Deliverables}
\label{phaseThreeDeliverables}
\end{table}

\section{DESCRIPTION OF RESULTS} \label{descriptionofresults}

\subsection{Introduction}

The work under the FEF project considered in this document was commissioned and carried out in three phases.
The bulk of the work was carried out between March 1992 and December 1993.

The main technical aim of Phase 1 was to produce a formal specification of the semantics of SSQL in a form suitable for processing using a computerised theorem-proving system and to provide a machine-checked proof that the SSQL semantics provided information-flow security according to an agreed formalisation of the `No Flows Down' security policy.
An important feature of the approach taken was to structure the formal specification of the SSQL semantics so that security critical aspects were clearly separated out.

The original intention for Phase 2 had been to verify that the formal model of the Front End implementation of SWORD was a `secure refinement' (as defined in \cite{DS/FMU/017} Section 6.1) of the SSQL abstract machine (as specified in Phase 1) and so to demonstrate that it was secure.
However, the requirements for Phase 2 were reviewed towards the end of Phase 1, and it was agreed that the complexity of the implementation was likely to make a full correctness proof prohibitively expensive.
Moreover, complete informal specifications of the implementation were not expected to be available soon enough.
The revised objectives for Phase 2 were therefore to use formal specification and proof to discover any security flaws in the informal specifications, and to evolve the formal specifications to eliminate any flaws discovered.

Work in Phase 3 was concerned with extended the formal analysis to capture more fully the intended benefits arising from the proposed use of labels in multi-level results, and with the provision of various reports on the work previously undertaken.
On the technical side the results were to include a formalisation of a `labelling property', together with consistency and other relevant proofs relating to this property.

The deliverables of the FEF project mainly comprise documents containing specifications or proof scripts.
Specifications and theorems are expressed in {\ProductHOL}, a version of Higher Order Logic supported by {\Product} \cite{DS/FMU/IED/USR014}.
{\ProductHOL} is a formal logic suitable for specifying models of systems, and for formulating and proving theorems about such models.
The concrete syntax for {\ProductHOL} is in some ways similar to the Z notation \cite{Spivey89}, but the underlying abstract syntax and the logical system follows very closely that of HOL88 \cite{Gordon93}.
{\Product} is a tool which gives support for specification and proof in {\ProductHOL} (and other formal notations) via comprehensive programmable facilities for developing and interrogating a database of specifications and theorems.
The database is organised as an extensible hierarchy of modules referred to as ``theories''.
It also gives facilities for preparing documents containing a mixture of narrative and mathematical material.
Theory listings may be automatically included in such documents, giving a precise summary of the mathematical content of specifications and of any theorems which have been proved.
Most of the FEF project deliverables are documents containing both narrative and the formal material defining a theory together with the theory listing.

The results of the formal treatment from the two phases are discussed in more detail in sections \ref{phase1results} and \ref{phase2results} below.

In addition to the formal documents themselves, a key output of the work  is the feedback to the DRA designers about security and other problems which were found during the course of the work. This is discussed briefly in Section \ref{issuesdetected}.
The document \cite{DS/FMU/FEF/002} gives a complete account.

\subsection{Phase 1 Results}\label{phase1results}

\subsubsection{Overview} \label{phase1resultsoverview}

The main specification work in Phase 1 was the specification of a specific, although quite abstract, system to which the Security Model is formally applicable.
This system, the SSQL Abstract Machine is intended to serve as a formal definition of the SSQL semantics.
The main proof work in Phase 1 was to prove that the SSQL Abstract Machine is secure in the sense of the Security Model.
The specification of the SSQL Abstract Machine is structured in such a way that the critical security features are separated out from the specification of detailed functionality.
This makes clearer what is and is not essential to security and simplifies security proofs.

Sections \ref{sm} to \ref{secureSSQL} below discuss the Phase 1 results and their significance in greater detail.

\subsubsection{Security Model} \label{sm}

The Security Model\cite{DS/FMU/FEF/003} defines a property, $secure$, of behavioural models of systems.
This is a `non-interference' formulation in which it is required that highly classified inputs do not `interfere' with the values of less highly classified outputs.
This property is later applied to state transition models via a process of behavioural abstraction.
The Security Model was actually formalised and agreed in advance of Phase 1 and was taken as the common overall statement of critical security requirements for both phases of the work.

\subsubsection{SSQL Semantics}  \label{ss}

The specification of the semantics of SSQL describes how the result of an SSQL query is computed from the state of the database, covering both the response returned to the user and the new state.

The specification of the semantics is factored into three components, two of which contain all the security-relevant details and one of which contains the features which are not relevant to security.
This structure is described in \cite{DS/FMU/017} Section 6.3.4.

Of the two security-relevant parts one (known as `hide' \cite{DS/FMU/FEF/005}) determines the constraints on read access to the database which apply at the clearance of the query submitted, and the other (`update' \cite{DS/FMU/FEF/005}) determines the constraints on write access to the database at the relevant clearance.
In the context of these constraints the detailed semantics of the query language (`process query' \cite{DS/FMU/FEF/014}) can be specified in a way which does not contribute to the complexity of the security proof.

The specification of `process query' is incomplete (that is, loose), in certain respects.
Of the four kinds of query ({\it insert}, {\it delete}, {\it update} and {\it select}), it is only for {\it select} that full details of the functionality are specified.  
The specifications together contain sufficient information to establish that the SSQL Abstract Machine of Section \ref{sam} will be secure however the omitted details are filled in, as demonstrated by the completion of the proof against the formal model of the security policy.
  
\subsubsection{SSQL Abstract Machine}\label{sam}

To establish conformance of the system to the policy a `behavioural model' of the system is required.
This is constructed in two stages from the components of the SSQL semantics.

In the first stage a model of the target system as a state transition system is constructed.
This is known as the `SSQL Abstract Machine'.

In the second stage an operation of `behavioural abstraction' is performed on this abstract machine to give a behavioural model of the kind required in the security model.

The SSQL Abstract Machine consists of two parts:

\begin{itemize}
\item
The transition function.
\item
The initial state of the system.
\end{itemize}

The transition function is constructed from the three components of the SSQL semantics.
A view of the database state is constructed which hides anything not in the user's clearance (using the `hide' component of the semantics).
The query is then processed against this view (and thus with `no read up') using the `process query' component.
The results of the query are then applied to the database using the `update' component of the semantics, which also computes the output to be supplied to the user.
The `update' component is responsible for ensuring that there is no `write down'.

The initial state is loosely specified as conforming only to essential security invariants on the state.

The SSQL abstract machine is documented in \cite{DS/FMU/FEF/006} under the name of $SSQLam$. 

\subsubsection{Theorem about $SSQLam$}\label{secureSSQL}

The following theorem is proved as the key result in Phase 1:

=GFT
	Ù behaviours SSQLam ç secure
=TEX

A theorem is expressed in {\ProductHOL} as an optional list of assumptions followed by the turnstile symbol, ``Ù'', followed by a formula, called the conclusion of the theorem.
The theorem is the assertion that the conclusion is true provided all the assumptions are.
The {\Product} system ensures that the only theorems which can be computed are ones which have been derived from an identifiable list of axioms and definitions via mathematically sound rules of reasoning.
In this case, there are no assumptions, and the conclusion expresses a relationship between three named objects whose definitions form part of the Phase 1 specification work.
The theorem asserts that the result of applying the behavioural abstraction operation, $behaviours$, to the SSQL Abstract Machine, $SSQLam$ produces a system which belongs to the set, $secure$, of systems which conform to the Security Model.

The proof is documented in \cite{DS/FMU/FEF/015} under the name $secureSSQL$.
The proof comprises a formal validation of the fact expressed by the above theorem, viz., that the behaviours of the abstract-state machine $SSQLam$ satisfy the information-flow constraints imposed by the Security Model of Section \ref{sm}.   
\subsection{Phase 2 Results} \label{phase2results}

\subsubsection{Overview} \label{phase2resultsoverview}

In the Phase 2 specifications, various aspects of the actual Front End implementation of SWORD were modelled with a view to doing relevant proof work to discover security problems in the design.
The specifications were structured to expose security critical aspects of the design so that proof work could be done in the areas where most benefit was likely to be derived.
At the top level a formal model is given of the overall system architecture.
This gives rise to a decomposition of the critical security properties into properties of the top level subsystems of the actual Front End design;
it also gives an opportunity to verify that the critical properties on the subsystems are sufficient for overall system security.
However, these subsystems do not partition conveniently into security-critical and non-critical parts.
At the next level down the interactions between the subsystems were investigated by relating them to a slightly more abstract view of query execution.
At the third level, the constraints on query execution are re-expressed in terms of an explicit model which can be directly related to the SSQL syntax and which specifies precisely the security-relevant computations which are to be performed when a query is executed.

The main proof work was done at the third level, to prove that the model satisfies information-flow constraints which, intuitively, at least, bear a close relationship with the overall Security Model.
Proof work was also done to give a partial proof that these information-flow constraints are sufficient to ensure conformance of the system to the security requirements.
This amounts to showing that satisfaction of the information-flow constraints, together with some plausible assumptions about other aspects of the system, does entail that a system constructed according to the architectural model will conform to the Security Model.
A small amount of pilot proof work was carried out at the other two levels (however, the proof work at the top-level is not further discussed below).

Sections \ref{soa} to \ref{Thv} below discuss the Phase 2 results and their significance in greater detail.


\subsubsection{Specification of Architecture}  \label{soa}
Specification of the architecture of a DBMS, as a construction in terms of specified subsystems.  The construction itself is called $FE\_SWORD$, \cite{DS/FMU/FEF/022},  and the architectural subsystems are 
    \begin{itemize}
    \item  $TSQLtf$,  \cite{DS/FMU/FEF/021}, corresponding to a ``conventional DBMS'',
           implementing  $TSQL$.    This may or may not be implemented in reality by a ``standard commercial DBMS'', and so            to avoid taking a position on this issue this architectural component will here be called  the ``TSQL engine''.
    \item  $STP$  (``SSQL Transformation Processor'', \cite{DS/FMU/FEF/029}) which transforms queries input in SSQL to queries in TSQL to be submitted to the TSQL engine. 
    \item  $outputFilter$,   \cite{DS/FMU/FEF/024}, which sanitises results from the TSQL engine before passing them back to the user. 
\end{itemize}

The construction also requires a state-representation function, specified as $reprState$ in \cite{DS/FMU/FEF/025}.

\subsubsection{Specification of Security-Critical Properties}  \label{scp}
Specification of security-critical properties of the architectural construction and subsystems.   These are documented in \cite{DS/FMU/FEF/022} under the names:
\begin{center}
\begin{tabular}{l}
$subsys\_secure$  \\  
$subsys\_secureA$ \\
$subsys\_secureB$ \\
$subsys\_secureC$ \\
$subsys\_secureD$ \\
$subsys\_secureE$ \\
\end{tabular}
\end{center}

\subsubsection{Subsystem Lemmas} \label{subsystemlemmas}

The statement of a collection of lemmas, which may be called the `subsystem' lemmas.  Taken together, these lemmas assert that  the security-critical properties (Section \ref{scp} above) are true of the construction and subsystems of the architecture. 

Thus a proof of security assuming the lemmas will be a proof of the correctness of the architectural structuring as a first design-step. Since the lemmas are stated in terms of specifications of the individual subsystems of the architecture, they represent proof-obligations which are carried forward to later design-steps.  The subsystem lemmas are documented in \cite{DS/FMU/FEF/034} under the names:

\begin{center}
\begin{tabular}{l}
$Architecture\_Secure$  \\  
$Subsys\_SecureA$ \\
$Subsys\_SecureB$ \\
$Subsys\_SecureC$ \\
$Subsys\_SecureD$ \\
$Subsys\_SecureE$ \\
\end{tabular}
\end{center}
 
\subsubsection{Specification of $FE\_SWORD\_SYSTEM$} \label{soFESS}

$FE\_SWORD\_SYSTEM$ is a DBMS; it is  the architectural construction applied to the architectural subsystems. It is defined in \cite{DS/FMU/FEF/034}.

\subsubsection{Proof of $Theorem1$}
$Theorem1$, stated and proved in \cite{DS/FMU/FEF/034}, is  

=GFT
	Architecture_Secure,   
	Subsys_SecureA,
	Subsys_SecureB,
	Subsys_SecureC,
	Subsys_SecureD,
	Subsys_SecureE
	Ù  FE_SWORD_SYSTEM_secure
=TEX

Here there are 6 assumptions, namely the subsystem lemmas described in Section \ref{subsystemlemmas} above.
The conclusion of the theorem here is the boolean term $FE\_SWORD\_SYSTEM\_secure$.
This is defined in \cite{DS/FMU/FEF/034} to be equivalent to $FE\_SWORD\_SYSTEM \in secure$, (and so the theorem has a similar form to the main theorem, $secureSSQL$,  of Phase 1, discussed in Section \ref{secureSSQL}).
This result shows that the architecture specified is correct with regard to the Security Model. In other words,  the security-critical requirements on the subsystems and the construction have been correctly identified in that they are indeed sufficient to ensure the security of the constructed DBMS. 

\subsubsection{Specification of Execution Model}

What is called the `Execution Model' represents a conceptual step in the development process following on from the Architecture definition.  The Execution Model  may be described as a specification of a new constraint on the architectural subsystems  $TSQLtf$ and $STP$.  The purpose of the constraint is to provide an alternative to the somewhat intractable semantics of TSQL for use in the further formal modelling. 

The Execution Model is documented in \cite{DS/FMU/FEF/026} through the specification of three new objects: $EM_1$,  $compile$ and $upd$.  $EM_1$ is a constant, while $compile$ and $update$ are variables (representing subsystems whose detailed specification is not available).
$EM_1$ is a construction function for composing the two subsystems $compile$ and $upd$.
$compile$ models compilation a query to give a formal representation of a database operation; $upd$ models the use of the result of $compile$ to update a database state.
$EM_1$ composes the two subsystems by compiling and executing a query, using $update$ to modify the database state or ``outputting'' the result of a select query as appropriate. 
A loose specification for $compile$ and $upd$ is given by a definition of correctness relative to the TSQL semantics:
 
=GFT
	Correct_Compile  = {(compile, upd) | EMâ1 compile upd = TSQLtf}
=TEX

\subsubsection{Reduction of Proof-Obligations: $Theorem4$}\label{componentlemmas} \label{theoremiv}

Further development, on the familiar recursive pattern,  consists of a design-decomposition of a subsystem into components, together with further correctness-proof work to reduce the subsystem proof-obligations to component proof-obligations. 

In this case,  the subsystems in question are $TSQLtf$ and $STP$, taken together, and the components in question are $EM_1$,  $compile$ and $upd$. Use is made of the definitions of the Execution Model to show that the lemma $Subsys\_SecureE$ can be reduced to  three lemmas, called:

\begin{center}
\begin{tabular}{l}
$EM\_SecureE$   \\ 
$Correct\_Compile\_OkSTP$ \\
$TableComputationsSecure$
\end{tabular}
\end{center}

These lemmas are documented in \cite{DS/FMU/FEF/034}, and the relevant theorem is  stated and proved in \cite{DS/FMU/FEF/034} as  $Theorem4$:    
=GFT
	Architecture_Secure,   
	Subsys_SecureA,
	Subsys_SecureB,
	Subsys_SecureC,
	Subsys_SecureD,
	EM_SecureE,  
	Correct_Compile_OkSTP,
	TableComputationsSecure
	Ù  FE_SWORD_SYSTEM_secure
=TEX

which may be compared with $Theorem1$ above.
The approach here is that of so-called ``partial proofs'', in which a partial attack is made on a verification problem by successively attacking the assumptions of an initial theorem (typically vacuous: $P\,Ù\,P$).
The goal being to replace each assumption of the initial theorem with zero or more assumptions which are more plausible, or which constrain fewer or simpler components of the system.

The significance of this theorem is that assumption $Subsys\_SecureE$ of $Theorem1$  has been shown to be reducible to a condition, $EM\_SecureE$ on  $EM_1$, provided that:

\begin{itemize}
\item  $STP$ is related in a certain way to $compile$, the relationship being that specified in the definition of $Correct\_Compile\_OkSTP$.
In essence, this says the the input-output behaviour of a select query at any state could equally well be computed by interpreting the query in the state according to a set of rules captured in the definition of a set of computations called $TableComputations$.
Subject to various modelling assumptions discussed in detail in \cite{DS/FMU/FEF/032}, the details of the definition of this set are based closely on the semi-formal definition of the query transformations specified informally in \cite{trans}.
In a certain sense, $TableComputations$ embodies a description of SSQL in terms of a relational algebra augmented with security features.
\item  All the computations in the set $TableComputations$, satisfy certain natural information-flow constraints, as specified in the definition of $TableComputationsSecure$.
\end{itemize}  

\subsubsection{$Theorem5$}   \label{Thv}
Further proof work results in reducing $Theorem4$ above to $Theorem5$ below, which is documented in \cite{DS/FMU/FEF/036}.
This result is ``the best partial proof of the overall system security'' achieved under the FEF project.

=GFT
	Architecture_Secure,   
	Subsys_SecureA,
	Subsys_SecureB,
	Subsys_SecureC,
	Subsys_SecureD,
	Viewât_secureE,
	outputFilter_secureE,
	Correct_Compile_OkSTP,
	Ù  FE_SWORD_SYSTEM_secure
=TEX

$Theorem5$, in comparison with $Theorem4$, represents progress in the following respects:

\begin{itemize}
\item The assumption $TableComputationsSecure$ has disappeared, since it has been proved as a theorem, as documented in \cite{DS/FMU/FEF/036}.
This indicates that the bottom level of proof work as discussed in Section \ref{phase2resultsoverview} is complete --- the SSQL relational algebra satisfies the information-flow constraints imposed upon it.
\item The assumption $EM\_SecureE$ has been replaced by two new assumptions $View_t\_secureE$ and $outputFilter\_secureE$.
This indicates partial progress on the second level of proof work and reflects a reduction of the assumption $EM\_SecureE$ of $Theorem4$ to conditions, $View_t\_secureE$ and $outputFilter\_secureE$ on two of the constituents of $EM_1$.
\end{itemize}
  
\subsection{Phase 3 Results}

The main technical aim of phase 3 was to clarify by formal specification and proof the ideas of the DRA paper \cite{securityprops}.
This paper is concerned with the support which SWORD provides for database queries and results which are themselves structured multi-level objects.
There are two main aspects to this: the multi-level security policy and the result labelling property.
The multi-level security policy is intended to generalise the security policy which was used in phases 1 and 2.
The result labelling property is intended to give a formal description of the intentions behind the classification information appearing within the tables which are the outputs from queries to SWORD.
In essence, the idea is that the classification associated with a field in a table should indicate to the client the classification of the data in the field.
While the intuitions behind this idea are clear in simple cases, it turns out that of the required property is somewhat tricky to define in general (as is discussed in the postscript to \cite{securityprops}.

In phase 3 the multi-level security policy was addressed at two levels:
at an abstract level, a ``generic'' policy was formulated and a few of its theoretical properties were investigated; at a more concrete level, a high-level architectural model of SWORD was described.
The architectural model also served to give a framework for defining the result labelling property.

A more detailed discussion of the phase 3 technical work is given in the document \cite{DS/FMU/FEF/046}, which also serves as an introduction to the specifications produces during phase 3.
\cite{DS/FMU/FEF/046} also discusses the technical conclusions which can be drawn from the phase 3 work.

\subsection{Issues Detected} \label{issuesdetected}

The main issues with the SSQL and Front End designs which were detected during the project are described and discussed in \cite{DS/FMU/FEF/002}.
For present purposes these may conveniently be classified and summarised as follows::

\begin{itemize}
\item
{\bf Syntax and type checking errors:} the bulk of the design was conveyed to ICL in a semi-formal notation; transcription of this into a machine-checked formal language revealed errors such as misspellings of names, failure to pass arguments correctly, and omission of auxiliary definitions.
While none of these problems cause the system as specified to be demonstrably insecure, they are likely to prevent a proof of security from going through, and make a proper judgement about security difficult.
In some cases the correction is obvious and the problem would therefore be unlikely to result in an insecure implementation, but in other cases it is less clear how the problem should be resolved.
In these cases there is a greater risk that a misunsdertanding might arise which would cause the implementation to be insecure.

This type of problem is detected automatically as the design is transcribed and checked using the {\Product} tool.

Approximately 30 problems of this class were reported in Phase 1 and about the same number in Phase 2.

\item
{\bf Incompleteness:} for example, security of the query transformations of \cite{trans} relies on the system not loading into its symbol tables information about directories and tables which the client is not cleared to see; this was not made explicit in the design material.
The detection of this type of error depends on whether an object is just referenced and not defined (in which case the tool will flag the omission) or whether an object is inappropriately given a dummy definition (in which case the significance of the omission may not become apparent until proof is attempted).

Some 13 problems of this class were reported in Phase 1 and 6 in Phase 2.
Perhaps 5 or 6 of the 7 Phase 2 problems were directly relevant to security in that a security check was omitted from the design in a way which would lead directly to a violation of the Security Model if reflected in the implementation.

\item
{\bf Algorithmic errors:} for example, security of the overall system is crucially dependent on clearances of fields within derived tables being computed in a way which respects the possible flow of information into the field.
The functional requirements on SWORD mean that some of these computations are quite subtle.
This type of error, if it is security-relevant, is certain to be exposed during a full proof of security, and has a good chance of being exposed by partial proof work as carried out in Phase 2 if the area of attack is carefully chosen.

1 problem of this type was discovered in Phase 1 and 5 were discovered in Phase 2.
All but one of these problems were discovered during the proof work rather than during formulation of the specifications, and all would lead directly to a violation of the Security Model if reflected in the implementation.

\item
{\bf Modelling errors:} these are errors where the assumptions used to model a system themselves give rise to problems which would not actually arise in an implementation: an example in the FEF work was in the Phase 2 model of select query execution ($TableComputations$), which, in a sense, tries to recover from errors which cause execution to be aborted (or never initiated) in the implementation.

Only 1 significant problem of this type arose (viz., the above one).
\end{itemize}

\section{COST EFFECTIVENESS}\label{costeffectiveness}

This final report is required to address the cost effectiveness of the work undertaken on the FEF project.

Objective measures of cost effectiveness are difficult to establish in this context, partly because of the lack of comparative data, and partly becuase the SWORD project is still under way.
Full information on the impact of the formal treatment is therefore not yet available.

Since the work was undertaken on a fixed price basis, additional costs arising were absorbed by the contractor, except for costs arising from changes to the requirements.
By comparison with the expectations at the time of placing the contract, we believe that the project has exceeded expectations, in terms of the benefit realised.
It is therefore reasonable to argue that the cost-effectiveness of the work has exceeded expectations at the time of placing the contract.

The remainder of this section adds detail by mentioning some of the ways in which the benefits realised exeeded expectations.

\subsection{Phase 1}

During Phase 1 the required formal machine checked verification of the specifications of SSQL was achieved.
Thus `computerised mathematical theorem proving' was shown to be applicable in this system of `realistic size and complexity'.

Careful structuring of the specifications was however necessary to ensure that the required proofs were of manageable complexity.
The specification and proof work were undertaken in HOL using {\Product}, by experience personnel at ICL supported by senior consultants with more extensive experience.
If any of these crucial elements had been different then costs might have been substantially greater.
For example, at the time of bidding for the contract ICL believed that the cost of the proofs required in Phase 1 would have been greater by a factor of at least 10 if the proposed restructuring of the specifications had not been achievable.

During the course of the Phase 1 work many errors were detected and corrected.
The proof work therefore contributed to significant improvements in the quality of the specifications.
Had these specifications been originally developed using fully formal notations and appropriate supporting tools, this benefit would have been realised probably within the cost of the original specification work.

\subsection{Phase 2}

When the complexity of the specifications involved in the Phase 2 work was clear full formal proofs of correctness were judged to be unrealisable within reasonable costs, and more selective formal analysis was therefore undertaken.

The revised objective for this phase was to use the formal modelling work to discover flaws in the specifications, and by this means to evolve the specifications as necessary to eliminate any flaws discovered.

The work was successful in discovering a number of problems and in general the errors found were more significant than those found in Phase 1.


\subsection{Phase 3}
 
The technical work in phase 3 was essentially research into certain issues in formal modelling of security-relevant properties of a system such as SWORD.
The cost-effectiveness of this research can therefore only be conjectured by considering its likely relevance in a future work on systems similar to SWORD.

Certain parts of the phase 3 formal specifications and proofs would be directly reusable in an appropriate context: e.g., the ``generic'' formulation of the security policy.
The technical approach used in other parts of the work could also be exploited by using it as a paradigm in applications where the formal material was not directly reusable.
In particular, the treatment of the result labelling property could be adapted if it was required to capture formally the significance of classification labels like those which appear within SWORD tables.

\pagebreak
\section{CONCLUSIONS} \label{oac}

Under the FEF contract the SWORD multi-level secure RDBMS has been subject to extensive formal modelling to validate the security aspects of the design, including the completion of a number of formal proofs about aspects of the specification and design.

The FEF contract has achieved its original objectives and has yielded benefits beyond those anticipated.

The following conclusions are suggested:

\begin{itemize}
\item
That the use of formal methods involving the development of machine checked formal proofs is feasible on projects of this kind.
\item
That great care should be taken in the structuring of specifications to improve the clarity with which they address critical issues.
This reduces the costs and increases the benefits obtained from formal proof development.
\item
That careful modelling of selected aspects of the system can enable useful proof work even where the overall complexity would make less subtle approaches prohibitively expensive.
\item
That greater benefits are realisable if formal languages and tools are introduced at the earliest possible stage in the development process.
In particular, use of formal notations and tools during specification and design where appropriate rather than as a post-hoc exercises would be likely to be more cost effective.
\end{itemize} 


\end{document}




