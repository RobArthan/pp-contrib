=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DRA FRONT END FILTER PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Proof of Security (IIe)}  %% Mandatory field
\TPPref{DS/FMU/FEF/015}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Approved}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document completes the formal proof of security for Phase 1 of the
DRA front end filter project RSRE 1C/6130.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File \\
	Simon Wiseman
}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion(\FormatDate{$Date$
})]First approved version.
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document completes the  formal Phase 1 proof  that  
the behaviour of the SSQL abstract machine is secure. 
It constitutes part of deliverable D6 
of work package 1c, as given
in section 7 of the Secure Database Technical Proposal, \cite{DS/FMU/017}.

\subsection{Introduction}

This document is a proof script which provides a formal proof that the behaviour of the SSQL abstract machine is secure.

In the proof strategy document, \cite{DS/FMU/FEF/007}, we state the $main\_thm$:

=GFT HOL output
main_thm = Ù  Lemma1 ± Lemma3 ± Lemma4 ± Lemma5 ¥ behaviours SSQLam ç secure
=TEX

This result is progressed by the proofs of $Lemma3$, $Lemma4$ and $Lemma5$ in
the unwinding proof document \cite{DS/FMU/FEF/009} to give $main\_thm1$:

=GFT HOL output
main_thm1 = Ù  Lemma1 ¥ behaviours SSQLam ç secure
=TEX

$Lemma1$ is the requirement on the critical components  $hide$ and $updateState$.

{\bf Lemma1}
=GFT 
	?Ù 	hide ç secureHide ± (hide,updateState) ç secureUpdate
=TEX

In \cite{DS/FMU/FEF/010}, a formal proof of the first conjunct of $Lemma1$  is given.
In \cite{DS/FMU/FEF/011}, formal proofs of the third and fourth conjuncts of the second
conjunct of $Lemma1$ are given. In \cite{DS/FMU/FEF/012} and \cite{DS/FMU/FEF/013},
formal proofs of the first and second conjuncts of the second
conjunct of $Lemma1$ are given	 for $hideR$ and $updateStateR$. In this 
document, we prove $Lemma1$ by using the results from \cite{DS/FMU/FEF/010}, \cite{DS/FMU/FEF/011}, 
\cite{DS/FMU/FEF/012} and \cite{DS/FMU/FEF/013} together with a formal proof that $updateStateR$ maintains the invariant
on the representation state.



\section{PRELIMINARIES}
The following \Product{} instructions set up the new theory $fef015$.

=SML 
open_theory "fef013";
new_theory€"fef015"›;
push_merge_pcs["hol","wrk049","wrk049a","'pair1"] ;
=TEX
\section{$Lemma1$}

\subsection{Relationship between $updateState$ and $updateStateR$} \label{REL}

We first prove that if $updateStateR$ maintains the invariant
on the representation state, then $hide$  and $updateState$ satisfy the relation
$secureUpdate$.


=SML
push_goal([],
	¨(µ clear s u ∑ isState s ¥ isState(Fst(updateStateR(clear,u,s)))) 
	¥ (hide,updateState) ç secureUpdateÆ);
a(REPEAT strip_tac THEN rewrite_tac[conjunct4,secureUpdate_def,hide_def]);
a(LEMMA_T¨(µ c sâ1 sâ2 e
             ∑ absState (hideR (c, repState sâ1))
                   = absState (hideR (c, repState sâ2))
                 ¥ Snd (updateState (c, e, sâ1)) = Snd (updateState (c, e, sâ2)))Æ
	rewrite_thm_tac);
=TEX
=SML
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨sâ1ÆisState_lemma));
a(strip_asm_tac(µ_elim¨sâ2ÆisState_lemma));
a(bc_tac[conjunct3,eq_sym_rule(all_µ_elim hide_eq_lemma)]);
a(fc_tac[hideR_lemma]);
a(spec_nth_asm_tac 2 ¨cÆ);
a(spec_nth_asm_tac 2 ¨cÆ);
a(strip_asm_tac(list_µ_elim[¨hideR (c, repState sâ1)Æ,¨hideR (c, repState sâ2)Æ]isState_lemma2));
=TEX
=SML
(* *** Goal "2" *** *)
a(LEMMA_T¨µ câ1 câ2 sâ1 sâ2 e
             ∑ absState (hideR (câ1, repState sâ1))
                     = absState (hideR (câ1, repState sâ2))
                   ± câ1 dominates câ2
                 ¥ absState
                     (hideR (câ1, repState (Fst (updateState (câ2, e, sâ1)))))
                   = absState
                     (hideR (câ1, repState (Fst (updateState (câ2, e, sâ2)))))Æ
	rewrite_thm_tac);
=TEX
=SML
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨sâ2ÆisState_lemma));
a(strip_asm_tac(µ_elim¨sâ1ÆisState_lemma));
a(fc_tac[hideR_lemma]);
a(spec_nth_asm_tac 2 ¨câ1Æ);
a(spec_nth_asm_tac 2 ¨câ1Æ);
a(strip_asm_tac(list_µ_elim[¨hideR (câ1, repState sâ1)Æ,
	¨hideR (câ1, repState sâ2)Æ]isState_lemma2));
a(LEMMA_T¨e = (Fst e,Snd e)Æ pure_once_asm_rewrite_thm_tac 
	THEN_LIST[rewrite_tac[],rewrite_tac[updateState_def]]);
a(list_spec_nth_asm_tac 10[¨câ2Æ,¨repState sâ1Æ,¨eÆ]);
a(list_spec_nth_asm_tac 11[¨câ2Æ,¨repState sâ2Æ,¨eÆ]);
a(fc_tac[conjunct2]);
a(list_spec_nth_asm_tac 1[¨câ2Æ,¨eÆ]);
a(fc_tac[isState_lemma1]THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "2.2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨sÆisState_lemma));
a(fc_tac[hideR_lemma]);
a(spec_nth_asm_tac 1 ¨câ2Æ);
a(DROP_NTH_ASM_T 4 ante_tac);
a(LEMMA_T¨e = (Fst e,Snd e)Æ pure_once_asm_rewrite_thm_tac 
	THEN_LIST[rewrite_tac[],rewrite_tac[updateState_def]]);
a(asm_fc_tac[]);
a(list_spec_nth_asm_tac 2[¨câ1Æ,¨eÆ]);
a(fc_tac[hideR_lemma]);
a(spec_nth_asm_tac 1 ¨câ2Æ);
a(fc_tac[isState_lemma1]THEN asm_rewrite_tac[]);
a(¥_tac THEN swap_nth_asm_concl_tac 1);
a(strip_asm_tac(list_µ_elim[¨hideR (câ2, repState s)Æ,
	¨hideR (câ2, Fst (updateStateR (câ1, e, repState s)))Æ]isState_lemma2));
a(fc_tac[conjunct1]);
val €updateStateR_updateState_lemma› = save_pop_thm"updateStateR_updateState_lemma";
=TEX
=GFT HOL output
updateStateR_updateState_lemma = 
Ù (µ clear s u
    ∑ isState s ¥ isState (Fst (updateStateR (clear, u, s))))
    ¥ (hide, updateState) ç secureUpdate
=TEX
\subsection{Proof that the Invariant on the State is Maintained} \label{INV}
We now prove that the invariant on the representation state is maintained.
\subsubsection{$insertQuery$ Lemma}
=SML
push_goal([],¨µ c i ns s ts ∑ isState s ± tabExists c i s 
	¥ isState(Fst(insertQuery(c,(i,ds),s,getTable i s)))Æ);
a(rewrite_tac[get_spec¨isStateÆ,get_spec¨StateSÆ,ﬂ_def,°_def,
	rewrite_rule[dom_def]tabExists_def,getTable_def] 
	THEN REPEAT µ_tac THEN strip_tac);
a(LIST_DROP_NTH_ASM_T[2,3](MAP_EVERY (fn _ => id_tac))); 
a(strip_asm_tac(list_µ_elim[¨sÆ,¨Front iÆ,¨yÆ]at_thm1));
a(rewrite_tac[insertQuery_def,changeSpec_def]);
=TEX
=SML
a(cases_tac¨≥ Elems
                             (Map
                                 (MkRow c
                                     o colDefaults
                                       c
                                       (Dir_tables
                                             (s @ Front i)
                                           @ Last i))
                                 ds)
                           Ä RowSÆ
	THEN asm_rewrite_tac[]);
a(POP_ASM_T ante_tac THEN DROP_NTH_ASM_T 2 ante_tac 
	THEN POP_ASM_T rewrite_thm_tac THEN REPEAT strip_tac);
=TEX
=SML
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 5 ante_tac THEN 
	rewrite_tac[™_def,get_spec¨IdeLÆ,get_spec¨DirectorySÆ,°_def,∏_def,
	get_spec¨UniverseÆ,rel_ext_clauses,get_spec¨$Æ]THEN REPEAT ¥_tac);
a(asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac[ﬂ_def,°_def,´_single]
	THEN REPEAT strip_tac);
=TEX
=SML
(* *** Goal "1.1" *** *)
a(POP_ASM_T rewrite_thm_tac THEN rewrite_tac[get_spec¨MkDirectoryÆ]);
a(strip_asm_tac(list_µ_elim[¨Dir_tables yÆ,¨Last iÆ,¨y'Æ]at_thm1));
a(DROP_NTH_ASM_T 6 ante_tac THEN POP_ASM_T rewrite_thm_tac THEN ¥_tac);
a(DROP_NTH_ASM_T 4 ante_tac THEN 
	rewrite_tac[™_def,get_spec¨IdeÆ,conv_rule(MAP_C let_conv)(get_spec¨TableSpecSÆ),
	°_def,∏_def,get_spec¨UniverseÆ,rel_ext_clauses,get_spec¨$Æ]
	THEN REPEAT ¥_tac);
a(rewrite_tac[´_single]THEN strip_tac THEN strip_tac THEN strip_tac);
=TEX
=SML
(* *** Goal "1.1.1" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(rewrite_tac[replaceRows_def,get_spec¨MkTableSpecÆ]);
a(asm_fc_tac[]THEN REPEAT strip_tac);
a(fc_tac[çâl_Î_thm] THEN asm_fc_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[çâl_elems_thm]));
a(fc_tac[Ä_def] THEN asm_fc_tac[]);
=TEX
=SML
(* *** Goal "1.1.2" *** *)
a(asm_fc_tac[]THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(POP_ASM_T rewrite_thm_tac THEN rewrite_tac[get_spec¨MkDirectoryÆ]);
a(DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac[functional_def,´_single]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(asm_fc_tac[] THEN asm_fc_tac[]);
(* *** Goal "1.3" *** *)
a(asm_fc_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[ﬂ_def,°_def]));
(* *** Goal "1.4" *** *)
a(asm_fc_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[ﬂ_def,°_def]));
=TEX
=SML
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 ante_tac THEN rewrite_tac[functional_def,´_single]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(asm_fc_tac[] THEN asm_fc_tac[]);
val €isState_insertQuery_lemma› = save_pop_thm"isState_insertQuery_lemma";
=TEX
=GFT HOL output
isState_insertQuery_lemma =
Ù µ c i ns s ts
  ∑ isState s ± tabExists c i s
      ¥ isState (Fst (insertQuery (c, (i, ds), s, getTable i s)))
=TEX

\subsubsection{$deleteQuery$ Lemma}
=SML
push_goal([],¨µ c i ns s ts ∑ isState s ± tabExists c i s 
	¥ isState(deleteQuery(c,(i,ns),s,getTable i s))Æ);
a(rewrite_tac[get_spec¨isStateÆ,get_spec¨StateSÆ,ﬂ_def,°_def,
	rewrite_rule[dom_def]tabExists_def,getTable_def] 
	THEN REPEAT µ_tac THEN strip_tac);
a(LIST_DROP_NTH_ASM_T[2,3](MAP_EVERY (fn _ => id_tac))); 
a(strip_asm_tac(list_µ_elim[¨sÆ,¨Front iÆ,¨yÆ]at_thm1));
a(rewrite_tac[deleteQuery_def,changeSpec_def]);
a(DROP_NTH_ASM_T 2 ante_tac THEN POP_ASM_T rewrite_thm_tac 
	THEN REPEAT strip_tac);
=TEX
=SML
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 ante_tac THEN 
	rewrite_tac[™_def,get_spec¨IdeLÆ,get_spec¨DirectorySÆ,°_def,∏_def,
	get_spec¨UniverseÆ,rel_ext_clauses,get_spec¨$Æ]THEN REPEAT ¥_tac);
a(asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac[ﬂ_def,°_def,´_single]
	THEN REPEAT strip_tac);
=TEX
=SML
(* *** Goal "1.1" *** *)
a(POP_ASM_T rewrite_thm_tac THEN rewrite_tac[get_spec¨MkDirectoryÆ]);
a(strip_asm_tac(list_µ_elim[¨Dir_tables yÆ,¨Last iÆ,¨y'Æ]at_thm1));
a(POP_ASM_T rewrite_thm_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN 
	rewrite_tac[™_def,get_spec¨IdeÆ,conv_rule(MAP_C let_conv)(get_spec¨TableSpecSÆ),
	°_def,∏_def,get_spec¨UniverseÆ,rel_ext_clauses,get_spec¨$Æ]
	THEN REPEAT ¥_tac);
a(rewrite_tac[´_single]THEN strip_tac THEN strip_tac THEN strip_tac);
=TEX
=SML
(* *** Goal "1.1.1" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(rewrite_tac[replaceRows_def,get_spec¨MkTableSpecÆ]);
a(asm_fc_tac[]THEN REPEAT strip_tac);
a(fc_tac[çâl_extract_thm] THEN asm_fc_tac[]);
(* *** Goal "1.1.2" *** *)
a(asm_fc_tac[]THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "1.2" *** *)
a(POP_ASM_T rewrite_thm_tac THEN rewrite_tac[get_spec¨MkDirectoryÆ]);
a(DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac[functional_def,´_single]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(asm_fc_tac[] THEN asm_fc_tac[]);
(* *** Goal "1.3" *** *)
a(asm_fc_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[ﬂ_def,°_def]));
(* *** Goal "1.4" *** *)
a(asm_fc_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[ﬂ_def,°_def]));
=TEX
=SML
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN rewrite_tac[functional_def,´_single]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(asm_fc_tac[] THEN asm_fc_tac[]);
val €isState_deleteQuery_lemma› = save_pop_thm"isState_deleteQuery_lemma";
=TEX
=GFT HOL output
isState_deleteQuery_lemma =
Ù µ c i ns s ts
  ∑ isState s ± tabExists c i s
      ¥ isState (deleteQuery (c, (i, ns), s, getTable i s))
=TEX
\subsubsection{Update Lemmas}
=SML
push_goal([],¨µ r c tc u ∑ r ç RowS ± isVal(updateRow c tc (u, r))
	¥ destVal (updateRow c tc (u, r)) ç RowSÆ);
a(REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[isVal_def]));
a(asm_rewrite_tac[destVal_def]);
a(POP_ASM_T ante_tac THEN rewrite_tac[updateRow_def]);
a(cases_tac¨≥ u ç FunctionalÆ THEN
	cases_tac¨((RelCombine u (R_data r)
                           ª Graph (updateField c tc))
                         í {x|isError x})
                       ª Graph destError
                     = {}Æ
	THEN asm_rewrite_tac[≥giveError_eq_giveVal_thm,giveVal_eq_thm]);
a(¥_T (rewrite_thm_tac o eq_sym_rule));
a(DROP_NTH_ASM_T 3 ante_tac THEN rewrite_tac[get_spec¨RowSÆ]
	THEN conv_tac(MAP_C let_conv) 
	THEN PC_T1 "hol1"rewrite_tac[™_def,∏_def,get_spec¨NumÆ,get_spec¨DataSÆ,ﬂ_def]);
a(rewrite_tac[get_spec¨MkRowÆ,functional_def,´_thm,rel_combine_def]);
a(REPEAT strip_tac);
=TEX
=SML
(* *** Goal "1" *** *)
a(asm_fc_tac[]THEN asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_fc_tac[]THEN asm_fc_tac[]);
(* *** Goal "3" *** *)
a(asm_fc_tac[]THEN asm_fc_tac[]);
(* *** Goal "4" *** *)
a(DROP_NTH_ASM_T 11(strip_asm_tac o rewrite_rule[functional_def]));
a(asm_fc_tac[]THEN asm_fc_tac[]);
a(asm_rewrite_tac[]);
a(LEMMA_T¨z'' = (Fst z'',Snd z'')Æ pure_once_asm_rewrite_thm_tac 
	THEN_LIST[rewrite_tac[],id_tac]);
a(LEMMA_T¨z'''' = (Fst z'''',Snd z'''')Æ pure_once_asm_rewrite_thm_tac 
	THEN_LIST[rewrite_tac[],rewrite_tac[]]);
val €isState_updateRow_lemma› = save_pop_thm"isState_updateRow_lemma";
=TEX
=GFT HOL output
isState_updateRow_lemma = Ù µ r c tc u
  ∑ r ç RowS ± isVal (updateRow c tc (u, r))
      ¥ destVal (updateRow c tc (u, r)) ç RowS
=TEX
=SML
push_goal([],¨µ r c t u ∑ 
	u ç Functional 
	± ((RelCombine
               (Á~Í (revealRow c t) ª u)
                     (ListRel (TS_rows t))
                   ª Graph (updateRow c (TS_class t)))
                 í {x|isError x})
               ª Graph destError
             = {}
	± (µ r∑ r çâl (TS_rows t) ¥ r ç RowS)
	¥ (r
             çâl (RelList
                   (ListRel (TS_rows t)
                       ´ (RelCombine
                           (Á~Í (revealRow c t) ª u)
                           (ListRel (TS_rows t))
                         ª Graph (updateRow c (TS_class t)))
                       ª Graph destVal)) ¥ r ç RowS)Æ);
=TEX
=SML
a(rewrite_tac[revealRow_def]THEN REPEAT µ_tac);
a(lemma_tac¨∂ l ∑ TS_rows t = lÆTHEN_LIST
	[prove_∂_tac,POP_ASM_T rewrite_thm_tac]);
a(REV_LIST_INDUCTION_T¨lÆasm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[çâl_def,´_null_thm2,rel_list_null_thm]THEN REPEAT strip_tac);
=TEX
=SML
(* *** Goal "2" *** *)
a µ_tac;
a(cases_tac¨c dominates R_exist lastÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(fc_tac[rel_combine_null_lemma]);
a(lemma_tac¨(µ r∑ r çâl l ¥ r ç RowS) ± last ç RowSÆ);
(* *** Goal "2.1.1" *** *)
a(REPEAT strip_tac);
(* *** Goal "2.1.1.1" *** *)
a(spec_nth_asm_tac 4 ¨r'Æ);
(* *** Goal "2.1.1.2" *** *)
a(spec_nth_asm_tac 3 ¨lastÆ);
(* *** Goal "2.1.2" *** *)
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[]
	THEN ¥_T asm_tac);
a(DROP_NTH_ASM_T 5 ante_tac);
a(cases_tac¨∂ up ∑ (#(Squash (Id (Dom (ListRel (l Î [last])
                                                   í {r|c dominates R_exist r})))),up) ç uÆ);
=TEX
=SML
(* *** Goal "2.1.2.1" *** *)
a(strip_asm_tac(list_µ_elim[¨cÆ,¨lastÆ,¨lÆ,¨upÆ,¨uÆ,¨tÆ]conjunct1_lemma2)
	THEN POP_ASM_T rewrite_thm_tac);
a(REPEAT strip_tac);
(* *** Goal "2.1.2.1.1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2.1.2.1.2" *** *)
a(lemma_tac¨isVal(updateRow c (TS_class t) (up, last))Æ);
(* *** Goal "2.1.2.1.2.1" *** *)
a(strip_asm_tac(µ_elim¨(updateRow c (TS_class t) (up, last))Æval_or_error_type));
a(DROP_NTH_ASM_T 10 (strip_asm_tac o rewrite_rule[rel_ext_clauses,rel_combine_def]));
a(list_spec_nth_asm_tac 1 [¨# l + 1Æ,¨destError(updateRow c (TS_class t) (up, last))Æ]);
a(spec_nth_asm_tac 1 ¨(updateRow c (TS_class t) (up, last))Æ);
a(POP_ASM_T(strip_asm_tac o rewrite_rule[] o µ_elim ¨(up, last)Æ));
=TEX
=SML
(* *** Goal "2.1.2.1.2.1.1" *** *)
a(spec_nth_asm_tac 1 ¨#(Squash (Id (Dom (ListRel (l Î [last])
                                                   í {r|c dominates R_exist r}))))Æ);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[inv_rel_def]);
a(strip_asm_tac(list_µ_elim[¨lÆ,¨lastÆ,¨{r|c dominates R_exist r}Æ]size_Î_one_thm));
(* *** Goal "2.1.2.1.2.1.2" *** *)
a(POP_ASM_T(strip_asm_tac o rewrite_rule[list_rel_def,dot_dot_def,
	length_Î_one_thm,nth_length_one_thm]));
(* *** Goal "2.1.2.1.2.2" *** *)
a(fc_tac[isState_updateRow_lemma] THEN asm_fc_tac[]);
a(asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "2.1.2.2" *** *)
a(LEMMA_T¨RelCombine(Á~Í(Squash(Id(Dom
		(ListRel(l Î [last]) í {r|c dominates R_exist r})))) ª u)
		(ListRel (l Î [last]))
	=
	RelCombine(Á~Í(Squash(Id(Dom
		(ListRel l í {r|c dominates R_exist r})))) ª u)
		(ListRel l )Æ rewrite_thm_tac);
=TEX
=SML
(* *** Goal "2.1.2.2.1" *** *)
a(asm_rewrite_tac[squash_Î_thm]);
a(LEMMA_T¨Á~Í{(#(Squash(Id (Dom(ListRel l í {r|c
			dominates R_exist r}))))
                                 + 1, # l + 1)}
                     ª u = {}Ærewrite_thm_tac);
(* *** Goal "2.1.2.2.1.1" *** *)
a(rewrite_tac[rel_ext_clauses,inv_rel_def]THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨yÆ);
a(DROP_NTH_ASM_T 4(fn _ => id_tac));
a(strip_asm_tac(list_µ_elim[¨lÆ,¨lastÆ,¨{r|c dominates R_exist r}Æ]size_squash_plus1_thm));
a contr_tac;
a(DROP_NTH_ASM_T 5 ante_tac THEN DROP_NTH_ASM_T 3 ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2.2.1.2" *** *)
a(rewrite_tac[rel_combine_one_lemma]);
=TEX
=SML
(* *** Goal "2.1.2.2.2" *** *)
a(strip_asm_tac(list_µ_elim[¨lÆ,¨lastÆ,¨cÆ,¨uÆ,¨tÆ]conjunct1_lemma1));
a(asm_rewrite_tac[]);
a(REPEAT strip_tac THEN asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(REPEAT strip_tac);
a(fc_tac[rel_combine_null_lemma]);
a(lemma_tac¨(µ r∑ r çâl l ¥ r ç RowS) ± last ç RowSÆ);
(* *** Goal "2.2.1" *** *)
a(REPEAT strip_tac);
(* *** Goal "2.2.1.1" *** *)
a(spec_nth_asm_tac 4 ¨r'Æ);
(* *** Goal "2.2.1.2" *** *)
a(spec_nth_asm_tac 3 ¨lastÆ);
=TEX
=SML
(* *** Goal "2.2.2" *** *)
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[]
	THEN ¥_T asm_tac);
a(DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac
	[rel_combine_one_lemma,squash_Î_thm]);
a(strip_asm_tac(list_µ_elim[¨lÆ,¨lastÆ,¨cÆ,¨uÆ,¨tÆ]conjunct1_lemma1));
a(asm_rewrite_tac[]);
a(REPEAT strip_tac THEN asm_fc_tac[]);
val €isState_updateRows_lemma› = save_pop_thm"isState_updateRows_lemma";
=TEX
=GFT HOL output
isState_updateRows_lemma = Ù µ r c t u
  ∑ u ç Functional
        ± ((RelCombine (Á~Í (revealRow c t) ª u) (ListRel (TS_rows t))
                ª Graph (updateRow c (TS_class t)))
              í {x|isError x})
            ª Graph destError
          = {}
        ± (µ r∑ r çâl TS_rows t ¥ r ç RowS)
      ¥ r
        çâl RelList
          (ListRel (TS_rows t)
              ´ (RelCombine
                  (Á~Í (revealRow c t) ª u)
                  (ListRel (TS_rows t))
                ª Graph (updateRow c (TS_class t)))
              ª Graph destVal)
      ¥ r ç RowS
=TEX
\subsubsection{$updateQuery$ Lemma}
=SML
push_goal([],¨µ c i us s ts ∑ isState s ± tabExists c i s 
	¥ isState(Fst(updateQuery(c,(i,us),s,getTable i s)))Æ);
a(rewrite_tac[get_spec¨isStateÆ,get_spec¨StateSÆ,ﬂ_def,°_def,
	rewrite_rule[dom_def]tabExists_def,getTable_def] 
	THEN REPEAT µ_tac THEN strip_tac);
a(LIST_DROP_NTH_ASM_T[2,3](MAP_EVERY (fn _ => id_tac))); 
a(strip_asm_tac(list_µ_elim[¨sÆ,¨Front iÆ,¨yÆ]at_thm1));
a(rewrite_tac[conv_rule(MAP_C let_conv)updateQuery_def,changeSpec_def]);
=TEX
=SML
a(cases_tac¨≥ us ç FunctionalÆ THEN asm_rewrite_tac[]);
a(cases_tac¨≥ Dom (ﬁ (Ran us))
                           Ä {n
                           |∂ c'
                             ∑ c'
                                   ç visibleCols
                                     c
                                     (Dir_tables y
                                         @ Last i)
                                 ± CS_posn c' = n}Æ
	THEN asm_rewrite_tac[]);
=TEX
=SML
a(cases_tac¨((RelCombine (Á~Í (revealRow c
                                           (Dir_tables y
                                               @ Last i))
                                     ª us)
                                 (ListRel
                                     (TS_rows
                                         (Dir_tables y
                                             @ Last i)))
                               ª Graph
                                 (updateRow
                                     c
                                     (TS_class
                                         (Dir_tables y
                                             @ Last i))))
                             í {x|isError x})
                           ª Graph destError
                         = {}Æ
	THEN asm_rewrite_tac[]);
=TEX
=SML
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac 
	THEN DROP_NTH_ASM_T 3 ante_tac 
	THEN DROP_NTH_ASM_T 2 rewrite_thm_tac 
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 7 ante_tac THEN 
	rewrite_tac[™_def,get_spec¨IdeLÆ,get_spec¨DirectorySÆ,
	°_def,∏_def,get_spec¨UniverseÆ,rel_ext_clauses,get_spec¨$Æ]
	THEN REPEAT ¥_tac);
a(asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac[ﬂ_def,°_def,´_single]
	THEN REPEAT strip_tac);
=TEX
=SML
(* *** Goal "1.1" *** *)
a(POP_ASM_T rewrite_thm_tac THEN rewrite_tac[get_spec¨MkDirectoryÆ]);
a(strip_asm_tac(list_µ_elim[¨Dir_tables yÆ,¨Last iÆ,¨y'Æ]at_thm1));
a(DROP_NTH_ASM_T 7 ante_tac THEN DROP_NTH_ASM_T 6 ante_tac
	THEN POP_ASM_T rewrite_thm_tac THEN REPEAT ¥_tac);
a(DROP_NTH_ASM_T 5 ante_tac THEN 
	rewrite_tac[™_def,get_spec¨IdeÆ,conv_rule(MAP_C let_conv)(get_spec¨TableSpecSÆ),
	°_def,∏_def,get_spec¨UniverseÆ,rel_ext_clauses,get_spec¨$Æ]
	THEN REPEAT ¥_tac);
a(rewrite_tac[´_single]THEN strip_tac THEN strip_tac THEN strip_tac);
=TEX
=SML
(* *** Goal "1.1.1" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(rewrite_tac[replaceRows_def,get_spec¨MkTableSpecÆ]);
a(list_spec_nth_asm_tac 2 [¨Last iÆ,¨y'Æ]);
a(REPEAT strip_tac);
a(fc_tac[isState_updateRows_lemma] THEN asm_fc_tac[]);
a(POP_ASM_T (ante_tac o µ_elim¨rÆ)THEN asm_rewrite_tac[]);
(* *** Goal "1.1.2" *** *)
a(asm_fc_tac[]THEN asm_rewrite_tac[]);
=TEX
=SML
(* *** Goal "1.2" *** *)
a(POP_ASM_T rewrite_thm_tac THEN rewrite_tac[get_spec¨MkDirectoryÆ]);
a(DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac[functional_def,´_single]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(asm_fc_tac[] THEN asm_fc_tac[]);
(* *** Goal "1.3" *** *)
a(asm_fc_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[ﬂ_def,°_def]));
(* *** Goal "1.4" *** *)
a(asm_fc_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[ﬂ_def,°_def]));
=TEX
=SML
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 6 ante_tac THEN rewrite_tac[functional_def,´_single]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(asm_fc_tac[] THEN asm_fc_tac[]);
val €isState_updateQuery_lemma› = save_pop_thm"isState_updateQuery_lemma";
=TEX
=GFT HOL output
isState_updateQuery_lemma =
Ù µ c i ns s ts
  ∑ isState s ± tabExists c i s
      ¥ isState (deleteQuery (c, (i, ns), s, getTable i s))
=TEX
\subsubsection{State Invariant Lemma}
=SML
push_goal([],¨µ clear s ∑ isState s ¥ isState(Fst (updateStateR (clear, u, s)))Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨u = (Fst u,Snd u)Æ pure_once_asm_rewrite_thm_tac 
	THEN_LIST[rewrite_tac[],rewrite_tac[updateStateR_def] THEN REPEAT µ_tac]);
a(strip_asm_tac(µ_elim ¨Fst uÆ query_type) THEN asm_rewrite_tac[]
	THEN cases_tac¨≥ Snd u = []Æ THEN asm_rewrite_tac[]
	THEN cases_tac¨tabExists clear (tabFromEffect (Fst u)) sÆTHEN asm_rewrite_tac[]
	THEN cases_tac¨≥ clear dominates TS_class (getTable (tabFromEffect (Fst u)) s)Æ
	THEN asm_rewrite_tac[]);
=TEX
=SML
(* 3 subgoals - Select automatically proven *)
(* *** Goal "1" *** *)
(* Insert *)
a(DROP_NTH_ASM_T 7(strip_asm_tac o rewrite_rule[isInsert_def]));
a(DROP_NTH_ASM_T 3 ante_tac THEN POP_ASM_T rewrite_thm_tac);
a(rewrite_tac[destInsert_def,tabFromEffect_def]THEN ¥_tac);
a(fc_tac[isState_insertQuery_lemma] THEN asm_fc_tac[]);
a(POP_ASM_T (ante_tac o µ_elim¨Snd iÆ));
a(rewrite_tac[]);
=TEX
=SML
(* Delete *)
a(DROP_NTH_ASM_T 7(strip_asm_tac o rewrite_rule[isInsert_def]));
a(DROP_NTH_ASM_T 3 ante_tac THEN POP_ASM_T rewrite_thm_tac);
a(rewrite_tac[destInsert_def,tabFromEffect_def]THEN ¥_tac);
a(fc_tac[isState_deleteQuery_lemma] THEN asm_fc_tac[]);
a(POP_ASM_T (ante_tac o µ_elim¨Snd dÆ));
a(rewrite_tac[]);
=TEX
=SML
(* Update *)
a(DROP_NTH_ASM_T 7(strip_asm_tac o rewrite_rule[isInsert_def]));
a(DROP_NTH_ASM_T 3 ante_tac THEN POP_ASM_T rewrite_thm_tac);
a(rewrite_tac[destInsert_def,tabFromEffect_def]THEN ¥_tac);
a(fc_tac[isState_updateQuery_lemma] THEN asm_fc_tac[]);
a(POP_ASM_T (ante_tac o µ_elim¨Snd u'Æ));
a(rewrite_tac[]);
val €updateStateR_lemma› = save_pop_thm"updateStateR_lemma";
=TEX
=GFT HOL output
updateStateR_lemma = Ù µ clear s
  ∑ isState s ¥ isState (Fst (updateStateR (clear, u, s)))
=TEX


\subsection{Proof of $Lemma1$}
We prove $Lemma1$ using the results of section \ref{REL} and section \ref{INV}
together with $secureHide\_lemma$ from \cite{DS/FMU/FEF/010}.

=SML
val €lemma1_thm› = 
	prove_rule[Lemma1,secureHide_lemma,
	rewrite_rule[updateStateR_lemma]updateStateR_updateState_lemma]¨Lemma1Æ;
=TEX
=GFT HOL output
val lemma1_thm = Ù Lemma1
=TEX
\section{PROOF OF SECURITY OF SSQL}

We now give the main result $secureSSQL$ that the behaviour of the SSQL abstract machine is secure.

=SML
val €secureSSQL› = save_thm("secureSSQL",rewrite_rule[lemma1_thm]main_thm1);
=TEX

=GFT HOL output
secureSSQL = Ù behaviours SSQLam ç secure
=TEX


\section{CLOSING DOWN}
The following \Product{} instruction restores the previous proof context.
=SML
pop_pc();
=TEX


\newpage
\HOLindexOff
\input{fef015th.tex}
\HOLindexOn
\newpage
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}

