    $Date$ $Id$ %Z% 
=TEX
\documentstyle[hol1,11pt,TQ]{article}

\TPPtitle{Implementation for FEF Makefile}
\TPPref{DS/FMU/FEF/100}
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}

\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{DRA FRONT END FILTER PROJECT}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Standard}
\TPPkeywords{}
\TPPauthor{G.~M.~Prout & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document gives the implementation for the makefile for the
DRA front end filter project RSRE 1C/6130.}
\TPPdistribution{\parbox[t]{4.0in}{%
	HAT FEF File 
}}

\ftlinepenalty=9999
\makeindex
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

%\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}

\newpage
\section {DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,fef}

\subsection{Changes History}
\begin{description}
\item[\SCCSversion ({\FormatDate{$Date$
}})] Ported to version 0.3 ProofPower. Initialisation file not
required now.
\end{description}

\subsection{Changes Forecast}
\subsection{Scope}
This document produces a makefile for the DRA front end filter project RSRE 1C/6130.

\subsection{Introduction}
This file contains the literate script of a makefile. To produce the makefile, enter 
$$ sieve\ sml\ <\ fef100.doc$$

\section{MAKEFILE}

=DUMP fef.mkf
# $Id$ %Z%
# Built from fef100.doc
#
#	An attempt at a makefile for fef
#
#	For details of the main entries in this file look for the
#	string MAIN ENTRIES below.

ÛdefaultÝ : 
	@ echo "Read fef100.doc for a description of this makefile"
=TEX
An important list is of the sml files that need to be
compiled.  This list also gives the correct compilation
order for the files.  From this list we derive the
lists of ".doc" and ".tex" files.

=DUMPMORE fef.mkf
#######################################
#
#	An important list is of the sml files that need to be
#	compiled.  This list also gives the correct compilation
#	order for the files.  From this list we derive the
#	lists of ".doc" and ".tex" files.


SMLFILES =	fef003.sml \
		fef004.sml \
		fef005.sml \
		fef014.sml \
		fef006.sml \
		fef007.sml \
		fef009.sml \
		fef010.sml \
		fef011.sml \
		fef012.sml \
		fef013.sml \
		fef015.sml \
		fef022.sml \
		fef024.sml \
		fef021.sml \
		fef025.sml \
		fef028.sml \
		fef029.sml \
		fef026.sml \
		fef032.sml \
		fef034.sml \
		fef031.sml \
		fef033.sml

ALLSMLS = wrk044.sml wrk046.sml wrk049.sml $(SMLFILES)
MINSMLS = wrk044.sml wrk046.sml wrk049.sml $(MINSMLFILES)

DOCFILES = $(ALLSMLS:.sml=.doc) fef001.doc 
TEXFILES = $(SMLFILES:.sml=.tex) fef001.tex 
DVIFILES = $(SMLFILES:.sml=.dvi) fef001.dvi 

#######################################

ARCH:sh = echo `arch`
HOLDB = $(ARCH)hol.db
FEFDB = $(ARCH)fef.db
DIR	= /hat/projects/fef
SDIR	= $(DIR)/SCCS
SCCSGET	= sccs -d $(DIR) get

#######################################
#
#	Pattern matching rules

.SUFFIXES: .doc .sml .tex .sh .dvi 
%th.tex: %.doc
	hol_list -d $(FEFDB) $* > $*th.doc
	doctex $*th

%.tex: %.doc
	doctex $*

%.sml: %.doc
	docsml $*

%.dvi: %.tex
	- $(MAKE) -f fef.mkf $*th.tex 
	texdvi $*
	- bibtex $*
	texdvi $*
	texdvi $*



#######################################
#
#	Get any necessary files from SCCS control.  Note that the SCCS
#	directory is the project directory, not necessarily "./SCCS".

$(DOCFILES) : $(DIR)/SCCS/s.$$@
	$(SCCSGET) $@

#######################################
#
#	MAIN ENTRIES.  The main entries to the makefile follow.
#	Additional main entries are the names of the ".dvi" files


#	Do everything!

ÛallÝ : $(FEFDB)  latexall

#	fef database

Ûfef.dbÝ : $(FEFDB)


#	Run LaTeX on all the documents, but do not actually print them.

ÛlatexallÝ : $(TEXFILES) $(DVIFILES)


#	To run LaTeX and BiBTeX on a given document to produce
#	a ".dvi" file that may be printed.  Use e.g.,
#		> make fef001.dvi
#
#{docname}.dvi


#	Run LaTeX once on a given document.  Use just the
#	document name, e.g.,
#		> make fef001

$(SMLFILES:.sml=) : $$@.tex
	texdvi $@


#	Get the sources from SCCS.

ÛdocsÝ : $(DOCFILES)


#	Form all the sml files for the fef database.

ÛsmlÝ : $(SMLFILES)



#	build the fef database

$(FEFDB) : $(ALLSMLS) makefef.sh
	rm -f $(FEFDB)
	pp_make_database -f -p pp_hol#fin_set fef#cache_thms
	- chmod u+w $(FEFDB)
	makefef.sh -d $(FEFDB) -s "Built by makefile"  $(ALLSMLS)

=TEX
\section{TIDYING UP THE FILE STORE}
Rule $texclean$ removes all recreatable \TeX{} and \LaTeX{}
files, i.e., those which
can be derived from the ".doc" files.

Rule $sccsclean$ removes files that can be obtained from sccs.

Rule $derivedclean$ removes `{\tt *.sml}' and database files.

Rule $allclean$ removes all recreatable files, i.e., those which can be
derived from the SCCS directory, which is all of the above files.

=DUMPMORE fef.mkf
ÛallcleanÝ : texclean sccsclean derivedclean

ÛtexcleanÝ :
	rm -f $(DVIFILES) $(TEXFILES)
	rm -f $(DOCFILES:.doc=.aux) $(DOCFILES:.doc=.log)
	rm -f $(DOCFILES:.doc=.idx) $(DOCFILES:.doc=.sid)
	rm -f $(DOCFILES:.doc=.toc) $(DOCFILES:.doc=.bbl)
	rm -f $(DOCFILES:.doc=.blg)

ÛsccscleanÝ :
	sccs -d $(DIR) clean

ÛderivedcleanÝ :
	rm -f sun3fef.db sun4fef.db
	rm -f $(ALLSMLS)

ÛtexverycleanÝ :
	rm -f *.aux
	rm -f *.bbl
	rm -f *.blg
	rm -f *.dvi
	rm -f *.idx
	rm -f *.log
	rm -f *.sid
	rm -f *.tex
	rm -f *.toc


=TEX
\section{SHELL SCRIPT TO COMPILE IN FILES}

Shell script {\tt makefef.sh} does the actual compiling of the
system.  The following options are provided.

\begin{description}

\item[-d databasename ] Use or create the named database, default is
	``{\em arch\/}{\tt fef.db}'' where `{\em arch\/}' is the
	architecture of the computer running the command.  Thus the
	defaults are ``{\tt sun3fef.db}'' and ``{\tt sun4fef.db}''.

\item[-g ] Run the disc garbage collector after all the compilations.

\item[-s] Optional system version (a string).
\end{description}

Note that we direct standard error to standard output when we run
poly (via script hol).  This is because it checks that the three standard streams are in
working order whenever it is called. With the redirection we can run
this script off-line, provided the standard output is redirected.

Two auxiliary files are used.  For each compilation (the ``{\tt .sml}''
files are compiled one at a time) status information
is written into file `{\tt .makefef.log\_file}', these statuses are
concatenated into file `{\tt .makefef.compile\_summary}' which is then
processed (by {\tt sed}) to create a short report about all of the
files.  Both auxiliary files are deleted when the build completes.  A
status of ``{\tt Compiled OK}'' denotes the compilation completed
without ML errors, ``{\tt Compiling}'' denotes the compilation of the
file started but did not complete, and ``{\tt Trying}'' denotes some
problem invoking PolyML.

Flag loadReader is 1 on the first pass of the loop,
to indicate addition of fefversions,
otherwise at 2.
=DUMP makefef.sh
#! /bin/sh
# makefef.sh
#	A shell script that controls the builds of the fef database.
#	Created from:  fef100.doc  $Id$ %Z%

usage="makefef.sh: usage: makefef.sh [-d database] [-g] [-s fef_issue] files"

# -g - do a garbage collect at the end
# -d - source database to have material added in
# -s - fef issue number (assigned to ML variable fef version)

collect=n
database=`pwd`/`arch`"hol.db"
loadReader="1"
build_version="Not given"

# Argument processing

while getopts gd:s: arg
do
    case $arg in
        g)    collect=y ;;
        d)    database=$OPTARG ;;
        s)    build_version=$OPTARG ;;
        \?)   echo $usage ; exit 1 ;;
    esac
done

# Discard all flags - only arguments left are file names
shift `expr $OPTIND - 1`

echo Compilation summary > .makefef.compile_summary
echo Start time `date` >> .makefef.compile_summary

# Compile each file named in the command list.
for i in $*
do
	date
	docname=`basename $i .sml`.doc
	iver=`sccs -d /hat/projects/fef prs -d":Dt:" $docname`
	command="Install(\"$i\", \"$i  - $iver\")"

	echo Trying: $i > .makefef.log_file

	(
# Material only put in during load of first loaded file
	if test $loadReader = "1"
	then
		echo 'val fefversions : string list ref = ref'
		date '+ ["- - build_on %y/%m/%d %H:%M:%S",'
		echo '"Built from files in directory"];'
		echo 'val fef_version : string = "'$build_version'";'
	cat <<EOF
		fun Install (name, version) = (
		let
			val log_file = open_out ".makefef.log_file";
		in
			output(log_file, "\nCompiling:\t" ^ name ^ "\n");
			output(std_out, "Compiling: " ^ name ^ "\n");
			use_file name;
			fefversions := version :: !fefversions;
			output(log_file, "\t" ^ name ^ " compiled\n");
			close_out log_file;
			output(std_out, "Compiled: " ^ name ^ "\n")
		end
		);
EOF
	fi
# Material put in during the load of each file
	echo "$command; save_and_quit();"

# The following is where the above is piped to ProofPower
	) | hol -d $database 2>&1

	cat .makefef.log_file >> .makefef.compile_summary

	loadReader="2"
done

#       Here we build an input stream for "hol" over several lines of
#	shell script, delimited by "##Start" and "##End".

(	##Start

	echo 'val fefversions : string list ref = ref'
	date '+("- - build_completed %y/%m/%d %H:%M:%S" :: !fefversions);'

	echo "rev(!fefversions); save_and_quit();"
	##End
) | hol -d $database 2>&1

if test $collect = "y"
then
	discgarb $database
fi

# Always make database read-only
chmod -w $database

echo " " >> .makefef.compile_summary
echo ================================
sed		-e '/^Compiling:/N' \
		-e 's/^Compiling:	\(.*\.sml\)\n	\1 compiled$/Compiled OK:	\1/' \
		-e '/^$/d' \
		-e 's/\n$//' \
		-e 's/\n/--/g' \
	.makefef.compile_summary
echo Finish time `date`
echo ================================
rm -f .makefef.compile_summary .makefef.log_file
=TEX

=SH
chmod +x makefef.sh
=TEX
\twocolumn[\section{INDEX} \label{INDEX}]
\small
\printindex

\end{document}
 

