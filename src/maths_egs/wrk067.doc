pp_make_database -f -p hol topology
docsml topology
xpp -file topology.doc -com pp -d topology -i topology &
doctex topology topology.th; texdvi topology
=TEX
\documentclass[10pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\title{Homology of the Plane}
\author{Rob Arthan}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
This {\ProductHOL} script contains definitions and proofs concerning the
basics of point-set topology.
\end{abstract}
\vfill
\newpage
\tableofcontents
\newpage
%%%%
%%%%
%%%%
%%%%
\section{INTRODUCTION}
%%%%
%%%%
%%%%
%%%%
=SML
force_delete_theory"topology" handle Fail _ => ();
open_theory"Ø";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙", "'Ø"];
new_theory"topology";
new_parent"fin_set";
=TEX
%%%%
%%%%
%%%%
%%%%
\section{DEFINITIONS}\label{DEFINITIONS}
=TEX
%%%%
%%%%
=SML
πHOLCONST
‹ €Topology› : 'a SET SET SET
˜¸¸¸¸¸¸
‹ 	Topology =
‹	{‘ | (µV∑ V Ä ‘ ¥ ﬁ V ç ‘) ± (µA B∑A ç ‘ ± B ç ‘ ¥ A ° B ç ‘)}
∞
=TEX
%%%%
%%%%
=SML
πHOLCONST
‹ €$Space› : 'a SET SET ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ‘∑ Space ‘ = ﬁ ‘
∞
=TEX
%%%%
%%%%
=SML
declare_postfix(300, "Closed");
πHOLCONST
‹ €$Closed› : 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ‘∑ ‘ Closed = {A | ∂B∑B ç ‘ ± A = Space ‘ \ B}
∞
=TEX
%%%%
%%%%
=SML
declare_postfix(300, "Continuous");
πHOLCONST
‹ €$Continuous› : ('a SET SET ∏ 'b SET SET) ≠ ('a ≠ 'b) SET
˜¸¸¸¸¸¸
‹ µ” ‘∑ (”, ‘) Continuous =	{f | (µx∑ x ç Space ” ¥ f x ç Space ‘) ± (µA∑ A ç ‘ ¥ {x | f x ç A} ç ”)}
∞
=TEX
%%%%
%%%%
=SML
declare_postfix(300, "Connected");
πHOLCONST
‹ €$Connected› : 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ‘∑ ‘ Connected =
‹	{A | A Ä Space ‘
‹	± µB C∑ B ç ‘ ± C ç ‘ ± A Ä B ¿ C ± A ° B ° C = {} ¥ (A Ä B ≤ A Ä C)}
∞
=TEX
%%%%
%%%%
=SML
declare_postfix(300, "Compact");
πHOLCONST
‹ €$Compact› : 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ‘∑ ‘ Compact =
‹	{A | A Ä Space ‘ ± µV∑ V Ä ‘ ± A Ä ﬁ V ¥ ∂W∑ W Ä V ± W ç Finite ± A Ä ﬁ W}
∞
=TEX
%%%%
%%%%
=SML
declare_infix(240, "ÚâT");
πHOLCONST
‹ €$ÚâT› : 'a SET ≠ 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µX ‘∑ 	(X ÚâT ‘)
‹ =	{A | ∂B∑ B ç ‘ ± A = B ° X}
∞
=TEX
%%%%
%%%%
=SML
declare_infix(150, "∏âT");
πHOLCONST
‹ €$∏âT› : 'a SET SET ≠ 'b SET SET ≠ ('a ∏ 'b) SET SET
˜¸¸¸¸¸¸
‹ µ” ‘∑ 	(” ∏âT ‘)
‹ =	{C | µ x y∑ (x, y) ç C ¥ ∂A B∑ A ç ” ±  B ç ‘ ± x ç A ± y ç B  ± (A ∏ B) Ä C}
∞
=TEX
%%%%
%%%%
=SML
πHOLCONST
‹ €Hausdorff› : 'a SET SET SET
˜¸¸¸¸¸¸
‹ 	Hausdorff =
‹	{‘ | µx y∑ x ç Space ‘ ± y ç Space ‘ ± ≥x = y
‹	¥	∂A B∑A ç ‘ ± B ç ‘ ± x ç A ± y ç B ± A ° B = {}}
∞
=TEX
%%%%
%%%%
{\HOLindexOff
\include{topology.th}}
=TEX
%%%%
%%%%
\section{THEOREMS AND PROOFS}
=TEX
%%%%
%%%%
\subsection{Lemmas About Finite Sets}
The following should definitely go in the finite sets theory ASAP. !!! TBD !!!
=SML
set_goal([], ¨µA B∑
	 (A ¿ B) ç Finite § A ç Finite ± B ç Finite
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac ¨A Ä A ¿ BÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
(* *** Goal "2" *** *)
a(lemma_tac ¨B Ä A ¿ BÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨BÆ, ¨BÆ));
a(finite_induction_tac ¨AÆ THEN1 asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(LEMMA_T¨({x} ¿ A) ¿ B = {x} ¿ A ¿ BÆ
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(bc_thm_tac singleton_¿_finite_thm THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
val €¿_finite_thm› = save_pop_thm "¿_finite_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ f : 'a ≠ 'b; A : 'a SET∑
	 A ç Finite ¥ {y | ∂x∑x ç A ± y = f x} ç Finite
Æ);
a(REPEAT strip_tac);
a(finite_induction_tac ¨AÆ THEN1 rewrite_tac[]);
(* *** Goal "1" *** *)
a(LEMMA_T¨{y:'b|F} = {}Æ (fn th => rewrite_tac[th, empty_finite_thm])
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨{y|∂ x'∑ x' ç {x} ¿ A ± y = f x'} = {f x} ¿ {y|∂ x'∑ x' ç A ± y = f x'}Æ
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(bc_thm_tac singleton_¿_finite_thm THEN REPEAT strip_tac);
val €finite_image_thm› = save_pop_thm "finite_image_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{The Definitions}
=SML
val €topology_def› = get_spec¨$TopologyÆ;
val €space_def› = get_spec¨$SpaceÆ;
val €closed_def› = get_spec¨$ClosedÆ;
val €continuous_def› = get_spec¨$ContinuousÆ;
val €connected_def› = get_spec¨$ConnectedÆ;
val €compact_def› = get_spec¨$CompactÆ;
val €subspace_topology_def› = get_spec¨$ÚâTÆ;
val €product_topology_def› = get_spec¨$∏âTÆ;
val €hausdorff_def› = get_spec¨HausdorffÆ;
=TEX
\subsection{Elementary Properties of Open and Closed Sets}
%%%%
%%%%
=SML
set_goal([], ¨µ‘ : 'a SET SET ∑ ‘ ç Topology ¥ {} ç ‘Æ);
a(rewrite_tac[topology_def] THEN REPEAT strip_tac);
a(SPEC_NTH_ASM_T 2 ¨{}: 'a SET SETÆ ante_tac);
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨ﬁ{} = {}Æ]);
val €empty_open_thm› = save_pop_thm "empty_open_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ : 'a SET SET ∑ ‘ ç Topology ¥ Space ‘ ç ‘Æ);
a(rewrite_tac[topology_def, space_def] THEN REPEAT strip_tac);
a(SPEC_NTH_ASM_T 2 ¨‘: 'a SET SETÆ ante_tac);
a(rewrite_tac[]);
val €space_open_thm› = save_pop_thm "space_open_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ : 'a SET SET ∑ ‘ ç Topology ¥ {} ç ‘ ClosedÆ);
a(rewrite_tac[closed_def] THEN REPEAT strip_tac);
a(all_fc_tac[space_open_thm]);
a(∂_tac¨Space ‘Æ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" prove_tac[]);
val €empty_closed_thm› = save_pop_thm "empty_closed_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ : 'a SET SET ∑ ‘ ç Topology ¥ Space ‘ ç ‘ ClosedÆ);
a(rewrite_tac[closed_def] THEN REPEAT strip_tac);
a(all_fc_tac[empty_open_thm]);
a(∂_tac¨{} : 'a SETÆ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" prove_tac[]);
val €space_closed_thm› = save_pop_thm "space_closed_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ A ∑
	‘ ç Topology ¥
	(A ç ‘ § µx∑x ç A ¥ ∂B∑ B ç ‘ ± x ç B ± B Ä A)Æ);
a(rewrite_tac[topology_def, space_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨AÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨A = ﬁ{B | B ç ‘ ± B Ä A}Æ);
(* *** Goal "2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN
	contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(POP_ASM_T once_rewrite_thm_tac THEN DROP_NTH_ASM_T 3 bc_thm_tac);
a(PC_T1 "sets_ext1" prove_tac[]);
val €open_open_neighbourhood_thm› = save_pop_thm "open_open_neighbourhood_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ A ∑
	‘ ç Topology ¥
	(	A ç ‘ Closed
	§ 	A Ä Space ‘
	±	µx∑x ç Space ‘  ± ≥x ç A ¥ ∂B∑ B ç ‘ ± x ç B ± B ° A = {})Æ);
a(rewrite_tac[closed_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨x ç BÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[open_open_neighbourhood_thm]);
a(∂_tac¨B'Æ THEN PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(FC_T1 fc_§_canon once_rewrite_tac [open_open_neighbourhood_thm]);
a(∂_tac¨Space ‘ \ AÆ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(all_asm_fc_tac[]);
a(∂_tac¨BÆ THEN PC_T1 "sets_ext1" asm_rewrite_tac[]);
a(rewrite_tac[space_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "3.1.1" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "3.1.2" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac) THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "3.2" *** *)
a(LIST_GET_NTH_ASM_T [1, 3] (MAP_EVERY ante_tac)  THEN PC_T1 "sets_ext1" prove_tac[]);
val €closed_open_neighbourhood_thm› = save_pop_thm "closed_open_neighbourhood_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ V∑ 
	‘ ç Topology ± V Ä ‘ ± ≥V = {} ± V ç Finite
¥	•V ç ‘Æ);
a(rewrite_tac[topology_def] THEN REPEAT strip_tac);
a(POP_ASM_T (fn th => POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN asm_tac th));
a(finite_induction_tac¨VÆ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(all_var_elim_asm_tac1 THEN rewrite_tac[]);
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µx y∑{x} Ä y § x ç yÆ]);
a(LEMMA_T¨•{x} = xÆ (fn th => rewrite_tac [th] THEN taut_tac));
(* *** Goal "3" *** *)
a(PC_T"sets_ext1" strip_tac THEN rewrite_tac[•_def] THEN prove_tac[]);
(* *** Goal "4" *** *)
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µx y z∑{x} ¿ z Ä y § x ç y ± z Ä yÆ]);
a(LEMMA_T¨•({x} ¿ V) = x ° •VÆ rewrite_thm_tac);
(* *** Goal "4.1" *** *)
a(PC_T"sets_ext1" strip_tac THEN rewrite_tac[•_def, °_def, ¿_def] THEN prove_tac[]);
(* *** Goal "4.2" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
val €finite_•_open_thm› = save_pop_thm "finite_•_open_thm";
=TEX
\subsection{Constructing New Topologies from Old}
%%%%
%%%%
=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
¥	(X ÚâT ‘) ç TopologyÆ);
a(rewrite_tac[topology_def, subspace_topology_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_ante_tac THEN1 PC_T1 "sets_ext1" REPEAT strip_tac);
a(∂_tac ¨ﬁ{C| C ç ‘ ± C ° X ç V}Æ  THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "1.1" *** *)
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.2" *** *)
a(PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.2.1" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
a(∂_tac ¨BÆ  THEN REPEAT strip_tac);
(* *** Goal "1.2.2" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
(* *** Goal "1.2.3" *** *)
a(∂_tac ¨s ° XÆ  THEN PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(∂_tac ¨B' ° B''Æ   THEN PC_T1 "sets_ext1" asm_prove_tac[]);
val €subspace_topology_thm› = save_pop_thm "subspace_topology_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ A∑ 
	‘ ç Topology
¥	Space (A ÚâT ‘) = A ° Space ‘Æ);
a(rewrite_tac[topology_def, space_def, subspace_topology_def] THEN 
	PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(∂_tac ¨BÆ  THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(∂_tac ¨s ° AÆ  THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(∂_tac ¨s Æ  THEN REPEAT strip_tac);
val €subspace_topology_space_thm› = save_pop_thm "subspace_topology_space_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET∑ 
	” ç Topology
±	‘ ç Topology
¥	(” ∏âT ‘) ç TopologyÆ);
a(rewrite_tac[topology_def, product_topology_def]
	THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LIST_DROP_NTH_ASM_T  [3] all_fc_tac);
a(∂_tac¨AÆ  THEN ∂_tac ¨BÆ THEN REPEAT strip_tac);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx y z∑x Ä y ± y ç z ¥ x Ä ﬁ zÆ]);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T  [3, 4] all_fc_tac);
a(∂_tac¨A' ° A''Æ  THEN ∂_tac ¨B' ° B''Æ THEN REPEAT strip_tac
	THEN_TRY SOLVED_T (all_asm_fc_tac[]));
a(MERGE_PCS_T1["'bin_rel", "sets_ext1"] asm_prove_tac[]);
val €product_topology_thm› = save_pop_thm "product_topology_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'a SET SET∑ 
	” ç Topology
±	‘ ç Topology
¥	Space  (” ∏âT ‘)  = (Space ” ∏ Space ‘)Æ);
a(rewrite_tac[product_topology_def, space_def]);
a(MERGE_PCS_T1["'bin_rel", "sets_ext1"] prove_tac[]);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[] THEN contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨s ∏ s'Æ THEN MERGE_PCS_T1["'bin_rel", "sets_ext1"] REPEAT strip_tac);
a(∂_tac¨sÆ THEN ∂_tac¨s'Æ THEN MERGE_PCS_T1["'bin_rel", "sets_ext1"] REPEAT strip_tac);
val €product_topology_space_thm› = save_pop_thm "product_topology_space_thm";
=TEX
\subsection{Compactness}
%%%%
%%%%
%%%%
%%%%
=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
¥	(X ç ‘ Compact § X ç (X ÚâT ‘) Compact)Æ);
a(rewrite_tac[compact_def] THEN PC_T1 "sets_ext1" REPEAT µ_tac THEN ¥_tac);
a(ALL_FC_T1 fc_§_canon rewrite_tac[subspace_topology_space_thm]);
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b∑a Ä a ° b § a Ä bÆ]);
a(rewrite_tac[subspace_topology_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨X Ä ﬁ{B | B ç ‘ ± B ° X ç V} Æ THEN1 PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(LIST_GET_NTH_ASM_T [1, 2, 3] (PC_T1 "sets_ext1" (MAP_EVERY strip_asm_tac)));
a(all_asm_fc_tac[]);
a(LIST_GET_NTH_ASM_T [3] all_fc_tac THEN all_var_elim_asm_tac1);
a(∂_tac¨BÆ THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(lemma_tac¨{B | B ç ‘ ± B ° X ç V} Ä ‘Æ THEN1 PC_T1 "sets_ext" prove_tac[]);
a(all_asm_fc_tac[]);
a(ante_tac(list_µ_elim[¨ÃB∑B ° XÆ, ¨WÆ]finite_image_thm));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac ¨{C|∂ B∑ B ç W ± C = B ° X}Æ THEN REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(PC_T "sets_ext1"  strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(LIST_GET_NTH_ASM_T [5] (PC_T1 "sets_ext1" all_fc_tac));
(* *** Goal "1.2.2" *** *)
a(PC_T "sets_ext1"  strip_tac THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [3] (PC_T1 "sets_ext1" all_fc_tac));
a(∂_tac¨s ° XÆ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(lemma_tac¨X Ä ﬁ{C | ∂B∑ B ç V ± C = B ° X} Æ THEN1 PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(LIST_GET_NTH_ASM_T [2] (PC_T1 "sets_ext1" all_fc_tac));
a(∂_tac¨s ° XÆ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(lemma_tac¨{C | ∂B∑ B ç V ± C = B ° X} Ä {A|∂ B∑ B ç ‘ ± A = B ° X}Æ
	THEN1 (PC_T "sets_ext" strip_tac THEN REPEAT strip_tac));
(* *** Goal "2.2.1" *** *)
a(all_var_elim_asm_tac1 THEN ∂_tac ¨BÆ THEN 
	REPEAT strip_tac THEN PC_T1 "sets_ext1" all_asm_fc_tac[]);
(* *** Goal "2.2.2" *** *)
a(all_asm_fc_tac[]);
a(lemma_tac¨∂f∑µC∑ C ç W ¥ f C ç V ± C = f C ° XÆ THEN1 prove_∂_tac);
(* *** Goal "2.2.2.1" *** *)
a(REPEAT strip_tac);
a(cases_tac¨≥C' ç WÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 4 (PC_T1 "sets_ext1" strip_asm_tac));
a(LIST_DROP_NTH_ASM_T [1] all_fc_tac);
a(all_var_elim_asm_tac1 THEN ∂_tac¨BÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2" *** *)
a(strip_asm_tac(list_µ_elim[¨fÆ, ¨WÆ]finite_image_thm));
a(∂_tac¨{y|∂ x∑ x ç W ± y = f x}Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(PC_T "sets_ext1"  strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a(PC_T "sets_ext1"  strip_tac THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (PC_T1 "sets_ext1" strip_asm_tac));
a(LIST_DROP_NTH_ASM_T [1] all_fc_tac);
a(∂_tac¨f sÆ THEN asm_rewrite_tac[]);
a(LIST_DROP_NTH_ASM_T [5] all_fc_tac);
a(DROP_NTH_ASM_T 4 ante_tac);
a(POP_ASM_T (fn th => conv_tac(LEFT_C(once_rewrite_conv[th]))));
a(REPEAT strip_tac THEN rename_tac[]);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
val €compact_topological_thm› = save_pop_thm "compact_topological_thm";
=TEX
=SML
set_goal([], ¨µ‘ V p∑ 
	‘ ç Topology
±	V Ä ‘
±	V ç Finite
±	p ç Space ‘
±	(µA∑ A ç V ¥ ∂B∑ B ç ‘ ± p ç B ± A ° B = {})
¥	∂B∑ B ç ‘ ± p ç B ± B ° ﬁV = {}Æ);
a(REPEAT strip_tac);
a(lemma_tac¨
	∂b∑µA∑A ç V ¥ b A ç ‘ ± p ç b A ± A ° b A = {}
Æ THEN1 prove_∂_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(cases_tac¨≥A' ç VÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 2 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(cases_tac¨ﬁV = {}Æ);
(* *** Goal "2.1" *** *)
a(∂_tac ¨Space ‘Æ THEN ALL_FC_T asm_rewrite_tac[space_open_thm]);
(* *** Goal "2.2" *** *)
a(lemma_tac ¨•{y|∂ x∑ x ç V ± y = b x} ç ‘Æ THEN1 bc_thm_tac finite_•_open_thm);
(* *** Goal "2.2.1" *** *)
a(asm_rewrite_tac[] THEN ALL_FC_T rewrite_tac[finite_image_thm]);
a(REPEAT strip_tac THEN PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
(* *** Goal "2.2.1.1" *** *)
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.1.2" *** *)
a(rewrite_tac[]);
a(cases_tac¨V = {}Æ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(POP_ASM_T (PC_T1 "sets_ext1" strip_asm_tac));
a(∂_tac¨b xÆ THEN ∂_tac¨xÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(∂_tac¨•{y|∂ x∑ x ç V ± y = b x}Æ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.2.2.1" *** *)
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(PC_T "sets_ext1" strip_tac THEN rewrite_tac[°_def, •_def, ﬁ_def]);
a(REPEAT strip_tac);
a(∂_tac¨b sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(∂_tac¨ sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.2" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
val €compact_closed_lemma› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ C∑ 
	‘ ç Topology
±	‘ ç Hausdorff
±	C ç ‘ Compact
¥	C ç ‘ ClosedÆ);
a(REPEAT strip_tac);
a(ALL_FC_T1 fc_§_canon  rewrite_tac[closed_open_neighbourhood_thm]);
a(once_rewrite_tac[prove_rule[]¨µp1 p2∑ p1 ± p2 § p1 ± (p1 ¥ p2)Æ]);
a(REPEAT strip_tac THEN1
	(POP_ASM_T ante_tac THEN prove_tac[compact_def]));
a(lemma_tac¨C Ä ﬁ {A | A ç ‘ ± ∂B∑B ç ‘ ± x ç B ± A ° B = {}}Æ);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[hausdorff_def]));
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(lemma_tac¨x' ç Space ‘Æ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(lemma_tac¨≥x' = xÆ THEN1 (contr_tac THEN all_var_elim_asm_tac1));
a(all_asm_fc_tac[]);
a(∂_tac¨AÆ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[compact_def]));
a(lemma_tac¨{A | A ç ‘ ± ∂B∑B ç ‘ ± x ç B ± A ° B = {}} Ä ‘Æ
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(all_asm_fc_tac[]);
a(lemma_tac¨W Ä ‘Æ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(lemma_tac¨µ A∑ A ç W ¥ (∂ B∑ B ç ‘ ± x ç B ± A ° B = {})Æ);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
a(∂_tac¨BÆ THEN PC_T1 "sets_ext1" asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(all_fc_tac[compact_closed_lemma]);
a(∂_tac¨BÆ THEN  asm_rewrite_tac[]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[] ¨µX∑ C Ä X ± B ° X = {} ¥ B ° C = {}Æ]);
val €compact_closed_thm› = save_pop_thm "compact_closed_thm";
=TEX
\subsection{Connectdness}
%%%%
%%%%
=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
¥	(X ç ‘ Connected § X ç (X ÚâT ‘) Connected)Æ);
a(rewrite_tac[connected_def] THEN PC_T1 "sets_ext1" REPEAT µ_tac THEN ¥_tac);
a(ALL_FC_T1 fc_§_canon rewrite_tac[subspace_topology_space_thm]);
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b∑a Ä a ° b § a Ä bÆ]);
a(rewrite_tac[subspace_topology_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1);
a(lemma_tac¨X Ä B'  ¿ B''Æ THEN1
	(GET_NTH_ASM_T 3 ante_tac THEN  PC_T1 "sets_ext" prove_tac[]));
a(DROP_NTH_ASM_T 3 ante_tac THEN
	rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b c∑a ° (b ° a) ° c ° a = a ° b ° cÆ]);
a(REPEAT strip_tac);
a(lemma_tac¨≥X Ä B' Æ THEN1
	(GET_NTH_ASM_T 3 ante_tac THEN  PC_T1 "sets_ext" prove_tac[]));
a(all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(list_spec_nth_asm_tac 6 [¨B ° XÆ, ¨C ° XÆ]);
(* *** Goal "2.1" *** *)
a(list_spec_nth_asm_tac 1 [¨BÆ]);
(* *** Goal "2.2" *** *)
a(list_spec_nth_asm_tac 1 [¨CÆ]);
(* *** Goal "2.3" *** *)
a(i_contr_tac THEN LIST_DROP_NTH_ASM_T [1, 4] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.4" *** *)
a(i_contr_tac THEN LIST_DROP_NTH_ASM_T [1, 3] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.5" *** *)
a(i_contr_tac THEN LIST_DROP_NTH_ASM_T [1, 2] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.6" *** *)
a(LIST_DROP_NTH_ASM_T [1] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext1" prove_tac[]);
val €connected_topological_thm› = save_pop_thm "connected_topological_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
¥	(	X ç ‘ Connected
	 § 	µx y∑ x ç X ± y ç X ¥ ∂Y∑ Y Ä X ± x ç Y ± y ç Y ± Y ç ‘ Connected)Æ);
a(REPEAT strip_tac THEN1 (∂_tac¨XÆ THEN PC_T1 "sets_ext1" asm_prove_tac[]));
a(POP_ASM_T ante_tac THEN rewrite_tac[connected_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN all_asm_fc_tac[]);
a(LIST_GET_NTH_ASM_T [2, 3, 4] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN PC_T "sets_ext1" contr_tac);
a(list_spec_nth_asm_tac 9 [¨xÆ, ¨x'Æ]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä b ± b Ä c ¥ a Ä cÆ]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä b ± b ° c = {} ¥ a ° c = {}Æ]);
a(list_spec_nth_asm_tac 3 [¨BÆ, ¨CÆ]);
(* *** Goal "2.1" *** *)
a(LIST_GET_NTH_ASM_T [1, 7, 11] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2.2" *** *)
a(LIST_GET_NTH_ASM_T [1, 6, 9] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext" prove_tac[]);
val €connected_pointwise_thm› = save_pop_thm "connected_pointwise_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET;  AB : ('a ∏ 'b) SET∑ 
	” ç Topology
±	‘ ç Topology
±	AB ç (” ∏âT ‘)
¥	(µx∑x ç Space ” ¥ {y | (x, y) ç AB} ç ‘)
±	(µy∑y ç Space ‘ ¥ {x | (x, y) ç AB} ç ”)
Æ);
a(rewrite_tac[product_topology_def] THEN REPEAT µ_tac THEN ¥_tac);
a(FC_T1 fc_§_canon once_rewrite_tac [open_open_neighbourhood_thm]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "1" *** *)
a(∂_tac¨BÆ THEN MERGE_PCS_T1["'bin_rel", "sets_ext1"] asm_prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨AÆ THEN MERGE_PCS_T1["'bin_rel", "sets_ext1"] asm_prove_tac[]);
val €product_topology_slice_thm› = save_pop_thm "product_topology_slice_thm";
=TEX
]%%%%
%%%%
=SML
(*
set_goal([], ¨µ” : 'a SET SET; ‘ : 'a SET SET∑ 
	” ç Topology
±	‘ ç Topology
±	Space ” ç ” Connected
±	Space ‘ ç ‘ Connected
¥	(Space ” ∏ Space ‘) ç (” ∏âT ‘) ConnectedÆ);
a(rewrite_tac[connected_def]);
a(REPEAT µ_tac THEN ¥_tac THEN ALL_FC_T rewrite_tac[product_topology_space_thm]);
a(REPEAT strip_tac);
a(cases_tac¨Space ” = {}Æ THEN1 
	(DROP_NTH_ASM_T 4 ante_tac THEN TOP_ASM_T rewrite_thm_tac
		THEN MERGE_PCS_T1 ["'bin_rel", "sets_ext1"] prove_tac[]));
a(cases_tac¨Space ‘ = {}Æ THEN1 
	(DROP_NTH_ASM_T 5 ante_tac THEN TOP_ASM_T rewrite_thm_tac
		THEN MERGE_PCS_T1 ["'bin_rel", "sets_ext1"] prove_tac[]));
a(LIST_DROP_NTH_ASM_T [1, 2]
	(MERGE_PCS_T1 ["'bin_rel", "sets_ext1"] (MAP_EVERY strip_asm_tac)));
a(all_fc_tac[product_topology_slice_thm]);
a(lemma_tac ¨
	{x'|(x', x) ç B} ¿ {x'|(x', x) ç C} =  {x'|(x', x) ç B ¿ C}
±	{y|(x', y) ç C} ¿ {y|(x', y) ç B} =  {y|(x', y) ç B ¿ C}Æ
	THEN1 MERGE_PCS_T1 ["'bin_rel", "sets_ext1"] prove_tac[]);
a(LEMMA_T ¨
	{x'|(x', x) ç B} ° {x'|(x', x) ç C} =  {x'|(x', x) ç B ° C}
±	{y|(x', y) ç C} ° {y|(x', y) ç B} =  {y|(x', y) ç B ° C}Æ
	(fn th => ante_tac th THEN asm_rewrite_tac[
		pc_rule1 "sets_ext1" prove_rule[]¨{x|F} = {}Æ ] THEN REPEAT strip_tac)
	THEN1 MERGE_PCS_T1 ["'bin_rel", "sets_ext1"] prove_tac[]);
a(lemma_tac ¨{x'|(x', x) ç B} ¿ {x'|(x', x) ç C} = Space ”±
	{y|(x', y) ç C} ¿ {y|(x', y) ç B} = Space ‘Æ
	THEN1 (asm_rewrite_tac[] THEN 
		MERGE_PCS_T1 ["'bin_rel", "sets_ext1"] prove_tac[]));
a(DROP_NTH_ASM_T 19 (ante_tac o list_µ_elim[
	¨{x'|(x', x) ç B}Æ, ¨{x'|(x', x) ç C}Æ]));
a(DROP_NTH_ASM_T 18 (ante_tac o list_µ_elim[
	¨ {y|(x', y) ç C} Æ, ¨  {y|(x', y) ç B} Æ]));
a(LIST_GET_NTH_ASM_T [1, 2, 3, 4, 7, 8, 9, 10] rewrite_tac);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T ¨(x', x) ç {x'|(x', x) ç B} ° {x'|(x', x) ç C}Æ (fn th =>  ante_tac th THEN asm_rewrite_tac[]));

a(MERGE_PCS_T1 ["'bin_rel", "sets_ext1"] REPEAT strip_tac
	THEN_TRY SOLVED_T (all_asm_fc_tac[]));
n

a(LIST_DROP_NTH_ASM_T [2, 3, 8, 9, 10, 11] discard_tac);
a(MERGE_PCS_T1 ["'bin_rel", "sets_ext1"] REPEAT strip_tac
	THEN_TRY SOLVED_T (all_asm_fc_tac[]));
a(all_asm_fc_tac[]);


val €product_topology_connected_thm› = save_pop_thm "compact_closed_thm";
*)
=TEX
\subsection{Epilogue}
=TEX
=SML
output_theory{out_file="topology.th.doc", theory="-"};
=TEX
\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}
\end{document}


