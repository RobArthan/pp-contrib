pp_make_database -f -p hol topology
docsml topology analysis
xpp -file topology.doc -com pp -d topology -i analysis,topology &
doctex topology.doc  topology[1234].th.doc ; texdvi topology
=TEX
\documentclass[10pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\title{Mathematical Case Studies: \\ --- \\ Some Abstract Topology}
\author{Rob Arthan}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
This {\ProductHOL} script contains definitions and proofs concerning some
basics of abstract topology. This includes the definitions of the following:
construction of new topologies from old as (binary) product spaces or subspaces;
continuity, Hausdorff spaces; connectedness;  compactness. A range of basic theorems are
proved, including: continuity of functional composition and of the structural maps
for products; preservation of compactness and connectedness under continuous maps;
connectedness resp. compactness of products of connected resp. compact spaces.
\end{abstract}
\vfill
\newpage
\tableofcontents
\newpage
%%%%
%%%%

%%%%
%%%%

\section{ABSTRACT TOPOLOGY --- DEFINITIONS}
%%%%
%%%%

%%%%
%%%%

=SML
force_delete_theory"topology" handle Fail _ => ();
open_theory"bin_rel";
set_merge_pcs["basic_hol1", "'sets_alg"];
new_theory"topology";
new_parent"fin_set";
=TEX
%%%%
%%%%

%%%%
%%%%

=TEX
We begin with the definition of a topology. We follow the most common tradition
of defining a topology by specifying its set of open sets. The polymorphic set
{\it Topology} is the set of all sets of sets that we will consider to be topologies.
We do not require a topology to form a topology on the universe of the type of its points.
For example, we wish to consider sets such as the unit interval in the real line to be
topological spaces in their own right. This actually simplifies the definition: we simply
require a topology to be a set of sets that is closed under arbitrary unions and
binary intersections. We do not require the underlying of the topology to 
be a non-empty set (following Kelley). Nor do we need to make a special case of
the empty set --- it will be shown to be an open set in any topology (as the union
of an empty set of open sets).
%%%%
%%%%

=SML
πHOLCONST
‹ €Topology› : 'a SET SET SET
˜¸¸¸¸¸¸
‹ 	Topology =
‹	{‘ | (µV∑ V Ä ‘ ¥ ﬁ V ç ‘) ± (µA B∑A ç ‘ ± B ç ‘ ¥ A ° B ç ‘)}
∞
=TEX
We can recover the underlying set of a topology as the union of all its open sets.
It reads quite nicely to call this the {\em space} of the topology.
%%%%
%%%%

=SML
πHOLCONST
‹ €$Space› : 'a SET SET ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ‘∑ Space ‘ = ﬁ ‘
∞
=TEX
A set is {\em closed} with respect to a topology, $\tau$, if is a subset of
the underlying set of the topology its complement in
that set is open (i.e., is a member of $\tau$).
For this and several other concepts, we use postfix notation to suggest informal
notations like ``$\tau-$closed''.
%%%%
%%%%

=SML
declare_postfix(300, "Closed");
πHOLCONST
‹ €$Closed› : 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ‘∑ ‘ Closed = {A | ∂B∑B ç ‘ ± A = Space ‘ \ B}
∞
=TEX
There are some issues about the precise formalisation of continuity.
The interesting part is completely standard: a function is continuous
iff. the inverse images of open sets are open sets. Clearly, there are
two topologies here: one for the domain of the function and one for its
range.
It is technically convenient to work with functions that are total on the
universe of the type of the domain. In any case, we want to support
something like the usual way of thinking in the calculus
where one doesn't carefully restrict every function to the domain of interest.
E.g., one says things like ``$1/\mbox{sin}\;x$ is continuous from  $(0, \pi/2)$
to the positive real numbers.``.

The upshot is the following definiition of a continuous function from
the topological space $\sigma$ to the topological space $\tau$.
The function is required to map the underlying set of $\sigma$ to that of $\tau$.
It may well also map things outside the underlying of $\sigma$ into that
of $\tau$, and these need to be filtered out when we are testing whether the
inverse image of an open set is open.
%%%%
%%%%

=SML
declare_postfix(300, "Continuous");
πHOLCONST
‹ €$Continuous› : ('a SET SET ∏ 'b SET SET) ≠ ('a ≠ 'b) SET
˜¸¸¸¸¸¸
‹ µ” ‘∑	(”, ‘) Continuous =
‹	{f
‹	|	(µx∑ x ç Space ” ¥ f x ç Space ‘)
‹	±	(µA∑ A ç ‘ ¥ {x | x ç Space ” ± f x ç A} ç ”)}
∞
=TEX
The definition of compactness is the standard one, together with the explicit
requirement that the compact set be a subset of the space of the topology in question.
%%%%
%%%%

=SML
declare_postfix(300, "Compact");
πHOLCONST
‹ €$Compact› : 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ‘∑ ‘ Compact =
‹	{A | A Ä Space ‘ ± µV∑ V Ä ‘ ± A Ä ﬁ V ¥ ∂W∑ W Ä V ± W ç Finite ± A Ä ﬁ W}
∞
=TEX
Similarly, the definition of connectedness is the standard one, together with the explicit
requirement that the connected set be a subset of the underlying set of the topology in question.
%%%%
%%%%

=SML
declare_postfix(300, "Connected");
πHOLCONST
‹ €$Connected› : 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ‘∑ ‘ Connected =
‹	{A | A Ä Space ‘
‹	± µB C∑ B ç ‘ ± C ç ‘ ± A Ä B ¿ C ± A ° B ° C = {} ¥ (A Ä B ≤ A Ä C)}
∞
=TEX
We borrow the Z symbol for range restriction (decorated with a subscript
to avoid overloading) for the operator that forms the
subspace of a topological space defined by some subset of the universe of its points.
If that subset contains points outside the underlying set of the topological space they
are ignored.
%%%%
%%%%

=SML
declare_infix(240, "ÚâT");
πHOLCONST
‹ €$ÚâT› : 'a SET ≠ 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µX ‘∑ 	(X ÚâT ‘)
‹ =	{A | ∂B∑ B ç ‘ ± A = B ° X}
∞
=TEX
The definition of the product topology is straightforward.
%%%%
%%%%

=SML
declare_infix(150, "∏âT");
πHOLCONST
‹ €$∏âT› : 'a SET SET ≠ 'b SET SET ≠ ('a ∏ 'b) SET SET
˜¸¸¸¸¸¸
‹ µ” ‘∑ 	(” ∏âT ‘)
‹ =	{C | µ x y∑ (x, y) ç C ¥ ∂A B∑ A ç ” ±  B ç ‘ ± x ç A ± y ç B  ± (A ∏ B) Ä C}
∞
=TEX
Now we define the Hausdorff condition:
%%%%
%%%%

=SML
πHOLCONST
‹ €Hausdorff› : 'a SET SET SET
˜¸¸¸¸¸¸
‹ 	Hausdorff =
‹	{‘ | µx y∑ x ç Space ‘ ± y ç Space ‘ ± ≥x = y
‹	¥	∂A B∑A ç ‘ ± B ç ‘ ± x ç A ± y ç B ± A ° B = {}}
∞
=TEX
Homeomorphisms:
%%%%
%%%%

=SML
declare_postfix(300, "Homeomorphism");
πHOLCONST
‹ €$Homeomorphism› : ('a SET SET ∏ 'b SET SET) ≠ ('a ≠ 'b) SET
˜¸¸¸¸¸¸
‹ µ” ‘∑	(”, ‘) Homeomorphism =
‹	{f
‹	|	f ç (”, ‘) Continuous
‹	±	∂g∑ 	g ç (‘, ”) Continuous
‹		±	(µx∑x ç Space ” ¥ g(f x) = x)
‹		±	(µy∑y ç Space ‘ ¥ f( g y) = y)}
∞
=TEX
\section{METRIC SPACES --- DEFINITIONS}
=SML
force_delete_theory"metric_spaces" handle Fail _ => ();
open_theory"topology";
new_theory"metric_spaces";
new_parent"analysis";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙", "'Ø"];
=TEX
Our treatment of metric spaces is very minimal. The main fact we are interested in
will be that compact subsets of metric spaces have a Lebesgue number.
The definitions involved are the concept of a metric:
%%%%
%%%%
πHOLCONST
‹ €Metric› : ('a ∏ 'a ≠ Ø) SET
˜¸¸¸¸¸¸
‹ 	Metric =
‹	{	D
‹	|	(µx y∑ ÓØ 0 º D(x, y))
‹	±	(µx y∑ D(x, y) = ÓØ 0 § x = y)
‹	±	(µx y∑ D(x, y) = D (y, x))
‹	±	(µx y z∑ D(x, z) º D (x, y) + D(y, z))}
∞
=TEX
\ldots and the concept of the metric topology:
πHOLCONST
‹ €MetricTopology› : ('a ∏ 'a ≠ Ø) ≠ 'a SET SET
˜¸¸¸¸¸¸
‹  µD∑ MetricTopology D = {A | µx∑x ç A ¥ ∂e∑ ÓØ 0 < e ± (µy∑D(x, y) < e ¥ y ç A)}
∞

%%%%
%%%%
=TEX
%%%%
%%%%
=TEX
\section{THE REAL LINE AND THE PLANE --- DEFINITIONS }
=SML
force_delete_theory"topology_Ø" handle Fail _ => ();
open_theory"metric_spaces";
new_theory"topology_Ø";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙", "'Ø"];
=TEX
%%%%
%%%%

πHOLCONST
‹ €DâR› : Ø ∏ Ø ≠ Ø
˜¸¸¸¸¸¸
‹  µx y∑ DâR(x, y) = Abs(y - x)
∞
πHOLCONST
‹ €DâR2› : (Ø ∏ Ø) ∏ (Ø ∏ Ø) ≠ Ø
˜¸¸¸¸¸¸
‹  µx1 y1 x2 y2∑ DâR2 ((x1, y1), (x2, y2)) = Abs(x2 - x1) + Abs(y2 - y1)
∞
=TEX
%%%%
%%%%
%%%%
%%%%

\section{HOMOTOPY THEORY --- DEFINITIONS}
=SML
force_delete_theory"homotopy" handle Fail _ => ();
open_theory"topology_Ø";
new_theory"homotopy";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙", "'Ø"];
=TEX
\subsection{Path Connectedness}
%%%%
%%%%
Continuing along the way towards the elements of algebraic topology, we now consider
path connectedness. Here is the definition of a path connected set. For technical convenience,
we require a path to be a continuous function on the whole real line, although the behaviour of
the path outside the closed interval $[0, 1]$ is irrelevant. This involves no
loss of generality.
%%%%
%%%%

=SML
declare_postfix(300, "PathConnected");
πHOLCONST
‹ €$PathConnected› : 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ‘∑ ‘ PathConnected =
‹	{	A
‹	|	A Ä Space ‘
‹	±	µx y∑ x ç A ± y ç A 
‹	¥	∂f∑  f ç (OpenâR, ‘) Continuous ± (µ t∑ f t ç A) ± f (ÓØ 0) = x ± f (ÓØ 1) = y}
∞
=TEX
\subsection{Homotopy}
Continuing along the way towards the elements of algebraic topology, we now consider
the notion of a homotopy. Here and elsewhere it is convenient to model functions
continuous on the unit interval by functions continuous on the whole line.
This is not problematic since any function continuous on the unit interval
can be extended to be continuous everywhere.

Our homotopies are relative to a set $X$.
%%%%
%%%%

=SML
declare_postfix(300, "Homotopy");
πHOLCONST
‹ €$Homotopy› : 'a SET SET ∏ 'a SET ∏ 'b SET SET ≠ ('a ∏ Ø ≠ 'b) SET
˜¸¸¸¸¸¸
‹ µ” X ‘∑ (”, X, ‘) Homotopy =
‹	{ f | f ç ((” ∏âT OpenâR), ‘) Continuous ± µx s t∑x ç X ¥ f(x, s) = f(x, t)}
∞
Our homotopies are relative to a set $X$.
%%%%
%%%%

=SML
declare_postfix(300, "HomotopyClass");
πHOLCONST
‹ €$HomotopyClass› : 'a SET SET ∏ 'a SET ∏ 'b SET SET ≠ ('a ≠ 'b) ≠ ('a ≠ 'b) SET
˜¸¸¸¸¸¸
‹ µ” X ‘ f∑ ((”, X, ‘) HomotopyClass) f =
‹	{ g | ∂H∑ H ç (”, X, ‘) Homotopy ± (µx∑ H(x, ÓØ 0) = f x) ± (µx∑ H(x, ÓØ 1) = g x)}
∞
=TEX
\subsection{The Path Groupoid}
=TEX
We define the path space of a space in the usual way.
For convenience, our paths are continuous functions on the whole real line.
For the time being we do not define a topology on the path space (this being a slightly thorny
topic in the literature).
%%%%
%%%%

=SML
πHOLCONST
‹ €PathSpace› : 'a SET SET ≠ (Ø ≠ 'a) SET
˜¸¸¸¸¸¸
‹ µ‘∑	PathSpace ‘ =
‹	{	f
‹	|	f ç (OpenâR, ‘) Continuous
‹(*	±	(µt∑ t º ÓØ 0 ¥ f t = f(ÓØ 0))
‹	±	(µt∑ ÓØ 1 º t ¥ f t = f(ÓØ 1)) *) }
∞
=TEX
Now we define addition of paths:
=SML
declare_infix(300, "+âP");
πHOLCONST
‹ €$+âP› : (Ø ≠ 'a) ≠ (Ø ≠ 'a) ≠ (Ø ≠ 'a)
˜¸¸¸¸¸¸
‹ µf g∑ f +âP g = (Ãt∑if t º 1/2 then f (ÓØ 2*t) else g (ÓØ 2*(t - 1/2)))
∞
The identity elements of the path space may be taken to be the constant paths of zero length:
πHOLCONST
‹ €0âP› : 'a ≠ (Ø ≠ 'a)
˜¸¸¸¸¸¸
‹ µx∑ 0âP x = (Ãt∑ x)
∞
=TEX
Now we define the inverse of a path:
=SML
πHOLCONST
‹ €$~âP› : (Ø ≠ 'a) ≠ (Ø ≠ 'a)
˜¸¸¸¸¸¸
‹ µf∑ ~âP f = (Ãt∑ f(ÓØ 1 -  t))
∞
=TEX
{\HOLindexOff
\include{topology1.th}}
{\HOLindexOff
\include{topology2.th}}
{\HOLindexOff
\include{topology3.th}}
{\HOLindexOff
\include{topology4.th}}
=TEX
%%%%
%%%%

\section{ABSTRACT TOPOLOGY --- THEOREMS}
=TEX
%%%%
%%%%
=SML
open_theory"topology";
set_merge_pcs["basic_hol1", "'sets_alg"];
=TEX
\subsection{Lemmas About Finite Sets}
=TEX
%%%%
%%%%

=SML
set_goal([], ¨
	µ A B C∑  (Insert A B) Ä C § A ç C ± B Ä C
Æ);
a(PC_T1 "sets_ext1" rewrite_tac[insert_def]);
a(prove_tac[]);
val €enum_set_Ä_thm› = save_pop_thm "enum_set_Ä_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨
	ﬁ{} = {}
±	µ A B∑  ﬁ(Insert A B) = A ¿ (ﬁB)
Æ);
a(REPEAT strip_tac THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(PC_T "sets_ext1" strip_tac);
a(rewrite_tac[ﬁ_def, insert_def, ¿_def]);
a(prove_tac[]);
val €ﬁ_enum_set_clauses› = save_pop_thm "ﬁ_enum_set_clauses";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨
	•{} = Universe
±	µ A B∑  •(Insert A B) = A ° (•B)
Æ);
a(REPEAT strip_tac THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(PC_T "sets_ext1" strip_tac);
a(rewrite_tac[•_def, insert_def, °_def]);
a(prove_tac[]);
val €•_enum_set_clauses› = save_pop_thm "•_enum_set_clauses";
val €enum_set_clauses› = list_±_intro
	[enum_set_Ä_thm,  ﬁ_enum_set_clauses, •_enum_set_clauses];
=TEX
The following should definitely go in the finite sets theory ASAP. !!! TBD !!!
%%%%
%%%%

=SML
set_goal([], ¨µA B∑
	 (A ¿ B) ç Finite § A ç Finite ± B ç Finite
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac ¨A Ä A ¿ BÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
(* *** Goal "2" *** *)
a(lemma_tac ¨B Ä A ¿ BÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨BÆ, ¨BÆ));
a(finite_induction_tac ¨AÆ THEN1 asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(LEMMA_T¨({x} ¿ A) ¿ B = {x} ¿ A ¿ BÆ
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(bc_thm_tac singleton_¿_finite_thm THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
val €¿_finite_thm› = save_pop_thm "¿_finite_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µV∑
	 V  ç Finite ± V Ä Finite ¥ ﬁV ç Finite
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µW∑ W ç Finite ± W Ä V ¥ ﬁW ç FiniteÆ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(finite_induction_tac¨WÆ);
(* *** Goal "1.1" *** *)
a(rewrite_tac[enum_set_clauses, empty_finite_thm]);
(* *** Goal "1.2" *** *)
a(LEMMA_T¨≥{x} ¿ W Ä VÆ rewrite_thm_tac);
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "1.3" *** *)
a(REPEAT strip_tac THEN
	rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa v∑ﬁ(a ¿ v) = ﬁa ¿ ﬁvÆ,
		enum_set_clauses]);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a b c∑{x} ¿ a Ä b ± b Ä c ¥ x ç cÆ]);
a(asm_rewrite_tac[¿_finite_thm]);
(* *** Goal "2" *** *)
a(POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
val €ﬁ_finite_thm› = save_pop_thm "ﬁ_finite_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ f : 'a ≠ 'b; A : 'a SET∑
	 A ç Finite ¥ {y | ∂x∑x ç A ± y = f x} ç Finite
Æ);
a(REPEAT strip_tac);
a(finite_induction_tac ¨AÆ THEN1 rewrite_tac[]);
(* *** Goal "1" *** *)
a(LEMMA_T¨{y:'b|F} = {}Æ (fn th => rewrite_tac[th, empty_finite_thm])
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨{y|∂ x'∑ x' ç {x} ¿ A ± y = f x'} = {f x} ¿ {y|∂ x'∑ x' ç A ± y = f x'}Æ
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(bc_thm_tac singleton_¿_finite_thm THEN REPEAT strip_tac);
val €finite_image_thm› = save_pop_thm "finite_image_thm";
=TEX
=TEX
%%%%
%%%%

\subsection{The Definitions}
=SML
val €topology_def› = get_spec¨$TopologyÆ;
val €space_def› = get_spec¨$SpaceÆ;
val €closed_def› = get_spec¨$ClosedÆ;
val €continuous_def› = get_spec¨$ContinuousÆ;
val €connected_def› = get_spec¨$ConnectedÆ;
val €compact_def› = get_spec¨$CompactÆ;
val €subspace_topology_def› = get_spec¨$ÚâTÆ;
val €product_topology_def› = get_spec¨$∏âTÆ;
val €hausdorff_def› = get_spec¨HausdorffÆ;
val €homeomorphism_def› = get_spec¨$HomeomorphismÆ;
=TEX
\subsection{ProofPower Generalisation and Instantiation}
=SML
fun arb_gen (thm : THM) : THM = (
	let	val ty_map = map
			(fn tv => (mk_vartype("@_" ^ tv), mk_vartype tv))
			(term_tyvars(concl thm));
		val thm1 = asm_inst_type_rule ty_map thm;
	in	all_µ_intro (all_µ_arb_elim thm1)
	end
);
=TEX
\subsection{Elementary Properties of Open and Closed Sets}
%%%%
%%%%

=SML
set_goal([], ¨µ‘ : 'a SET SET ∑ ‘ ç Topology ¥ {} ç ‘Æ);
a(rewrite_tac[topology_def] THEN REPEAT strip_tac);
a(SPEC_NTH_ASM_T 2 ¨{}: 'a SET SETÆ ante_tac);
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨ﬁ{} = {}Æ]);
val €empty_open_thm› = save_pop_thm "empty_open_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ : 'a SET SET ∑ ‘ ç Topology ¥ Space ‘ ç ‘Æ);
a(rewrite_tac[topology_def, space_def] THEN REPEAT strip_tac);
a(SPEC_NTH_ASM_T 2 ¨‘: 'a SET SETÆ ante_tac);
a(rewrite_tac[]);
val €space_open_thm› = save_pop_thm "space_open_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ : 'a SET SET ∑ ‘ ç Topology ¥ {} ç ‘ ClosedÆ);
a(rewrite_tac[closed_def] THEN REPEAT strip_tac);
a(all_fc_tac[space_open_thm]);
a(∂_tac¨Space ‘Æ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" prove_tac[]);
val €empty_closed_thm› = save_pop_thm "empty_closed_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ : 'a SET SET ∑ ‘ ç Topology ¥ Space ‘ ç ‘ ClosedÆ);
a(rewrite_tac[closed_def] THEN REPEAT strip_tac);
a(all_fc_tac[empty_open_thm]);
a(∂_tac¨{} : 'a SETÆ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" prove_tac[]);
val €space_closed_thm› = save_pop_thm "space_closed_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ A ∑
	‘ ç Topology ¥
	(A ç ‘ § µx∑x ç A ¥ ∂B∑ B ç ‘ ± x ç B ± B Ä A)Æ);
a(rewrite_tac[topology_def, space_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨AÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨A = ﬁ{B | B ç ‘ ± B Ä A}Æ);
(* *** Goal "2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN
	contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(POP_ASM_T once_rewrite_thm_tac THEN DROP_NTH_ASM_T 3 bc_thm_tac);
a(PC_T1 "sets_ext1" prove_tac[]);
val €open_open_neighbourhood_thm› = save_pop_thm "open_open_neighbourhood_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ A ∑
	‘ ç Topology ¥
	(	A ç ‘ Closed
	§ 	A Ä Space ‘
	±	µx∑x ç Space ‘  ± ≥x ç A ¥ ∂B∑ B ç ‘ ± x ç B ± B ° A = {})Æ);
a(rewrite_tac[closed_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨x ç BÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[open_open_neighbourhood_thm]);
a(∂_tac¨B'Æ THEN PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(FC_T1 fc_§_canon once_rewrite_tac [open_open_neighbourhood_thm]);
a(∂_tac¨Space ‘ \ AÆ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(all_asm_fc_tac[]);
a(∂_tac¨BÆ THEN PC_T1 "sets_ext1" asm_rewrite_tac[]);
a(rewrite_tac[space_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "3.1.1" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "3.1.2" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac) THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "3.2" *** *)
a(LIST_GET_NTH_ASM_T [1, 3] (MAP_EVERY ante_tac)  THEN PC_T1 "sets_ext1" prove_tac[]);
val €closed_open_neighbourhood_thm› = save_pop_thm "closed_open_neighbourhood_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ x A ∑
	‘ ç Topology ± x ç A ± A ç ‘ ¥ x ç Space ‘
Æ);
a(rewrite_tac[topology_def, space_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €ç_space_thm› = save_pop_thm "ç_space_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ A B ∑
	‘ ç Topology ± A ç ‘ ± B ç ‘ ¥ A ¿ B ç ‘
Æ);
a(rewrite_tac[topology_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(SPEC_NTH_ASM_T 4 ¨{A; B}Æ (strip_asm_tac o rewrite_rule[enum_set_clauses]));
val €¿_open_thm› = save_pop_thm "¿_open_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ A B ∑
	‘ ç Topology ± A ç ‘ ± B ç ‘ ¥ A ° B ç ‘
Æ);
a(rewrite_tac[topology_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €°_open_thm› = save_pop_thm "°_open_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ V∑ 
	‘ ç Topology ± V Ä ‘ ± ≥V = {} ± V ç Finite
¥	•V ç ‘Æ);
a(rewrite_tac[topology_def] THEN REPEAT strip_tac);
a(POP_ASM_T (fn th => POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN asm_tac th));
a(finite_induction_tac¨VÆ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(all_var_elim_asm_tac1 THEN rewrite_tac[]);
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µx y∑{x} Ä y § x ç yÆ]);
a(LEMMA_T¨•{x} = xÆ (fn th => rewrite_tac [th] THEN taut_tac));
(* *** Goal "3" *** *)
a(PC_T"sets_ext1" strip_tac THEN rewrite_tac[•_def] THEN prove_tac[]);
(* *** Goal "4" *** *)
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µx y z∑{x} ¿ z Ä y § x ç y ± z Ä yÆ]);
a(LEMMA_T¨•({x} ¿ V) = x ° •VÆ rewrite_thm_tac);
(* *** Goal "4.1" *** *)
a(PC_T"sets_ext1" strip_tac THEN rewrite_tac[•_def, °_def, ¿_def] THEN prove_tac[]);
(* *** Goal "4.2" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
val €finite_•_open_thm› = save_pop_thm "finite_•_open_thm";
=TEX
\subsection{Constructing New Topologies from Old}
%%%%
%%%%

=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
¥	(X ÚâT ‘) ç TopologyÆ);
a(rewrite_tac[topology_def, subspace_topology_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_ante_tac THEN1 PC_T1 "sets_ext1" REPEAT strip_tac);
a(∂_tac ¨ﬁ{C| C ç ‘ ± C ° X ç V}Æ  THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "1.1" *** *)
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.2" *** *)
a(PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.2.1" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
a(∂_tac ¨BÆ  THEN REPEAT strip_tac);
(* *** Goal "1.2.2" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
(* *** Goal "1.2.3" *** *)
a(∂_tac ¨s ° XÆ  THEN PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(∂_tac ¨B' ° B''Æ   THEN PC_T1 "sets_ext1" asm_prove_tac[]);
val €subspace_topology_thm› = save_pop_thm "subspace_topology_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ A∑ 
	‘ ç Topology
¥	Space (A ÚâT ‘) = A ° Space ‘Æ);
a(rewrite_tac[topology_def, space_def, subspace_topology_def] THEN 
	PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(∂_tac ¨BÆ  THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(∂_tac ¨s ° AÆ  THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(∂_tac ¨s Æ  THEN REPEAT strip_tac);
val €subspace_topology_space_thm› = save_pop_thm "subspace_topology_space_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘∑ 
	‘ ç Topology
¥	(Space ‘ ÚâT ‘)  = ‘Æ);
a(rewrite_tac[subspace_topology_def] THEN  REPEAT strip_tac);
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1 THEN all_fc_tac[space_open_thm]);
a(all_fc_tac[arb_gen °_open_thm]);
(* *** Goal "2" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_fc_tac[ç_space_thm]);
val €trivial_subspace_topology_thm› = save_pop_thm "trivial_subspace_topology_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET∑ 
	” ç Topology
±	‘ ç Topology
¥	(” ∏âT ‘) ç TopologyÆ);
a(rewrite_tac[topology_def, product_topology_def]
	THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LIST_DROP_NTH_ASM_T  [3] all_fc_tac);
a(∂_tac¨AÆ  THEN ∂_tac ¨BÆ THEN REPEAT strip_tac);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx y z∑x Ä y ± y ç z ¥ x Ä ﬁ zÆ]);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T  [3, 4] all_fc_tac);
a(∂_tac¨A' ° A''Æ  THEN ∂_tac ¨B' ° B''Æ THEN REPEAT strip_tac
	THEN_TRY SOLVED_T (all_asm_fc_tac[]));
a(MERGE_PCS_T1["'bin_rel", "sets_ext1"] asm_prove_tac[]);
val €product_topology_thm› = save_pop_thm "product_topology_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET∑ 
	” ç Topology
±	‘ ç Topology
¥	Space  (” ∏âT ‘)  = (Space ” ∏ Space ‘)Æ);
a(rewrite_tac[product_topology_def, space_def]);
a(MERGE_PCS_T1["'bin_rel", "sets_ext1"] REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[] THEN contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨s ∏ s'Æ THEN MERGE_PCS_T1["'bin_rel", "sets_ext1"] REPEAT strip_tac);
a(∂_tac¨sÆ THEN ∂_tac¨s'Æ THEN MERGE_PCS_T1["'bin_rel", "sets_ext1"] REPEAT strip_tac);
val €product_topology_space_thm› = save_pop_thm "product_topology_space_thm";
=TEX
\subsection{Continuity}
%%%%
%%%%

=SML
set_goal([], ¨µ” ‘ c∑ 
	” ç Topology
±	‘ ç Topology
±	c ç Space ‘
¥	(Ãx∑ c) ç (”, ‘) Continuous
Æ);
a(REPEAT strip_tac);
a(rewrite_tac[continuous_def, topology_def] THEN 
	PC_T1 "sets_ext1" REPEAT strip_tac);
a(cases_tac¨c ç AÆ THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(rewrite_tac[pc_rule1"sets_ext" prove_rule[]¨{x | x ç Space ”} = Space ”Æ]);
a(all_asm_fc_tac[space_open_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[pc_rule1"sets_ext" prove_rule[]¨{x | F} = {}Æ]);
a(all_asm_fc_tac[empty_open_thm]);
val €const_continuous_thm› = save_pop_thm "const_continuous_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘∑ 
	‘ ç Topology
¥	(Ãx∑ x) ç (‘, ‘) Continuous
Æ);
a(rewrite_tac[continuous_def, topology_def, space_def] THEN 
	PC_T1 "sets_ext1" REPEAT strip_tac);
a(LEMMA_T ¨ {x|x ç ﬁ ‘ ± x ç A} = AÆ  asm_rewrite_thm_tac);
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext1"  prove_tac[]);
val €id_continuous_thm› = save_pop_thm "id_continuous_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µf g “ ” ‘∑ 
	f ç (“, ”) Continuous
±	g ç (”, ‘) Continuous
±	“ ç Topology
±	” ç Topology
±	‘ ç Topology
¥	(Ãx∑ g(f x)) ç (“, ‘) Continuous
Æ);
a(rewrite_tac[continuous_def] THEN REPEAT strip_tac THEN
	(all_asm_fc_tac[] THEN all_asm_fc_tac[]));
a( LEMMA_T ¨{x|x ç Space “ ± g (f x) ç A} ={x|x ç Space “ ± f x ç {x|x ç Space ” ± g x ç A}}Æ
	once_rewrite_thm_tac THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" prove_tac[] THEN all_asm_fc_tac[]);
val €comp_continuous_thm› = save_pop_thm "comp_continuous_thm";
=TEX
The following theorem about the continuity of a function defined by cases is not
the most general of its type, but it should be suffficient for the intended applications
in, for example, showing the continuity of a piecewise linear function.
%%%%
%%%%

=SML
set_goal([], ¨µf g X ” ‘∑ 
	f ç (”, ‘) Continuous
±	g ç (”, ‘) Continuous
±	(µx∑x ç Space ” ±  (µA∑x ç A ± A ç ” ¥ ∂y z∑y ç A ± z ç A ± y ç X ± ≥z ç X)
		¥ f x = g x)
±	” ç Topology
±	‘ ç Topology
¥	(Ãx∑ if x ç X then f x else g x) ç (”, ‘) Continuous
Æ);
a(rewrite_tac[continuous_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(cases_tac¨x ç XÆ THEN asm_rewrite_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(ALL_FC_T1 fc_§_canon once_rewrite_tac[open_open_neighbourhood_thm]);
a(strip_tac THEN rewrite_tac[]);
a(cases_tac¨x ç XÆ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(cases_tac¨≥ µ A∑ x ç A ± A ç ” ¥ (∂ y z∑ y ç A ± z ç A ± y ç X ± ≥ z ç X)Æ);
(* *** Goal "2.1.1" *** *)
a(LIST_DROP_NTH_ASM_T [13] all_fc_tac);
a(∂_tac¨{x|x ç Space ” ± f x ç A} ° A'Æ);
a(REPEAT strip_tac);
(* *** Goal "2.1.1.1" *** *)
a(bc_thm_tac °_open_thm THEN REPEAT strip_tac);
(* *** Goal "2.1.1.2" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(spec_nth_asm_tac 5 ¨xÆ);
a(spec_nth_asm_tac 1 ¨x'Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a(LIST_DROP_NTH_ASM_T [9, 11] all_fc_tac);
a(∂_tac¨{x|x ç Space ” ± f x ç A} ° {x | x ç Space ” ± g x ç A}Æ);
a(REPEAT strip_tac);
(* *** Goal "2.1.2.1" *** *)
a(bc_thm_tac °_open_thm THEN REPEAT strip_tac);
(* *** Goal "2.1.2.2" *** *)
a(LEMMA_T¨f x = g xÆ (asm_rewrite_thm_tac o eq_sym_rule));
a(all_asm_fc_tac[]);
(* *** Goal "2.1.2.3" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(cases_tac ¨x' ç XÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(cases_tac¨≥ µ A∑ x ç A ± A ç ” ¥ (∂ y z∑ y ç A ± z ç A ± y ç X ± ≥ z ç X)Æ);
(* *** Goal "2.2.1" *** *)
a(LIST_DROP_NTH_ASM_T [11] all_fc_tac);
a(∂_tac¨{x|x ç Space ” ± g x ç A} ° A'Æ);
a(REPEAT strip_tac);
(* *** Goal "2.2.1.1" *** *)
a(bc_thm_tac °_open_thm THEN REPEAT strip_tac);
(* *** Goal "2.2.1.2" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(spec_nth_asm_tac 5 ¨x'Æ);
a(spec_nth_asm_tac 1 ¨xÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a(LIST_DROP_NTH_ASM_T [9, 11] all_fc_tac);
a(∂_tac¨{x|x ç Space ” ± f x ç A} ° {x | x ç Space ” ± g x ç A}Æ);
a(REPEAT strip_tac);
(* *** Goal "2.2.2.1" *** *)
a(bc_thm_tac °_open_thm THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2" *** *)
a(LEMMA_T¨f x = g xÆ asm_rewrite_thm_tac);
a(all_asm_fc_tac[]);
(* *** Goal "2.2.2.3" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(cases_tac ¨x' ç XÆ THEN asm_rewrite_tac[]);
val €cond_continuous_thm› = save_pop_thm "cond_continuous_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET∑ 
	” ç Topology
±	‘ ç Topology
¥	(Ã(x, y)∑ x) ç ((” ∏âT ‘), ”) Continuous
Æ);
a(REPEAT strip_tac THEN rewrite_tac[continuous_def]);
a(all_fc_tac[arb_gen product_topology_thm]);
a(ALL_FC_T rewrite_tac [arb_gen product_topology_space_thm]);
a(rewrite_tac[product_topology_def, ∏_def] THEN REPEAT strip_tac);
a(∂_tac¨AÆ THEN ∂_tac¨Space ‘Æ THEN 
	ALL_FC_T asm_rewrite_tac[space_open_thm]);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(all_fc_tac[ç_space_thm]);
val €left_proj_continuous_thm› = save_pop_thm "left_proj_continuous_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET∑ 
	” ç Topology
±	‘ ç Topology
¥	(Ã(x, y)∑ y) ç ((” ∏âT ‘), ‘) Continuous
Æ);
a(REPEAT strip_tac THEN rewrite_tac[continuous_def]);
a(all_fc_tac[arb_gen product_topology_thm]);
a(ALL_FC_T rewrite_tac [arb_gen product_topology_space_thm]);
a(rewrite_tac[product_topology_def, ∏_def] THEN REPEAT strip_tac);
a(∂_tac¨Space ”Æ THEN ∂_tac¨AÆ THEN 
	ALL_FC_T asm_rewrite_tac[space_open_thm]);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(all_fc_tac[ç_space_thm]);
val €right_proj_continuous_thm› = save_pop_thm "right_proj_continuous_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ f : 'a ≠ 'b; g : 'a ≠ 'c; “ : 'a SET SET; ” : 'b SET SET; ‘ : 'c SET SET∑ 
	f ç (“, ”) Continuous
±	g ç (“, ‘) Continuous
±	“ ç Topology
±	” ç Topology
±	‘ ç Topology
¥	(Ãz∑(f z, g z)) ç (“, (” ∏âT ‘)) Continuous
Æ);
a(REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [4, 5] (MAP_EVERY ante_tac));
a(rewrite_tac[continuous_def]);
a(all_fc_tac[arb_gen product_topology_thm]);
a(ALL_FC_T rewrite_tac [arb_gen product_topology_space_thm]);
a(rewrite_tac[product_topology_def, ∏_def] THEN REPEAT strip_tac
	THEN_TRY (SOLVED_T (all_asm_fc_tac[])));
a(LIST_DROP_NTH_ASM_T (interval 6 16) discard_tac
	THEN ALL_FC_T1 fc_§_canon once_rewrite_tac[open_open_neighbourhood_thm]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(LIST_DROP_NTH_ASM_T [11, 13] all_fc_tac);
a(∂_tac¨{x|x ç Space “ ± g x ç B} ° {x|x ç Space “ ± f x ç A'}Æ);
a(ALL_FC_T rewrite_tac[°_open_thm]);
a(REPEAT strip_tac THEN PC_T1"sets_ext1" REPEAT strip_tac);
a(bc_thm_tac (pc_rule1"sets_ext" prove_rule[]¨µa xy∑xy ç a ± a Ä A ¥ xy ç AÆ));
a(∂_tac¨{(v, w)|v ç A' ± w ç B}Æ THEN REPEAT strip_tac);
val €product_continuous_thm› = save_pop_thm "product_continuous_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET; y : 'b∑ 
	” ç Topology
±	‘ ç Topology
±	y ç Space ‘
¥	(Ãx∑ (x, y)) ç (”, ” ∏âT ‘) Continuous
Æ);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨Ãx:'a∑ xÆ, ¨Ãx:'a∑yÆ, ¨”Æ, ¨”Æ, ¨‘Æ] product_continuous_thm));
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm, const_continuous_thm]);
val €left_product_inj_continuous_thm› = save_pop_thm "left_product_inj_continuous_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ”: 'a SET SET; ‘ : 'b SET SET; x : 'a∑ 
	” ç Topology
±	‘ ç Topology
±	x ç Space ”
¥	(Ãy∑ (x, y)) ç (‘, ” ∏âT ‘) Continuous
Æ);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨Ãy:'b∑ xÆ, ¨Ãy:'b∑yÆ, ¨‘Æ, ¨”Æ, ¨‘Æ] product_continuous_thm));
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm, arb_gen const_continuous_thm]);
val €right_product_inj_continuous_thm› = save_pop_thm "right_product_inj_continuous_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ ‘ : 'a SET SET∑ 
	‘ ç Topology
¥	(Ãx∑ (x, x)) ç (‘, ‘ ∏âT ‘) Continuous
Æ);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨Ãx:'a∑ xÆ, ¨Ãx:'a∑xÆ, ¨‘Æ, ¨‘Æ, ¨‘Æ] product_continuous_thm));
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm, arb_gen const_continuous_thm]);
val €diag_inj_continuous_thm› = save_pop_thm "diag_inj_continuous_thm";
=TEX
\subsection{Hausdorff Property}
=TEX
Any subspace of a Hausdorff space is Hausdorff:
%%%%
%%%%

=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
±	‘ ç Hausdorff
¥	(X ÚâT ‘) ç Hausdorff
Æ);
a(rewrite_tac [hausdorff_def]);
a(REPEAT µ_tac THEN ¥_tac);
a(ALL_FC_T rewrite_tac [subspace_topology_space_thm]);
a(rewrite_tac[subspace_topology_def] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(∂_tac¨A ° XÆ THEN ∂_tac ¨B ° XÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨AÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(∂_tac¨BÆ THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext1" prove_tac[]);
val €subspace_topology_hausdorff_thm› = save_pop_thm "subspace_topology_hausdorff_thm";
=TEX
A product Hausdorff spaces is Hausdorff:
%%%%
%%%%

=SML
set_goal([], ¨µ” ‘∑ 
	” ç Topology
±	‘ ç Topology
±	” ç Hausdorff
±	‘ ç Hausdorff
¥	(” ∏âT ‘) ç Hausdorff
Æ);
a(rewrite_tac [hausdorff_def]);
a(REPEAT µ_tac THEN ¥_tac);
a(ALL_FC_T rewrite_tac [product_topology_space_thm]);
a(rewrite_tac[product_topology_def, 
	pc_rule1"prop_eq_pair" prove_rule[]
		¨µp q∑≥p = q § ≥Fst p = Fst q ≤ ≥Snd p = Snd qÆ,
	merge_pcs_rule1["'bin_rel", "sets_ext1"] prove_rule[]
		¨µp a b∑p ç (a ∏ b) § Fst p ç a ± Snd p ç bÆ]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
a(∂_tac¨A ∏ Space ‘Æ THEN ∂_tac ¨B ∏ Space ‘Æ);
a(rewrite_tac[merge_pcs_rule1["'bin_rel", "sets_ext1"] prove_rule[]
		¨µp a b∑p ç (a ∏ b) § Fst p ç a ± Snd p ç bÆ]
	THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(∂_tac¨AÆ THEN ∂_tac ¨Space ‘Æ THEN ALL_FC_T asm_rewrite_tac[space_open_thm]);
(* *** Goal "1.2" *** *)
a(∂_tac¨BÆ THEN ∂_tac ¨Space ‘Æ THEN ALL_FC_T asm_rewrite_tac[space_open_thm]);
a(asm_rewrite_tac[merge_pcs_rule1["'bin_rel", "sets_ext1"] prove_rule[]
		¨µa b c d∑ (a ∏ b) ° (c ∏ d) = ((a ° c) ∏ (b ° d))  ± ({} ∏ a) = {}Æ]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
a(∂_tac¨Space ” ∏ AÆ THEN ∂_tac ¨Space ” ∏ BÆ);
a(rewrite_tac[merge_pcs_rule1["'bin_rel", "sets_ext1"] prove_rule[]
		¨µp a b∑p ç (a ∏ b) § Fst p ç a ± Snd p ç bÆ]
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(∂_tac¨Space ”Æ THEN ∂_tac ¨AÆ THEN ALL_FC_T asm_rewrite_tac[space_open_thm]);
(* *** Goal "2.2" *** *)
a(∂_tac¨Space ”Æ THEN ∂_tac ¨BÆ THEN ALL_FC_T asm_rewrite_tac[space_open_thm]);
a(asm_rewrite_tac[merge_pcs_rule1["'bin_rel", "sets_ext1"] prove_rule[]
		¨µa b c d∑ (a ∏ b) ° (c ∏ d) = ((a ° c) ∏ (b ° d))  ± (a ∏ {}) = {}Æ]);
val €product_topology_hausdorff_thm› = save_pop_thm "product_topology_hausdorff_thm";
=TEX
\subsection{Compactness}
%%%%
%%%%

%%%%
%%%%

=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
¥	(X ç ‘ Compact § X ç (X ÚâT ‘) Compact)Æ);
a(rewrite_tac[compact_def] THEN PC_T1 "sets_ext1" REPEAT µ_tac THEN ¥_tac);
a(ALL_FC_T1 fc_§_canon rewrite_tac[subspace_topology_space_thm]);
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b∑a Ä a ° b § a Ä bÆ]);
a(rewrite_tac[subspace_topology_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨X Ä ﬁ{B | B ç ‘ ± B ° X ç V} Æ THEN1 PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(LIST_GET_NTH_ASM_T [1, 2, 3] (PC_T1 "sets_ext1" (MAP_EVERY strip_asm_tac)));
a(all_asm_fc_tac[]);
a(LIST_GET_NTH_ASM_T [3] all_fc_tac THEN all_var_elim_asm_tac1);
a(∂_tac¨BÆ THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(lemma_tac¨{B | B ç ‘ ± B ° X ç V} Ä ‘Æ THEN1 PC_T1 "sets_ext" prove_tac[]);
a(all_asm_fc_tac[]);
a(ante_tac(list_µ_elim[¨ÃB∑B ° XÆ, ¨WÆ]finite_image_thm));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac ¨{C|∂ B∑ B ç W ± C = B ° X}Æ THEN REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(PC_T "sets_ext1"  strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(LIST_GET_NTH_ASM_T [5] (PC_T1 "sets_ext1" all_fc_tac));
(* *** Goal "1.2.2" *** *)
a(PC_T "sets_ext1"  strip_tac THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [3] (PC_T1 "sets_ext1" all_fc_tac));
a(∂_tac¨s ° XÆ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(lemma_tac¨X Ä ﬁ{C | ∂B∑ B ç V ± C = B ° X} Æ THEN1 PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(LIST_GET_NTH_ASM_T [2] (PC_T1 "sets_ext1" all_fc_tac));
a(∂_tac¨s ° XÆ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(lemma_tac¨{C | ∂B∑ B ç V ± C = B ° X} Ä {A|∂ B∑ B ç ‘ ± A = B ° X}Æ
	THEN1 (PC_T "sets_ext" strip_tac THEN REPEAT strip_tac));
(* *** Goal "2.2.1" *** *)
a(all_var_elim_asm_tac1 THEN ∂_tac ¨BÆ THEN 
	REPEAT strip_tac THEN PC_T1 "sets_ext1" all_asm_fc_tac[]);
(* *** Goal "2.2.2" *** *)
a(all_asm_fc_tac[]);
a(lemma_tac¨∂f∑µC∑ C ç W ¥ f C ç V ± C = f C ° XÆ THEN1 prove_∂_tac);
(* *** Goal "2.2.2.1" *** *)
a(REPEAT strip_tac);
a(cases_tac¨≥C' ç WÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 4 (PC_T1 "sets_ext1" strip_asm_tac));
a(LIST_DROP_NTH_ASM_T [1] all_fc_tac);
a(all_var_elim_asm_tac1 THEN ∂_tac¨BÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2" *** *)
a(strip_asm_tac(list_µ_elim[¨fÆ, ¨WÆ]finite_image_thm));
a(∂_tac¨{y|∂ x∑ x ç W ± y = f x}Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(PC_T "sets_ext1"  strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a(PC_T "sets_ext1"  strip_tac THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (PC_T1 "sets_ext1" strip_asm_tac));
a(LIST_DROP_NTH_ASM_T [1] all_fc_tac);
a(∂_tac¨f sÆ THEN asm_rewrite_tac[]);
a(LIST_DROP_NTH_ASM_T [5] all_fc_tac);
a(DROP_NTH_ASM_T 4 ante_tac);
a(POP_ASM_T (fn th => conv_tac(LEFT_C(once_rewrite_conv[th]))));
a(REPEAT strip_tac THEN rename_tac[]);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
val €compact_topological_thm› = save_pop_thm "compact_topological_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µf C ” ‘∑ 
	f ç (”, ‘) Continuous
±	C ç ” Compact
±	” ç Topology
±	‘ ç Topology
¥	{y | ∂x∑ x ç C ± y = f x} ç ‘ Compact
Æ);
a(rewrite_tac[compact_def, continuous_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac );
a(all_var_elim_asm_tac1 THEN PC_T1 "sets_ext1" all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨{A | ∂B∑ B ç V ± A = {x|x ç Space ” ± f x ç B}} Ä ”Æ);
(* *** Goal "2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN GET_NTH_ASM_T 8 bc_thm_tac);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a b∑x ç a ± a Ä b ¥ x ç bÆ]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨C Ä ﬁ{A | ∂B∑ B ç V ± A = {x|x ç Space ” ± f x ç B}}Æ);
(* *** Goal "2.2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(LEMMA_T¨f x ç {y|∂ x∑ x ç C ± y = f x}Æ  asm_tac THEN1
	(REPEAT strip_tac THEN ∂_tac¨xÆ THEN REPEAT strip_tac));
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a b∑x ç a ± a Ä b ¥ x ç bÆ]);
a(∂_tac¨{x|x ç Space ” ± f x ç s}Æ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(all_asm_fc_tac[]);
a(lemma_tac¨∂h∑µA∑ A ç W ¥ h A ç V ± A = {x | x ç Space ” ± f x ç h A}Æ
	THEN1 prove_∂_tac THEN REPEAT strip_tac);
 (* *** Goal "2.2.2.1" *** *)
a(cases_tac ¨A' ç WÆ  THEN asm_rewrite_tac[]);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a b∑x ç a ± a Ä b ¥ x ç bÆ]);
a(∂_tac¨BÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2" *** *)
a(strip_asm_tac (list_µ_elim[¨hÆ, ¨WÆ] finite_image_thm));
a(∂_tac¨{y|∂ x∑ x ç W ± y = h x}Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 7 discard_tac);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µb∑x' ç C ± C Ä b ¥ x' ç bÆ]);
a(∂_tac¨h sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.2.1" *** *)
a(all_asm_fc_tac[]);
a(POP_ASM_T (fn th => DROP_NTH_ASM_T 5 (ante_tac o once_rewrite_rule[th])));
a(REPEAT strip_tac);
(* *** Goal "2.2.2.2.2.2" *** *)
a(∂_tac¨sÆ THEN REPEAT strip_tac);
val €image_compact_thm› = save_pop_thm "image_compact_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µC D ”∑ 
	C ç ” Compact
±	D ç ” Compact
±	” ç Topology
¥	C ¿ D ç ” Compact
Æ);
a(rewrite_tac[compact_def] THEN REPEAT strip_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b c∑a ¿ b Ä c ¥ a Ä c ± b Ä cÆ]);
a(all_asm_fc_tac[]);
a(∂_tac ¨W ¿ W'Æ THEN
	rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b∑ﬁ(a ¿ b) = ﬁa ¿ ﬁbÆ]
	THEN ALL_FC_T rewrite_tac[
	pc_rule1"sets_ext1" prove_rule[]¨µa b c∑a Ä c ± b Ä c ¥ a ¿ b Ä cÆ,
	pc_rule1"sets_ext1" prove_rule[]¨µa b c d∑a Ä c ± b Ä d ¥ a ¿ b Ä d ¿ cÆ,
	conv_rule(ONCE_MAP_C eq_sym_conv) ¿_finite_thm]);
val €¿_compact_thm› = save_pop_thm "¿_compact_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µU ‘ X∑ 
	‘ ç Topology
±	U Ä ‘
±	(µA∑µx∑ x ç A ± A ç ‘ ¥ ∂B∑ x ç B ± B Ä A ± B ç U)
±	X Ä Space ‘
±	(µV∑ V Ä U ± X Ä ﬁ V ¥ ∂ W∑ W Ä V ± W ç Finite ± X Ä ﬁ W)
¥	X ç ‘ Compact
Æ);
a(rewrite_tac[compact_def] THEN REPEAT strip_tac);
a(lemma_tac¨{B | B ç U ± ∂ A∑ A ç V ± B Ä A} Ä UÆ THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(lemma_tac¨X Ä ﬁ{B | B ç U ± ∂ A∑ A ç V ± B Ä A}Æ
	THEN1 PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 3 (fn th => PC_T1 "sets_ext1" all_fc_tac[th]));
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a∑x ç a ± a Ä ‘ ¥ x ç ‘Æ]);
a(DROP_NTH_ASM_T 9 (fn th => all_fc_tac[th]));
a(∂_tac¨BÆ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 5 (fn th => all_fc_tac[th]));
a(lemma_tac¨∂f∑µB∑B ç W ¥ f B ç V ± B Ä f BÆ THEN1 prove_∂_tac);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac THEN cases_tac¨B' ç WÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 4 (fn th => all_fc_tac[pc_rule1 "sets_ext1" once_rewrite_rule[] th]));
a(∂_tac ¨AÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(ante_tac(list_µ_elim[¨fÆ, ¨WÆ] finite_image_thm) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(∂_tac ¨{y|∂ x∑ x ç W ± y = f x}Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (fn th => all_fc_tac[pc_rule1 "sets_ext1" once_rewrite_rule[] th]));
a(∂_tac ¨f sÆ THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.2.2.1" *** *)
a(PC_T1 "sets_ext" asm_prove_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(∂_tac ¨sÆ THEN asm_rewrite_tac[] );
val €compact_basis_thm› = save_pop_thm "compact_basis_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ” ‘ X∑ 
	” ç Topology
±	‘ ç Topology
±	X Ä Space (” ∏âT ‘)
±	(µV∑ 	V Ä (” ∏âT ‘)
	±	(µD∑ D ç V ¥ ∂B C∑ B ç ” ± C ç ‘ ± D = (B ∏ C))
	±	X Ä ﬁ V
	¥	∂ W∑ W Ä V ± W ç Finite ± X Ä ﬁ W)
¥	X ç (” ∏âT ‘) Compact
Æ);
a(REPEAT strip_tac THEN bc_thm_tac compact_basis_thm);
a(ALL_FC_T asm_rewrite_tac[product_topology_thm]);
a(∂_tac¨{D | ∂B C∑ B ç ” ± C ç ‘ ± D = (B ∏ C)}Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[product_topology_def] THEN PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(∂_tac¨BÆ THEN ∂_tac¨CÆ THEN asm_rewrite_tac[]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[∏_def]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[product_topology_def] THEN REPEAT strip_tac);
a(POP_ASM_T (ante_tac o list_µ_elim[¨Fst xÆ, ¨Snd xÆ]));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨A' ∏ BÆ THEN REPEAT strip_tac THEN1 asm_rewrite_tac[∏_def]);
a(∂_tac¨A'Æ THEN ∂_tac¨BÆ THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 2 (fn th => ante_tac(pc_rule1 "sets_ext1" once_rewrite_rule[] th)));
a(rewrite_tac[taut_rule¨µp1 p2∑(p1 ¥ p2 ± p1) § p1 ¥ p2Æ]);
a(REPEAT strip_tac THEN PC_T "sets_ext" strip_tac THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
a(rewrite_tac[product_topology_def] THEN REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[∏_def]));
a(∂_tac¨BÆ THEN ∂_tac¨CÆ THEN asm_rewrite_tac[]);
val €compact_basis_product_topology_thm› = save_pop_thm "compact_basis_product_topology_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ” ‘ W x∑ 
	” ç Topology
±	‘ ç Topology
±	x ç Space ”
±	W ç Finite
±	(µD∑D ç W ¥ ∂B C∑ x ç B ± B ç ” ± C ç ‘ ± D = (B ∏ C))
¥	∂A∑ x ç A ± A ç ” ± µt y∑(x, y) ç ﬁW ± t ç A ¥ (t, y) ç ﬁWÆ);
a(REPEAT strip_tac);
a(lemma_tac¨µV∑ V ç Finite ± V Ä W ¥
	∂A∑ x ç A ± A ç ” ± µt y∑(x, y) ç ﬁV ± t ç A ¥ (t, y) ç ﬁVÆ);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(finite_induction_tac ¨VÆ);
(* *** Goal "1.1" *** *)
a(rewrite_tac[enum_set_clauses]);
a(all_fc_tac[space_open_thm] THEN contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a(LEMMA_T ¨≥{x'} ¿ V Ä WÆ rewrite_thm_tac);
a(GET_NTH_ASM_T 2 ante_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.3" *** *)
a(REPEAT strip_tac);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[] ¨µx a b∑ {x} ¿ a Ä b ¥ x ç bÆ]);
a(LIST_DROP_NTH_ASM_T [8] all_fc_tac);
a(all_var_elim_asm_tac1 THEN rewrite_tac[enum_set_clauses,
	pc_rule1"sets_ext1" prove_rule[]¨µa v∑ﬁ(a ¿ v) = ﬁa ¿ ﬁvÆ]);
a(∂_tac ¨B ° AÆ THEN REPEAT strip_tac);
(* *** Goal "1.3.1" *** *)
a(bc_thm_tac °_open_thm THEN REPEAT strip_tac);
(* *** Goal "1.3.2" *** *)
a(swap_nth_asm_concl_tac 1 THEN LIST_DROP_NTH_ASM_T [3, 4] (MAP_EVERY ante_tac));
a(rewrite_tac[∏_def] THEN prove_tac[]);
(* *** Goal "1.3.3" *** *)
a(LEMMA_T ¨(x, y) ç ﬁVÆ asm_tac THEN1
	(LIST_DROP_NTH_ASM_T [5, 4] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext" prove_tac[]));
a(LIST_DROP_NTH_ASM_T [13] all_fc_tac);
a(contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
val €compact_product_lemma› = save_pop_thm "compact_product_lemma";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µX : 'a SET; Y : 'b SET; ” ‘ ∑ 
	X ç ” Compact
±	Y ç ‘ Compact
±	” ç Topology
±	‘ ç Topology
¥	(X ∏ Y) ç (” ∏âT ‘) CompactÆ);
a(REPEAT strip_tac THEN bc_thm_tac compact_basis_product_topology_thm);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[product_topology_space_thm]);
a(all_asm_ante_tac THEN rewrite_tac[compact_def] THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [4, 6] (MAP_EVERY ante_tac) THEN
	MERGE_PCS_T1 ["'bin_rel", "sets_ext1"] prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac ¨∂W∑µx∑ x ç X ¥
	W x Ä V ± W x ç Finite ± (µy∑y ç Y ¥ (x, y) ç ﬁ(W x)) ±
	µD∑ D ç W x ¥ (∂ B C∑ x ç B ± B ç ” ± C ç ‘ ± D = (B ∏ C))Æ
	THEN1 prove_∂_tac THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(cases_tac ¨x' ç XÆ THEN asm_rewrite_tac[]);
a(lemma_tac ¨x' ç Space ”Æ THEN1
	(LIST_DROP_NTH_ASM_T [1, 8] (MAP_EVERY ante_tac) THEN
	rewrite_tac[compact_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(strip_asm_tac (list_µ_elim[¨”Æ, ¨‘Æ, ¨x'Æ] right_product_inj_continuous_thm));
a(lemma_tac ¨(” ∏âT ‘) ç TopologyÆ THEN1 all_fc_tac[product_topology_thm]);
a(ante_tac (list_µ_elim[¨Ãy:'b∑(x', y)Æ, ¨YÆ, ¨‘Æ, ¨” ∏âT ‘Æ] image_compact_thm));
a(asm_rewrite_tac[compact_def] THEN REPEAT strip_tac);
a(lemma_tac¨x' ç X ¥ {y|∂ x∑ x ç Y ± Fst y = x' ± Snd y = x} Ä (X ∏ Y)Æ
	THEN1 (MERGE_PCS_T1 ["'bin_rel", "sets_ext" ] prove_tac[]
		THEN all_var_elim_asm_tac1));
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b c∑a Ä b ± b Ä c ¥ a Ä cÆ]);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac);
a(POP_ASM_T (PC_T1 "sets_ext1" strip_asm_tac));
a(∂_tac ¨{A | A ç W ± ∂y∑(x', y) ç A}Æ THEN PC_T1 "basic_hol" REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.1.2" *** *)
a(bc_thm_tac Ä_finite_thm THEN ∂_tac ¨WÆ THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.1.3" *** *)
a(lemma_tac¨(x', y) ç ﬁWÆ);
(* *** Goal "2.1.3.1" *** *)
a(DROP_NTH_ASM_T 2 bc_thm_tac THEN REPEAT strip_tac);
a(∂_tac¨yÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.1.3.2" *** *)
a(REPEAT strip_tac);
a(∂_tac¨sÆ THEN asm_rewrite_tac[]);
a(∂_tac¨yÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.1.4" *** *)
a(lemma_tac¨D ç VÆ THEN1 (
	LIST_DROP_NTH_ASM_T [1, 4] (MAP_EVERY ante_tac)
		THEN PC_T1 "sets_ext" prove_tac[]));
a(LIST_DROP_NTH_ASM_T [14] all_fc_tac);
a(∂_tac¨BÆ THEN ∂_tac¨CÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 5 ante_tac THEN all_var_elim_asm_tac1);
a(prove_tac[∏_def]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨X Ä ﬁ{A | A ç ” ±∂x∑x ç X ±  x ç A ± µt y∑t ç A ± y ç Y ¥ (t, y) ç ﬁ(W x)}Æ
	THEN1 PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(lemma_tac ¨x ç Space ”Æ THEN1
	(LIST_DROP_NTH_ASM_T [1, 9] (MAP_EVERY ante_tac) THEN
	rewrite_tac[compact_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(DROP_NTH_ASM_T 3 (strip_asm_tac o µ_elim¨xÆ));
a(all_fc_tac[compact_product_lemma]);
a(∂_tac¨AÆ THEN REPEAT strip_tac);
a(∂_tac¨xÆ THEN PC_T1 "basic_hol" REPEAT strip_tac);
a(PC_T1 "basic_hol" (LIST_DROP_NTH_ASM_T [7])  all_fc_tac);
a(PC_T1 "basic_hol" (LIST_DROP_NTH_ASM_T [4])  all_fc_tac);
(* *** Goal "2.2.2" *** *)
a(lemma_tac¨{A | A ç ” ±∂x∑x ç X ±  x ç A ± µt y∑t ç A ± y ç Y ¥ (t, y) ç ﬁ(W x)} Ä ”Æ
	THEN1 PC_T1 "sets_ext" prove_tac[]);
a(GET_NTH_ASM_T 10 (fn th => all_fc_tac[rewrite_rule[compact_def] th]));
a(LIST_DROP_NTH_ASM_T [4, 5, 7, 8] discard_tac);
a(lemma_tac¨∂U∑µA∑A ç W' ¥ (µ t y∑ t ç A ± y ç Y ¥ (t, y) ç ﬁ (U A)) ± U A Ä V ± U A ç FiniteÆ
	THEN1 prove_∂_tac);
(* *** Goal "2.2.2.1" *** *)
a(REPEAT strip_tac);
a(cases_tac¨A' ç W'Æ THEN asm_rewrite_tac[]);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a b∑x ç a ± a Ä b ¥ x ç bÆ]);
a(∂_tac¨W xÆ THEN  POP_ASM_T ante_tac THEN ALL_ASM_FC_T rewrite_tac[] THEN taut_tac);
(* *** Goal "2.2.2.2" *** *)
a(∂_tac¨ﬁ{y|∂ x∑ x ç W' ± y = U x}Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [3] all_asm_fc_tac);
a(LIST_DROP_NTH_ASM_T [2, 4] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a(ante_tac (list_µ_elim[¨UÆ, ¨W'Æ] finite_image_thm) THEN asm_rewrite_tac[] THEN strip_tac);
a(bc_thm_tac ﬁ_finite_thm THEN REPEAT strip_tac);
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.3" *** *)
a(MERGE_PCS_T1 ["'bin_rel", "sets_ext1"] REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [4] (PC_T1"sets_ext1" all_fc_tac));
a(LIST_DROP_NTH_ASM_T [5] all_fc_tac);
a(∂_tac¨s'Æ THEN REPEAT strip_tac);
a(∂_tac¨U sÆ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
val €product_compact_thm› = save_pop_thm "product_compact_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ V p∑ 
	‘ ç Topology
±	V Ä ‘
±	V ç Finite
±	p ç Space ‘
±	(µA∑ A ç V ¥ ∂B∑ B ç ‘ ± p ç B ± A ° B = {})
¥	∂B∑ B ç ‘ ± p ç B ± B ° ﬁV = {}Æ);
a(REPEAT strip_tac);
a(lemma_tac¨
	∂b∑µA∑A ç V ¥ b A ç ‘ ± p ç b A ± A ° b A = {}
Æ THEN1 prove_∂_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(cases_tac¨≥A' ç VÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 2 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(cases_tac¨ﬁV = {}Æ);
(* *** Goal "2.1" *** *)
a(∂_tac ¨Space ‘Æ THEN ALL_FC_T asm_rewrite_tac[space_open_thm]);
(* *** Goal "2.2" *** *)
a(lemma_tac ¨•{y|∂ x∑ x ç V ± y = b x} ç ‘Æ THEN1 bc_thm_tac finite_•_open_thm);
(* *** Goal "2.2.1" *** *)
a(asm_rewrite_tac[] THEN ALL_FC_T rewrite_tac[finite_image_thm]);
a(REPEAT strip_tac THEN PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
(* *** Goal "2.2.1.1" *** *)
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.1.2" *** *)
a(rewrite_tac[]);
a(cases_tac¨V = {}Æ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(POP_ASM_T (PC_T1 "sets_ext1" strip_asm_tac));
a(∂_tac¨b xÆ THEN ∂_tac¨xÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(∂_tac¨•{y|∂ x∑ x ç V ± y = b x}Æ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.2.2.1" *** *)
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(PC_T "sets_ext1" strip_tac THEN rewrite_tac[°_def, •_def, ﬁ_def]);
a(REPEAT strip_tac);
a(∂_tac¨b sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(∂_tac¨ sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.2" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
val €compact_closed_lemma› = pop_thm();
=TEX
We now look at sequential compactness. To show that compact spaces are sequentially compact
we use the following purely combinatorial lemma:
%%%%
%%%%

=SML
set_goal([], ¨µW s∑ 
	W ç Finite
±	(µm:Ó∑s m ç ﬁW)
¥	∂A∑A ç W ± µm∑∂n∑m º n ± s n ç A
Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨µV s∑ 
	V ç Finite
±	(µm:Ó∑s m ç ﬁV)
±	V Ä W
¥	∂A∑A ç W ± µm∑∂n∑m º n ± s n ç A
Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN POP_ASM_T ante_tac THEN POP_ASM_T ante_tac);
a(intro_µ_tac(¨s'Æ, ¨s'Æ));
a(finite_induction_tac¨VÆ THEN
	rewrite_tac[ﬁ_enum_set_clauses,
		pc_rule1"sets_ext1" prove_rule[]¨µu v∑ﬁ(u ¿ v) = ﬁu ¿ ﬁvÆ]);
a(REPEAT strip_tac);
a(cases_tac¨µ m∑ ∂ n∑ m º n ± s' n ç xÆ);
(* *** Goal "1.1" *** *)
a(∂_tac¨xÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 2 ante_tac THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(POP_ASM_T bc_thm_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 5 (ante_tac o µ_elim¨Ãn∑s'(m + n)Æ));
a(ALL_FC_T rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b c∑a ¿ b Ä c ¥ b Ä cÆ]);
a(LEMMA_T ¨µ m'∑ s' (m + m') ç ﬁ VÆ rewrite_thm_tac THEN1 µ_tac);
(* *** Goal "1.2.1" *** *)
a(bc_thm_tac (pc_rule1"sets_ext1" prove_rule[]¨µa b y∑≥y ç a ± y ç a ¿ b ¥ y ç bÆ));
a(∂_tac¨xÆ THEN asm_rewrite_tac[]);
a(spec_nth_asm_tac 1 ¨m + m'Æ);
(* *** Goal "1.2.2" *** *)
a(REPEAT strip_tac THEN ∂_tac¨AÆ THEN REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨m'Æ);
a(∂_tac¨m + nÆ THEN asm_rewrite_tac[]);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 1 (ante_tac o µ_elim¨WÆ) THEN rewrite_tac[] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(∂_tac¨AÆ THEN asm_rewrite_tac[]);
val €compact_sequentially_compact_lemma› = save_pop_thm "compact_sequentially_compact_lemma";
=TEX
We can now show that compact spaces are sequentially compact. This is useful
prove the existence of Lebesgue numbers for coverings of compact subspaces
of the real line or the plane.

%%%%
%%%%

=SML
set_goal([], ¨µ‘ X s∑ 
	‘ ç Topology
±	X ç ‘ Compact
±	(µm:Ó∑s m ç X)
¥	∂x∑x ç X ± (µA∑A ç ‘ ± x ç A ¥ µm∑∂n∑m º n ± s n ç A)
Æ);
a(rewrite_tac[compact_def] THEN contr_tac);
a(lemma_tac¨X Ä ﬁ{A | A ç ‘ ± ∂x∑x ç A ± x ç X ± ∂m∑µn∑m º n ¥ ≥s n ç A}Æ);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(spec_nth_asm_tac 2 ¨xÆ);
a(∂_tac¨AÆ THEN asm_rewrite_tac[]);
a(∂_tac¨xÆ THEN asm_rewrite_tac[]);
a(∂_tac¨mÆ THEN REPEAT strip_tac);
a(spec_nth_asm_tac 2 ¨nÆ);
(* *** Goal "2" *** *)
a(lemma_tac¨{A | A ç ‘ ± ∂x∑x ç A ± x ç X ± ∂m∑µn∑m º n ¥ ≥s n ç A} Ä ‘Æ
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(LIST_DROP_NTH_ASM_T [5] all_fc_tac);
a(lemma_tac¨µm∑s m ç ﬁWÆ THEN1
	all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b∑a Ä b ± (µ m∑ s m ç a) ¥ (µ m∑ s m ç b)Æ]);
a(all_fc_tac[compact_sequentially_compact_lemma]);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µy a b∑y ç a ± a Ä b ¥ y ç bÆ]);
a(spec_nth_asm_tac 5 ¨mÆ);
a(LIST_DROP_NTH_ASM_T [3] all_asm_fc_tac);
val €compact_sequentially_compact_thm› = save_pop_thm "compact_sequentially_compact_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ C∑ 
	‘ ç Topology
±	‘ ç Hausdorff
±	C ç ‘ Compact
¥	C ç ‘ ClosedÆ);
a(REPEAT strip_tac);
a(ALL_FC_T1 fc_§_canon  rewrite_tac[closed_open_neighbourhood_thm]);
a(once_rewrite_tac[prove_rule[]¨µp1 p2∑ p1 ± p2 § p1 ± (p1 ¥ p2)Æ]);
a(REPEAT strip_tac THEN1
	(POP_ASM_T ante_tac THEN prove_tac[compact_def]));
a(lemma_tac¨C Ä ﬁ {A | A ç ‘ ± ∂B∑B ç ‘ ± x ç B ± A ° B = {}}Æ);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[hausdorff_def]));
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(lemma_tac¨x' ç Space ‘Æ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(lemma_tac¨≥x' = xÆ THEN1 (contr_tac THEN all_var_elim_asm_tac1));
a(all_asm_fc_tac[]);
a(∂_tac¨AÆ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[compact_def]));
a(lemma_tac¨{A | A ç ‘ ± ∂B∑B ç ‘ ± x ç B ± A ° B = {}} Ä ‘Æ
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(all_asm_fc_tac[]);
a(lemma_tac¨W Ä ‘Æ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(lemma_tac¨µ A∑ A ç W ¥ (∂ B∑ B ç ‘ ± x ç B ± A ° B = {})Æ);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
a(∂_tac¨BÆ THEN PC_T1 "sets_ext1" asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(all_fc_tac[compact_closed_lemma]);
a(∂_tac¨BÆ THEN  asm_rewrite_tac[]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[] ¨µX∑ C Ä X ± B ° X = {} ¥ B ° C = {}Æ]);
val €compact_closed_thm› = save_pop_thm "compact_closed_thm";
=TEX
\subsection{Connectedness}
%%%%
%%%%

=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
¥	(X ç ‘ Connected § X ç (X ÚâT ‘) Connected)Æ);
a(rewrite_tac[connected_def] THEN PC_T1 "sets_ext1" REPEAT µ_tac THEN ¥_tac);
a(ALL_FC_T1 fc_§_canon rewrite_tac[subspace_topology_space_thm]);
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b∑a Ä a ° b § a Ä bÆ]);
a(rewrite_tac[subspace_topology_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1);
a(lemma_tac¨X Ä B'  ¿ B''Æ THEN1
	(GET_NTH_ASM_T 3 ante_tac THEN  PC_T1 "sets_ext" prove_tac[]));
a(DROP_NTH_ASM_T 3 ante_tac THEN
	rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b c∑a ° (b ° a) ° c ° a = a ° b ° cÆ]);
a(REPEAT strip_tac);
a(lemma_tac¨≥X Ä B' Æ THEN1
	(GET_NTH_ASM_T 3 ante_tac THEN  PC_T1 "sets_ext" prove_tac[]));
a(all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(list_spec_nth_asm_tac 6 [¨B ° XÆ, ¨C ° XÆ]);
(* *** Goal "2.1" *** *)
a(list_spec_nth_asm_tac 1 [¨BÆ]);
(* *** Goal "2.2" *** *)
a(list_spec_nth_asm_tac 1 [¨CÆ]);
(* *** Goal "2.3" *** *)
a(i_contr_tac THEN LIST_DROP_NTH_ASM_T [1, 4] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.4" *** *)
a(i_contr_tac THEN LIST_DROP_NTH_ASM_T [1, 3] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.5" *** *)
a(i_contr_tac THEN LIST_DROP_NTH_ASM_T [1, 2] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.6" *** *)
a(LIST_DROP_NTH_ASM_T [1] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext1" prove_tac[]);
val €connected_topological_thm› = save_pop_thm "connected_topological_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
¥	(	X ç ‘ Connected
	 § 	µx y∑ x ç X ± y ç X ¥ ∂Y∑ Y Ä X ± x ç Y ± y ç Y ± Y ç ‘ Connected)Æ);
a(REPEAT strip_tac THEN1 (∂_tac¨XÆ THEN PC_T1 "sets_ext1" asm_prove_tac[]));
a(POP_ASM_T ante_tac THEN rewrite_tac[connected_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN all_asm_fc_tac[]);
a(LIST_GET_NTH_ASM_T [2, 3, 4] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN PC_T "sets_ext1" contr_tac);
a(list_spec_nth_asm_tac 9 [¨xÆ, ¨x'Æ]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä b ± b Ä c ¥ a Ä cÆ]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä b ± b ° c = {} ¥ a ° c = {}Æ]);
a(list_spec_nth_asm_tac 3 [¨BÆ, ¨CÆ]);
(* *** Goal "2.1" *** *)
a(LIST_GET_NTH_ASM_T [1, 7, 11] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2.2" *** *)
a(LIST_GET_NTH_ASM_T [1, 6, 9] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext" prove_tac[]);
val €connected_pointwise_thm› = save_pop_thm "connected_pointwise_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
± 	(µx y∑ x ç X ± y ç X ¥ ∂Y∑ Y Ä X ± x ç Y ± y ç Y ± Y ç ‘ Connected)
¥	X ç ‘ ConnectedÆ);
a(REPEAT strip_tac THEN ALL_FC_T1 fc_§_canon once_rewrite_tac[connected_pointwise_thm]);
a(POP_ASM_T ante_tac THEN taut_tac);
val €connected_pointwise_bc_thm› = save_pop_thm "connected_pointwise_bc_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘∑ ‘ ç Topology ¥ {} ç ‘ ConnectedÆ);
a(REPEAT strip_tac THEN bc_thm_tac connected_pointwise_bc_thm);
a(asm_rewrite_tac[]);
val €empty_connected_thm› = save_pop_thm "empty_connected_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ x∑ ‘ ç Topology ± x ç Space ‘ ¥ {x} ç ‘ ConnectedÆ);
a(REPEAT strip_tac THEN rewrite_tac[connected_def, enum_set_clauses]);
a(PC_T1 "sets_ext1" prove_tac[]);
val €singleton_connected_thm› = save_pop_thm "singleton_connected_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µC D ”∑ 
	C ç ” Connected
±	D ç ” Connected
±	≥C ° D = {}
±	” ç Topology
¥	C ¿ D ç ” Connected
Æ);
a(rewrite_tac[connected_def] THEN REPEAT strip_tac
	THEN1 all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä c ± b Ä c ¥ a ¿ b Ä cÆ]);
a(DROP_NTH_ASM_T 7 (PC_T1 "sets_ext1" strip_asm_tac) THEN contr_tac);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a ¿ b Ä c ¥ a Ä c ± b Ä cÆ]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑(a ¿ b) ° c = {} ¥ a ° c = {} ± b ° c = {}Æ]);
a(list_spec_nth_asm_tac 16 [¨BÆ, ¨C'Æ] THEN list_spec_nth_asm_tac 15 [¨BÆ, ¨C'Æ]);
(* *** Goal "1" *** *)
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä c ± b Ä c ¥ a ¿ b Ä cÆ]);
(* *** Goal "2" *** *)
a(ante_tac(pc_rule1 "sets_ext1" prove_rule[]
	¨x ç C ± x ç D  ± C Ä B ± D Ä C' ¥ x ç C ° B ° C'Æ));
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(ante_tac(pc_rule1 "sets_ext1" prove_rule[]
	¨x ç C ± x ç D  ± C Ä C' ± D Ä B ¥ x ç C ° B ° C'Æ));
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä c ± b Ä c ¥ a ¿ b Ä cÆ]);
val €¿_connected_thm› = save_pop_thm "¿_connected_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µf X ” ‘∑ 
	f ç (”, ‘) Continuous
±	X ç ” Connected
±	” ç Topology
±	‘ ç Topology
¥	{y | ∂x∑ x ç X ± y = f x} ç ‘ Connected
Æ);
a(rewrite_tac[connected_def, continuous_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac );
a(all_var_elim_asm_tac1 THEN PC_T1 "sets_ext1" all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(contr_tac);
a(LIST_DROP_NTH_ASM_T [11] all_fc_tac);
a(GET_NTH_ASM_T 12 (PC_T1 "sets_ext1" strip_asm_tac));
a(lemma_tac¨
	X Ä {x|x ç Space ” ± f x ç B} ¿ {x|x ç Space ” ± f x ç C}
Æ THEN1 (PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac
		THEN_TRY SOLVED_T (all_asm_fc_tac[])));
(* *** Goal "2.1" *** *)
a(swap_nth_asm_concl_tac 9 THEN PC_T "sets_ext1" strip_tac);
a(REPEAT strip_tac THEN ∂_tac¨f xÆ THEN REPEAT strip_tac);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(lemma_tac¨
	X ° {x|x ç Space ” ± f x ç B} ° {x|x ç Space ” ± f x ç C} = {}
Æ THEN1 (PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac));
(* *** Goal "2.2.1" *** *)
a(swap_nth_asm_concl_tac 11 THEN PC_T "sets_ext1" strip_tac);
a(REPEAT strip_tac THEN ∂_tac¨f xÆ);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(LEMMA_T ¨X Ä {x|x ç Space ” ± f x ç B} ≤ X Ä {x|x ç Space ” ± f x ç C}Æ ante_tac);
(* *** Goal "2.2.2.1" *** *)
a(DROP_NTH_ASM_T 14 bc_thm_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(swap_nth_asm_concl_tac 8);
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a(swap_nth_asm_concl_tac 7);
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
val €image_connected_thm› = save_pop_thm "image_connected_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µX : 'a SET; Y : 'b SET; ” ‘ ∑ 
	X ç ” Connected
±	Y ç ‘ Connected
±	” ç Topology
±	‘ ç Topology
¥	(X ∏ Y) ç (” ∏âT ‘) ConnectedÆ);
a(REPEAT strip_tac);
a(lemma_tac ¨(” ∏âT ‘) ç TopologyÆ THEN1 all_fc_tac[product_topology_thm]);
a(ALL_FC_T1 fc_§_canon once_rewrite_tac[connected_pointwise_thm]);
a(REPEAT strip_tac);
a(lemma_tac¨
	(∂H∑ H ç (” ∏âT ‘) Connected ± x ç H ± (Fst y, Snd x) ç H ± H Ä (X ∏ Y))
±	(∂V∑ V ç (” ∏âT ‘) Connected ± y ç V ± (Fst y, Snd x) ç V ± V Ä (X ∏ Y))Æ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨{ab | ∂a∑ a ç X ± ab = (Ãa∑(a, Snd x)) a}Æ THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(bc_thm_tac image_connected_thm);
a(∂_tac¨”Æ THEN REPEAT strip_tac);
a(bc_thm_tac left_product_inj_continuous_thm THEN REPEAT strip_tac);
a(POP_ASM_T discard_tac THEN POP_ASM_T (ante_tac o rewrite_rule[∏_def]));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o rewrite_rule[connected_def]));
a(POP_ASM_T discard_tac THEN POP_ASM_T ante_tac 
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.2" *** *)
a(∂_tac ¨Fst xÆ THEN rewrite_tac[]);
a(POP_ASM_T discard_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[∏_def]));
(* *** Goal "1.3" *** *)
a(∂_tac ¨Fst yÆ THEN rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[∏_def]));
(* *** Goal "1.4" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN rewrite_tac[∏_def] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o rewrite_rule[∏_def]) THEN taut_tac);
(* *** Goal "2" *** *)
a(∂_tac¨{ab | ∂b∑ b ç Y ± ab = (Ãb∑(Fst y, b)) b}Æ THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac image_connected_thm);
a(∂_tac¨‘Æ THEN REPEAT strip_tac);
a(bc_thm_tac right_product_inj_continuous_thm THEN REPEAT strip_tac);
a(POP_ASM_T (ante_tac o rewrite_rule[∏_def]));
a(DROP_NTH_ASM_T 6 (strip_asm_tac o rewrite_rule[connected_def]));
a(POP_ASM_T discard_tac THEN POP_ASM_T ante_tac 
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.2" *** *)
a(∂_tac ¨Snd yÆ THEN rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[∏_def]));
(* *** Goal "2.3" *** *)
a(∂_tac ¨Snd xÆ THEN rewrite_tac[]);
a(POP_ASM_T discard_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[∏_def]));
(* *** Goal "2.4" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN rewrite_tac[∏_def] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[∏_def]) THEN taut_tac);
(* *** Goal "3" *** *)
a(lemma_tac ¨H ¿ V Ä (X ∏ Y)Æ THEN1
	all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä c ± b Ä c ¥ a ¿ b Ä cÆ]);
a(∂_tac¨H ¿ VÆ THEN REPEAT strip_tac);
a(bc_thm_tac ¿_connected_thm);
a(REPEAT strip_tac THEN PC_T "sets_ext1" contr_tac THEN all_asm_fc_tac[]);
val €product_connected_thm› = save_pop_thm "product_connected_thm";
=TEX
\subsection{Homeomorphisms}
%%%%
%%%%
The identity function is a homeomorphism.
=SML
set_goal([], ¨µ‘∑ 
	‘ ç Topology
¥	(Ãx∑ x) ç (‘, ‘) HomeomorphismÆ);
a(rewrite_tac [homeomorphism_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[id_continuous_thm]);
(* *** Goal "2" *** *)
a(∂_tac¨Ãy∑ yÆ);
a(ALL_FC_T rewrite_tac[id_continuous_thm]);
val €id_homomorphism_thm› = save_pop_thm "id_homeomorphism_thm";
=TEX
%%%%
%%%%
The composite of two homeomorphisms is a homeomorphism:
=SML
set_goal([], ¨µf g “ ” ‘∑ 
	f ç (“, ”) Homeomorphism
±	g ç (”, ‘) Homeomorphism
±	“ ç Topology
±	” ç Topology
±	‘ ç Topology
¥	(Ãx∑ g(f x)) ç (“, ‘) Homeomorphism
Æ);
a(rewrite_tac [homeomorphism_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac [comp_continuous_thm]);
(* *** Goal "2" *** *)
a(∂_tac¨Ãy∑ g'(g'' y)Æ);
a(ALL_FC_T rewrite_tac [arb_gen comp_continuous_thm]);
a(all_asm_ante_tac THEN rewrite_tac[continuous_def] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(all_asm_fc_tac[] THEN ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(all_asm_fc_tac[] THEN ALL_ASM_FC_T rewrite_tac[]);
val €comp_homeomorphism_thm› = save_pop_thm "comp_homeomorphism_thm";
=TEX
%%%%
%%%%
The cartesian product of two homeomoprhisms is a homeomorphism:
=SML
set_goal([], ¨µ f : 'a ≠ 'b; g : 'c ≠ 'd; “ : 'a SET SET; ” : 'b SET SET; ‘ : 'c SET SET; ’ : 'd SET SET∑ 
	f ç (“, ”) Homeomorphism
±	g ç (‘, ’) Homeomorphism
±	“ ç Topology
±	” ç Topology
±	‘ ç Topology
±	’ ç Topology
¥	(Ã(x, y)∑(f x, g y)) ç ((“ ∏âT ‘), (” ∏âT ’)) Homeomorphism
Æ);
a(rewrite_tac [homeomorphism_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T ¨
	(Ã (x, y)∑ (f x, g y)) = (Ãz∑( (Ãz∑f((Ã(x, y)∑ x) z)) z, (Ãz∑g((Ã(x, y)∑ y) z)) z))Æ
	pure_rewrite_thm_tac THEN1 rewrite_tac[]);
a(bc_thm_tac (arb_gen product_continuous_thm));
a(ALL_FC_T pure_asm_rewrite_tac[arb_gen product_topology_thm]);
a(REPEAT strip_tac THEN bc_thm_tac (arb_gen comp_continuous_thm));
(* *** Goal "1.1" *** *)
a(∂_tac¨“Æ THEN REPEAT strip_tac
	THEN ALL_FC_T rewrite_tac(map arb_gen [left_proj_continuous_thm, right_proj_continuous_thm,
		product_topology_thm]));
(* *** Goal "1.2" *** *)
a(∂_tac¨‘Æ THEN REPEAT strip_tac
	THEN ALL_FC_T rewrite_tac (map arb_gen [left_proj_continuous_thm, right_proj_continuous_thm,
		product_topology_thm]));
(* *** Goal "2" *** *)
a(∂_tac¨Ã(x, y)∑ (g' x, g'' y)Æ);
a(ALL_FC_T pure_rewrite_tac[arb_gen product_topology_space_thm] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(LEMMA_T ¨
	(Ã (x, y)∑ (g' x, g'' y)) = (Ãz∑( (Ãz∑g'((Ã(x, y)∑ x) z)) z, (Ãz∑g''((Ã(x, y)∑ y) z)) z))Æ
	pure_rewrite_thm_tac THEN1 rewrite_tac[]);
a(bc_thm_tac (arb_gen product_continuous_thm));
a(ALL_FC_T pure_asm_rewrite_tac[arb_gen product_topology_thm]);
a(REPEAT strip_tac THEN bc_thm_tac (arb_gen comp_continuous_thm));
(* *** Goal "2.1.1" *** *)
a(∂_tac¨”Æ THEN REPEAT strip_tac
	THEN ALL_FC_T rewrite_tac (map arb_gen [left_proj_continuous_thm, right_proj_continuous_thm,
		product_topology_thm]));
(* *** Goal "2.1.2" *** *)
a(∂_tac¨’Æ THEN REPEAT strip_tac
	THEN ALL_FC_T rewrite_tac(map arb_gen [left_proj_continuous_thm, right_proj_continuous_thm,
		product_topology_thm]));
(* *** Goal "2.2" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[∏_def]);
a(REPEAT strip_tac THEN ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "2.3" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[∏_def]);
a(REPEAT strip_tac THEN ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "2.4" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[∏_def]);
a(REPEAT strip_tac THEN ALL_ASM_FC_T rewrite_tac[]);
val €product_homeomorphism_thm› = save_pop_thm "product_homeomorphism_thm";
=TEX
%%%%
%%%%
A homeomorphism is an open mapping (i.e., it maps open sets to open sets):
=SML
set_goal([], ¨µf ” ‘ A∑ 
	f ç (”, ‘) Homeomorphism
±	A ç ”
±	” ç Topology
±	‘ ç Topology
¥	{y | ∂x∑ x ç A ± y = f x} ç ‘
Æ);
a(rewrite_tac [homeomorphism_def, continuous_def] THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [6] all_fc_tac);
a(LEMMA_T ¨ {y|∂ x∑ x ç A ± y = f x} = {x|x ç Space ‘ ± g x ç A}Æ asm_rewrite_thm_tac);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1);
a(GET_NTH_ASM_T 11 bc_thm_tac);
a(ALL_FC_T rewrite_tac[arb_gen ç_space_thm]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(all_fc_tac[arb_gen ç_space_thm]);
a(ALL_ASM_FC_T asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨g xÆ THEN REPEAT strip_tac);
a(ALL_ASM_FC_T asm_rewrite_tac[]);
val €homeomorphism_open_mapping_thm› = save_pop_thm "homeomorphism_open_mapping_thm";
=TEX
%%%%
%%%%
A homeomorphism is one-to-one on the space of its domain:
=SML
set_goal([], ¨µf ” ‘∑ 
	f ç (”, ‘) Homeomorphism
±	” ç Topology
±	‘ ç Topology
¥	µx y∑ x ç Space ” ± y ç Space ” ± f x = f y ¥ x = y
Æ);
a(rewrite_tac [homeomorphism_def] THEN REPEAT strip_tac);
a(LEMMA_T ¨g(f x) = g(f y)Æ ante_tac THEN1 asm_rewrite_tac[]);
a(ALL_ASM_FC_T rewrite_tac[]);
val €homeomorphism_one_one_thm› = save_pop_thm "homeomorphism_one_one_thm";
=TEX
%%%%
%%%%
A homeomorphism is onto on the space of its range:
=SML
set_goal([], ¨µf ” ‘ y∑ 
	f ç (”, ‘) Homeomorphism
±	” ç Topology
±	‘ ç Topology
±	y ç Space ‘
¥	∂x∑x ç Space ” ± y = f x
Æ);
a(rewrite_tac [homeomorphism_def, continuous_def] THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T[7] all_fc_tac);
a(∂_tac¨g yÆ THEN REPEAT strip_tac);
a(ALL_ASM_FC_T rewrite_tac[]);
val €homeomorphism_onto_thm› = save_pop_thm "homeomorphism_onto_thm";
=TEX
%%%%
%%%%
A function is homomorphism iff. it is one-to-one (on the space of its domain), onto (the space of tis range),
continuous and open:
=SML
set_goal([], ¨µf ” ‘∑
	” ç Topology
±	‘ ç Topology
¥	(	f ç (”, ‘) Homeomorphism
	§	(µx y∑ x ç Space ” ± y ç Space ” ± f x = f y ¥ x = y)
	±	(µy∑ y ç Space ‘ ¥ ∂x∑x ç Space ” ± y = f x)
	±	f ç (”, ‘) Continuous
	±	(µA∑A ç ” ¥ {y | ∂x∑ x ç A ± y = f x} ç ‘))
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[homeomorphism_one_one_thm]);
(* *** Goal "2" *** *)
a(bc_thm_tac homeomorphism_onto_thm);
a(∂_tac¨‘Æ THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac [homeomorphism_def] THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(all_fc_tac[homeomorphism_open_mapping_thm]);
(* *** Goal "5" *** *)
a(rewrite_tac[homeomorphism_def] THEN REPEAT strip_tac);
a(lemma_tac¨∂g∑µy∑y ç Space ‘ ¥ g y ç Space ” ± y = f(g y)Æ THEN1 prove_∂_tac);
(* *** Goal "5.1" *** *)
a(REPEAT strip_tac THEN cases_tac ¨y' ç Space ‘Æ THEN asm_rewrite_tac[]);
a(GET_NTH_ASM_T 4 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "5.2" *** *)
a(∂_tac¨gÆ THEN rewrite_tac[continuous_def] THEN REPEAT strip_tac);
(* *** Goal "5.2.1" *** *)
a(ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "5.2.2" *** *)
a(LIST_GET_NTH_ASM_T [3] all_fc_tac);
a(LEMMA_T¨{x|x ç Space ‘ ± g x ç A} = {y|∂ x∑ x ç A ± y = f x}Æ asm_rewrite_thm_tac);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "5.2.2.1" *** *)
a(∂_tac¨g xÆ THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "5.2.2.2" *** *)
a(all_var_elim_asm_tac1);
a(all_fc_tac[arb_gen ç_space_thm]);
a(GET_NTH_ASM_T 7 ante_tac THEN rewrite_tac[continuous_def] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "5.2.2.3" *** *)
a(all_var_elim_asm_tac1);
a(all_fc_tac[arb_gen ç_space_thm]);
a(LEMMA_T¨g(f x') = x'Æ asm_rewrite_thm_tac);
a(GET_NTH_ASM_T 7 ante_tac THEN rewrite_tac[continuous_def] THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [2] all_fc_tac);
a(LIST_DROP_NTH_ASM_T [7] all_fc_tac);
a(LIST_DROP_NTH_ASM_T [12] all_fc_tac);
a(conv_tac eq_sym_conv THEN REPEAT strip_tac);
(* *** Goal "5.2.3" *** *)
a(GET_NTH_ASM_T 4 ante_tac THEN rewrite_tac[continuous_def] THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [2] all_fc_tac);
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
a(LIST_DROP_NTH_ASM_T [9] all_fc_tac);
a(conv_tac eq_sym_conv THEN REPEAT strip_tac);
(* *** Goal "5.2.4" *** *)
a(LIST_DROP_NTH_ASM_T [5] all_fc_tac);
a(all_var_elim_asm_tac1);
a(LEMMA_T¨g(f x) = xÆ asm_rewrite_thm_tac);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac);
a(LIST_DROP_NTH_ASM_T [7] all_fc_tac);
a(conv_tac eq_sym_conv THEN REPEAT strip_tac);

val €homeomorphism_one_one_open_mapping_thm› = save_pop_thm "homeomorphism_one_one_open_mapping_thm";
=TEX
\section{METRIC SPACES --- THEOREMS}
=SML
open_theory"metric_spaces";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙", "'Ø"];
=TEX
\subsection{The Definitions}
=SML
val €metric_def› = get_spec¨MetricÆ;
val €metric_topology_def› = get_spec¨MetricTopologyÆ;
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µD∑D ç Metric ¥ MetricTopology D ç TopologyÆ);
a(rewrite_tac[topology_def, metric_def, metric_topology_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µx b c∑x ç b ± b Ä c ¥ x ç  cÆ]);
a(LIST_DROP_NTH_ASM_T [1] all_fc_tac);
a(∂_tac¨eÆ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN ALL_ASM_FC_T asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T [3, 4] all_fc_tac);
a(cases_tac¨e º e'Æ);
(* *** Goal "2.1" *** *)
a(∂_tac¨eÆ THEN PC_T1 "predicates" REPEAT strip_tac);
a(lemma_tac¨D(x, y) < e'Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [4, 6] all_fc_tac THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(∂_tac¨e'Æ THEN PC_T1 "predicates" REPEAT strip_tac);
a(lemma_tac¨D(x, y) < eÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [4, 6] all_fc_tac THEN REPEAT strip_tac);
val €metric_topology_thm› = save_pop_thm "metric_topology_thm";
=TEX
%%%%
%%%%


=SML
set_goal([], ¨µD e x∑ÓØ 0 <  e ± D ç Metric ¥ {y | D (x, y) < e} ç MetricTopology DÆ);
a(rewrite_tac[metric_topology_def, metric_def] THEN REPEAT strip_tac);
a(∂_tac¨e - D(x, x')Æ THEN REPEAT strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨D(x, y) º D(x, x') + D(x', y)Æ THEN1 asm_rewrite_tac[]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €open_ball_open_thm› = save_pop_thm"open_ball_open_thm";
=TEX
%%%%
%%%%


=SML
set_goal([], ¨µD e x∑ÓØ 0 <  e ± D ç Metric ¥ x ç {y | D(x, y) < e}Æ);
a(rewrite_tac[metric_def] THEN REPEAT strip_tac);
a(lemma_tac¨D(x, x) = ÓØ 0Æ THEN asm_rewrite_tac[]);
val €open_ball_neighbourhood_thm› = save_pop_thm "open_ball_neighbourhood_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µD X U∑
	D ç Metric
±	X ç (MetricTopology D) Compact
±	U Ä MetricTopology D
±	X Ä ﬁU
¥	∂e∑ ÓØ 0 < e
±	µx∑ x ç X ¥ ∂A∑ x ç  A ± A ç U ± µy∑ D(x, y) < e ¥ y ç A
Æ);
a(contr_tac);
a(all_fc_tac [metric_topology_thm]);
a(lemma_tac¨∂s∑(µm:Ó∑ s m ç X) ± (µA; m:Ó∑A ç U ¥ ∂y∑ D(s m, y) < ÓØ (m + 1) õ-õ1 ± ≥y ç A)Æ
	THEN1 (prove_∂_tac THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a(lemma_tac¨ÓØ 0 < ÓØ (m' + 1)õ-õ1Æ THEN1 
	(bc_thm_tac  Ø_0_less_0_less_recip_thm THEN
		rewrite_tac [ÓØ_less_thm] THEN PC_T1 "lin_arith" prove_tac[]));
a(spec_nth_asm_tac 3 ¨ÓØ (m' + 1)õ-õ1Æ);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
a(spec_nth_asm_tac 2 ¨AÆ);
(* *** Goal "1.1" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac);
a(LEMMA_T ¨D(x, x) = ÓØ 0Æ asm_rewrite_thm_tac);
a(DROP_NTH_ASM_T 11 (rewrite_thm_tac o rewrite_rule[metric_def]));
(* *** Goal "1.2" *** *)
a(∂_tac¨yÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(all_fc_tac[compact_sequentially_compact_thm]);
a(DROP_NTH_ASM_T 7 (PC_T1 "sets_ext1" strip_asm_tac));
a(LIST_DROP_NTH_ASM_T [1] all_fc_tac);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa∑s' ç U ± U Ä a ¥ s' ç aÆ]);
a(spec_nth_asm_tac 4 ¨s'Æ);
a(GET_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[metric_topology_def]));
a(LIST_DROP_NTH_ASM_T [1] all_fc_tac);
a(lemma_tac¨ÓØ 0  < (1/2)*e Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 3 discard_tac);
a(lemma_tac¨{y | D(x, y) < (1/2)*e} ç MetricTopology DÆ
	THEN1 (bc_thm_tac open_ball_open_thm THEN REPEAT strip_tac));
a(LEMMA_T¨x ç {y | D(x, y) < (1/2)*e}Æ asm_tac
	THEN1 (bc_thm_tac open_ball_neighbourhood_thm THEN REPEAT strip_tac));
a(PC_T1 "predicates" (spec_nth_asm_tac 9) ¨{y | D(x, y) < (1/2)*e}Æ);
a(all_fc_tac[Ø_archimedean_recip_thm]);
a(spec_nth_asm_tac 2 ¨m+1Æ);
a(lemma_tac¨ÓØ 0 < ÓØ(m+1) ± ÓØ 0 < ÓØ(n+1) ± ÓØ(m+1) < ÓØ(n+1)Æ
	THEN1 (rewrite_tac [ÓØ_less_thm] THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(lemma_tac¨ÓØ(n+1)õ-õ1  < ÓØ(m+1)õ-õ1Æ
	THEN1 (bc_thm_tac Ø_less_recip_less_thm THEN REPEAT strip_tac));
a(lemma_tac¨ÓØ 0 < ÓØ(m+1)õ-õ1 ± ÓØ 0 < ÓØ(n+1)õ-õ1Æ
	THEN1 (ALL_FC_T rewrite_tac [Ø_0_less_0_less_recip_thm]));
a(list_spec_nth_asm_tac 21 [¨s'Æ, ¨nÆ]);
a(swap_nth_asm_concl_tac 1 THEN DROP_NTH_ASM_T 15 bc_thm_tac);
a(lemma_tac¨D(x, y) º D(x, s n) + D(s n, y)Æ
	THEN1 DROP_NTH_ASM_T 27 (rewrite_thm_tac o rewrite_rule[metric_def]));
a(lemma_tac¨D(s n, y) < (1/2)*eÆ
	THEN1 REPEAT (all_fc_tac[Ø_less_trans_thm]));
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €lebesgue_number_thm› = save_pop_thm "lebesgue_number_thm";
=TEX
%%%%
%%%%

=TEX
\section{THE REAL LINE AND THE PLANE --- THEOREMS}
=SML
open_theory"topology_Ø";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙", "'Ø"];
=TEX
\subsection{The Definitions}
=SML
val €d_Ø_def› = get_spec¨DâRÆ;
val €d_Ø_2_def› = get_spec¨DâR2Æ;
set_goal([], ¨µxy1 xy2∑ DâR2 (xy1, xy2) = Abs(Fst xy2 - Fst xy1)  + Abs(Snd xy2 - Snd  xy1)Æ);
a(REPEAT strip_tac);
a(pure_once_rewrite_tac[prove_rule[]¨µp:Ø ∏ Ø∑p = (Fst p, Snd p)Æ]);
a(pure_rewrite_tac[d_Ø_2_def]);
a(rewrite_tac[]);
val €d_Ø_2_def1› = save_pop_thm "d_Ø_2_def1";
=TEX
%%%%
%%%%

We show that the open sets as defined in [Analysis]  do indeed comprise a topology on
the real line with the expected basic properties. The proofs are very easy, because
most of the work has already been done in [Analysis].
First, the open sets do form a topology:
%%%%
%%%%

=SML
set_goal([], ¨OpenâR ç TopologyÆ);
a(rewrite_tac[topology_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[ﬁ_open_Ø_thm]);
(* *** Goal "2" *** *)
a(all_fc_tac[°_open_Ø_thm]);
val €open_Ø_topology_thm› = save_pop_thm "open_Ø_topology_thm";
=TEX
The underlying set of the topology is the entire real line:
%%%%
%%%%

=SML
set_goal([], ¨Space OpenâR = UniverseÆ);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(bc_thm_tac ç_space_thm);
a(∂_tac¨UniverseÆ THEN rewrite_tac[open_Ø_topology_thm, empty_universe_open_closed_thm]);
val €space_Ø_thm› = save_pop_thm "space_Ø_thm";
=TEX
The definition from [Analysis] of a closed set agrees with the abstract one:
%%%%
%%%%

=SML
set_goal([], ¨OpenâR Closed = ClosedâRÆ);
a(rewrite_tac[closed_def, closed_Ø_def, space_Ø_thm] THEN REPEAT strip_tac);
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[pc_rule1"sets_ext1" prove_rule[complement_clauses]¨µa:'a SET∑~(~a) = aÆ]);
(* *** Goal "2" *** *)
a(∂_tac¨~xÆ THEN
	asm_rewrite_tac[pc_rule1"sets_ext1" prove_rule[complement_clauses]¨µa:'a SET∑~(~a) = aÆ]);
val €closed_closed_Ø_thm› = save_pop_thm "closed_closed_Ø_thm";
=TEX
The definition from [Analysis] of a connected set agrees with the abstract one:
%%%%
%%%%

=SML
set_goal([], ¨OpenâR Compact = CompactâRÆ);
a(rewrite_tac[compact_def, compact_Ø_def, space_Ø_thm] THEN REPEAT strip_tac);
val €compact_compact_Ø_thm› = save_pop_thm "compact_compact_Ø_thm";
=TEX
Finally (amongst the basic properties), functions are continuous in the abstract sense
iff. they are everywhere continuous in the sense of [Analysis].
%%%%
%%%%

=SML
set_goal([], ¨µf∑ f ç (OpenâR, OpenâR) Continuous § µx∑f Cts xÆ);
a(rewrite_tac[continuous_def, cts_open_Ø_thm, space_Ø_thm] THEN REPEAT strip_tac);
val €continuous_cts_at_Ø_thm› = save_pop_thm "continuous_cts_at_Ø_thm";
=TEX
With a distant view to doing some algebraic topology, we now look at connectedness,
which was not much studied in [Analysis]. Our intention is to characterise the connected
subsets of the real line. The plan is to use material from this document and from [Analysis]
as appropriate to best effect. We show that the real line as a whole is connected using
the intermediate value theorem, from which we infer that closed intervals are connected
using a continous mapping of the real line onto a closed interval. From this we infer that
a subset of the real line is connected iff. it contains the closed interval lying between
any two of its points, using the pointwise characterisation of connectedness and the
fact that closed intervals are connected.

That the real line is topologically connected is a consequence of the intermediate
value theorem: if the disjoint open sets $B$ and $C$ exhausted the real line,
then the function which is 0 on $B$ and 1 on $C$ would be continuous but
would not take on any real value (e.g., $1/2$) strictly between 0 and 1, contradicting
the intermediate value theorem. (That the real line is connected is proved in [Analysis], but
the proof is not as nice as this one.)
%%%%
%%%%

=SML
set_goal([], ¨Universe ç OpenâR ConnectedÆ);
a(rewrite_tac[connected_def, space_Ø_thm] THEN PC_T1 "sets_ext1" rewrite_tac[]);
a(strip_asm_tac open_Ø_topology_thm THEN contr_tac);
a(lemma_tac¨∂f∑µt∑ f t = if t ç B then ÓØ 0 else ÓØ 1Æ THEN1 prove_∂_tac);
a(lemma_tac¨µt∑f Cts tÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[cts_open_Ø_thm] THEN REPEAT strip_tac);
a(cases_tac¨ÓØ 0 ç AÆ THEN cases_tac¨ÓØ 1 ç AÆ);
(* *** Goal "1.1" *** *)
a(LEMMA_T ¨{x | f x ç A} = Space OpenâRÆ rewrite_thm_tac THEN_LIST
	[rewrite_tac[space_Ø_thm], ALL_FC_T rewrite_tac[space_open_thm]]);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN asm_rewrite_tac[]);
a(cases_tac ¨x'' ç BÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(LEMMA_T ¨{x | f x ç A} = BÆ  asm_rewrite_thm_tac);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "1.3" *** *)
a(LEMMA_T ¨{z | f z ç A} = CÆ  asm_rewrite_thm_tac);
a(LEMMA_T¨µt∑t ç B § ≥t ç CÆ asm_rewrite_thm_tac THEN1 asm_prove_tac[]);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "1.4" *** *)
a(LEMMA_T ¨{x | f x ç A} = {}Æ rewrite_thm_tac THEN_LIST
	[PC_T "sets_ext1" contr_tac, ALL_FC_T rewrite_tac[empty_open_thm]]);
a(POP_ASM_T ante_tac THEN spec_nth_asm_tac 8 ¨x''Æ THEN asm_rewrite_tac[]);
a(LEMMA_T¨µt∑t ç B § ≥t ç CÆ asm_rewrite_thm_tac THEN1 asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨µt∑≥f t = 1/2Æ THEN1 (strip_tac THEN cases_tac¨t ç BÆ THEN asm_rewrite_tac[]));
a(lemma_tac¨f x = ÓØ 1Æ THEN1 asm_rewrite_tac[]);
a(lemma_tac¨f x' = ÓØ 0Æ THEN1
	(cases_tac ¨x' ç BÆ THEN asm_rewrite_tac[] THEN asm_prove_tac[]));
a(DROP_NTH_ASM_T 5 discard_tac);
a(lemma_tac¨≥x = x'Æ THEN1  (contr_tac THEN all_var_elim_asm_tac THEN asm_prove_tac[]));
a(strip_asm_tac (list_µ_elim[¨xÆ, ¨x'Æ] Ø_less_cases_thm));
(* *** Goal "2.1" *** *)
a(ante_tac(list_µ_elim[¨fÆ, ¨xÆ, ¨x'Æ] intermediate_value_thm)
	THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨1/2Æ  THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(ante_tac(list_µ_elim[¨fÆ, ¨x'Æ, ¨xÆ] intermediate_value_thm)
	THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨1/2Æ  THEN asm_rewrite_tac[]);
val €universe_Ø_connected_thm› = save_pop_thm "universe_Ø_connected_thm";
=TEX
We can now apply the theorem that continuous images of connected sets are connected
to show that closed intervals are connected, using a useful theorem from [Analysis]
to construct a continuous mapping of the real line onto any given closed interval.
%%%%
%%%%

=SML
set_goal([], ¨µx y∑ x < y ¥ ClosedInterval x y ç OpenâR ConnectedÆ);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨xÆ, ¨yÆ,  ¨Ãt:Ø∑tÆ] cts_extension_thm1));
a(asm_rewrite_tac[id_cts_thm,
	conv_rule(ONCE_MAP_C eq_sym_conv) continuous_cts_at_Ø_thm] THEN strip_tac);
a(strip_asm_tac universe_Ø_connected_thm THEN strip_asm_tac open_Ø_topology_thm);
a(all_fc_tac[image_connected_thm]);
a(POP_ASM_T ante_tac THEN rewrite_tac[]);
a(bc_thm_tac(prove_rule[]¨µx y a∑x = y ¥ x ç a ¥ y ç aÆ));
a(rewrite_tac[closed_interval_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1);
a(cases_tac¨x'' < xÆ THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(cases_tac¨y < x''Æ THEN1 
	(ALL_ASM_FC_T rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨x º x'' ± x'' º yÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_ASM_FC_T asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(cases_tac¨y < x''Æ THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(cases_tac¨x'' < xÆ THEN1 
	(ALL_ASM_FC_T rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨x º x'' ± x'' º yÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_ASM_FC_T asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨x'Æ THEN ALL_ASM_FC_T asm_rewrite_tac[]);
val €closed_interval_connected_thm› = save_pop_thm "closed_interval_connected_thm";
=TEX
We can now characterise the connected subsets of the real line as those
which sets which contain every point lying between any two members.
%%%%
%%%%

=SML
set_goal([], ¨µX∑
		X ç OpenâR Connected
	§	µx y z∑x ç X ± y ç X ± x º z ± z º y ¥ z ç XÆ
);
a(REPEAT_N 3 strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[connected_def, space_Ø_thm, Ø_º_def] THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac THEN contr_tac);
a(strip_asm_tac (µ_elim¨zÆ half_infinite_intervals_open_thm));
a(lemma_tac¨X Ä {t|t < z} ¿ {t | z < t}Æ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a((cases_tac¨x' = zÆ THEN1 all_var_elim_asm_tac) THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(lemma_tac¨X ° {t|t < z} ° {t | z < t} = {}Æ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2" *** *)
a(lemma_tac¨≥X Ä {t|t < z}Æ THEN PC_T "sets_ext1" contr_tac);
(* *** Goal "1.2.2.1" *** *)
a(spec_nth_asm_tac 1 ¨yÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2.2" *** *)
a(lemma_tac¨≥X Ä {t|z < t}Æ THEN PC_T "sets_ext1" contr_tac);
(* *** Goal "1.2.2.2.1" *** *)
a(spec_nth_asm_tac 1 ¨xÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2.2.2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN strip_asm_tac open_Ø_topology_thm);
a(bc_thm_tac connected_pointwise_bc_thm);
a(REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim[¨xÆ, ¨yÆ] Ø_less_cases_thm));
(* *** Goal "2.1" *** *)
a(∂_tac¨ClosedInterval x yÆ);
a(ALL_FC_T rewrite_tac[closed_interval_connected_thm]);
a(PC_T1 "sets_ext1" rewrite_tac[closed_interval_def]);
a(REPEAT strip_tac THEN all_asm_fc_tac[] THEN asm_rewrite_tac[Ø_º_def]);
(* *** Goal "2.2" *** *)
a(∂_tac¨{x}Æ THEN asm_rewrite_tac[enum_set_clauses]);
a(lemma_tac¨y ç Space OpenâRÆ THEN1 rewrite_tac[space_Ø_thm]);
a(ALL_FC_T rewrite_tac[singleton_connected_thm]);
(* *** Goal "2.3" *** *)
a(∂_tac¨ClosedInterval y xÆ);
a(ALL_FC_T rewrite_tac[closed_interval_connected_thm]);
a(PC_T1 "sets_ext1" rewrite_tac[closed_interval_def]);
a(REPEAT strip_tac THEN rename_tac[] THEN all_asm_fc_tac[] THEN asm_rewrite_tac[Ø_º_def]);
val €connected_Ø_thm› = save_pop_thm "connected_Ø_thm";
=TEX
Note there is essentially no arithmetic involved in the following. The only fact being
used is that the open intervals provide a basis for the topology of the real line
that is closed under finite intersections.
%%%%
%%%%

=SML
set_goal([], ¨µX f∑
	X ç (OpenâR ∏âT OpenâR)
¥	(f ç (X ÚâT (OpenâR ∏âT OpenâR), OpenâR) Continuous
	§	µx y u v∑ f(u, v) ç OpenInterval x y ± (u, v) ç X ¥
		∂a b c d∑u ç OpenInterval a b ± v ç OpenInterval c d ±
			µs t∑	s ç OpenInterval a b ± t ç OpenInterval c d ± (s, t) ç X
			¥	f(s, t) ç OpenInterval x y)Æ);
a(rewrite_tac[continuous_def]);
a(strip_asm_tac open_Ø_topology_thm);
a(all_fc_tac[product_topology_thm]);
a(ALL_FC_T rewrite_tac [subspace_topology_space_thm, product_topology_space_thm]);
a(rewrite_tac[space_Ø_thm]);
a(rewrite_tac [open_Ø_def, product_topology_def, subspace_topology_def,
	merge_pcs_rule1 ["'bin_rel", "sets_ext"] prove_rule[]¨(Universe ∏ Universe) = UniverseÆ]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 discard_tac);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o µ_elim¨OpenInterval x yÆ));
(* *** Goal "1.1" *** *)
a(swap_nth_asm_concl_tac 1 THEN REPEAT strip_tac);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
a(∂_tac¨yÆ THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(lemma_tac¨(u, v) ç B ° XÆ THEN1
	(POP_ASM_T (rewrite_thm_tac o eq_sym_rule) THEN asm_rewrite_tac[]));
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac);
a(LIST_DROP_NTH_ASM_T [4, 5] all_fc_tac);
a(MAP_EVERY ∂_tac [¨x''Æ, ¨y''Æ, ¨x'Æ, ¨y'Æ] THEN REPEAT strip_tac);
a(LEMMA_T¨(s, t) ç B ° XÆ ante_tac THEN1 REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µx a b∑x ç a ± a Ä b ¥ x ç bÆ]);
a(lemma_tac¨(s, t) ç (A ∏ B')Æ THEN1 asm_rewrite_tac[∏_def]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µx a b∑x ç a ± a Ä b ¥ x ç bÆ]);
(* *** Goal "1.2.2" *** *)
a(DROP_NTH_ASM_T 12 (rewrite_thm_tac o eq_sym_rule) THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨{(s, t) | (s, t) ç X ±  f(s, t) ç A }Æ THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac);
a(LIST_DROP_NTH_ASM_T [6] all_fc_tac);
a(LIST_DROP_NTH_ASM_T [4, 5, 10] all_fc_tac);
a(MAP_EVERY ∂_tac [¨OpenInterval a b ° OpenInterval x''' y'''Æ,
	¨OpenInterval c d ° OpenInterval x''  y''Æ] THEN REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(strip_asm_tac (list_µ_elim[¨aÆ, ¨bÆ, ¨x'''Æ, ¨y'''Æ] °_open_interval_thm));
a(MAP_EVERY ∂_tac [¨x''''Æ,	¨y''''Æ]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule) THEN REPEAT strip_tac);
(* *** Goal "2.1.2" *** *)
a(strip_asm_tac (list_µ_elim[¨cÆ, ¨dÆ, ¨x''Æ, ¨y''Æ] °_open_interval_thm));
a(MAP_EVERY ∂_tac [¨x''''Æ,	¨y''''Æ]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule) THEN REPEAT strip_tac);
(* *** Goal "2.1.3" *** *)
a(rewrite_tac[∏_def] THEN PC_T1 "sets_ext1" rewrite_tac[]);
a(REPEAT µ_tac THEN ¥_tac);
a(once_rewrite_tac[taut_rule¨µa b∑a ± b § a ± (a ¥ b)Æ] THEN REPEAT strip_tac);
(* *** Goal "2.1.3.1" *** *)
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µx a b∑x ç a ± a Ä b ¥ x ç bÆ]);
a(lemma_tac¨(x1, x2) ç (A' ∏ B)Æ THEN1 asm_rewrite_tac[∏_def]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µx a b∑x ç a ± a Ä b ¥ x ç bÆ]);
(* *** Goal "2.1.3.2" *** *)
a(all_asm_fc_tac[] THEN PC_T1 "sets_ext1" all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(PC_T1 "sets_ext1" prove_tac[]);
val €continuous_Ø_∏_Ø_Ø_thm› = save_pop_thm "plus_continuous_Ø_∏_Ø_Ø_thm";
=TEX
The special case of the above theorem when $X$ is the whole space is very useful:.
%%%%
%%%%

=SML
set_goal([], ¨µf∑
	f ç ((OpenâR ∏âT OpenâR), OpenâR) Continuous
	§	µx y u v∑ f(u, v) ç OpenInterval x y ¥
		∂a b c d∑u ç OpenInterval a b ± v ç OpenInterval c d ±
			µs t∑	s ç OpenInterval a b ± t ç OpenInterval c d
			¥	f(s, t) ç OpenInterval x yÆ);
a(ante_tac(µ_elim¨Space (OpenâR ∏âT OpenâR)Æ continuous_Ø_∏_Ø_Ø_thm));
a(strip_asm_tac open_Ø_topology_thm);
a(all_fc_tac[product_topology_thm]);
a(ALL_FC_T rewrite_tac [trivial_subspace_topology_thm, space_open_thm]);
a(ALL_FC_T rewrite_tac [product_topology_space_thm]);
a(rewrite_tac[space_Ø_thm,
	merge_pcs_rule1 ["'bin_rel", "sets_ext"] prove_rule[]¨(Universe ∏ Universe) = UniverseÆ]);
val €continuous_Ø_∏_Ø_Ø_thm1› = save_pop_thm "plus_continuous_Ø_∏_Ø_Ø_thm1";
=TEX
The plan is to use the following to derive an equivalent condition to the above
phrased in terms of absolute values for use in showing that multiplication defines a
continuous mapping of the plane to the real line.
%%%%
%%%%

=SML
set_goal([], ¨µX∑
	(µx y u v∑ f(u, v) ç OpenInterval x y ± (u, v) ç X ¥
		∂a b c d∑u ç OpenInterval a b ± v ç OpenInterval c d ±
			µs t∑	s ç OpenInterval a b ± t ç OpenInterval c d ± (s, t) ç X
			¥	f(s, t) ç OpenInterval x y)
§	(µe u v∑ ÓØ 0 < e ± (u, v) ç X ¥
		∂d1 d2 ∑ ÓØ 0 < d1 ± ÓØ 0 < d2 ±
			µs t∑	Abs(s - u) < d1 ± Abs(t - v) < d2 ± (s, t) ç X
			¥	Abs(f(s, t) - f(u, v)) < e)
Æ);
a(rewrite_tac[open_interval_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(list_spec_nth_asm_tac 3 [¨f(u, v) + ~eÆ, ¨f(u, v) + eÆ, ¨uÆ, ¨vÆ]
	THEN_TRY SOLVED_T(PC_T1"Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨ÓØ 0 < u + ~a ±  ÓØ 0 < b + ~u ± ÓØ 0 < v + ~c ± ÓØ 0 < d + ~vÆ
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(cases_tac¨u + ~a < b + ~uÆ THEN cases_tac¨v + ~c < d + ~vÆ);
(* *** Goal "1.1" *** *)
a(∂_tac¨u + ~aÆ THEN ∂_tac¨v + ~cÆ THEN  asm_rewrite_tac[]);
a(ALL_FC_T1 fc_§_canon rewrite_tac[Ø_abs_diff_bounded_thm] THEN REPEAT µ_tac THEN ¥_tac);
a(DROP_NTH_ASM_T 12 bc_thm_tac);
a(PC_T1"Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(∂_tac¨u + ~aÆ THEN ∂_tac¨d + ~vÆ THEN  asm_rewrite_tac[]);
a(ALL_FC_T1 fc_§_canon rewrite_tac[Ø_abs_diff_bounded_thm] THEN REPEAT µ_tac THEN ¥_tac);
a(DROP_NTH_ASM_T 12 bc_thm_tac);
a(PC_T1"Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.3" *** *)
a(∂_tac¨b + ~uÆ THEN ∂_tac¨v + ~cÆ THEN  asm_rewrite_tac[]);
a(ALL_FC_T1 fc_§_canon rewrite_tac[Ø_abs_diff_bounded_thm] THEN REPEAT µ_tac THEN ¥_tac);
a(DROP_NTH_ASM_T 12 bc_thm_tac);
a(PC_T1"Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.4" *** *)
a(∂_tac¨b + ~uÆ THEN ∂_tac¨d + ~vÆ THEN  asm_rewrite_tac[]);
a(ALL_FC_T1 fc_§_canon rewrite_tac[Ø_abs_diff_bounded_thm] THEN REPEAT µ_tac THEN ¥_tac);
a(DROP_NTH_ASM_T 12 bc_thm_tac);
a(PC_T1"Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨∂e∑ÓØ 0 < e ± e º f(u, v) + ~x ± e º  y + ~(f(u, v))Æ THEN1
	(cases_tac ¨f(u, v) + ~x º y + ~(f(u, v))Æ  THEN_LIST
	[∂_tac¨f(u, v) + ~xÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[],
	 ∂_tac¨y + ~(f(u, v))Æ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]]));
a(all_asm_fc_tac[]);
a(MAP_EVERY ∂_tac [¨u + ~d1Æ, ¨u + d1Æ, ¨v + ~d2Æ, ¨v + d2Æ]);
a(strip_tac THEN_TRY SOLVED_T (PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(strip_tac THEN_TRY SOLVED_T (PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(REPEAT µ_tac THEN ¥_tac);
a(LIST_SPEC_NTH_ASM_T 6 [¨sÆ, ¨tÆ] ante_tac);
a(ALL_FC_T1 fc_§_canon rewrite_tac[Ø_abs_diff_bounded_thm]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €continuous_Ø_∏_Ø_Ø_lemma› = pop_thm ();
=TEX
%%%%
%%%%

=SML
val €continuous_Ø_∏_Ø_Ø_thm3› = save_thm(
	"continuous_Ø_∏_Ø_Ø_thm3",
	rewrite_rule[continuous_Ø_∏_Ø_Ø_lemma] continuous_Ø_∏_Ø_Ø_thm);
val €continuous_Ø_∏_Ø_Ø_thm4› = save_thm(
	"continuous_Ø_∏_Ø_Ø_thm4",
	rewrite_rule[
		rewrite_rule[](µ_elim¨Universe:(Ø ∏ Ø) SETÆ
			continuous_Ø_∏_Ø_Ø_lemma)] continuous_Ø_∏_Ø_Ø_thm1);
=TEX
The above lets us make light work of showing the addition viewed as a function from the plane
to the real line is continuous:
%%%%
%%%%

=SML
set_goal([], ¨ (Uncurry $+) ç ((OpenâR ∏âT OpenâR), OpenâR) Continuous Æ);
a(rewrite_tac[continuous_Ø_∏_Ø_Ø_thm1] THEN REPEAT strip_tac);
a(MAP_EVERY ∂_tac[ ¨u - (1/2)*(u + v - x)Æ, ¨u + (1/2)*(y - (u + v))Æ,
	¨v - (1/2)*(u + v - x)Æ, ¨v + (1/2)*(y - (u + v))Æ]);
a(POP_ASM_T ante_tac THEN rewrite_tac[open_interval_def] THEN REPEAT strip_tac
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €plus_continuous_Ø_∏_Ø_thm› = save_pop_thm "plus_continuous_Ø_∏_Ø_thm";
=TEX

%%%%
%%%%

=SML
set_goal([], ¨ (Uncurry $*) ç ((OpenâR ∏âT OpenâR), OpenâR) Continuous Æ);
a(rewrite_tac[continuous_Ø_∏_Ø_Ø_thm4] THEN REPEAT strip_tac);
a(lemma_tac¨∂t∑Abs u + ÓØ 1 < t ± Abs v < tÆ);
(* *** Goal "1" *** *)
a(cases_tac ¨Abs u + ÓØ 1 <  Abs vÆ THEN_LIST [
	∂_tac ¨ Abs v + ÓØ 1Æ, ∂_tac¨Abs u + ÓØ 2Æ]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨ÓØ 0  < ÓØ 2 * tÆ THEN1 
	(strip_asm_tac(µ_elim¨vÆØ_0_º_abs_thm) THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨ÓØ 0 < e * (ÓØ 2 * t) õ-õ1Æ THEN1
	(all_fc_tac[Ø_0_less_0_less_recip_thm] THEN all_fc_tac[Ø_0_less_0_less_times_thm]));
a(lemma_tac¨∂d∑ÓØ 0 <  d ± d < ÓØ 1 ± d <  e * (ÓØ 2 * t) õ-õ1Æ);
(* *** Goal "2.1" *** *)
a(cases_tac ¨ÓØ 1 < e * (ÓØ 2 * t) õ-õ1ÆTHEN_LIST [
	∂_tac ¨1/2Æ, ∂_tac¨(1/2)* e * (ÓØ 2 * t) õ-õ1Æ]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(∂_tac¨dÆ THEN ∂_tac¨dÆ THEN REPEAT strip_tac);
a(bc_thm_tac (rewrite_rule[]times_lim_seq_lemma));
a(∂_tac¨tÆ THEN REPEAT strip_tac THEN_TRY PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 2 ante_tac THEN ALL_FC_T1 fc_§_canon rewrite_tac[Ø_abs_diff_bounded_thm]);
a(DROP_NTH_ASM_T 8 ante_tac);
a(cases_tac¨ÓØ 0 º sÆ THEN cases_tac ¨ÓØ 0 º uÆ
	THEN asm_rewrite_tac[Ø_abs_def]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €times_continuous_Ø_∏_Ø_thm› = save_pop_thm "times_continuous_Ø_∏_Ø_thm";
=TEX

%%%%
%%%%

=SML
set_goal([], ¨µb c f g ” ‘∑
	” ç  Topology
±	‘ ç  Topology
±	c ç (”, OpenâR) Continuous
±	f ç (”, ‘) Continuous
±	g ç (”, ‘) Continuous
±	(µx∑x ç Space ” ± c x = b ¥ f x = g x)
¥	(Ãx∑if c x º b then f x else g x) ç (”, ‘) Continuous
Æ);
a(REPEAT strip_tac);
a(LEMMA_T ¨µx∑c x º b § x ç {t|c t º b}Æ pure_once_rewrite_thm_tac THEN1
	rewrite_tac[]);
a(bc_thm_tac cond_continuous_thm THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN rewrite_tac[Ø_≥_º_less_thm] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 bc_thm_tac);
a(strip_asm_tac (list_µ_elim[¨c xÆ, ¨bÆ] Ø_less_cases_thm) THEN
	REPEAT strip_tac THEN  i_contr_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨{t | t < b} ç OpenâRÆ THEN1
	rewrite_tac[half_infinite_intervals_open_thm]);
a(DROP_NTH_ASM_T 7 (fn th => all_fc_tac[rewrite_rule[continuous_def] th]));
a(spec_nth_asm_tac 5 ¨{x|x ç Space ” ± c x ç {t|t < b}}Æ);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨{t | b < t} ç OpenâRÆ THEN1
	rewrite_tac[half_infinite_intervals_open_thm]);
a(DROP_NTH_ASM_T 7 (fn th => all_fc_tac[rewrite_rule[continuous_def] th]));
a(spec_nth_asm_tac 5 ¨{x|x ç Space ” ± c x ç {t|b < t}}Æ);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €cond_continuous_Ø_thm› = save_pop_thm "cond_continuous_Ø_thm";
=TEX

%%%%
%%%%

=SML
set_goal([], ¨
	DâR ç Metric
Æ);
a(rewrite_tac[metric_def, d_Ø_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[Ø_0_º_abs_thm]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[Ø_abs_eq_0_thm] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[Ø_abs_0_thm]);
(* *** Goal "4" *** *)
a(pure_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[] ¨y + ~x = ~(x + ~y)Æ, Ø_abs_minus_thm]);
a(rewrite_tac[]);
(* *** Goal "5" *** *)
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[] ¨z + ~x = (y + ~x) + (z + ~y)Æ, Ø_abs_plus_thm]);
val €d_Ø_metric_thm› = save_pop_thm "d_Ø_metric_thm";
=TEX

%%%%
%%%%

=SML
set_goal([], ¨
	MetricTopology DâR = OpenâR
Æ);
a(PC_T1 "sets_ext1" rewrite_tac[metric_topology_def, open_Ø_delta_thm, d_Ø_def] THEN REPEAT strip_tac);
val €d_Ø_open_Ø_thm› = save_pop_thm "d_Ø_open_Ø_thm";
=TEX

%%%%
%%%%

=SML
set_goal([], ¨µD1 D2∑
	D1 ç Metric ± D2 ç Metric
¥	(Ã((x1, x2), (y1, y2))∑ D1(x1, y1) + D2(x2, y2)) ç Metric
Æ);
a(rewrite_tac[metric_def, d_Ø_2_def1] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac (pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µx y∑ÓØ 0 º x ± ÓØ 0 º y ¥ ÓØ 0 º x + yÆ) THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac ¨ÓØ 0 º D1(Fst x, Fst y) ± ÓØ 0 º D2(Snd x, Snd y)Æ
	THEN1 asm_rewrite_tac[]);
a(lemma_tac ¨D1(Fst x, Fst y) = ÓØ 0 ± D2(Snd x, Snd y) = ÓØ 0Æ
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[]);
a(pure_once_rewrite_tac[prove_rule[]¨µp∑p = (Fst p, Snd p)Æ]);
a(pure_asm_rewrite_tac[] THEN rewrite_tac[]);
(* *** Goal "3" *** *)
a(LEMMA_T¨x = y ± (µx∑ D1(x, x) = ÓØ 0) ± (µy∑D2(y, y) = ÓØ 0)Æ rewrite_thm_tac
	THEN LIST_GET_NTH_ASM_T [1, 4, 8] rewrite_tac);
(* *** Goal "4" *** *)
a(GET_NTH_ASM_T 6 (rewrite_thm_tac o µ_elim¨Fst yÆ));
a(GET_NTH_ASM_T 2 (rewrite_thm_tac o µ_elim¨Snd yÆ));
(* *** Goal "5" *** *)
a(bc_thm_tac (pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b c d e f:Ø∑a º c + e ± b º d + f ¥ a + b º (c + d) + e + fÆ));
a(asm_rewrite_tac[]);
val €product_metric_thm› = save_pop_thm "product_metric_thm";
=TEX

%%%%
%%%%

=SML
set_goal([], ¨µD1 D2∑
	D1 ç Metric ± D2 ç Metric
¥	MetricTopology (Ã((x1, x2), (y1, y2))∑ D1(x1, y1) + D2(x2, y2))  =
	(MetricTopology D1 ∏âT MetricTopology D2)
Æ);
a(rewrite_tac[metric_def, metric_topology_def, product_topology_def] THEN
	PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LIST_DROP_NTH_ASM_T [2] all_fc_tac);
a(lemma_tac¨ÓØ 0 < (1/2)*eÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(∂_tac¨{x1 | D1(x', x1)  < (1/2)*e}Æ THEN ∂_tac¨{x2 | D2(y, x2)  < (1/2)*e}Æ THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(∂_tac¨(1/2)*e - D1(x' , x'')Æ THEN REPEAT strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨D1(x', y') º D1(x', x'') + D1(x'', y')Æ THEN1 GET_NTH_ASM_T 11 rewrite_thm_tac);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(∂_tac¨(1/2)*e - D2(y , x'')Æ THEN REPEAT strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨D2(y, y') º D2(y, x'') + D2(x'', y')Æ THEN1 GET_NTH_ASM_T 7 rewrite_thm_tac);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.3" *** *)
a(LEMMA_T ¨µx∑ D1(x, x) = ÓØ 0Æ asm_rewrite_thm_tac
	THEN1 LIST_GET_NTH_ASM_T [1, 11] rewrite_tac);
(* *** Goal "1.4" *** *)
a(LEMMA_T ¨µx∑ D2(x, x) = ÓØ 0Æ asm_rewrite_thm_tac
	THEN LIST_GET_NTH_ASM_T [1, 7] rewrite_tac);
(* *** Goal "1.5" *** *)
a(rewrite_tac[∏_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (bc_thm_tac o rewrite_rule[]));
a(rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 2 (ante_tac o list_µ_elim[¨Fst x'Æ, ¨Snd x'Æ]));
a(rewrite_tac[] THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [4, 5] all_fc_tac);
a(cases_tac¨e < e'Æ);
(* *** Goal "2.1" *** *)
a(∂_tac¨eÆ THEN REPEAT strip_tac);
a(bc_thm_tac (pc_rule1 "sets_ext1" prove_rule[]¨µa x y∑ a Ä x ± y ç a ¥ y ç xÆ));
a(∂_tac¨A ∏ BÆ THEN REPEAT strip_tac);
a(lemma_tac ¨ÓØ 0 º D1 (Fst x', Fst y) ± ÓØ 0 º  D2 (Snd x', Snd y)Æ
	THEN1 LIST_GET_NTH_ASM_T [14, 18] rewrite_tac);
a(lemma_tac ¨D1 (Fst x', Fst y) < e' ± D2 (Snd x', Snd y) < eÆ
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T[7, 9] all_fc_tac);
a(rewrite_tac[∏_def] THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(∂_tac¨e'Æ THEN REPEAT strip_tac);
a(bc_thm_tac (pc_rule1 "sets_ext1" prove_rule[]¨µa x y∑ a Ä x ± y ç a ¥ y ç xÆ));
a(∂_tac¨A ∏ BÆ THEN REPEAT strip_tac);
a(lemma_tac ¨ÓØ 0 º D1 (Fst x', Fst y) ± ÓØ 0 º  D2 (Snd x', Snd y)Æ
	THEN1 LIST_GET_NTH_ASM_T [14, 18] rewrite_tac);
a(lemma_tac ¨D1 (Fst x', Fst y) < e' ± D2 (Snd x', Snd y) < eÆ
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T[7, 9] all_fc_tac);
a(rewrite_tac[∏_def] THEN REPEAT strip_tac);
val €product_metric_topology_thm› = save_pop_thm "product_metric_topology_thm";
=TEX

%%%%
%%%%

=SML
set_goal([], ¨
	DâR2 ç Metric
Æ);
a(LEMMA_T ¨DâR2 = (Ã ((x1, x2), y1, y2)∑ DâR (x1, y1) + DâR (x2, y2))Æ rewrite_thm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[d_Ø_def] THEN REPEAT strip_tac);
a(pure_once_rewrite_tac[prove_rule[]¨x = (Fst x, Snd x)Æ]);
a(pure_rewrite_tac[d_Ø_2_def1]);
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(bc_thm_tac product_metric_thm THEN rewrite_tac[d_Ø_metric_thm]);
val €d_Ø_2_metric_thm› = save_pop_thm "d_Ø_2_metric_thm";
=TEX

%%%%
%%%%

=SML
set_goal([], ¨
	MetricTopology DâR2 = (OpenâR ∏âT OpenâR)
Æ);
a(LEMMA_T ¨DâR2 = (Ã ((x1, x2), y1, y2)∑ DâR (x1, y1) + DâR (x2, y2))Æ rewrite_thm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[d_Ø_def] THEN REPEAT strip_tac);
a(pure_once_rewrite_tac[prove_rule[]¨x = (Fst x, Snd x)Æ]);
a(pure_rewrite_tac[d_Ø_2_def1]);
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac d_Ø_metric_thm);
a(ALL_FC_T rewrite_tac[product_metric_topology_thm]);
a(rewrite_tac[d_Ø_open_Ø_thm]);
val €d_Ø_2_open_Ø_∏_open_Ø_thm› = save_pop_thm "d_Ø_2_open_Ø_∏_open_Ø_thm";
=TEX
%%%%
%%%%
\section{HOMOTOPY THEORY --- THEOREMS}
=SML
open_theory "homotopy";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙", "'Ø"];
=TEX
\subsection{The Definitions}
=SML
val €path_connected_def› = get_spec¨$PathConnectedÆ;
val €homotopy_def› = get_spec¨$HomotopyÆ;
val €homotopy_class_def› = get_spec¨$HomotopyClassÆ;
val €path_space_def› = get_spec¨$PathSpaceÆ;
val €path_plus_def› = get_spec¨$+âPÆ;
val €path_0_def› = get_spec¨0âPÆ;
val €path_minus_def› = get_spec¨~âPÆ;
=TEX
Path-connectedness implies connectedness, because a path, as the continuous image of
a connected set is itself connected.
%%%%
%%%%
\subsection{Path Connectedness}
=SML
set_goal([], ¨µ‘ X∑
	‘ ç Topology
±	X ç ‘ PathConnected
¥	X ç ‘ Connected
Æ);
a(rewrite_tac[path_connected_def] THEN REPEAT strip_tac);
a(bc_thm_tac connected_pointwise_bc_thm THEN REPEAT strip_tac);
a(list_spec_nth_asm_tac 3 [¨xÆ, ¨yÆ]);
a(ante_tac(list_µ_elim[¨fÆ, ¨Universe:Ø SETÆ, ¨OpenâRÆ, ¨‘Æ] image_connected_thm));
a(pure_asm_rewrite_tac[open_Ø_topology_thm, universe_Ø_connected_thm]);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨{y|∂ x∑ y = f x}Æ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1 THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨ÓØ 0Æ THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨ÓØ 1Æ THEN asm_rewrite_tac[]);
val €path_connected_connected_thm› = save_pop_thm "path_connected_connected_thm";
=TEX
%%%%
%%%%
\subsection{Homotopy Classes}

=SML
set_goal([], ¨µ” X ‘ f∑
	” ç Topology
±	‘ ç Topology
±	f ç (”, ‘) Continuous
¥	f ç ((”, X, ‘) HomotopyClass) f
Æ);
a(rewrite_tac[ homotopy_def, homotopy_class_def ] THEN REPEAT strip_tac);
a(asm_tac open_Ø_topology_thm);
a(lemma_tac ¨(” ∏âT OpenâR) ç TopologyÆ
	THEN1 all_fc_tac[product_topology_thm]);
a(lemma_tac ¨(Ã (x, y)∑ x) ç ((” ∏âT OpenâR), ”) ContinuousÆ
	THEN1 all_fc_tac[left_proj_continuous_thm]);
a(all_fc_tac[arb_gen comp_continuous_thm]);
a(POP_ASM_T ante_tac THEN rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨Ã x∑ f (Fst x)Æ THEN asm_rewrite_tac[]);
val €homotopy_class_refl_thm› = save_pop_thm "homotopy_class_refl_thm";
=TEX
%%%%
%%%%

=SML
val €Ã_un_¬_rand_conv› : CONV = (fn tm =>
	let	val (v, _) = dest_Ã tm;
	in	SIMPLE_Ã_C (RAND_C (un_¬_conv v)) tm
	end
);
set_goal([], ¨µ” : 'a SET SET; X ‘ f g∑
	” ç Topology
±	‘ ç Topology
±	g ç ((”, X, ‘) HomotopyClass) f
¥	f ç ((”, X, ‘) HomotopyClass) g
Æ);
a(rewrite_tac[ homotopy_def, homotopy_class_def ] THEN REPEAT strip_tac);
a(∂_tac¨Ã xt∑ H(Fst xt, ÓØ 1 -  Snd xt)Æ THEN asm_rewrite_tac[]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac comp_continuous_thm);
a(asm_tac open_Ø_topology_thm);
a(lemma_tac ¨(” ∏âT OpenâR) ç TopologyÆ
	THEN1 all_fc_tac[product_topology_thm]);
a(∂_tac¨” ∏âT OpenâRÆ THEN asm_rewrite_tac[]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac product_continuous_thm THEN asm_rewrite_tac[]);
a(rewrite_tac[prove_rule[]¨(Ãxt∑Fst xt) = (Ã(x, y)∑x)Æ]);
a(ALL_FC_T rewrite_tac[left_proj_continuous_thm]);
a(pure_rewrite_tac[prove_rule[]¨µx y:Ø∑ x + y = Uncurry $+ (x, y)Æ]);
a(conv_tac (LEFT_C Ã_un_¬_rand_conv));
a(bc_thm_tac comp_continuous_thm);
a(lemma_tac ¨(OpenâR ∏âT OpenâR) ç TopologyÆ
	THEN1 all_fc_tac[product_topology_thm]);
a(∂_tac¨OpenâR ∏âT OpenâRÆ THEN asm_rewrite_tac[plus_continuous_Ø_∏_Ø_thm]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac product_continuous_thm THEN asm_rewrite_tac[]);
a(lemma_tac¨ÓØ 1 ç Space OpenâRÆ THEN1 rewrite_tac[space_Ø_thm]);
a(ALL_FC_T rewrite_tac[const_continuous_thm]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac comp_continuous_thm THEN asm_rewrite_tac[]);
a(∂_tac¨OpenâRÆ THEN asm_rewrite_tac[continuous_cts_at_Ø_thm, minus_cts_thm]);
a(rewrite_tac[prove_rule[]¨(Ãxt∑Snd xt) = (Ã(x, y)∑y)Æ]);
a(ALL_FC_T rewrite_tac[right_proj_continuous_thm]);
val €homotopy_class_sym_thm› = save_pop_thm "homotopy_class_sym_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ” : 'a SET SET; X ‘ f g h∑
	” ç Topology
±	‘ ç Topology
±	g ç ((”, X, ‘) HomotopyClass) f
±	h ç ((”, X, ‘) HomotopyClass) g
¥	h ç ((”, X, ‘) HomotopyClass) f
Æ);
a(rewrite_tac[ homotopy_def, homotopy_class_def ] THEN REPEAT strip_tac);
a(∂_tac¨
	Ã xt∑
	if	Snd xt º 1/2
	then	H(Fst xt, ÓØ 2 * Snd xt)
	else	H'(Fst xt, ÓØ 2 * (Snd xt + ~ (1/2)))Æ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(conv_tac (LEFT_C(Ã_C(RATOR_C(RATOR_C(RAND_C ¬_conv))))));
a(bc_thm_tac cond_continuous_Ø_thm);
a(strip_asm_tac open_Ø_topology_thm THEN ALL_FC_T asm_rewrite_tac[product_topology_thm]);
a(REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(rewrite_tac[prove_rule[]¨Snd = Ã(x, y)∑ yÆ]);
a(bc_thm_tac right_proj_continuous_thm THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac comp_continuous_thm);
a(lemma_tac ¨(” ∏âT OpenâR) ç TopologyÆ
	THEN1 all_fc_tac[product_topology_thm]);
a(∂_tac¨” ∏âT OpenâRÆ THEN asm_rewrite_tac[]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac product_continuous_thm THEN asm_rewrite_tac[]);
a(rewrite_tac[prove_rule[]¨(Ãxt∑Fst xt) = (Ã(x, y)∑x)Æ]);
a(ALL_FC_T rewrite_tac[left_proj_continuous_thm]);
a(pure_rewrite_tac[prove_rule[]¨µx y:Ø∑ x * y = Uncurry $* (x, y)Æ]);
a(conv_tac (LEFT_C Ã_un_¬_rand_conv));
a(bc_thm_tac comp_continuous_thm);
a(lemma_tac ¨(OpenâR ∏âT OpenâR) ç TopologyÆ
	THEN1 all_fc_tac[product_topology_thm]);
a(∂_tac¨OpenâR ∏âT OpenâRÆ THEN asm_rewrite_tac[times_continuous_Ø_∏_Ø_thm]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac product_continuous_thm THEN asm_rewrite_tac[]);
a(lemma_tac¨ÓØ 2 ç Space OpenâRÆ THEN1 rewrite_tac[space_Ø_thm]);
a(ALL_FC_T rewrite_tac[const_continuous_thm]);
a(rewrite_tac[prove_rule[]¨(Ãx∑Snd x)= Ã(x, y)∑ yÆ]);
a(bc_thm_tac right_proj_continuous_thm THEN REPEAT strip_tac);
(* *** Goal "1.3" *** *)
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac comp_continuous_thm);
a(lemma_tac ¨(” ∏âT OpenâR) ç TopologyÆ
	THEN1 all_fc_tac[product_topology_thm]);
a(∂_tac¨” ∏âT OpenâRÆ THEN asm_rewrite_tac[]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac product_continuous_thm THEN asm_rewrite_tac[]);
a(rewrite_tac[prove_rule[]¨(Ãxt∑Fst xt) = (Ã(x, y)∑x)Æ]);
a(ALL_FC_T rewrite_tac[left_proj_continuous_thm]);
a(pure_rewrite_tac[prove_rule[]¨µx y:Ø∑ x * y = Uncurry $* (x, y)Æ]);
a(conv_tac (LEFT_C Ã_un_¬_rand_conv));
a(bc_thm_tac comp_continuous_thm);
a(lemma_tac ¨(OpenâR ∏âT OpenâR) ç TopologyÆ
	THEN1 all_fc_tac[product_topology_thm]);
a(∂_tac¨OpenâR ∏âT OpenâRÆ THEN asm_rewrite_tac[times_continuous_Ø_∏_Ø_thm]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac product_continuous_thm THEN asm_rewrite_tac[]);
a(lemma_tac¨ÓØ 2 ç Space OpenâRÆ THEN1 rewrite_tac[space_Ø_thm]);
a(ALL_FC_T rewrite_tac[const_continuous_thm]);
a(pure_rewrite_tac[prove_rule[]¨µx y:Ø∑ x + y = Uncurry $+ (x, y)Æ]);
a(conv_tac (LEFT_C Ã_un_¬_rand_conv));
a(bc_thm_tac comp_continuous_thm);
a(∂_tac¨OpenâR ∏âT OpenâRÆ THEN asm_rewrite_tac[plus_continuous_Ø_∏_Ø_thm]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac product_continuous_thm THEN asm_rewrite_tac[]);
a(lemma_tac¨~(1/2) ç Space OpenâRÆ THEN1 rewrite_tac[space_Ø_thm]);
a(ALL_FC_T rewrite_tac[const_continuous_thm]);
a(rewrite_tac[prove_rule[]¨(Ãxt∑ Snd xt) = (Ã(x, y)∑y)Æ]);
a(ALL_FC_T rewrite_tac[right_proj_continuous_thm]);
(* *** Goal "1.4" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨µt∑ H(x, t) = g x ± H'(x, t) = g xÆ rewrite_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(LIST_DROP_NTH_ASM_T [6] (rewrite_tac o map (conv_rule(ONCE_MAP_C eq_sym_conv))));
a(ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(LIST_DROP_NTH_ASM_T [3] (rewrite_tac o map (conv_rule(ONCE_MAP_C eq_sym_conv))));
a(ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "2.3" *** *)
a(cases_tac ¨s º 1/2Æ THEN cases_tac ¨t º 1/2Æ THEN  asm_rewrite_tac[]);
val €homotopy_class_trans_thm› = save_pop_thm "homotopy_class_trans_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ” X Y ‘ H∑
	” ç Topology
±	‘ ç Topology
±	H ç (”, X, ‘) Homotopy
±	Y Ä X
¥	H ç (”, Y, ‘) Homotopy
Æ);
a(rewrite_tac[ homotopy_def ] THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
a(ALL_ASM_FC_T rewrite_tac[]);
val €homotopy_Ä_thm› = save_pop_thm "homotopy_Ä_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ” X Y ‘ f g∑
	” ç Topology
±	‘ ç Topology
±	g ç ((”, X, ‘) HomotopyClass) f
±	Y Ä X
¥	g ç ((”, Y, ‘) HomotopyClass) f
Æ);
a(rewrite_tac[ homotopy_class_def ] THEN REPEAT strip_tac);
a(∂_tac¨HÆ THEN ALL_FC_T asm_rewrite_tac[homotopy_Ä_thm]);
val €homotopy_class_Ä_thm› = save_pop_thm "homotopy_class_Ä_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ“ ” ‘ X f g h∑
	“ ç Topology
±	” ç Topology
±	‘ ç Topology
±	g ç ((“, X, ”) HomotopyClass) f
±	h ç (”,‘) Continuous
¥	(Ãx∑h(g x)) ç ((“, X, ‘) HomotopyClass) (Ãx∑h(f x))
Æ);
a(rewrite_tac[ homotopy_def, homotopy_class_def ] THEN REPEAT strip_tac);
a(∂_tac¨Ãxt∑ h(H xt)Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac comp_continuous_thm);
a(∂_tac¨”Æ THEN REPEAT strip_tac);
a(bc_thm_tac product_topology_thm THEN asm_rewrite_tac[open_Ø_topology_thm]);
(* *** Goal "2" *** *)
a(ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(asm_rewrite_tac[]);
val €homotopy_class_comp_left_thm› = save_pop_thm "homotopy_class_comp_left_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ“ ” ‘ X f g h∑
	“ ç Topology
±	” ç Topology
±	‘ ç Topology
±	g ç ((”, X, ‘) HomotopyClass) f
±	h ç (“,”) Continuous
¥	(Ãx∑g(h x)) ç ((“, {x | h x ç X}, ‘) HomotopyClass) (Ãx∑f(h x))
Æ);
a(rewrite_tac[ homotopy_def, homotopy_class_def ] THEN REPEAT strip_tac);
a(∂_tac¨Ãxt∑ H ((Ãxt∑ (h(Fst xt), Snd xt)) xt)Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac comp_continuous_thm);
a(strip_asm_tac open_Ø_topology_thm);
a(∂_tac¨(” ∏âT OpenâR)Æ THEN ALL_FC_T asm_rewrite_tac[arb_gen product_topology_thm]);
a(pure_once_rewrite_tac[prove_rule[]¨µx∑h(Fst x) = (Ãx∑h(Fst x))xÆ]);
a(bc_thm_tac product_continuous_thm);
a(ALL_FC_T asm_rewrite_tac[arb_gen product_topology_thm] THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(bc_thm_tac comp_continuous_thm);
a(∂_tac¨“Æ THEN ALL_FC_T asm_rewrite_tac[arb_gen product_topology_thm]);
a(rewrite_tac[prove_rule[]¨Fst = (Ã(x, y)∑ x)Æ]);
a(bc_thm_tac left_proj_continuous_thm THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(rewrite_tac[prove_rule[]¨Snd = (Ã(x, y)∑ y)Æ]);
a(bc_thm_tac right_proj_continuous_thm THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(asm_rewrite_tac[]);
val €homotopy_class_comp_right_thm› = save_pop_thm "homotopy_class_comp_right_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ f g ∑
	‘ ç Topology
±	f ç (‘,OpenâR) Continuous
±	g ç (‘,OpenâR) Continuous
¥	g ç ((‘, {x | g x = f x}, OpenâR) HomotopyClass) f
Æ);
a(rewrite_tac[ homotopy_def, homotopy_class_def ] THEN REPEAT strip_tac);
a(∂_tac¨Ãxt∑ (ÓØ 1 + ~(Snd xt))*f (Fst xt) + (Snd xt)*g(Fst xt) Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(pure_once_rewrite_tac[prove_rule[]¨µx y:Ø∑ x + y = Uncurry $+ (x, y)Æ]);
a(conv_tac (LEFT_C Ã_un_¬_rand_conv));
a(bc_thm_tac comp_continuous_thm);
a(∂_tac¨OpenâR ∏âT OpenâRÆ THEN asm_rewrite_tac[plus_continuous_Ø_∏_Ø_thm]);
a(strip_asm_tac open_Ø_topology_thm);
a(ALL_FC_T asm_rewrite_tac[product_topology_thm]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac product_continuous_thm);
a(ALL_FC_T asm_rewrite_tac[product_topology_thm] THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(pure_once_rewrite_tac[prove_rule[]¨µx y:Ø∑ x * y = Uncurry $* (x, y)Æ]);
a(conv_tac (LEFT_C Ã_un_¬_rand_conv));
a(bc_thm_tac comp_continuous_thm);
a(∂_tac¨OpenâR ∏âT OpenâRÆ THEN asm_rewrite_tac[times_continuous_Ø_∏_Ø_thm]);
a(ALL_FC_T asm_rewrite_tac[product_topology_thm] THEN REPEAT strip_tac);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac product_continuous_thm);
a(ALL_FC_T asm_rewrite_tac[product_topology_thm] THEN REPEAT strip_tac);
(* *** Goal "1.1.1" *** *)
a(pure_once_rewrite_tac[prove_rule[]¨µx y:Ø∑ x + y = Uncurry $+ (x, y)Æ]);
a(conv_tac (LEFT_C Ã_un_¬_rand_conv));
a(bc_thm_tac comp_continuous_thm);
a(∂_tac¨OpenâR ∏âT OpenâRÆ THEN asm_rewrite_tac[plus_continuous_Ø_∏_Ø_thm]);
a(ALL_FC_T asm_rewrite_tac[product_topology_thm]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac product_continuous_thm);
a(lemma_tac¨(‘ ∏âT OpenâR) ç TopologyÆ THEN1 ALL_FC_T asm_rewrite_tac[product_topology_thm]);
a(lemma_tac¨ÓØ 1 ç Space OpenâRÆ THEN1 rewrite_tac[space_Ø_thm]);
a(ALL_FC_T asm_rewrite_tac[product_topology_thm, arb_gen const_continuous_thm]);
a(bc_thm_tac comp_continuous_thm);
a(∂_tac¨OpenâRÆ THEN asm_rewrite_tac[minus_cts_thm, continuous_cts_at_Ø_thm]);
a(rewrite_tac[prove_rule[]¨Snd = (Ã(x, y)∑ y)Æ]);
a(bc_thm_tac right_proj_continuous_thm THEN REPEAT strip_tac);
(* *** Goal "1.1.2" *** *)
a(bc_thm_tac comp_continuous_thm);
a(∂_tac¨‘Æ THEN ALL_FC_T asm_rewrite_tac[product_topology_thm]);
a(rewrite_tac[prove_rule[]¨Fst = (Ã(x, y)∑ x)Æ]);
a(bc_thm_tac left_proj_continuous_thm THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(pure_once_rewrite_tac[prove_rule[]¨µx y:Ø∑ x * y = Uncurry $* (x, y)Æ]);
a(conv_tac (LEFT_C Ã_un_¬_rand_conv));
a(bc_thm_tac comp_continuous_thm);
a(∂_tac¨OpenâR ∏âT OpenâRÆ THEN asm_rewrite_tac[times_continuous_Ø_∏_Ø_thm]);
a(ALL_FC_T asm_rewrite_tac[product_topology_thm]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac product_continuous_thm);
a(ALL_FC_T asm_rewrite_tac[product_topology_thm] THEN REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(rewrite_tac[»_axiom, prove_rule[]¨Snd = (Ã(x, y)∑ y)Æ]);
a(bc_thm_tac right_proj_continuous_thm THEN REPEAT strip_tac);
(* *** Goal "1.2.2" *** *)
a(bc_thm_tac comp_continuous_thm);
a(∂_tac¨‘Æ THEN ALL_FC_T asm_rewrite_tac[product_topology_thm]);
a(rewrite_tac[prove_rule[]¨Fst = (Ã(x, y)∑ x)Æ]);
a(bc_thm_tac left_proj_continuous_thm THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(asm_rewrite_tac[]);
val €homotopy_class_Ø_thm› = save_pop_thm "homotopy_class_Ø_thm";
=TEX
\subsection{The Path Groupoid}

%%%%
%%%%

=SML
set_goal([], ¨µ‘ x∑
	‘ ç Topology
±	x ç Space ‘
¥	0âP x ç PathSpace ‘
Æ);
a(rewrite_tac[path_space_def, path_0_def] THEN REPEAT strip_tac);
a(strip_asm_tac open_Ø_topology_thm);
a(all_fc_tac[const_continuous_thm]);
val €path_0_path_thm› = save_pop_thm "path_0_path_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ f g∑
	‘ ç Topology
±	f ç PathSpace ‘
±	g ç PathSpace ‘
±	g(ÓØ 0) = f(ÓØ 1)
¥	f +âP g ç PathSpace ‘
Æ);
a(rewrite_tac[path_space_def, path_plus_def] THEN REPEAT strip_tac);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(pure_rewrite_tac[prove_rule[]¨µt∑ ((Ã t∑ t º 1 / 2) t) = ((Ãt∑ t) t º 1/2)Æ]);
a(bc_thm_tac cond_continuous_Ø_thm);
a(strip_asm_tac open_Ø_topology_thm);
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac comp_continuous_thm);
a(∂_tac¨OpenâRÆ THEN REPEAT strip_tac);
a(rewrite_tac[continuous_cts_at_Ø_thm]);
a(REPEAT (REPEAT strip_tac THEN simple_cts_tac));
(* *** Goal "2" *** *)
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac comp_continuous_thm);
a(∂_tac¨OpenâRÆ THEN REPEAT strip_tac);
a(rewrite_tac[continuous_cts_at_Ø_thm]);
a(REPEAT (REPEAT strip_tac THEN simple_cts_tac));
(* *** Goal "3" *** *)
a(all_var_elim_asm_tac1 THEN asm_rewrite_tac[]);
val €path_plus_path_thm› = save_pop_thm "path_plus_path_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ f∑
	‘ ç Topology
±	f ç PathSpace ‘
¥	 ~âP f ç PathSpace ‘
Æ);
a(rewrite_tac[path_minus_def, path_space_def] THEN REPEAT strip_tac);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac comp_continuous_thm);
a(strip_asm_tac open_Ø_topology_thm);
a(∂_tac¨OpenâRÆ THEN REPEAT strip_tac);
a(rewrite_tac[continuous_cts_at_Ø_thm]);
a(REPEAT (REPEAT strip_tac THEN simple_cts_tac));
val €path_minus_path_thm› = save_pop_thm "path_minus_path_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ f g h k∑
	‘ ç Topology
±	f ç PathSpace ‘
±	g ç PathSpace ‘
±	h ç PathSpace ‘
±	(µt∑k t = if t º 1/4 then ÓØ 2*t else if t º 1/2 then t + 1/4 else (1/2)*t + 1/2)
¥	((f +âP g) +âP h) = Ãt∑ (f +âP (g +âP h)) (k t)
Æ);
a(rewrite_tac[path_space_def, path_plus_def] THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
a(cases_tac¨x º 1/4Æ THEN cases_tac ¨x º 1/2Æ THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(LEMMA_T¨ÓØ 2*x º 1/2Æ  rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(LEMMA_T¨≥ÓØ 2*x º 1/2 ± ≥x + 1/4 º 1/2Æ  rewrite_thm_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨ÓØ 2 * ((x + 1 / 4) + ~ (1 / 2)) º 1 / 2Æ  rewrite_thm_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(conv_tac (ONCE_MAP_C Ø_anf_conv) THEN strip_tac);
(* *** Goal "4" *** *)
a(LEMMA_T¨≥(1/2)*x º ÓØ 0Æ  rewrite_thm_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨≥ÓØ 2 * ((1 / 2 * x + 1 / 2) + ~ (1 / 2)) º 1 / 2Æ  rewrite_thm_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(conv_tac (ONCE_MAP_C Ø_anf_conv) THEN strip_tac);
val €path_plus_assoc_lemma1› = save_pop_thm "path_plus_assoc_lemma1";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µk∑
	(µt∑k t = if t º 1/4 then ÓØ 2*t else if t º 1/2 then t + 1/4 else (1/2)*t + 1/2)
¥	k ç (OpenâR, OpenâR) Continuous
Æ);
a(REPEAT strip_tac);
a(pure_once_rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) (µ_elim¨kÆ»_axiom)]);
a(POP_ASM_T pure_rewrite_thm_tac);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(pure_rewrite_tac[prove_rule[]¨µt∑ ((Ã t∑ t º 1 / 4) t) = ((Ãt∑ t) t º 1/4)Æ]);
a(bc_thm_tac cond_continuous_Ø_thm);
a(strip_asm_tac open_Ø_topology_thm);
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[continuous_cts_at_Ø_thm]);
a(REPEAT (REPEAT strip_tac THEN simple_cts_tac));
(* *** Goal "2" *** *)
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(pure_rewrite_tac[prove_rule[]¨µt∑ ((Ã t∑ t º 1 / 2) t) = ((Ãt∑ t) t º 1/2)Æ]);
a(bc_thm_tac cond_continuous_Ø_thm);
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[continuous_cts_at_Ø_thm]);
a(REPEAT (REPEAT strip_tac THEN simple_cts_tac));
(* *** Goal "2.2" *** *)
a(rewrite_tac[continuous_cts_at_Ø_thm]);
a(REPEAT (REPEAT strip_tac THEN simple_cts_tac));
(* *** Goal "2.3" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
val €path_plus_assoc_lemma2› = save_pop_thm "path_plus_assoc_lemma2";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µk∑
	(µt∑k t = if t º 1/4 then ÓØ 2*t else if t º 1/2 then t + 1/4 else (1/2)*t + 1/2)
¥	k ç ((OpenâR, {ÓØ 0; ÓØ 1},OpenâR) HomotopyClass) (Ãx∑x)
Æ);
a(REPEAT strip_tac);
a(bc_thm_tac homotopy_class_Ä_thm);
a(strip_asm_tac open_Ø_topology_thm THEN asm_rewrite_tac[]);
a(∂_tac¨{x | k x = (Ãx∑ x) x}Æ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac homotopy_class_Ø_thm);
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm, path_plus_assoc_lemma2]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
val €path_plus_assoc_lemma3› = save_pop_thm "path_plus_assoc_lemma3";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ f g h∑
	‘ ç Topology
±	f ç PathSpace ‘
±	g ç PathSpace ‘
±	h ç PathSpace ‘
±	g(ÓØ 0) = f(ÓØ 1)
±	h(ÓØ 0) = g(ÓØ 1)
¥	((f +âP g) +âP h) ç ((OpenâR, {ÓØ 0; ÓØ 1}, ‘) HomotopyClass)(f +âP (g +âP h))
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂k∑µt∑k t = if t º 1/4 then ÓØ 2*t else if t º 1/2 then t + 1/4 else (1/2)*t + 1/2Æ
	THEN1 prove_∂_tac);
a(strip_asm_tac open_Ø_topology_thm);
a(all_fc_tac[path_plus_assoc_lemma2, path_plus_assoc_lemma3]);
a(pure_once_rewrite_tac[prove_rule[]¨f +âP g +âP h = Ãt∑(f +âP g +âP h)((Ãx∑ x) t)Æ]);
a(PC_T1 "predicates" (ALL_FC_T pure_rewrite_tac)[path_plus_assoc_lemma1]);
a(bc_thm_tac homotopy_class_comp_left_thm);
a(∂_tac¨OpenâRÆ THEN REPEAT strip_tac);
a(bc_tac [path_plus_path_thm, pc_rule1 "sets_ext1" rewrite_rule[]path_space_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_tac [path_plus_path_thm, pc_rule1 "sets_ext1" rewrite_rule[]path_space_def]
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[path_plus_def]);
val €path_plus_assoc_thm› = save_pop_thm "path_plus_assoc_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ f k∑
	‘ ç Topology
±	f ç PathSpace ‘
±	(µt∑k t = if t º 1/2 then ÓØ 2*t else ÓØ 1)
¥	(f +âP 0âP (f(ÓØ 1))) = Ãt∑ f (k t)
Æ);
a(rewrite_tac[path_space_def, path_plus_def, path_0_def] THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
a(cases_tac¨x º 1/2Æ THEN asm_rewrite_tac[]);
val €path_plus_0_lemma1› = save_pop_thm "path_plus_0_lemma1";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µk∑
	(µt∑k t = if t º 1/2 then ÓØ 2*t else ÓØ 1)
¥	k ç (OpenâR, OpenâR) Continuous
Æ);
a(REPEAT strip_tac);
a(pure_once_rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) (µ_elim¨kÆ»_axiom)]);
a(POP_ASM_T pure_rewrite_thm_tac);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(pure_rewrite_tac[prove_rule[]¨µt∑ ((Ã t∑ t º 1 / 2) t) = ((Ãt∑ t) t º 1/2)Æ]);
a(bc_thm_tac cond_continuous_Ø_thm);
a(strip_asm_tac open_Ø_topology_thm);
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[continuous_cts_at_Ø_thm]);
a(REPEAT (REPEAT strip_tac THEN simple_cts_tac));
(* *** Goal "2" *** *)
a(rewrite_tac[continuous_cts_at_Ø_thm]);
a(REPEAT (REPEAT strip_tac THEN simple_cts_tac));
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
val €path_plus_0_lemma2› = save_pop_thm "path_plus_0_lemma2";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µk∑
	(µt∑k t = if t º 1/2 then ÓØ 2*t else ÓØ 1)
¥	k ç ((OpenâR, {ÓØ 0; ÓØ 1},OpenâR) HomotopyClass) (Ãx∑x)
Æ);
a(REPEAT strip_tac);
a(bc_thm_tac homotopy_class_Ä_thm);
a(strip_asm_tac open_Ø_topology_thm THEN asm_rewrite_tac[]);
a(∂_tac¨{x | k x = (Ãx∑ x) x}Æ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac homotopy_class_Ø_thm);
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm, path_plus_0_lemma2]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
val €path_plus_0_lemma3› = save_pop_thm "path_plus_0_lemma3";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ f∑
	‘ ç Topology
±	f ç PathSpace ‘
¥	f +âP 0âP (f(ÓØ 1)) ç ((OpenâR, {ÓØ 0; ÓØ 1}, ‘) HomotopyClass) f
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂k∑µt∑k t = if t º 1/2 then ÓØ 2*t else ÓØ 1Æ
	THEN1 prove_∂_tac);
a(strip_asm_tac open_Ø_topology_thm);
a(all_fc_tac[path_plus_0_lemma2, path_plus_0_lemma3]);
a(conv_tac (RIGHT_C (pure_once_rewrite_conv[prove_rule[]¨f = Ãt∑f ((Ãt∑t)t)Æ])));
a(PC_T1 "predicates" (ALL_FC_T pure_rewrite_tac)[path_plus_0_lemma1]);
a(bc_thm_tac homotopy_class_comp_left_thm);
a(∂_tac¨OpenâRÆ THEN REPEAT strip_tac);
a(bc_tac [pc_rule1 "sets_ext1" rewrite_rule[]path_space_def]
	THEN REPEAT strip_tac);
val €path_plus_0_thm› = save_pop_thm "path_plus_0_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ f k∑
	‘ ç Topology
±	f ç PathSpace ‘
±	(µt∑k t = if t º 1/2 then ÓØ 0 else ÓØ 2*t + ~(ÓØ 1))
¥	0âP (f(ÓØ 0)) +âP f = Ãt∑ f (k t)
Æ);
a(rewrite_tac[path_space_def, path_plus_def, path_0_def] THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
a(cases_tac¨x º 1/2Æ THEN  asm_rewrite_tac[]);
a(conv_tac (ONCE_MAP_C Ø_anf_conv) THEN  asm_rewrite_tac[]);
val €path_0_plus_lemma1› = save_pop_thm "path_0_plus_lemma1";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µk∑
	(µt∑k t = if t º 1/2 then ÓØ 0 else ÓØ 2*t + ~(ÓØ 1))
¥	k ç (OpenâR, OpenâR) Continuous
Æ);
a(REPEAT strip_tac);
a(pure_once_rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) (µ_elim¨kÆ»_axiom)]);
a(POP_ASM_T pure_rewrite_thm_tac);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(pure_rewrite_tac[prove_rule[]¨µt∑ ((Ã t∑ t º 1 / 2) t) = ((Ãt∑ t) t º 1/2)Æ]);
a(bc_thm_tac cond_continuous_Ø_thm);
a(strip_asm_tac open_Ø_topology_thm);
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[continuous_cts_at_Ø_thm]);
a(REPEAT (REPEAT strip_tac THEN simple_cts_tac));
(* *** Goal "2" *** *)
a(rewrite_tac[continuous_cts_at_Ø_thm]);
a(REPEAT (REPEAT strip_tac THEN simple_cts_tac));
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
val €path_0_plus_lemma2› = save_pop_thm "path_0_plus_lemma2";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µk∑
	(µt∑k t = if t º 1/2 then ÓØ 0 else ÓØ 2*t + ~(ÓØ 1))
¥	k ç ((OpenâR, {ÓØ 0; ÓØ 1},OpenâR) HomotopyClass) (Ãx∑x)
Æ);
a(REPEAT strip_tac);
a(bc_thm_tac homotopy_class_Ä_thm);
a(strip_asm_tac open_Ø_topology_thm THEN asm_rewrite_tac[]);
a(∂_tac¨{x | k x = (Ãx∑ x) x}Æ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac homotopy_class_Ø_thm);
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm, path_0_plus_lemma2]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
val €path_0_plus_lemma3› = save_pop_thm "path_0_plus_lemma3";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ f∑
	‘ ç Topology
±	f ç PathSpace ‘
¥	0âP (f(ÓØ 0)) +âP f ç ((OpenâR, {ÓØ 0; ÓØ 1}, ‘) HomotopyClass) f
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂k∑	(µt∑k t = if t º 1/2 then ÓØ 0 else ÓØ 2*t + ~(ÓØ 1))Æ
	THEN1 prove_∂_tac);
a(strip_asm_tac open_Ø_topology_thm);
a(all_fc_tac[path_0_plus_lemma2, path_0_plus_lemma3]);
a(conv_tac (RIGHT_C (pure_once_rewrite_conv[prove_rule[]¨f = Ãt∑f ((Ãt∑t)t)Æ])));
a(PC_T1 "predicates" (ALL_FC_T pure_rewrite_tac)[path_0_plus_lemma1]);
a(bc_thm_tac homotopy_class_comp_left_thm);
a(∂_tac¨OpenâRÆ THEN REPEAT strip_tac);
a(bc_tac [pc_rule1 "sets_ext1" rewrite_rule[]path_space_def]
	THEN REPEAT strip_tac);
val €path_0_plus_thm› = save_pop_thm "path_0_plus_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ f k∑
	‘ ç Topology
±	f ç PathSpace ‘
±	(µt∑k t = if t º 1/2 then ÓØ 2*t else ÓØ 2 + ~(ÓØ 2*t) )
¥	f +âP ~âP f= Ãt∑ f (k t)
Æ);
a(rewrite_tac[path_space_def, path_plus_def, path_minus_def] THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
a(cases_tac¨x º 1/2Æ THEN  asm_rewrite_tac[]);
a(conv_tac (ONCE_MAP_C Ø_anf_conv) THEN REPEAT strip_tac);
val €path_plus_minus_lemma1› = save_pop_thm "path_plus_minus_lemma1";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µk∑
	(µt∑k t = if t º 1/2 then ÓØ 2*t else ÓØ 2 + ~(ÓØ 2*t) )
¥	k ç (OpenâR, OpenâR) Continuous
Æ);
a(REPEAT strip_tac);
a(pure_once_rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) (µ_elim¨kÆ»_axiom)]);
a(POP_ASM_T pure_rewrite_thm_tac);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(pure_rewrite_tac[prove_rule[]¨µt∑ ((Ã t∑ t º 1 / 2) t) = ((Ãt∑ t) t º 1/2)Æ]);
a(bc_thm_tac cond_continuous_Ø_thm);
a(strip_asm_tac open_Ø_topology_thm);
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[continuous_cts_at_Ø_thm]);
a(REPEAT (REPEAT strip_tac THEN simple_cts_tac));
(* *** Goal "2" *** *)
a(rewrite_tac[continuous_cts_at_Ø_thm]);
a(REPEAT (REPEAT strip_tac THEN simple_cts_tac));
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
val €path_plus_minus_lemma2› = save_pop_thm "path_plus_minus_lemma2";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µk∑
	(µt∑k t = if t º 1/2 then ÓØ 2*t else ÓØ 2 + ~(ÓØ 2*t) )
¥	k ç ((OpenâR, {ÓØ 0; ÓØ 1},OpenâR) HomotopyClass) (Ãx∑ÓØ 0)
Æ);
a(REPEAT strip_tac);
a(bc_thm_tac homotopy_class_Ä_thm);
a(strip_asm_tac open_Ø_topology_thm THEN asm_rewrite_tac[]);
a(∂_tac¨{x | k x = (Ãx∑ ÓØ 0) x}Æ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac homotopy_class_Ø_thm);
a(lemma_tac¨ÓØ 0 ç Space OpenâRÆ THEN1 rewrite_tac[space_Ø_thm]);
a(ALL_FC_T asm_rewrite_tac[const_continuous_thm, path_plus_minus_lemma2]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
val €path_plus_minus_lemma3› = save_pop_thm "path_plus_minus_lemma3";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ f∑
	‘ ç Topology
±	f ç PathSpace ‘
¥	f +âP ~âP fç ((OpenâR, {ÓØ 0; ÓØ 1}, ‘) HomotopyClass) (0âP (f(ÓØ 0)))
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂k∑ (µt∑k t = if t º 1/2 then ÓØ 2*t else ÓØ 2 + ~(ÓØ 2*t) )Æ
	THEN1 prove_∂_tac);
a(strip_asm_tac open_Ø_topology_thm);
a(all_fc_tac[path_plus_minus_lemma2, path_plus_minus_lemma3]);
a(rewrite_tac[path_0_def]);
a(pure_once_rewrite_tac[prove_rule[]¨(Ãt∑f(ÓØ 0)) =(Ãt∑f((Ãt∑ÓØ 0)t))Æ]);
a(PC_T1 "predicates" (ALL_FC_T pure_rewrite_tac)[path_plus_minus_lemma1]);
a(bc_thm_tac homotopy_class_comp_left_thm);
a(∂_tac¨OpenâRÆ THEN REPEAT strip_tac);
a(bc_tac [pc_rule1 "sets_ext1" rewrite_rule[]path_space_def]
	THEN REPEAT strip_tac);
val €path_plus_minus_thm› = save_pop_thm "path_plus_minus_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µf∑
	 ~âP (~âP f) = f
Æ);
a(rewrite_tac[path_minus_def] THEN conv_tac (ONCE_MAP_C Ø_anf_conv));
a(REPEAT strip_tac);
val €path_minus_minus_thm› = save_pop_thm "path_minus_minus_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µ‘ f∑
	‘ ç Topology
±	f ç PathSpace ‘
¥	~âP f +âP fç ((OpenâR, {ÓØ 0; ÓØ 1}, ‘) HomotopyClass) (0âP (f(ÓØ 1)))
Æ);
a(REPEAT strip_tac);
a(all_fc_tac[path_minus_path_thm]);
a(DROP_NTH_ASM_T 2 discard_tac);
a(ALL_FC_T (MAP_EVERY ante_tac) [path_plus_minus_thm]);
a(rewrite_tac[path_minus_minus_thm]);
a(rewrite_tac[path_0_def, path_minus_def]);
val €path_minus_plus_thm› = save_pop_thm "path_minus_plus_thm";
=TEX
\subsection{Epilogue}
=TEX
=SML
output_theory{out_file="topology1.th.doc", theory="topology"};
output_theory{out_file="topology2.th.doc", theory="metric_spaces"};
output_theory{out_file="topology3.th.doc", theory="topology_Ø"};
output_theory{out_file="topology4.th.doc", theory="homotopy"};
=TEX
\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}
\end{document}


