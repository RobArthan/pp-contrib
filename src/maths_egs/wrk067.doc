pp_make_database -f -p hol topology
docsml topology analysis
xpp -file topology.doc -com pp -d topology -i analysis,topology &
doctex topology topology.th  topology_examples.th; texdvi topology
=TEX
\documentclass[10pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\title{Mathematical Case Studies: \\ --- \\ Some Abstract Topology}
\author{Rob Arthan}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
This {\ProductHOL} script contains definitions and proofs concerning some
basics of abstract topology. This includes the definitions of the following:
construction of new topologies from old as (binary) product spaces or subspaces;
continuity, Hausdorff spaces; connectedness;  compactness. A range of basic theorems are
proved, including: continuity of functional composition and of the structural maps
for products; preservation of compactness and connectedness under continuous maps;
connectedness resp. compactness of products of connected resp. compact spaces.
\end{abstract}
\vfill
\newpage
\tableofcontents
\newpage
%%%%
%%%%
%%%%
%%%%
\section{INTRODUCTION}
%%%%
%%%%
%%%%
%%%%
=SML
force_delete_theory"topology" handle Fail _ => ();
open_theory"bin_rel";
set_merge_pcs["basic_hol1", "'sets_alg"];
new_theory"topology";
new_parent"fin_set";
=TEX
%%%%
%%%%
%%%%
%%%%
\section{DEFINITIONS}\label{DEFINITIONS}
=TEX
We begin with the definition of a topology. We follow the most common tradition
of defining a topology by specifying its set of open sets. The polymorphic set
{\it Topology} is the set of all sets of sets that we will consider to be topologies.
We do not require a topology to form a topology on the universe of the type of its points.
For example, we wish to consider sets such as the unit interval in the real line to be
topological spaces in their own right. This actually simplifies the definition: we simply
require a topology to be a set of sets that is closed under arbitrary unions and
binary intersections. We do not require the underlying of the topology to 
be a non-empty set (following Kelley). Nor do we need to make a special case of
the empty set --- it will be shown to be an open set in any topology (as the union
of an empty set of open sets).
%%%%
%%%%
=SML
πHOLCONST
‹ €Topology› : 'a SET SET SET
˜¸¸¸¸¸¸
‹ 	Topology =
‹	{‘ | (µV∑ V Ä ‘ ¥ ﬁ V ç ‘) ± (µA B∑A ç ‘ ± B ç ‘ ¥ A ° B ç ‘)}
∞
=TEX
We can recover the underlying set of a topology as the union of all its open sets.
It reads quite nicely to call this the {\em space} of the topology.
%%%%
%%%%
=SML
πHOLCONST
‹ €$Space› : 'a SET SET ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ‘∑ Space ‘ = ﬁ ‘
∞
=TEX
A set is {\em closed} with respect to a topology, $\tau$, if is a subset of
the underlying set of the topology its complement in
that set is open (i.e., is a member of $\tau$).
For this and several other concepts, we use postfix notation to suggest informal
notations like ``$\tau-$closed''.
%%%%
%%%%
=SML
declare_postfix(300, "Closed");
πHOLCONST
‹ €$Closed› : 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ‘∑ ‘ Closed = {A | ∂B∑B ç ‘ ± A = Space ‘ \ B}
∞
=TEX
There are some issues abou the precise formalisation of continuity.
The interesting part is completely standard: a function is continuous
iff. the inverse images of open sets are open sets. Clearly, there are
two topologies here: one for the domain of the function and one for its
range.
It is technically convenient to work with functions that are total on the
universe of the type of the domain. In any case, we want to support
something like the usual way of thinking in the calculus
where one doesn't carefully restrict every function to the domain of interest.
E.g., one says things like ``$1/\mbox{sin}\;x$ is continuous from  $(0, \pi/2)$
to the positive real numbers.``.

The upshot is the following definiition of a continuous function from
the topological space $\sigma$ to the topological space $\tau$.
The function is required to map the underlying set of $\sigma$ to that of $\tau$.
It may well also map things outside the underlying of $\sigma$ into that
of $\tau$, and these need to be filtered out when we are testing whether the
inverse image of an open set is open.
%%%%
%%%%
=SML
declare_postfix(300, "Continuous");
πHOLCONST
‹ €$Continuous› : ('a SET SET ∏ 'b SET SET) ≠ ('a ≠ 'b) SET
˜¸¸¸¸¸¸
‹ µ” ‘∑	(”, ‘) Continuous =
‹	{f
‹	|	(µx∑ x ç Space ” ¥ f x ç Space ‘)
‹	±	(µA∑ A ç ‘ ¥ {x | x ç Space ” ± f x ç A} ç ”)}
∞
=TEX
The definition of compactness is the standard one, together with the explicit
requirement that the compact set be a subset of the space of the topology in question.
%%%%
%%%%
=SML
declare_postfix(300, "Compact");
πHOLCONST
‹ €$Compact› : 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ‘∑ ‘ Compact =
‹	{A | A Ä Space ‘ ± µV∑ V Ä ‘ ± A Ä ﬁ V ¥ ∂W∑ W Ä V ± W ç Finite ± A Ä ﬁ W}
∞
=TEX
Similarly, the definition of connectedness is the standard one, together with the explicit
requirement that the connected set be a subset of the underlying set of the topology in question.
%%%%
%%%%
=SML
declare_postfix(300, "Connected");
πHOLCONST
‹ €$Connected› : 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ‘∑ ‘ Connected =
‹	{A | A Ä Space ‘
‹	± µB C∑ B ç ‘ ± C ç ‘ ± A Ä B ¿ C ± A ° B ° C = {} ¥ (A Ä B ≤ A Ä C)}
∞
=TEX
We borrow the Z symbol for range restriction (decorated with a subscript
to avoid overloading) for the operator that forms the
subspace of a topological space defined by some subset of the universe of its points.
If that subset contains points outside the underlying set of the topological space they
are ignored.
%%%%
%%%%
=SML
declare_infix(240, "ÚâT");
πHOLCONST
‹ €$ÚâT› : 'a SET ≠ 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µX ‘∑ 	(X ÚâT ‘)
‹ =	{A | ∂B∑ B ç ‘ ± A = B ° X}
∞
=TEX
The definition of the product topology is straightforward.
%%%%
%%%%
=SML
declare_infix(150, "∏âT");
πHOLCONST
‹ €$∏âT› : 'a SET SET ≠ 'b SET SET ≠ ('a ∏ 'b) SET SET
˜¸¸¸¸¸¸
‹ µ” ‘∑ 	(” ∏âT ‘)
‹ =	{C | µ x y∑ (x, y) ç C ¥ ∂A B∑ A ç ” ±  B ç ‘ ± x ç A ± y ç B  ± (A ∏ B) Ä C}
∞
=TEX
Our final definition is the Hausdorff condition:
%%%%
%%%%
=SML
πHOLCONST
‹ €Hausdorff› : 'a SET SET SET
˜¸¸¸¸¸¸
‹ 	Hausdorff =
‹	{‘ | µx y∑ x ç Space ‘ ± y ç Space ‘ ± ≥x = y
‹	¥	∂A B∑A ç ‘ ± B ç ‘ ± x ç A ± y ç B ± A ° B = {}}
∞
=TEX
%%%%
%%%%
{\HOLindexOff
\include{topology.th}}
{\HOLindexOff
\include{topology_examples.th}}
=TEX
%%%%
%%%%
\section{THEOREMS AND PROOFS}
=TEX
%%%%
%%%%
\subsection{Lemmas About Finite Sets}
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µ A B C∑  (Insert A B) Ä C § A ç C ± B Ä C
Æ);
a(PC_T1 "sets_ext1" rewrite_tac[insert_def]);
a(prove_tac[]);
val €enum_set_Ä_thm› = save_pop_thm "enum_set_Ä_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	ﬁ{} = {}
±	µ A B∑  ﬁ(Insert A B) = A ¿ (ﬁB)
Æ);
a(REPEAT strip_tac THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(PC_T "sets_ext1" strip_tac);
a(rewrite_tac[ﬁ_def, insert_def, ¿_def]);
a(prove_tac[]);
val €ﬁ_enum_set_clauses› = save_pop_thm "ﬁ_enum_set_clauses";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	•{} = Universe
±	µ A B∑  •(Insert A B) = A ° (•B)
Æ);
a(REPEAT strip_tac THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(PC_T "sets_ext1" strip_tac);
a(rewrite_tac[•_def, insert_def, °_def]);
a(prove_tac[]);
val €•_enum_set_clauses› = save_pop_thm "•_enum_set_clauses";
val €enum_set_clauses› = list_±_intro
	[enum_set_Ä_thm,  ﬁ_enum_set_clauses, •_enum_set_clauses];
=TEX
The following should definitely go in the finite sets theory ASAP. !!! TBD !!!
%%%%
%%%%
=SML
set_goal([], ¨µA B∑
	 (A ¿ B) ç Finite § A ç Finite ± B ç Finite
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac ¨A Ä A ¿ BÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
(* *** Goal "2" *** *)
a(lemma_tac ¨B Ä A ¿ BÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨BÆ, ¨BÆ));
a(finite_induction_tac ¨AÆ THEN1 asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(LEMMA_T¨({x} ¿ A) ¿ B = {x} ¿ A ¿ BÆ
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(bc_thm_tac singleton_¿_finite_thm THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
val €¿_finite_thm› = save_pop_thm "¿_finite_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µV∑
	 V  ç Finite ± V Ä Finite ¥ ﬁV ç Finite
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µW∑ W ç Finite ± W Ä V ¥ ﬁW ç FiniteÆ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(finite_induction_tac¨WÆ);
(* *** Goal "1.1" *** *)
a(rewrite_tac[enum_set_clauses, empty_finite_thm]);
(* *** Goal "1.2" *** *)
a(LEMMA_T¨≥{x} ¿ W Ä VÆ rewrite_thm_tac);
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "1.3" *** *)
a(REPEAT strip_tac THEN
	rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa v∑ﬁ(a ¿ v) = ﬁa ¿ ﬁvÆ,
		enum_set_clauses]);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a b c∑{x} ¿ a Ä b ± b Ä c ¥ x ç cÆ]);
a(asm_rewrite_tac[¿_finite_thm]);
(* *** Goal "2" *** *)
a(POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
val €ﬁ_finite_thm› = save_pop_thm "ﬁ_finite_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ f : 'a ≠ 'b; A : 'a SET∑
	 A ç Finite ¥ {y | ∂x∑x ç A ± y = f x} ç Finite
Æ);
a(REPEAT strip_tac);
a(finite_induction_tac ¨AÆ THEN1 rewrite_tac[]);
(* *** Goal "1" *** *)
a(LEMMA_T¨{y:'b|F} = {}Æ (fn th => rewrite_tac[th, empty_finite_thm])
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨{y|∂ x'∑ x' ç {x} ¿ A ± y = f x'} = {f x} ¿ {y|∂ x'∑ x' ç A ± y = f x'}Æ
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(bc_thm_tac singleton_¿_finite_thm THEN REPEAT strip_tac);
val €finite_image_thm› = save_pop_thm "finite_image_thm";
=TEX
=TEX
%%%%
%%%%
\subsection{The Definitions}
=SML
val €topology_def› = get_spec¨$TopologyÆ;
val €space_def› = get_spec¨$SpaceÆ;
val €closed_def› = get_spec¨$ClosedÆ;
val €continuous_def› = get_spec¨$ContinuousÆ;
val €connected_def› = get_spec¨$ConnectedÆ;
val €compact_def› = get_spec¨$CompactÆ;
val €subspace_topology_def› = get_spec¨$ÚâTÆ;
val €product_topology_def› = get_spec¨$∏âTÆ;
val €hausdorff_def› = get_spec¨HausdorffÆ;
=TEX
\subsection{ProofPower Generalisation and Instantiation}
=SML
fun arb_gen (thm : THM) : THM = (
	let	val ty_map = map
			(fn tv => (mk_vartype("@_" ^ tv), mk_vartype tv))
			(term_tyvars(concl thm));
		val thm1 = asm_inst_type_rule ty_map thm;
	in	all_µ_intro (all_µ_arb_elim thm1)
	end
);
=TEX
\subsection{Elementary Properties of Open and Closed Sets}
%%%%
%%%%
=SML
set_goal([], ¨µ‘ : 'a SET SET ∑ ‘ ç Topology ¥ {} ç ‘Æ);
a(rewrite_tac[topology_def] THEN REPEAT strip_tac);
a(SPEC_NTH_ASM_T 2 ¨{}: 'a SET SETÆ ante_tac);
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨ﬁ{} = {}Æ]);
val €empty_open_thm› = save_pop_thm "empty_open_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ : 'a SET SET ∑ ‘ ç Topology ¥ Space ‘ ç ‘Æ);
a(rewrite_tac[topology_def, space_def] THEN REPEAT strip_tac);
a(SPEC_NTH_ASM_T 2 ¨‘: 'a SET SETÆ ante_tac);
a(rewrite_tac[]);
val €space_open_thm› = save_pop_thm "space_open_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ : 'a SET SET ∑ ‘ ç Topology ¥ {} ç ‘ ClosedÆ);
a(rewrite_tac[closed_def] THEN REPEAT strip_tac);
a(all_fc_tac[space_open_thm]);
a(∂_tac¨Space ‘Æ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" prove_tac[]);
val €empty_closed_thm› = save_pop_thm "empty_closed_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ : 'a SET SET ∑ ‘ ç Topology ¥ Space ‘ ç ‘ ClosedÆ);
a(rewrite_tac[closed_def] THEN REPEAT strip_tac);
a(all_fc_tac[empty_open_thm]);
a(∂_tac¨{} : 'a SETÆ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" prove_tac[]);
val €space_closed_thm› = save_pop_thm "space_closed_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ A ∑
	‘ ç Topology ¥
	(A ç ‘ § µx∑x ç A ¥ ∂B∑ B ç ‘ ± x ç B ± B Ä A)Æ);
a(rewrite_tac[topology_def, space_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨AÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨A = ﬁ{B | B ç ‘ ± B Ä A}Æ);
(* *** Goal "2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN
	contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(POP_ASM_T once_rewrite_thm_tac THEN DROP_NTH_ASM_T 3 bc_thm_tac);
a(PC_T1 "sets_ext1" prove_tac[]);
val €open_open_neighbourhood_thm› = save_pop_thm "open_open_neighbourhood_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ A ∑
	‘ ç Topology ¥
	(	A ç ‘ Closed
	§ 	A Ä Space ‘
	±	µx∑x ç Space ‘  ± ≥x ç A ¥ ∂B∑ B ç ‘ ± x ç B ± B ° A = {})Æ);
a(rewrite_tac[closed_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨x ç BÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[open_open_neighbourhood_thm]);
a(∂_tac¨B'Æ THEN PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(FC_T1 fc_§_canon once_rewrite_tac [open_open_neighbourhood_thm]);
a(∂_tac¨Space ‘ \ AÆ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(all_asm_fc_tac[]);
a(∂_tac¨BÆ THEN PC_T1 "sets_ext1" asm_rewrite_tac[]);
a(rewrite_tac[space_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "3.1.1" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "3.1.2" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac) THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "3.2" *** *)
a(LIST_GET_NTH_ASM_T [1, 3] (MAP_EVERY ante_tac)  THEN PC_T1 "sets_ext1" prove_tac[]);
val €closed_open_neighbourhood_thm› = save_pop_thm "closed_open_neighbourhood_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ x A ∑
	‘ ç Topology ± x ç A ± A ç ‘ ¥ x ç Space ‘
Æ);
a(rewrite_tac[topology_def, space_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €ç_space_thm› = save_pop_thm "ç_space_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ A B ∑
	‘ ç Topology ± A ç ‘ ± B ç ‘ ¥ A ¿ B ç ‘
Æ);
a(rewrite_tac[topology_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(SPEC_NTH_ASM_T 4 ¨{A; B}Æ (strip_asm_tac o rewrite_rule[enum_set_clauses]));
val €¿_open_thm› = save_pop_thm "¿_open_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ A B ∑
	‘ ç Topology ± A ç ‘ ± B ç ‘ ¥ A ° B ç ‘
Æ);
a(rewrite_tac[topology_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €°_open_thm› = save_pop_thm "°_open_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ V∑ 
	‘ ç Topology ± V Ä ‘ ± ≥V = {} ± V ç Finite
¥	•V ç ‘Æ);
a(rewrite_tac[topology_def] THEN REPEAT strip_tac);
a(POP_ASM_T (fn th => POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN asm_tac th));
a(finite_induction_tac¨VÆ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(all_var_elim_asm_tac1 THEN rewrite_tac[]);
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µx y∑{x} Ä y § x ç yÆ]);
a(LEMMA_T¨•{x} = xÆ (fn th => rewrite_tac [th] THEN taut_tac));
(* *** Goal "3" *** *)
a(PC_T"sets_ext1" strip_tac THEN rewrite_tac[•_def] THEN prove_tac[]);
(* *** Goal "4" *** *)
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µx y z∑{x} ¿ z Ä y § x ç y ± z Ä yÆ]);
a(LEMMA_T¨•({x} ¿ V) = x ° •VÆ rewrite_thm_tac);
(* *** Goal "4.1" *** *)
a(PC_T"sets_ext1" strip_tac THEN rewrite_tac[•_def, °_def, ¿_def] THEN prove_tac[]);
(* *** Goal "4.2" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
val €finite_•_open_thm› = save_pop_thm "finite_•_open_thm";
=TEX
\subsection{Constructing New Topologies from Old}
%%%%
%%%%
=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
¥	(X ÚâT ‘) ç TopologyÆ);
a(rewrite_tac[topology_def, subspace_topology_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_ante_tac THEN1 PC_T1 "sets_ext1" REPEAT strip_tac);
a(∂_tac ¨ﬁ{C| C ç ‘ ± C ° X ç V}Æ  THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "1.1" *** *)
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.2" *** *)
a(PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.2.1" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
a(∂_tac ¨BÆ  THEN REPEAT strip_tac);
(* *** Goal "1.2.2" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
(* *** Goal "1.2.3" *** *)
a(∂_tac ¨s ° XÆ  THEN PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(∂_tac ¨B' ° B''Æ   THEN PC_T1 "sets_ext1" asm_prove_tac[]);
val €subspace_topology_thm› = save_pop_thm "subspace_topology_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ A∑ 
	‘ ç Topology
¥	Space (A ÚâT ‘) = A ° Space ‘Æ);
a(rewrite_tac[topology_def, space_def, subspace_topology_def] THEN 
	PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(∂_tac ¨BÆ  THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(∂_tac ¨s ° AÆ  THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(∂_tac ¨s Æ  THEN REPEAT strip_tac);
val €subspace_topology_space_thm› = save_pop_thm "subspace_topology_space_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET∑ 
	” ç Topology
±	‘ ç Topology
¥	(” ∏âT ‘) ç TopologyÆ);
a(rewrite_tac[topology_def, product_topology_def]
	THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LIST_DROP_NTH_ASM_T  [3] all_fc_tac);
a(∂_tac¨AÆ  THEN ∂_tac ¨BÆ THEN REPEAT strip_tac);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx y z∑x Ä y ± y ç z ¥ x Ä ﬁ zÆ]);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T  [3, 4] all_fc_tac);
a(∂_tac¨A' ° A''Æ  THEN ∂_tac ¨B' ° B''Æ THEN REPEAT strip_tac
	THEN_TRY SOLVED_T (all_asm_fc_tac[]));
a(MERGE_PCS_T1["'bin_rel", "sets_ext1"] asm_prove_tac[]);
val €product_topology_thm› = save_pop_thm "product_topology_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET∑ 
	” ç Topology
±	‘ ç Topology
¥	Space  (” ∏âT ‘)  = (Space ” ∏ Space ‘)Æ);
a(rewrite_tac[product_topology_def, space_def]);
a(MERGE_PCS_T1["'bin_rel", "sets_ext1"] REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[] THEN contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨s ∏ s'Æ THEN MERGE_PCS_T1["'bin_rel", "sets_ext1"] REPEAT strip_tac);
a(∂_tac¨sÆ THEN ∂_tac¨s'Æ THEN MERGE_PCS_T1["'bin_rel", "sets_ext1"] REPEAT strip_tac);
val €product_topology_space_thm› = save_pop_thm "product_topology_space_thm";
=TEX
\subsection{Continuity}
%%%%
%%%%
=SML
set_goal([], ¨µ” ‘ c∑ 
	” ç Topology
±	‘ ç Topology
±	c ç Space ‘
¥	(Ãx∑ c) ç (”, ‘) Continuous
Æ);
a(REPEAT strip_tac);
a(rewrite_tac[continuous_def, topology_def] THEN 
	PC_T1 "sets_ext1" REPEAT strip_tac);
a(cases_tac¨c ç AÆ THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(rewrite_tac[pc_rule1"sets_ext" prove_rule[]¨{x | x ç Space ”} = Space ”Æ]);
a(all_asm_fc_tac[space_open_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[pc_rule1"sets_ext" prove_rule[]¨{x | F} = {}Æ]);
a(all_asm_fc_tac[empty_open_thm]);
val €const_continuous_thm› = save_pop_thm "const_continuous_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘∑ 
	‘ ç Topology
¥	(Ãx∑ x) ç (‘, ‘) Continuous
Æ);
a(rewrite_tac[continuous_def, topology_def, space_def] THEN 
	PC_T1 "sets_ext1" REPEAT strip_tac);
a(LEMMA_T ¨ {x|x ç ﬁ ‘ ± x ç A} = AÆ  asm_rewrite_thm_tac);
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext1"  prove_tac[]);
val €id_continuous_thm› = save_pop_thm "id_continuous_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g “ ” ‘∑ 
	f ç (“, ”) Continuous
±	g ç (”, ‘) Continuous
±	“ ç Topology
±	” ç Topology
±	‘ ç Topology
±	f ç (“, ”) Continuous
±	g ç (”, ‘) Continuous
¥	(Ãx∑ g(f x)) ç (“, ‘) Continuous
Æ);
a(rewrite_tac[continuous_def] THEN REPEAT strip_tac THEN
	(all_asm_fc_tac[] THEN all_asm_fc_tac[]));
a( LEMMA_T ¨{x|x ç Space “ ± g (f x) ç A} ={x|x ç Space “ ± f x ç {x|x ç Space ” ± g x ç A}}Æ
	once_rewrite_thm_tac THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" prove_tac[] THEN all_asm_fc_tac[]);
val €comp_continuous_thm› = save_pop_thm "comp_continuous_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET∑ 
	” ç Topology
±	‘ ç Topology
¥	(Ã(x, y)∑ x) ç ((” ∏âT ‘), ”) Continuous
Æ);
a(REPEAT strip_tac THEN rewrite_tac[continuous_def]);
a(all_fc_tac[arb_gen product_topology_thm]);
a(ALL_FC_T rewrite_tac [arb_gen product_topology_space_thm]);
a(rewrite_tac[product_topology_def, ∏_def] THEN REPEAT strip_tac);
a(∂_tac¨AÆ THEN ∂_tac¨Space ‘Æ THEN 
	ALL_FC_T asm_rewrite_tac[space_open_thm]);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(all_fc_tac[ç_space_thm]);
val €left_proj_continuous_thm› = save_pop_thm "left_proj_continuous_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET∑ 
	” ç Topology
±	‘ ç Topology
¥	(Ã(x, y)∑ y) ç ((” ∏âT ‘), ‘) Continuous
Æ);
a(REPEAT strip_tac THEN rewrite_tac[continuous_def]);
a(all_fc_tac[arb_gen product_topology_thm]);
a(ALL_FC_T rewrite_tac [arb_gen product_topology_space_thm]);
a(rewrite_tac[product_topology_def, ∏_def] THEN REPEAT strip_tac);
a(∂_tac¨Space ”Æ THEN ∂_tac¨AÆ THEN 
	ALL_FC_T asm_rewrite_tac[space_open_thm]);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(all_fc_tac[ç_space_thm]);
val €right_proj_continuous_thm› = save_pop_thm "right_proj_continuous_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ f : 'a ≠ 'b; g : 'a ≠ 'c; “ : 'a SET SET; ” : 'b SET SET; ‘ : 'c SET SET∑ 
	f ç (“, ”) Continuous
±	g ç (“, ‘) Continuous
±	“ ç Topology
±	” ç Topology
±	‘ ç Topology
±	f ç (“, ”) Continuous
±	g ç (“, ‘) Continuous
¥	(Ãz∑(f z, g z)) ç (“, (” ∏âT ‘)) Continuous
Æ);
a(REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [4, 5] (MAP_EVERY ante_tac));
a(rewrite_tac[continuous_def]);
a(all_fc_tac[arb_gen product_topology_thm]);
a(ALL_FC_T rewrite_tac [arb_gen product_topology_space_thm]);
a(rewrite_tac[product_topology_def, ∏_def] THEN REPEAT strip_tac
	THEN_TRY (SOLVED_T (all_asm_fc_tac[])));
a(LIST_DROP_NTH_ASM_T (interval 6 16) discard_tac
	THEN ALL_FC_T1 fc_§_canon once_rewrite_tac[open_open_neighbourhood_thm]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(LIST_DROP_NTH_ASM_T [11, 13] all_fc_tac);
a(∂_tac¨{x|x ç Space “ ± g x ç B} ° {x|x ç Space “ ± f x ç A'}Æ);
a(ALL_FC_T rewrite_tac[°_open_thm]);
a(REPEAT strip_tac THEN PC_T1"sets_ext1" REPEAT strip_tac);
a(bc_thm_tac (pc_rule1"sets_ext" prove_rule[]¨µa xy∑xy ç a ± a Ä A ¥ xy ç AÆ));
a(∂_tac¨{(v, w)|v ç A' ± w ç B}Æ THEN REPEAT strip_tac);
val €product_map_continuous_thm› = save_pop_thm "product_map_continuous_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET; y : 'b∑ 
	” ç Topology
±	‘ ç Topology
±	y ç Space ‘
¥	(Ãx∑ (x, y)) ç (”, ” ∏âT ‘) Continuous
Æ);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨Ãx:'a∑ xÆ, ¨Ãx:'a∑yÆ, ¨”Æ, ¨”Æ, ¨‘Æ] product_map_continuous_thm));
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm, const_continuous_thm]);
val €left_product_inj_continuous_thm› = save_pop_thm "left_product_inj_continuous_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ”: 'a SET SET; ‘ : 'b SET SET; x : 'a∑ 
	” ç Topology
±	‘ ç Topology
±	x ç Space ”
¥	(Ãy∑ (x, y)) ç (‘, ” ∏âT ‘) Continuous
Æ);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨Ãy:'b∑ xÆ, ¨Ãy:'b∑yÆ, ¨‘Æ, ¨”Æ, ¨‘Æ] product_map_continuous_thm));
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm, arb_gen const_continuous_thm]);
val €right_product_inj_continuous_thm› = save_pop_thm "right_product_inj_continuous_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ ‘ : 'a SET SET∑ 
	‘ ç Topology
¥	(Ãx∑ (x, x)) ç (‘, ‘ ∏âT ‘) Continuous
Æ);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨Ãx:'a∑ xÆ, ¨Ãx:'a∑xÆ, ¨‘Æ, ¨‘Æ, ¨‘Æ] product_map_continuous_thm));
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm, arb_gen const_continuous_thm]);
val €diag_inj_continuous_thm› = save_pop_thm "diag_inj_continuous_thm";
=TEX
\subsection{Compactness}
%%%%
%%%%
%%%%
%%%%
=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
¥	(X ç ‘ Compact § X ç (X ÚâT ‘) Compact)Æ);
a(rewrite_tac[compact_def] THEN PC_T1 "sets_ext1" REPEAT µ_tac THEN ¥_tac);
a(ALL_FC_T1 fc_§_canon rewrite_tac[subspace_topology_space_thm]);
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b∑a Ä a ° b § a Ä bÆ]);
a(rewrite_tac[subspace_topology_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨X Ä ﬁ{B | B ç ‘ ± B ° X ç V} Æ THEN1 PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(LIST_GET_NTH_ASM_T [1, 2, 3] (PC_T1 "sets_ext1" (MAP_EVERY strip_asm_tac)));
a(all_asm_fc_tac[]);
a(LIST_GET_NTH_ASM_T [3] all_fc_tac THEN all_var_elim_asm_tac1);
a(∂_tac¨BÆ THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(lemma_tac¨{B | B ç ‘ ± B ° X ç V} Ä ‘Æ THEN1 PC_T1 "sets_ext" prove_tac[]);
a(all_asm_fc_tac[]);
a(ante_tac(list_µ_elim[¨ÃB∑B ° XÆ, ¨WÆ]finite_image_thm));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac ¨{C|∂ B∑ B ç W ± C = B ° X}Æ THEN REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(PC_T "sets_ext1"  strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(LIST_GET_NTH_ASM_T [5] (PC_T1 "sets_ext1" all_fc_tac));
(* *** Goal "1.2.2" *** *)
a(PC_T "sets_ext1"  strip_tac THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [3] (PC_T1 "sets_ext1" all_fc_tac));
a(∂_tac¨s ° XÆ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(lemma_tac¨X Ä ﬁ{C | ∂B∑ B ç V ± C = B ° X} Æ THEN1 PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(LIST_GET_NTH_ASM_T [2] (PC_T1 "sets_ext1" all_fc_tac));
a(∂_tac¨s ° XÆ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(lemma_tac¨{C | ∂B∑ B ç V ± C = B ° X} Ä {A|∂ B∑ B ç ‘ ± A = B ° X}Æ
	THEN1 (PC_T "sets_ext" strip_tac THEN REPEAT strip_tac));
(* *** Goal "2.2.1" *** *)
a(all_var_elim_asm_tac1 THEN ∂_tac ¨BÆ THEN 
	REPEAT strip_tac THEN PC_T1 "sets_ext1" all_asm_fc_tac[]);
(* *** Goal "2.2.2" *** *)
a(all_asm_fc_tac[]);
a(lemma_tac¨∂f∑µC∑ C ç W ¥ f C ç V ± C = f C ° XÆ THEN1 prove_∂_tac);
(* *** Goal "2.2.2.1" *** *)
a(REPEAT strip_tac);
a(cases_tac¨≥C' ç WÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 4 (PC_T1 "sets_ext1" strip_asm_tac));
a(LIST_DROP_NTH_ASM_T [1] all_fc_tac);
a(all_var_elim_asm_tac1 THEN ∂_tac¨BÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2" *** *)
a(strip_asm_tac(list_µ_elim[¨fÆ, ¨WÆ]finite_image_thm));
a(∂_tac¨{y|∂ x∑ x ç W ± y = f x}Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(PC_T "sets_ext1"  strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a(PC_T "sets_ext1"  strip_tac THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (PC_T1 "sets_ext1" strip_asm_tac));
a(LIST_DROP_NTH_ASM_T [1] all_fc_tac);
a(∂_tac¨f sÆ THEN asm_rewrite_tac[]);
a(LIST_DROP_NTH_ASM_T [5] all_fc_tac);
a(DROP_NTH_ASM_T 4 ante_tac);
a(POP_ASM_T (fn th => conv_tac(LEFT_C(once_rewrite_conv[th]))));
a(REPEAT strip_tac THEN rename_tac[]);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
val €compact_topological_thm› = save_pop_thm "compact_topological_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf C ” ‘∑ 
	f ç (”, ‘) Continuous
±	C ç ” Compact
±	” ç Topology
±	‘ ç Topology
¥	{y | ∂x∑ x ç C ± y = f x} ç ‘ Compact
Æ);
a(rewrite_tac[compact_def, continuous_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac );
a(all_var_elim_asm_tac1 THEN PC_T1 "sets_ext1" all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨{A | ∂B∑ B ç V ± A = {x|x ç Space ” ± f x ç B}} Ä ”Æ);
(* *** Goal "2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN GET_NTH_ASM_T 8 bc_thm_tac);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a b∑x ç a ± a Ä b ¥ x ç bÆ]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨C Ä ﬁ{A | ∂B∑ B ç V ± A = {x|x ç Space ” ± f x ç B}}Æ);
(* *** Goal "2.2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(LEMMA_T¨f x ç {y|∂ x∑ x ç C ± y = f x}Æ  asm_tac THEN1
	(REPEAT strip_tac THEN ∂_tac¨xÆ THEN REPEAT strip_tac));
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a b∑x ç a ± a Ä b ¥ x ç bÆ]);
a(∂_tac¨{x|x ç Space ” ± f x ç s}Æ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(all_asm_fc_tac[]);
a(lemma_tac¨∂h∑µA∑ A ç W ¥ h A ç V ± A = {x | x ç Space ” ± f x ç h A}Æ
	THEN1 prove_∂_tac THEN REPEAT strip_tac);
 (* *** Goal "2.2.2.1" *** *)
a(cases_tac ¨A' ç WÆ  THEN asm_rewrite_tac[]);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a b∑x ç a ± a Ä b ¥ x ç bÆ]);
a(∂_tac¨BÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2" *** *)
a(strip_asm_tac (list_µ_elim[¨hÆ, ¨WÆ] finite_image_thm));
a(∂_tac¨{y|∂ x∑ x ç W ± y = h x}Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 7 discard_tac);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µb∑x' ç C ± C Ä b ¥ x' ç bÆ]);
a(∂_tac¨h sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.2.1" *** *)
a(all_asm_fc_tac[]);
a(POP_ASM_T (fn th => DROP_NTH_ASM_T 5 (ante_tac o once_rewrite_rule[th])));
a(REPEAT strip_tac);
(* *** Goal "2.2.2.2.2.2" *** *)
a(∂_tac¨sÆ THEN REPEAT strip_tac);
val €image_compact_thm› = save_pop_thm "image_compact_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µC D ”∑ 
	C ç ” Compact
±	D ç ” Compact
±	” ç Topology
¥	C ¿ D ç ” Compact
Æ);
a(rewrite_tac[compact_def] THEN REPEAT strip_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b c∑a ¿ b Ä c ¥ a Ä c ± b Ä cÆ]);
a(all_asm_fc_tac[]);
a(∂_tac ¨W ¿ W'Æ THEN
	rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b∑ﬁ(a ¿ b) = ﬁa ¿ ﬁbÆ]
	THEN ALL_FC_T rewrite_tac[
	pc_rule1"sets_ext1" prove_rule[]¨µa b c∑a Ä c ± b Ä c ¥ a ¿ b Ä cÆ,
	pc_rule1"sets_ext1" prove_rule[]¨µa b c d∑a Ä c ± b Ä d ¥ a ¿ b Ä d ¿ cÆ,
	conv_rule(ONCE_MAP_C eq_sym_conv) ¿_finite_thm]);
val €¿_compact_thm› = save_pop_thm "¿_compact_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µU ‘ X∑ 
	‘ ç Topology
±	U Ä ‘
±	(µA∑µx∑ x ç A ± A ç ‘ ¥ ∂B∑ x ç B ± B Ä A ± B ç U)
±	X Ä Space ‘
±	(µV∑ V Ä U ± X Ä ﬁ V ¥ ∂ W∑ W Ä V ± W ç Finite ± X Ä ﬁ W)
¥	X ç ‘ Compact
Æ);
a(rewrite_tac[compact_def] THEN REPEAT strip_tac);
a(lemma_tac¨{B | B ç U ± ∂ A∑ A ç V ± B Ä A} Ä UÆ THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(lemma_tac¨X Ä ﬁ{B | B ç U ± ∂ A∑ A ç V ± B Ä A}Æ
	THEN1 PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 3 (fn th => PC_T1 "sets_ext1" all_fc_tac[th]));
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a∑x ç a ± a Ä ‘ ¥ x ç ‘Æ]);
a(DROP_NTH_ASM_T 9 (fn th => all_fc_tac[th]));
a(∂_tac¨BÆ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 5 (fn th => all_fc_tac[th]));
a(lemma_tac¨∂f∑µB∑B ç W ¥ f B ç V ± B Ä f BÆ THEN1 prove_∂_tac);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac THEN cases_tac¨B' ç WÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 4 (fn th => all_fc_tac[pc_rule1 "sets_ext1" once_rewrite_rule[] th]));
a(∂_tac ¨AÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(ante_tac(list_µ_elim[¨fÆ, ¨WÆ] finite_image_thm) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(∂_tac ¨{y|∂ x∑ x ç W ± y = f x}Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (fn th => all_fc_tac[pc_rule1 "sets_ext1" once_rewrite_rule[] th]));
a(∂_tac ¨f sÆ THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.2.2.1" *** *)
a(PC_T1 "sets_ext" asm_prove_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(∂_tac ¨sÆ THEN asm_rewrite_tac[] );
val €compact_basis_thm› = save_pop_thm "compact_basis_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” ‘ X∑ 
	” ç Topology
±	‘ ç Topology
±	X Ä Space (” ∏âT ‘)
±	(µV∑ 	V Ä (” ∏âT ‘)
	±	(µD∑ D ç V ¥ ∂B C∑ B ç ” ± C ç ‘ ± D = (B ∏ C))
	±	X Ä ﬁ V
	¥	∂ W∑ W Ä V ± W ç Finite ± X Ä ﬁ W)
¥	X ç (” ∏âT ‘) Compact
Æ);
a(REPEAT strip_tac THEN bc_thm_tac compact_basis_thm);
a(ALL_FC_T asm_rewrite_tac[product_topology_thm]);
a(∂_tac¨{D | ∂B C∑ B ç ” ± C ç ‘ ± D = (B ∏ C)}Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[product_topology_def] THEN PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(∂_tac¨BÆ THEN ∂_tac¨CÆ THEN asm_rewrite_tac[]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[∏_def]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[product_topology_def] THEN REPEAT strip_tac);
a(POP_ASM_T (ante_tac o list_µ_elim[¨Fst xÆ, ¨Snd xÆ]));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨A' ∏ BÆ THEN REPEAT strip_tac THEN1 asm_rewrite_tac[∏_def]);
a(∂_tac¨A'Æ THEN ∂_tac¨BÆ THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 2 (fn th => ante_tac(pc_rule1 "sets_ext1" once_rewrite_rule[] th)));
a(rewrite_tac[taut_rule¨µp1 p2∑(p1 ¥ p2 ± p1) § p1 ¥ p2Æ]);
a(REPEAT strip_tac THEN PC_T "sets_ext" strip_tac THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
a(rewrite_tac[product_topology_def] THEN REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[∏_def]));
a(∂_tac¨BÆ THEN ∂_tac¨CÆ THEN asm_rewrite_tac[]);
val €compact_basis_product_topology_thm› = save_pop_thm "compact_basis_product_topology_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” ‘ W x Y∑ 
	” ç Topology
±	‘ ç Topology
±	x ç Space ”
±	W ç Finite
±	(µD∑D ç W ¥ ∂B C∑ x ç B ± B ç ” ± C ç ‘ ± D = (B ∏ C))
¥	∂A∑ x ç A ± A ç ” ± µt y∑(x, y) ç ﬁW ± t ç A ¥ (t, y) ç ﬁWÆ);
a(REPEAT strip_tac);
a(lemma_tac¨µV∑ V ç Finite ± V Ä W ¥
	∂A∑ x ç A ± A ç ” ± µt y∑(x, y) ç ﬁV ± t ç A ¥ (t, y) ç ﬁVÆ);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(finite_induction_tac ¨VÆ);
(* *** Goal "1.1" *** *)
a(rewrite_tac[enum_set_clauses]);
a(all_fc_tac[space_open_thm] THEN contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a(LEMMA_T ¨≥{x'} ¿ V Ä WÆ rewrite_thm_tac);
a(GET_NTH_ASM_T 2 ante_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.3" *** *)
a(REPEAT strip_tac);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[] ¨µx a b∑ {x} ¿ a Ä b ¥ x ç bÆ]);
a(LIST_DROP_NTH_ASM_T [8] all_fc_tac);
a(all_var_elim_asm_tac1 THEN rewrite_tac[enum_set_clauses,
	pc_rule1"sets_ext1" prove_rule[]¨µa v∑ﬁ(a ¿ v) = ﬁa ¿ ﬁvÆ]);
a(∂_tac ¨B ° AÆ THEN REPEAT strip_tac);
(* *** Goal "1.3.1" *** *)
a(bc_thm_tac °_open_thm THEN REPEAT strip_tac);
(* *** Goal "1.3.2" *** *)
a(swap_nth_asm_concl_tac 1 THEN LIST_DROP_NTH_ASM_T [3, 4] (MAP_EVERY ante_tac));
a(rewrite_tac[∏_def] THEN prove_tac[]);
(* *** Goal "1.3.3" *** *)
a(LEMMA_T ¨(x, y) ç ﬁVÆ asm_tac THEN1
	(LIST_DROP_NTH_ASM_T [5, 4] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext" prove_tac[]));
a(LIST_DROP_NTH_ASM_T [13] all_fc_tac);
a(contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
val €compact_product_lemma› = save_pop_thm "compact_product_lemma";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µX : 'a SET; Y : 'b SET; ” ‘ ∑ 
	X ç ” Compact
±	Y ç ‘ Compact
±	” ç Topology
±	‘ ç Topology
¥	(X ∏ Y) ç (” ∏âT ‘) CompactÆ);
a(REPEAT strip_tac THEN bc_thm_tac compact_basis_product_topology_thm);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[product_topology_space_thm]);
a(all_asm_ante_tac THEN rewrite_tac[compact_def] THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [4, 6] (MAP_EVERY ante_tac) THEN
	MERGE_PCS_T1 ["'bin_rel", "sets_ext1"] prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac ¨∂W∑µx∑ x ç X ¥
	W x Ä V ± W x ç Finite ± (µy∑y ç Y ¥ (x, y) ç ﬁ(W x)) ±
	µD∑ D ç W x ¥ (∂ B C∑ x ç B ± B ç ” ± C ç ‘ ± D = (B ∏ C))Æ
	THEN1 prove_∂_tac THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(cases_tac ¨x' ç XÆ THEN asm_rewrite_tac[]);
a(lemma_tac ¨x' ç Space ”Æ THEN1
	(LIST_DROP_NTH_ASM_T [1, 8] (MAP_EVERY ante_tac) THEN
	rewrite_tac[compact_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(strip_asm_tac (list_µ_elim[¨”Æ, ¨‘Æ, ¨x'Æ] right_product_inj_continuous_thm));
a(lemma_tac ¨(” ∏âT ‘) ç TopologyÆ THEN1 all_fc_tac[product_topology_thm]);
a(ante_tac (list_µ_elim[¨Ãy:'b∑(x', y)Æ, ¨YÆ, ¨‘Æ, ¨” ∏âT ‘Æ] image_compact_thm));
a(asm_rewrite_tac[compact_def] THEN REPEAT strip_tac);
a(lemma_tac¨x' ç X ¥ {y|∂ x∑ x ç Y ± Fst y = x' ± Snd y = x} Ä (X ∏ Y)Æ
	THEN1 (MERGE_PCS_T1 ["'bin_rel", "sets_ext" ] prove_tac[]
		THEN all_var_elim_asm_tac1));
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b c∑a Ä b ± b Ä c ¥ a Ä cÆ]);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac);
a(POP_ASM_T (PC_T1 "sets_ext1" strip_asm_tac));
a(∂_tac ¨{A | A ç W ± ∂y∑(x', y) ç A}Æ THEN PC_T1 "basic_hol" REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.1.2" *** *)
a(bc_thm_tac Ä_finite_thm THEN ∂_tac ¨WÆ THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.1.3" *** *)
a(lemma_tac¨(x', y) ç ﬁWÆ);
(* *** Goal "2.1.3.1" *** *)
a(DROP_NTH_ASM_T 2 bc_thm_tac THEN REPEAT strip_tac);
a(∂_tac¨yÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.1.3.2" *** *)
a(REPEAT strip_tac);
a(∂_tac¨sÆ THEN asm_rewrite_tac[]);
a(∂_tac¨yÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.1.4" *** *)
a(lemma_tac¨D ç VÆ THEN1 (
	LIST_DROP_NTH_ASM_T [1, 4] (MAP_EVERY ante_tac)
		THEN PC_T1 "sets_ext" prove_tac[]));
a(LIST_DROP_NTH_ASM_T [14] all_fc_tac);
a(∂_tac¨BÆ THEN ∂_tac¨CÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 5 ante_tac THEN all_var_elim_asm_tac1);
a(prove_tac[∏_def]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨X Ä ﬁ{A | A ç ” ±∂x∑x ç X ±  x ç A ± µt y∑t ç A ± y ç Y ¥ (t, y) ç ﬁ(W x)}Æ
	THEN1 PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(lemma_tac ¨x ç Space ”Æ THEN1
	(LIST_DROP_NTH_ASM_T [1, 9] (MAP_EVERY ante_tac) THEN
	rewrite_tac[compact_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(DROP_NTH_ASM_T 3 (strip_asm_tac o µ_elim¨xÆ));
a(all_fc_tac[compact_product_lemma]);
a(∂_tac¨AÆ THEN REPEAT strip_tac);
a(∂_tac¨xÆ THEN PC_T1 "basic_hol" REPEAT strip_tac);
a(PC_T1 "basic_hol" (LIST_DROP_NTH_ASM_T [7])  all_fc_tac);
a(PC_T1 "basic_hol" (LIST_DROP_NTH_ASM_T [4])  all_fc_tac);
(* *** Goal "2.2.2" *** *)
a(lemma_tac¨{A | A ç ” ±∂x∑x ç X ±  x ç A ± µt y∑t ç A ± y ç Y ¥ (t, y) ç ﬁ(W x)} Ä ”Æ
	THEN1 PC_T1 "sets_ext" prove_tac[]);
a(GET_NTH_ASM_T 10 (fn th => all_fc_tac[rewrite_rule[compact_def] th]));
a(LIST_DROP_NTH_ASM_T [4, 5, 7, 8] discard_tac);
a(lemma_tac¨∂U∑µA∑A ç W' ¥ (µ t y∑ t ç A ± y ç Y ¥ (t, y) ç ﬁ (U A)) ± U A Ä V ± U A ç FiniteÆ
	THEN1 prove_∂_tac);
(* *** Goal "2.2.2.1" *** *)
a(REPEAT strip_tac);
a(cases_tac¨A' ç W'Æ THEN asm_rewrite_tac[]);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a b∑x ç a ± a Ä b ¥ x ç bÆ]);
a(∂_tac¨W xÆ THEN  POP_ASM_T ante_tac THEN ALL_ASM_FC_T rewrite_tac[] THEN taut_tac);
(* *** Goal "2.2.2.2" *** *)
a(∂_tac¨ﬁ{y|∂ x∑ x ç W' ± y = U x}Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [3] all_asm_fc_tac);
a(LIST_DROP_NTH_ASM_T [2, 4] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a(ante_tac (list_µ_elim[¨UÆ, ¨W'Æ] finite_image_thm) THEN asm_rewrite_tac[] THEN strip_tac);
a(bc_thm_tac ﬁ_finite_thm THEN REPEAT strip_tac);
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.3" *** *)
a(MERGE_PCS_T1 ["'bin_rel", "sets_ext1"] REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [4] (PC_T1"sets_ext1" all_fc_tac));
a(LIST_DROP_NTH_ASM_T [5] all_fc_tac);
a(∂_tac¨s'Æ THEN REPEAT strip_tac);
a(∂_tac¨U sÆ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
val €product_compact_thm› = save_pop_thm "product_compact_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ V p∑ 
	‘ ç Topology
±	V Ä ‘
±	V ç Finite
±	p ç Space ‘
±	(µA∑ A ç V ¥ ∂B∑ B ç ‘ ± p ç B ± A ° B = {})
¥	∂B∑ B ç ‘ ± p ç B ± B ° ﬁV = {}Æ);
a(REPEAT strip_tac);
a(lemma_tac¨
	∂b∑µA∑A ç V ¥ b A ç ‘ ± p ç b A ± A ° b A = {}
Æ THEN1 prove_∂_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(cases_tac¨≥A' ç VÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 2 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(cases_tac¨ﬁV = {}Æ);
(* *** Goal "2.1" *** *)
a(∂_tac ¨Space ‘Æ THEN ALL_FC_T asm_rewrite_tac[space_open_thm]);
(* *** Goal "2.2" *** *)
a(lemma_tac ¨•{y|∂ x∑ x ç V ± y = b x} ç ‘Æ THEN1 bc_thm_tac finite_•_open_thm);
(* *** Goal "2.2.1" *** *)
a(asm_rewrite_tac[] THEN ALL_FC_T rewrite_tac[finite_image_thm]);
a(REPEAT strip_tac THEN PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
(* *** Goal "2.2.1.1" *** *)
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.1.2" *** *)
a(rewrite_tac[]);
a(cases_tac¨V = {}Æ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(POP_ASM_T (PC_T1 "sets_ext1" strip_asm_tac));
a(∂_tac¨b xÆ THEN ∂_tac¨xÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(∂_tac¨•{y|∂ x∑ x ç V ± y = b x}Æ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.2.2.1" *** *)
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(PC_T "sets_ext1" strip_tac THEN rewrite_tac[°_def, •_def, ﬁ_def]);
a(REPEAT strip_tac);
a(∂_tac¨b sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(∂_tac¨ sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.2" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
val €compact_closed_lemma› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ C∑ 
	‘ ç Topology
±	‘ ç Hausdorff
±	C ç ‘ Compact
¥	C ç ‘ ClosedÆ);
a(REPEAT strip_tac);
a(ALL_FC_T1 fc_§_canon  rewrite_tac[closed_open_neighbourhood_thm]);
a(once_rewrite_tac[prove_rule[]¨µp1 p2∑ p1 ± p2 § p1 ± (p1 ¥ p2)Æ]);
a(REPEAT strip_tac THEN1
	(POP_ASM_T ante_tac THEN prove_tac[compact_def]));
a(lemma_tac¨C Ä ﬁ {A | A ç ‘ ± ∂B∑B ç ‘ ± x ç B ± A ° B = {}}Æ);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[hausdorff_def]));
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(lemma_tac¨x' ç Space ‘Æ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(lemma_tac¨≥x' = xÆ THEN1 (contr_tac THEN all_var_elim_asm_tac1));
a(all_asm_fc_tac[]);
a(∂_tac¨AÆ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[compact_def]));
a(lemma_tac¨{A | A ç ‘ ± ∂B∑B ç ‘ ± x ç B ± A ° B = {}} Ä ‘Æ
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(all_asm_fc_tac[]);
a(lemma_tac¨W Ä ‘Æ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(lemma_tac¨µ A∑ A ç W ¥ (∂ B∑ B ç ‘ ± x ç B ± A ° B = {})Æ);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
a(∂_tac¨BÆ THEN PC_T1 "sets_ext1" asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(all_fc_tac[compact_closed_lemma]);
a(∂_tac¨BÆ THEN  asm_rewrite_tac[]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[] ¨µX∑ C Ä X ± B ° X = {} ¥ B ° C = {}Æ]);
val €compact_closed_thm› = save_pop_thm "compact_closed_thm";
=TEX
\subsection{Connectedness}
%%%%
%%%%
=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
¥	(X ç ‘ Connected § X ç (X ÚâT ‘) Connected)Æ);
a(rewrite_tac[connected_def] THEN PC_T1 "sets_ext1" REPEAT µ_tac THEN ¥_tac);
a(ALL_FC_T1 fc_§_canon rewrite_tac[subspace_topology_space_thm]);
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b∑a Ä a ° b § a Ä bÆ]);
a(rewrite_tac[subspace_topology_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1);
a(lemma_tac¨X Ä B'  ¿ B''Æ THEN1
	(GET_NTH_ASM_T 3 ante_tac THEN  PC_T1 "sets_ext" prove_tac[]));
a(DROP_NTH_ASM_T 3 ante_tac THEN
	rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b c∑a ° (b ° a) ° c ° a = a ° b ° cÆ]);
a(REPEAT strip_tac);
a(lemma_tac¨≥X Ä B' Æ THEN1
	(GET_NTH_ASM_T 3 ante_tac THEN  PC_T1 "sets_ext" prove_tac[]));
a(all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(list_spec_nth_asm_tac 6 [¨B ° XÆ, ¨C ° XÆ]);
(* *** Goal "2.1" *** *)
a(list_spec_nth_asm_tac 1 [¨BÆ]);
(* *** Goal "2.2" *** *)
a(list_spec_nth_asm_tac 1 [¨CÆ]);
(* *** Goal "2.3" *** *)
a(i_contr_tac THEN LIST_DROP_NTH_ASM_T [1, 4] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.4" *** *)
a(i_contr_tac THEN LIST_DROP_NTH_ASM_T [1, 3] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.5" *** *)
a(i_contr_tac THEN LIST_DROP_NTH_ASM_T [1, 2] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.6" *** *)
a(LIST_DROP_NTH_ASM_T [1] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext1" prove_tac[]);
val €connected_topological_thm› = save_pop_thm "connected_topological_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
¥	(	X ç ‘ Connected
	 § 	µx y∑ x ç X ± y ç X ¥ ∂Y∑ Y Ä X ± x ç Y ± y ç Y ± Y ç ‘ Connected)Æ);
a(REPEAT strip_tac THEN1 (∂_tac¨XÆ THEN PC_T1 "sets_ext1" asm_prove_tac[]));
a(POP_ASM_T ante_tac THEN rewrite_tac[connected_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN all_asm_fc_tac[]);
a(LIST_GET_NTH_ASM_T [2, 3, 4] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN PC_T "sets_ext1" contr_tac);
a(list_spec_nth_asm_tac 9 [¨xÆ, ¨x'Æ]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä b ± b Ä c ¥ a Ä cÆ]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä b ± b ° c = {} ¥ a ° c = {}Æ]);
a(list_spec_nth_asm_tac 3 [¨BÆ, ¨CÆ]);
(* *** Goal "2.1" *** *)
a(LIST_GET_NTH_ASM_T [1, 7, 11] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2.2" *** *)
a(LIST_GET_NTH_ASM_T [1, 6, 9] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext" prove_tac[]);
val €connected_pointwise_thm› = save_pop_thm "connected_pointwise_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
± 	(µx y∑ x ç X ± y ç X ¥ ∂Y∑ Y Ä X ± x ç Y ± y ç Y ± Y ç ‘ Connected)
¥	X ç ‘ ConnectedÆ);
a(REPEAT strip_tac THEN ALL_FC_T1 fc_§_canon once_rewrite_tac[connected_pointwise_thm]);
a(POP_ASM_T ante_tac THEN taut_tac);
val €connected_pointwise_bc_thm› = save_pop_thm "connected_pointwise_bc_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘∑ ‘ ç Topology ¥ {} ç ‘ ConnectedÆ);
a(REPEAT strip_tac THEN bc_thm_tac connected_pointwise_bc_thm);
a(asm_rewrite_tac[]);
val €empty_connected_thm› = save_pop_thm "empty_connected_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ x∑ ‘ ç Topology ± x ç Space ‘ ¥ {x} ç ‘ ConnectedÆ);
a(REPEAT strip_tac THEN rewrite_tac[connected_def, enum_set_clauses]);
a(PC_T1 "sets_ext1" prove_tac[]);
val €singleton_connected_thm› = save_pop_thm "singleton_connected_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µC D ”∑ 
	C ç ” Connected
±	D ç ” Connected
±	≥C ° D = {}
±	” ç Topology
¥	C ¿ D ç ” Connected
Æ);
a(rewrite_tac[connected_def] THEN REPEAT strip_tac
	THEN1 all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä c ± b Ä c ¥ a ¿ b Ä cÆ]);
a(DROP_NTH_ASM_T 7 (PC_T1 "sets_ext1" strip_asm_tac) THEN contr_tac);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a ¿ b Ä c ¥ a Ä c ± b Ä cÆ]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑(a ¿ b) ° c = {} ¥ a ° c = {} ± b ° c = {}Æ]);
a(list_spec_nth_asm_tac 16 [¨BÆ, ¨C'Æ] THEN list_spec_nth_asm_tac 15 [¨BÆ, ¨C'Æ]);
(* *** Goal "1" *** *)
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä c ± b Ä c ¥ a ¿ b Ä cÆ]);
(* *** Goal "2" *** *)
a(ante_tac(pc_rule1 "sets_ext1" prove_rule[]
	¨x ç C ± x ç D  ± C Ä B ± D Ä C' ¥ x ç C ° B ° C'Æ));
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(ante_tac(pc_rule1 "sets_ext1" prove_rule[]
	¨x ç C ± x ç D  ± C Ä C' ± D Ä B ¥ x ç C ° B ° C'Æ));
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä c ± b Ä c ¥ a ¿ b Ä cÆ]);
val €¿_connected_thm› = save_pop_thm "¿_connected_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf X ” ‘∑ 
	f ç (”, ‘) Continuous
±	X ç ” Connected
±	” ç Topology
±	‘ ç Topology
¥	{y | ∂x∑ x ç X ± y = f x} ç ‘ Connected
Æ);
a(rewrite_tac[connected_def, continuous_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac );
a(all_var_elim_asm_tac1 THEN PC_T1 "sets_ext1" all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(contr_tac);
a(LIST_DROP_NTH_ASM_T [11] all_fc_tac);
a(GET_NTH_ASM_T 12 (PC_T1 "sets_ext1" strip_asm_tac));
a(lemma_tac¨
	X Ä {x|x ç Space ” ± f x ç B} ¿ {x|x ç Space ” ± f x ç C}
Æ THEN1 (PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac
		THEN_TRY SOLVED_T (all_asm_fc_tac[])));
(* *** Goal "2.1" *** *)
a(swap_nth_asm_concl_tac 9 THEN PC_T "sets_ext1" strip_tac);
a(REPEAT strip_tac THEN ∂_tac¨f xÆ THEN REPEAT strip_tac);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(lemma_tac¨
	X ° {x|x ç Space ” ± f x ç B} ° {x|x ç Space ” ± f x ç C} = {}
Æ THEN1 (PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac));
(* *** Goal "2.2.1" *** *)
a(swap_nth_asm_concl_tac 11 THEN PC_T "sets_ext1" strip_tac);
a(REPEAT strip_tac THEN ∂_tac¨f xÆ);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(LEMMA_T ¨X Ä {x|x ç Space ” ± f x ç B} ≤ X Ä {x|x ç Space ” ± f x ç C}Æ ante_tac);
(* *** Goal "2.2.2.1" *** *)
a(DROP_NTH_ASM_T 14 bc_thm_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(swap_nth_asm_concl_tac 8);
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a(swap_nth_asm_concl_tac 7);
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
val €image_connected_thm› = save_pop_thm "image_connected_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µX : 'a SET; Y : 'b SET; ” ‘ ∑ 
	X ç ” Connected
±	Y ç ‘ Connected
±	” ç Topology
±	‘ ç Topology
¥	(X ∏ Y) ç (” ∏âT ‘) ConnectedÆ);
a(REPEAT strip_tac);
a(lemma_tac ¨(” ∏âT ‘) ç TopologyÆ THEN1 all_fc_tac[product_topology_thm]);
a(ALL_FC_T1 fc_§_canon once_rewrite_tac[connected_pointwise_thm]);
a(REPEAT strip_tac);
a(lemma_tac¨
	(∂H∑ H ç (” ∏âT ‘) Connected ± x ç H ± (Fst y, Snd x) ç H ± H Ä (X ∏ Y))
±	(∂V∑ V ç (” ∏âT ‘) Connected ± y ç V ± (Fst y, Snd x) ç V ± V Ä (X ∏ Y))Æ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨{ab | ∂a∑ a ç X ± ab = (Ãa∑(a, Snd x)) a}Æ THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(bc_thm_tac image_connected_thm);
a(∂_tac¨”Æ THEN REPEAT strip_tac);
a(bc_thm_tac left_product_inj_continuous_thm THEN REPEAT strip_tac);
a(POP_ASM_T discard_tac THEN POP_ASM_T (ante_tac o rewrite_rule[∏_def]));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o rewrite_rule[connected_def]));
a(POP_ASM_T discard_tac THEN POP_ASM_T ante_tac 
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.2" *** *)
a(∂_tac ¨Fst xÆ THEN rewrite_tac[]);
a(POP_ASM_T discard_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[∏_def]));
(* *** Goal "1.3" *** *)
a(∂_tac ¨Fst yÆ THEN rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[∏_def]));
(* *** Goal "1.4" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN rewrite_tac[∏_def] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o rewrite_rule[∏_def]) THEN taut_tac);
(* *** Goal "2" *** *)
a(∂_tac¨{ab | ∂b∑ b ç Y ± ab = (Ãb∑(Fst y, b)) b}Æ THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac image_connected_thm);
a(∂_tac¨‘Æ THEN REPEAT strip_tac);
a(bc_thm_tac right_product_inj_continuous_thm THEN REPEAT strip_tac);
a(POP_ASM_T (ante_tac o rewrite_rule[∏_def]));
a(DROP_NTH_ASM_T 6 (strip_asm_tac o rewrite_rule[connected_def]));
a(POP_ASM_T discard_tac THEN POP_ASM_T ante_tac 
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.2" *** *)
a(∂_tac ¨Snd yÆ THEN rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[∏_def]));
(* *** Goal "2.3" *** *)
a(∂_tac ¨Snd xÆ THEN rewrite_tac[]);
a(POP_ASM_T discard_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[∏_def]));
(* *** Goal "2.4" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN rewrite_tac[∏_def] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[∏_def]) THEN taut_tac);
(* *** Goal "3" *** *)
a(lemma_tac ¨H ¿ V Ä (X ∏ Y)Æ THEN1
	all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä c ± b Ä c ¥ a ¿ b Ä cÆ]);
a(∂_tac¨H ¿ VÆ THEN REPEAT strip_tac);
a(bc_thm_tac ¿_connected_thm);
a(REPEAT strip_tac THEN PC_T "sets_ext1" contr_tac THEN all_asm_fc_tac[]);
val €product_connected_thm› = save_pop_thm "product_connected_thm";
=TEX
\subsection{Examples and Applications}
%%%%
%%%%
=SML
=SML
force_delete_theory"topology_examples" handle Fail _ => ();
open_theory"topology";
new_theory"topology_examples";
new_parent"analysis";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙", "'Ø"];
=TEX
\subsection{The real numbers}
We show that the open sets as defined in [Analysis]  do indeed comprise a topology on
the real line with the expected basic properties. The proofs are very easy, because
most of the work has already been done in [Analysis].
First, the open sets do form a topology:
%%%%
%%%%
=SML
set_goal([], ¨OpenâR ç TopologyÆ);
a(rewrite_tac[topology_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[ﬁ_open_Ø_thm]);
(* *** Goal "2" *** *)
a(all_fc_tac[°_open_Ø_thm]);
val €open_Ø_topology_thm› = save_pop_thm "open_Ø_topology_thm";
=TEX
The underlying set of the topology is the entire real line:
%%%%
%%%%
=SML
set_goal([], ¨Space OpenâR = UniverseÆ);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(bc_thm_tac ç_space_thm);
a(∂_tac¨UniverseÆ THEN rewrite_tac[open_Ø_topology_thm, empty_universe_open_closed_thm]);
val €space_Ø_thm› = save_pop_thm "space_Ø_thm";
=TEX
The definition from [Analysis] of a closed set agrees with the abstract one:
%%%%
%%%%
=SML
set_goal([], ¨OpenâR Closed = ClosedâRÆ);
a(rewrite_tac[closed_def, closed_Ø_def, space_Ø_thm] THEN REPEAT strip_tac);
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[pc_rule1"sets_ext1" prove_rule[complement_clauses]¨µa:'a SET∑~(~a) = aÆ]);
(* *** Goal "2" *** *)
a(∂_tac¨~xÆ THEN
	asm_rewrite_tac[pc_rule1"sets_ext1" prove_rule[complement_clauses]¨µa:'a SET∑~(~a) = aÆ]);
val €closed_closed_Ø_thm› = save_pop_thm "closed_closed_Ø_thm";
=TEX
The definition from [Analysis] of a connected set agrees with the abstract one:
%%%%
%%%%
=SML
set_goal([], ¨OpenâR Compact = CompactâRÆ);
a(rewrite_tac[compact_def, compact_Ø_def, space_Ø_thm] THEN REPEAT strip_tac);
val €compact_compact_Ø_thm› = save_pop_thm "compact_compact_Ø_thm";
=TEX
Finally (amongst the basic properties), functions are continuous in the abstract sense
iff. they are everywhere continuous in the sense of [Analysis].
%%%%
%%%%
=SML
set_goal([], ¨µf∑ f ç (OpenâR, OpenâR) Continuous § µx∑f CtsAt xÆ);
a(rewrite_tac[continuous_def, cts_open_Ø_thm, space_Ø_thm] THEN REPEAT strip_tac);
val €continuous_cts_at_Ø_thm› = save_pop_thm "continuous_cts_at_Ø_thm";
=TEX
With a distant view to doing some algebraic topology, we now look at connectedness,
which was not much studied in [Analysis]. Our intention is to characterise the connected
subsets of the real line. The plan is to use material from this document and from [Analysis]
as appropriate to best effect. We show that the real line as a whole is connected using
the intermediate value theorem, from which we infer that closed intervals are connected
using a continous mapping of the real line onto a closed interval. From this we infer that
a subset of the real line is connected iff. it contains the closed interval lying between
any two of its points, using the pointwise characterisation of connectedness and the
fact that closed intervals are connected.

That the real line is topologically connected is a consequence of the intermediate
value theorem: if the disjoint open sets $B$ and $C$ exhausted the real line,
then the function which is 0 on $B$ and 1 on $C$ would be continuous but
would not take on any real value (e.g., $1/2$) strictly between 0 and 1, contradicting
the intermediate value theorem.
%%%%
%%%%
=SML
set_goal([], ¨Universe ç OpenâR ConnectedÆ);
a(rewrite_tac[connected_def, space_Ø_thm] THEN PC_T1 "sets_ext1" rewrite_tac[]);
a(strip_asm_tac open_Ø_topology_thm THEN contr_tac);
a(lemma_tac¨∂f∑µt∑ f t = if t ç B then ÓØ 0 else ÓØ 1Æ THEN1 prove_∂_tac);
a(lemma_tac¨µt∑f CtsAt tÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[cts_open_Ø_thm] THEN REPEAT strip_tac);
a(cases_tac¨ÓØ 0 ç AÆ THEN cases_tac¨ÓØ 1 ç AÆ);
(* *** Goal "1.1" *** *)
a(LEMMA_T ¨{x | f x ç A} = Space OpenâRÆ rewrite_thm_tac THEN_LIST
	[rewrite_tac[space_Ø_thm], ALL_FC_T rewrite_tac[space_open_thm]]);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN asm_rewrite_tac[]);
a(cases_tac ¨x'' ç BÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(LEMMA_T ¨{x | f x ç A} = BÆ  asm_rewrite_thm_tac);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "1.3" *** *)
a(LEMMA_T ¨{z | f z ç A} = CÆ  asm_rewrite_thm_tac);
a(LEMMA_T¨µt∑t ç B § ≥t ç CÆ asm_rewrite_thm_tac THEN1 asm_prove_tac[]);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "1.4" *** *)
a(LEMMA_T ¨{x | f x ç A} = {}Æ rewrite_thm_tac THEN_LIST
	[PC_T "sets_ext1" contr_tac, ALL_FC_T rewrite_tac[empty_open_thm]]);
a(POP_ASM_T ante_tac THEN spec_nth_asm_tac 8 ¨x''Æ THEN asm_rewrite_tac[]);
a(LEMMA_T¨µt∑t ç B § ≥t ç CÆ asm_rewrite_thm_tac THEN1 asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨µt∑≥f t = 1/2Æ THEN1 (strip_tac THEN cases_tac¨t ç BÆ THEN asm_rewrite_tac[]));
a(lemma_tac¨f x = ÓØ 1Æ THEN1 asm_rewrite_tac[]);
a(lemma_tac¨f x' = ÓØ 0Æ THEN1
	(cases_tac ¨x' ç BÆ THEN asm_rewrite_tac[] THEN asm_prove_tac[]));
a(DROP_NTH_ASM_T 5 discard_tac);
a(lemma_tac¨≥x = x'Æ THEN1  (contr_tac THEN all_var_elim_asm_tac THEN asm_prove_tac[]));
a(strip_asm_tac (list_µ_elim[¨xÆ, ¨x'Æ] Ø_less_cases_thm));
(* *** Goal "2.1" *** *)
a(ante_tac(list_µ_elim[¨fÆ, ¨xÆ, ¨x'Æ] intermediate_value_thm)
	THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨1/2Æ  THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(ante_tac(list_µ_elim[¨fÆ, ¨x'Æ, ¨xÆ] intermediate_value_thm)
	THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨1/2Æ  THEN asm_rewrite_tac[]);
val €universe_Ø_connected_thm› = save_pop_thm "universe_Ø_connected_thm";
=TEX
We can now apply the theorem that continuous images of connected sets are connected
to show that closed intervals are connected, using a useful theorem from [Analysis]
to construct a continuous mapping of the real line onto any given closed interval.
%%%%
%%%%
=SML
set_goal([], ¨µx y∑ x < y ¥ ClosedInterval x y ç OpenâR ConnectedÆ);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨xÆ, ¨yÆ,  ¨Ãt:Ø∑tÆ] cts_extension_thm1));
a(asm_rewrite_tac[id_cts_thm,
	conv_rule(ONCE_MAP_C eq_sym_conv) continuous_cts_at_Ø_thm] THEN strip_tac);
a(strip_asm_tac universe_Ø_connected_thm THEN strip_asm_tac open_Ø_topology_thm);
a(all_fc_tac[image_connected_thm]);
a(POP_ASM_T ante_tac THEN rewrite_tac[]);
a(bc_thm_tac(prove_rule[]¨µx y a∑x = y ¥ x ç a ¥ y ç aÆ));
a(rewrite_tac[closed_interval_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1);
a(cases_tac¨x'' < xÆ THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(cases_tac¨y < x''Æ THEN1 
	(ALL_ASM_FC_T rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨x º x'' ± x'' º yÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_ASM_FC_T asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(cases_tac¨y < x''Æ THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(cases_tac¨x'' < xÆ THEN1 
	(ALL_ASM_FC_T rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨x º x'' ± x'' º yÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_ASM_FC_T asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨x'Æ THEN ALL_ASM_FC_T asm_rewrite_tac[]);
val €closed_interval_connected_thm› = save_pop_thm "closed_interval_connected_thm";
=TEX
We can now characterise the connected subsets of the real line as those
which sets which contain every point lying between any two members.
%%%%
%%%%
=SML
set_goal([], ¨µX∑
		X ç OpenâR Connected
	§	µx y z∑x ç X ± y ç X ± x º z ± z º y ¥ z ç XÆ
);
a(REPEAT_N 3 strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[connected_def, space_Ø_thm, Ø_º_def] THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac THEN contr_tac);
a(strip_asm_tac (µ_elim¨zÆ half_infinite_intervals_open_thm));
a(lemma_tac¨X Ä {t|t < z} ¿ {t | z < t}Æ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a((cases_tac¨x' = zÆ THEN1 all_var_elim_asm_tac) THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(lemma_tac¨X ° {t|t < z} ° {t | z < t} = {}Æ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2" *** *)
a(lemma_tac¨≥X Ä {t|t < z}Æ THEN PC_T "sets_ext1" contr_tac);
(* *** Goal "1.2.2.1" *** *)
a(spec_nth_asm_tac 1 ¨yÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2.2" *** *)
a(lemma_tac¨≥X Ä {t|z < t}Æ THEN PC_T "sets_ext1" contr_tac);
(* *** Goal "1.2.2.2.1" *** *)
a(spec_nth_asm_tac 1 ¨xÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2.2.2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN strip_asm_tac open_Ø_topology_thm);
a(bc_thm_tac connected_pointwise_bc_thm);
a(REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim[¨xÆ, ¨yÆ] Ø_less_cases_thm));
(* *** Goal "2.1" *** *)
a(∂_tac¨ClosedInterval x yÆ);
a(ALL_FC_T rewrite_tac[closed_interval_connected_thm]);
a(PC_T1 "sets_ext1" rewrite_tac[closed_interval_def]);
a(REPEAT strip_tac THEN all_asm_fc_tac[] THEN asm_rewrite_tac[Ø_º_def]);
(* *** Goal "2.2" *** *)
a(∂_tac¨{x}Æ THEN asm_rewrite_tac[enum_set_clauses]);
a(lemma_tac¨y ç Space OpenâRÆ THEN1 rewrite_tac[space_Ø_thm]);
a(ALL_FC_T rewrite_tac[singleton_connected_thm]);
(* *** Goal "2.3" *** *)
a(∂_tac¨ClosedInterval y xÆ);
a(ALL_FC_T rewrite_tac[closed_interval_connected_thm]);
a(PC_T1 "sets_ext1" rewrite_tac[closed_interval_def]);
a(REPEAT strip_tac THEN rename_tac[] THEN all_asm_fc_tac[] THEN asm_rewrite_tac[Ø_º_def]);
val €connected_Ø_thm› = save_pop_thm "connected_Ø_thm";
=TEX
\subsection{Path Connectedness and the Path Groupoid}
Continuing along the way towards the elements of algebraic topology, we now consider
path connectedness. Here is the definition of path connected set.
This differs from the traditional one in taking the path to be a continuous function on
the whole real line and in allowing the end point of the path to be any real number.
This does not make any difference to the underlying concept and is more uniform with
what we plan to do with the path space presently.
=SML
declare_postfix(300, "PathConnected");
πHOLCONST
‹ €$PathConnected› : 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ‘∑ ‘ PathConnected =
‹	{	A
‹	|	A Ä Space ‘
‹	±	µx y∑ x ç A ± y ç A 
‹	¥	∂f t∑  f ç (OpenâR, ‘) Continuous ± (µ t∑ f t ç A) ± f (ÓØ 0) = x ± f t = y}
∞
=SML
val €path_connected_def› = get_spec¨$PathConnectedÆ;
=TEX
Path-connectedness implies connectedness, because a path, as the continuous image of
a connected set is itself connected.
%%%%
%%%%
=SML
set_goal([], ¨µ‘ X∑
	‘ ç Topology
±	X ç ‘ PathConnected
¥	X ç ‘ Connected
Æ);
a(rewrite_tac[path_connected_def] THEN REPEAT strip_tac);
a(bc_thm_tac connected_pointwise_bc_thm THEN REPEAT strip_tac);
a(list_spec_nth_asm_tac 3 [¨xÆ, ¨yÆ]);
a(ante_tac(list_µ_elim[¨fÆ, ¨Universe:Ø SETÆ, ¨OpenâRÆ, ¨‘Æ] image_connected_thm));
a(pure_asm_rewrite_tac[open_Ø_topology_thm, universe_Ø_connected_thm]);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨{y|∂ x∑ y = f x}Æ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1 THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨ÓØ 0Æ THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨tÆ THEN asm_rewrite_tac[]);
val €path_connected_connected_thm› = save_pop_thm "path_connected_connected_thm";
=TEX
We define the path space of a space to be a set of pairs $(f, d)$ where $f$ is a continuous function
from the real line into the space and $d$ is a non-negative real number giving the end-point
of the path, the start-point being taken to be $0$. The function is required to be constant
for $x \le 0$ and $x \ge d$.
This formulation is equivalent to the more common
one where $d$ is fixed equal to $1$ and has the advantage that addition of paths can be defined
so that it is associative and has an identity on the nose rather than just up to homotopy.
For the time being we do not define a topology on the path space (this being a slightly thorny
topic in the literature).
%%%%
%%%%
=SML
πHOLCONST
‹ €PathSpace› : 'a SET SET ≠ ((Ø ≠ 'a) ∏ Ø) SET
˜¸¸¸¸¸¸
‹ µ‘∑ PathSpace ‘ =
‹	{	(f, d)
‹	|	f ç (OpenâR, ‘) Continuous ± ÓØ 0 º d
‹	±	(µt∑ t º ÓØ 0 ¥ f t = f(ÓØ 0))
‹	±	(µt∑ d º t ¥ f t = f d) }
∞
=TEX
Now we define addition of paths:
=SML
declare_infix(300, "+âP");
πHOLCONST
‹ €$+âP› : ((Ø ≠ 'a) ∏ Ø) ≠ ((Ø ≠ 'a) ∏ Ø) ≠ ((Ø ≠ 'a) ∏ Ø)
˜¸¸¸¸¸¸
‹ µf d g e∑ (f, d) +âP (g, e) = ((Ãt∑if t º d then f t else g (t - d)), d + e)
∞
The identity elements of the path space are the constant paths of zero length:
πHOLCONST
‹ €0âP› : 'a ≠ ((Ø ≠ 'a) ∏ Ø)
˜¸¸¸¸¸¸
‹ µx∑ 0âP x = ((Ãt∑ x), ÓØ 0)
∞
=SML
val €path_space_def› = get_spec¨$PathSpaceÆ;
val €path_plus_def› = get_spec¨$+âPÆ;
val €path_0_def› = get_spec¨0âPÆ;
=TEX
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ f d∑
	‘ ç Topology
±	(f, d) ç PathSpace ‘
¥	(f, d) +âP 0âP (f d) = (f, d)
±	0âP (f (ÓØ 0)) +âP (f, d) = (f, d)
Æ);
a(rewrite_tac[path_space_def, path_0_def, path_plus_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(cases_tac¨x º dÆ THEN asm_rewrite_tac[]);
a(lemma_tac¨d º xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "2" *** *)
a(cases_tac¨x º ÓØ 0Æ THEN asm_rewrite_tac[]);
a(ALL_ASM_FC_T rewrite_tac[]);
val €path_plus_0_thm› = save_pop_thm "path_plus_0_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ f d∑
	‘ ç Topology
±	(f, c) ç PathSpace ‘
±	(g, d) ç PathSpace ‘
±	(h, e) ç PathSpace ‘
±	f c = g (ÓØ 0)
±	g d = h(ÓØ 0)
¥	((f, c) +âP (g, d)) +âP (h, e) = (f, c) +âP ((g, d) +âP (h, e))
Æ);
a(rewrite_tac[path_space_def, path_plus_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(cases_tac¨x º cÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a(cases_tac¨x º c + dÆ THEN asm_rewrite_tac[]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(cases_tac¨x º c + dÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.2.1" *** *)
a(cases_tac¨x + ~c º dÆ THEN asm_rewrite_tac[]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2" *** *)
a(cases_tac¨x + ~c º dÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.1" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2.2" *** *)
a(rewrite_tac[Ø_plus_assoc_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[Ø_plus_assoc_thm]);
val €path_plus_assoc_thm› = save_pop_thm "path_plus_assoc_thm";
=TEX
\subsection{Epilogue}
=TEX
=SML
output_theory{out_file="topology.th.doc", theory="topology"};
output_theory{out_file="topology_examples.th.doc", theory="topology_examples"};
=TEX
\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}
\end{document}


