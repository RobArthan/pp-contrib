pp_make_database -f -p hol topology
docsml topology
xpp -file topology.doc -com pp -d topology -i topology &
doctex topology topology.th; texdvi topology
=TEX
\documentclass[10pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\title{Homology of the Plane}
\author{Rob Arthan}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
This {\ProductHOL} script contains definitions and proofs concerning the
basics of point-set topology.
\end{abstract}
\vfill
\newpage
\tableofcontents
\newpage
%%%%
%%%%
%%%%
%%%%
\section{INTRODUCTION}
%%%%
%%%%
%%%%
%%%%
=SML
force_delete_theory"topology" handle Fail _ => ();
open_theory"Ø";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙", "'Ø"];
new_theory"topology";
new_parent"fin_set";
=TEX
%%%%
%%%%
%%%%
%%%%
\section{DEFINITIONS}\label{DEFINITIONS}
=TEX
%%%%
%%%%
=SML
πHOLCONST
‹ €Topology› : 'a SET SET SET
˜¸¸¸¸¸¸
‹ 	Topology =
‹	{‘ | (µV∑ V Ä ‘ ¥ ﬁ V ç ‘) ± (µA B∑A ç ‘ ± B ç ‘ ¥ A ° B ç ‘)}
∞
=TEX
%%%%
%%%%
=SML
πHOLCONST
‹ €$Space› : 'a SET SET ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ‘∑ Space ‘ = ﬁ ‘
∞
=TEX
%%%%
%%%%
=SML
declare_postfix(300, "Closed");
πHOLCONST
‹ €$Closed› : 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ‘∑ ‘ Closed = {A | ∂B∑B ç ‘ ± A = Space ‘ \ B}
∞
=TEX
%%%%
%%%%
=SML
declare_postfix(300, "Continuous");
πHOLCONST
‹ €$Continuous› : ('a SET SET ∏ 'b SET SET) ≠ ('a ≠ 'b) SET
˜¸¸¸¸¸¸
‹ µ” ‘∑	(”, ‘) Continuous =
‹	{f
‹	|	(µx∑ x ç Space ” ¥ f x ç Space ‘)
‹	±	(µA∑ A ç ‘ ¥ {x | x ç Space ” ± f x ç A} ç ”)}
∞
=TEX
%%%%
%%%%
=SML
declare_postfix(300, "Compact");
πHOLCONST
‹ €$Compact› : 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ‘∑ ‘ Compact =
‹	{A | A Ä Space ‘ ± µV∑ V Ä ‘ ± A Ä ﬁ V ¥ ∂W∑ W Ä V ± W ç Finite ± A Ä ﬁ W}
∞
=TEX
%%%%
%%%%
=SML
declare_postfix(300, "Connected");
πHOLCONST
‹ €$Connected› : 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ‘∑ ‘ Connected =
‹	{A | A Ä Space ‘
‹	± µB C∑ B ç ‘ ± C ç ‘ ± A Ä B ¿ C ± A ° B ° C = {} ¥ (A Ä B ≤ A Ä C)}
∞
=TEX
%%%%
%%%%
=SML
declare_infix(240, "ÚâT");
πHOLCONST
‹ €$ÚâT› : 'a SET ≠ 'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µX ‘∑ 	(X ÚâT ‘)
‹ =	{A | ∂B∑ B ç ‘ ± A = B ° X}
∞
=TEX
%%%%
%%%%
=SML
declare_infix(150, "∏âT");
πHOLCONST
‹ €$∏âT› : 'a SET SET ≠ 'b SET SET ≠ ('a ∏ 'b) SET SET
˜¸¸¸¸¸¸
‹ µ” ‘∑ 	(” ∏âT ‘)
‹ =	{C | µ x y∑ (x, y) ç C ¥ ∂A B∑ A ç ” ±  B ç ‘ ± x ç A ± y ç B  ± (A ∏ B) Ä C}
∞
=TEX
%%%%
%%%%
=SML
πHOLCONST
‹ €Hausdorff› : 'a SET SET SET
˜¸¸¸¸¸¸
‹ 	Hausdorff =
‹	{‘ | µx y∑ x ç Space ‘ ± y ç Space ‘ ± ≥x = y
‹	¥	∂A B∑A ç ‘ ± B ç ‘ ± x ç A ± y ç B ± A ° B = {}}
∞
=TEX
%%%%
%%%%
{\HOLindexOff
\include{topology.th}}
=TEX
%%%%
%%%%
\section{THEOREMS AND PROOFS}
=TEX
%%%%
%%%%
\subsection{Lemmas About Finite Sets}
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µ A B C∑  (Insert A B) Ä C § A ç C ± B Ä C
Æ);
a(PC_T1 "sets_ext1" rewrite_tac[insert_def]);
a(prove_tac[]);
val €enum_set_Ä_thm› = save_pop_thm "enum_set_Ä_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	ﬁ{} = {}
±	µ A B∑  ﬁ(Insert A B) = A ¿ (ﬁB)
Æ);
a(REPEAT strip_tac THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(PC_T "sets_ext1" strip_tac);
a(rewrite_tac[ﬁ_def, insert_def, ¿_def]);
a(prove_tac[]);
val €ﬁ_enum_set_clauses› = save_pop_thm "ﬁ_enum_set_clauses";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	•{} = Universe
±	µ A B∑  •(Insert A B) = A ° (•B)
Æ);
a(REPEAT strip_tac THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(PC_T "sets_ext1" strip_tac);
a(rewrite_tac[•_def, insert_def, °_def]);
a(prove_tac[]);
val €•_enum_set_clauses› = save_pop_thm "•_enum_set_clauses";
val €enum_set_clauses› = list_±_intro
	[enum_set_Ä_thm,  ﬁ_enum_set_clauses, •_enum_set_clauses];
=TEX
The following should definitely go in the finite sets theory ASAP. !!! TBD !!!
%%%%
%%%%
=SML
set_goal([], ¨µA B∑
	 (A ¿ B) ç Finite § A ç Finite ± B ç Finite
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac ¨A Ä A ¿ BÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
(* *** Goal "2" *** *)
a(lemma_tac ¨B Ä A ¿ BÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨BÆ, ¨BÆ));
a(finite_induction_tac ¨AÆ THEN1 asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(LEMMA_T¨({x} ¿ A) ¿ B = {x} ¿ A ¿ BÆ
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(bc_thm_tac singleton_¿_finite_thm THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
val €¿_finite_thm› = save_pop_thm "¿_finite_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µV∑
	 V  ç Finite ± V Ä Finite ¥ ﬁV ç Finite
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µW∑ W ç Finite ± W Ä V ¥ ﬁW ç FiniteÆ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(finite_induction_tac¨WÆ);
(* *** Goal "1.1" *** *)
a(rewrite_tac[enum_set_clauses, empty_finite_thm]);
(* *** Goal "1.2" *** *)
a(LEMMA_T¨≥{x} ¿ W Ä VÆ rewrite_thm_tac);
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "1.3" *** *)
a(REPEAT strip_tac THEN
	rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa v∑ﬁ(a ¿ v) = ﬁa ¿ ﬁvÆ,
		enum_set_clauses]);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a b c∑{x} ¿ a Ä b ± b Ä c ¥ x ç cÆ]);
a(asm_rewrite_tac[¿_finite_thm]);
(* *** Goal "2" *** *)
a(POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
val €ﬁ_finite_thm› = save_pop_thm "ﬁ_finite_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ f : 'a ≠ 'b; A : 'a SET∑
	 A ç Finite ¥ {y | ∂x∑x ç A ± y = f x} ç Finite
Æ);
a(REPEAT strip_tac);
a(finite_induction_tac ¨AÆ THEN1 rewrite_tac[]);
(* *** Goal "1" *** *)
a(LEMMA_T¨{y:'b|F} = {}Æ (fn th => rewrite_tac[th, empty_finite_thm])
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨{y|∂ x'∑ x' ç {x} ¿ A ± y = f x'} = {f x} ¿ {y|∂ x'∑ x' ç A ± y = f x'}Æ
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(bc_thm_tac singleton_¿_finite_thm THEN REPEAT strip_tac);
val €finite_image_thm› = save_pop_thm "finite_image_thm";
=TEX
=TEX
%%%%
%%%%
\subsection{The Definitions}
=SML
val €topology_def› = get_spec¨$TopologyÆ;
val €space_def› = get_spec¨$SpaceÆ;
val €closed_def› = get_spec¨$ClosedÆ;
val €continuous_def› = get_spec¨$ContinuousÆ;
val €connected_def› = get_spec¨$ConnectedÆ;
val €compact_def› = get_spec¨$CompactÆ;
val €subspace_topology_def› = get_spec¨$ÚâTÆ;
val €product_topology_def› = get_spec¨$∏âTÆ;
val €hausdorff_def› = get_spec¨HausdorffÆ;
=TEX
\subsection{ProofPower Generalisation and Instantiation}
=SML
fun arb_gen (thm : THM) : THM = (
	let	val ty_map = map
			(fn tv => (mk_vartype("@_" ^ tv), mk_vartype tv))
			(term_tyvars(concl thm));
		val thm1 = asm_inst_type_rule ty_map thm;
	in	all_µ_intro (all_µ_arb_elim thm1)
	end
);
=TEX
\subsection{Elementary Properties of Open and Closed Sets}
%%%%
%%%%
=SML
set_goal([], ¨µ‘ : 'a SET SET ∑ ‘ ç Topology ¥ {} ç ‘Æ);
a(rewrite_tac[topology_def] THEN REPEAT strip_tac);
a(SPEC_NTH_ASM_T 2 ¨{}: 'a SET SETÆ ante_tac);
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨ﬁ{} = {}Æ]);
val €empty_open_thm› = save_pop_thm "empty_open_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ : 'a SET SET ∑ ‘ ç Topology ¥ Space ‘ ç ‘Æ);
a(rewrite_tac[topology_def, space_def] THEN REPEAT strip_tac);
a(SPEC_NTH_ASM_T 2 ¨‘: 'a SET SETÆ ante_tac);
a(rewrite_tac[]);
val €space_open_thm› = save_pop_thm "space_open_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ : 'a SET SET ∑ ‘ ç Topology ¥ {} ç ‘ ClosedÆ);
a(rewrite_tac[closed_def] THEN REPEAT strip_tac);
a(all_fc_tac[space_open_thm]);
a(∂_tac¨Space ‘Æ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" prove_tac[]);
val €empty_closed_thm› = save_pop_thm "empty_closed_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ : 'a SET SET ∑ ‘ ç Topology ¥ Space ‘ ç ‘ ClosedÆ);
a(rewrite_tac[closed_def] THEN REPEAT strip_tac);
a(all_fc_tac[empty_open_thm]);
a(∂_tac¨{} : 'a SETÆ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" prove_tac[]);
val €space_closed_thm› = save_pop_thm "space_closed_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ A ∑
	‘ ç Topology ¥
	(A ç ‘ § µx∑x ç A ¥ ∂B∑ B ç ‘ ± x ç B ± B Ä A)Æ);
a(rewrite_tac[topology_def, space_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨AÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨A = ﬁ{B | B ç ‘ ± B Ä A}Æ);
(* *** Goal "2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN
	contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(POP_ASM_T once_rewrite_thm_tac THEN DROP_NTH_ASM_T 3 bc_thm_tac);
a(PC_T1 "sets_ext1" prove_tac[]);
val €open_open_neighbourhood_thm› = save_pop_thm "open_open_neighbourhood_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ A ∑
	‘ ç Topology ¥
	(	A ç ‘ Closed
	§ 	A Ä Space ‘
	±	µx∑x ç Space ‘  ± ≥x ç A ¥ ∂B∑ B ç ‘ ± x ç B ± B ° A = {})Æ);
a(rewrite_tac[closed_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨x ç BÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[open_open_neighbourhood_thm]);
a(∂_tac¨B'Æ THEN PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(FC_T1 fc_§_canon once_rewrite_tac [open_open_neighbourhood_thm]);
a(∂_tac¨Space ‘ \ AÆ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(all_asm_fc_tac[]);
a(∂_tac¨BÆ THEN PC_T1 "sets_ext1" asm_rewrite_tac[]);
a(rewrite_tac[space_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "3.1.1" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "3.1.2" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac) THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "3.2" *** *)
a(LIST_GET_NTH_ASM_T [1, 3] (MAP_EVERY ante_tac)  THEN PC_T1 "sets_ext1" prove_tac[]);
val €closed_open_neighbourhood_thm› = save_pop_thm "closed_open_neighbourhood_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ x A ∑
	‘ ç Topology ± x ç A ± A ç ‘ ¥ x ç Space ‘
Æ);
a(rewrite_tac[topology_def, space_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €ç_space_thm› = save_pop_thm "ç_space_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ A B ∑
	‘ ç Topology ± A ç ‘ ± B ç ‘ ¥ A ¿ B ç ‘
Æ);
a(rewrite_tac[topology_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(SPEC_NTH_ASM_T 4 ¨{A; B}Æ (strip_asm_tac o rewrite_rule[enum_set_clauses]));
val €¿_open_thm› = save_pop_thm "¿_open_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ A B ∑
	‘ ç Topology ± A ç ‘ ± B ç ‘ ¥ A ° B ç ‘
Æ);
a(rewrite_tac[topology_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €°_open_thm› = save_pop_thm "°_open_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ V∑ 
	‘ ç Topology ± V Ä ‘ ± ≥V = {} ± V ç Finite
¥	•V ç ‘Æ);
a(rewrite_tac[topology_def] THEN REPEAT strip_tac);
a(POP_ASM_T (fn th => POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN asm_tac th));
a(finite_induction_tac¨VÆ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(all_var_elim_asm_tac1 THEN rewrite_tac[]);
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µx y∑{x} Ä y § x ç yÆ]);
a(LEMMA_T¨•{x} = xÆ (fn th => rewrite_tac [th] THEN taut_tac));
(* *** Goal "3" *** *)
a(PC_T"sets_ext1" strip_tac THEN rewrite_tac[•_def] THEN prove_tac[]);
(* *** Goal "4" *** *)
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µx y z∑{x} ¿ z Ä y § x ç y ± z Ä yÆ]);
a(LEMMA_T¨•({x} ¿ V) = x ° •VÆ rewrite_thm_tac);
(* *** Goal "4.1" *** *)
a(PC_T"sets_ext1" strip_tac THEN rewrite_tac[•_def, °_def, ¿_def] THEN prove_tac[]);
(* *** Goal "4.2" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
val €finite_•_open_thm› = save_pop_thm "finite_•_open_thm";
=TEX
\subsection{Constructing New Topologies from Old}
%%%%
%%%%
=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
¥	(X ÚâT ‘) ç TopologyÆ);
a(rewrite_tac[topology_def, subspace_topology_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_ante_tac THEN1 PC_T1 "sets_ext1" REPEAT strip_tac);
a(∂_tac ¨ﬁ{C| C ç ‘ ± C ° X ç V}Æ  THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "1.1" *** *)
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.2" *** *)
a(PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.2.1" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
a(∂_tac ¨BÆ  THEN REPEAT strip_tac);
(* *** Goal "1.2.2" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
(* *** Goal "1.2.3" *** *)
a(∂_tac ¨s ° XÆ  THEN PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(∂_tac ¨B' ° B''Æ   THEN PC_T1 "sets_ext1" asm_prove_tac[]);
val €subspace_topology_thm› = save_pop_thm "subspace_topology_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ A∑ 
	‘ ç Topology
¥	Space (A ÚâT ‘) = A ° Space ‘Æ);
a(rewrite_tac[topology_def, space_def, subspace_topology_def] THEN 
	PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(∂_tac ¨BÆ  THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(∂_tac ¨s ° AÆ  THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(∂_tac ¨s Æ  THEN REPEAT strip_tac);
val €subspace_topology_space_thm› = save_pop_thm "subspace_topology_space_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET∑ 
	” ç Topology
±	‘ ç Topology
¥	(” ∏âT ‘) ç TopologyÆ);
a(rewrite_tac[topology_def, product_topology_def]
	THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LIST_DROP_NTH_ASM_T  [3] all_fc_tac);
a(∂_tac¨AÆ  THEN ∂_tac ¨BÆ THEN REPEAT strip_tac);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx y z∑x Ä y ± y ç z ¥ x Ä ﬁ zÆ]);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T  [3, 4] all_fc_tac);
a(∂_tac¨A' ° A''Æ  THEN ∂_tac ¨B' ° B''Æ THEN REPEAT strip_tac
	THEN_TRY SOLVED_T (all_asm_fc_tac[]));
a(MERGE_PCS_T1["'bin_rel", "sets_ext1"] asm_prove_tac[]);
val €product_topology_thm› = save_pop_thm "product_topology_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET∑ 
	” ç Topology
±	‘ ç Topology
¥	Space  (” ∏âT ‘)  = (Space ” ∏ Space ‘)Æ);
a(rewrite_tac[product_topology_def, space_def]);
a(MERGE_PCS_T1["'bin_rel", "sets_ext1"] prove_tac[]);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[] THEN contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨s ∏ s'Æ THEN MERGE_PCS_T1["'bin_rel", "sets_ext1"] REPEAT strip_tac);
a(∂_tac¨sÆ THEN ∂_tac¨s'Æ THEN MERGE_PCS_T1["'bin_rel", "sets_ext1"] REPEAT strip_tac);
val €product_topology_space_thm› = save_pop_thm "product_topology_space_thm";
=TEX
\subsection{Continuity}
%%%%
%%%%
=SML
set_goal([], ¨µ” ‘ c∑ 
	” ç Topology
±	‘ ç Topology
±	c ç Space ‘
¥	(Ãx∑ c) ç (”, ‘) Continuous
Æ);
a(REPEAT strip_tac);
a(rewrite_tac[continuous_def, topology_def] THEN 
	PC_T1 "sets_ext1" REPEAT strip_tac);
a(cases_tac¨c ç AÆ THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(rewrite_tac[pc_rule1"sets_ext" prove_rule[]¨{x | x ç Space ”} = Space ”Æ]);
a(all_asm_fc_tac[space_open_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[pc_rule1"sets_ext" prove_rule[]¨{x | F} = {}Æ]);
a(all_asm_fc_tac[empty_open_thm]);
val €const_continuous_thm› = save_pop_thm "const_continuous_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘∑ 
	‘ ç Topology
¥	(Ãx∑ x) ç (‘, ‘) Continuous
Æ);
a(rewrite_tac[continuous_def, topology_def, space_def] THEN 
	PC_T1 "sets_ext1" REPEAT strip_tac);
a(LEMMA_T ¨ {x|x ç ﬁ ‘ ± x ç A} = AÆ  asm_rewrite_thm_tac);
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext1"  prove_tac[]);
val €id_continuous_thm› = save_pop_thm "id_continuous_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g “ ” ‘∑ 
	f ç (“, ”) Continuous
±	g ç (”, ‘) Continuous
±	“ ç Topology
±	” ç Topology
±	‘ ç Topology
±	f ç (“, ”) Continuous
±	g ç (”, ‘) Continuous
¥	(Ãx∑ g(f x)) ç (“, ‘) Continuous
Æ);
a(rewrite_tac[continuous_def] THEN REPEAT strip_tac THEN
	(all_asm_fc_tac[] THEN all_asm_fc_tac[]));
a( LEMMA_T ¨{x|x ç Space “ ± g (f x) ç A} ={x|x ç Space “ ± f x ç {x|x ç Space ” ± g x ç A}}Æ
	once_rewrite_thm_tac THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" prove_tac[] THEN all_asm_fc_tac[]);
val €comp_continuous_thm› = save_pop_thm "comp_continuous_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET∑ 
	” ç Topology
±	‘ ç Topology
¥	(Ã(x, y)∑ x) ç ((” ∏âT ‘), ”) Continuous
Æ);
a(REPEAT strip_tac THEN rewrite_tac[continuous_def]);
a(all_fc_tac[arb_gen product_topology_thm]);
a(ALL_FC_T rewrite_tac [arb_gen product_topology_space_thm]);
a(rewrite_tac[product_topology_def, ∏_def] THEN REPEAT strip_tac);
a(∂_tac¨AÆ THEN ∂_tac¨Space ‘Æ THEN 
	ALL_FC_T asm_rewrite_tac[space_open_thm]);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(all_fc_tac[ç_space_thm]);
val €left_proj_continuous_thm› = save_pop_thm "left_proj_continuous_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET∑ 
	” ç Topology
±	‘ ç Topology
¥	(Ã(x, y)∑ y) ç ((” ∏âT ‘), ‘) Continuous
Æ);
a(REPEAT strip_tac THEN rewrite_tac[continuous_def]);
a(all_fc_tac[arb_gen product_topology_thm]);
a(ALL_FC_T rewrite_tac [arb_gen product_topology_space_thm]);
a(rewrite_tac[product_topology_def, ∏_def] THEN REPEAT strip_tac);
a(∂_tac¨Space ”Æ THEN ∂_tac¨AÆ THEN 
	ALL_FC_T asm_rewrite_tac[space_open_thm]);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(all_fc_tac[ç_space_thm]);
val €right_proj_continuous_thm› = save_pop_thm "right_proj_continuous_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ f : 'a ≠ 'b; g : 'a ≠ 'c; “ : 'a SET SET; ” : 'b SET SET; ‘ : 'c SET SET∑ 
	f ç (“, ”) Continuous
±	g ç (“, ‘) Continuous
±	“ ç Topology
±	” ç Topology
±	‘ ç Topology
±	f ç (“, ”) Continuous
±	g ç (“, ‘) Continuous
¥	(Ãz∑(f z, g z)) ç (“, (” ∏âT ‘)) Continuous
Æ);
a(REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [4, 5] (MAP_EVERY ante_tac));
a(rewrite_tac[continuous_def]);
a(all_fc_tac[arb_gen product_topology_thm]);
a(ALL_FC_T rewrite_tac [arb_gen product_topology_space_thm]);
a(rewrite_tac[product_topology_def, ∏_def] THEN REPEAT strip_tac
	THEN_TRY (SOLVED_T (all_asm_fc_tac[])));
a(LIST_DROP_NTH_ASM_T (interval 6 16) discard_tac
	THEN ALL_FC_T1 fc_§_canon once_rewrite_tac[open_open_neighbourhood_thm]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(LIST_DROP_NTH_ASM_T [11, 13] all_fc_tac);
a(∂_tac¨{x|x ç Space “ ± g x ç B} ° {x|x ç Space “ ± f x ç A'}Æ);
a(ALL_FC_T rewrite_tac[°_open_thm]);
a(REPEAT strip_tac THEN PC_T1"sets_ext1" REPEAT strip_tac);
a(bc_thm_tac (pc_rule1"sets_ext" prove_rule[]¨µa xy∑xy ç a ± a Ä A ¥ xy ç AÆ));
a(∂_tac¨{(v, w)|v ç A' ± w ç B}Æ THEN REPEAT strip_tac);
val €product_map_continuous_thm› = save_pop_thm "product_map_continuous_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” : 'a SET SET; ‘ : 'b SET SET; y : 'b∑ 
	” ç Topology
±	‘ ç Topology
±	y ç Space ‘
¥	(Ãx∑ (x, y)) ç (”, ” ∏âT ‘) Continuous
Æ);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨Ãx:'a∑ xÆ, ¨Ãx:'a∑yÆ, ¨”Æ, ¨”Æ, ¨‘Æ] product_map_continuous_thm));
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm, const_continuous_thm]);
val €left_product_inj_continuous_thm› = save_pop_thm "left_product_inj_continuous_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ”: 'a SET SET; ‘ : 'b SET SET; x : 'a∑ 
	” ç Topology
±	‘ ç Topology
±	x ç Space ”
¥	(Ãy∑ (x, y)) ç (‘, ” ∏âT ‘) Continuous
Æ);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨Ãy:'b∑ xÆ, ¨Ãy:'b∑yÆ, ¨‘Æ, ¨”Æ, ¨‘Æ] product_map_continuous_thm));
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm, arb_gen const_continuous_thm]);
val €right_product_inj_continuous_thm› = save_pop_thm "right_product_inj_continuous_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ ‘ : 'a SET SET∑ 
	‘ ç Topology
¥	(Ãx∑ (x, x)) ç (‘, ‘ ∏âT ‘) Continuous
Æ);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨Ãx:'a∑ xÆ, ¨Ãx:'a∑xÆ, ¨‘Æ, ¨‘Æ, ¨‘Æ] product_map_continuous_thm));
a(ALL_FC_T asm_rewrite_tac[id_continuous_thm, arb_gen const_continuous_thm]);
val €diag_inj_continuous_thm› = save_pop_thm "diag_inj_continuous_thm";
=TEX
\subsection{Compactness}
%%%%
%%%%
%%%%
%%%%
=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
¥	(X ç ‘ Compact § X ç (X ÚâT ‘) Compact)Æ);
a(rewrite_tac[compact_def] THEN PC_T1 "sets_ext1" REPEAT µ_tac THEN ¥_tac);
a(ALL_FC_T1 fc_§_canon rewrite_tac[subspace_topology_space_thm]);
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b∑a Ä a ° b § a Ä bÆ]);
a(rewrite_tac[subspace_topology_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨X Ä ﬁ{B | B ç ‘ ± B ° X ç V} Æ THEN1 PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(LIST_GET_NTH_ASM_T [1, 2, 3] (PC_T1 "sets_ext1" (MAP_EVERY strip_asm_tac)));
a(all_asm_fc_tac[]);
a(LIST_GET_NTH_ASM_T [3] all_fc_tac THEN all_var_elim_asm_tac1);
a(∂_tac¨BÆ THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(lemma_tac¨{B | B ç ‘ ± B ° X ç V} Ä ‘Æ THEN1 PC_T1 "sets_ext" prove_tac[]);
a(all_asm_fc_tac[]);
a(ante_tac(list_µ_elim[¨ÃB∑B ° XÆ, ¨WÆ]finite_image_thm));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac ¨{C|∂ B∑ B ç W ± C = B ° X}Æ THEN REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(PC_T "sets_ext1"  strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(LIST_GET_NTH_ASM_T [5] (PC_T1 "sets_ext1" all_fc_tac));
(* *** Goal "1.2.2" *** *)
a(PC_T "sets_ext1"  strip_tac THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [3] (PC_T1 "sets_ext1" all_fc_tac));
a(∂_tac¨s ° XÆ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(lemma_tac¨X Ä ﬁ{C | ∂B∑ B ç V ± C = B ° X} Æ THEN1 PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(LIST_GET_NTH_ASM_T [2] (PC_T1 "sets_ext1" all_fc_tac));
a(∂_tac¨s ° XÆ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(lemma_tac¨{C | ∂B∑ B ç V ± C = B ° X} Ä {A|∂ B∑ B ç ‘ ± A = B ° X}Æ
	THEN1 (PC_T "sets_ext" strip_tac THEN REPEAT strip_tac));
(* *** Goal "2.2.1" *** *)
a(all_var_elim_asm_tac1 THEN ∂_tac ¨BÆ THEN 
	REPEAT strip_tac THEN PC_T1 "sets_ext1" all_asm_fc_tac[]);
(* *** Goal "2.2.2" *** *)
a(all_asm_fc_tac[]);
a(lemma_tac¨∂f∑µC∑ C ç W ¥ f C ç V ± C = f C ° XÆ THEN1 prove_∂_tac);
(* *** Goal "2.2.2.1" *** *)
a(REPEAT strip_tac);
a(cases_tac¨≥C' ç WÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 4 (PC_T1 "sets_ext1" strip_asm_tac));
a(LIST_DROP_NTH_ASM_T [1] all_fc_tac);
a(all_var_elim_asm_tac1 THEN ∂_tac¨BÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2" *** *)
a(strip_asm_tac(list_µ_elim[¨fÆ, ¨WÆ]finite_image_thm));
a(∂_tac¨{y|∂ x∑ x ç W ± y = f x}Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(PC_T "sets_ext1"  strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a(PC_T "sets_ext1"  strip_tac THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (PC_T1 "sets_ext1" strip_asm_tac));
a(LIST_DROP_NTH_ASM_T [1] all_fc_tac);
a(∂_tac¨f sÆ THEN asm_rewrite_tac[]);
a(LIST_DROP_NTH_ASM_T [5] all_fc_tac);
a(DROP_NTH_ASM_T 4 ante_tac);
a(POP_ASM_T (fn th => conv_tac(LEFT_C(once_rewrite_conv[th]))));
a(REPEAT strip_tac THEN rename_tac[]);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
val €compact_topological_thm› = save_pop_thm "compact_topological_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf C ” ‘∑ 
	f ç (”, ‘) Continuous
±	C ç ” Compact
±	” ç Topology
±	‘ ç Topology
¥	{y | ∂x∑ x ç C ± y = f x} ç ‘ Compact
Æ);
a(rewrite_tac[compact_def, continuous_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac );
a(all_var_elim_asm_tac1 THEN PC_T1 "sets_ext1" all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨{A | ∂B∑ B ç V ± A = {x|x ç Space ” ± f x ç B}} Ä ”Æ);
(* *** Goal "2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN GET_NTH_ASM_T 8 bc_thm_tac);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a b∑x ç a ± a Ä b ¥ x ç bÆ]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨C Ä ﬁ{A | ∂B∑ B ç V ± A = {x|x ç Space ” ± f x ç B}}Æ);
(* *** Goal "2.2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(LEMMA_T¨f x ç {y|∂ x∑ x ç C ± y = f x}Æ  asm_tac THEN1
	(REPEAT strip_tac THEN ∂_tac¨xÆ THEN REPEAT strip_tac));
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a b∑x ç a ± a Ä b ¥ x ç bÆ]);
a(∂_tac¨{x|x ç Space ” ± f x ç s}Æ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(all_asm_fc_tac[]);
a(lemma_tac¨∂h∑µA∑ A ç W ¥ h A ç V ± A = {x | x ç Space ” ± f x ç h A}Æ
	THEN1 prove_∂_tac THEN REPEAT strip_tac);
 (* *** Goal "2.2.2.1" *** *)
a(cases_tac ¨A' ç WÆ  THEN asm_rewrite_tac[]);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a b∑x ç a ± a Ä b ¥ x ç bÆ]);
a(∂_tac¨BÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2" *** *)
a(strip_asm_tac (list_µ_elim[¨hÆ, ¨WÆ] finite_image_thm));
a(∂_tac¨{y|∂ x∑ x ç W ± y = h x}Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 7 discard_tac);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µb∑x' ç C ± C Ä b ¥ x' ç bÆ]);
a(∂_tac¨h sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.2.1" *** *)
a(all_asm_fc_tac[]);
a(POP_ASM_T (fn th => DROP_NTH_ASM_T 5 (ante_tac o once_rewrite_rule[th])));
a(REPEAT strip_tac);
(* *** Goal "2.2.2.2.2.2" *** *)
a(∂_tac¨sÆ THEN REPEAT strip_tac);
val €image_compact_thm› = save_pop_thm "image_compact_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µC D ”∑ 
	C ç ” Compact
±	D ç ” Compact
±	” ç Topology
¥	C ¿ D ç ” Compact
Æ);
a(rewrite_tac[compact_def] THEN REPEAT strip_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b c∑a ¿ b Ä c ¥ a Ä c ± b Ä cÆ]);
a(all_asm_fc_tac[]);
a(∂_tac ¨W ¿ W'Æ THEN
	rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b∑ﬁ(a ¿ b) = ﬁa ¿ ﬁbÆ]
	THEN ALL_FC_T rewrite_tac[
	pc_rule1"sets_ext1" prove_rule[]¨µa b c∑a Ä c ± b Ä c ¥ a ¿ b Ä cÆ,
	pc_rule1"sets_ext1" prove_rule[]¨µa b c d∑a Ä c ± b Ä d ¥ a ¿ b Ä d ¿ cÆ,
	conv_rule(ONCE_MAP_C eq_sym_conv) ¿_finite_thm]);
val €¿_compact_thm› = save_pop_thm "¿_compact_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µU ‘ X∑ 
	‘ ç Topology
±	U Ä ‘
±	(µA∑µx∑ x ç A ± A ç ‘ ¥ ∂B∑ x ç B ± B Ä A ± B ç U)
±	X Ä Space ‘
±	(µV∑ V Ä U ± X Ä ﬁ V ¥ ∂ W∑ W Ä V ± W ç Finite ± X Ä ﬁ W)
¥	X ç ‘ Compact
Æ);
a(rewrite_tac[compact_def] THEN REPEAT strip_tac);
a(lemma_tac¨{B | B ç U ± ∂ A∑ A ç V ± B Ä A} Ä UÆ THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(lemma_tac¨X Ä ﬁ{B | B ç U ± ∂ A∑ A ç V ± B Ä A}Æ
	THEN1 PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 3 (fn th => PC_T1 "sets_ext1" all_fc_tac[th]));
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µx a∑x ç a ± a Ä ‘ ¥ x ç ‘Æ]);
a(DROP_NTH_ASM_T 9 (fn th => all_fc_tac[th]));
a(∂_tac¨BÆ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 5 (fn th => all_fc_tac[th]));
a(lemma_tac¨∂f∑µB∑B ç W ¥ f B ç V ± B Ä f BÆ THEN1 prove_∂_tac);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac THEN cases_tac¨B' ç WÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 4 (fn th => all_fc_tac[pc_rule1 "sets_ext1" once_rewrite_rule[] th]));
a(∂_tac ¨AÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(ante_tac(list_µ_elim[¨fÆ, ¨WÆ] finite_image_thm) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(∂_tac ¨{y|∂ x∑ x ç W ± y = f x}Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (fn th => all_fc_tac[pc_rule1 "sets_ext1" once_rewrite_rule[] th]));
a(∂_tac ¨f sÆ THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.2.2.1" *** *)
a(PC_T1 "sets_ext" asm_prove_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(∂_tac ¨sÆ THEN asm_rewrite_tac[] );
val €compact_basis_thm› = save_pop_thm "compact_basis_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” ‘ X∑ 
	” ç Topology
±	‘ ç Topology
±	X Ä Space (” ∏âT ‘)
±	(µV∑ 	V Ä (” ∏âT ‘)
	±	(µD∑ D ç V ¥ ∂B C∑ B ç ” ± C ç ‘ ± D = (B ∏ C))
	±	X Ä ﬁ V
	¥	∂ W∑ W Ä V ± W ç Finite ± X Ä ﬁ W)
¥	X ç (” ∏âT ‘) Compact
Æ);
a(REPEAT strip_tac THEN bc_thm_tac compact_basis_thm);
a(ALL_FC_T asm_rewrite_tac[product_topology_thm]);
a(∂_tac¨{D | ∂B C∑ B ç ” ± C ç ‘ ± D = (B ∏ C)}Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[product_topology_def] THEN PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(∂_tac¨BÆ THEN ∂_tac¨CÆ THEN asm_rewrite_tac[]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[∏_def]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[product_topology_def] THEN REPEAT strip_tac);
a(POP_ASM_T (ante_tac o list_µ_elim[¨Fst xÆ, ¨Snd xÆ]));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨A' ∏ BÆ THEN REPEAT strip_tac THEN1 asm_rewrite_tac[∏_def]);
a(∂_tac¨A'Æ THEN ∂_tac¨BÆ THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 2 (fn th => ante_tac(pc_rule1 "sets_ext1" once_rewrite_rule[] th)));
a(rewrite_tac[taut_rule¨µp1 p2∑(p1 ¥ p2 ± p1) § p1 ¥ p2Æ]);
a(REPEAT strip_tac THEN PC_T "sets_ext" strip_tac THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
a(rewrite_tac[product_topology_def] THEN REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[∏_def]));
a(∂_tac¨BÆ THEN ∂_tac¨CÆ THEN asm_rewrite_tac[]);
val €compact_basis_product_topology_thm› = save_pop_thm "compact_basis_product_topology_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ” ‘ W x Y∑ 
	” ç Topology
±	‘ ç Topology
±	x ç Space ”
±	W ç Finite
±	(µD∑D ç W ¥ ∂B C∑ x ç B ± B ç ” ± C ç ‘ ± D = (B ∏ C))
¥	∂A∑ x ç A ± A ç ” ± µt y∑(x, y) ç ﬁW ± t ç A ¥ (t, y) ç ﬁWÆ);
a(REPEAT strip_tac);
a(lemma_tac¨µV∑ V ç Finite ± V Ä W ¥
	∂A∑ x ç A ± A ç ” ± µt y∑(x, y) ç ﬁV ± t ç A ¥ (t, y) ç ﬁVÆ);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(finite_induction_tac ¨VÆ);
(* *** Goal "1.1" *** *)
a(rewrite_tac[enum_set_clauses]);
a(all_fc_tac[space_open_thm] THEN contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a(LEMMA_T ¨≥{x'} ¿ V Ä WÆ rewrite_thm_tac);
a(GET_NTH_ASM_T 2 ante_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.3" *** *)
a(REPEAT strip_tac);
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[] ¨µx a b∑ {x} ¿ a Ä b ¥ x ç bÆ]);
a(LIST_DROP_NTH_ASM_T [8] all_fc_tac);
a(all_var_elim_asm_tac1 THEN rewrite_tac[enum_set_clauses,
	pc_rule1"sets_ext1" prove_rule[]¨µa v∑ﬁ(a ¿ v) = ﬁa ¿ ﬁvÆ]);
a(∂_tac ¨B ° AÆ THEN REPEAT strip_tac);
(* *** Goal "1.3.1" *** *)
a(bc_thm_tac °_open_thm THEN REPEAT strip_tac);
(* *** Goal "1.3.2" *** *)
a(swap_nth_asm_concl_tac 1 THEN LIST_DROP_NTH_ASM_T [3, 4] (MAP_EVERY ante_tac));
a(rewrite_tac[∏_def] THEN prove_tac[]);
(* *** Goal "1.3.3" *** *)
a(LEMMA_T ¨(x, y) ç ﬁVÆ asm_tac THEN1
	(LIST_DROP_NTH_ASM_T [5, 4] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext" prove_tac[]));
a(LIST_DROP_NTH_ASM_T [13] all_fc_tac);
a(contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
val €compact_product_lemma› = save_pop_thm "compact_product_lemma";
=TEX
%%%%
%%%%
=SML
(*
set_goal([], ¨µX : 'a SET; Y : 'b SET; ” ‘ ∑ 
	X ç ” Compact
±	Y ç ‘ Compact
±	” ç Topology
±	‘ ç Topology
¥	(X ∏ Y) ç (” ∏âT ‘) CompactÆ);
a(REPEAT strip_tac THEN bc_thm_tac compact_basis_product_topology_thm);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[product_topology_space_thm]);
a(all_asm_ante_tac THEN rewrite_tac[compact_def] THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [4, 6] (MAP_EVERY ante_tac) THEN
	MERGE_PCS_T1 ["'bin_rel", "sets_ext1"] prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac ¨∂W∑µx∑ x ç X ¥
	W x Ä V ± W x ç Finite ± (µy∑y ç Y ¥ (x, y) ç ﬁ(W x)) ±
	µD∑ D ç W x ¥ (∂ B C∑ x ç B ± B ç ” ± C ç ‘ ± D = (B ∏ C))Æ
	THEN1 prove_∂_tac THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(cases_tac ¨x' ç XÆ THEN asm_rewrite_tac[]);
a(lemma_tac ¨x' ç Space ”Æ THEN1
	(LIST_DROP_NTH_ASM_T [1, 8] (MAP_EVERY ante_tac) THEN
	rewrite_tac[compact_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(strip_asm_tac (list_µ_elim[¨”Æ, ¨‘Æ, ¨x'Æ] right_product_inj_continuous_thm));
a(lemma_tac ¨(” ∏âT ‘) ç TopologyÆ THEN1 all_fc_tac[product_topology_thm]);
a(ante_tac (list_µ_elim[¨Ãy:'b∑(x', y)Æ, ¨YÆ, ¨‘Æ, ¨” ∏âT ‘Æ] image_compact_thm));
a(asm_rewrite_tac[compact_def] THEN REPEAT strip_tac);
a(lemma_tac¨x' ç X ¥ {y|∂ x∑ x ç Y ± Fst y = x' ± Snd y = x} Ä (X ∏ Y)Æ
	THEN1 (MERGE_PCS_T1 ["'bin_rel", "sets_ext" ] prove_tac[]
		THEN all_var_elim_asm_tac1));
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b c∑a Ä b ± b Ä c ¥ a Ä cÆ]);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac);
a(POP_ASM_T (PC_T1 "sets_ext1" strip_asm_tac));
a(∂_tac ¨{A | A ç W ± ∂y∑(x', y) ç A}Æ THEN PC_T1 "basic_hol" REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.1.2" *** *)
a(bc_thm_tac Ä_finite_thm THEN ∂_tac ¨WÆ THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.1.3" *** *)
a(lemma_tac¨(x', y) ç ﬁWÆ);
(* *** Goal "2.1.3.1" *** *)
a(DROP_NTH_ASM_T 2 bc_thm_tac THEN REPEAT strip_tac);
a(∂_tac¨yÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.1.3.2" *** *)
a(REPEAT strip_tac);
a(∂_tac¨sÆ THEN asm_rewrite_tac[]);
a(∂_tac¨yÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.1.4" *** *)
a(lemma_tac¨D ç VÆ THEN1 (
	LIST_DROP_NTH_ASM_T [1, 4] (MAP_EVERY ante_tac)
		THEN PC_T1 "sets_ext" prove_tac[]));
a(LIST_DROP_NTH_ASM_T [14] all_fc_tac);
a(∂_tac¨BÆ THEN ∂_tac¨CÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 5 ante_tac THEN all_var_elim_asm_tac1);
a(prove_tac[∏_def]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨X Ä ﬁ{A | A ç ” ±∂x∑x ç X ±  x ç A ± µt y∑t ç A ± y ç Y ¥ (t, y) ç ﬁ(W x)}Æ
	THEN1 PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(lemma_tac ¨x ç Space ”Æ THEN1
	(LIST_DROP_NTH_ASM_T [1, 9] (MAP_EVERY ante_tac) THEN
	rewrite_tac[compact_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(DROP_NTH_ASM_T 3 (strip_asm_tac o µ_elim¨xÆ));
a(all_fc_tac[compact_product_lemma]);
a(∂_tac¨AÆ THEN REPEAT strip_tac);
a(∂_tac¨xÆ THEN PC_T1 "basic_hol" REPEAT strip_tac);
a(PC_T1 "basic_hol" (LIST_DROP_NTH_ASM_T [7])  all_fc_tac);
a(PC_T1 "basic_hol" (LIST_DROP_NTH_ASM_T [4])  all_fc_tac);
(* *** Goal "2.2.2" *** *)
a(lemma_tac¨{A | A ç ” ±∂x∑x ç X ±  x ç A ± µt y∑t ç A ± y ç Y ¥ (t, y) ç ﬁ(W x)} Ä ”Æ
	THEN1 PC_T1 "sets_ext" prove_tac[]);
a(GET_NTH_ASM_T 10 (fn th => all_fc_tac[rewrite_rule[compact_def] th]));
a(LIST_DROP_NTH_ASM_T [4, 5, 7, 8] discard_tac);
a(lemma_tac¨∂U∑µA∑A ç W' ¥ µ t y∑ t ç A ± y ç Y ¥ (t, y) ç ﬁ (U A)Æ
	THEN1 prove_∂_tac);
(* *** Goal "2.2.2.1" *** *)
a(REPEAT strip_tac);
a(cases_tac¨A' ç W'Æ THEN asm_rewrite_tac[]);


val €product_compact_thm› = save_pop_thm "product_compact_thm";
*)
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ V p∑ 
	‘ ç Topology
±	V Ä ‘
±	V ç Finite
±	p ç Space ‘
±	(µA∑ A ç V ¥ ∂B∑ B ç ‘ ± p ç B ± A ° B = {})
¥	∂B∑ B ç ‘ ± p ç B ± B ° ﬁV = {}Æ);
a(REPEAT strip_tac);
a(lemma_tac¨
	∂b∑µA∑A ç V ¥ b A ç ‘ ± p ç b A ± A ° b A = {}
Æ THEN1 prove_∂_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(cases_tac¨≥A' ç VÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 2 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(cases_tac¨ﬁV = {}Æ);
(* *** Goal "2.1" *** *)
a(∂_tac ¨Space ‘Æ THEN ALL_FC_T asm_rewrite_tac[space_open_thm]);
(* *** Goal "2.2" *** *)
a(lemma_tac ¨•{y|∂ x∑ x ç V ± y = b x} ç ‘Æ THEN1 bc_thm_tac finite_•_open_thm);
(* *** Goal "2.2.1" *** *)
a(asm_rewrite_tac[] THEN ALL_FC_T rewrite_tac[finite_image_thm]);
a(REPEAT strip_tac THEN PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
(* *** Goal "2.2.1.1" *** *)
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.1.2" *** *)
a(rewrite_tac[]);
a(cases_tac¨V = {}Æ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(POP_ASM_T (PC_T1 "sets_ext1" strip_asm_tac));
a(∂_tac¨b xÆ THEN ∂_tac¨xÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(∂_tac¨•{y|∂ x∑ x ç V ± y = b x}Æ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.2.2.1" *** *)
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(PC_T "sets_ext1" strip_tac THEN rewrite_tac[°_def, •_def, ﬁ_def]);
a(REPEAT strip_tac);
a(∂_tac¨b sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(∂_tac¨ sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.2" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
val €compact_closed_lemma› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ C∑ 
	‘ ç Topology
±	‘ ç Hausdorff
±	C ç ‘ Compact
¥	C ç ‘ ClosedÆ);
a(REPEAT strip_tac);
a(ALL_FC_T1 fc_§_canon  rewrite_tac[closed_open_neighbourhood_thm]);
a(once_rewrite_tac[prove_rule[]¨µp1 p2∑ p1 ± p2 § p1 ± (p1 ¥ p2)Æ]);
a(REPEAT strip_tac THEN1
	(POP_ASM_T ante_tac THEN prove_tac[compact_def]));
a(lemma_tac¨C Ä ﬁ {A | A ç ‘ ± ∂B∑B ç ‘ ± x ç B ± A ° B = {}}Æ);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[hausdorff_def]));
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(lemma_tac¨x' ç Space ‘Æ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(lemma_tac¨≥x' = xÆ THEN1 (contr_tac THEN all_var_elim_asm_tac1));
a(all_asm_fc_tac[]);
a(∂_tac¨AÆ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[compact_def]));
a(lemma_tac¨{A | A ç ‘ ± ∂B∑B ç ‘ ± x ç B ± A ° B = {}} Ä ‘Æ
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(all_asm_fc_tac[]);
a(lemma_tac¨W Ä ‘Æ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(lemma_tac¨µ A∑ A ç W ¥ (∂ B∑ B ç ‘ ± x ç B ± A ° B = {})Æ);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
a(∂_tac¨BÆ THEN PC_T1 "sets_ext1" asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(all_fc_tac[compact_closed_lemma]);
a(∂_tac¨BÆ THEN  asm_rewrite_tac[]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[] ¨µX∑ C Ä X ± B ° X = {} ¥ B ° C = {}Æ]);
val €compact_closed_thm› = save_pop_thm "compact_closed_thm";
=TEX
\subsection{Connectdness}
%%%%
%%%%
=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
¥	(X ç ‘ Connected § X ç (X ÚâT ‘) Connected)Æ);
a(rewrite_tac[connected_def] THEN PC_T1 "sets_ext1" REPEAT µ_tac THEN ¥_tac);
a(ALL_FC_T1 fc_§_canon rewrite_tac[subspace_topology_space_thm]);
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b∑a Ä a ° b § a Ä bÆ]);
a(rewrite_tac[subspace_topology_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1);
a(lemma_tac¨X Ä B'  ¿ B''Æ THEN1
	(GET_NTH_ASM_T 3 ante_tac THEN  PC_T1 "sets_ext" prove_tac[]));
a(DROP_NTH_ASM_T 3 ante_tac THEN
	rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨µa b c∑a ° (b ° a) ° c ° a = a ° b ° cÆ]);
a(REPEAT strip_tac);
a(lemma_tac¨≥X Ä B' Æ THEN1
	(GET_NTH_ASM_T 3 ante_tac THEN  PC_T1 "sets_ext" prove_tac[]));
a(all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(list_spec_nth_asm_tac 6 [¨B ° XÆ, ¨C ° XÆ]);
(* *** Goal "2.1" *** *)
a(list_spec_nth_asm_tac 1 [¨BÆ]);
(* *** Goal "2.2" *** *)
a(list_spec_nth_asm_tac 1 [¨CÆ]);
(* *** Goal "2.3" *** *)
a(i_contr_tac THEN LIST_DROP_NTH_ASM_T [1, 4] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.4" *** *)
a(i_contr_tac THEN LIST_DROP_NTH_ASM_T [1, 3] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.5" *** *)
a(i_contr_tac THEN LIST_DROP_NTH_ASM_T [1, 2] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.6" *** *)
a(LIST_DROP_NTH_ASM_T [1] (MAP_EVERY ante_tac)
	THEN PC_T1 "sets_ext1" prove_tac[]);
val €connected_topological_thm› = save_pop_thm "connected_topological_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ‘ X∑ 
	‘ ç Topology
¥	(	X ç ‘ Connected
	 § 	µx y∑ x ç X ± y ç X ¥ ∂Y∑ Y Ä X ± x ç Y ± y ç Y ± Y ç ‘ Connected)Æ);
a(REPEAT strip_tac THEN1 (∂_tac¨XÆ THEN PC_T1 "sets_ext1" asm_prove_tac[]));
a(POP_ASM_T ante_tac THEN rewrite_tac[connected_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN all_asm_fc_tac[]);
a(LIST_GET_NTH_ASM_T [2, 3, 4] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN PC_T "sets_ext1" contr_tac);
a(list_spec_nth_asm_tac 9 [¨xÆ, ¨x'Æ]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä b ± b Ä c ¥ a Ä cÆ]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä b ± b ° c = {} ¥ a ° c = {}Æ]);
a(list_spec_nth_asm_tac 3 [¨BÆ, ¨CÆ]);
(* *** Goal "2.1" *** *)
a(LIST_GET_NTH_ASM_T [1, 7, 11] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2.2" *** *)
a(LIST_GET_NTH_ASM_T [1, 6, 9] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext" prove_tac[]);
val €connected_pointwise_thm› = save_pop_thm "connected_pointwise_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µC D ”∑ 
	C ç ” Connected
±	D ç ” Connected
±	≥C ° D = {}
±	” ç Topology
¥	C ¿ D ç ” Connected
Æ);
a(rewrite_tac[connected_def] THEN REPEAT strip_tac
	THEN1 all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä c ± b Ä c ¥ a ¿ b Ä cÆ]);
a(DROP_NTH_ASM_T 7 (PC_T1 "sets_ext1" strip_asm_tac) THEN contr_tac);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a ¿ b Ä c ¥ a Ä c ± b Ä cÆ]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑(a ¿ b) ° c = {} ¥ a ° c = {} ± b ° c = {}Æ]);
a(list_spec_nth_asm_tac 16 [¨BÆ, ¨C'Æ] THEN list_spec_nth_asm_tac 15 [¨BÆ, ¨C'Æ]);
(* *** Goal "1" *** *)
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä c ± b Ä c ¥ a ¿ b Ä cÆ]);
(* *** Goal "2" *** *)
a(ante_tac(pc_rule1 "sets_ext1" prove_rule[]
	¨x ç C ± x ç D  ± C Ä B ± D Ä C' ¥ x ç C ° B ° C'Æ));
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(ante_tac(pc_rule1 "sets_ext1" prove_rule[]
	¨x ç C ± x ç D  ± C Ä C' ± D Ä B ¥ x ç C ° B ° C'Æ));
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä c ± b Ä c ¥ a ¿ b Ä cÆ]);
val €¿_connected_thm› = save_pop_thm "¿_connected_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf X ” ‘∑ 
	f ç (”, ‘) Continuous
±	X ç ” Connected
±	” ç Topology
±	‘ ç Topology
¥	{y | ∂x∑ x ç X ± y = f x} ç ‘ Connected
Æ);
a(rewrite_tac[connected_def, continuous_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac );
a(all_var_elim_asm_tac1 THEN PC_T1 "sets_ext1" all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(contr_tac);
a(LIST_DROP_NTH_ASM_T [11] all_fc_tac);
a(GET_NTH_ASM_T 12 (PC_T1 "sets_ext1" strip_asm_tac));
a(lemma_tac¨
	X Ä {x|x ç Space ” ± f x ç B} ¿ {x|x ç Space ” ± f x ç C}
Æ THEN1 (PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac
		THEN_TRY SOLVED_T (all_asm_fc_tac[])));
(* *** Goal "2.1" *** *)
a(swap_nth_asm_concl_tac 9 THEN PC_T "sets_ext1" strip_tac);
a(REPEAT strip_tac THEN ∂_tac¨f xÆ THEN REPEAT strip_tac);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(lemma_tac¨
	X ° {x|x ç Space ” ± f x ç B} ° {x|x ç Space ” ± f x ç C} = {}
Æ THEN1 (PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac));
(* *** Goal "2.2.1" *** *)
a(swap_nth_asm_concl_tac 11 THEN PC_T "sets_ext1" strip_tac);
a(REPEAT strip_tac THEN ∂_tac¨f xÆ);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(LEMMA_T ¨X Ä {x|x ç Space ” ± f x ç B} ≤ X Ä {x|x ç Space ” ± f x ç C}Æ ante_tac);
(* *** Goal "2.2.2.1" *** *)
a(DROP_NTH_ASM_T 14 bc_thm_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(swap_nth_asm_concl_tac 8);
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a(swap_nth_asm_concl_tac 7);
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
val €image_connected_thm› = save_pop_thm "image_connected_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µX : 'a SET; Y : 'b SET; ” ‘ ∑ 
	X ç ” Connected
±	Y ç ‘ Connected
±	” ç Topology
±	‘ ç Topology
¥	(X ∏ Y) ç (” ∏âT ‘) ConnectedÆ);
a(REPEAT strip_tac);
a(lemma_tac ¨(” ∏âT ‘) ç TopologyÆ THEN1 all_fc_tac[product_topology_thm]);
a(ALL_FC_T1 fc_§_canon once_rewrite_tac[connected_pointwise_thm]);
a(REPEAT strip_tac);
a(lemma_tac¨
	(∂H∑ H ç (” ∏âT ‘) Connected ± x ç H ± (Fst y, Snd x) ç H ± H Ä (X ∏ Y))
±	(∂V∑ V ç (” ∏âT ‘) Connected ± y ç V ± (Fst y, Snd x) ç V ± V Ä (X ∏ Y))Æ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨{ab | ∂a∑ a ç X ± ab = (Ãa∑(a, Snd x)) a}Æ THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(bc_thm_tac image_connected_thm);
a(∂_tac¨”Æ THEN REPEAT strip_tac);
a(bc_thm_tac left_product_inj_continuous_thm THEN REPEAT strip_tac);
a(POP_ASM_T discard_tac THEN POP_ASM_T (ante_tac o rewrite_rule[∏_def]));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o rewrite_rule[connected_def]));
a(POP_ASM_T discard_tac THEN POP_ASM_T ante_tac 
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.2" *** *)
a(∂_tac ¨Fst xÆ THEN rewrite_tac[]);
a(POP_ASM_T discard_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[∏_def]));
(* *** Goal "1.3" *** *)
a(∂_tac ¨Fst yÆ THEN rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[∏_def]));
(* *** Goal "1.4" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN rewrite_tac[∏_def] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o rewrite_rule[∏_def]) THEN taut_tac);
(* *** Goal "2" *** *)
a(∂_tac¨{ab | ∂b∑ b ç Y ± ab = (Ãb∑(Fst y, b)) b}Æ THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac image_connected_thm);
a(∂_tac¨‘Æ THEN REPEAT strip_tac);
a(bc_thm_tac right_product_inj_continuous_thm THEN REPEAT strip_tac);
a(POP_ASM_T (ante_tac o rewrite_rule[∏_def]));
a(DROP_NTH_ASM_T 6 (strip_asm_tac o rewrite_rule[connected_def]));
a(POP_ASM_T discard_tac THEN POP_ASM_T ante_tac 
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.2" *** *)
a(∂_tac ¨Snd yÆ THEN rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[∏_def]));
(* *** Goal "2.3" *** *)
a(∂_tac ¨Snd xÆ THEN rewrite_tac[]);
a(POP_ASM_T discard_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[∏_def]));
(* *** Goal "2.4" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN rewrite_tac[∏_def] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[∏_def]) THEN taut_tac);
(* *** Goal "3" *** *)
a(lemma_tac ¨H ¿ V Ä (X ∏ Y)Æ THEN1
	all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]¨µa b c∑a Ä c ± b Ä c ¥ a ¿ b Ä cÆ]);
a(∂_tac¨H ¿ VÆ THEN REPEAT strip_tac);
a(bc_thm_tac ¿_connected_thm);
a(REPEAT strip_tac THEN PC_T "sets_ext1" contr_tac THEN all_asm_fc_tac[]);
val €product_connected_thm› = save_pop_thm "product_connected_thm";
=TEX
\subsection{Epilogue}
=TEX
=SML
output_theory{out_file="topology.th.doc", theory="-"};
=TEX
\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}
\end{document}


