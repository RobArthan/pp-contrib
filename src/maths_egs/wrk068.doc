=IGN
********************************************************************************
wrk068.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=IGN
pp_make_database -f -p hol maths_egs
docsml wrk068
xpp wrk068.doc -d maths_egs -i wrk068 &
doctex wrk068 wrk068.th; texdvi -b wrk068; texdvi wrk068; texdvi wrk068
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\def\Lim{\mbox{{\sf lim}}}
\def\LimInf{\mbox{{\sf lim inf}}}
\def\LimSup{\mbox{{\sf lim sup}}}

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}

\def\LogName{\mbox{{\sf log}}}
\def\Log#1{\LogName(#1)}

\def\SinName{\mbox{{\sf sin}}}
\def\Sin#1{\SinName(#1)}

\def\CosName{\mbox{{\sf cos}}}
\def\Cos#1{\CosName(#1)}

\def\Abs#1{|#1|}

\def\ThmsII#1#2{%
{\vertbarfalse
\begin{minipage}[t]{0.48\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.48\hsize}
#2
\end{minipage}}}

\def\ThmsIII#1#2#3{%
{\vertbarfalse
\begin{minipage}[t]{0.32\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#2
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#3
\end{minipage}}}

\def\Hide#1{\relax}

\makeindex
\title{Mathematical Case Studies: \\ --- \\ Some Group Theory}
\author{Rob Arthan}
\makeindex
\author{R.D. Arthan \\ Lemma 1 Ltd. \\ rda@lemma-one.com}
\date{\FormatDate{$Date: 2004/04/26 20:21:59 $%
}}

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
This {\ProductHOL} script contains definitions and proofs concerning
the elements of group theory.
What is currently covered is what is covered in the first chapter of any good text on the subject:
in preparation for the introduction of quotient groups, we begin with a purely set-theoretical study of equivalance relations and the quotient of a set with respect to an equivalence relation.
This is followed by the definitions of the concepts of group, homomorphism between groups, subgroups, normal subgroups, kernels of homomorphisms, congruence modulo a subgroup, cosets, and quotient groups.
We then demonstrate a few examples of groups and go on to show that the various abstract notions lead to the expected theorems: e.g., that the quotient group construction is consistent and does indeed give rise to a group.

The treatment in {\ProductHOL} raises some interesting methodological problems and we give our preferred solutions to these problems.
These issues are mostly not specific to {\ProductHOL} but are likely to apply to any development of the material in a typed logic with Millner-style polymorphism.
\end{abstract}
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd \number\year \\
Reference: LEMMA1/HOL/WRK068; issue $Revision: 1.2 $%


\end{centering}
\thispagestyle{empty}
\end{titlepage}
\newpage
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
\tableofcontents
%\newpage
%\subsection{Document cross references}

\subsection*{To Do}
\begin{itemize}

\item
Write the document!

\end{itemize}


\bibliographystyle{plain}
\bibliography{fmu}

%%%%
%%%%
%%%%
%%%%
\newpage
\section{INTRODUCTION}
%%%%
%%%%
%%%%
%%%%
This document gives specifications and proofs relating to group theory.
%%%%
%%%%
%%%%
%%%%
\section{AN OVERVIEW OF THE THEORY}

\subsection{Equivalence Relations}

\subsubsection{Technical Prelude}

First of all, we must give the the ML commands to  introduce the new theory ``equiv\_rel'' as a child of the theory ``orders'' of ordered sets (whence comes our definition of transitivity,
see \cite{LEMMA1/HOL/DTD115}).


=SML
force_delete_theory"equiv_rel" handle Fail _ => ();
open_theory"orders";
set_merge_pcs["basic_hol1", "'sets_alg"];
new_theory"equiv_rel";
=TEX
%%%%
%%%%
%%%%
%%%%

%%%%
%%%%
%%%%
%%%%
\subsubsection{The Definitions}
We need to define the notion of an equivalence relation, i.e., a binary relation that is transitive, reflexive and symmetric.
Transitivity is defined elsewhere, but we now need the notions of refliexivity and symmetry to support the definition of an equivalence relation.
We follow the theory of orders in making these notions properties of set-relation pairs.

=SML
declare_infix(210, "¶");
πHOLCONST
‹ €Refl› : ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ BOOL
˜¸¸¸¸¸¸
‹ µ X $¶∑
‹	Refl(X, $¶)
‹ §	µx∑x ç X ¥ x ¶  x
∞
πHOLCONST
‹ €Sym› : ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ BOOL
˜¸¸¸¸¸¸
‹ µ X $¶∑
‹	Sym(X, $¶)
‹ §	µx y∑x ç X ± y ç X ± x ¶  y ¥ y ¶ x
∞
πHOLCONST
‹ €Equiv› : ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ BOOL
˜¸¸¸¸¸¸
‹ µ X $¶∑
‹	Equiv(X, $¶)
‹ §	Refl(X, $¶) ± Sym(X, $¶) ± Trans(X, $¶)
∞

πHOLCONST
‹ €EquivClass› : ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ 'a ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ X $¶ x∑
‹	EquivClass(X, $¶) x = {y | y ç X ± x ¶ y}
∞

πHOLCONST
‹ €QuotientSet› : 'a SET ≠ ('a ≠ 'a ≠ BOOL) ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ X $¶∑
‹	QuotientSet X ($¶) = {A | ∂x∑ x ç X ± A = EquivClass(X, $¶) x}
∞
=SML
declare_infix(300, "//");
declare_alias("//", ¨QuotientSetÆ);
=SML
declare_infix(200, "Respects");

πHOLCONST
‹ €$Respects› : ('a ≠ 'b) ≠ ('a ≠ 'a ≠ BOOL) ≠ 'a SET ≠ BOOL
˜¸¸¸¸¸¸
‹ µ f $¶ X∑
‹	(f Respects $¶) X § µx y∑x ç X ± y ç X ± x ¶ y ¥ f x = f y
∞
πHOLCONST
‹ €$Contents› : 'a SET ≠ 'a
˜¸¸¸¸¸¸
‹ µ x∑ Contents {x} = x
∞

=SML
declare_postfix(330, "Á-Í");

πHOLCONST
‹ €$Á-Í› : ('a ≠ 'b) ≠ 'a  SET ≠ 'b
˜¸¸¸¸¸¸
‹ µ f A∑ (f Á-Í) A = Contents{y | ∂x∑  x ç A ± y = f x}
∞
\subsection{Groups}

\subsubsection{Technical Prelude}

First of all, we must give the the ML commands to  introduce the new theory ``groups'' as a child of the theory ``equiv\_rel'' of equivalence relations.

=SML
force_delete_theory"groups" handle Fail _ => ();
open_theory"equiv_rel";
new_theory"groups";
set_merge_pcs["basic_hol1", "'sets_alg"];
=TEX
%%%%
%%%%
%%%%
%%%%

%%%%
%%%%
%%%%
%%%%
\subsubsection{The Definitions}
=SML
declare_infix(310, ".");
declare_postfix(330, "õ~");
declare_type_abbrev("GROUP", ["'a"], î'a SET ∏ ('a ≠ 'a ≠ 'a) ∏ ('a ≠ 'a) ∏ 'aÆ);


πHOLCONST
‹ €Car› :  'a GROUP ≠ 'a SET;
‹ €$.› :  'a ≠ 'a ≠ 'a GROUP ≠ 'a;
‹ €$õ~› :  'a ≠ 'a GROUP ≠ 'a;
‹ €One› :  'a GROUP ≠ 'a
˜¸¸¸¸¸¸
‹ µ set times inverse one∑
‹	Car (set, times, inverse, one) = set
‹ ±	(µx y∑ (x . y) (set, times, inverse, one) = times x y)
‹ ±	(µx∑ (x õ~) (set, times, inverse, one) = inverse x)
‹ ±	One (set, times, inverse, one) = one
∞
πHOLCONST
‹ €Group› : ('a SET ∏ ('a ≠ 'a ≠ 'a) ∏ ('a ≠ 'a) ∏ 'a) SET
˜¸¸¸¸¸¸
‹ µ G∑
‹	G ç Group
‹ §	(µx y∑ x ç Car G ± y ç Car G ¥ (x . y) G ç Car G)
‹ ±	(µx y z∑ x ç Car G ± y ç Car G ± z ç Car G ¥ ((x . y)G . z)G = (x . (y . z)G)G)
‹ ±	One G ç Car G
‹ ±	(µx∑ x ç Car G ¥ (x . One G) G = x ± (One G . x)G = x)
‹ ±	(µx∑ x ç Car G ¥ (x õ~) G ç Car G)
‹ ±	(µx∑ x ç Car G ¥ (x . (x õ~)G)G = One G ± ((x õ~)G . x)G = One G)
∞

πHOLCONST
‹ €Homomorphism› : 'a GROUP ∏ 'b GROUP ≠ ('a ≠ 'b) SET
˜¸¸¸¸¸¸
‹ µ G H f∑
‹	f ç Homomorphism(G, H)
‹ §	(µx ∑ x ç Car G ¥ f x ç Car H)
‹ ±	(µx y∑ x ç Car G ± y ç Car G¥ f((x . y) G) = (f x . f y)H)
∞
πHOLCONST
‹ €Subgroup› : 'a GROUP  ≠ 'a GROUP SET
˜¸¸¸¸¸¸
‹ µ G H∑
‹	H ç Subgroup G
‹ §	Car H Ä Car G
‹ ±	H ç Group
‹ ±	(µx y∑  (x.y)H = (x.y)G)
‹ ±	(µx∑  (x õ~)H = (x õ~)G)
∞
πHOLCONST
‹ €NormalSubgroup› : 'a GROUP  ≠ 'a GROUP SET
˜¸¸¸¸¸¸
‹ µ G H∑
‹	H ç NormalSubgroup G
‹ §	H ç Subgroup G
‹ ±	(µx y∑ x ç Car H ± y ç Car G ¥ ((y õ~)G.(x.y)G)G ç Car H)
∞
πHOLCONST
‹ €Kernel› : ('a ≠ 'b) ≠ 'a GROUP ∏ 'b GROUP≠ 'a GROUP
˜¸¸¸¸¸¸
‹ µ f G H∑
‹	Kernel f (G, H)
‹ =	({x | x ç Car G ± f x = One H}, (Ãx y∑ (x . y)G), (Ãx∑(x õ~) G), One G)
∞

πHOLCONST
‹ €RightCongruent› :'a GROUP ≠ 'a GROUP ≠ 'a ≠ 'a ≠ BOOL
˜¸¸¸¸¸¸
‹ µ H G x y∑ RightCongruent H G x y § ((x õ~) G . y) G ç Car H
∞

πHOLCONST
‹ €RightCoset› :'a GROUP ≠ 'a GROUP≠ 'a ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ H G x∑ RightCoset H G x = {y | ∂z∑z ç Car H ± y = (x.z) G}
∞
πHOLCONST
‹ €QuotientGroup› :'a GROUP ≠ 'a GROUP≠ 'a SET GROUP
˜¸¸¸¸¸¸
‹ µ H G∑ G ç Group ± H ç NormalSubgroup G
‹ ¥	Car (QuotientGroup G H) = {A | ∂x∑x ç Car G ± A = RightCoset H G x}
‹ ±	(µx y∑ x ç Car G ± y ç Car G ¥
‹		(RightCoset H G x.RightCoset H G y) (QuotientGroup G H)
‹	=	RightCoset H G ((x.y)G))
‹ ±	One (QuotientGroup G H) = RightCoset H G (One G)
‹ ± 	(µx∑ x ç Car G ¥
‹		(RightCoset H G x õ~) (QuotientGroup G H)
‹	=	RightCoset H G ((x õ~)G))
∞
=SML
declare_alias("//", ¨QuotientGroupÆ);
=TEX
\newpage
\subsection{Examples of Groups}

\subsubsection{Technical Prelude}

First of all, we must give the the ML commands to  introduce the new theory ``group\_egs'' as a child of the theory `groups'' of groups.

=SML
force_delete_theory"group_egs" handle Fail _ => ();
open_theory"groups";
new_theory"group_egs";
new_parent"Ø";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙", "'Ø"];
=TEX
%%%%
%%%%
%%%%
%%%%

%%%%
%%%%
%%%%
%%%%
\subsubsection{The Definitions}
=SML


πHOLCONST
‹ €˙_plus› :  ˙ GROUP;
‹ €˙_units› :  ˙ GROUP
˜¸¸¸¸¸¸
‹	˙_plus = (Universe, $+, ~, Ó˙ 0)
‹ ±	˙_units = ({~(Ó˙ 1); Ó˙ 1}, $*, (Ãx∑x), Ó˙ 1)
∞

%%%%
%%%%
%%%%
%%%%
{\let\Section\section
\def\section#1{\Section{#1}}
\include{wrk0681.th}
\include{wrk0682.th}
\include{wrk0683.th}
}  %\let

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document}

{\HOLindexOff
%%%%
%%%%
%%%%
%%%%
\onecolumn
\section{THEOREMS}\label{THEOREMS}
=SML
fun arb_gen (thm : THM) : THM = (
	let	val ty_map = map
			(fn tv => (mk_vartype("@_" ^ tv), mk_vartype tv))
			(term_tyvars(concl thm));
		val thm1 = asm_inst_type_rule ty_map thm;
	in	all_µ_intro (all_µ_arb_elim thm1)
	end
);
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{The Definitions and Their Consistency}
%%%%
%%%%
%%%%
%%%%
=SML
open_theory"equiv_rel";
set_merge_pcs["basic_hol1", "'sets_alg"];
=TEX
=SML
val €refl_def› = get_spec¨ReflÆ;
val €sym_def› = get_spec¨SymÆ;
val €equiv_def› = get_spec¨EquivÆ;
val €equiv_class_def› = get_spec¨EquivClassÆ;
val €quotient_set_def› = get_spec¨$//Æ;
val €respects_def› = get_spec¨$RespectsÆ;
val €induced_def› = get_spec¨$Á-ÍÆ;
=SML
push_consistency_goal ¨ContentsÆ;
a(∂_tac¨ÃA∑≈x∑A = {x}Æ THEN REPEAT strip_tac THEN rewrite_tac[]);
a(all_≈_tac);
(* *** Goal "1" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext" REPEAT strip_tac);
a(POP_ASM_T (ante_tac o µ_elim¨xÆ));
a(rewrite_tac[] THEN STRIP_T (rewrite_thm_tac o eq_sym_rule));
val _ = save_consistency_thm ¨ContentsÆ (pop_thm());
val €contents_def› = save_thm("contents_def", get_spec¨$ContentsÆ);
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Equivalence Relations}
%%%%
%%%%
%%%%
%%%%
=SML
set_goal([], ¨
	µX; $¶; x y∑
	Equiv(X, $¶) ± x ç X ± y ç X ¥
	(EquivClass(X, $¶)  x = EquivClass(X, $¶) y § x ¶ y)
Æ);
a(PC_T1 "sets_ext1" rewrite_tac[equiv_class_def, equiv_def, sym_def, refl_def, trans_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 5 bc_thm_tac THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 1 (ante_tac o µ_elim¨xÆ));
a(ALL_ASM_FC_T asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(REPEAT (all_asm_fc_tac[]));
(* *** Goal "3" *** *)
a(REPEAT (all_asm_fc_tac[]));
val €equiv_class_eq_thm› = save_pop_thm "equiv_class_eq_thm";
=TEX
=SML
set_goal([], ¨
	µX; $¶; x y∑
	Equiv(X, $¶) ± x ç X ¥ x ç EquivClass(X, $¶) x
Æ);
a(PC_T1 "sets_ext1" rewrite_tac[equiv_class_def, equiv_def, sym_def, refl_def, trans_def]
	THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
val €equiv_class_ç_thm› = save_pop_thm "equiv_class_ç_thm";
=TEX
=SML
set_goal([], ¨
	µA a c∑
		a ç A ± (µx∑x ç A ¥ f x = c)
	¥	{y | ∂x∑x ç A ± y = f x} = {c}
Æ);
a(PC_T1 "sets_ext1"  REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
(* *** Goal "2" *** *)
a(∂_tac¨aÆ THEN REPEAT strip_tac);
a(ALL_ASM_FC_T asm_rewrite_tac[]);
val €constant_image_thm› = save_pop_thm "constant_image_thm";
=TEX
=SML
set_goal([], ¨
	µX $¶ f x∑
		Equiv(X, $¶)
	±	(f Respects $¶) X
	±	x ç X
	¥	{y | ∂z∑z ç EquivClass(X, $¶) x ± y = f z} = {f x}
Æ);
a(REPEAT strip_tac);
a(bc_thm_tac constant_image_thm);
a(∂_tac¨xÆ THEN all_asm_ante_tac);
a(PC_T1 "sets_ext1" rewrite_tac[ respects_def,
	equiv_class_def, equiv_def, sym_def, refl_def, trans_def]
		THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(ALL_ASM_FC_T rewrite_tac[]);
val €respects_image_thm› = save_pop_thm "respects_image_thm";
=TEX
=SML
set_goal([], ¨
	µX $¶ f x∑
		Equiv(X, $¶)
	±	(f Respects $¶) X
	±	x ç X
	¥	Contents {y | ∂z∑z ç EquivClass(X, $¶) x ± y = f z} = f x
Æ);
a(REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[arb_gen respects_image_thm]);
a(rewrite_tac[contents_def]);
val €respects_image_contents_thm› = save_pop_thm "respects_image_contents_thm";
=TEX
=SML
set_goal([], ¨
	µX $¶∑
		Equiv(X, $¶)
	¥	µA∑ A ç X // ($¶) ¥ ∂x∑ x ç X ± A = EquivClass(X, $¶) x

Æ);
a(rewrite_tac[ quotient_set_def]);
val €quotient_map_onto_thm› = save_pop_thm "quotient_map_onto_thm";
=TEX
=SML
set_goal([], ¨
	µX $¶∑ A ç X // ($¶) ± x ç A ¥ x ç X
Æ);
a(rewrite_tac[ quotient_set_def, equiv_class_def] THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
val €quotient_ç_thm› = save_pop_thm "quotient_ç_thm";
=TEX
=SML
set_goal([], ¨
	µX $¶∑
		Equiv(X, $¶)
	¥	A ç X // ($¶) ¥ ∂x∑ x ç X ± x ç A
Æ);
a(rewrite_tac[ quotient_set_def, equiv_class_def, equiv_def, refl_def] THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(∂_tac¨xÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val €quotient_rep_∂_thm› = save_pop_thm "quotient_rep_∂_thm";
=TEX
=SML
set_goal([], ¨
	µX f∑ Equiv(X, (Ãx y∑f x = f y))
Æ);
a(PC_T1 "sets_ext1" rewrite_tac[ equiv_def, sym_def, refl_def, trans_def]
		THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
val €equiv_fun_thm› = save_pop_thm "equiv_fun_thm";
=TEX
=SML
set_goal([], ¨
	µX f∑ (f Respects (Ãx y∑f x = f y)) X
Æ);
a(rewrite_tac[ respects_def] THEN REPEAT strip_tac);
val €respects_fun_thm› = save_pop_thm "respects_fun_thm";
=TEX
=SML
set_goal([], ¨
	µX $¶ f x∑
		Equiv(X, $¶)
	±	(f Respects $¶) X
	±	x ç X
	¥	(f Á-Í) (EquivClass(X, $¶) x) = f x
Æ);
a(rewrite_tac[induced_def] THEN REPEAT strip_tac);
a(bc_thm_tac respects_image_contents_thm THEN REPEAT strip_tac);
val €induced_fun_thm1› = save_pop_thm "induced_fun_thm1";
=TEX
=SML
set_goal([], ¨
	µX $¶ f ∑
		Equiv(X, $¶)
	±	(f Respects $¶) X
	¥	µA x∑ A ç X // $¶ ± x ç A ¥ (f Á-Í) A = f x
Æ);
a(rewrite_tac[quotient_set_def] THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[equiv_class_def]));
a(ALL_FC_T  rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) equiv_class_eq_thm,
	induced_fun_thm1]);
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[respects_def]));
a(all_asm_fc_tac[]);
val €induced_fun_thm› = save_pop_thm "induced_fun_thm";
=TEX
=SML
set_goal([], ¨
	µX R Y S f ∑
		Equiv(X, R)
	±	Equiv(Y, S)
	±	(µy∑ y ç Y ¥ ((Ãx∑f x y) Respects R) X)
	±	(µx∑ x ç X ¥ (f x Respects S) Y)
	¥	µA x B y∑ A ç X // R ± x ç A ± B ç Y // S ± y ç B
			¥ ((Ãx∑(f x Á-Í) B )Á-Í) A = f x y
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µx∑x ç X ¥ (f x Á-Í) B = f x yÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN all_fc_tac[induced_fun_thm]);
(* *** Goal "2" *** *)
a(lemma_tac¨((Ã x∑ (f x Á-Í) B) Respects R) XÆ);
(* *** Goal "2.1" *** *)
a(rewrite_tac[respects_def] THEN REPEAT strip_tac THEN ALL_ASM_FC_T rewrite_tac[]);
a(lemma_tac¨y ç YÆ THEN1 all_fc_tac[arb_gen quotient_ç_thm]);
a(DROP_NTH_ASM_T 11 (ante_tac o rewrite_rule[respects_def] o µ_elim¨yÆ));
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(ALL_FC_T rewrite_tac[induced_fun_thm]);
a(lemma_tac¨x ç XÆ THEN1 all_fc_tac[arb_gen quotient_ç_thm]);
a(ALL_ASM_FC_T rewrite_tac[]);
val €induced_fun_induced_fun_thm› = save_pop_thm "induced_fun_induced_fun_thm";
=TEX
=SML
set_goal([], ¨
	µX $¶ f ∑
		Equiv(X, $¶)
	±	(f Respects $¶) X
	¥	∂g∑ µA x∑ A ç X // $¶ ± x ç A ¥ g A = f x
Æ);
a(REPEAT strip_tac);
a(∂_tac¨f Á-ÍÆ THEN REPEAT strip_tac);
a(all_fc_tac[arb_gen induced_fun_thm]);
val €induced_fun_∂_thm› = save_pop_thm "induced_fun_∂_thm";
=TEX
=SML
set_goal([], ¨
	µX $¶ f g h∑
		Equiv(X, $¶)
	±	(f Respects $¶) X
	±	(µA x∑ A ç X // $¶ ± x ç A ¥ g A = f x)
	±	(µA x∑ A ç X // $¶ ± x ç A ¥ h A = f x)
	¥	(µA∑ A ç X // $¶  ¥ h A = g A)
Æ);
a(REPEAT strip_tac);
a(all_fc_tac[quotient_rep_∂_thm]);
a(ALL_ASM_FC_T rewrite_tac[]);
val €induced_fun_∂_unique_thm› = save_pop_thm "induced_fun_∂_unique_thm";
=TEX
=SML
set_goal([], ¨
	µX R Y S f ∑
		Equiv(X, R)
	±	Equiv(Y, S)
	±	(µy∑ y ç Y ¥ ((Ãx∑f x y) Respects R) X)
	±	(µx∑ x ç X ¥ ((Ãy∑f x y) Respects S) Y)
	¥	∂g∑ µA x B y∑ A ç X // R ± x ç A ± B ç Y // S ± y ç B
			¥ g A B = f x y
Æ);
a(REPEAT µ_tac);
a(rewrite_tac[prove_rule[]¨(Ãy∑f x y) = f xÆ] THEN REPEAT strip_tac);
a(∂_tac¨ ÃA B∑ ((Ãx∑(f x Á-Í) B )Á-Í) AÆ THEN REPEAT strip_tac THEN rewrite_tac[]);
a(all_fc_tac[ induced_fun_induced_fun_thm]);
val €dyadic_induced_fun_∂_thm› = save_pop_thm "dyadic_induced_fun_∂_thm";
=TEX
=SML
set_goal([], ¨
	µX R Y S f g h∑
		Equiv(X, R)
	±	Equiv(Y, S)
	±	(µy∑ y ç Y ¥ ((Ãx∑f x y) Respects R) X)
	±	(µx∑ x ç X ¥ ((Ãy∑f x y) Respects S) Y)
	±	(µA x B y∑ A ç X // R ± x ç A ± B ç Y // S ± y ç B ¥ g A B = f x y)
	±	(µA x B y∑ A ç X // R ± x ç A ± B ç Y // S ± y ç B ¥ h A B = f x y)
	¥	(µA B y∑ A ç X // R ± B ç Y // S ¥ h A B = g A B)
Æ);
a(REPEAT strip_tac);
a(all_fc_tac[quotient_rep_∂_thm]);
a(ALL_ASM_FC_T rewrite_tac[]);
val €dyadic_induced_fun_∂_unique_thm› = save_pop_thm "dyadic_induced_fun_∂_unique_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Groups}
%%%%
%%%%
%%%%
%%%%
=SML
open_theory"groups";
set_merge_pcs["basic_hol1", "'sets_alg"];
=TEX
=SML
val €group_ops_def› = get_spec¨OneÆ;
val €group_def› = get_spec¨GroupÆ;
val €homomorphism_def› = get_spec¨HomomorphismÆ;
val €subgroup_def› = get_spec¨SubgroupÆ;
val €subgroup_def1› = pc_rule1 "sets_ext1" rewrite_rule[] (get_spec¨SubgroupÆ);
val €normal_subgroup_def1› = get_spec¨NormalSubgroupÆ;
val €kernel_def› = get_spec¨KernelÆ;
val €right_congruent_def› = get_spec¨RightCongruentÆ;
val €right_coset_def› = get_spec¨RightCosetÆ;
=TEX
%%%%
%%%%
%%%%
=SML
open_theory"group_egs";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙", "'Ø"];
=TEX
=SML
val €˙_plus_def› = ±_left_elim(get_spec¨˙_plusÆ);
val €˙_units_def› = ±_right_elim(get_spec¨˙_unitsÆ);
=TEX
=SML
set_goal([], ¨
	˙_plus ç Group
Æ);
a(rewrite_tac[˙_plus_def, group_def, group_ops_def, ˙_plus_assoc_thm]);
val €˙_group_thm› = save_pop_thm "˙_group_thm";
=TEX
=SML
set_goal([], ¨
	˙_units ç Group
Æ);
a(rewrite_tac[˙_units_def, group_def, group_ops_def, ˙_times_assoc_thm]);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[] THEN
	all_var_elim_asm_tac1 THEN all_asm_ante_tac THEN rewrite_tac[]);
val €˙_ones_group_thm› = save_pop_thm "˙_ones_group_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
=SML
open_theory"groups";
set_merge_pcs["basic_hol1", "'sets_alg"];
=TEX
=SML
set_goal([], ¨
	µG x∑
	G ç Group ± x ç Car G
¥	(x õ~)G ç Car G
±	(x.One G) G = x
±	(One G.x)G = x
±	((x õ~)G . x) G = One G
±	(x . (x õ~)G) G = One G
Æ);
a(rewrite_tac[group_def] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val €group_clauses1› = save_pop_thm"group_clauses1";
=TEX
=SML
set_goal([], ¨
	µG x y z∑
	G ç Group ± x ç Car G ± y ç Car G
¥	(x.y)G ç Car G
±	µz∑ z ç Car G ¥ ((x.y)G.z)G = (x. (y.z)G)G
Æ);
a(rewrite_tac[group_def] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val €group_clauses2› =  save_pop_thm"group_clauses2";
=TEX
=SML
set_goal([], ¨
	µG x y∑
	G ç Group ± x ç Car G ± y ç Car G
¥	(x = y § (x.(y õ~)G)G = One G)
Æ);
a(REPEAT strip_tac THEN1
	(ALL_FC_T asm_rewrite_tac[group_clauses1]));
a(LEMMA_T ¨((x . (y õ~) G) G .y)G = (One G.y)GÆ ante_tac THEN1 asm_rewrite_tac[]);
a(lemma_tac¨(y õ~)G  ç Car GÆ THEN1 all_fc_tac[group_clauses1]);
a(ALL_FC_T rewrite_tac[group_clauses1, group_clauses2]);
val €group_eq_thm› = save_pop_thm"group_eq_thm";
=TEX
=SML
set_goal([], ¨
	µG x y∑
	G ç Group ± x ç Car G ± y ç Car G
¥	(x = y § ((x õ~)G.y)G = One G)
Æ);
a(REPEAT strip_tac THEN1
	(ALL_FC_T asm_rewrite_tac[group_clauses1]));
a(LEMMA_T ¨(x.((x õ~) G . y) G)G = (x.One G)GÆ ante_tac THEN1 asm_rewrite_tac[]);
a(lemma_tac¨(x õ~)G  ç Car GÆ THEN1 all_fc_tac[group_clauses1]);
a(ALL_FC_T rewrite_tac[group_clauses1, 
	conv_rule (ONCE_MAP_C eq_sym_conv) group_clauses2]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val €group_eq_thm1› = save_pop_thm"group_eq_thm1";
=TEX
=SML
set_goal([], ¨
	µG x y z∑
	G ç Group ± x ç Car G ± y ç Car G ± z ç Car G
¥	( (x.y) G = (x.z) G § y = z)
Æ);
a(REPEAT strip_tac THEN_LIST [id_tac, asm_rewrite_tac[]]);
a(lemma_tac¨ (x õ~) G ç Car GÆ THEN1 all_fc_tac[group_clauses1]);
a(LEMMA_T¨(( (x õ~) G. x) G. y) G = (( (x õ~) G. x) G. z) G Æ ante_tac THEN1
	ALL_FC_T asm_rewrite_tac[group_clauses2]);
a(ALL_FC_T rewrite_tac[group_clauses1]);
val €left_cancel_thm› = save_pop_thm"left_cancel_thm";
=TEX
=SML
set_goal([], ¨
	µG x y z∑
	G ç Group ± x ç Car G
¥	((x õ~)G õ~)G = x
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨ (x õ~) G ç Car GÆ THEN1 all_fc_tac[group_clauses1]);
a(lemma_tac¨ ((x õ~) G. (((x õ~)G õ~)G)) G = ((x õ~) G. x)  G Æ THEN1
	ALL_FC_T asm_rewrite_tac[group_clauses1]);
a(lemma_tac¨ ((x õ~) G õ~)G ç Car GÆ THEN1 all_fc_tac[group_clauses1]);
a(all_fc_tac[left_cancel_thm]);
val €inverse_inverse_thm› = save_pop_thm"inverse_inverse_thm";
=TEX
=SML
set_goal([], ¨
	µG : 'a GROUP; x y∑
	G ç Group ± x ç Car G ± y ç Car G
¥	(x.((x õ~)G.y)G)G = y
±	((x õ~)G.(x.y)G)G = y
Æ);
a(REPEAT strip_tac THEN
	(lemma_tac¨((x:'a) õ~)G ç Car GÆ THEN1 all_fc_tac[group_clauses1]));
(* *** Goal "1" *** *)
a(LEMMA_T¨(x.((x õ~)G.y)G)G = ((x.(x õ~)G)G.y)GÆ rewrite_thm_tac THEN1
	ALL_FC_T rewrite_tac[group_clauses2]);
a(ALL_FC_T rewrite_tac[group_clauses1]);
(* *** Goal "2" *** *)
a(LEMMA_T¨((x õ~)G.(x.y)G)G = (((x õ~)G.x)G.y)GÆ rewrite_thm_tac THEN1
	ALL_FC_T rewrite_tac[group_clauses2]);
a(ALL_FC_T rewrite_tac[group_clauses1]);
val €group_clauses3› = save_pop_thm"group_clauses3";
=TEX
=SML
set_goal([], ¨
	µG x y∑
	G ç Group ± x ç Car G ± y ç Car G
¥	((x.y)G õ~)G = ((y õ~)G. (x õ~)G)G
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨(x.y)G ç Car G ±  (x õ~) G ç Car G  ±  (y õ~) G ç Car GÆ THEN1 
	(all_fc_tac[group_clauses1, group_clauses2] THEN REPEAT strip_tac));
a(lemma_tac¨((x.y)G.((x . y) G õ~) G)G = ((x.y)G.((y õ~) G . (x õ~) G) G)GÆ);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[group_clauses1]);
a(lemma_tac¨((y õ~) G . (x õ~) G) G ç Car GÆ THEN1 all_fc_tac[arb_gen group_clauses2]);
a(ALL_FC_T rewrite_tac[ group_clauses1,
	arb_gen group_clauses2, arb_gen group_clauses3]);
(* *** Goal "2" *** *)
a(lemma_tac¨((x . y) G õ~) G ç Car G ±  ((y õ~) G . (x õ~) G) G ç Car G Æ THEN1
	(all_fc_tac[arb_gen group_clauses1,
		arb_gen group_clauses2] THEN REPEAT strip_tac));
a(all_fc_tac[arb_gen left_cancel_thm]);
val €times_inverse_thm› = save_pop_thm"times_inverse_thm";
=TEX
=SML
set_goal([], ¨
	µG x y∑
	G ç Group ± x ç Car G ± y ç Car G
¥	((x.y)G = One G § y = (x õ~)G)
Æ);
a(REPEAT strip_tac THEN_LIST [id_tac,
	all_var_elim_asm_tac1 THEN all_fc_tac[group_clauses1]]);
a(lemma_tac¨(x.y) G = (x.(x õ~)G)GÆ THEN1
	ALL_FC_T asm_rewrite_tac[group_clauses1]);
a(lemma_tac¨(x õ~)G ç Car GÆ THEN1 all_fc_tac[group_clauses1]);
a(all_fc_tac[left_cancel_thm]);
val €inverse_unique_thm› = save_pop_thm"inverse_unique_thm";
=TEX
=SML
set_goal([], ¨
	µG∑
	G ç Group
¥	One G ç Car G
Æ);
a(rewrite_tac[group_def] THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
val €one_clauses_lemma› = pop_thm();
=TEX
=SML
set_goal([], ¨
	µG∑
	G ç Group
¥	One G ç Car G
±	((One G) õ~)G = One G
Æ);
a(REPEAT strip_tac THEN all_fc_tac[one_clauses_lemma]);
a(lemma_tac¨(One G.One G)G = One GÆ THEN1 ALL_FC_T rewrite_tac[group_clauses1]);
a(all_fc_tac[inverse_unique_thm]);
a(conv_tac eq_sym_conv THEN REPEAT strip_tac);
val €group_clauses4› = save_pop_thm"group_clauses4";
=TEX
=SML
set_goal([], ¨
	µG x y∑
	G ç Group ± x ç Car G ± y ç Car G
¥	( (x.y)G = x § y = One G )
Æ);
a(REPEAT strip_tac THEN_LIST [id_tac,
	all_var_elim_asm_tac1 THEN all_fc_tac[group_clauses1]]);
a(lemma_tac ¨(x . y) G = (x. One G) GÆ THEN1
	ALL_FC_T asm_rewrite_tac[group_clauses1]);
a(all_fc_tac[group_clauses4] THEN all_fc_tac[left_cancel_thm]);
val €one_unique_thm› = save_pop_thm"one_unique_thm";
=TEX
Some proof automation is now in order. A really good conditional rewriting tool could do
most of this automatically. Given the tools to hand, we create a customised conditional
rewriting tool.

The following two rules are lifted from WRK066; they probably belong in ProofPower.
=SML
fun €asm_±_intro_rule› (thm : THM) : THM = (
	case asms thm of
		(asm1::asm2::_) => (
		let	val thm1 = asm_rule (mk_±(asm1, asm2));
			val thm2 = ±_left_elim thm1;
			val thm3 = ±_right_elim thm1;
			val thm4 = prove_asm_rule thm2 thm;
			val thm5 = prove_asm_rule thm3 thm4;
		in	asm_±_intro_rule thm5
		end
	) | 	_ => thm
);
fun €all_undisch_rule› (thm : THM)  : THM = (
	all_undisch_rule (undisch_rule thm) handle Fail _ =>  thm
);
=TEX
Our customised rewriting tool will take terms constructed using the group operations (multiplication, inverse and unit) and put them in the ``free group normal form'' obtained by repeatedly applying the following (convergent) rewrite rules:

\begin{enumerate}
\item $(xy)^{-1} = y^{-1}{x^-1}
\item ${x^{-1}}^{-1} = x$
\item $x{x^-1} = 1$
\item ${x^-1x} = 1$
\item $x{x^-1}z = z$
\item ${x^-1x}z = z$
\item $(xy)z = x(yz)$
\item $x1 = 1x = x$
\end{enumerate}

The complication is that each of these rules depends on the operations actually being those of a group and on all the intermediate subexpressions being members of that group.
Typically the necessary side-condition can be simplified effectively by back-chaining with the theorems that say that the group is closed under multiplication and inverse and contains the unit element.
To deal with this we will set up the simplified side-condition as a lemma.
This will normally be a conjunction of atomic membership assertions which will all be assumptions of the goal being proved.

First of all we extract the lemmas we need from the various portmanteau theorems:
=SML
val all_thms =  (fc_canon( list_±_intro [
	group_clauses1,
	group_clauses2,
	inverse_inverse_thm,
	group_clauses3,
	times_inverse_thm,
	group_clauses4
]));
val eq_thms = map (all_undisch_rule o all_µ_elim o rewrite_rule[]) all_thms drop (not o is_eq o concl);
val ç_thms = map §_t_intro (map (all_undisch_rule o all_µ_elim o rewrite_rule[])
	all_thms drop (is_eq o concl));
=TEX
We derive equation contexts (efficient rewrite systems) from the two sets of lemmas:
=SML
val eq_eqn_cxt :EQN_CXT = map (fn th => (fst(dest_eq(concl th)), eq_match_conv th)) eq_thms;
val ç_eqn_cxt :EQN_CXT = map (fn th => (fst(dest_eq(concl th)), eq_match_conv th)) ç_thms;
=TEX
The corresponding conversions do one step of the expression rewriting or side-condition simplification:
=SML
val eq_rw_conv = eqn_cxt_conv eq_eqn_cxt;
val ç_rw_conv = eqn_cxt_conv ç_eqn_cxt;
=TEX
The following rule simplifies the assumptions by repeatedly looking for assumptions that can be simplified and simplifying them.
=SML
fun simplify_asm (thm : THM)  : THM = (
	let	fun try [] = fail "simplify_asm" 7061 []
		|   try (tm :: more) =(
			§_t_elim (ç_rw_conv tm)
			handle Fail _ => try more
		);
	in	prove_asm_rule (try (asms thm)) thm
	end
);
=TEX
That gives a general tactic for groups which is parametrised by a conversional to control how the the term structure is to be traversed:
=SML
fun gen_group_eq_tac (cnvl : CONV -> CONV) : TACTIC = (fn gl as (hyps, conc) =>
	let	val thm1 = cnvl eq_rw_conv conc;
		val thm2 = all_¥_intro (asm_±_intro_rule (iterate simplify_asm thm1));
		val lemma_tm = fst(dest_¥(concl thm2));
		fun thm_tac lemma_thm = (
			let	val thm3 = ¥_elim thm2 lemma_thm;
			in	conv_tac (simple_eq_match_conv thm3)
			end
		);
	in	LEMMA_T lemma_tm thm_tac gl
	end
);
=TEX
Next, we define the form we will use most frequently which uses the standard top-down traversal doing as much as you can at each node before doing sub-nodes.
=SML
val group_eq_tac : TACTIC = gen_group_eq_tac TOP_MAP_C;
=TEX
We also derive a tactic which will simplify assertions that expressions are members of a group:
=SML
fun gen_group_ç_tac (cnvl : CONV -> CONV) : TACTIC = (fn gl as (hyps, conc) =>
	let	val thm1 = cnvl ç_rw_conv conc;
		val thm2 = all_¥_intro (asm_±_intro_rule (iterate simplify_asm thm1));
		val lemma_tm = fst(dest_¥(concl thm2));
		fun thm_tac lemma_thm = (
			let	val thm3 = ¥_elim thm2 lemma_thm;
			in	conv_tac (simple_eq_match_conv thm3)
			end
		);
	in	LEMMA_T lemma_tm thm_tac gl
	end
);
val group_ç_tac : TACTIC = gen_group_ç_tac TOP_MAP_C;
=SML
set_goal([], ¨
	µG : 'a GROUP; H : 'b GROUP; f : 'a ≠ 'b∑
	G ç Group ± H ç Group ± f ç Homomorphism(G, H)
¥	f(One G) = One H
Æ);
a(rewrite_tac[homomorphism_def,
	group_ops_def] THEN
	REPEAT strip_tac);
a(lemma_tac ¨One G ç Car GÆ THEN1 all_fc_tac[group_clauses4]);
a(LEMMA_T ¨f( (One G.One G)G) = f(One G)Æ ante_tac THEN1
	(group_eq_tac THEN REPEAT strip_tac));
a(ALL_ASM_FC_T rewrite_tac[]);
a(REPEAT strip_tac);
a(lemma_tac¨f(One G) ç Car HÆ THEN1 all_asm_fc_tac[]);
a(all_fc_tac[one_unique_thm]);
val €homomorphism_one_thm› = save_pop_thm "homomorphism_one_thm";
=TEX
=SML
set_goal([], ¨
	µG : 'a GROUP; H : 'b GROUP; f : 'a ≠ 'b; x : 'a∑
	G ç Group ± H ç Group ± f ç Homomorphism(G, H) ± x ç Car G
¥	f((x õ~)G) = ((f x) õ~) H
Æ);
a(REPEAT strip_tac THEN all_fc_tac[homomorphism_one_thm] THEN all_asm_ante_tac THEN
	rewrite_tac[homomorphism_def,
		group_ops_def] THEN
		REPEAT strip_tac);
a(lemma_tac¨(x õ~) G ç Car GÆ THEN1 (group_ç_tac THEN REPEAT strip_tac));
a(lemma_tac¨f x ç Car HÆ THEN1 all_asm_fc_tac[]);
a(lemma_tac¨f ((x õ~) G) ç Car HÆ THEN1 all_asm_fc_tac[]);
a(LEMMA_T ¨f((x.(x õ~)G)G ) = One HÆ ante_tac THEN1 (group_eq_tac THEN REPEAT strip_tac));
a(ALL_ASM_FC_T rewrite_tac[]);
a(ALL_FC_T1 fc_§_canon rewrite_tac[inverse_unique_thm]);
val €homomorphism_inverse_thm› = save_pop_thm "homomorphism_inverse_thm";
=TEX
=SML
set_goal([], ¨
	µG : 'a GROUP; H : 'b GROUP; f : 'a ≠ 'b; x y : 'a∑
	G ç Group ± H ç Group ± f ç Homomorphism(G, H) ± x ç Car G ± y ç Car G
¥	 f ((x . y) G) = (f x . f y) H
Æ);
a(rewrite_tac[homomorphism_def,
		group_ops_def] THEN
		REPEAT strip_tac);
a(ALL_ASM_FC_T rewrite_tac[]);
val €homomorphism_times_thm› = save_pop_thm "homomorphism_times_thm";
=TEX
=SML
set_goal([], ¨
	µG : 'a GROUP; H : 'a GROUP; x y : 'a∑
	G ç Group ± H ç Subgroup G
¥	((x.y)H = (x.y)G)
±	One H = One G
±	(x ç Car H  ¥ (x õ~)H = (x õ~)G)
Æ);
a(rewrite_tac[subgroup_def1] THEN REPEAT µ_tac THEN ¥_tac);
a(lemma_tac¨One H ç Car HÆ THEN1 (group_ç_tac THEN REPEAT strip_tac));
a(lemma_tac¨One H ç Car GÆ THEN1 all_asm_fc_tac[]);
a(LEMMA_T¨(One H.One H)G = (One H.One H)HÆ ante_tac THEN1 asm_rewrite_tac[]);
a(group_eq_tac THEN1 strip_tac);
a(ALL_FC_T1 fc_§_canon rewrite_tac[one_unique_thm]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨(x õ~)H ç Car HÆ THEN1 (group_ç_tac THEN REPEAT strip_tac));
a(LEMMA_T¨(x.(x õ~)H)G = (x.(x õ~)H)HÆ ante_tac THEN1 asm_rewrite_tac[]);
a(asm_rewrite_tac[]);
val €subgroup_clauses› = save_pop_thm "subgroup_clauses";
=TEX
Without the custom tactics for groups, the first strip in the next theorem produces 13 subgoals rather than 4.
=SML
set_goal([], ¨
	µG : 'a GROUP; H : 'b GROUP; f : 'a ≠ 'b∑
	G ç Group ± H ç Group ± f ç Homomorphism(G, H)
¥	Kernel f (G, H) ç NormalSubgroup G
Æ);
a(rewrite_tac[kernel_def, normal_subgroup_def1, subgroup_def1, group_ops_def] THEN
	REPEAT strip_tac THEN1
	rewrite_tac[group_def, group_ops_def] THEN REPEAT strip_tac
	THEN_TRY (SOLVED_T ((group_eq_tac ORELSE group_ç_tac)THEN REPEAT strip_tac)));
(* *** Goal "1" *** *)
a(ALL_FC_T asm_rewrite_tac[group_clauses1, homomorphism_times_thm]);
a(all_fc_tac[group_clauses4]);
a(group_eq_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(all_fc_tac[homomorphism_one_thm]);
(* *** Goal "3" *** *)
a(ALL_FC_T asm_rewrite_tac[homomorphism_inverse_thm, group_clauses4]);
(* *** Goal "4" *** *)
a(lemma_tac¨(y õ~) G ç Car G ± (x.y) G ç Car GÆ THEN1 
	(group_ç_tac THEN REPEAT strip_tac));
a(ALL_FC_T asm_rewrite_tac[arb_gen homomorphism_times_thm,
	arb_gen homomorphism_inverse_thm]);
a(all_fc_tac[homomorphism_def]);
a(group_eq_tac THEN REPEAT strip_tac);
val €kernel_normal_subgroup_thm› = save_pop_thm "kernel_normal_subgroup_thm";
=TEX
=SML
set_goal([], ¨
	µG : 'a GROUP; H : 'a GROUP∑
	G ç Group ± H ç Subgroup G
¥	Equiv(Car G, RightCongruent H G)
Æ);
a(rewrite_tac[equiv_def, refl_def, sym_def, trans_def, right_congruent_def] THEN REPEAT strip_tac 
	THEN all_fc_tac[subgroup_def1]);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[group_clauses1]);
a(LEMMA_T ¨One G = One HÆ rewrite_thm_tac THEN1 ALL_FC_T rewrite_tac[subgroup_clauses]);
a(all_fc_tac [group_clauses4]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨((((x õ~) G . y) G)  õ~)H ç Car HÆ ante_tac
	THEN1 all_fc_tac[arb_gen group_clauses1]);
a(ALL_FC_T rewrite_tac[subgroup_clauses]);
a(lemma_tac¨(x õ~)G ç Car GÆ THEN1 all_fc_tac[group_clauses1]);
a(ALL_FC_T rewrite_tac[times_inverse_thm, inverse_inverse_thm]);
(* *** Goal "3" *** *)
a(LEMMA_T ¨(((x õ~) G . y) G . ((y õ~) G . z) G) H ç Car HÆ ante_tac
	THEN1 all_fc_tac[arb_gen group_clauses2]);
a(ALL_FC_T rewrite_tac[arb_gen subgroup_clauses]);
a(lemma_tac¨(x õ~)G ç Car GÆ THEN1 all_fc_tac[group_clauses1]);
a(lemma_tac¨(y õ~)G ç Car GÆ THEN1 all_fc_tac[group_clauses1]);
a(ALL_FC_T rewrite_tac[group_clauses2, arb_gen group_clauses3]);
val €right_congruent_equiv_thm› = save_pop_thm "right_congruent_equiv_thm";
=TEX
=SML
set_goal([], ¨
	µG : 'a GROUP; H : 'a GROUP∑
	G ç Group ± H ç NormalSubgroup G
¥	µy∑ y ç Car G ¥ (
		(Ãx∑ (Ãa b∑RightCoset H G ((a.b)G)) x y)
		Respects	(RightCongruent H G)
	) (Car G)
Æ);
a(rewrite_tac[respects_def, normal_subgroup_def1, right_coset_def, right_congruent_def,
	equiv_class_def]
	THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨(((y õ~)G.(((y' õ~)G.x)G.y)G)G.z)HÆ);
a(GET_NTH_ASM_T 8 (strip_asm_tac o rewrite_rule[subgroup_def1]));
a(group_ç_tac THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(GET_NTH_ASM_T 11 bc_thm_tac);
a(LEMMA_T ¨((y' õ~) G . x)G = (((x õ~)G.y')G õ~)HÆ rewrite_thm_tac
	THEN1 (asm_rewrite_tac[] THEN group_eq_tac THEN REPEAT strip_tac));
a(REPEAT strip_tac);
a(group_ç_tac THEN REPEAT strip_tac);
a(asm_rewrite_tac[] THEN group_eq_tac THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨(((y õ~)G.(((x õ~)G.y')G.y)G)G.z)HÆ);
a(GET_NTH_ASM_T 8 (strip_asm_tac o rewrite_rule[subgroup_def1]));
a(group_ç_tac THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(GET_NTH_ASM_T 11 bc_thm_tac);
a(REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[] THEN group_eq_tac THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(all_asm_fc_tac[]);
val €times_respects_right_congruent_lemma1› = save_pop_thm "times_respects_right_congruent_lemma1";
=TEX
=SML
set_goal([], ¨
	µG : 'a GROUP; H : 'a GROUP∑
	G ç Group ± H ç NormalSubgroup G
¥	µx∑ x ç Car G ¥ (
		(Ãy∑ (Ãa b∑RightCoset H G ((a.b)G)) x y)
		Respects	(RightCongruent H G)
	) (Car G)
Æ);
a(rewrite_tac[respects_def, normal_subgroup_def1, right_coset_def, right_congruent_def,
	equiv_class_def]
	THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨(((y õ~)G.x')G.z)HÆ);
a(GET_NTH_ASM_T 8 (strip_asm_tac o rewrite_rule[subgroup_def1]));
a(group_ç_tac THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(LEMMA_T ¨((y õ~) G . x')G = (((x' õ~)G.y)G õ~)HÆ rewrite_thm_tac
	THEN1 (asm_rewrite_tac[] THEN group_eq_tac THEN REPEAT strip_tac));
a(group_ç_tac THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(asm_rewrite_tac[] THEN group_eq_tac THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨(((x' õ~)G.y)G.z)HÆ);
a(GET_NTH_ASM_T 8 (strip_asm_tac o rewrite_rule[subgroup_def1]));
a(group_ç_tac THEN REPEAT strip_tac);
a(asm_rewrite_tac[] THEN group_eq_tac THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
val €times_respects_right_congruent_lemma2› = save_pop_thm "times_respects_right_congruent_lemma2";
=TEX
=SML
set_goal([], ¨
	µG : 'a GROUP; H : 'a GROUP∑
	G ç Group ± H ç NormalSubgroup G
¥	(
		(Ãa∑RightCoset H G ((a õ~)G))
		Respects	(RightCongruent H G)
	) (Car G)
Æ);
a(rewrite_tac[respects_def, normal_subgroup_def1, right_coset_def, right_congruent_def,
	equiv_class_def]
	THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨((y.(x õ~)G)G.z)HÆ);
a(GET_NTH_ASM_T 7 (strip_asm_tac o rewrite_rule[subgroup_def1]));
a(group_ç_tac THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(LEMMA_T ¨(y . (x õ~) G) G = (x .(((x õ~) G.y)G.(x õ~)G)G)GÆ rewrite_thm_tac
	THEN1 (group_eq_tac THEN REPEAT strip_tac));
a(LEMMA_T ¨x  = ((x õ~)G õ~)GÆ once_rewrite_thm_tac
	THEN1 (group_eq_tac THEN REPEAT strip_tac));
a(LEMMA_T ¨(((x õ~)G õ~)G õ~)G = (x õ~)GÆ once_rewrite_thm_tac
	THEN1 (group_eq_tac THEN REPEAT strip_tac));
a(GET_NTH_ASM_T 10 bc_thm_tac THEN REPEAT strip_tac);
a(group_ç_tac THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(asm_rewrite_tac[] THEN group_eq_tac THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨((x.(y õ~)G)G.z)HÆ);
a(GET_NTH_ASM_T 7 (strip_asm_tac o rewrite_rule[subgroup_def1]));
a(group_ç_tac THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(LEMMA_T ¨(x . (y õ~) G) G = (y .(((y õ~) G.x)G.(y õ~)G)G)GÆ rewrite_thm_tac
	THEN1 (group_eq_tac THEN REPEAT strip_tac));
a(LEMMA_T ¨y = ((y õ~)G õ~)GÆ once_rewrite_thm_tac
	THEN1 (group_eq_tac THEN REPEAT strip_tac));
a(LEMMA_T ¨(((y õ~)G õ~)G õ~)G = (y õ~)GÆ once_rewrite_thm_tac
	THEN1 (group_eq_tac THEN REPEAT strip_tac));
a(GET_NTH_ASM_T 10 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(LEMMA_T ¨((y õ~) G . x) G = (((x õ~) G . y) G õ~)HÆ rewrite_thm_tac
	THEN1 (asm_rewrite_tac[] THEN group_eq_tac THEN REPEAT strip_tac));
a(group_ç_tac THEN REPEAT strip_tac);
(* *** Goal "2.1.2" *** *)
a(group_ç_tac THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[] THEN group_eq_tac THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
val €inverse_respects_right_congruent_lemma› = save_pop_thm "inverse_respects_right_congruent_lemma";
=TEX
=SML
set_goal([], ¨
	µG : 'a GROUP; H : 'a GROUP; x : 'a∑
	G ç Group ± H ç Subgroup G ± x ç Car G
¥	RightCoset H G x = EquivClass(Car G, RightCongruent H G) x
Æ);
a(rewrite_tac[respects_def, subgroup_def1, right_coset_def, right_congruent_def,
	equiv_class_def]
	THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[] THEN group_ç_tac THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[] THEN group_eq_tac THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨((x õ~)G.x')GÆ THEN REPEAT strip_tac);
a(group_eq_tac THEN REPEAT strip_tac);
val €right_coset_equiv_class_thm› = save_pop_thm "right_coset_equiv_class_thm";
=TEX
=SML
(drop_main_goal(); ()) handle Fail _ => ();
push_consistency_goal¨QuotientGroupÆ;
a(prove_∂_tac THEN REPEAT strip_tac);
a(cases_tac¨G' ç Group ± H' ç NormalSubgroup G'Æ THEN asm_rewrite_tac[]);
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[normal_subgroup_def1]));
a(lemma_tac¨Equiv (Car G', RightCongruent H' G')Æ THEN1
	ALL_FC_T rewrite_tac[right_congruent_equiv_thm]);
a(LEMMA_T¨
	∂ times∑ µ A x B y∑
	A ç Car G' // RightCongruent H' G' ± x ç A ±
	B ç Car G' // RightCongruent H' G' ± y ç B
	¥ times A B =  (Ã a b∑ RightCoset H' G' ((a . b) G')) x yÆ 
	(strip_asm_tac o rewrite_rule[]) THEN1 bc_thm_tac dyadic_induced_fun_∂_thm);
 (* ** Goal "1" *** *)
a(REPEAT strip_tac THEN ALL_FC_T rewrite_tac[
	times_respects_right_congruent_lemma1,
	times_respects_right_congruent_lemma2]);
(* *** Goal "2" *** *)
a(LEMMA_T¨
	∂ inverse∑ µ A x∑ A ç Car G' // RightCongruent H' G' ± x ç A¥
	inverse A = (Ã a∑ RightCoset H' G' ((a õ~) G')) xÆ 
	(strip_asm_tac o rewrite_rule[]) THEN1 bc_thm_tac induced_fun_∂_thm);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac THEN ALL_FC_T rewrite_tac[inverse_respects_right_congruent_lemma]);
(* *** Goal "2.2" *** *)
a(∂_tac¨ (Car G' // RightCongruent H' G', times, inverse, RightCoset H' G' (One G'))Æ);
a(rewrite_tac[group_ops_def] THEN PC_T1 "sets_ext1" once_rewrite_tac[] THEN
	REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_fc_tac[quotient_rep_∂_thm]);
a(∂_tac¨x'Æ THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[right_coset_equiv_class_thm]);
a(all_fc_tac [quotient_map_onto_thm] THEN all_var_elim_asm_tac1);
a(ALL_FC_T1 fc_§_canon rewrite_tac[equiv_class_eq_thm]);
a(DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac[equiv_class_def]);
a(PC_T1 "sets_ext1" asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a(all_var_elim_asm_tac1);
a(ALL_FC_T rewrite_tac[right_coset_equiv_class_thm]);
a(rewrite_tac[quotient_set_def]);
a(∂_tac¨x'Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.3" *** *)
a(POP_ASM_T ante_tac THEN ALL_FC_T rewrite_tac[right_coset_equiv_class_thm]);
a(LEMMA_T ¨
	times
                 (EquivClass (Car G', RightCongruent H' G') x)
                 (EquivClass (Car G', RightCongruent H' G') y) =
	RightCoset H' G' ((x . y) G')Æ rewrite_thm_tac);
a(GET_NTH_ASM_T 4 bc_thm_tac);
a(ALL_FC_T rewrite_tac[equiv_class_ç_thm]);
a(rewrite_tac[quotient_set_def] THEN REPEAT strip_tac);
(* *** Goal "2.2.3.1" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.3.2" *** *)
a(∂_tac¨yÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.4" *** *)
a(ALL_FC_T rewrite_tac[right_coset_equiv_class_thm]);
a(LEMMA_T ¨
	times
                 (EquivClass (Car G', RightCongruent H' G') x)
                 (EquivClass (Car G', RightCongruent H' G') y) =
	RightCoset H' G' ((x . y) G')Æ asm_rewrite_thm_tac);
a(GET_NTH_ASM_T 5 bc_thm_tac);
a(ALL_FC_T rewrite_tac[equiv_class_ç_thm]);
a(rewrite_tac[quotient_set_def]  THEN REPEAT strip_tac);
(* *** Goal "2.2.4.1" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.4.2" *** *)
a(∂_tac¨yÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.5" *** *)
a(POP_ASM_T ante_tac THEN ALL_FC_T rewrite_tac[right_coset_equiv_class_thm]);
a(LEMMA_T ¨
	inverse(EquivClass (Car G', RightCongruent H' G') x) =
	RightCoset H' G' ((x õ~) G')Æ rewrite_thm_tac);
a(GET_NTH_ASM_T 2 bc_thm_tac);
a(ALL_FC_T rewrite_tac[equiv_class_ç_thm]);
a(rewrite_tac[quotient_set_def] THEN REPEAT strip_tac);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.6" *** *)
a(ALL_FC_T rewrite_tac[right_coset_equiv_class_thm]);
a(LEMMA_T ¨
	inverse(EquivClass (Car G', RightCongruent H' G') x) =
	RightCoset H' G' ((x õ~) G')Æ asm_rewrite_thm_tac);
a(GET_NTH_ASM_T 3 bc_thm_tac);
a(ALL_FC_T rewrite_tac[equiv_class_ç_thm]);
a(rewrite_tac[quotient_set_def] THEN REPEAT strip_tac);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
val _ = save_consistency_thm ¨QuotientGroupÆ (pop_thm());
val €quotient_group_def› = save_thm("quotient_group_def", get_spec¨QuotientGroupÆ);
=TEX
=SML
set_goal([], ¨
	µG : 'a GROUP; H : 'a GROUP∑
	G ç Group ± H ç NormalSubgroup G
¥	G // H ç Group
Æ);
a(REPEAT strip_tac THEN rewrite_tac[group_def]);
a(strip_asm_tac(list_µ_elim[¨HÆ, ¨GÆ]quotient_group_def));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨(x'.x'')GÆ THEN1 group_ç_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(lemma_tac¨(x'.x'') G ç Car G ± (x''.x''')G ç Car GÆ THEN1
	(group_ç_tac THEN REPEAT strip_tac));
a(ALL_ASM_FC_T rewrite_tac[]);
a(group_eq_tac THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(∂_tac¨One GÆ THEN group_ç_tac THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(all_var_elim_asm_tac1);
a(lemma_tac¨One G ç Car GÆ THEN1 (group_ç_tac THEN REPEAT strip_tac));
a(ALL_ASM_FC_T rewrite_tac[]);
a(group_eq_tac THEN REPEAT strip_tac);
(* *** Goal "5" *** *)
a(all_var_elim_asm_tac1);
a(lemma_tac¨One G ç Car GÆ THEN1 (group_ç_tac THEN REPEAT strip_tac));
a(ALL_ASM_FC_T rewrite_tac[]);
a(group_eq_tac THEN REPEAT strip_tac);
(* *** Goal "6" *** *)
a(∂_tac¨(x' õ~)GÆ THEN1 group_ç_tac THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "7" *** *)
a(lemma_tac¨(x' õ~)G ç Car GÆ THEN1 (group_ç_tac THEN REPEAT strip_tac));
a(all_var_elim_asm_tac1);
a(ALL_ASM_FC_T rewrite_tac[]);
a(group_eq_tac THEN REPEAT strip_tac);
(* *** Goal "8" *** *)
a(lemma_tac¨(x' õ~)G ç Car GÆ THEN1 (group_ç_tac THEN REPEAT strip_tac));
a(all_var_elim_asm_tac1);
a(ALL_ASM_FC_T rewrite_tac[]);
a(group_eq_tac THEN REPEAT strip_tac);
val €quotient_group_group_thm› = save_pop_thm "quotient_group_group_thm";
=TEX
%%%%
=TEX
%%%%
%%%%
%%%%
%%%%
=TEX
\subsection{Epilogue}\label{END}
} % matches turning off of HOL index entries.
=TEX
%%%%
%%%%
=SML
open_theory"group_egs";
output_theory{out_file="wrk0681.th.doc", theory="equiv_rel"};
output_theory{out_file="wrk0682.th.doc", theory="groups"};
output_theory{out_file="wrk0683.th.doc", theory="group_egs"};
open_theory "groups";
=TEX
\end{document}
=IGN
