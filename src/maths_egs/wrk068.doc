=IGN
********************************************************************************
wrk068.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=IGN
pp_make_database -f -p hol maths_egs
docsml wrk068
xpp wrk068.doc -d maths_egs -i wrk068 &
doctex wrk068 wrk068.th; texdvi -b wrk068; texdvi wrk068; texdvi wrk068
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\def\Lim{\mbox{{\sf lim}}}
\def\LimInf{\mbox{{\sf lim inf}}}
\def\LimSup{\mbox{{\sf lim sup}}}

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}

\def\LogName{\mbox{{\sf log}}}
\def\Log#1{\LogName(#1)}

\def\SinName{\mbox{{\sf sin}}}
\def\Sin#1{\SinName(#1)}

\def\CosName{\mbox{{\sf cos}}}
\def\Cos#1{\CosName(#1)}

\def\Abs#1{|#1|}

\def\ThmsII#1#2{%
{\vertbarfalse
\begin{minipage}[t]{0.48\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.48\hsize}
#2
\end{minipage}}}

\def\ThmsIII#1#2#3{%
{\vertbarfalse
\begin{minipage}[t]{0.32\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#2
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#3
\end{minipage}}}

\def\Hide#1{\relax}

\makeindex
\title{Mathematical Case Studies: \\ --- \\ Some Group Theory}
\author{Rob Arthan}
\makeindex
\author{R.D. Arthan \\ Lemma 1 Ltd. \\ rda@lemma-one.com}
\date{\FormatDate{$Date: 2004/04/12 14:39:52 $%
}}

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
This {\ProductHOL} script contains definitions and proofs concerning
group theory.

\end{abstract}
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd \number\year \\
Reference: LEMMA1/HOL/WRK068; issue $Revision: 1.1 $%


\end{centering}
\thispagestyle{empty}
\end{titlepage}
\newpage
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
\tableofcontents
%\newpage
%\subsection{Document cross references}

\subsection*{To Do}
\begin{itemize}

\item
Write the document!

\end{itemize}


\bibliographystyle{plain}
\bibliography{fmu}

%%%%
%%%%
%%%%
%%%%
\newpage
\section{INTRODUCTION}
%%%%
%%%%
%%%%
%%%%
This document gives specifications and proofs relating to group theory.
%%%%
%%%%
%%%%
%%%%
\section{AN OVERVIEW OF THE THEORY}

\subsection{Equivalence Relations}

\subsection{Technical Prelude}

First of all, we must give the the ML commands to  introduce the new theory ``equiv\_rel'' as a child of the theory ``orders'' of ordered sets (whence comes our definition of transitivity,
see \cite{LEMMA1/HOL/DTD115}).


=SML
force_delete_theory"equiv_rel" handle Fail _ => ();
open_theory"orders";
set_merge_pcs["basic_hol1", "'sets_alg"];
new_theory"equiv_rel";
=TEX
%%%%
%%%%
%%%%
%%%%

%%%%
%%%%
%%%%
%%%%
\subsubsection{The Definitions}
=SML
declare_infix(210, "¶");
πHOLCONST
‹ €Refl› : ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ BOOL
˜¸¸¸¸¸¸
‹ µ X $¶∑
‹	Refl(X, $¶)
‹ §	µx∑x ç X ¥ x ¶  x
∞
πHOLCONST
‹ €Sym› : ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ BOOL
˜¸¸¸¸¸¸
‹ µ X $¶∑
‹	Sym(X, $¶)
‹ §	µx y∑x ç X ± y ç X ± x ¶  y ¥ y ¶ x
∞
πHOLCONST
‹ €Equiv› : ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ BOOL
˜¸¸¸¸¸¸
‹ µ X $¶∑
‹	Equiv(X, $¶)
‹ §	Refl(X, $¶) ± Sym(X, $¶) ± Trans(X, $¶)
∞
πHOLCONST
‹ €EquivClass› : ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ 'a ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ X $¶ x∑
‹	EquivClass(X, $¶) x = {y | y ç X ± x ¶ y}
∞
=SML
declare_infix(300, "//");

πHOLCONST
‹ €$//› : 'a SET ≠ ('a ≠ 'a ≠ BOOL) ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ X $¶∑
‹	X // ($¶) = {A | ∂x∑ x ç X ± A = EquivClass(X, $¶) x}
∞
=SML
declare_infix(200, "Respects");

πHOLCONST
‹ €$Respects› : ('a ≠ 'b) ≠ ('a ≠ 'a ≠ BOOL) ≠ 'a SET ≠ BOOL
˜¸¸¸¸¸¸
‹ µ f $¶ X∑
‹	(f Respects $¶) X § µx y∑x ç X ± y ç X ± x ¶ y ¥ f x = f y
∞
πHOLCONST
‹ €$Contents› : 'a SET ≠ 'a
˜¸¸¸¸¸¸
‹ µ x∑ Contents {x} = x
∞

=SML
declare_postfix(330, "Á-Í");

πHOLCONST
‹ €$Á-Í› : ('a ≠ 'b) ≠ 'a  SET ≠ 'b
˜¸¸¸¸¸¸
‹ µ f A∑ (f Á-Í) A = Contents{y | ∂x∑  x ç A ± y = f x}
∞
\subsection{Groups}

\subsection{Technical Prelude}

First of all, we must give the the ML commands to  introduce the new theory ``groups'' as a child of the theory ``equiv\_rel'' of equivalence relations.

=SML
force_delete_theory"groups" handle Fail _ => ();
open_theory"equiv_rel";
new_theory"groups";
new_parent"˙";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙"];
=TEX
%%%%
%%%%
%%%%
%%%%

%%%%
%%%%
%%%%
%%%%
\subsubsection{The Definitions}
=SML
declare_infix(310, "><");
declare_infix(310, ">><<");

πHOLCONST
‹ €Group› : ('a SET ∏ ('a ≠ 'a ≠ 'a) ∏ ('a ≠ 'a) ∏ 'a) SET
˜¸¸¸¸¸¸
‹ µ G $>< -- e∑
‹	(G, $><, --, e) ç Group
‹ §	(µx y z∑x ç G ± y ç G ± z ç G ¥ (x >< y) >< z = x >< y >< z)
‹ ±	e ç G
‹ ±	(µx∑ x ç G ¥ x >< e = x ± e >< x = x)
‹ ±	(µx∑ x ç G ¥ x >< -- x = e ± -- x >< x = e)
‹
∞

\newpage

%%%%
%%%%
%%%%
%%%%
{\let\Section\section
\def\section#1{\Section{#1}}
\include{wrk0681.th}
\include{wrk0682.th}
}  %\let

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document}

{\HOLindexOff
%%%%
%%%%
%%%%
%%%%
\onecolumn
\section{THEOREMS}\label{THEOREMS}
=SML
fun arb_gen (thm : THM) : THM = (
	let	val ty_map = map
			(fn tv => (mk_vartype("@_" ^ tv), mk_vartype tv))
			(term_tyvars(concl thm));
		val thm1 = asm_inst_type_rule ty_map thm;
	in	all_µ_intro (all_µ_arb_elim thm1)
	end
);
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{The Definitions and Their Consistency}
%%%%
%%%%
%%%%
%%%%
=SML
open_theory"equiv_rel";
set_merge_pcs["basic_hol1", "'sets_alg"];
val €refl_def› = get_spec¨ReflÆ;
val €sym_def› = get_spec¨SymÆ;
val €equiv_def› = get_spec¨EquivÆ;
val €equiv_class_def› = get_spec¨EquivClassÆ;
val €quotient_def› = get_spec¨$//Æ;
val €respects_def› = get_spec¨$RespectsÆ;
val €induced_def› = get_spec¨$Á-ÍÆ;
=SML
push_consistency_goal ¨ContentsÆ;
a(∂_tac¨ÃA∑≈x∑A = {x}Æ THEN REPEAT strip_tac THEN rewrite_tac[]);
a(all_≈_tac);
(* *** Goal "1" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext" REPEAT strip_tac);
a(POP_ASM_T (ante_tac o µ_elim¨xÆ));
a(rewrite_tac[] THEN STRIP_T (rewrite_thm_tac o eq_sym_rule));
val _ = save_consistency_thm ¨ContentsÆ (pop_thm());
val €contents_def› = save_thm("contents_def", get_spec¨$ContentsÆ);
=TEX
%%%%
%%%%
%%%%
%%%%
%%%%
%%%%
%%%%
%%%%
=SML
set_goal([], ¨
	µX; $¶; x y∑
	Equiv(X, $¶) ± x ç X ± y ç X ¥
	(EquivClass(X, $¶)  x = EquivClass(X, $¶) y § x ¶ y)
Æ);
a(PC_T1 "sets_ext1" rewrite_tac[equiv_class_def, equiv_def, sym_def, refl_def, trans_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 5 bc_thm_tac THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 1 (ante_tac o µ_elim¨xÆ));
a(ALL_ASM_FC_T asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(REPEAT (all_asm_fc_tac[]));
(* *** Goal "3" *** *)
a(REPEAT (all_asm_fc_tac[]));
val €equiv_class_eq_thm› = save_pop_thm "equiv_class_eq_thm";
=TEX
=SML
set_goal([], ¨
	µA a c∑
		a ç A ± (µx∑x ç A ¥ f x = c)
	¥	{y | ∂x∑x ç A ± y = f x} = {c}
Æ);
a(PC_T1 "sets_ext1"  REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
(* *** Goal "2" *** *)
a(∂_tac¨aÆ THEN REPEAT strip_tac);
a(ALL_ASM_FC_T asm_rewrite_tac[]);
val €constant_image_thm› = save_pop_thm "constant_image_thm";
=TEX
=SML
set_goal([], ¨
	µX $¶ f x∑
		Equiv(X, $¶)
	±	(f Respects $¶) X
	±	x ç X
	¥	{y | ∂z∑z ç EquivClass(X, $¶) x ± y = f z} = {f x}
Æ);
a(REPEAT strip_tac);
a(bc_thm_tac constant_image_thm);
a(∂_tac¨xÆ THEN all_asm_ante_tac);
a(PC_T1 "sets_ext1" rewrite_tac[ respects_def,
	equiv_class_def, equiv_def, sym_def, refl_def, trans_def]
		THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(ALL_ASM_FC_T rewrite_tac[]);
val €respects_image_thm› = save_pop_thm "respects_image_thm";
=TEX
=SML
set_goal([], ¨
	µX $¶ f x∑
		Equiv(X, $¶)
	±	(f Respects $¶) X
	±	x ç X
	¥	Contents {y | ∂z∑z ç EquivClass(X, $¶) x ± y = f z} = f x
Æ);
a(REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[arb_gen respects_image_thm]);
a(rewrite_tac[contents_def]);
val €respects_image_contents_thm› = save_pop_thm "respects_image_contents_thm";
=TEX
=SML
set_goal([], ¨
	µX $¶∑
		Equiv(X, $¶)
	¥	µA∑ A ç X // ($¶) ¥ ∂x∑ x ç X ± A = EquivClass(X, $¶) x

Æ);
a(rewrite_tac[ quotient_def]);
val €quotient_map_onto_thm› = save_pop_thm "quotient_map_onto_thm";
=TEX
=SML
set_goal([], ¨
	µX f∑ Equiv(X, (Ãx y∑f x = f y))
Æ);
a(PC_T1 "sets_ext1" rewrite_tac[ equiv_def, sym_def, refl_def, trans_def]
		THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
val €equiv_fun_thm› = save_pop_thm "equiv_fun_thm";
=TEX
=SML
set_goal([], ¨
	µX f∑ (f Respects (Ãx y∑f x = f y)) X
Æ);
a(rewrite_tac[ respects_def] THEN REPEAT strip_tac);
val €respects_fun_thm› = save_pop_thm "respects_fun_thm";
=TEX
=SML
set_goal([], ¨
	µX : 'a SET; f : 'a ≠ 'b∑ ∂g : 'a SET ≠ 'b∑
		µx:'a∑ x ç X ¥ g(EquivClass(X, (Ãx y∑f x = f y)) x)  = f x
Æ);
a(REPEAT strip_tac);
a(∂_tac¨ÃA∑Contents{ y | ∂z∑z ç A ± y = f z}Æ THEN REPEAT strip_tac THEN rewrite_tac[]);
a(bc_thm_tac respects_image_contents_thm);
a(asm_rewrite_tac[equiv_fun_thm, respects_fun_thm]);
val €fun_factors_thm› = save_pop_thm "fun_factors_thm";
=TEX
=SML
set_goal([], ¨
	µX : 'a SET; f : 'a ≠ 'b; g1 g2 : 'a SET ≠ 'b∑
		(µx:'a∑ x ç X ¥ g1(EquivClass(X, (Ãx y∑f x = f y)) x)  = f x)
	±	(µx:'a∑ x ç X ¥ g2(EquivClass(X, (Ãx y∑f x = f y)) x)  = f x)
	¥	µA∑A ç X //  (Ãx y∑f x = f y) ¥ g1 A = g2 A
Æ);
a(rewrite_tac[quotient_def] THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(ALL_ASM_FC_T rewrite_tac[]);
val €fun_factors_unique_thm› = save_pop_thm "fun_factors_unique_thm";
=TEX
=SML
set_goal([], ¨
	µX $¶ f x∑
		Equiv(X, $¶)
	±	(f Respects $¶) X
	±	x ç X
	¥	(f Á-Í) (EquivClass(X, $¶) x) = f x
Æ);
a(rewrite_tac[induced_def] THEN REPEAT strip_tac);
a(bc_thm_tac respects_image_contents_thm THEN REPEAT strip_tac);
val €induced_fun_thm› = save_pop_thm "induced_fun_thm";
=TEX
=SML
open_theory"groups";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙"];
=TEX
=SML
val €group_def› = get_spec¨GroupÆ;
=TEX
=SML
set_goal([], ¨
	(Universe, $+, ~, Ó˙ 0) ç Group
Æ);
a(rewrite_tac[group_def, ˙_plus_assoc_thm]);
val €˙_group_thm› = save_pop_thm "˙_group_thm";
=TEX
=SML
set_goal([], ¨
	({~(Ó˙ 1); Ó˙ 1}, $*, (Ãx∑x), Ó˙ 1) ç Group
Æ);
a(rewrite_tac[group_def, ˙_times_assoc_thm]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val €˙_units_group_thm› = save_pop_thm "˙_units_group_thm";

=TEX
%%%%
%%%%
%%%%
%%%%
=TEX
\subsection{Epilogue}\label{END}
} % matches turning off of HOL index entries.
=TEX
%%%%
%%%%
=SML
output_theory{out_file="wrk0681.th.doc", theory="equiv_rel"};
output_theory{out_file="wrk0682.th.doc", theory="groups"};
=TEX
\end{document}
=IGN
