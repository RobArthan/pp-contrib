=IGN
********************************************************************************
wrk068.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=IGN
pp_make_database -f -p hol maths_egs
docsml wrk068
xpp wrk068.doc -d maths_egs -i wrk068 &
doctex wrk068 wrk068.th; texdvi -b wrk068; texdvi wrk068; texdvi wrk068
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\def\Lim{\mbox{{\sf lim}}}
\def\LimInf{\mbox{{\sf lim inf}}}
\def\LimSup{\mbox{{\sf lim sup}}}

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}

\def\LogName{\mbox{{\sf log}}}
\def\Log#1{\LogName(#1)}

\def\SinName{\mbox{{\sf sin}}}
\def\Sin#1{\SinName(#1)}

\def\CosName{\mbox{{\sf cos}}}
\def\Cos#1{\CosName(#1)}

\def\Abs#1{|#1|}

\def\ThmsII#1#2{%
{\vertbarfalse
\begin{minipage}[t]{0.48\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.48\hsize}
#2
\end{minipage}}}

\def\ThmsIII#1#2#3{%
{\vertbarfalse
\begin{minipage}[t]{0.32\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#2
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#3
\end{minipage}}}

\def\Hide#1{\relax}

\makeindex
\title{Mathematical Case Studies: \\ --- \\ Some Group Theory}
\author{Rob Arthan}
\makeindex
\author{R.D. Arthan \\ Lemma 1 Ltd. \\ rda@lemma-one.com}
\date{\FormatDate{$Date: 2004/04/17 16:02:32 $%
}}

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
This {\ProductHOL} script contains definitions and proofs concerning
group theory.

\end{abstract}
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd \number\year \\
Reference: LEMMA1/HOL/WRK068; issue $Revision: 1.3 $%


\end{centering}
\thispagestyle{empty}
\end{titlepage}
\newpage
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
\tableofcontents
%\newpage
%\subsection{Document cross references}

\subsection*{To Do}
\begin{itemize}

\item
Write the document!

\end{itemize}


\bibliographystyle{plain}
\bibliography{fmu}

%%%%
%%%%
%%%%
%%%%
\newpage
\section{INTRODUCTION}
%%%%
%%%%
%%%%
%%%%
This document gives specifications and proofs relating to group theory.
%%%%
%%%%
%%%%
%%%%
\section{AN OVERVIEW OF THE THEORY}

\subsection{Equivalence Relations}

\subsection{Technical Prelude}

First of all, we must give the the ML commands to  introduce the new theory ``equiv\_rel'' as a child of the theory ``orders'' of ordered sets (whence comes our definition of transitivity,
see \cite{LEMMA1/HOL/DTD115}).


=SML
force_delete_theory"equiv_rel" handle Fail _ => ();
open_theory"orders";
set_merge_pcs["basic_hol1", "'sets_alg"];
new_theory"equiv_rel";
=TEX
%%%%
%%%%
%%%%
%%%%

%%%%
%%%%
%%%%
%%%%
\subsubsection{The Definitions}
=SML
declare_infix(210, "¦");
¹HOLCONST
Ü ÛReflÝ : ('a SET ¸ ('a ­ 'a ­ BOOL)) ­ BOOL
÷üüüüüü
Ü µ X $¦·
Ü	Refl(X, $¦)
Ü ¤	µx·x  X ´ x ¦  x
°
¹HOLCONST
Ü ÛSymÝ : ('a SET ¸ ('a ­ 'a ­ BOOL)) ­ BOOL
÷üüüüüü
Ü µ X $¦·
Ü	Sym(X, $¦)
Ü ¤	µx y·x  X ± y  X ± x ¦  y ´ y ¦ x
°
¹HOLCONST
Ü ÛEquivÝ : ('a SET ¸ ('a ­ 'a ­ BOOL)) ­ BOOL
÷üüüüüü
Ü µ X $¦·
Ü	Equiv(X, $¦)
Ü ¤	Refl(X, $¦) ± Sym(X, $¦) ± Trans(X, $¦)
°
¹HOLCONST
Ü ÛEquivClassÝ : ('a SET ¸ ('a ­ 'a ­ BOOL)) ­ 'a ­ 'a SET
÷üüüüüü
Ü µ X $¦ x·
Ü	EquivClass(X, $¦) x = {y | y  X ± x ¦ y}
°
=SML
declare_infix(300, "//");

¹HOLCONST
Ü Û$//Ý : 'a SET ­ ('a ­ 'a ­ BOOL) ­ 'a SET SET
÷üüüüüü
Ü µ X $¦·
Ü	X // ($¦) = {A | ¶x· x  X ± A = EquivClass(X, $¦) x}
°
=SML
declare_infix(200, "Respects");

¹HOLCONST
Ü Û$RespectsÝ : ('a ­ 'b) ­ ('a ­ 'a ­ BOOL) ­ 'a SET ­ BOOL
÷üüüüüü
Ü µ f $¦ X·
Ü	(f Respects $¦) X ¤ µx y·x  X ± y  X ± x ¦ y ´ f x = f y
°
¹HOLCONST
Ü Û$ContentsÝ : 'a SET ­ 'a
÷üüüüüü
Ü µ x· Contents {x} = x
°

=SML
declare_postfix(330, "ç-ê");

¹HOLCONST
Ü Û$ç-êÝ : ('a ­ 'b) ­ 'a  SET ­ 'b
÷üüüüüü
Ü µ f A· (f ç-ê) A = Contents{y | ¶x·  x  A ± y = f x}
°
\subsection{Groups}

\subsection{Technical Prelude}

First of all, we must give the the ML commands to  introduce the new theory ``groups'' as a child of the theory ``equiv\_rel'' of equivalence relations.

=SML
force_delete_theory"groups" handle Fail _ => ();
open_theory"equiv_rel";
new_theory"groups";
set_merge_pcs["basic_hol1", "'sets_alg"];
=TEX
%%%%
%%%%
%%%%
%%%%

%%%%
%%%%
%%%%
%%%%
\subsubsection{The Definitions}
=SML
declare_infix(310, ".");
declare_postfix(330, "›~");
declare_type_abbrev("GROUP", ["'a"], ”'a SET ¸ ('a ­ 'a ­ 'a) ¸ ('a ­ 'a) ¸ 'a®);


¹HOLCONST
Ü ÛCarÝ :  'a GROUP ­ 'a SET;
Ü Û$.Ý :  'a ­ 'a ­ 'a GROUP ­ 'a;
Ü Û$›~Ý :  'a ­ 'a GROUP ­ 'a;
Ü ÛOneÝ :  'a GROUP ­ 'a
÷üüüüüü
Ü µ set times inverse one·
Ü	Car (set, times, inverse, one) = set
Ü ±	(µx y· (x . y) (set, times, inverse, one) = times x y)
Ü ±	(µx· (x ›~) (set, times, inverse, one) = inverse x)
Ü ±	One (set, times, inverse, one) = one
°
¹HOLCONST
Ü ÛGroupÝ : ('a SET ¸ ('a ­ 'a ­ 'a) ¸ ('a ­ 'a) ¸ 'a) SET
÷üüüüüü
Ü µ G·
Ü	G  Group
Ü ¤	(µx y· x  Car G ± y  Car G ´ (x . y) G  Car G)
Ü ±	(µx y z· x  Car G ± y  Car G ± z  Car G ´ ((x . y)G . z)G = (x . (y . z)G)G)
Ü ±	One G  Car G
Ü ±	(µx· x  Car G ´ (x . One G) G = x ± (One G . x)G = x)
Ü ±	(µx· x  Car G ´ (x ›~) G  Car G)
Ü ±	(µx· x  Car G ´ (x . (x ›~)G)G = One G ± ((x ›~)G . x)G = One G)
°

¹HOLCONST
Ü ÛHomomorphismÝ : 'a GROUP ¸ 'b GROUP ­ ('a ­ 'b) SET
÷üüüüüü
Ü µ G H f·
Ü	f  Homomorphism(G, H)
Ü ¤	(µx · x  Car G ´ f x  Car H)
Ü ±	(µx y· x  Car G ± y  Car G´ f((x . y) G) = (f x . f y)H)
°
¹HOLCONST
Ü ÛSubgroupÝ : 'a GROUP  ­ 'a GROUP SET
÷üüüüüü
Ü µ G H·
Ü	H  Subgroup G
Ü ¤	Car H € Car G
Ü ±	H  Group
Ü ±	(µx y·  (x.y)H = (x.y)G)
Ü ±	(µx·  (x ›~)H = (x ›~)G)
°
¹HOLCONST
Ü ÛNormalSubgroupÝ : 'a GROUP  ­ 'a GROUP SET
÷üüüüüü
Ü µ G H·
Ü	H  NormalSubgroup G
Ü ¤	H  Subgroup G
Ü ±	(µx y· x  Car H ± y  Car G ´ ((y ›~)G.(x.y)G)G  Car H)
°
¹HOLCONST
Ü ÛKernelÝ : ('a ­ 'b) ­ 'a GROUP ¸ 'b GROUP­ 'a GROUP
÷üüüüüü
Ü µ f G H·
Ü	Kernel f (G, H)
Ü =	({x | x  Car G ± f x = One H}, (Ìx y· (x . y)G), (Ìx·(x ›~) G), One G)
°

¹HOLCONST
Ü ÛRightCongruentÝ :'a GROUP ­ 'a GROUP ­ 'a ­ 'a ­ BOOL
÷üüüüüü
Ü µ H G x y· RightCongruent H G x y ¤ ((x ›~) G . y) G  Car H
°

¹HOLCONST
Ü ÛRightCosetÝ :'a GROUP ­ 'a GROUP­ 'a ­ 'a SET
÷üüüüüü
Ü µ H G x· RightCoset H G x = EquivClass(Car G, RightCongruent H G) x
°


\newpage
\subsection{Examples of Groups}

\subsection{Technical Prelude}

First of all, we must give the the ML commands to  introduce the new theory ``group\_egs'' as a child of the theory `groups'' of groups.

=SML
force_delete_theory"group_egs" handle Fail _ => ();
open_theory"groups";
new_theory"group_egs";
new_parent"¯";
set_merge_pcs["basic_hol1", "'sets_alg", "'ú", "'¯"];
=TEX
%%%%
%%%%
%%%%
%%%%

%%%%
%%%%
%%%%
%%%%
\subsubsection{The Definitions}
=SML


¹HOLCONST
Ü Ûú_plusÝ :  ú GROUP;
Ü Ûú_unitsÝ :  ú GROUP
÷üüüüüü
Ü	ú_plus = (Universe, $+, ~, îú 0)
Ü ±	ú_units = ({~(îú 1); îú 1}, $*, (Ìx·x), îú 1)
°

%%%%
%%%%
%%%%
%%%%
{\let\Section\section
\def\section#1{\Section{#1}}
\include{wrk0681.th}
\include{wrk0682.th}
\include{wrk0683.th}
}  %\let

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document}

{\HOLindexOff
%%%%
%%%%
%%%%
%%%%
\onecolumn
\section{THEOREMS}\label{THEOREMS}
=SML
fun arb_gen (thm : THM) : THM = (
	let	val ty_map = map
			(fn tv => (mk_vartype("@_" ^ tv), mk_vartype tv))
			(term_tyvars(concl thm));
		val thm1 = asm_inst_type_rule ty_map thm;
	in	all_µ_intro (all_µ_arb_elim thm1)
	end
);
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{The Definitions and Their Consistency}
%%%%
%%%%
%%%%
%%%%
=SML
open_theory"equiv_rel";
set_merge_pcs["basic_hol1", "'sets_alg"];
=TEX
=SML
val Ûrefl_defÝ = get_spec¬Refl®;
val Ûsym_defÝ = get_spec¬Sym®;
val Ûequiv_defÝ = get_spec¬Equiv®;
val Ûequiv_class_defÝ = get_spec¬EquivClass®;
val Ûquotient_defÝ = get_spec¬$//®;
val Ûrespects_defÝ = get_spec¬$Respects®;
val Ûinduced_defÝ = get_spec¬$ç-ê®;
=SML
push_consistency_goal ¬Contents®;
a(¶_tac¬ÌA·Åx·A = {x}® THEN REPEAT strip_tac THEN rewrite_tac[]);
a(all_Å_tac);
(* *** Goal "1" *** *)
a(¶_tac¬x® THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext" REPEAT strip_tac);
a(POP_ASM_T (ante_tac o µ_elim¬x®));
a(rewrite_tac[] THEN STRIP_T (rewrite_thm_tac o eq_sym_rule));
val _ = save_consistency_thm ¬Contents® (pop_thm());
val Ûcontents_defÝ = save_thm("contents_def", get_spec¬$Contents®);
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Equivalence Relations}
%%%%
%%%%
%%%%
%%%%
=SML
set_goal([], ¬
	µX; $¦; x y·
	Equiv(X, $¦) ± x  X ± y  X ´
	(EquivClass(X, $¦)  x = EquivClass(X, $¦) y ¤ x ¦ y)
®);
a(PC_T1 "sets_ext1" rewrite_tac[equiv_class_def, equiv_def, sym_def, refl_def, trans_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 5 bc_thm_tac THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 1 (ante_tac o µ_elim¬x®));
a(ALL_ASM_FC_T asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(REPEAT (all_asm_fc_tac[]));
(* *** Goal "3" *** *)
a(REPEAT (all_asm_fc_tac[]));
val Ûequiv_class_eq_thmÝ = save_pop_thm "equiv_class_eq_thm";
=TEX
=SML
set_goal([], ¬
	µX; $¦; x y·
	Equiv(X, $¦) ± x  X ´ x  EquivClass(X, $¦) x
®);
a(PC_T1 "sets_ext1" rewrite_tac[equiv_class_def, equiv_def, sym_def, refl_def, trans_def]
	THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
val Ûequiv_class__thmÝ = save_pop_thm "equiv_class__thm";
=TEX
=SML
set_goal([], ¬
	µA a c·
		a  A ± (µx·x  A ´ f x = c)
	´	{y | ¶x·x  A ± y = f x} = {c}
®);
a(PC_T1 "sets_ext1"  REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
(* *** Goal "2" *** *)
a(¶_tac¬a® THEN REPEAT strip_tac);
a(ALL_ASM_FC_T asm_rewrite_tac[]);
val Ûconstant_image_thmÝ = save_pop_thm "constant_image_thm";
=TEX
=SML
set_goal([], ¬
	µX $¦ f x·
		Equiv(X, $¦)
	±	(f Respects $¦) X
	±	x  X
	´	{y | ¶z·z  EquivClass(X, $¦) x ± y = f z} = {f x}
®);
a(REPEAT strip_tac);
a(bc_thm_tac constant_image_thm);
a(¶_tac¬x® THEN all_asm_ante_tac);
a(PC_T1 "sets_ext1" rewrite_tac[ respects_def,
	equiv_class_def, equiv_def, sym_def, refl_def, trans_def]
		THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(ALL_ASM_FC_T rewrite_tac[]);
val Ûrespects_image_thmÝ = save_pop_thm "respects_image_thm";
=TEX
=SML
set_goal([], ¬
	µX $¦ f x·
		Equiv(X, $¦)
	±	(f Respects $¦) X
	±	x  X
	´	Contents {y | ¶z·z  EquivClass(X, $¦) x ± y = f z} = f x
®);
a(REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[arb_gen respects_image_thm]);
a(rewrite_tac[contents_def]);
val Ûrespects_image_contents_thmÝ = save_pop_thm "respects_image_contents_thm";
=TEX
=SML
set_goal([], ¬
	µX $¦·
		Equiv(X, $¦)
	´	µA· A  X // ($¦) ´ ¶x· x  X ± A = EquivClass(X, $¦) x

®);
a(rewrite_tac[ quotient_def]);
val Ûquotient_map_onto_thmÝ = save_pop_thm "quotient_map_onto_thm";
=TEX
=SML
set_goal([], ¬
	µX $¦· A  X // ($¦) ± x  A ´ x  X
®);
a(rewrite_tac[ quotient_def, equiv_class_def] THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
val Ûquotient__thmÝ = save_pop_thm "quotient__thm";
=TEX
=SML
set_goal([], ¬
	µX $¦·
		Equiv(X, $¦)
	´	A  X // ($¦) ´ ¶x· x  X ± x  A
®);
a(rewrite_tac[ quotient_def, equiv_class_def, equiv_def, refl_def] THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(¶_tac¬x® THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val Ûquotient_rep_¶_thmÝ = save_pop_thm "quotient_rep_¶_thm";
=TEX
=SML
set_goal([], ¬
	µX f· Equiv(X, (Ìx y·f x = f y))
®);
a(PC_T1 "sets_ext1" rewrite_tac[ equiv_def, sym_def, refl_def, trans_def]
		THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
val Ûequiv_fun_thmÝ = save_pop_thm "equiv_fun_thm";
=TEX
=SML
set_goal([], ¬
	µX f· (f Respects (Ìx y·f x = f y)) X
®);
a(rewrite_tac[ respects_def] THEN REPEAT strip_tac);
val Ûrespects_fun_thmÝ = save_pop_thm "respects_fun_thm";
=TEX
=SML
set_goal([], ¬
	µX $¦ f x·
		Equiv(X, $¦)
	±	(f Respects $¦) X
	±	x  X
	´	(f ç-ê) (EquivClass(X, $¦) x) = f x
®);
a(rewrite_tac[induced_def] THEN REPEAT strip_tac);
a(bc_thm_tac respects_image_contents_thm THEN REPEAT strip_tac);
val Ûinduced_fun_thm1Ý = save_pop_thm "induced_fun_thm1";
=TEX
=SML
set_goal([], ¬
	µX $¦ f ·
		Equiv(X, $¦)
	±	(f Respects $¦) X
	´	µA x· A  X // $¦ ± x  A ´ (f ç-ê) A = f x
®);
a(rewrite_tac[quotient_def] THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[equiv_class_def]));
a(ALL_FC_T  rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) equiv_class_eq_thm,
	induced_fun_thm1]);
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[respects_def]));
a(all_asm_fc_tac[]);
val Ûinduced_fun_thmÝ = save_pop_thm "induced_fun_thm";
=TEX
=SML
set_goal([], ¬
	µX R Y S f ·
		Equiv(X, R)
	±	Equiv(Y, S)
	±	(µy· y  Y ´ ((Ìx·f x y) Respects R) X)
	±	(µx· x  X ´ (f x Respects S) Y)
	´	µA x B y· A  X // R ± x  A ± B  Y // S ± y  B
			´ ((Ìx·(f x ç-ê) B )ç-ê) A = f x y
®);
a(REPEAT strip_tac);
a(lemma_tac¬µx·x  X ´ (f x ç-ê) B = f x y® THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN all_fc_tac[induced_fun_thm]);
(* *** Goal "2" *** *)
a(lemma_tac¬((Ì x· (f x ç-ê) B) Respects R) X®);
(* *** Goal "2.1" *** *)
a(rewrite_tac[respects_def] THEN REPEAT strip_tac THEN ALL_ASM_FC_T rewrite_tac[]);
a(lemma_tac¬y  Y® THEN1 all_fc_tac[arb_gen quotient__thm]);
a(DROP_NTH_ASM_T 11 (ante_tac o rewrite_rule[respects_def] o µ_elim¬y®));
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(ALL_FC_T rewrite_tac[induced_fun_thm]);
a(lemma_tac¬x  X® THEN1 all_fc_tac[arb_gen quotient__thm]);
a(ALL_ASM_FC_T rewrite_tac[]);
val Ûinduced_fun_induced_fun_thmÝ = save_pop_thm "induced_fun_induced_fun_thm";
=TEX
=SML
set_goal([], ¬
	µX $¦ f ·
		Equiv(X, $¦)
	±	(f Respects $¦) X
	´	¶g· µA x· A  X // $¦ ± x  A ´ g A = f x
®);
a(REPEAT strip_tac);
a(¶_tac¬f ç-ê® THEN REPEAT strip_tac);
a(all_fc_tac[induced_fun_thm]);
val Ûinduced_fun_¶_thmÝ = save_pop_thm "induced_fun_¶_thm";
=TEX
=SML
set_goal([], ¬
	µX $¦ f g h·
		Equiv(X, $¦)
	±	(f Respects $¦) X
	±	(µA x· A  X // $¦ ± x  A ´ g A = f x)
	±	(µA x· A  X // $¦ ± x  A ´ h A = f x)
	´	(µA· A  X // $¦  ´ h A = g A)
®);
a(REPEAT strip_tac);
a(all_fc_tac[quotient_rep_¶_thm]);
a(ALL_ASM_FC_T rewrite_tac[]);
val Ûinduced_fun_¶_unique_thmÝ = save_pop_thm "induced_fun_¶_unique_thm";
=TEX
=SML
set_goal([], ¬
	µX R Y S f ·
		Equiv(X, R)
	±	Equiv(Y, S)
	±	(µy· y  Y ´ ((Ìx·f x y) Respects R) X)
	±	(µx· x  X ´ (f x Respects S) Y)
	´	¶g· µA x B y· A  X // R ± x  A ± B  Y // S ± y  B
			´ g A B = f x y
®);
a(REPEAT strip_tac);
a(¶_tac¬ ÌA B· ((Ìx·(f x ç-ê) B )ç-ê) A® THEN REPEAT strip_tac THEN rewrite_tac[]);
a(all_fc_tac[induced_fun_induced_fun_thm]);
val Ûdyadic_induced_fun_¶_thmÝ = save_pop_thm "dyadic_induced_fun_¶_thm";
=TEX
=SML
set_goal([], ¬
	µX R Y S f g h·
		Equiv(X, R)
	±	Equiv(Y, S)
	±	(µy· y  Y ´ ((Ìx·f x y) Respects R) X)
	±	(µx· x  X ´ ((Ìy·f x y) Respects S) Y)
	±	(µA x B y· A  X // R ± x  A ± B  Y // S ± y  B ´ g A B = f x y)
	±	(µA x B y· A  X // R ± x  A ± B  Y // S ± y  B ´ h A B = f x y)
	´	(µA B y· A  X // R ± B  Y // S ´ h A B = g A B)
®);
a(REPEAT strip_tac);
a(all_fc_tac[quotient_rep_¶_thm]);
a(ALL_ASM_FC_T rewrite_tac[]);
val Ûdyadic_induced_fun_¶_unique_thmÝ = save_pop_thm "dyadic_induced_fun_¶_unique_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Groups}
%%%%
%%%%
%%%%
%%%%
=SML
open_theory"groups";
set_merge_pcs["basic_hol1", "'sets_ext"];
=TEX
=SML
val Ûgroup_ops_defÝ = get_spec¬One®;
val Ûgroup_defÝ = get_spec¬Group®;
val Ûhomomorphism_defÝ = get_spec¬Homomorphism®;
val Ûsubgroup_defÝ = get_spec¬Subgroup®;
val Ûnormal_subgroup_defÝ = get_spec¬NormalSubgroup®;
val Ûkernel_defÝ = get_spec¬Kernel®;
val Ûright_congruent_defÝ = get_spec¬RightCongruent®;
val Ûright_coset_defÝ = get_spec¬RightCoset®;
=TEX
=SML
set_goal([], ¬
	µG x·
	G  Group ± x  Car G
´	(x ›~)G  Car G
±	(x.One G) G = x
±	(One G.x)G = x
±	((x ›~)G . x) G = One G
±	(x . (x ›~)G) G = One G
®);
a(rewrite_tac[group_def] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val Ûgroup_clauses_lemma1Ý = save_pop_thm"group_clauses_lemma1";
=TEX
=SML
set_goal([], ¬
	µG x y z·
	G  Group ± x  Car G ± y  Car G ± z  Car G
´	(x.y)G  Car G
±	((x.y)G.z)G = (x. (y.z)G)G
®);
a(rewrite_tac[group_def] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val Ûgroup_clauses_lemma2Ý =  save_pop_thm"group_clauses_lemma2";
=TEX
=SML
set_goal([], ¬
	µG x y·
	G  Group ± x  Car G ± y  Car G
´	(x = y ¤ (x.(y ›~)G)G = One G)
®);
a(REPEAT strip_tac THEN1
	(ALL_FC_T asm_rewrite_tac[group_clauses_lemma1]));
a(LEMMA_T ¬((x . (y ›~) G) G .y)G = (One G.y)G® ante_tac THEN1 asm_rewrite_tac[]);
a(lemma_tac¬(y ›~)G   Car G® THEN1 all_fc_tac[group_clauses_lemma1]);
a(ALL_FC_T rewrite_tac[group_clauses_lemma1, group_clauses_lemma2]);
val Ûgroup_eq_thmÝ = save_pop_thm"group_eq_thm";
=TEX
=SML
set_goal([], ¬
	µG x y·
	G  Group ± x  Car G ± y  Car G
´	(x = y ¤ ((x ›~)G.y)G = One G)
®);
a(REPEAT strip_tac THEN1
	(ALL_FC_T asm_rewrite_tac[group_clauses_lemma1]));
a(LEMMA_T ¬(x.((x ›~) G . y) G)G = (x.One G)G® ante_tac THEN1 asm_rewrite_tac[]);
a(lemma_tac¬(x ›~)G   Car G® THEN1 all_fc_tac[group_clauses_lemma1]);
a(ALL_FC_T rewrite_tac[group_clauses_lemma1, 
	conv_rule (ONCE_MAP_C eq_sym_conv) group_clauses_lemma2]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val Ûgroup_eq_thm1Ý = save_pop_thm"group_eq_thm1";
=TEX
=SML
set_goal([], ¬
	µG x y z·
	G  Group ± x  Car G ± y  Car G ± z  Car G
´	( (x.y) G = (x.z) G ¤ y = z)
®);
a(REPEAT strip_tac THEN_LIST [id_tac, asm_rewrite_tac[]]);
a(lemma_tac¬ (x ›~) G  Car G® THEN1 all_fc_tac[group_clauses_lemma1]);
a(LEMMA_T¬(( (x ›~) G. x) G. y) G = (( (x ›~) G. x) G. z) G ® ante_tac THEN1
	ALL_FC_T asm_rewrite_tac[group_clauses_lemma2]);
a(ALL_FC_T rewrite_tac[group_clauses_lemma1]);
val Ûleft_cancel_thmÝ = save_pop_thm"left_cancel_thm";
=TEX
=SML
set_goal([], ¬
	µG x y z·
	G  Group ± x  Car G
´	((x ›~)G ›~)G = x
®);
a(REPEAT strip_tac);
a(lemma_tac¬ (x ›~) G  Car G® THEN1 all_fc_tac[group_clauses_lemma1]);
a(lemma_tac¬ ((x ›~) G. (((x ›~)G ›~)G)) G = ((x ›~) G. x)  G ® THEN1
	ALL_FC_T asm_rewrite_tac[group_clauses_lemma1]);
a(lemma_tac¬ ((x ›~) G ›~)G  Car G® THEN1 all_fc_tac[group_clauses_lemma1]);
a(all_fc_tac[left_cancel_thm]);
val Ûinverse_inverse_thmÝ = save_pop_thm"inverse_inverse_thm";
=TEX
=SML
set_goal([], ¬
	µG : 'a GROUP; x y·
	G  Group ± x  Car G ± y  Car G
´	(x.((x ›~)G.y)G)G = y
±	((x ›~)G.(x.y)G)G = y
®);
a(REPEAT strip_tac THEN
	(lemma_tac¬((x:'a) ›~)G  Car G® THEN1 all_fc_tac[group_clauses_lemma1]));
(* *** Goal "1" *** *)
a(LEMMA_T¬(x.((x ›~)G.y)G)G = ((x.(x ›~)G)G.y)G® rewrite_thm_tac THEN1
	ALL_FC_T rewrite_tac[group_clauses_lemma2]);
a(ALL_FC_T rewrite_tac[group_clauses_lemma1]);
(* *** Goal "2" *** *)
a(LEMMA_T¬((x ›~)G.(x.y)G)G = (((x ›~)G.x)G.y)G® rewrite_thm_tac THEN1
	ALL_FC_T rewrite_tac[group_clauses_lemma2]);
a(ALL_FC_T rewrite_tac[group_clauses_lemma1]);
val Ûgroup_clauses_lemma3Ý = save_pop_thm"group_clauses_lemma3";
=TEX
=SML
set_goal([], ¬
	µG x y·
	G  Group ± x  Car G ± y  Car G
´	((x.y)G ›~)G = ((y ›~)G. (x ›~)G)G
®);
a(REPEAT strip_tac);
a(lemma_tac¬(x.y)G  Car G ±  (x ›~) G  Car G  ±  (y ›~) G  Car G® THEN1 
	(all_fc_tac[group_clauses_lemma1, group_clauses_lemma2] THEN REPEAT strip_tac));
a(lemma_tac¬((x.y)G.((x . y) G ›~) G)G = ((x.y)G.((y ›~) G . (x ›~) G) G)G®);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[group_clauses_lemma1]);
a(lemma_tac¬((y ›~) G . (x ›~) G) G  Car G® THEN1 all_fc_tac[arb_gen group_clauses_lemma2]);
a(ALL_FC_T rewrite_tac[ group_clauses_lemma1,
	arb_gen group_clauses_lemma2, arb_gen group_clauses_lemma3]);
(* *** Goal "2" *** *)
a(lemma_tac¬((x . y) G ›~) G  Car G ±  ((y ›~) G . (x ›~) G) G  Car G ® THEN1
	(all_fc_tac[arb_gen group_clauses_lemma1,
		arb_gen group_clauses_lemma2] THEN REPEAT strip_tac));
a(all_fc_tac[arb_gen left_cancel_thm]);
val Ûtimes_inverse_thmÝ = save_pop_thm"times_inverse_thm";
=TEX
=SML
set_goal([], ¬
	µG x y·
	G  Group ± x  Car G ± y  Car G
´	((x.y)G = One G ¤ y = (x ›~)G)
®);
a(REPEAT strip_tac THEN_LIST [id_tac,
	all_var_elim_asm_tac1 THEN all_fc_tac[group_clauses_lemma1]]);
a(lemma_tac¬(x.y) G = (x.(x ›~)G)G® THEN1
	ALL_FC_T asm_rewrite_tac[group_clauses_lemma1]);
a(lemma_tac¬(x ›~)G  Car G® THEN1 all_fc_tac[group_clauses_lemma1]);
a(all_fc_tac[left_cancel_thm]);
val Ûinverse_unique_thmÝ = save_pop_thm"inverse_unique_thm";
=TEX
=SML
set_goal([], ¬
	µG·
	G  Group
´	One G  Car G
®);
a(rewrite_tac[group_def] THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
val Ûone_clauses_lemmaÝ = save_pop_thm"one_clauses_lemma";
=TEX
=SML
set_goal([], ¬
	µG·
	G  Group
´	One G  Car G
±	((One G) ›~)G = One G
®);
a(REPEAT strip_tac THEN all_fc_tac[one_clauses_lemma]);
a(lemma_tac¬(One G.One G)G = One G® THEN1 ALL_FC_T rewrite_tac[group_clauses_lemma1]);
a(all_fc_tac[inverse_unique_thm]);
a(conv_tac eq_sym_conv THEN REPEAT strip_tac);
val Ûone_clauses_thmÝ = save_pop_thm"one_clauses_thm";
=TEX
=SML
set_goal([], ¬
	µG x y·
	G  Group ± x  Car G ± y  Car G
´	( (x.y)G = x ¤ y = One G )
®);
a(REPEAT strip_tac THEN_LIST [id_tac,
	all_var_elim_asm_tac1 THEN all_fc_tac[group_clauses_lemma1]]);
a(lemma_tac ¬(x . y) G = (x. One G) G® THEN1
	ALL_FC_T asm_rewrite_tac[group_clauses_lemma1]);
a(all_fc_tac[one_clauses_thm] THEN all_fc_tac[left_cancel_thm]);
val Ûone_unique_thmÝ = save_pop_thm"one_unique_thm";
=TEX
=SML
set_goal([], ¬
	µG : 'a GROUP; H : 'b GROUP; f : 'a ­ 'b·
	G  Group ± H  Group ± f  Homomorphism(G, H)
´	f(One G) = One H
®);
a(rewrite_tac[homomorphism_def,
	group_ops_def] THEN
	REPEAT strip_tac);
a(lemma_tac ¬One G  Car G® THEN1 all_fc_tac[one_clauses_thm]);
a(LEMMA_T ¬f( (One G.One G)G) = f(One G)® ante_tac THEN1
	ALL_FC_T rewrite_tac[group_clauses_lemma1]);
a(ALL_ASM_FC_T rewrite_tac[]);
a(REPEAT strip_tac);
a(lemma_tac¬f(One G)  Car H® THEN1 all_asm_fc_tac[]);
a(all_fc_tac[one_unique_thm]);
val Ûhomomorphism_one_thmÝ = save_pop_thm "homomorphism_one_thm";
=TEX
=SML
set_goal([], ¬
	µG : 'a GROUP; H : 'b GROUP; f : 'a ­ 'b; x : 'a·
	G  Group ± H  Group ± f  Homomorphism(G, H) ± x  Car G
´	f((x ›~)G) = ((f x) ›~) H
®);
a(REPEAT strip_tac THEN all_fc_tac[homomorphism_one_thm] THEN all_asm_ante_tac THEN
	rewrite_tac[homomorphism_def,
		group_ops_def] THEN
		REPEAT strip_tac);
a(lemma_tac¬(x ›~) G  Car G® THEN1 all_fc_tac[group_clauses_lemma1]);
a(lemma_tac¬f x  Car H® THEN1 all_asm_fc_tac[]);
a(lemma_tac¬f ((x ›~) G)  Car H® THEN1 all_asm_fc_tac[]);
a(lemma_tac¬f ((x ›~) G)  Car H® THEN1 all_asm_fc_tac[]);
a(LEMMA_T ¬f((x.(x ›~)G)G ) = One H® ante_tac THEN1
	ALL_FC_T asm_rewrite_tac[group_clauses_lemma1]);
a(ALL_ASM_FC_T rewrite_tac[]);
a(ALL_FC_T1 fc_¤_canon rewrite_tac[inverse_unique_thm]);
val Ûhomomorphism_inverse_thmÝ = save_pop_thm "homomorphism_inverse_thm";
=TEX
=SML
set_goal([], ¬
	µG : 'a GROUP; H : 'b GROUP; f : 'a ­ 'b; x y : 'a·
	G  Group ± H  Group ± f  Homomorphism(G, H) ± x  Car G ± y  Car G
´	 f ((x . y) G) = (f x . f y) H
®);
a(rewrite_tac[homomorphism_def,
		group_ops_def] THEN
		REPEAT strip_tac);
a(ALL_ASM_FC_T rewrite_tac[]);
val Ûhomomorphism_times_thmÝ = save_pop_thm "homomorphism_times_thm";
=TEX
=SML
set_goal([], ¬
	µG : 'a GROUP; H : 'a GROUP; x y : 'a·
	G  Group ± H  Subgroup G
´	((x.y)H = (x.y)G)
±	One H = One G
±	(x  Car H  ´ (x ›~)H = (x ›~)G)
®);
a(rewrite_tac[subgroup_def] THEN REPEAT µ_tac THEN ´_tac);
a(lemma_tac¬One H  Car H® THEN1 all_fc_tac[group_def]);
a(lemma_tac¬One H  Car G® THEN1 all_asm_fc_tac[]);
a(LEMMA_T¬(One H.One H)G = (One H.One H)H® ante_tac THEN1 asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[group_clauses_lemma1]);
a(ALL_FC_T1 fc_¤_canon rewrite_tac[one_unique_thm]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¬(x ›~)H  Car H® THEN1 all_fc_tac[group_def]);
a(LEMMA_T¬(x.(x ›~)H)G = (x.(x ›~)H)H® ante_tac THEN1 asm_rewrite_tac[]);
a(ALL_FC_T asm_rewrite_tac[group_clauses_lemma1]);
val Ûsubgroup_clausesÝ = save_pop_thm "subgroup_clauses";
=TEX
=SML
set_goal([], ¬
	µG : 'a GROUP; H : 'b GROUP; f : 'a ­ 'b·
	G  Group ± H  Group ± f  Homomorphism(G, H)
´	Kernel f (G, H)  NormalSubgroup G
®);
a(rewrite_tac[kernel_def, normal_subgroup_def, subgroup_def, group_ops_def] THEN
	REPEAT strip_tac THEN1
	rewrite_tac[group_def, group_ops_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[group_clauses_lemma2]);
(* *** Goal "2" *** *)
a(ALL_FC_T asm_rewrite_tac[group_clauses_lemma1, homomorphism_times_thm]);
a(all_fc_tac[one_clauses_thm]);
a(ALL_FC_T asm_rewrite_tac[group_clauses_lemma1, homomorphism_times_thm]);
(* *** Goal "3" *** *)
a(ALL_FC_T asm_rewrite_tac[group_clauses_lemma2]);
(* *** Goal "4" *** *)
a(all_fc_tac[one_clauses_thm]);
(* *** Goal "5" *** *)
a(all_fc_tac[homomorphism_one_thm]);
(* *** Goal "6" *** *)
a(ALL_FC_T asm_rewrite_tac[group_clauses_lemma1]);
(* *** Goal "7" *** *)
a(ALL_FC_T asm_rewrite_tac[group_clauses_lemma1]);
(* *** Goal "8" *** *)
a(ALL_FC_T asm_rewrite_tac[group_clauses_lemma1]);
(* *** Goal "9" *** *)
a(ALL_FC_T asm_rewrite_tac[homomorphism_inverse_thm, one_clauses_thm]);
(* *** Goal "10" *** *)
a(ALL_FC_T asm_rewrite_tac[group_clauses_lemma1]);
(* *** Goal "11" *** *)
a(ALL_FC_T asm_rewrite_tac[group_clauses_lemma1]);
(* *** Goal "12" *** *)
a(REPEAT (all_fc_tac[arb_gen group_clauses_lemma1, arb_gen group_clauses_lemma2]));
(* *** Goal "13" *** *)
a(lemma_tac¬(y ›~) G  Car G® THEN1 all_fc_tac[group_clauses_lemma1]);
a(lemma_tac¬(x.y) G  Car G® THEN1 all_fc_tac[group_clauses_lemma2]);
a(ALL_FC_T asm_rewrite_tac[arb_gen homomorphism_times_thm,
	arb_gen homomorphism_inverse_thm]);
a(all_fc_tac[homomorphism_def]);
a(ALL_FC_T rewrite_tac[group_clauses_lemma1, group_clauses_lemma2]);
val Ûkernel_normal_subgroup_thmÝ = save_pop_thm "kernel_normal_subgroup_thm";
=TEX
=SML
set_goal([], ¬
	µG : 'a GROUP; H : 'a GROUP·
	G  Group ± H  Subgroup G
´	Equiv(Car G, RightCongruent H G)
®);
a(rewrite_tac[equiv_def, refl_def, sym_def, trans_def, right_congruent_def] THEN REPEAT strip_tac 
	THEN all_fc_tac[subgroup_def]);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[group_clauses_lemma1]);
a(LEMMA_T ¬One G = One H® rewrite_thm_tac THEN1 ALL_FC_T rewrite_tac[subgroup_clauses]);
a(all_fc_tac [one_clauses_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¬((((x ›~) G . y) G)  ›~)H  Car H® ante_tac
	THEN1 all_fc_tac[arb_gen group_clauses_lemma1]);
a(ALL_FC_T rewrite_tac[subgroup_clauses]);
a(lemma_tac¬(x ›~)G  Car G® THEN1 all_fc_tac[group_clauses_lemma1]);
a(ALL_FC_T rewrite_tac[times_inverse_thm, inverse_inverse_thm]);
(* *** Goal "3" *** *)
a(LEMMA_T ¬(((x ›~) G . y) G . ((y ›~) G . z) G) H  Car H® ante_tac
	THEN1 all_fc_tac[arb_gen group_clauses_lemma2]);
a(ALL_FC_T rewrite_tac[arb_gen subgroup_clauses]);
a(lemma_tac¬(x ›~)G  Car G® THEN1 all_fc_tac[group_clauses_lemma1]);
a(lemma_tac¬(y ›~)G  Car G® THEN1 all_fc_tac[group_clauses_lemma1]);
a(ALL_FC_T rewrite_tac[group_clauses_lemma2, arb_gen group_clauses_lemma3]);
val Ûright_congruent_thmÝ = save_pop_thm "right_congruent_thm";
=TEX
=SML
(*
set_goal([], ¬
	µG : 'a GROUP; H : 'a GROUP·
	G  Group ± H  NormalSubgroup G
´	µy· y  Car G ´ (
		(Ìx· (Ìa b·RightCoset H G ((a.b)G)) x y)
		Respects	(RightCongruent H G)
	) (Car G)
®);
a(rewrite_tac[respects_def, normal_subgroup_def, right_coset_def, right_congruent_def,
	equiv_class_def]
	THEN REPEAT strip_tac);
a(lemma_tac¬(x.y)G  Car G ± (y'.y) G  Car G® THEN1
	(all_fc_tac[group_clauses_lemma2] THEN REPEAT strip_tac));
a(ALL_FC_T1 fc_¤_canon once_rewrite_tac[arb_gen group_eq_thm1]);
a(lemma_tac¬(x ›~)G  Car G ± (y ›~) G  Car G® THEN1
	(all_fc_tac[group_clauses_lemma1] THEN REPEAT strip_tac));
a(ALL_FC_T rewrite_tac[times_inverse_thm, group_clauses_lemma

val Ûright_congruence_thmÝ = save_pop_thm "right_congruence_thm";
*)
=TEX
%%%%
%%%%
%%%%
%%%%
=SML
open_theory"group_egs";
set_merge_pcs["basic_hol1", "'sets_alg", "'ú", "'¯"];
=TEX
=SML
val Ûú_plus_defÝ = ±_left_elim(get_spec¬ú_plus®);
val Ûú_units_defÝ = ±_right_elim(get_spec¬ú_units®);
=TEX
=SML
set_goal([], ¬
	ú_plus  Group
®);
a(rewrite_tac[ú_plus_def, group_def, group_ops_def, ú_plus_assoc_thm]);
val Ûú_group_thmÝ = save_pop_thm "ú_group_thm";
=TEX
=SML
set_goal([], ¬
	ú_units  Group
®);
a(rewrite_tac[ú_units_def, group_def, group_ops_def, ú_times_assoc_thm]);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[] THEN
	all_var_elim_asm_tac1 THEN all_asm_ante_tac THEN rewrite_tac[]);
val Ûú_ones_group_thmÝ = save_pop_thm "ú_ones_group_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
=TEX
\subsection{Epilogue}\label{END}
} % matches turning off of HOL index entries.
=TEX
%%%%
%%%%
=SML
output_theory{out_file="wrk0681.th.doc", theory="equiv_rel"};
output_theory{out_file="wrk0682.th.doc", theory="groups"};
output_theory{out_file="wrk0683.th.doc", theory="group_egs"};
=TEX
\end{document}
=IGN
fun Ûall_undisch_ruleÝ (thm : THM)  : THM = (
	all_undisch_rule (undisch_rule thm) handle Fail _ =>  thm
);
val thms = map (all_undisch_rule o all_µ_elim o rewrite_rule[]) (fc_canon( list_±_intro [
	group_clauses_lemma1,
	group_clauses_lemma2,
	inverse_inverse_thm,
	group_clauses_lemma3,
	times_inverse_thm,
	one_clauses_thm
])) drop (not o is_eq o concl);

val eqn_cxt :EQN_CXT = map (fn th => (fst(dest_eq(concl th)), eq_match_conv th)) thms;

val group_rw_conv = eqn_cxt_conv eqn_cxt;

TOP_MAP_C group_rw_conv ¬
	(z.((((x ›~)G . x)G. z)G. (z ›~)G) G)G
®;
