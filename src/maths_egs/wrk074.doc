=IGN
********************************************************************************
wrk073.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}

\def\ThmsII#1#2{%
{\vertbarfalse
\begin{minipage}[t]{0.48\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.48\hsize}
#2
\end{minipage}}}

\def\ThmsIII#1#2#3{%
{\vertbarfalse
\begin{minipage}[t]{0.32\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#2
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#3
\end{minipage}}}
\def\Hide#1{\relax}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\C{\mathbb{C}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}

\def\LogName{\mbox{{\sf log}}}
\def\Log#1{\LogName(#1)}

\def\SinName{\mbox{{\sf sin}}}
\def\Sin#1{\SinName(#1)}

\def\CosName{\mbox{{\sf cos}}}
\def\Cos#1{\CosName(#1)}

\def\Abs#1{|#1|}

\def\ElemsName{\mbox{{\em Elems}}}
\def\Elems#1{\ElemsName(#1)}

\def\SizeName{\#}
\def\Size#1{\#\left(#1\right)}

%\def\Binomial#1#2{\left(\begin{array}{c}#1\\#2\end{array}\right)}
\def\Binomial#1#2{C_{#2}^{#1}}

\title{Mathematical Case Studies: Number Theory}
\author{Rob Arthan\\{\tt rda@lemma-one.com}}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
Beginnings of number theory in \ProductHOL.
\end{abstract}
%\newpage
%\tableofcontents
%\newpage
\section{INTRODUCTION}

Birthday problem etc. For inclusion in wrk073.doc presently.

\section{THE THEORY {\em fincomb}}\label{theory}

\subsection{Preliminaries}
=SML
force_delete_theory "number_theory" handle Fail _ => ();
open_theory"fincomb";
new_theory "number_theory";
set_merge_pcs["basic_hol1", "'sets_alg", "'ú", "'¯"];
=TEX

\subsection{Real Integral Domains}
In general, an integral domain is a ring without zero divisors.
As we are only concerned with subrings of the reals here, any subring of the reals is an integral domain. 
 
¹HOLCONST
Ü ÛRealIntegralDomainÝ : ¯ SET SET
÷üüüüüü
Ü µA· A  RealIntegralDomain ¤
Ü	î¯ 1  A
Ü ±	(µx y·x  A ± y  A ´ x + y  A)
Ü ±	(µx·x  A ´ ~x  A)
Ü ±	(µx y·x  A ± y  A ´ x * y  A)
°

The domain of (rational) integers comprises the intersection of all real integral domains:

¹HOLCONST
Ü Ûú‰RÝ : ¯ SET
÷üüüüüü
Ü ú‰R = ¥RealIntegralDomain
°
=SML
declare_alias("ú", ¬ú‰R®);
=TEX
To get started, we prove that ¯ is a real integral domain, as is the intersection of any family of real integral domains, and so in particular is ú, the intersection of all real integral domains.
We then show that ú is precisely the image of the type ú of integers under the injection ú¯:

\ThmsII{
=GFT
¯_real_integral_domain_thm
¥_real_integral_domain_thm
=TEX
}{%
=GFT
ú_real_integral_domain_thm
ú_thm
=TEX
}

\subsection{Real Fields}
A real field is a real integral domain that is closed under taking reciprocals of non-zero elements.

¹HOLCONST
Ü ÛRealFieldÝ : ¯ SET SET
÷üüüüüü
Ü µA· A  RealField ¤
Ü	A  RealIntegralDomain
Ü ±	(µx·x  A \ {î¯ 0} ´ x ›-›1  A)
°

The field of rational numbes is the intersection of all real fields.

¹HOLCONST
Ü Û%bbQ%‰RÝ : ¯ SET
÷üüüüüü
Ü %bbQ%‰R = ¥RealField
°

Following a similar pattern to the last section, we prove that ¯ is a real field, as is the intersection of any family of real fields, in particular, %bbQ%, the intersection of all real fields.
We prove that ú is a subset of %bbQ%.
An explicit formula for the set %bbQ% is given in the next section.

\ThmsII{
=GFT
¯_real_field_thm
¥_real_field_thm
=TEX
}{
=GFT
rat_real_integral_domain_thm
ú_€_rat_thm
=TEX
}

=SML
declare_alias("%bbQ%", ¬%bbQ%‰R®);
=TEX
\subsection{Fields of Fractions}
The field of fractions of a set $A$, (typically an integral domain) is the intersection of all fields that contain $A$.

¹HOLCONST
Ü ÛFieldOfFractionsÝ : ¯ SET ­ ¯ SET
÷üüüüüü
Ü µA· FieldOfFractions A = ¥{K | K  RealField ± A € K}
°
We prove that the field of fractions of any set is indeed a real field and that %bbQ% is the field of fractions of ú.
We then show that if $A$ is an integral domain, then its field of fractions does indeed comprise precisely the set of fractions $a/b$ with $a, b \in A$ and $b \not = 0$.
Using this we can derive an explicit formula for the set %bbQ%.


\ThmsII{
=GFT
field_of_fractions_field_thm
rat_field_of_fractions_thm
=TEX
}{
=GFT
field_of_fractions_thm
rat_thm
=TEX
}

%\bibliographystyle{fmu}
%\bibliography{fmu}

%\appendix
{%\HOLindexOff
\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{numbers.th}}

=TEX

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
=TEX
%%%%
%%%%
=SML
val Ûreal_integral_domain_defÝ = get_spec ¬RealIntegralDomain®;
val Ûú_defÝ = get_spec ¬ú‰R®;
val Ûreal_field_defÝ = get_spec ¬RealField®;
val Ûrat_defÝ = get_spec ¬%bbQ%‰R®;
val Ûfield_of_fractions_defÝ = get_spec ¬FieldOfFractions®;
=TEX
%%%%
%%%%
=SML
set_goal([], ¬Universe  RealIntegralDomain®);
a(rewrite_tac[real_integral_domain_def]);
val Û¯_real_integral_domain_thmÝ = save_pop_thm "¯_real_integral_domain_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¬µV· V € RealIntegralDomain ´ ¥V  RealIntegralDomain®);
a(PC_T1 "sets_ext1" rewrite_tac[real_integral_domain_def]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
val Û¥_real_integral_domain_thmÝ = save_pop_thm "¥_real_integral_domain_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¬ú  RealIntegralDomain®);
a(rewrite_tac[ú_def]);
a(bc_thm_tac ¥_real_integral_domain_thm THEN rewrite_tac[]);
val Ûú_real_integral_domain_thmÝ = save_pop_thm "ú_real_integral_domain_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¬ú = {x | ¶i·x = ú¯ i}®);
a(PC_T1 "sets_ext1" rewrite_tac[ú_def, real_integral_domain_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(swap_nth_asm_concl_tac 1 THEN REPEAT strip_tac);
a(¶_tac ¬{x | ¶i·x = ú¯ i}® THEN rewrite_tac[]
	THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
(* *** Goal "1.1" *** *)
a(¶_tac¬îú 1® THEN rewrite_tac[ú¯_îú_thm]);
(* *** Goal "1.2" *** *)
a(¶_tac¬i + i'® THEN rewrite_tac[ú¯_plus_homomorphism_thm]);
(* *** Goal "1.3" *** *)
a(¶_tac¬~i® THEN rewrite_tac[ú¯_minus_thm]);
(* *** Goal "1.4" *** *)
a(¶_tac¬i * i'® THEN rewrite_tac[ú¯_times_homomorphism_thm]);
(* *** Goal "1.5" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(ú_induction_tac¬i®);
(* *** Goal "2.1" *** *)
a(asm_rewrite_tac[ú¯_îú_thm]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[ú¯_minus_thm] THEN all_asm_fc_tac[]);
(* *** Goal "2.3" *** *)
a(rewrite_tac[ú¯_plus_homomorphism_thm] THEN all_asm_fc_tac[]);
val Ûú_thmÝ = save_pop_thm "ú_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¬Universe  RealField®);
a(rewrite_tac[real_field_def, ¯_real_integral_domain_thm]);
val Û¯_real_field_thmÝ = save_pop_thm "¯_real_field_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¬µV· V € RealField ´ ¥V  RealField®);
a(PC_T1 "sets_ext1" rewrite_tac[real_field_def,
	real_integral_domain_def]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
val Û¥_real_field_thmÝ = save_pop_thm "¥_real_field_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¬%bbQ%  RealField®);
a(rewrite_tac[rat_def]);
a(bc_thm_tac ¥_real_field_thm THEN rewrite_tac[]);
val Ûrat_real_integral_domain_thmÝ = save_pop_thm "rat_real_integral_domain_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¬ú € %bbQ%®);
a(PC_T1"sets_ext1" rewrite_tac[rat_def, ú_def, real_field_def]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
val Ûú_€_rat_thmÝ = save_pop_thm "ú_€_rat_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¬µA· FieldOfFractions A  RealField®);
a(REPEAT strip_tac THEN rewrite_tac[field_of_fractions_def]);
a(bc_thm_tac ¥_real_field_thm);
a(PC_T1 "sets_ext1" prove_tac[]);
val Ûfield_of_fractions_field_thmÝ = save_pop_thm "field_of_fractions_field_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¬%bbQ% = FieldOfFractions ú®);
a(rewrite_tac[field_of_fractions_def, rat_def]);
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac
	THEN1 all_asm_fc_tac[]);
a(DROP_NTH_ASM_T 2 bc_thm_tac THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac
	THEN PC_T1"sets_ext1" rewrite_tac[ú_def, real_field_def]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
val Ûrat_field_of_fractions_thmÝ = save_pop_thm "rat_field_of_fractions_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¬µA·
	A  RealIntegralDomain
´	FieldOfFractions A =
	{x | ¶a b·a  A ± b  A ± ³b = î¯ 0 ± x = a * b ›-›1}®);
a(PC_T1 "sets_ext1" rewrite_tac[real_integral_domain_def, field_of_fractions_def,
	real_field_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T ¬x  {y | ¶ a b· a  A ± b  A ± ³ b = î¯ 0 ± y = a * b ›-›1}®
	(fn th => ante_tac th THEN rewrite_tac[]));
a(POP_ASM_T bc_thm_tac THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
(* *** Goal "1.1" *** *)
a(¶_tac¬î¯ 1® THEN ¶_tac¬î¯ 1® THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(¶_tac¬a * b' + a' * b® THEN ¶_tac¬b*b'®);
a(asm_rewrite_tac[¯_times_eq_0_thm]);
a(REPEAT strip_tac
	THEN_TRY LIST_GET_NTH_ASM_T [7, 8, 9] bc_tac
	THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (fn th =>
	ALL_FC_T1 fc_¤_canon
	once_rewrite_tac[conv_rule(ONCE_MAP_C (RIGHT_C eq_sym_conv))
	¯_times_cancel_thm] THEN asm_tac th));
a(DROP_NTH_ASM_T 2 (fn th =>
	ALL_FC_T1 fc_¤_canon
	once_rewrite_tac[conv_rule(ONCE_MAP_C (RIGHT_C eq_sym_conv))
	¯_times_cancel_thm] THEN asm_tac th));
a(ALL_FC_T rewrite_tac[¯_recip_clauses]);
a(rewrite_tac[¯_times_plus_distrib_thm, ¯_times_assoc_thm]);
a(rewrite_tac[pc_rule1 "¯_lin_arith" prove_rule[]
	¬µa b c d·a*b ›-›1*c*d = (a*c)*(b ›-›1 *d)®]);
a(ALL_FC_T rewrite_tac[¯_recip_clauses]);
a(conv_tac (RANDS_C ¯_anf_conv) THEN strip_tac);
(* *** Goal "1.3" *** *)
a(¶_tac¬~a® THEN ¶_tac¬b® THEN 
	LIST_DROP_NTH_ASM_T [5] (ALL_FC_T asm_rewrite_tac));
a(PC_T1 "¯_lin_arith" prove_tac[]);
(* *** Goal "1.4" *** *)
a(¶_tac¬a*a'® THEN ¶_tac¬b*b'®);
a(asm_rewrite_tac[¯_times_eq_0_thm]);
a(LIST_DROP_NTH_ASM_T [7] (ALL_FC_T asm_rewrite_tac));
a(ALL_FC_T rewrite_tac[¯_recip_clauses]
	THEN PC_T1 "¯_lin_arith" prove_tac[]);
(* *** Goal "1.5" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[¯_times_eq_0_thm]));
a(ALL_FC_T rewrite_tac[¯_recip_clauses]);
a(¶_tac¬b® THEN ¶_tac¬a® THEN asm_rewrite_tac[]);
a(PC_T1 "¯_lin_arith" prove_tac[]);
(* *** Goal "1.6" *** *)
a(¶_tac¬x® THEN ¶_tac¬î¯ 1® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [2, 3] bc_tac
	THEN REPEAT strip_tac
	THEN DROP_NTH_ASM_T 1 bc_thm_tac
	THEN REPEAT strip_tac);
val Ûfield_of_fractions_thmÝ = save_pop_thm "field_of_fractions_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¬%bbQ% = {x | ¶i:ú; m:î·x = ú¯ i * î¯ (m+1) ›-›1}®);
a(rewrite_tac[rat_field_of_fractions_thm]);
a(strip_asm_tac ú_real_integral_domain_thm);
a(ALL_FC_T rewrite_tac[field_of_fractions_thm]);
a(rewrite_tac[ú_thm]);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(strip_asm_tac(µ_elim¬i'®ú_cases_thm1)
	THEN all_var_elim_asm_tac1);
(* *** Goal "1.1" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[ú¯_îú_thm,
	î¯_one_one_thm,
	pc_rule1 "lin_arith" prove_rule[]
	¬(³m = 0 ¤ 1 ¼ m) ± µi·1 + i = i + 1®,
	¼_def] THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(¶_tac¬i® THEN ¶_tac¬i'® THEN rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(¶_tac¬~i® THEN ¶_tac¬m® THEN rewrite_tac[ú¯_minus_thm,
	ú¯_îú_thm]);
a(lemma_tac¬³î¯ (m + 1) = î¯ 0®
	THEN1 rewrite_tac[î¯_one_one_thm]);
a(ALL_FC_T rewrite_tac[¯_minus_recip_thm]);
a(PC_T1 "¯_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(¶_tac¬ú¯ i® THEN ¶_tac¬ú¯(îú(m+1))® THEN
	rewrite_tac[ú¯_îú_thm, î¯_one_one_thm]);
a(strip_tac THEN1 prove_tac[]);
a(¶_tac¬îú(m+1)® THEN rewrite_tac[ú¯_îú_thm]);
val Ûrat_thmÝ = save_pop_thm "rat_thm";
=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val ÛsectionsÝ = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="numbers.th.doc", theory="-"};
end;
=TEX
} %\Hide
\end{document}

=TEX
%%%%
%%%%
=IGN
