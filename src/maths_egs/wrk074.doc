=IGN
********************************************************************************
wrk073.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}

\def\ThmsII#1#2{%
{\vertbarfalse
\begin{minipage}[t]{0.48\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.48\hsize}
#2
\end{minipage}}}

\def\ThmsIII#1#2#3{%
{\vertbarfalse
\begin{minipage}[t]{0.32\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#2
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#3
\end{minipage}}}
\def\Hide#1{\relax}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\C{\mathbb{C}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}

\def\LogName{\mbox{{\sf log}}}
\def\Log#1{\LogName(#1)}

\def\SinName{\mbox{{\sf sin}}}
\def\Sin#1{\SinName(#1)}

\def\CosName{\mbox{{\sf cos}}}
\def\Cos#1{\CosName(#1)}

\def\Abs#1{|#1|}

\def\ElemsName{\mbox{{\em Elems}}}
\def\Elems#1{\ElemsName(#1)}

\def\SizeName{\#}
\def\Size#1{\#\left(#1\right)}

%\def\Binomial#1#2{\left(\begin{array}{c}#1\\#2\end{array}\right)}
\def\Binomial#1#2{C_{#2}^{#1}}

\title{Mathematical Case Studies: Some Number Theory}
\author{Rob Arthan\\{\tt rda@lemma-one.com}}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
Beginnings of number theory in \ProductHOL.
\end{abstract}
%\newpage
%\tableofcontents
%\newpage
\section{INTRODUCTION}

Some number theory.

\section{THE THEORY {\em numbers}}\label{theory}

\subsection{Preliminaries}
=SML
force_delete_theory "numbers" handle Fail _ => ();
open_theory"fincomb";
new_theory "numbers";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙", "'Ø"];
=TEX

\subsection{Divisors in Ó}
We begin working in the natural numbers and develop the theory of divisors.
We define an infix relation {\em Divides} such that {\em n Divides m} iff. $m$ is a multiple of $n$.
 
=SML
declare_infix(200, "Divides");
πHOLCONST
‹ €$Divides› : Ó ≠ Ó ≠ BOOL
˜¸¸¸¸¸¸
‹ µn m∑ n Divides m § ∂k∑ m = k * n
∞
It is often convenient to reduce
=INLINEFT
n Divides m
=TEX
\ to
=INLINEFT
m Mod n = 0
=TEX
.
The following block of theorems provide this and several other useful facts, e.g., that {\em Divides} is a partial ordering, i.e., it is reflexive, antisymmetric and transitive.

\ThmsIII{
=GFT
times_eq_0_thm
times_cancel_thm
times_eq_eq_1_thm
times_eq_1_thm
div_mod_1_thm
m_div_mod_m_thm
zero_div_mod_thm
less_div_mod_thm
=TEX
}{%
=GFT
div_mod_times_cancel_thm
mod_clauses
mod_eq_0_thm
divides_0_thm
divides_trans_thm
divides_mod_thm
divides_refl_thm
divides_antisym_thm
=TEX
}{%
=GFT
divides_plus_thm
divides_º_thm
divides_1_thm
mod_plus_homomorphism_thm
mod_times_homomorphism_thm
mod_Ó_exp_thm
=TEX
}

We now specify the greatest common divisor function by requiring it to produce greatest lower bounds with respect to the divisor ordering.

πHOLCONST
‹ €Gcd› : Ó ≠ Ó ≠ Ó
˜¸¸¸¸¸¸
‹ µm n∑	0 < m ± 0 < n
‹ ¥	Gcd m n Divides m
‹ ±	Gcd m n Divides n
‹ ± 	µd∑	d Divides m
‹	±	d Divides n
‹	¥	d Divides Gcd m n
∞

We will need to prove the consistency of the above definition.
Our approach is based on the one  which exhibits the greatest common divisor of $m$ and $n$ as the smallest positive value of the form $am + bn$.
To follow that approach directly requires $a$ and $b$ to range over both positive and negative integers.
A slightly less symmetrical alternative is to take the g.c.d. to be the smallest positive value of the form $(am)\;Mod\;n$.
This works over the natural numbers and is the method we use.

Various useful lemmas about greatest common divisors are then proved culminating in the theorem that Euclid's algorithm computes them.

\ThmsIII{
=GFT
Gcd_consistent
gcd_def
gcd_pos_thm
=TEX
}{%
=GFT
gcd_unique_thm
gcd_idemp_thm
gcd_comm_thm
=TEX
}{%
=GFT
gcd_plus_thm
gcd_eq_mod_thm
euclid_algorithm_thm
=TEX
}
Now we define the set of prime numbers:

πHOLCONST
‹ €Prime› : Ó SET
˜¸¸¸¸¸¸
‹ Prime = {p | 1 < p ± µm n∑ p = m*n ¥ m = 1 ≤ n = 1}
∞
The first important fact we need about prime numbers is the fact that a number is prime iff. it is greater than 1 and whenever it divides a product it divides one of the factors.
The right-to-left direction of this is simple.
It is for this the other direction that we need to develop the theory of the g.c.d.


\subsection{Indexed Sums and Products in Ó}
A useful application of the set fold operation is to define the following indexed sum operation. Given an index set, $a$, and a function, $f$, assigning a number to each member of $a$,
=INLINEFT
IndSumâN a f
=TEX
\ is the indexed sum $\sum_{x\in a}f(x)$, which is defined on any set $a$ in which $f$ has finite support.


πHOLCONST
‹ €IndSumâN› : 'a SET ≠ ('a ≠ Ó) ≠ Ó
˜¸¸¸¸¸¸
‹ µf∑	IndSumâN {} f = 0
‹ ±	µx a∑	a ° {x|≥ f x = 0} ç Finite ± ≥x ç a
‹	¥	IndSumâN ({x} ¿ a) f = f x + IndSumâN a f
∞

We will write $\sum\,a\,f$ as shorthand for
=INLINEFT
IndSumâN a f
=TEX
.
=SML
declare_alias("ì", ¨IndSumâNÆ);
=TEX
Similarly, we define indexed products:
=TEX
πHOLCONST
‹ €IndProdâN› : 'a SET ≠ ('a ≠ Ó) ≠ Ó
˜¸¸¸¸¸¸
‹ µf∑	IndProdâN {} f = 1
‹ ±	µx a∑	a ° {x|≥ f x = 1} ç Finite ± ≥x ç a
‹	¥	IndProdâN ({x} ¿ a) f = f x * IndProdâN a f
∞

We will write $\prod\,a\,f$ as shorthand for
=INLINEFT
IndProdâN a f
=TEX
.
=SML
declare_alias("ê", ¨IndProdâNÆ);
=TEX


\subsection{Real Integral Domains}
In general, an integral domain is a ring without zero divisors.
As we are only concerned with subrings of the reals here, any subring of the reals is an integral domain. 
 
πHOLCONST
‹ €RealID› : Ø SET SET
˜¸¸¸¸¸¸
‹ µA∑ A ç RealID §
‹	ÓØ 1 ç A
‹ ±	(µx y∑x ç A ± y ç A ¥ x + y ç A)
‹ ±	(µx∑x ç A ¥ ~x ç A)
‹ ±	(µx y∑x ç A ± y ç A ¥ x * y ç A)
∞

The domain of (rational) integers comprises the intersection of all real integral domains:

πHOLCONST
‹ €˙âR› : Ø SET
˜¸¸¸¸¸¸
‹ ˙âR = •RealID
∞
=SML
declare_alias("˙", ¨˙âRÆ);
=TEX
To get started, we prove that Ø is a real integral domain, as is the intersection of any family of real integral domains, and so in particular is ˙, the intersection of all real integral domains.
We then show that ˙ is precisely the image of the type ˙ of integers under the injection ˙Ø:

\ThmsII{
=GFT
Ø_real_i_d_thm
•_real_i_d_thm
=TEX
}{%
=GFT
˙_real_i_d_thm
˙_thm
=TEX
}

\subsection{Real Fields}
A real field is a real integral domain that is closed under taking reciprocals of non-zero elements.

πHOLCONST
‹ €RealField› : Ø SET SET
˜¸¸¸¸¸¸
‹ µA∑ A ç RealField §
‹	A ç RealID
‹ ±	(µx∑x ç A \ {ÓØ 0} ¥ x õ-õ1 ç A)
∞

The field of rational numbes is the intersection of all real fields.

πHOLCONST
‹ €%bbQ%âR› : Ø SET
˜¸¸¸¸¸¸
‹ %bbQ%âR = •RealField
∞

Following a similar pattern to the last section, we prove that Ø is a real field, as is the intersection of any family of real fields, in particular, %bbQ%, the intersection of all real fields.
We prove that ˙ is a subset of %bbQ%.
An explicit formula for the set %bbQ% is given in the next section.

\ThmsII{
=GFT
Ø_real_field_thm
•_real_field_thm
=TEX
}{
=GFT
rat_real_i_d_thm
˙_Ä_rat_thm
=TEX
}

=SML
declare_alias("%bbQ%", ¨%bbQ%âRÆ);
=TEX
\subsection{Fields of Fractions}
The field of fractions of a set $A$, (typically an integral domain) is the intersection of all fields that contain $A$.

πHOLCONST
‹ €FieldOfFractions› : Ø SET ≠ Ø SET
˜¸¸¸¸¸¸
‹ µA∑ FieldOfFractions A = •{K | K ç RealField ± A Ä K}
∞
We prove that the field of fractions of any set is indeed a real field and that %bbQ% is the field of fractions of ˙.
We then show that if $A$ is an integral domain, then its field of fractions does indeed comprise precisely the set of fractions $a/b$ with $a, b \in A$ and $b \not = 0$.
Using this we can derive an explicit formula for the set %bbQ%.


\ThmsII{
=GFT
field_of_fractions_field_thm
rat_field_of_fractions_thm
=TEX
}{
=GFT
field_of_fractions_thm
rat_thm
=TEX
}

%\bibliographystyle{fmu}
%\bibliography{fmu}

%\appendix
{%\HOLindexOff
\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{wrk074.th}}

=TEX

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
=TEX
%%%%
%%%%
=SML
val €divides_def› = get_spec ¨$DividesÆ;
val €prime_def› = get_spec ¨PrimeÆ;
val €real_i_d_def› = get_spec ¨RealIDÆ;
val €˙_def› = get_spec ¨˙âRÆ;
val €real_field_def› = get_spec ¨RealFieldÆ;
val €rat_def› = get_spec ¨%bbQ%âRÆ;
val €field_of_fractions_def› = get_spec ¨FieldOfFractionsÆ;
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µm n a∑ (µi∑i ç a ¥ i º m) ± n ç a ¥ Max a ç aÆ);
a(µ_tac THEN induction_tac ¨m:ÓÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
a(all_fc_tac[get_spec¨MaxÆ] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(cases_tac¨m + 1 ç aÆ
	THEN1 (all_fc_tac[get_spec¨MaxÆ] THEN asm_rewrite_tac[]));
a(DROP_NTH_ASM_T 4 bc_thm_tac THEN ∂_tac¨nÆ
	THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
a(cases_tac¨i = m + 1Æ THEN1 all_var_elim_asm_tac1);
a(PC_T1 "lin_arith" asm_prove_tac[]);
val €max_ç_thm› = save_pop_thm"max_ç_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n a∑ (µi∑i ç a ¥ i º m) ± n ç a ¥ n º Max aÆ);
a(µ_tac THEN induction_tac ¨m:ÓÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
a(all_fc_tac[get_spec¨MaxÆ] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(cases_tac¨m + 1 ç aÆ
	THEN1 (all_fc_tac[get_spec¨MaxÆ] THEN asm_rewrite_tac[]
		THEN all_asm_fc_tac[]));
a(DROP_NTH_ASM_T 4 bc_thm_tac THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
a(cases_tac¨i = m + 1Æ THEN1 all_var_elim_asm_tac1);
a(PC_T1 "lin_arith" asm_prove_tac[]);
val €max_º_thm› = save_pop_thm"max_º_thm";
=TEX
%%%%
%%%% DIVISORS IN Ó
%%%%
=SML
val €div_mod_unique_thm1› =
	rewrite_rule[taut_rule
		¨µp1 p2 p3∑ (p1 ¥ p2 ¥ p3) § (p1 ± p2 ¥ p3)Æ]
	(conv_rule (ONCE_MAP_C(RAND_C(RAND_C (RANDS_C eq_sym_conv))))
		div_mod_unique_thm);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n∑m * n = 0 ¥ m = 0 ≤ n = 0Æ);
a(contr_tac);
a(LEMMA_T¨1 º m ± 1 º nÆ (strip_asm_tac o rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
val €times_eq_0_thm› = save_pop_thm "times_eq_0_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µk m n∑0 < k ± k * m = k * n ¥ m = nÆ);
a(contr_tac);
a((LEMMA_T¨m º n ≤ n º mÆ (strip_asm_tac o rewrite_rule[º_def])
	THEN1 rewrite_tac[º_cases_thm])
		THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(lemma_tac¨k*i = 0Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(fc_tac[times_eq_0_thm] THEN all_var_elim_asm_tac1
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨k*i = 0Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(fc_tac[times_eq_0_thm] THEN all_var_elim_asm_tac1
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
val €times_cancel_thm› = save_pop_thm "times_cancel_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n∑0 < n ± m * n = n ¥ m = 1Æ);
a(REPEAT strip_tac THEN
	bc_thm_tac (once_rewrite_rule[times_comm_thm] times_cancel_thm));
a(∂_tac¨nÆ THEN asm_rewrite_tac[]);
val €times_eq_eq_1_thm› = save_pop_thm "times_eq_eq_1_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n∑m * n = 1 § m = 1 ± n = 1Æ);
a(REPEAT µ_tac);
a(cases_tac¨m = 0 ≤ n = 0 ≤ m = 1 ≤ n = 1Æ THEN_TRY
	(all_var_elim_asm_tac1 THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(LEMMA_T¨2 º m ± 2 º nÆ (strip_asm_tac o rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [3, 4, 5, 6] discard_tac);
a(all_var_elim_asm_tac1 THEN PC_T1 "lin_arith" asm_prove_tac[]);
val €times_eq_1_thm› = save_pop_thm "times_eq_1_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n∑m^n = 1 § m = 1 ≤ n = 0Æ);
a(REPEAT_UNTIL is_¥ strip_tac);
(* *** Goal "1" *** *)
a(induction_tac¨n:ÓÆ
	THEN  asm_rewrite_tac[Ó_exp_def, times_eq_1_thm]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[Ó_exp_def]);
a(induction_tac¨n:ÓÆ
	THEN  asm_rewrite_tac[Ó_exp_def]);
val €Ó_exp_eq_1_thm› = save_pop_thm "Ó_exp_eq_1_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm:Ó∑ m^1 = mÆ);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨mÆ, ¨0Æ](±_right_elim Ó_exp_def)));
a(rewrite_tac[±_left_elim Ó_exp_def]);
val €Ó_exp_1_thm› = save_pop_thm "Ó_exp_1_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm∑m Div 1 = m ± m Mod 1 = 0Æ);
a(µ_tac);
a(bc_thm_tac div_mod_unique_thm1 THEN rewrite_tac[]);
val €div_mod_1_thm› = save_pop_thm "div_mod_1_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm∑ 0 < m ¥ m Div m = 1 ± m Mod m = 0Æ);
a(µ_tac THEN ¥_tac);
a(bc_thm_tac div_mod_unique_thm1 THEN asm_rewrite_tac[]);
val €m_div_mod_m_thm› = save_pop_thm "m_div_mod_m_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm∑0 < m ¥ 0 Div m = 0 ± 0 Mod m = 0Æ);
a(µ_tac THEN ¥_tac);
a(bc_thm_tac div_mod_unique_thm1 THEN asm_rewrite_tac[]);
val €zero_div_mod_thm› = save_pop_thm "zero_div_mod_thm";
=TEX
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n∑n < m ¥ n Div m = 0 ± n Mod m = nÆ);
a(REPEAT µ_tac THEN ¥_tac);
a(bc_thm_tac div_mod_unique_thm1 THEN asm_rewrite_tac[]);
val €less_div_mod_thm› = save_pop_thm "less_div_mod_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µk m n∑0 < k ¥ (m*k + n) Div k = m + n Div k ±  (m*k + n) Mod k = n Mod kÆ);
a(REPEAT µ_tac THEN ¥_tac);
a(bc_thm_tac div_mod_unique_thm1
	THEN ALL_FC_T rewrite_tac[mod_less_thm]);
a(rewrite_tac[times_plus_distrib_thm, plus_assoc_thm]);
a(bc_thm_tac div_mod_thm THEN REPEAT strip_tac);
val €div_mod_times_cancel_thm› = save_pop_thm "div_mod_times_cancel_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µk m n∑
	0 < k
¥	(m*k) Mod k = 0
±	(k*m) Mod k = 0
±	(k*m + n) Mod k = n Mod k
±	(m*k + n) Mod k = n Mod k
±	(n + k*m) Mod k = n Mod k
±	(n + m*k) Mod k = n Mod k
±	(k + n) Mod k = n Mod k
±	(n + k) Mod k = n Mod k
±	0 Mod k = 0
±	k Mod k = 0
±	(m Mod k) Mod k = m Mod k
Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(rewrite_tac[µ_elim¨kÆ times_comm_thm, µ_elim¨nÆ plus_order_thm]);
a(ALL_FC_T rewrite_tac[rewrite_rule[µ_elim¨nÆ plus_order_thm]
	div_mod_times_cancel_thm, m_div_mod_m_thm, zero_div_mod_thm]);
a(pure_once_rewrite_tac[prove_rule[]
	¨m*k = m*k + 0 ± k + n = 1*k + n ± n + k = 1*k + nÆ]);
a(ALL_FC_T pure_rewrite_tac[div_mod_times_cancel_thm]
	THEN ALL_FC_T rewrite_tac[zero_div_mod_thm]);
a(lemma_tac¨m Mod k < kÆ THEN1 ALL_FC_T rewrite_tac[mod_less_thm]);
a(ALL_FC_T rewrite_tac[less_div_mod_thm]);
val €mod_clauses› = save_pop_thm "mod_clauses";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n∑
	0 < n
¥	(m Mod n = 0 § ∂k∑m = k*n)
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨m Div nÆ);
a(ALL_FC_T (conv_tac o LEFT_C o once_rewrite_conv)[div_mod_thm]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1 THEN ALL_FC_T rewrite_tac[mod_clauses]);
val €mod_eq_0_thm› = save_pop_thm "mod_eq_0_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm∑m Divides 0 ± (0 Divides m § m = 0)Æ);
a(REPEAT µ_tac THEN rewrite_tac[divides_def]);
a(∂_tac¨0Æ THEN rewrite_tac[]);
val €divides_0_thm› = save_pop_thm "divides_0_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µn m∑
	n Divides m § (if 0 < n then m Mod n else m) = 0
Æ);
a(REPEAT µ_tac);
a(cases_tac¨≥0 < nÆ THEN asm_rewrite_tac[divides_def]);
(* *** Goal "1" *** *)
a(lemma_tac¨n = 0Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(cases_tac¨m = 0Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(ALL_FC_T1 fc_§_canon rewrite_tac[mod_eq_0_thm]);
val €divides_mod_thm› = save_pop_thm "divides_mod_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨ µm∑ m Divides m Æ);
a(REPEAT strip_tac
	THEN rewrite_tac[divides_def]
	THEN ∂_tac ¨1Æ THEN rewrite_tac[]);
val €divides_refl_thm› = save_pop_thm "divides_refl_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨ µm n∑ n Divides m ± m Divides n § m = n Æ);
a(REPEAT µ_tac THEN cases_tac¨n = 0Æ
	THEN1 asm_rewrite_tac[divides_0_thm]);
a(cases_tac¨m = 0Æ
	THEN1 (asm_rewrite_tac[divides_0_thm]
		THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(lemma_tac¨0 < n ± 0 < mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[divides_mod_thm]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[arb_gen mod_eq_0_thm]);
a(lemma_tac¨(k'*k)*m = mÆ THEN1
	(POP_ASM_T (fn th => conv_tac (RIGHT_C(rewrite_conv[th])))
		THEN asm_rewrite_tac[times_assoc_thm]));
a(all_fc_tac[arb_gen times_eq_eq_1_thm]);
a(all_fc_tac[arb_gen times_eq_1_thm]);
a(all_var_elim_asm_tac1 THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac THEN ALL_FC_T rewrite_tac[mod_clauses]);
(* *** Goal "3" *** *)
a(all_var_elim_asm_tac THEN ALL_FC_T rewrite_tac[mod_clauses]);
val €divides_antisym_thm› = save_pop_thm "divides_antisym_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨ µm n k∑ n Divides m ± m Divides k ¥ n Divides k Æ);
a(REPEAT µ_tac THEN rewrite_tac[divides_def]
	THEN REPEAT strip_tac);
a(∂_tac¨k''*k'Æ THEN asm_rewrite_tac[times_assoc_thm]);
val €divides_trans_thm› = save_pop_thm "divides_trans_thm";

=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n d∑
	d Divides n 
¥	(d Divides (m+n) § d Divides m)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[divides_mod_thm]);
a(cases_tac¨d = 0Æ THEN1 (asm_rewrite_tac[] THEN taut_tac));
a(DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac[divides_def]);
a(lemma_tac¨0 < dÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[] THEN once_rewrite_tac[plus_comm_thm]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN ALL_FC_T rewrite_tac[mod_clauses]);
(* *** Goal "2" *** *)
a(all_asm_ante_tac THEN rewrite_tac[divides_def]
		THEN REPEAT strip_tac
		THEN all_var_elim_asm_tac1);
a(∂_tac¨k' + kÆ THEN PC_T1 "lin_arith" prove_tac[]);
val €divides_plus_thm› = save_pop_thm "divides_plus_thm";

=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n∑
	0 < m
±	n Divides m
¥	0 < n ± n º mÆ);
a(rewrite_tac[divides_def] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(swap_nth_asm_concl_tac 1);
a(LEMMA_T¨n = 0Æ rewrite_thm_tac THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN cases_tac¨k = 0Æ
	THEN1 asm_rewrite_tac[]);
a(LEMMA_T¨1 º kÆ (strip_asm_tac o rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 2 discard_tac THEN all_var_elim_asm_tac1);
a(PC_T1 "lin_arith" prove_tac[]);
val €divides_º_thm› = save_pop_thm "divides_º_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm∑m Divides 1 § m = 1Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T¨0 < 1Æ asm_tac THEN1 rewrite_tac[]);
a(all_fc_tac[divides_º_thm]);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[divides_mod_thm]);
val €divides_1_thm› = save_pop_thm "divides_1_thm";

=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n k∑0 < k ¥ (m + n) Mod k = (m Mod k + n Mod k) Mod kÆ);
a(REPEAT strip_tac);
a(all_fc_tac[div_mod_thm]);
a(TOP_ASM_T (ante_tac o µ_elim¨mÆ));
a(POP_ASM_T (ante_tac o µ_elim¨nÆ) THEN REPEAT strip_tac);
a(REPEAT (POP_ASM_T (fn th => conv_tac(LEFT_C(once_rewrite_conv[th])))));
a(rewrite_tac[pc_rule1 "lin_arith" prove_rule[]
	¨µa b c d∑(a*k + b) + (c*k + d) = (a+c)*k + b + dÆ]);
a(ALL_FC_T rewrite_tac[div_mod_times_cancel_thm]);
val €mod_plus_homomorphism_thm› = save_pop_thm "mod_plus_homomorphism_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n k∑0 < k ¥ (m * n) Mod k = ((m Mod k) * (n Mod k)) Mod kÆ);
a(REPEAT strip_tac);
a(all_fc_tac[div_mod_thm]);
a(TOP_ASM_T (ante_tac o µ_elim¨mÆ));
a(POP_ASM_T (ante_tac o µ_elim¨nÆ) THEN REPEAT strip_tac);
a(REPEAT (POP_ASM_T (fn th => conv_tac(LEFT_C(once_rewrite_conv[th])))));
a(rewrite_tac[pc_rule1 "lin_arith" prove_rule[]
	¨µa b c d∑(a*k + b) * (c*k + d) = (a*c*k + a*d +b*c)*k + b*dÆ]);
a(ALL_FC_T rewrite_tac[div_mod_times_cancel_thm]);
val €mod_times_homomorphism_thm› = save_pop_thm "mod_times_homomorphism_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n k∑0 < k ¥ (m ^ n) Mod k = ((m Mod k) ^ n) Mod kÆ);
a(REPEAT strip_tac);
a(induction_tac¨nÆ THEN rewrite_tac[Ó_exp_def]);
a(ALL_FC_T1 fc_§_canon once_rewrite_tac
	[mod_times_homomorphism_thm]);
a(ALL_FC_T asm_rewrite_tac[mod_clauses]);
val €mod_Ó_exp_thm› = save_pop_thm "mod_Ó_exp_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n∑
	0 < m ± 0 < n ± 0 < m Mod n
¥	∂a∑ 0 < (a*m) Mod n
± 	µb∑ 0 < (b*m) Mod n ¥ (a*m) Mod n º (b*m) Mod nÆ);
a(REPEAT strip_tac);
a(PC_T1 "predicates" lemma_tac
	¨ ∂i∑ i ç { i | ∂a∑0 < (a*m) Mod n ± i = (a*m) Mod n } Æ);
(* *** Goal "1" *** *)
a(∂_tac¨m Mod nÆ THEN REPEAT strip_tac);
a(∂_tac¨1Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_fc_tac[min_ç_thm]);
a(∂_tac¨aÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 discard_tac);
a(PC_T1 "predicates" lemma_tac
	¨ (b*m) Mod n ç { i | ∂a∑0 < (a*m) Mod n ± i = (a*m) Mod n } Æ
	THEN1 (REPEAT strip_tac THEN asm_prove_tac[]));
a(all_fc_tac[min_º_thm]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
val €gcd_consistent_lemma1› = pop_thm();
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n a d∑
	0 < m ± 0 < n ± 0 < d
±	m Mod d = 0 ± n Mod d = 0
¥	((a*m) Mod n) Mod d = 0
Æ);
a(REPEAT strip_tac);
a(all_fc_tac[mod_eq_0_thm]);
a(ante_tac(list_µ_elim[¨a*mÆ, ¨nÆ] div_mod_thm));
a(strip_tac THEN LEMMA_T
	¨(((a*m) Div n)*n + (a*m) Mod n) Mod d = (a*m) Mod dÆ ante_tac
	THEN1 POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(ALL_FC_T once_rewrite_tac[mod_plus_homomorphism_thm]);
a(all_var_elim_asm_tac1
	THEN rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) times_assoc_thm]
	THEN ALL_FC_T rewrite_tac[mod_clauses]);
val €gcd_consistent_lemma2› = pop_thm();
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b m n p r s∑
	a*m = b*(n+1) + r
±	m = p*r + s
¥	∂q∑(q*m) Mod (n+1) = s Mod (n+1)Æ);
a(REPEAT strip_tac);
a(∂_tac¨n*p*a+1Æ);
a(scale_nth_asm_tac¨n*pÆ 2);
a(rewrite_tac[times_assoc_thm, times_plus_distrib_thm] THEN
	POP_ASM_T (asm_rewrite_thm_tac o rewrite_rule[times_assoc_thm]));
a(LEMMA_T ¨
	n*p*(b*(n + 1) + r) + p * r + s =
	(n+1)*(p*b*n + p*r) + sÆ rewrite_thm_tac THEN1
	PC_T1 "lin_arith" prove_tac[]);
a(rewrite_tac[rewrite_rule[](µ_elim¨n+1Æmod_clauses)]);
val €gcd_consistent_lemma3› = pop_thm();
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b m n p r s∑
	a*m = b*(n+1) + r
±	n + 1 = p*r + s
¥	∂q∑(q*m) Mod (n+1) = s Mod (n+1)Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨µx∑(x*m) Mod (n + 1) = (x*m + n + 1) Mod (n + 1)Æ
	rewrite_thm_tac THEN1
		rewrite_tac[rewrite_rule[](µ_elim¨n+1Æmod_clauses)]);
a(∂_tac¨n*p*aÆ);
a(scale_nth_asm_tac¨n*pÆ 2);
a(rewrite_tac[times_assoc_thm, times_plus_distrib_thm] THEN
	POP_ASM_T (rewrite_thm_tac o rewrite_rule[times_assoc_thm]));
a(LEMMA_T¨µx∑x + n + 1 = x + p*r + sÆ rewrite_thm_tac THEN1
	asm_rewrite_tac[]);
a(LEMMA_T ¨
	n*p*(b*(n+1) + r) + p * r + s =
	(n+1)*(p*b*n + p*r) + sÆ rewrite_thm_tac THEN1
	PC_T1 "lin_arith" prove_tac[]);
a(rewrite_tac[rewrite_rule[](µ_elim¨n+1Æmod_clauses)]);
val €gcd_consistent_lemma4› = pop_thm();
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n k a∑
	0 < m ± 0 < n ± 0 < m Mod n
±	0 < (a*m) Mod n
± 	(µb∑ 0 < (b*m) Mod n ¥ (a*m) Mod n º (b*m) Mod n)
¥	m Mod ((a*m) Mod n) = 0 ± n Mod ((a*m) Mod n) = 0Æ);
a(REPEAT µ_tac THEN ¥_tac THEN 
	LEMMA_T ¨1 º nÆ
		(strip_asm_tac o once_rewrite_rule[plus_comm_thm]
			o rewrite_rule[º_def]) THEN1
	PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN contr_tac);
(* *** Goal "1" *** *)
a(ante_tac(list_µ_elim[ ¨aÆ, ¨(a*m) Div (i+1)Æ,
	¨mÆ, ¨iÆ, ¨m Div ((a*m) Mod (i+1))Æ,
	¨(a*m) Mod (i+1)Æ,
	¨m Mod ((a*m) Mod (i+1))Æ ]gcd_consistent_lemma3));
a(asm_tac (prove_rule[]¨0 < i + 1Æ));
a(ALL_FC_T rewrite_tac[
	conv_rule(ONCE_MAP_C eq_sym_conv) div_mod_thm]);
a(lemma_tac¨m Mod ((a*m) Mod (i + 1)) < (a*m) Mod (i+1)Æ
	THEN1 all_fc_tac[mod_less_thm]);
a(lemma_tac¨(a*m) Mod (i+1) < (i+1)Æ
	THEN1 (bc_thm_tac mod_less_thm THEN REPEAT strip_tac));
a(lemma_tac¨m Mod ((a*m) Mod (i + 1)) < (i+1)Æ
	THEN1 all_fc_tac[less_trans_thm]);
a(ALL_FC_T rewrite_tac [less_div_mod_thm]);
a(contr_tac);
a(DROP_NTH_ASM_T 7 (ante_tac o µ_elim¨qÆ));
a(asm_rewrite_tac[]);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(ante_tac(list_µ_elim[ ¨aÆ, ¨(a*m) Div (i+1)Æ,
	¨mÆ, ¨iÆ, ¨(i+1) Div ((a*m) Mod (i+1))Æ,
	¨(a*m) Mod (i+1)Æ,
	¨(i+1) Mod ((a*m) Mod (i+1))Æ ]gcd_consistent_lemma4));
a(asm_tac (prove_rule[]¨0 < i + 1Æ));
a(ALL_FC_T rewrite_tac[
	conv_rule(ONCE_MAP_C eq_sym_conv) (arb_gen div_mod_thm)]);
a(lemma_tac¨(i+1) Mod ((a*m) Mod (i+1)) < (a*m) Mod (i+1)Æ
	THEN1 (bc_thm_tac mod_less_thm THEN REPEAT strip_tac));
a(lemma_tac¨(a*m) Mod (i+1) < (i+1)Æ
	THEN1 (bc_thm_tac mod_less_thm THEN REPEAT strip_tac));
a(lemma_tac¨(i+1) Mod ((a*m) Mod (i + 1)) < (i+1)Æ
	THEN1 all_fc_tac[less_trans_thm]);
a(ALL_FC_T rewrite_tac [less_div_mod_thm]);
a(contr_tac);
a(DROP_NTH_ASM_T 7 (ante_tac o µ_elim¨qÆ));
a(asm_rewrite_tac[]);
a(PC_T1 "lin_arith" asm_prove_tac[]);
val €gcd_consistent_lemma5› = pop_thm();
=TEX
%%%%
%%%%

=SML
(*
drop_main_goal();
*)
push_consistency_goal ¨GcdÆ;
a(prove_∂_tac THEN REPEAT strip_tac);
a(cases_tac¨m' = 0Æ THEN1 all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(∂_tac¨0Æ THEN REPEAT strip_tac THEN 
	ALL_FC_T rewrite_tac[mod_clauses]);
(* *** Goal "2" *** *)
a(cases_tac¨n' = 0Æ THEN1 all_var_elim_asm_tac1);
(* *** Goal "2.1" *** *)
a(∂_tac¨0Æ THEN REPEAT strip_tac THEN 
	ALL_FC_T rewrite_tac[mod_clauses]);
(* *** Goal "2.2" *** *)
a(cases_tac¨m' Mod n' = 0Æ);
(* *** Goal "2.2.1" *** *)
a(∂_tac¨n'Æ THEN REPEAT strip_tac
	THEN rewrite_tac[divides_mod_thm]
	THEN ALL_FC_T asm_rewrite_tac[mod_clauses]);
(* *** Goal "2.2.2" *** *)
a(lemma_tac¨0 < m' ± 0 < n' ± 0 < m' Mod n'Æ
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]
	THEN LIST_DROP_NTH_ASM_T [4, 5, 6] discard_tac);
a(all_fc_tac [gcd_consistent_lemma1]);
a(all_fc_tac [gcd_consistent_lemma5]);
a(∂_tac¨(a*m') Mod n'Æ THEN asm_rewrite_tac[divides_mod_thm]);
a(µ_tac THEN cases_tac ¨≥0 < dÆ THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac THEN1 all_var_elim_asm_tac1);
a(bc_thm_tac gcd_consistent_lemma2
	THEN REPEAT strip_tac);
val _ = save_consistency_thm ¨GcdÆ (pop_thm());
=TEX
%%%%
%%%%

=SML
val €gcd_def› = save_thm("gcd_def", get_spec¨GcdÆ);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n∑ 0 < m ± 0 < n ¥ 0 < Gcd m nÆ);
a(REPEAT strip_tac THEN all_fc_tac[gcd_def]);
a(swap_nth_asm_concl_tac 5);
a(DROP_NTH_ASM_T 3 ante_tac);
a(LEMMA_T ¨Gcd m n = 0Æ rewrite_thm_tac THEN1 PC_T1"lin_arith" asm_prove_tac[]);
a(rewrite_tac[divides_def] THEN PC_T1 "lin_arith" prove_tac[]);
val €gcd_pos_thm› = save_pop_thm "gcd_pos_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n d∑
	0 < m ± 0 < n
±	d Divides m ± d Divides n ± Gcd m n Divides d
¥	d = Gcd m n
Æ);
a(REPEAT strip_tac THEN all_fc_tac[gcd_def]
	THEN all_fc_tac[divides_antisym_thm]);
val €gcd_unique_thm› = save_pop_thm "gcd_unique_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm∑ 0 < m ¥ Gcd m m = mÆ);
a(REPEAT strip_tac THEN conv_tac eq_sym_conv);
a(bc_thm_tac gcd_unique_thm);
a(asm_rewrite_tac[divides_refl_thm]);
a(ALL_FC_T rewrite_tac[gcd_def]);
val €gcd_idemp_thm› = save_pop_thm "gcd_idemp_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n d∑
	0 < m ± 0 < n
¥	Gcd m n = Gcd n m
Æ);
a(REPEAT strip_tac THEN bc_thm_tac gcd_unique_thm);
a(REPEAT strip_tac THEN all_fc_tac[arb_gen gcd_def]
	THEN all_fc_tac[arb_gen gcd_def]);
val €gcd_comm_thm› = save_pop_thm "gcd_comm_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n d∑
	0 < m ± 0 < n
¥	Gcd (m + n) n = Gcd m n
Æ);
a(REPEAT strip_tac THEN bc_thm_tac gcd_unique_thm);
a(lemma_tac¨0 < m + nÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(ALL_FC_T asm_rewrite_tac[gcd_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac  ¨Gcd (m + n) n Divides m + n ± Gcd (m + n) n Divides nÆ 
	THEN1 ALL_FC_T rewrite_tac[gcd_def]);
a(DROP_NTH_ASM_T 2 ante_tac);
a(ALL_FC_T1 fc_§_canon rewrite_tac[arb_gen divides_plus_thm]);
(* *** Goal "2" *** *)
a(lemma_tac¨Gcd m n Divides m ± Gcd m n Divides nÆ 
	THEN1 ALL_FC_T rewrite_tac[gcd_def]);
a(lemma_tac¨Gcd m n Divides m + nÆ 
	THEN1 ALL_FC_T1 fc_§_canon asm_rewrite_tac[arb_gen divides_plus_thm]);
a(all_fc_tac[gcd_def]);
val €gcd_plus_thm› = save_pop_thm "gcd_plus_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨
	µm n∑	0 < m ± 0 < n ± 0 < m Mod n
	¥	∂a∑ 0 < (a*m) Mod n
	± 	(µb∑ 0 < (b*m) Mod n ¥ (a*m) Mod n º (b*m) Mod n)
	±	Gcd m n = (a*m) Mod n
Æ);
a(REPEAT strip_tac);
a(all_fc_tac[gcd_consistent_lemma1]);
a(∂_tac¨aÆ THEN asm_rewrite_tac[]);
a(conv_tac eq_sym_conv THEN bc_thm_tac gcd_unique_thm);
a(asm_rewrite_tac[divides_mod_thm]);
a(ALL_FC_T rewrite_tac[gcd_pos_thm, gcd_consistent_lemma5]);
a(bc_thm_tac gcd_consistent_lemma2);
a(ALL_FC_T asm_rewrite_tac[gcd_pos_thm]);
a(LIST_DROP_NTH_ASM_T[1, 2, 3] discard_tac);
a(ALL_FC_T (MAP_EVERY ante_tac) [all_µ_elim gcd_def]);
a(rewrite_tac[divides_mod_thm]);
a(ALL_FC_T rewrite_tac[gcd_pos_thm] THEN taut_tac);
val €gcd_eq_mod_thm› = save_pop_thm"gcd_eq_mod_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm n∑
	0 < m ± 0 < n
¥	Gcd m n = if m < n then Gcd m (n-m) else if m = n then m else Gcd (m-n) n
Æ);
a(REPEAT strip_tac);
a(strip_asm_tac (pc_rule1"lin_arith" prove_rule[]
	¨m < n ≤ m = n ≤ (≥m < n ± ≥ m = n ± n < m)Æ)
	THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(LEMMA_T ¨m + 1 º nÆ (strip_asm_tac o
	rewrite_rule[º_def, pc_rule1"lin_arith" prove_rule[]
	¨µi∑ (m + 1) + i = (i + 1) + mÆ])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1);
a(LEMMA_T ¨0 < i + 1Æ asm_tac THEN REPEAT strip_tac);
a(rewrite_tac[]);
a(ALL_FC_T once_rewrite_tac [gcd_comm_thm]);
a(ALL_FC_T rewrite_tac[arb_gen gcd_plus_thm]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac[gcd_idemp_thm]);
(* *** Goal "3" *** *)
a(LEMMA_T ¨n + 1 º mÆ (strip_asm_tac o
	rewrite_rule[º_def, pc_rule1"lin_arith" prove_rule[]
	¨µi∑ (n + 1) + i = (i + 1) + nÆ])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T[2, 3, 4] discard_tac
	THEN all_var_elim_asm_tac1);
a(LEMMA_T ¨0 < i + 1Æ asm_tac THEN REPEAT strip_tac);
a(rewrite_tac[]);
a(ALL_FC_T rewrite_tac[arb_gen gcd_plus_thm]);
val €euclid_algorithm_thm› = save_pop_thm "euclid_algorithm_thm";
=TEX
%%%%
%%%% PRIMES IN Ó
%%%%

=SML
set_goal([], ¨µp∑ p ç Prime ¥ 0 < pÆ);
a(rewrite_tac[prime_def] THEN PC_T1 "lin_arith" asm_prove_tac[]);
val €prime_0_less_thm› = save_pop_thm"prime_0_less_thm";
%%%%

=SML
set_goal([], ¨µp∑ p ç Prime ¥ 2 º pÆ);
a(rewrite_tac[prime_def] THEN PC_T1 "lin_arith" asm_prove_tac[]);
val €prime_2_º_thm› = save_pop_thm"prime_2_º_thm";
=TEX
%%%%
%%%% PRIMES IN Ó
%%%%

=SML
set_goal([], ¨µp∑ p ç Prime § (1 < p ± µd∑d Divides p § d = 1 ≤ d = p)Æ);
a(rewrite_tac[prime_def, divides_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1);
a(list_spec_nth_asm_tac 2 [¨kÆ, ¨dÆ]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨pÆ THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨1Æ THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 2 (ante_tac o µ_elim ¨mÆ));
a(LEMMA_T¨∂ k∑ m * n = k * mÆ asm_rewrite_thm_tac
	THEN1 (∂_tac¨nÆ THEN PC_T1 "lin_arith" prove_tac[]));
a(all_asm_ante_tac THEN cases_tac¨m = 0Æ THEN1 asm_rewrite_tac[]);
a(strip_asm_tac (µ_elim¨nÆ Ó_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN1 rewrite_tac[]);
a(strip_asm_tac (µ_elim¨iÆ Ó_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN1 rewrite_tac[]);
a(PC_T1 "lin_arith" asm_prove_tac[]);
val €prime_divides_thm› = save_pop_thm"prime_divides_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm p∑
	0 < m ± p ç Prime
¥	Gcd m p = 1 ≤ Gcd m p = pÆ);
a(REPEAT strip_tac
	THEN all_fc_tac[prime_0_less_thm]
		THEN all_asm_ante_tac);
a(rewrite_tac[prime_divides_thm] THEN REPEAT strip_tac);
a(lemma_tac¨Gcd m p Divides pÆ THEN1 all_fc_tac[gcd_def]);
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
val €gcd_prime_thm› = save_pop_thm "gcd_prime_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µp∑
	(µm n∑	p Divides m*n
	¥	p Divides m ≤ p Divides n)
±	1 < p
¥	p ç Prime
Æ);
a(rewrite_tac[prime_def, divides_mod_thm] THEN contr_tac);
a(all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 4 (ante_tac o list_µ_elim[¨mÆ, ¨nÆ]));
a(lemma_tac ¨0 < m*n Æ THEN1
	PC_T1"lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[m_div_mod_m_thm]);
a(lemma_tac ¨0 < m ± 0 < nÆ THEN1
	(LIST_DROP_NTH_ASM_T [1, 2, 3] discard_tac
		THEN contr_tac THEN lemma_tac¨m = 0 ≤ n = 0Æ
		THEN_TRY all_var_elim_asm_tac1 THEN
			PC_T1"lin_arith" asm_prove_tac[]));
a(cases_tac¨m < m*nÆ THEN1 
	ALL_FC_T asm_rewrite_tac[less_div_mod_thm]);
(* *** Goal "1" *** *)
a(cases_tac¨n < m*nÆ THEN1 
	(ALL_FC_T asm_rewrite_tac[less_div_mod_thm] THEN
		PC_T1 "lin_arith" asm_prove_tac[]));
a(LEMMA_T¨2 º mÆ (strip_asm_tac o rewrite_rule[º_def])
	THEN1 PC_T1"lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN PC_T1"lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T¨2 º nÆ (strip_asm_tac o rewrite_rule[º_def])
	THEN1 PC_T1"lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN PC_T1"lin_arith" asm_prove_tac[]);
val €prime_lemma1› = pop_thm ();
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µp m n∑
	p ç Prime ± p Divides m*n
¥	p Divides m ≤ p Divides n
Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(all_fc_tac[prime_0_less_thm]);
a(cases_tac¨m = 0 ≤ n = 0Æ THEN_TRY
	(asm_rewrite_tac[divides_0_thm]));
a(lemma_tac¨0 < m ± 0 < nÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(cases_tac¨Gcd m p = pÆ THEN1
	(POP_ASM_T (once_rewrite_thm_tac o eq_sym_rule) THEN
		all_fc_tac[gcd_def] THEN REPEAT strip_tac));
a(cases_tac¨Gcd n p = pÆ THEN1
	(POP_ASM_T (once_rewrite_thm_tac o eq_sym_rule) THEN
		all_fc_tac[arb_gen gcd_def]
			THEN REPEAT strip_tac));
a(lemma_tac¨Gcd m p = 1 ± Gcd n p = 1Æ THEN1
	(fc_tac[gcd_prime_thm]
		THEN LIST_DROP_NTH_ASM_T [1, 2] fc_tac
			THEN REPEAT strip_tac));
a(asm_rewrite_tac[divides_mod_thm]);
a(rewrite_tac[pc_rule1 "lin_arith" prove_rule[]
	¨µa∑a = 0 § ≥0 < aÆ]);
a(contr_tac);
a(all_fc_tac[arb_gen gcd_eq_mod_thm]);
a(LIST_DROP_NTH_ASM_T [1, 4] (MAP_EVERY ante_tac));
a(asm_rewrite_tac[]);
a(LIST_DROP_NTH_ASM_T (interval 1 14) discard_tac);
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN contr_tac);
a(LEMMA_T¨((a' * m)*(a * n)) Mod p = 1Æ ante_tac THEN1
	ALL_FC_T once_asm_rewrite_tac[mod_times_homomorphism_thm]);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[prime_def]));
a(ALL_FC_T asm_rewrite_tac[less_div_mod_thm]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[divides_mod_thm]
	THEN REPEAT strip_tac);
a(LEMMA_T¨((a' * a)*(m * n)) Mod p = 0Æ ante_tac THEN1
	(ALL_FC_T once_asm_rewrite_tac[mod_times_homomorphism_thm]
		THEN ALL_FC_T asm_rewrite_tac[mod_clauses]));
a(conv_tac(ONCE_MAP_C anf_conv) THEN PC_T1 "lin_arith" prove_tac[]);
val €prime_lemma2› = pop_thm ();
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µp∑
	p ç Prime
§	1 < p ± (µm n∑ p Divides m*n ¥ p Divides m ≤ p Divides n)
Æ);
a(REPEAT strip_tac THEN_LIST [
	POP_ASM_T (strip_asm_tac o rewrite_rule[prime_def])
		THEN asm_rewrite_tac[],
	all_fc_tac[prime_lemma2],
	all_fc_tac[prime_lemma1]]);
val €prime_thm› = save_pop_thm "prime_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨ µm∑ 1 < m ¥ ∂p n∑p ç Prime ± m = p*n Æ);
a(µ_tac THEN cov_induction_tac¨m:ÓÆ);
a(REPEAT strip_tac);
a(cases_tac¨m ç PrimeÆ THEN1
	(∂_tac¨mÆ THEN ∂_tac¨1Æ THEN asm_rewrite_tac[]));
a(POP_ASM_T (strip_asm_tac o rewrite_rule[prime_def]));
a(cases_tac¨m' = 0Æ THEN1
	(all_var_elim_asm_tac1 THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(lemma_tac¨1 < m'Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(cases_tac¨≥m'< mÆ);
(* *** Goal "1" *** *)
a(cases_tac¨n = 0Æ THEN1
	(all_var_elim_asm_tac1 THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(LEMMA_T¨2 º nÆ (strip_asm_tac o rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN  PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T [8] all_fc_tac);
a(∂_tac¨pÆ THEN ∂_tac¨n'*nÆ THEN asm_rewrite_tac[times_assoc_thm]);
val €prime_divisor_thm› = save_pop_thm "prime_divisor_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨ µm n∑ 1 < m ¥ n º m^nÆ);
a(REPEAT strip_tac);
a(induction_tac¨nÆ THEN rewrite_tac[Ó_exp_def]);
a(cases_tac¨n = 0Æ
	THEN1 (asm_rewrite_tac[Ó_exp_def]
		THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(LEMMA_T ¨2 º mÆ (strip_asm_tac o rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN PC_T1 "lin_arith" asm_prove_tac[]);
val €Ó_exp_linear_bound_thm› = save_pop_thm "Ó_exp_linear_bound_thm";
=TEX
%%%%
%%%%
=SML
(*
drop_main_goal();
*)
push_consistency_goal ¨IndSumâNÆ;
a(∂_tac ¨Ãa f∑SetFold 0 ($ +) f aÆ);
a(µ_tac THEN rewrite_tac[] THEN bc_thm_tac(set_fold_def));
a(rewrite_tac[plus_assoc_thm]);
val _ = save_consistency_thm ¨IndSumâNÆ (pop_thm());
val €ind_sum_Ó_def› = save_thm("ind_sum_Ó_def", get_spec ¨IndSumâNÆ);
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ f∑
	ì {} f = 0
±	(µ x a∑ a ç Finite ± ≥ x ç a
¥	ì ({x} ¿ a) f = f x + ì a f)Æ);
a(REPEAT strip_tac THEN1 rewrite_tac[ind_sum_Ó_def]);
a(lemma_tac¨a ° {x|≥ f x = 0} ç FiniteÆ
	THEN1 (bc_thm_tac °_finite_thm THEN REPEAT strip_tac));
a(ALL_FC_T rewrite_tac[ind_sum_Ó_def]);
val €ind_sum_Ó_def1› = save_pop_thm "ind_sum_Ó_def1";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ f∑
	ì {} f = 0
±	({x|≥ f x = 0} ç Finite
	¥	(µ x a∑ ≥ x ç a
	¥	ì ({x} ¿ a) f = f x + ì a f))Æ);
a(REPEAT strip_tac THEN1 rewrite_tac[ind_sum_Ó_def]);
a(lemma_tac¨a ° {x|≥ f x = 0} ç FiniteÆ
	THEN1 (bc_thm_tac °_finite_thm THEN REPEAT strip_tac));
a(ALL_FC_T rewrite_tac[ind_sum_Ó_def]);
val €ind_sum_Ó_def2› = save_pop_thm "ind_sum_Ó_def2";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ A f∑
	A ç Finite
±	ì A f = 0
¥	µx∑x ç A ¥ f x = 0Æ);
a(REPEAT µ_tac THEN ¥_tac THEN POP_ASM_T ante_tac);
a(intro_µ_tac(¨fÆ, ¨fÆ));
a(finite_induction_tac¨AÆ THEN1 rewrite_tac[]);
a(ALL_FC_T rewrite_tac[ind_sum_Ó_def1]);
a(REPEAT µ_tac THEN ¥_tac);
a(REPEAT strip_tac THEN1 all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [5] all_fc_tac);
val €ind_sumÓ_0_thm› = save_pop_thm "ind_sum_Ó_0_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ A; f g : 'a ≠ Ó∑
	A ç Finite
±	(µx∑x ç A ¥ f x = g x)
¥	ì A f = ì A gÆ);
a(REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨fÆ, ¨fÆ));
a(finite_induction_tac¨AÆ
	THEN1 rewrite_tac[ind_sum_Ó_def1]);
a(REPEAT strip_tac);
a(lemma_tac¨µ x∑ x ç A ¥ f x = g xÆ
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
a(ALL_ASM_FC_T rewrite_tac[ind_sum_Ó_def1]);
a(spec_nth_asm_tac 2 ¨xÆ);
val €ind_sum_Ó_local_thm› = save_pop_thm "ind_sum_Ó_local_thm";
=TEX
%%%%
%%%%
=SML
(*
drop_main_goal();
*)
push_consistency_goal ¨IndProdâNÆ;
a(∂_tac ¨Ãa f∑SetFold 1 ($ *) f aÆ);
a(µ_tac THEN rewrite_tac[] THEN bc_thm_tac(set_fold_def));
a(PC_T1 "lin_arith" prove_tac[]);
val _ = save_consistency_thm ¨IndProdâNÆ (pop_thm());
val €ind_prod_Ó_def› = save_thm("ind_prod_Ó_def", get_spec ¨IndProdâNÆ);
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ f∑
	ê {} f = 1
±	(µ x a∑ a ç Finite ± ≥ x ç a
¥	ê ({x} ¿ a) f = f x * ê a f)Æ);
a(REPEAT strip_tac THEN1 rewrite_tac[ind_prod_Ó_def]);
a(lemma_tac¨a ° {x|≥ f x = 1} ç FiniteÆ
	THEN1 (bc_thm_tac °_finite_thm THEN REPEAT strip_tac));
a(ALL_FC_T rewrite_tac[ind_prod_Ó_def]);
val €ind_prod_Ó_def1› = save_pop_thm "ind_prod_Ó_def1";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ f∑
	ê {} f = 1
±	({x|≥ f x = 1} ç Finite
	¥	(µ x a∑ ≥ x ç a
	¥	ê ({x} ¿ a) f = f x * ê a f))Æ);
a(REPEAT strip_tac THEN1 rewrite_tac[ind_prod_Ó_def]);
a(lemma_tac¨a ° {x|≥ f x = 1} ç FiniteÆ
	THEN1 (bc_thm_tac °_finite_thm THEN REPEAT strip_tac));
a(ALL_FC_T rewrite_tac[ind_prod_Ó_def]);
val €ind_prod_Ó_def2› = save_pop_thm "ind_prod_Ó_def2";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ A f∑
	A ç Finite
±	ê A f = 1
¥	µx∑x ç A ¥ f x = 1Æ);
a(REPEAT µ_tac THEN ¥_tac THEN POP_ASM_T ante_tac);
a(intro_µ_tac(¨fÆ, ¨fÆ));
a(finite_induction_tac¨AÆ THEN1 rewrite_tac[]);
a(ALL_FC_T rewrite_tac[ind_prod_Ó_def1]);
a(REPEAT µ_tac THEN ¥_tac);
a(all_fc_tac[times_eq_1_thm]);
a(REPEAT strip_tac THEN1 all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [6] all_fc_tac);
val €ind_prod_Ó_1_thm› = save_pop_thm "ind_prod_Ó_1_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µ A f g∑
	A ç Finite
±	(µx∑x ç A ¥ f x = g x)
¥	ê A f = ê A gÆ);
a(REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨fÆ, ¨fÆ));
a(finite_induction_tac¨AÆ
	THEN1 rewrite_tac[ind_prod_Ó_def1]);
a(REPEAT strip_tac);
a(lemma_tac¨µ x∑ x ç A ¥ f x = g xÆ
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
a(ALL_ASM_FC_T rewrite_tac[ind_prod_Ó_def1]);
a(spec_nth_asm_tac 2 ¨xÆ THEN asm_rewrite_tac[]);
val €ind_prod_Ó_local_thm› = save_pop_thm "ind_prod_Ó_local_thm";
=TEX
%%%%
%%%%

=TEX
=SML
val €mod_3_plus_thm› = rewrite_rule[](all_µ_intro(list_µ_elim[¨m:ÓÆ, ¨n:ÓÆ, ¨3Æ]mod_plus_homomorphism_thm));
=TEX
=SML
val €mod_3_times_thm› = rewrite_rule[](all_µ_intro(list_µ_elim[¨m:ÓÆ, ¨n:ÓÆ, ¨3Æ]mod_times_homomorphism_thm));
=TEX
=SML
val €mod_3_Ó_exp_thm› = rewrite_rule[](all_µ_intro(list_µ_elim[¨m:ÓÆ, ¨n:ÓÆ, ¨3Æ]mod_Ó_exp_thm));
=TEX
=SML
val €mod_3_clauses› = rewrite_rule[](µ_elim¨3Æ mod_clauses);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µdigits n∑
	ì {i | i < n} (Ãi∑digits i * 10 ^ i) Mod 3 =
	ì {i | i < n} (Ãi∑digits i) Mod 3
Æ);
a(REPEAT strip_tac);
a(induction_tac¨nÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[ind_sum_Ó_def1, pc_rule1"sets_ext1" prove_rule[]¨{x|F} = {}Æ]);
(* *** Goal "1" *** *)
a(PC_T1 "predicates" lemma_tac¨{i|i < n + 1} = {n} ¿ {i|i < n} ± ≥n ç {i|i < n}
	± {i|i < n} ç FiniteÆ
	THEN1 rewrite_tac[range_finite_size_thm]);
(* *** Goal "2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(ALL_FC_T asm_rewrite_tac[ind_sum_Ó_def1]);
a(once_rewrite_tac[mod_3_plus_thm]);
a(asm_rewrite_tac[]);
a(once_rewrite_tac[mod_3_times_thm]);
a(once_rewrite_tac[mod_3_Ó_exp_thm]);
a(LEMMA_T¨1 ^ n = 1Æ (fn th => rewrite_tac[th, mod_3_clauses]));
a(DROP_ASMS_T discard_tac
	THEN induction_tac¨nÆ THEN asm_rewrite_tac[Ó_exp_def]);
val €div_3_rule_thm1› = save_pop_thm "div_3_rule_thm1";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µdigits n∑
	3 Divides ì {i | i < n} (Ãi∑digits i * 10 ^ i) §
	3 Divides ì {i | i < n} (Ãi∑digits i)
Æ);
a(REPEAT µ_tac);
a(rewrite_tac[divides_mod_thm, div_3_rule_thm1]);
val €div_3_rule_thm› = save_pop_thm "div_3_rule_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µp A f∑
	A ç Finite
±	p ç Prime
±	p Divides ê A f
¥	∂x∑ x ç A ± p Divides f x
Æ);
a(REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨fÆ, ¨fÆ));
a(finite_induction_tac¨AÆ);
(* *** Goal "1" *** *)
a(rewrite_tac [ind_prod_Ó_def1, divides_1_thm]);
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[prime_def]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac [ind_prod_Ó_def1]);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 5 (fn th => fc_tac[rewrite_rule[prime_thm] th]));
(* *** Goal "2.1" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
a(∂_tac¨x'Æ THEN REPEAT strip_tac);
val €prime_ê_thm› = save_pop_thm "prime_ê_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm∑ 0 < m
¥	∂ e∑
	{k | ≥e k = 0} ç Finite
±	{k | ≥e k = 0} Ä Prime
±	m = ê {k | ≥e k = 0} (Ãp∑ p ^ e p)
Æ);
a(µ_tac);
a(cov_induction_tac¨mÆ);
a(cases_tac¨m = 0Æ THEN1 asm_rewrite_tac[]);
a(cases_tac¨m = 1Æ THEN1 all_var_elim_asm_tac1
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T discard_tac THEN ∂_tac¨Ãm:Ó∑0Æ
	THEN rewrite_tac[pc_rule1"sets_ext1" prove_rule[]
		¨{x|F} = {}Æ, ind_prod_Ó_def1,
		empty_finite_thm]
	THEN contr_tac);
(* *** Goal "2" *** *)
a(lemma_tac¨1 < mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_fc_tac[prime_divisor_thm] THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 6 (strip_asm_tac o µ_elim¨nÆ));
(* *** Goal "2.1" *** *)
a(i_contr_tac THEN swap_nth_asm_concl_tac 1);
a(DROP_NTH_ASM_T 3 ante_tac THEN cases_tac¨n = 0Æ
	THEN1 asm_rewrite_tac[] THEN REPEAT strip_tac);
a(all_fc_tac[prime_2_º_thm]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[º_def]));
a(all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 2 ante_tac THEN PC_T1 "lin_arith" prove_tac[]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨n = 0Æ
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.3" *** *)
a(∂_tac¨Ãk∑if k = p then e p + 1 else e kÆ
	THEN rewrite_tac[]);
a(LEMMA_T ¨{k|≥ (if k = p then e p + 1 else e k) = 0} =
	{p} ¿ {k|≥ e k = 0}Æ
	(fn th => asm_rewrite_tac[th, ¿_finite_thm, singleton_finite_thm])
	THEN1(PC_T1 "sets_ext1" rewrite_tac[] THEN strip_tac
		THEN cases_tac¨x = pÆ THEN asm_rewrite_tac[])
	THEN REPEAT strip_tac);
(* *** Goal "2.3.1" *** *)
a(LIST_DROP_NTH_ASM_T [2, 4] (MAP_EVERY ante_tac));
a(PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.3.2" *** *)
a(POP_ASM_T discard_tac);
a(cases_tac¨e p = 0Æ);
(* *** Goal "2.3.2.1" *** *)
a(LEMMA_T¨≥p ç {k|≥ e k = 0}Æ asm_tac THEN1 asm_rewrite_tac[]);
a(ALL_FC_T asm_rewrite_tac[ind_prod_Ó_def1]);
a(rewrite_tac[Ó_exp_1_thm]
	THEN  bc_tac[prove_rule[]¨µx y∑x = y ¥p*x = p*yÆ,
		ind_prod_Ó_local_thm]
	THEN REPEAT strip_tac);
a(rewrite_tac[]);
a(cases_tac¨x = pÆ THEN1 all_var_elim_asm_tac);
a(asm_rewrite_tac[]);
(* *** Goal "2.3.2.2" *** *)
a(LEMMA_T ¨{p} ¿ {k|≥ e k = 0} = {p} ¿ {k|≥ e k = 0 ± ≥k = p}Æ
	rewrite_thm_tac
	THEN1 (POP_ASM_T ante_tac THEN PC_T1 "sets_ext1" prove_tac[]));
a(LEMMA_T ¨{k|≥ e k = 0} = {p} ¿ {k|≥ e k = 0 ± ≥k = p}Æ
	rewrite_thm_tac
	THEN1 (POP_ASM_T ante_tac THEN PC_T1 "sets_ext1" prove_tac[]));
a(LEMMA_T¨≥p ç {k|≥ e k = 0 ± ≥k = p}Æ asm_tac
	THEN1 (POP_ASM_T ante_tac THEN PC_T1 "sets_ext1" prove_tac[]));
a(LEMMA_T¨{k|≥ e k = 0 ± ≥k = p} ç FiniteÆ strip_asm_tac
	THEN1 (bc_thm_tac Ä_finite_thm THEN ∂_tac¨{k|≥ e k = 0}Æ
		THEN REPEAT strip_tac
		THEN PC_T1 "sets_ext1" prove_tac[]));
a(ALL_FC_T rewrite_tac[ind_prod_Ó_def1]);
a(rewrite_tac[Ó_exp_def, times_assoc_thm]);
a(bc_tac[prove_rule[]¨µx y∑x = y ± a = b ¥ p*a*x = p*b*yÆ,
		ind_prod_Ó_local_thm]
	THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
val €fund_thm_arith_thm1› = save_pop_thm "fund_thm_arith_thm1";
=TEX
%%%%
%%%% REAL INTEGRAL DOMAINS
%%%%
=SML
set_goal([], ¨Universe ç RealIDÆ);
a(rewrite_tac[real_i_d_def]);
val €Ø_real_i_d_thm› = save_pop_thm "Ø_real_i_d_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µV∑ V Ä RealID ¥ •V ç RealIDÆ);
a(PC_T1 "sets_ext1" rewrite_tac[real_i_d_def]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
val €•_real_i_d_thm› = save_pop_thm "•_real_i_d_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨˙ ç RealIDÆ);
a(rewrite_tac[˙_def]);
a(bc_thm_tac •_real_i_d_thm THEN rewrite_tac[]);
val €˙_real_i_d_thm› = save_pop_thm "˙_real_i_d_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨˙ = {x | ∂i∑x = ˙Ø i}Æ);
a(PC_T1 "sets_ext1" rewrite_tac[˙_def, real_i_d_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(swap_nth_asm_concl_tac 1 THEN REPEAT strip_tac);
a(∂_tac ¨{x | ∂i∑x = ˙Ø i}Æ THEN rewrite_tac[]
	THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
(* *** Goal "1.1" *** *)
a(∂_tac¨Ó˙ 1Æ THEN rewrite_tac[˙Ø_Ó˙_thm]);
(* *** Goal "1.2" *** *)
a(∂_tac¨i + i'Æ THEN rewrite_tac[˙Ø_plus_homomorphism_thm]);
(* *** Goal "1.3" *** *)
a(∂_tac¨~iÆ THEN rewrite_tac[˙Ø_minus_thm]);
(* *** Goal "1.4" *** *)
a(∂_tac¨i * i'Æ THEN rewrite_tac[˙Ø_times_homomorphism_thm]);
(* *** Goal "1.5" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(˙_induction_tac¨iÆ);
(* *** Goal "2.1" *** *)
a(asm_rewrite_tac[˙Ø_Ó˙_thm]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[˙Ø_minus_thm] THEN all_asm_fc_tac[]);
(* *** Goal "2.3" *** *)
a(rewrite_tac[˙Ø_plus_homomorphism_thm] THEN all_asm_fc_tac[]);
val €˙_thm› = save_pop_thm "˙_thm";
=TEX
%%%%
%%%% FIELDS
%%%%
=SML
set_goal([], ¨Universe ç RealFieldÆ);
a(rewrite_tac[real_field_def, Ø_real_i_d_thm]);
val €Ø_real_field_thm› = save_pop_thm "Ø_real_field_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µV∑ V Ä RealField ¥ •V ç RealFieldÆ);
a(PC_T1 "sets_ext1" rewrite_tac[real_field_def,
	real_i_d_def]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
val €•_real_field_thm› = save_pop_thm "•_real_field_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨%bbQ% ç RealFieldÆ);
a(rewrite_tac[rat_def]);
a(bc_thm_tac •_real_field_thm THEN rewrite_tac[]);
val €rat_real_i_d_thm› = save_pop_thm "rat_real_i_d_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨˙ Ä %bbQ%Æ);
a(PC_T1"sets_ext1" rewrite_tac[rat_def, ˙_def, real_field_def]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
val €˙_Ä_rat_thm› = save_pop_thm "˙_Ä_rat_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA∑ FieldOfFractions A ç RealFieldÆ);
a(REPEAT strip_tac THEN rewrite_tac[field_of_fractions_def]);
a(bc_thm_tac •_real_field_thm);
a(PC_T1 "sets_ext1" prove_tac[]);
val €field_of_fractions_field_thm› = save_pop_thm "field_of_fractions_field_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨%bbQ% = FieldOfFractions ˙Æ);
a(rewrite_tac[field_of_fractions_def, rat_def]);
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac
	THEN1 all_asm_fc_tac[]);
a(DROP_NTH_ASM_T 2 bc_thm_tac THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac
	THEN PC_T1"sets_ext1" rewrite_tac[˙_def, real_field_def]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
val €rat_field_of_fractions_thm› = save_pop_thm "rat_field_of_fractions_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA∑
	A ç RealID
¥	FieldOfFractions A =
	{x | ∂a b∑a ç A ± b ç A ± ≥b = ÓØ 0 ± x = a * b õ-õ1}Æ);
a(PC_T1 "sets_ext1" rewrite_tac[real_i_d_def, field_of_fractions_def,
	real_field_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T ¨x ç {y | ∂ a b∑ a ç A ± b ç A ± ≥ b = ÓØ 0 ± y = a * b õ-õ1}Æ
	(fn th => ante_tac th THEN rewrite_tac[]));
a(POP_ASM_T bc_thm_tac THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
(* *** Goal "1.1" *** *)
a(∂_tac¨ÓØ 1Æ THEN ∂_tac¨ÓØ 1Æ THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(∂_tac¨a * b' + a' * bÆ THEN ∂_tac¨b*b'Æ);
a(asm_rewrite_tac[Ø_times_eq_0_thm]);
a(REPEAT strip_tac
	THEN_TRY LIST_GET_NTH_ASM_T [7, 8, 9] bc_tac
	THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (fn th =>
	ALL_FC_T1 fc_§_canon
	once_rewrite_tac[conv_rule(ONCE_MAP_C (RIGHT_C eq_sym_conv))
	Ø_times_cancel_thm] THEN asm_tac th));
a(DROP_NTH_ASM_T 2 (fn th =>
	ALL_FC_T1 fc_§_canon
	once_rewrite_tac[conv_rule(ONCE_MAP_C (RIGHT_C eq_sym_conv))
	Ø_times_cancel_thm] THEN asm_tac th));
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(rewrite_tac[Ø_times_plus_distrib_thm, Ø_times_assoc_thm]);
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µa b c d∑a*b õ-õ1*c*d = (a*c)*(b õ-õ1 *d)Æ]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(conv_tac (RANDS_C Ø_anf_conv) THEN strip_tac);
(* *** Goal "1.3" *** *)
a(∂_tac¨~aÆ THEN ∂_tac¨bÆ THEN 
	LIST_DROP_NTH_ASM_T [5] (ALL_FC_T asm_rewrite_tac));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "1.4" *** *)
a(∂_tac¨a*a'Æ THEN ∂_tac¨b*b'Æ);
a(asm_rewrite_tac[Ø_times_eq_0_thm]);
a(LIST_DROP_NTH_ASM_T [7] (ALL_FC_T asm_rewrite_tac));
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]
	THEN PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "1.5" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_times_eq_0_thm]));
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(∂_tac¨bÆ THEN ∂_tac¨aÆ THEN asm_rewrite_tac[]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "1.6" *** *)
a(∂_tac¨xÆ THEN ∂_tac¨ÓØ 1Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [2, 3] bc_tac
	THEN REPEAT strip_tac
	THEN DROP_NTH_ASM_T 1 bc_thm_tac
	THEN REPEAT strip_tac);
val €field_of_fractions_thm› = save_pop_thm "field_of_fractions_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨%bbQ% = {x | ∂i:˙; m:Ó∑x = ˙Ø i * ÓØ (m+1) õ-õ1}Æ);
a(rewrite_tac[rat_field_of_fractions_thm]);
a(strip_asm_tac ˙_real_i_d_thm);
a(ALL_FC_T rewrite_tac[field_of_fractions_thm]);
a(rewrite_tac[˙_thm]);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(strip_asm_tac(µ_elim¨i'Æ˙_cases_thm1)
	THEN all_var_elim_asm_tac1);
(* *** Goal "1.1" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[˙Ø_Ó˙_thm,
	ÓØ_one_one_thm,
	pc_rule1 "lin_arith" prove_rule[]
	¨(≥m = 0 § 1 º m) ± µi∑1 + i = i + 1Æ,
	º_def] THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(∂_tac¨iÆ THEN ∂_tac¨i'Æ THEN rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(∂_tac¨~iÆ THEN ∂_tac¨mÆ THEN rewrite_tac[˙Ø_minus_thm,
	˙Ø_Ó˙_thm]);
a(lemma_tac¨≥ÓØ (m + 1) = ÓØ 0Æ
	THEN1 rewrite_tac[ÓØ_one_one_thm]);
a(ALL_FC_T rewrite_tac[Ø_minus_recip_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨˙Ø iÆ THEN ∂_tac¨˙Ø(Ó˙(m+1))Æ THEN
	rewrite_tac[˙Ø_Ó˙_thm, ÓØ_one_one_thm]);
a(strip_tac THEN1 prove_tac[]);
a(∂_tac¨Ó˙(m+1)Æ THEN rewrite_tac[˙Ø_Ó˙_thm]);
val €rat_thm› = save_pop_thm "rat_thm";
=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val €sections› = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="wrk074.th.doc", theory="-"};
end;
=TEX
} %\Hide
\end{document}

=TEX
%%%%
%%%%
=IGN
