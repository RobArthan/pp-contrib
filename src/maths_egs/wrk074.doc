=IGN
********************************************************************************
wrk073.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}

\def\ThmsII#1#2{%
{\vertbarfalse
\begin{minipage}[t]{0.48\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.48\hsize}
#2
\end{minipage}}}

\def\ThmsIII#1#2#3{%
{\vertbarfalse
\begin{minipage}[t]{0.32\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#2
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#3
\end{minipage}}}
\def\Hide#1{\relax}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\C{\mathbb{C}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}

\def\LogName{\mbox{{\sf log}}}
\def\Log#1{\LogName(#1)}

\def\SinName{\mbox{{\sf sin}}}
\def\Sin#1{\SinName(#1)}

\def\CosName{\mbox{{\sf cos}}}
\def\Cos#1{\CosName(#1)}

\def\Abs#1{|#1|}

\def\ElemsName{\mbox{{\em Elems}}}
\def\Elems#1{\ElemsName(#1)}

\def\SizeName{\#}
\def\Size#1{\#\left(#1\right)}

%\def\Binomial#1#2{\left(\begin{array}{c}#1\\#2\end{array}\right)}
\def\Binomial#1#2{C_{#2}^{#1}}

\title{Mathematical Case Studies: Number Theory}
\author{Rob Arthan\\{\tt rda@lemma-one.com}}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
Beginnings of number theory in \ProductHOL.
\end{abstract}
%\newpage
%\tableofcontents
%\newpage
\section{INTRODUCTION}

Birthday problem etc. For inclusion in wrk073.doc presently.

\section{THE THEORY {\em fincomb}}\label{theory}

\subsection{Preliminaries}
=SML
force_delete_theory "number_theory" handle Fail _ => ();
open_theory"fincomb";
new_theory "number_theory";
set_merge_pcs["basic_hol1", "'sets_alg", "'ú", "'¯"];
=TEX

\subsection{Real Integral Domains}
In general, an integral domain is a ring without zero divisors.
As we are only concerned with subrings of the reals here, any subring is an integral domain. 
 
¹HOLCONST
Ü ÛRealIntegralDomainÝ : ¯ SET SET
÷üüüüüü
Ü µA· A  RealIntegralDomain ¤
Ü	î¯ 1  A
Ü ±	(µx y·x  A ± y  A ´ x + y  A)
Ü ±	(µx·x  A ´ ~x  A)
Ü ±	(µx y·x  A ± y  A ´ x * y  A)
°

¹HOLCONST
Ü Ûú‰RÝ : ¯ SET
÷üüüüüü
Ü ú‰R = ¥RealIntegralDomain
°
=SML
declare_alias("ú", ¬ú‰R®);
=TEX
\subsection{Real Fields}
¹HOLCONST
Ü ÛRealFieldÝ : ¯ SET SET
÷üüüüüü
Ü µA· A  RealField ¤
Ü	A  RealIntegralDomain
Ü ±	(µx·x  A \ {î¯ 0} ´ x ›-›1  A)
°

¹HOLCONST
Ü Û%bbQ%‰RÝ : ¯ SET
÷üüüüüü
Ü %bbQ%‰R = ¥RealField
°
=SML
declare_alias("%bbQ%", ¬%bbQ%‰R®);
=TEX

%\bibliographystyle{fmu}
%\bibliography{fmu}

%\appendix
{%\HOLindexOff
\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{wrk073.th}}

=TEX

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
=TEX
%%%%
%%%%
=SML
val Ûreal_integral_domain_defÝ = get_spec ¬RealIntegralDomain®;
val Ûreal_field_defÝ = get_spec ¬RealField®;
val Ûú_defÝ = get_spec ¬ú‰R®;
val Ûrat_defÝ = get_spec ¬%bbQ%‰R®;
=TEX
%%%%
%%%%
=SML
set_goal([], ¬µV· V € RealIntegralDomain ´ ¥V  RealIntegralDomain®);
a(PC_T1 "sets_ext1" rewrite_tac[real_integral_domain_def]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
val Û¥_real_integral_domain_thmÝ = save_pop_thm "¥_real_integral_domain_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¬ú  RealIntegralDomain®);
a(rewrite_tac[ú_def]);
a(bc_thm_tac ¥_real_integral_domain_thm THEN rewrite_tac[]);
val Ûú_real_integral_domain_thmÝ = save_pop_thm "ú_real_integral_domain_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¬ú = {x | ¶i·x = ú¯ i}®);
a(PC_T1 "sets_ext1" rewrite_tac[ú_def, real_integral_domain_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(swap_nth_asm_concl_tac 1 THEN REPEAT strip_tac);
a(¶_tac ¬{x | ¶i·x = ú¯ i}® THEN rewrite_tac[]
	THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
(* *** Goal "1.1" *** *)
a(¶_tac¬îú 1® THEN rewrite_tac[ú¯_îú_thm]);
(* *** Goal "1.2" *** *)
a(¶_tac¬i + i'® THEN rewrite_tac[ú¯_plus_homomorphism_thm]);
(* *** Goal "1.3" *** *)
a(¶_tac¬~i® THEN rewrite_tac[ú¯_minus_thm]);
(* *** Goal "1.4" *** *)
a(¶_tac¬i * i'® THEN rewrite_tac[ú¯_times_homomorphism_thm]);
(* *** Goal "1.5" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(ú_induction_tac¬i®);
(* *** Goal "2.1" *** *)
a(asm_rewrite_tac[ú¯_îú_thm]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[ú¯_minus_thm] THEN all_asm_fc_tac[]);
(* *** Goal "2.3" *** *)
a(rewrite_tac[ú¯_plus_homomorphism_thm] THEN all_asm_fc_tac[]);
val Ûú_thmÝ = save_pop_thm "ú_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¬µV· V € RealField ´ ¥V  RealField®);
a(PC_T1 "sets_ext1" rewrite_tac[real_field_def,
	real_integral_domain_def]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
val Û¥_real_field_thmÝ = save_pop_thm "¥_real_field_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¬%bbQ%  RealField®);
a(rewrite_tac[rat_def]);
a(bc_thm_tac ¥_real_field_thm THEN rewrite_tac[]);
val Ûrat_real_integral_domain_thmÝ = save_pop_thm "rat_real_integral_domain_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¬%bbQ% = {x | ¶i:ú; m:î·x = ú¯ i * î¯ (m+1) ›-›1}®);
a(PC_T1 "sets_ext1" rewrite_tac[rat_def,
	real_field_def, real_integral_domain_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(swap_nth_asm_concl_tac 1 THEN REPEAT strip_tac);
a(¶_tac ¬{x | ¶i:ú; m:î·x = ú¯ i * î¯ (m+1) ›-›1}® THEN rewrite_tac[]
	THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
(* *** Goal "1.1" *** *)
a(¶_tac¬îú 1® THEN ¶_tac¬0® THEN rewrite_tac[ú¯_îú_thm]);
(* *** Goal "1.2" *** *)
a(¶_tac¬i * îú (m'+1) + i' * îú(m+1)® THEN ¶_tac¬m*m' + m + m'®);
a(lemma_tac¬³î¯(m+1) = î¯ 0®
	THEN1 rewrite_tac[î¯_one_one_thm]);
a(ALL_FC_T1 fc_¤_canon
	once_rewrite_tac[conv_rule(ONCE_MAP_C (RIGHT_C eq_sym_conv))
		¯_times_cancel_thm]);
a(POP_ASM_T discard_tac);
a(lemma_tac¬³î¯(m'+1) = î¯ 0®
	THEN1 rewrite_tac[î¯_one_one_thm]);
a(ALL_FC_T1 fc_¤_canon
	once_rewrite_tac[conv_rule(ONCE_MAP_C (RIGHT_C eq_sym_conv))
		¯_times_cancel_thm]);
a(LEMMA_T ¬(m * m' + m + m') + 1 = (m+1)*(m'+1)®
	(fn th => rewrite_tac[th, î¯_times_homomorphism_thm,
	¯_times_plus_distrib_thm, ¯_times_assoc_thm])
	THEN1 PC_T1 "lin_arith" prove_tac[]);
a(lemma_tac¬³î¯(m+1) = î¯ 0®
	THEN1 rewrite_tac[î¯_one_one_thm]);
a(ALL_FC_T rewrite_tac[¯_recip_clauses]);
a(rewrite_tac[pc_rule1 "¯_lin_arith" prove_rule[]
	¬µa b c d·(a*b ›-›1)*c*d = (a*c)*(b ›-›1 *d)®]);
a(ALL_FC_T rewrite_tac[¯_recip_clauses]);
a(rewrite_tac[pc_rule1 "¯_lin_arith" prove_rule[]
	¬µa b c d:¯·a*b*c*d = a*(b*c)*d®]);
a(ALL_FC_T rewrite_tac[¯_recip_clauses]);
a(rewrite_tac[pc_rule1 "¯_lin_arith" prove_rule[]
	¬µa b c d:¯· a*(b*c)*d = a*c*b*d®,
	ú¯_plus_homomorphism_thm,
	ú¯_times_homomorphism_thm,
	ú¯_îú_thm]);
a(ALL_FC_T rewrite_tac[¯_recip_clauses]);
(* *** Goal "1.3" *** *)
a(¶_tac¬~i® THEN ¶_tac¬m® THEN rewrite_tac[ú¯_minus_thm]
	THEN PC_T1 "¯_lin_arith" prove_tac[]);
(* *** Goal "1.4" *** *)
a(¶_tac¬i*i'® THEN ¶_tac¬m*m'+m + m'®);
a(LEMMA_T ¬(m * m' + m + m') + 1 = (m+1)*(m'+1)®
	(fn th => rewrite_tac[th,
	î¯_times_homomorphism_thm,
	ú¯_times_homomorphism_thm])
	THEN1 PC_T1 "lin_arith" prove_tac[]);
a(lemma_tac¬³î¯(m+1) = î¯ 0 ± ³î¯(m'+1) = î¯ 0®
	THEN1 rewrite_tac[î¯_one_one_thm]);
a(ALL_FC_T rewrite_tac[¯_recip_clauses]
	THEN PC_T1 "¯_lin_arith" prove_tac[]);
(* *** Goal "1.5" *** *)
a(POP_ASM_T (ante_tac o rewrite_rule[¯_times_eq_0_thm]));
a(strip_asm_tac(µ_elim¬i®ú_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN rewrite_tac[ú¯_minus_thm,
		ú¯_îú_thm, î¯_one_one_thm,
		pc_rule1 "¯_lin_arith" prove_rule[]
		¬µx:¯·~x = î¯ 0 ¤ x = î¯ 0®,
		pc_rule1 "lin_arith" prove_rule[]
		¬µm·(³m = 0 ¤ 1 ¼ m) ± 1 + m = m + 1®,
		prove_rule[]¬µp q·³(p ² q) ¤ ³p ± ³q®,
		¼_def]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "1.5.1" *** *)
a(lemma_tac¬³î¯(i+1) = î¯ 0®
	THEN1 rewrite_tac[î¯_one_one_thm]);
a(ALL_FC_T rewrite_tac[¯_recip_clauses]);
a(rewrite_tac[î¯_recip_thm]);
a(¶_tac¬îú (m+1)® THEN ¶_tac¬i®
	THEN rewrite_tac[ú¯_îú_thm, µ_elim¬î¯(m+1)®¯_times_order_thm]);
(* *** Goal "1.5.2" *** *)
a(lemma_tac¬³î¯(i+1) = î¯ 0®
	THEN1 rewrite_tac[î¯_one_one_thm]);
a(rewrite_tac[pc_rule1 "¯_lin_arith" prove_rule[]
	¬µa b:¯· ~a*b = ~(a*b)®]);
a(lemma_tac¬³î¯(i+1) * î¯(m + 1)›-›1 = î¯ 0®
	THEN1 asm_rewrite_tac[¯_times_eq_0_thm]);
a(ALL_FC_T rewrite_tac[¯_minus_recip_thm, ¯_recip_clauses]);
a(rewrite_tac[î¯_recip_thm]);
a(¶_tac¬~(îú (m+1))® THEN ¶_tac¬i®
	THEN rewrite_tac[ú¯_îú_thm,
	ú¯_minus_thm,
	pc_rule1 "¯_lin_arith" prove_rule[]
	¬µa b:¯· ~a*b = ~(a*b)®,
	µ_elim¬î¯(m+1)®¯_times_order_thm]);
(* *** Goal "1.6" *** *)
a(swap_nth_asm_concl_tac 1 THEN all_var_elim_asm_tac1
	THEN prove_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(ú_induction_tac¬i®);
(* *** Goal "2.1" *** *)
a(rewrite_tac[ú¯_îú_thm]);
a(POP_ASM_T bc_thm_tac THEN rewrite_tac[î¯_one_one_thm]);
a(induction_tac¬m® THEN1 asm_rewrite_tac[]);
a(once_rewrite_tac[î¯_plus_homomorphism_thm]);
a(DROP_NTH_ASM_T 4 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(rewrite_tac[ú¯_minus_thm,
	pc_rule1 "¯_lin_arith" prove_rule[]
	¬µa b:¯· ~a*b = ~(a*b)®]);
a(DROP_NTH_ASM_T 4 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2.3" *** *)
a(rewrite_tac[ú¯_plus_homomorphism_thm,
	¯_times_plus_distrib_thm]);
a(DROP_NTH_ASM_T 6 bc_thm_tac THEN REPEAT strip_tac);
val Ûrat_thmÝ = save_pop_thm "rat_thm";
=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val ÛsectionsÝ = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="wrk073.th.doc", theory="-"};
end;
=TEX
} %\Hide
\end{document}

=TEX
%%%%
%%%%
=IGN
