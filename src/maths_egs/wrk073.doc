=IGN
********************************************************************************
wrk073.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}

\def\ThmsII#1#2{%
{\vertbarfalse
\begin{minipage}[t]{0.48\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.48\hsize}
#2
\end{minipage}}}

\def\ThmsIII#1#2#3{%
{\vertbarfalse
\begin{minipage}[t]{0.32\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#2
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#3
\end{minipage}}}
\def\Hide#1{\relax}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\C{\mathbb{C}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}

\def\LogName{\mbox{{\sf log}}}
\def\Log#1{\LogName(#1)}

\def\SinName{\mbox{{\sf sin}}}
\def\Sin#1{\SinName(#1)}

\def\CosName{\mbox{{\sf cos}}}
\def\Cos#1{\CosName(#1)}

\def\Abs#1{|#1|}

\def\ElemsName{\mbox{{\em Elems}}}
\def\Elems#1{\ElemsName(#1)}

\def\SizeName{\#}
\def\Size#1{\#\left(#1\right)}

%\def\Binomial#1#2{\left(\begin{array}{c}#1\\#2\end{array}\right)}
\def\Binomial#1#2{C_{#2}^{#1}}

\title{Mathematical Case Studies: Finite Combinatorics}
\author{Rob Arthan\\{\tt rda@lemma-one.com}}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}

This document presents some definitions and theorems from elementary finite combinatorics.
The definitions include a ``fold'' operator for finite sets and the operation that sums a real-valued function on a finite indexed set.
The theorems include: more facts about finiteness and the size of finite sets; algebraic properties of indexed sums; induction over finitely-supported functions; the inclusion/exclusion principle;
the binomial coefficients and their basic properties, including the formula for the number of combinations and the binomial theorem.

\end{abstract}
%\newpage
%\tableofcontents
%\newpage
\section{INTRODUCTION}
This document is one of a set of documents containing mathematical case studies in  {\ProductHOL}.
It deals with some finite combinatorics.
Notable results include the inclusion/exclusion principle, the formula for the number of combinations and the binomial theorem.

Section~\ref{theory} below gives an overview of the theory, including all the specifications and a guide to the theorems proved.
Section~\ref{listing} contains a listing of all the theorems proved in the theory.
An index to the specifications and the theorems is given at the end of the document.

\section{THE THEORY {\em fincomb}}\label{theory}

\subsection{Preliminaries}
The following commands set up a theory to hold the definitions, theorems, etc.,  and a proof context that is convenient for the work.
The theory is a child of the theory ``analysis'' (defined in~\cite{LEMMA1/HOL/WRK066}) from which we use several definitions, in particular, the characteristic function $\chi_A$ of a set $A$.

=SML
force_delete_theory"fincomb" handle Fail _ => ();
open_theory"analysis";
new_theory"fincomb";
set_merge_pcs["basic_hol1", "'sets_alg", "'Ø"];
=TEX
\subsection{Folding Binary Operators over Finite Sets}

The following definition of a ``fold'' operation for finite sets is parametrised by three things: an associative and commutative binary operator, $p$, with identity element, $e$, and a ``valuation'' function $v$; the operation maps the valuation function over a set combining the resulting values with the product operation.


πHOLCONST
‹ €SetFold› : 'b ≠ ('b ≠ 'b ≠ 'b) ≠ ('a ≠ 'b) ≠ 'a SET ≠ 'b
˜¸¸¸¸¸¸
‹ µe p v∑
‹	(µx∑ p x e = x)
‹ ±	(µx y∑ p x y = p y x)
‹ ±	(µx y z∑ p (p x y) z = p x (p y z))
‹ ¥	SetFold e p v {}  = e
‹ ±	µx a∑	a ç Finite ± ≥x ç a
‹	¥	SetFold e p v ({x} ¿ a) = p (v x) (SetFold e p v a)
∞
This is based on an idea recommended by Nipkow and Paulson and works nicely. An alternative would be to combine $p$ and $v$ into a single function, say $f = \lambda x y \bullet p(v x) y$
but then the algebraic laws that $f$ must satisfy have an unfamiliar form. The two approaches are interdefinable.

The theorems in the theory begin by with some lemmas about finite sets and their sizes.
These are then used to prove to lemmas needed to prove the consistency of the definition of {\em SetFold}.

\ThmsIII{%
=GFT
¿_finite_thm
list_finite_size_thm
elems_finite_thm
=TEX
}{%
=GFT
set_fold_consistent_lemma1
set_fold_consistent_lemma2
=TEX
}{%
=GFT
SetFold_consistent
set_fold_def
=TEX
}

\subsection{Sums over Finite Indexed Sets}
A useful application of the set fold operation is to define the following indexed sum operation. Given a finite index set, $a$, and a function, $f$, assigning a real number to each member of $a$,
=INLINEFT
IndSum a f
=TEX
\ is the indexed sum $\sum_{x\in a}f(x)$.


πHOLCONST
‹ €IndSum› : 'a SET ≠ ('a ≠ Ø) ≠ Ø
˜¸¸¸¸¸¸
‹ µf∑	IndSum {} f = ÓØ 0
‹ ±	µx a∑	a ç Finite ± ≥x ç a
‹	¥	IndSum ({x} ¿ a) f = f x + IndSum a f
∞

We will write $\sum\,a\,f$ as shorthand for
=INLINEFT
IndSum a f
=TEX
.
=SML
declare_alias("ì", ¨IndSumÆ);
=TEX

The consistency proof for {\em IndSum} is very simple given the set fold operation.

\ThmsII{%
=GFT
IndSum_consistent
=TEX
}{%
=GFT
ind_sum_def
=TEX
}
\subsection{Binomial Coefficients}

We define the binomial coefficient $\Binomial{n}{m}$ by recursion equations in the usual way.
The consistency of the definition is proved automatically.

πHOLCONST
‹ €Binomial› : Ó ≠ Ó ≠ Ó 
˜¸¸¸¸¸¸
‹	Binomial 0 0 = 1
‹ ±	(µm∑Binomial 0 (m+1) = 0)
‹ ±	(µn∑Binomial (n+1) 0 = 1)
‹ ±	(µn m∑ Binomial (n+1) (m+1) = Binomial n m + Binomial n (m+1))
∞
\subsection{Theorems}
After the consistency of the definitions, the first block of theorems extends the repertoire of lemmas about finite sets and their sizes.
The approach to this topic in the {\ProductHOL} library tends to characterise a finite set, $A$, as one that can be written as $\Elems{L}$ for some list $L$ and the size $\Size{A}$ as the length $\Size{L}$ where $L$ is a list of distinct elements with $\Elems{L} = A$.

The first few theorems are aimed at an alternative characterisation of a finite set $A$ as one that is in one-one correspondence with an initial subset of the natural numbers, $\{i | i < m\}$ for some $m$.
{\em En route} is proved the very useful fact that finiteness and size are preserved under bijections.

\ThmsIII{%
=GFT
singleton_finite_thm
size_Ä_diff_thm
range_finite_size_thm
length_map_thm
=TEX
}{%
=GFT
elems_map_thm
map_distinct_thm
nth_ç_elems_thm
elems_nth_thm
=TEX
}{%
=GFT
distinct_nth_thm
bijection_finite_size_thm
range_bijection_finite_size_thm
=TEX
}

The next block of theorems deal with the power set operator.
$\Zpset\,a$
 is defined in the {\ProductHOL} library by the bi-implication
$x \in \Zpset a \iff x \subseteq a$.
The first theorem below just recasts this as an equation.
There are then two trivial but quite useful lemmas about binary partitions of a power set.
This is followed by the theorem that, if $a$ is finite, then so is $\Zpset a$ and $\Size{\Zpset a} = 2^{\Size{a}}$

\ThmsII{%
=GFT
_thm
_split_thm
=TEX
}{%
=GFT
_split_thm1
finite_size__thm
=TEX
}

We now begin to develop the theory of indexed sums.
The first result is an example: if $A$ is finite,
then its size $\Size{A}$ may be calculated as the indexed sum $\sum_A\,1$.
The next few theorems show that the indexed sum operator $\sum_A\,f$ is linear in $f$ (i.e., it respects addition and multiplication by a constant) and give some useful consequences of this.

A principle that is applied almost unconsciously in informal reasoning is that the indexed sum $\sum_A f$ is a local property of $f$, in the sense that, if $f$ and $g$ are functions that agree on $A$, then $\sum_A f = \sum_A g$.
This block  of theorems concludes with one showing how indexed sums behave when the function is composed with a bijection: if $b$ is a bijection on the set $A$ and $B$ is the image of $A$ under $b$, then $\sum_B f = \sum_A (\lambda x\bullet f(b(x)))$

\ThmsIII{%
=GFT
ind_sum_size_thm
ind_sum_plus_thm
ind_sum_minus_thm
=TEX
}{%
=GFT
ind_sum_const_times_thm
ind_sum_0_thm
ind_sum_diff_0_thm
=TEX
}{%
=GFT
ind_sum_local_thm
ind_sum_0_bc_thm
bijection_ind_sum_thm
=TEX
}

We now have two lemmas for calculating the indexed sum in two cases where there is at most one non-zero value in the sum:

\ThmsII{
=GFT
ind_sum_—_singleton_thm
=TEX
}{%
=GFT
ind_sum_singleton_thm
=TEX
}

Next comes an induction principle for functions of finite support, i.e., functions $f$ such that $f(x) \not= 0$ for at most finitely many $x$.
If $p$ is any property of functions that is true for the characteristic function, $\chi_{\{x\}}$, of any singleton set, $\{x\}$, and that is preserved under addition and multiplication by a constant (for operands of finite support), then $p(f)$ holds for any function $f$ of finite support.

In working with an indexed sum $\sum_A f$, one can always assume that $f$ has finite support (by adjusting it to be 0 outside $A$ if necessary). This induction principle gives a different line of attack on $\sum_A f$, which can be particularly useful if the internal structure of $A$ is complex.

\ThmsII{
=GFT
fin_supp_induction_thm
=TEX
}{}

We will use the induction principle for functions of finite support to tackle the inclusion/exclusion principle.
The inclusion/exclusion principle deals with a family $U_i$ of sets where $i$ range over a finite and non-empty index set $I$.
The inclusion/exclusion principle is the following equation giving the size of the union of the $U_i$.
\begin{equation}
\Size{\bigcup_{i \in I} U_i} =
\sum_%
	{\begin{array}{c}J \in \Zpset I\\ J \not= \{\}\end{array}}%
		(-1)^{\Size{J} + 1}%
	\Size{\bigcap_{j \in J}U_j}
\end{equation}

This is a special case of a more general statement about indexed sums and the more general statement is actually rather simpler to prove.
The more general statement is the following, which holds for $U_i$ and $I$ above and any real-valued function $f$:
\begin{equation}
\sum_{x \in \bigcup_{i \in I} U_i} f(x)=
\sum_%
	{\begin{array}{c}J \in \Zpset I\\ J \not= \{\}\end{array}}%
		(-1)^{\Size{J} + 1}%
	\left(\sum_%
		{z \in \bigcap_{j \in J}U_j}%
			f(z)%
	\right)
\end{equation}

The statement about sizes follows immediately from the statement about indexed sums by applying it to the function $f(x) = 1$.
The statement about sums is better understood in the following more symmetric form in which $A = \bigcup_{i \in I}U_i$ is the range of the sum on the left-hand side of the above equation:
\begin{equation}
\sum_%
	{J \in \Zpset I}%
		(-1)^{\Size{J}}%
	\left(\sum_%
		{z \in A \cap \bigcap_{j \in J}U_j}%
			f(z)%
	\right) %
	= 0 \label{sym_inc_exc}
\end{equation}

Here, the intersections with $A$ in the range of the inner sum have no effect except when $J$ is empty.
The previous statement thus follows from the above simply by subtracting the sum over the non-empty $J$ from both sides of the equation.

It is quite natural to attempt to prove equation (\ref{sym_inc_exc}) by induction on $I$ (or on the size of $I$). This works, but the proof is somewhat complicated. Somewhat simpler is to work by induction on $A$, but it it still quite complex.
Instead, our proof of the inclusion/exclusion principle implements the above remarks together with the proof of equation (\ref{sym_inc_exc}) sketched below which works by induction on the structure of $f$.



Changing it to be identically 0 outside A if necessary, we may assume $f$ has finite support, and, as the left-hand side of (\ref{sym_inc_exc}) is easily seen to be linear in $f$, the principle of induction for functions of finite support means it is sufficient to prove (\ref{sym_inc_exc}) when $f = \chi_{\{x\}}$ is the characteristic function of a singleton set $\{x\}$.
For $f = \chi_{\{x\}}$, the summand $f(z)$ on the left-hand side of (\ref{sym_inc_exc}) is 1 or 0 according as $z = x$ or not.
Thus the inner sum is 1 if $x \in U_j$ for all $j \in J$ and vanishes otherwise.

So, if $x$ is not in any $U_j$, the left-hand side of (\ref{sym_inc_exc}) vanishes and we are done, and, if $x$ is in some $U_j$, (\ref{sym_inc_exc}) reduces to:
\begin{equation}
\sum_%
	{J \in \Zpset \{j \in I | x \in U_j\}}%
		(-1)^{\Size{J}}%
	= 0 \label{ind_sum_p}
\end{equation}

(Formally, we are appealing here to the special case of the inclusion/exclusion principle when $\Size{I}=2$, which states that $\sum_{B \cup C}f = \sum_B f + \sum_C f - \sum_{B \cap C}f$, with $B = \Zpset \{j \in I | x \in U_j\}$ and $C = \Zpset I \backslash B$.)

But now I claim that 
$
\sum_%
	{J \in \Zpset K}%
		(-1)^{\Size{J}}%
	= 0
$ for any non-empty indexed set $K$, which, taking $K=\{j \in I | x \in U_j\}$ in (\ref{ind_sum_p}) will complete the proof.

To see that $
\sum_%
	{J \in \Zpset K}%
		(-1)^{\Size{J}}%
	= 0
$ for any non-empty indexed set $K$, pick $k \in K$, then, as $J$ ranges over $\Zpset(K \backslash \{k\})$, the sets $J$ and $J \cup \{i\}$ range over $\Zpset K$ (with every member of $\Zpset K$ appearing exactly once).
As $(-1)^{\Size{J}} = -(-1)^{\Size{J \cup \{i\}}}$, the contributions of $J$ and $J \cup \{i\}$ cancel out and the sum is zero. (Formally, we are again using the special case of the principle for $\Size{I} = 2$ together with the result about indexed sums composed with a bijection.)

The above proof is captured in the following series of theorems, which give the main steps in the above argument in bottom-up order:

\ThmsIII{%
=GFT
ind_sum_¿_thm
ind_sum__thm
=TEX
}{%
=GFT
ind_ﬁ_finite_thm
ind_sum_inc_exc_sym_thm
=TEX
}{%
=GFT
ind_sum_inc_exc_thm
size_inc_exc_thm
=TEX
}

After the inclusion/exclusion principle, we turn to something  a little simpler, proving that if $A$ is a set of size $n$, then $A$ has $\Binomial{n}{m}$ subsets of size $m$.
In a related vein we also prove the binomial theorem (but apart from the algebraic facts about the binomial function that are used, the proofs are separate).

\ThmsIII{%
=GFT
binomial_0_clauses
binomial_less_0_thm
=TEX
}{
=GFT
binomial_eq_thm
combinations_finite_size_thm
=TEX
}{
=GFT
binomial_thm1
binomial_thm
=TEX
}



\bibliographystyle{fmu}
\bibliography{fmu}

%\appendix
{%\HOLindexOff
\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{wrk073.th}}

=TEX

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
=TEX
%%%%
%%%%
=SML
val €binomial_def› = get_spec ¨BinomialÆ;
=TEX
The following should definitely go in the finite sets theory ASAP. !!! TBD !!!
%%%%
%%%%
=SML
set_goal([], ¨µA B∑
	 (A ¿ B) ç Finite § A ç Finite ± B ç Finite
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac ¨A Ä A ¿ BÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
(* *** Goal "2" *** *)
a(lemma_tac ¨B Ä A ¿ BÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨BÆ, ¨BÆ));
a(finite_induction_tac ¨AÆ THEN1 asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(LEMMA_T¨({x} ¿ A) ¿ B = {x} ¿ A ¿ BÆ
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(bc_thm_tac singleton_¿_finite_thm THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
val €¿_finite_thm› = save_pop_thm "¿_finite_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µa m∑
	 a ç Finite ± #a = m
§	∂list∑list ç Distinct ± Elems list = a ± #list = mÆ);
a(REPEAT_UNTIL is_± strip_tac THEN strip_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN all_var_elim_asm_tac1
	THEN all_fc_tac[finite_distinct_elems_thm]);
a(∂_tac¨listÆ THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[distinct_size_length_thm]);
(* *** Goal "2" *** *)
a(strip_tac THEN all_var_elim_asm_tac1 THEN all_asm_ante_tac);
a(list_induction_tac¨listÆ THEN
	asm_rewrite_tac[empty_finite_thm, elems_def, distinct_def,
		length_def, size_empty_thm]);
a(µ_tac THEN ¥_tac);
a(ALL_FC_T asm_rewrite_tac[singleton_¿_finite_thm,
	size_singleton_¿_thm]);
val €list_finite_size_thm› = save_pop_thm "list_finite_size_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µlist∑ Elems list ç FiniteÆ);
a(REPEAT strip_tac);
a(list_induction_tac ¨listÆ
	THEN asm_rewrite_tac[elems_def, empty_finite_thm]);
a(ALL_FC_T rewrite_tac[singleton_¿_finite_thm]);
val €elems_finite_thm› = save_pop_thm "elems_finite_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx list1 n∑
	x ç Elems list1 ± list1 ç Distinct ± #list1 = n + 1 
¥	∂list2∑ list2 ç Distinct ± Elems list2 = Elems list1 \ {x}
	± #list2 = nÆ);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) list_finite_size_thm]);
a(REPEAT µ_tac THEN ¥_tac);
a(once_rewrite_tac[prove_rule[]¨µp q∑p ± q § (p ± (p ¥ q))Æ]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ä_finite_thm);
a(∂_tac¨Elems list1Æ THEN rewrite_tac[elems_finite_thm]);
a(PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T¨#(Elems list1) = #list1Æ ante_tac
	THEN1 (bc_thm_tac distinct_size_length_thm
		THEN REPEAT strip_tac));
a(LEMMA_T¨Elems list1 = {x} ¿ Elems list1 \ {x}Æ (fn th => conv_tac(LEFT_C(once_rewrite_conv[th])))
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(LEMMA_T¨≥x ç Elems list1 \ {x}Æ asm_tac
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(ALL_FC_T rewrite_tac[size_singleton_¿_thm]);
a(asm_rewrite_tac[]);
val €set_fold_consistent_lemma1› = save_pop_thm "set_fold_consistent_lemma1";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µe p v∑
	(µx∑ p x e = x)
±	(µx y∑ p x y = p y x)
±	(µx y z∑ p (p x y) z = p x (p y z))
¥	µn list1 list2∑
	list1 ç Distinct ± list2 ç Distinct
±	#list1 = n
±	Elems list1 = Elems list2
¥	Fold (Ã x y∑ p (v x) y) list1 e
=	Fold (Ã x y∑ p (v x) y) list2 eÆ);
a(REPEAT µ_tac THEN ¥_tac THEN µ_tac);
a(induction_tac¨nÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T ¨list1 = [] ± list2 = []Æ
	(fn th => rewrite_tac[th, fold_def]));
a(DROP_NTH_ASM_T 2 ante_tac);
a(strip_asm_tac (µ_elim¨list1Æ list_cases_thm)
	THEN asm_rewrite_tac[length_def]
	THEN all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN rewrite_tac[elems_def]);
a(strip_asm_tac (µ_elim¨list2Æ list_cases_thm)
	THEN asm_rewrite_tac[elems_def]
	THEN all_var_elim_asm_tac1);
a(PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T¨#(Elems list1) = #list1Æ ante_tac
	THEN1 (bc_thm_tac distinct_size_length_thm
		THEN REPEAT strip_tac));
a(TOP_ASM_T rewrite_thm_tac);
a(LEMMA_T¨#(Elems list2) = #list2Æ rewrite_thm_tac
	THEN1 (bc_thm_tac distinct_size_length_thm
		THEN REPEAT strip_tac));
a(GET_NTH_ASM_T 2 rewrite_thm_tac THEN strip_tac);
a(DROP_NTH_ASM_T 3 ante_tac);
a(strip_asm_tac (µ_elim¨list1Æ list_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN rewrite_tac[length_def]
	THEN strip_tac);
a(DROP_NTH_ASM_T 2 ante_tac);
a(strip_asm_tac (µ_elim¨list2Æ list_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN rewrite_tac[length_def]);
a(rename_tac[(¨list2'Æ, "L1"), (¨list2''Æ, "L2")]
	THEN strip_tac);
a(cases_tac¨x' = xÆ
	THEN1 all_var_elim_asm_tac);
(* *** Goal "2.1" *** *)
a(LIST_DROP_NTH_ASM_T [3, 4]
	(MAP_EVERY (strip_asm_tac o rewrite_rule[distinct_def])));
a(DROP_NTH_ASM_T 6 ante_tac);
a(rewrite_tac[elems_def] THEN REPEAT strip_tac);
a(LEMMA_T¨µa b∑≥x ç a ± ≥ x ç b ± {x} ¿ a = {x} ¿ b ¥ a = bÆ (fn th => all_fc_tac[th])
	THEN1 PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(spec_nth_asm_tac 2 ¨x'Æ THEN all_var_elim_asm_tac1);
(* *** Goal "2.1.2" *** *)
a(spec_nth_asm_tac 2 ¨x'Æ THEN all_var_elim_asm_tac1);
(* *** Goal "2.1.3" *** *)
a(rewrite_tac[fold_def]);
a(bc_thm_tac(prove_rule [] ¨µa b ∑a = b ¥ p (v x') a = p (v x') bÆ));
a(DROP_NTH_ASM_T 8 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(LIST_DROP_NTH_ASM_T [4, 5]
	(MAP_EVERY (strip_asm_tac o rewrite_rule[distinct_def])));
a(LEMMA_T¨x' ç Elems(Cons x L1)Æ ante_tac
	THEN1 (DROP_NTH_ASM_T 7 rewrite_thm_tac
		THEN PC_T1 "sets_ext1" rewrite_tac[elems_def]));
a(PC_T1 "sets_ext1" rewrite_tac[elems_def]);
a(REPEAT strip_tac);
a(lemma_tac¨≥#L1 = 0Æ
	THEN1 (strip_asm_tac (µ_elim¨L1Æ list_cases_thm)
		THEN all_var_elim_asm_tac1
		THEN all_asm_ante_tac
		THEN rewrite_tac[length_def, elems_def]));
a(LEMMA_T¨1 º #L1Æ (strip_asm_tac o
	once_rewrite_rule[plus_comm_thm] o
		rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(POP_ASM_T (strip_asm_tac o eq_sym_rule));
a(all_fc_tac[set_fold_consistent_lemma1]);
a(rename_tac[(¨list2Æ, "T1")]
	THEN rewrite_tac[fold_def]);
a(LEMMA_T¨
	Fold (Ã x'' y∑ p (v x'') y) L1 e =
	Fold (Ã x'' y∑ p (v x'') y) (Cons x' T1) eÆ
	rewrite_thm_tac);
(* *** Goal "2.2.1" *** *)
a(DROP_NTH_ASM_T 14 bc_thm_tac);
a(asm_rewrite_tac[distinct_def, elems_def]);
a(PC_T1 "sets_ext1" rewrite_tac[]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac);
(* *** Goal "2.2.2" *** *)
a(rewrite_tac[fold_def]);
a(GET_NTH_ASM_T 15 (rewrite_thm_tac o conv_rule(ONCE_MAP_C eq_sym_conv)));
a(DROP_NTH_ASM_T 16 (fn th => conv_tac
(LEFT_C(RATOR_C(RAND_C(once_rewrite_conv[th]))))));
a(DROP_NTH_ASM_T 15 rewrite_thm_tac);
a(bc_thm_tac(prove_rule [] ¨µa b ∑a = b ¥ p (v x') a = p (v x') bÆ));
a(LEMMA_T¨
	Fold (Ã x'' y∑ p (v x'') y) L2 e =
	Fold (Ã x'' y∑ p (v x'') y) (Cons x T1) eÆ
	(rewrite_thm_tac o rewrite_rule[fold_def]));
a(DROP_NTH_ASM_T 14 bc_thm_tac);
a(DROP_NTH_ASM_T 13 ante_tac);
a(asm_rewrite_tac[distinct_def, elems_def]);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 12 (strip_asm_tac o conv_rule(RAND_C eq_sym_conv)));
a(ALL_FC_T rewrite_tac[pc_rule1 "sets_ext1" prove_rule[]
	¨µx y a∑ ≥x = y ¥ {x} ¿ a \ {y} = ({x} ¿ a) \ {y}Æ]);
a(asm_rewrite_tac[]);
a(PC_T1 "sets_ext1" rewrite_tac[]);
a(contr_tac THEN all_var_elim_asm_tac);
val €set_fold_consistent_lemma2› = save_pop_thm "set_fold_consistent_lemma2";
=TEX
%%%%
%%%%
=SML
(*
drop_main_goal();
*)
push_consistency_goal ¨SetFoldÆ;
a(lemma_tac¨∂r∑ µa∑ a ç Finite ¥ r a ç Distinct
	± Elems(r a) = a
	± #(r a) = #aÆ);
(* *** Goal "1" *** *)
a(prove_∂_tac THEN strip_tac);
a(cases_tac¨a' ç FiniteÆ THEN asm_rewrite_tac[]);
a(asm_rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) list_finite_size_thm]);
(* *** Goal "2" *** *)
a(prove_∂_tac THEN REPEAT strip_tac);
a(∂_tac ¨Ãa∑ Fold (Ãx y∑p' (v' x) y) (r a) e'Æ
	THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(LEMMA_T¨r{} = []Æ (fn th => rewrite_tac[th, fold_def]));
a(DROP_NTH_ASM_T 4 (ante_tac o µ_elim¨{}Æ));
a(strip_asm_tac (µ_elim¨r{}Æ list_cases_thm)
	THEN asm_rewrite_tac[]);
a(rewrite_tac[empty_finite_thm, size_empty_thm, length_def]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨{x} ¿ a ç FiniteÆ 
	THEN1 (bc_thm_tac singleton_¿_finite_thm
		THEN REPEAT strip_tac));
a(LIST_DROP_NTH_ASM_T [7] all_fc_tac);
a(LEMMA_T¨
	Fold (Ã x y∑ p' (v' x) y) (r ({x} ¿ a)) e' =
	(Fold (Ã x y∑ p' (v' x) y) (Cons x (r a)) e')Æ
	(rewrite_thm_tac o rewrite_rule[fold_def]));
a(ante_tac(list_µ_elim[¨e'Æ, ¨p'Æ, ¨v'Æ]set_fold_consistent_lemma2));
a(PC_T1 "'propositions" asm_rewrite_tac[]);
a(STRIP_T bc_thm_tac);
a(∂_tac¨#a + 1Æ THEN asm_rewrite_tac[distinct_def, elems_def]);
a(bc_thm_tac size_singleton_¿_thm THEN REPEAT strip_tac);
val _ = save_consistency_thm ¨SetFoldÆ (pop_thm());
val €set_fold_def› = save_thm("set_fold_def", get_spec ¨SetFoldÆ);
=TEX
%%%%
%%%%
=SML
(*
drop_main_goal();
*)
push_consistency_goal ¨ìÆ;
a(∂_tac ¨Ãa f∑SetFold (ÓØ 0) ($ +) f aÆ);
a(µ_tac THEN rewrite_tac[] THEN bc_thm_tac(set_fold_def));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val _ = save_consistency_thm ¨ìÆ (pop_thm());
val €ind_sum_def› = save_thm("ind_sum_def", get_spec ¨ìÆ);
=TEX
%%%%
%%%%
=SML
val €singleton_finite_thm› = save_thm("singleton_finite_thm",
	rewrite_rule[empty_finite_thm]
		(µ_elim¨{}Æ singleton_¿_finite_thm));
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µa b∑ a ç Finite ± b Ä a ¥ #a = #(a \ b) + #bÆ);
a(REPEAT strip_tac);
a(lemma_tac¨a \ b Ä a ± (a \ b) ° b = {} ± a = (a \ b) ¿ bÆ
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
a(DROP_NTH_ASM_T 3 (fn th => (conv_tac(LEFT_C(once_rewrite_conv[th])))));
a(ante_tac (list_µ_elim[¨a \ bÆ, ¨bÆ] size_¿_thm));
a(asm_rewrite_tac[size_empty_thm]);
val €size_Ä_diff_thm› = save_pop_thm "size_Ä_diff_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µm∑ {i | i < m} ç Finite ± #{i | i < m} = mÆ);
a(µ_tac THEN rewrite_tac[list_finite_size_thm]);
a(induction_tac¨mÆ);
(* *** Goal "1" *** *)
a(∂_tac¨[]Æ THEN rewrite_tac[distinct_def,
	elems_def, length_def]);
a(PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨Cons m listÆ THEN asm_rewrite_tac[distinct_def,
	elems_def, length_def]);
a(DROP_ASMS_T discard_tac
	THEN PC_T1 "sets_ext1" REPEAT strip_tac
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
val €range_finite_size_thm› = save_pop_thm "range_finite_size_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf list∑ #(Map f list) = # listÆ);
a(REPEAT strip_tac);
a(list_induction_tac ¨listÆ
	THEN asm_rewrite_tac[map_def, length_def]);
val €length_map_thm› = save_pop_thm "length_map_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf list∑ 
	Elems (Map f list) = {y | ∂x∑x ç Elems list ± y = f x}Æ);
a(REPEAT strip_tac);
a(list_induction_tac ¨listÆ
	THEN asm_rewrite_tac[map_def, elems_def]
	THEN REPEAT strip_tac
	THEN PC_T1 "sets_ext1" prove_tac[]);
val €elems_map_thm› = save_pop_thm "elems_map_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf list∑ 
	(µ x y∑ x ç Elems list ± y ç Elems list ± f x = f y ¥ x = y)
±	list ç Distinct
¥	Map f list ç DistinctÆ);
a(REPEAT µ_tac);
a(intro_µ_tac(¨fÆ, ¨fÆ) THEN list_induction_tac ¨listÆ
	THEN asm_rewrite_tac[map_def, distinct_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[elems_map_thm] THEN REPEAT strip_tac);
a(swap_nth_asm_concl_tac 3);
a(LEMMA_T¨x = x'Æ asm_rewrite_thm_tac);
a(DROP_NTH_ASM_T 4 bc_thm_tac);
a(PC_T1 "sets_ext1" asm_rewrite_tac[elems_def]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 bc_thm_tac);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 6 bc_thm_tac);
a(PC_T1 "sets_ext1" asm_rewrite_tac[elems_def]);
val €map_distinct_thm› = save_pop_thm "map_distinct_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µlist i∑ 
	i < #list
¥	Nth list (i+1) ç Elems listÆ);
a(µ_tac);
a(list_induction_tac ¨listÆ
	THEN asm_rewrite_tac[elems_def, nth_def, length_def]);
a(REPEAT µ_tac);
a(cases_tac¨i = 0Æ THEN asm_rewrite_tac[]
	THEN1 PC_T1 "sets_ext1" rewrite_tac[]);
a(REPEAT strip_tac);
a(lemma_tac¨1 º iÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[º_def]));
a(DROP_NTH_ASM_T 4 discard_tac THEN all_var_elim_asm_tac1);
a(once_rewrite_tac[plus_comm_thm]);
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN PC_T1 "lin_arith" asm_prove_tac[]);
val €nth_ç_elems_thm› = save_pop_thm "nth_ç_elems_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µlist∑ 
	Elems list = {x | ∂i∑ i < #list ± Nth list (i+1) = x}Æ);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨xÆ, ¨xÆ));
a(list_induction_tac ¨listÆ
	THEN MERGE_PCS_T1 ["sets_ext1", "basic_hol"]
		asm_rewrite_tac[elems_def, nth_def, length_def]);
a(REPEAT µ_tac);
a(cases_tac¨x' = xÆ THEN asm_rewrite_tac[]
	THEN1 (∂_tac¨0Æ THEN asm_rewrite_tac[]));
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(∂_tac¨i+1Æ THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a(all_var_elim_asm_tac1 THEN all_fc_tac[nth_ç_elems_thm]);
val €elems_nth_thm› = save_pop_thm "elems_nth_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µlist i j∑ 
	list ç Distinct
±	i < #list ± j < #list
±	Nth list (i+1) = Nth list (j+1)
¥	i = jÆ);
a(µ_tac);
a(list_induction_tac ¨listÆ
	THEN asm_rewrite_tac[length_def, nth_def, distinct_def]);
a(REPEAT µ_tac);
a(cases_tac¨i = 0Æ THEN cases_tac¨j = 0Æ
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(i_contr_tac THEN swap_nth_asm_concl_tac 3);
a(LEMMA_T ¨1 º jÆ (strip_asm_tac o once_rewrite_rule[plus_comm_thm]
		o rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 4 discard_tac THEN all_var_elim_asm_tac1);
a(bc_thm_tac nth_ç_elems_thm THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_T ¨1 º iÆ (strip_asm_tac o once_rewrite_rule[plus_comm_thm]
		o rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 4 discard_tac THEN all_var_elim_asm_tac1);
a(bc_thm_tac nth_ç_elems_thm THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(LEMMA_T ¨1 º i ± 1 º jÆ (strip_asm_tac o once_rewrite_rule[plus_comm_thm]
		o rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [8, 9] discard_tac THEN all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [6] (ALL_FC_T rewrite_tac));
val €distinct_nth_thm› = save_pop_thm "distinct_nth_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µa b f∑
	 a ç Finite
±	(µx y∑x ç a ± y ç a ± f x = f y ¥ x = y)
±	b = {z | ∂x∑x ç a ± z = f x}
¥	b ç Finite ± #b = #aÆ);
a(rewrite_tac[list_finite_size_thm] THEN REPEAT strip_tac);
a(all_fc_tac[finite_distinct_elems_thm]);
a(all_fc_tac[distinct_size_length_thm]);
a(all_var_elim_asm_tac1 THEN ∂_tac ¨Map f listÆ);
a(asm_rewrite_tac[length_map_thm, elems_map_thm]
	THEN REPEAT strip_tac);
a(bc_thm_tac map_distinct_thm);
a(REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [6] all_fc_tac);
val €bijection_finite_size_thm› = save_pop_thm "bijection_finite_size_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µa m∑
	 a ç Finite ± #a = m
§	∂f∑	(µi j∑i < m ± j < m ± f i = f j ¥ i = j)
	± 	a = {x | ∂i∑i < m ± f i = x}Æ);
a(REPEAT_UNTIL is_± strip_tac THEN strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[list_finite_size_thm]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(∂_tac¨Ãi∑Nth list (i+1)Æ THEN rewrite_tac[]);
a(REPEAT strip_tac THEN1 all_fc_tac[distinct_nth_thm]);
a(rewrite_tac[elems_nth_thm]);
(* *** Goal "2" *** *)
a(strip_tac);
a(once_rewrite_tac[
	eq_sym_rule(±_right_elim(µ_elim¨mÆ range_finite_size_thm))]);
a(bc_thm_tac bijection_finite_size_thm);
a(∂_tac¨fÆ THEN asm_rewrite_tac[range_finite_size_thm]);
a(conv_tac(LEFT_C (ONCE_MAP_C eq_sym_conv)));
a(rewrite_tac[]);
val €range_bijection_finite_size_thm› = save_pop_thm "range_bijection_finite_size_thm";
=TEX
%%%%
%%%%
=SML
val €Ó_exp_def› = get_spec ¨1 ^ 2Æ;
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µa∑  a = {b | b Ä a}Æ);
a(REPEAT strip_tac THEN PC_T "sets_ext1" strip_tac);
a(rewrite_tac[_def]);
val €_thm› = save_pop_thm "_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx a∑
	 a = {b | b Ä a ± x ç b} ¿ {b | b Ä a ± ≥x ç b}
±	{b | b Ä a ± x ç b} ° {b | b Ä a ± ≥x ç b} = {}
Æ);
a(rewrite_tac[_thm] THEN PC_T1 "sets_ext1" prove_tac[]);
val €_split_thm› = save_pop_thm "_split_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µa b∑ b Ä a ¥
	 a =  b ¿ {c | c Ä a ± ∂x∑ x ç c ± ≥x ç b}
±	 b ° {c | c Ä a ± ∂x∑ x ç c ± ≥x ç b} = {}
Æ);
a(rewrite_tac[_thm] THEN PC_T1 "sets_ext1" prove_tac[]);
val €_split_thm1› = save_pop_thm "_split_thm1";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µa∑
	 a ç Finite
¥	 a ç Finite ± #( a) = 2 ^ #aÆ);
a(REPEAT µ_tac THEN ¥_tac);
a(rewrite_tac[_thm] THEN finite_induction_tac¨aÆ);
(* *** Goal "1" *** *)
a(LEMMA_T¨{b|b Ä {}} = {{}}Æ rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(rewrite_tac[size_empty_thm, Ó_exp_def,
	size_singleton_thm, singleton_finite_thm]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac[size_singleton_¿_thm]);
a(rewrite_tac[Ó_exp_def]);
a(LEMMA_T¨{b|b Ä {x} ¿ a} =
	{b|b Ä a} ¿ {c|∂b∑b Ä a ± c = {x} ¿ b}Æ
	rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(∂_tac¨x' ° aÆ THEN PC_T1 "sets_ext1" asm_prove_tac[]);
a(spec_nth_asm_tac 3 ¨x''Æ THEN all_var_elim_asm_tac);
(* *** Goal "2.1.2" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2.1.3" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
a(spec_nth_asm_tac 3 ¨x''Æ);
a(spec_nth_asm_tac 5 ¨x''Æ);
(* *** Goal "2.2" *** *)
a(lemma_tac¨
	{c|∂ b∑ b Ä a ± c = {x} ¿ b} ç Finite ±
	#{c|∂ b∑ b Ä a ± c = {x} ¿ b} = #{b|b Ä a}Æ
	THEN1 bc_thm_tac bijection_finite_size_thm);
(* *** Goal "2.2.1" *** *)
a(∂_tac¨Ãb∑{x} ¿ bÆ THEN asm_rewrite_tac[]);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "2.2.1.1" *** *)
a(swap_nth_asm_concl_tac 2 THEN strip_tac);
a(∂_tac¨x''Æ THEN PC_T1 "sets_ext1" asm_rewrite_tac[]);
a(contr_tac THEN all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
(* *** Goal "2.2.1.2" *** *)
a(swap_nth_asm_concl_tac 2 THEN strip_tac);
a(∂_tac¨x''Æ THEN PC_T1 "sets_ext1" asm_rewrite_tac[]);
a(contr_tac THEN all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac);
a(asm_rewrite_tac[¿_finite_thm]);
(* *** Goal "2.2.2" *** *)
a(lemma_tac¨{b|b Ä a} ° {c|∂ b∑ b Ä a ± c = {x} ¿ b} = {}Æ);
(* *** Goal "2.2.2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨xÆ);
a(spec_nth_asm_tac 2 ¨xÆ);
(* *** Goal "2.2.2.2" *** *)
a(ante_tac(list_µ_elim[¨{b|b Ä a}Æ,
	¨{c|∂ b∑ b Ä a ± c = {x} ¿ b}Æ]
	size_¿_thm));
a(asm_rewrite_tac[size_empty_thm]);
a(STRIP_T rewrite_thm_tac);
a(PC_T1 "lin_arith" prove_tac[]);
val €finite_size__thm› = save_pop_thm "finite_size__thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA∑
	A ç Finite
¥	ì A (Ãx∑ÓØ 1) = ÓØ (#A)Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨AÆ
	THEN1 rewrite_tac[ind_sum_def, size_empty_thm]);
a(ALL_FC_T rewrite_tac[ind_sum_def, size_singleton_¿_thm]);
a(asm_rewrite_tac[ÓØ_plus_homomorphism_thm]);
val €ind_sum_size_thm› = save_pop_thm "ind_sum_size_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA f g∑
	A ç Finite
¥	ì A (Ãx∑f x + g x) = ì A f + ì A gÆ);
a(REPEAT strip_tac);
a(finite_induction_tac¨AÆ
	THEN1 rewrite_tac[ind_sum_def]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €ind_sum_plus_thm› = save_pop_thm "ind_sum_plus_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA f∑
	A ç Finite
¥	ì A (Ãx∑~(f x)) = ~(ì A f)Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨AÆ
	THEN1 rewrite_tac[ind_sum_def]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
val €ind_sum_minus_thm› = save_pop_thm "ind_sum_minus_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA f c∑
	A ç Finite
¥	ì A (Ãx∑c*(f x)) = c*(ì A f)Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨AÆ
	THEN1 rewrite_tac[ind_sum_def]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €ind_sum_const_times_thm› = save_pop_thm "ind_sum_const_times_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA f∑
	A ç Finite
¥	ì A  (Ã x∑ ÓØ 0) = ÓØ 0Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨AÆ
	THEN1 rewrite_tac[ind_sum_def]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
val €ind_sum_0_thm› = save_pop_thm "ind_sum_0_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA f g∑
	A ç Finite
±	ì A (Ãx∑f x - g x) = ÓØ 0
¥	ì A f = ì A gÆ);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(LEMMA_T ¨f = Ãx∑(Ãx∑ f x + ~(g x)) x + g xÆ pure_once_rewrite_thm_tac
	THEN1 rewrite_tac[Ø_plus_assoc_thm]);
a(ALL_FC_T pure_rewrite_tac[ind_sum_plus_thm]);
a(asm_rewrite_tac[]);
val €ind_sum_diff_0_thm› = save_pop_thm "ind_sum_diff_0_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA f g∑
	A ç Finite
± 	(µx∑x ç A ¥ f x = g x)
¥	ì A f = ì A gÆ);
a(REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨fÆ, ¨fÆ));
a(finite_induction_tac¨AÆ
	THEN1 rewrite_tac[ind_sum_def]);
a(REPEAT strip_tac);
a(lemma_tac¨µ x∑ x ç A ¥ f x = g xÆ
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
a(ALL_ASM_FC_T rewrite_tac[ind_sum_def]);
a(spec_nth_asm_tac 2 ¨xÆ);
val €ind_sum_local_thm› = save_pop_thm "ind_sum_local_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA f∑
	A ç Finite
±	(µx∑x ç A ¥ f x = ÓØ 0)
¥	ì A f = ÓØ 0Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨ì A (ÃJ∑ ÓØ 0) = ÓØ 0Æ
	(pure_once_rewrite_thm_tac o eq_sym_rule)
	THEN1 (bc_thm_tac ind_sum_0_thm
		THEN REPEAT strip_tac));
a(bc_thm_tac ind_sum_local_thm);
a(asm_rewrite_tac[]);
val €ind_sum_0_bc_thm› = save_pop_thm "ind_sum_0_bc_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA f b∑
	 A ç Finite
±	(µx y∑x ç A ± y ç A ± b x = b y ¥ x = y)
¥	ì {z | ∂x∑x ç A ± z = b x} f = ì A (Ãx∑f(b x))Æ);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(intro_µ_tac(¨bÆ, ¨bÆ) THEN finite_induction_tac¨AÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[ind_sum_def,
	pc_rule1"sets_ext1" prove_rule[]¨{x|F} = {}Æ]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(lemma_tac¨µ x y∑ x ç A ± y ç A ± b x = b y ¥ x = yÆ
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
a(lemma_tac¨∂B∑ B = {z|∂ x'∑ x' ç A ± z = b x'}Æ
	THEN1 prove_∂_tac);
a(all_fc_tac[bijection_finite_size_thm]);
a(all_var_elim_asm_tac1);
a(PC_T1 "predicates" lemma_tac¨
	≥b x ç {z|∂ x'∑ x' ç A ± z = b x'} ±
	{z|∂ x'∑ x' ç {x} ¿ A ± z = b x'} =
	{b x} ¿ {z|∂ x'∑ x' ç A ± z = b x'}Æ
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(cases_tac¨x' = xÆ THEN1 asm_rewrite_tac[]);
a(swap_nth_asm_concl_tac 1 THEN DROP_NTH_ASM_T 6 bc_thm_tac);
a(PC_T1 "sets_ext1" asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(DROP_ASMS_T discard_tac THEN PC_T1 "sets_ext1" rewrite_tac[]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "2.2.1" *** *)
a(∂_tac¨x''Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.3" *** *)
a(∂_tac¨x''Æ THEN REPEAT strip_tac);
(* *** Goal "2.3" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(ALL_FC_T rewrite_tac[ind_sum_def]);
a(LIST_DROP_NTH_ASM_T [7] all_fc_tac);
val €bijection_ind_sum_thm› = save_pop_thm "bijection_ind_sum_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA x∑
	A ç Finite
¥	ì A (—{x}) =
	if x ç A then ÓØ 1 else ÓØ 0Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨AÆ
	THEN1 rewrite_tac[ind_sum_def]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
a(PC_T1 "sets_ext1" asm_rewrite_tac[—_def]);
a(cases_tac¨x' = xÆ THEN1 all_var_elim_asm_tac
	THEN asm_rewrite_tac[]);
a(POP_ASM_T (rewrite_thm_tac o conv_rule(RAND_C eq_sym_conv)));
val €ind_sum_—_singleton_thm› = save_pop_thm "ind_sum_—_singleton_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx f∑
	ì {x} f = f xÆ);
a(REPEAT strip_tac);
a(pure_once_rewrite_tac[prove_rule [] ¨{x} = {x} ¿ {}Æ]);
a(lemma_tac¨{} ç FiniteÆ THEN1 rewrite_tac[empty_finite_thm]);
a(LEMMA_T¨≥x ç {}Æ asm_tac THEN1 rewrite_tac[]);
a(ALL_FC_T pure_rewrite_tac[ind_sum_def]);
a(rewrite_tac[ind_sum_def]);
val €ind_sum_singleton_thm› = save_pop_thm "ind_sum_singleton_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µp∑
	(µx∑p(—{x}))
±	(µf c∑	{x | ≥f x = ÓØ 0} ç Finite
	±	p f
	¥	p (Ãx∑c*(f x)))
±	(µf g∑	{x | ≥f x = ÓØ 0} ç Finite
	±	{x | ≥g x = ÓØ 0} ç Finite
	±	p f ± p g
	¥	p (Ãx∑f x + g x))
¥	(µf∑	{x | ≥f x = ÓØ 0} ç Finite
	¥	p f)
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂A∑ A = {x|≥ f x = ÓØ 0}Æ
	THEN1 prove_∂_tac);
a(lemma_tac¨A ç FiniteÆ
	THEN1 asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 3 discard_tac);
a(DROP_NTH_ASM_T 2 ante_tac);
a(intro_µ_tac(¨fÆ, ¨fÆ) THEN finite_induction_tac ¨AÆ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T¨f = Ãx∑ÓØ 0 * (—{a} x)Æ pure_rewrite_thm_tac);
(* *** Goal "1.1" *** *)
a(rewrite_tac[] THEN POP_ASM_T ante_tac);
a(PC_T1 "sets_ext" rewrite_tac[] THEN rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN POP_ASM_T discard_tac
	THEN asm_rewrite_tac[]);
a(LEMMA_T ¨{x|≥ — {a} x = ÓØ 0} = {a}Æ
	(fn th => rewrite_tac[th, singleton_finite_thm]));
a(PC_T1 "sets_ext1" rewrite_tac[—_def] THEN strip_tac);
a(cases_tac¨x = aÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨f = Ãx∑
	(Ãz∑if z ç A then f z else ÓØ 0) x +
	(Ãz∑if z ç A then ÓØ 0 else f z) xÆ
	pure_once_rewrite_thm_tac
	THEN1 (rewrite_tac[] THEN REPEAT strip_tac
		THEN cases_tac¨x' ç AÆ
		THEN asm_rewrite_tac[]));
a(DROP_NTH_ASM_T 5 bc_thm_tac);
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨AÆ
	THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨{x}Æ
	THEN PC_T1 "sets_ext1" rewrite_tac[singleton_finite_thm]
	THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN
	cases_tac¨x' ç AÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 2 ante_tac);
a(PC_T1 "sets_ext1" rewrite_tac[] THEN REPEAT strip_tac);
a(spec_nth_asm_tac 2 ¨x'Æ);
(* *** Goal "2.3" *** *)
a(DROP_NTH_ASM_T 3 bc_thm_tac);
a(PC_T1 "sets_ext1" rewrite_tac[] THEN REPEAT µ_tac);
a(cases_tac¨x' ç AÆ THEN asm_rewrite_tac[]);
a(LIST_DROP_NTH_ASM_T [2] (PC_T1 "sets_ext" all_fc_tac));
(* *** Goal "2.4" *** *)
a(LEMMA_T¨(Ã z∑ if z ç A then ÓØ 0 else f z) =
	(Ãz∑f x * —{x} z)Æ
	rewrite_thm_tac);
(* *** Goal "2.4.1" *** *)
a(rewrite_tac[—_def] THEN REPEAT strip_tac);
a(cases_tac¨x' = xÆ
	THEN1 all_var_elim_asm_tac1 THEN asm_rewrite_tac[]);
a(cases_tac¨x' ç AÆ THEN asm_rewrite_tac[]);
a(contr_tac THEN LEMMA_T¨x' ç {x} ¿ AÆ ante_tac
	THEN1 asm_rewrite_tac[]);
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2.4.2" *** *)
a(DROP_NTH_ASM_T 5 bc_thm_tac THEN asm_rewrite_tac[]);
a(LEMMA_T ¨{x'|≥ — {x} x' = ÓØ 0} = {x}Æ
	(fn th => rewrite_tac[th, singleton_finite_thm]));
a(PC_T1 "sets_ext" rewrite_tac[—_def] THEN µ_tac);
a(cases_tac¨x' = xÆ THEN asm_rewrite_tac[]);
val €fin_supp_induction_thm› = save_pop_thm "fin_supp_induction_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA∑ ﬁ{A} = AÆ);
a(PC_T "sets_ext1" contr_tac THEN1 all_asm_fc_tac[]);
a(spec_nth_asm_tac 1 ¨AÆ THEN all_var_elim_asm_tac1);
val ﬁ_singleton_thm = pop_thm ();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA B f∑
	A ç Finite
±	B ç Finite
¥	ì (A ¿ B) f =
	ì A f + ì B f - ì (A ° B) f
Æ);
a(REPEAT strip_tac);
a(finite_induction_tac ¨AÆ THEN1 rewrite_tac[ind_sum_def]);
a(lemma_tac¨A ¿ B ç Finite ± A ° B ç FiniteÆ
	THEN1 (asm_rewrite_tac[¿_finite_thm]
		THEN ALL_FC_T rewrite_tac[°_finite_thm]));
a(cases_tac¨{x} Ä BÆ);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[pc_rule1 "sets_ext1" prove_rule[]
	¨µa b c∑ a Ä c ¥ 
		(a ¿ b) ¿ c = b ¿ c
	±	(a ¿ b) ° c = a ¿ (b ° c)Æ]);
a(LEMMA_T¨≥x ç A ° BÆ asm_tac THEN1 REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[ind_sum_def]);
a(DROP_NTH_ASM_T 6 ante_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T (PC_T1 "sets_ext" strip_asm_tac)
	THEN all_var_elim_asm_tac);
a(ALL_FC_T rewrite_tac[pc_rule1 "sets_ext1" prove_rule[]
	¨µa b c∑ ≥x ç c ¥ 
		(a ¿ b) ¿ c = a ¿ b ¿ c
	±	({x} ¿ b) ° c = (b ° c)Æ]);
a(LEMMA_T¨≥x ç A ¿ BÆ asm_tac THEN1 REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[ind_sum_def]);
a(DROP_NTH_ASM_T 6 ante_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €ind_sum_¿_thm› = save_pop_thm "ind_sum_¿_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µK∑
	K ç Finite ± ≥K = {}
¥	ì (K) (ÃJ∑ ~(ÓØ 1) ^ #J) = ÓØ 0Æ);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(LEMMA_T¨K ç FiniteÆ ante_tac THEN1
	all_fc_tac[finite_size__thm]);
a(strip_asm_tac (list_µ_elim[¨xÆ, ¨KÆ]_split_thm));
a(DROP_NTH_ASM_T 2 rewrite_thm_tac);
a(rewrite_tac[¿_finite_thm] THEN strip_tac);
a(ALL_FC_T asm_rewrite_tac[ind_sum_¿_thm]);
a(rewrite_tac[ind_sum_def]);
a(lemma_tac¨∂g∑µJ∑g J = J \ {x}Æ THEN1 prove_∂_tac);
a(lemma_tac¨ µ X Y∑ X ç {b|b Ä K ± x ç b}
	± Y ç {b|b Ä K ± x ç b}
	± g X = g Y ¥ X = YÆ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[] THEN DROP_ASMS_T discard_tac
	THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(cases_tac¨x' = xÆ THEN1 asm_rewrite_tac[]);
a(spec_nth_asm_tac 3 ¨x'Æ);
(* *** Goal "1.2" *** *)
a(cases_tac¨x' = xÆ THEN1 asm_rewrite_tac[]);
a(spec_nth_asm_tac 3 ¨x'Æ);
(* *** Goal "2" *** *)
a(ante_tac(list_µ_elim[	¨{b|b Ä K ± x ç b}Æ,
		¨Ã J: 'a SET∑ ~ (ÓØ 1) ^ # JÆ,
		¨gÆ] bijection_ind_sum_thm));
a(asm_rewrite_tac[¿_finite_thm, singleton_finite_thm]);
a(LEMMA_T ¨
	{z|∂ x'∑ (x' Ä K ± x ç x') ± z = x' \ {x}} =
	{b|b Ä K ± ≥x ç b}Æ rewrite_thm_tac);
(* *** Goal ".1" *** *)
a(DROP_ASM_T ¨x ç KÆ ante_tac
	THEN DROP_ASMS_T discard_tac
	THEN PC_T1 "sets_ext1" rewrite_tac[]
	THEN REPEAT strip_tac
	THEN_TRY SOLVED_T (asm_prove_tac[]));
a(∂_tac¨{x} ¿ x'Æ THEN PC_T1 "sets_ext1" asm_prove_tac[]);
a(contr_tac THEN all_var_elim_asm_tac);
(* *** Goal "2.2" *** *)
a(STRIP_T rewrite_thm_tac THEN rename_tac[]);
a(LEMMA_T¨
	ì {b|b Ä K ± x ç b} (Ã x'∑ ~ (ÓØ 1) ^ # (x' \ {x})) =
	ì {b|b Ä K ± x ç b} (ÃK∑~((Ã J∑ ~ (ÓØ 1) ^ # J) K))Æ
	pure_rewrite_thm_tac);
(* *** Goal "2.2.1" *** *)
a(bc_thm_tac ind_sum_local_thm THEN REPEAT strip_tac);
a(LEMMA_T ¨#x' = #(x' \{x}) + 1Æ
	(fn th => rewrite_tac[th, Ø_Ó_exp_def]
		THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(LEMMA_T¨x' = {x} ¿ (x' \ {x})Æ
	(fn th => conv_tac (LEFT_C(once_rewrite_conv[th])))
	THEN1 (POP_ASM_T ante_tac THEN PC_T1 "sets_ext" prove_tac[]));
a(LEMMA_T¨≥x ç x' \ {x}Æ asm_tac
	THEN1 PC_T1 "sets_ext" prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
a(lemma_tac¨x' \ {x} Ä x'Æ 
	THEN1 PC_T1 "sets_ext" prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
a(all_fc_tac[size_singleton_¿_thm]);
(* *** Goal "2.2.2" *** *)
a(ALL_FC_T rewrite_tac[ind_sum_minus_thm]);
val €ind_sum__thm› = save_pop_thm "ind_sum__thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µI U A f∑
	I ç Finite
±	(µi∑ i ç I ¥ U i ç Finite)
±	A = ﬁ{B | ∂i∑ i ç I ± B = U i}
¥	A ç FiniteÆ);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac);
a(finite_induction_tac¨IÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨ﬁ{B|F} = {}Æ]);
a(REPEAT strip_tac THEN asm_rewrite_tac[empty_finite_thm]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(REPEAT strip_tac);
a(LEMMA_T ¨{B|∂ i∑ i ç {x} ¿ I ± B = U i} =
	{B|∂ i∑ i ç I ± B = U i} ¿ {U x}Æ rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(asm_rewrite_tac[pc_rule1"sets_ext1" prove_rule[]
	¨µV W∑ﬁ(V ¿ W) = ﬁV ¿ ﬁWÆ,
	ﬁ_singleton_thm,
	¿_finite_thm]);
a(POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
val €ind_ﬁ_finite_thm› = save_pop_thm "ind_ﬁ_finite_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µI U A x∑
	I ç Finite ± ≥I = {}
±	(µi∑ i ç I ¥ U i ç Finite)
±	A = ﬁ{B | ∂i∑ i ç I ± B = U i}
¥	ì
	(I)
	(ÃJ∑ ~(ÓØ 1) ^ #J * ì (A ° •{B | ∂j∑ j ç J ± B = U j}) (—{x}))
	= ÓØ 0Æ);
a(REPEAT strip_tac);
a(all_fc_tac[ind_ﬁ_finite_thm]);
a(lemma_tac¨I ç FiniteÆ
	THEN1 all_fc_tac[ finite_size__thm ]);
a(cases_tac¨≥x ç AÆ);
(* *** Goal "1" *** *)
a(bc_thm_tac ind_sum_0_bc_thm);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(LEMMA_T¨ì (A ° • {B|∂ j∑ j ç x' ± B = U j}) (— {x}) = ÓØ 0Æ
	rewrite_thm_tac);
a(bc_thm_tac ind_sum_0_bc_thm);
a(ALL_FC_T rewrite_tac[°_finite_thm]);
a(REPEAT strip_tac THEN rewrite_tac[—_def]);
a(cases_tac¨x'' = xÆ THEN asm_rewrite_tac[]
	THEN1 all_var_elim_asm_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 (strip_asm_tac o eq_sym_rule));
a(lemma_tac ¨x ç ﬁ {B|∂ i∑ i ç I ± B = U i}Æ
	THEN1 asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a(var_elim_nth_asm_tac 1);
a(lemma_tac¨≥{j | j ç I ± x ç U j} = {} ±
	{j | j ç I ± x ç U j} Ä IÆ
	THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(GET_ASM_T ¨I ç FiniteÆ ante_tac);
a(ALL_FC_T (MAP_EVERY ante_tac) [_split_thm1]);
a(rewrite_tac[] THEN strip_tac);
a(STRIP_T rewrite_thm_tac);
a(rewrite_tac[¿_finite_thm] THEN REPEAT strip_tac);
a(ALL_FC_T asm_rewrite_tac[ind_sum_¿_thm]);
a(rewrite_tac[ind_sum_def]);
a(bc_thm_tac (pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µx y∑ y = ÓØ 0 ± x = ÓØ 0 ¥ x + y = ÓØ 0Æ)
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac ind_sum_0_bc_thm);
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(LIST_DROP_NTH_ASM_T [3] (PC_T1 "sets_ext" all_fc_tac));
(* *** Goal "2.1.2" *** *)
a(LEMMA_T¨ì (A ° • {B|∂ j∑ j ç x' ± B = U j}) (— {x}) = ÓØ 0Æ
	rewrite_thm_tac);
a(bc_thm_tac ind_sum_0_bc_thm);
a(ALL_FC_T rewrite_tac[°_finite_thm]);
a(REPEAT strip_tac THEN rewrite_tac[—_def]);
a(cases_tac¨x''' = xÆ THEN asm_rewrite_tac[]
	THEN1 all_var_elim_asm_tac);
a(POP_ASM_T (ante_tac o µ_elim¨U x''Æ));
a(asm_rewrite_tac[]);
a(∂_tac¨x''Æ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(lemma_tac¨{j|j ç I ± x ç U j} ç FiniteÆ
	THEN1 all_fc_tac[Ä_finite_thm]);
a(DROP_NTH_ASM_T 14 discard_tac
	THEN all_fc_tac[ind_sum__thm]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(bc_thm_tac ind_sum_local_thm THEN REPEAT strip_tac);
a(LEMMA_T¨ì (A ° • {B|∂ j∑ j ç x' ± B = U j}) (— {x}) = ÓØ 1Æ
	rewrite_thm_tac);
a(lemma_tac¨A ° • {B|∂ j∑ j ç x' ± B = U j} ç FiniteÆ
	THEN1 ALL_FC_T rewrite_tac[°_finite_thm]);
a(ALL_FC_T rewrite_tac[ind_sum_—_singleton_thm]);
a(LEMMA_T ¨x ç A ° • {B|∂ j∑ j ç x' ± B = U j}Æ
	rewrite_thm_tac);
a(rename_tac[(¨x'Æ, "J")] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [3] (PC_T1 "sets_ext" all_fc_tac));
val €ind_sum_inc_exc_lemma1› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µI U A f c∑
	I ç Finite ± ≥I = {}
±	(µi∑ i ç I ¥ U i ç Finite)
±	A = ﬁ{B | ∂i∑ i ç I ± B = U i}
±	ì
	(I)
	(ÃJ∑ ~(ÓØ 1) ^ #J * ì (A ° •{B | ∂j∑ j ç J ± B = U j}) f) = ÓØ 0
¥	ì
	(I)
	(ÃJ∑ ~(ÓØ 1) ^ #J * ì (A ° •{B | ∂j∑ j ç J ± B = U j}) (Ãx∑c*f x)) = ÓØ 0
Æ);
a(REPEAT strip_tac);
a(all_fc_tac[ind_ﬁ_finite_thm]);
a(lemma_tac¨I ç FiniteÆ
	THEN1 all_fc_tac[ finite_size__thm ]);
a(LEMMA_T ¨ì ( I)
	(Ã J∑ ~ (ÓØ 1) ^ # J * ì (A ° • {B|∂ j∑ j ç J ± B = U j}) (Ã x∑ c * f x)) =
	c * ì ( I) (Ã J∑ ~ (ÓØ 1) ^ # J * ì (A ° • {B|∂ j∑ j ç J ± B = U j}) f)Æ
	asm_rewrite_thm_tac);
a(ALL_FC_T rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv)
	ind_sum_const_times_thm]);
a(bc_thm_tac ind_sum_local_thm);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(lemma_tac¨(A ° • {B|∂ j∑ j ç x ± B = U j}) ç FiniteÆ
	THEN1 ALL_FC_T rewrite_tac[°_finite_thm]);
a(ALL_FC_T rewrite_tac[ind_sum_const_times_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €ind_sum_inc_exc_lemma2› = pop_thm ();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µI U A f g∑
	I ç Finite ± ≥I = {}
±	(µi∑ i ç I ¥ U i ç Finite)
±	A = ﬁ{B | ∂i∑ i ç I ± B = U i}
±	ì
	(I)
	(ÃJ∑ ~(ÓØ 1) ^ #J * ì (A ° •{B | ∂j∑ j ç J ± B = U j}) f) = ÓØ 0
±	ì
	(I)
	(ÃJ∑ ~(ÓØ 1) ^ #J * ì (A ° •{B | ∂j∑ j ç J ± B = U j}) g) = ÓØ 0
¥	ì
	(I)
	(ÃJ∑ ~(ÓØ 1) ^ #J * ì (A ° •{B | ∂j∑ j ç J ± B = U j}) (Ãx∑f x + g x)) = ÓØ 0
Æ);
a(REPEAT strip_tac);
a(all_fc_tac[ind_ﬁ_finite_thm]);
a(lemma_tac¨I ç FiniteÆ
	THEN1 all_fc_tac[ finite_size__thm ]);
a(LEMMA_T ¨ì ( I)
	(Ã J∑ ~ (ÓØ 1) ^ # J * ì (A ° • {B|∂ j∑ j ç J ± B = U j}) (Ã x∑ f x + g x)) =
	ì ( I) (Ã J∑ ~ (ÓØ 1) ^ # J * ì (A ° • {B|∂ j∑ j ç J ± B = U j}) f) + 
	ì ( I) (Ã J∑ ~ (ÓØ 1) ^ # J * ì (A ° • {B|∂ j∑ j ç J ± B = U j}) g)Æ
	asm_rewrite_thm_tac);
a(ALL_FC_T rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv)
	ind_sum_plus_thm]);
a(bc_thm_tac ind_sum_local_thm);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(lemma_tac¨(A ° • {B|∂ j∑ j ç x ± B = U j}) ç FiniteÆ
	THEN1 ALL_FC_T rewrite_tac[°_finite_thm]);
a(ALL_FC_T rewrite_tac[ind_sum_plus_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €ind_sum_inc_exc_lemma3› = pop_thm ();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µI U A f∑
	I ç Finite ± ≥I = {}
±	(µi∑ i ç I ¥ U i ç Finite)
±	A = ﬁ{B | ∂i∑ i ç I ± B = U i}
¥	ì
	(I)
	(ÃJ∑ ~(ÓØ 1) ^ #J * ì (A ° •{B | ∂j∑ j ç J ± B = U j}) f) = ÓØ 0
Æ);
a(REPEAT strip_tac);
a(ante_tac(µ_elim¨Ãf∑ì (I)
	(ÃJ∑ ~(ÓØ 1) ^ #J * ì (A ° •{B | ∂j∑ j ç J ± B = U j}) f) = ÓØ 0Æ
	fin_supp_induction_thm));
a(rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(swap_nth_asm_concl_tac 1);
a(ALL_FC_T rewrite_tac[ind_sum_inc_exc_lemma1]);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(ALL_FC_T rewrite_tac[ind_sum_inc_exc_lemma2]);
(* *** Goal "3" *** *)
a(swap_nth_asm_concl_tac 1);
a(ALL_FC_T rewrite_tac[ind_sum_inc_exc_lemma3]);
(* *** Goal "4" *** *)
a(LEMMA_T ¨
	ì ( I) (Ã J∑ ~ (ÓØ 1) ^ # J * ì (A ° • {B|∂ j∑ j ç J ± B = U j})
	(Ãx∑if x ç A then f x else ÓØ 0)) = ÓØ 0Æ
	(once_rewrite_thm_tac o eq_sym_rule));
(* *** Goal "4.1" *** *)
a(POP_ASM_T bc_thm_tac);
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨AÆ);
a(all_fc_tac[ind_ﬁ_finite_thm]);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "4.2" *** *)
a(lemma_tac¨I ç FiniteÆ
	THEN1 all_fc_tac[ finite_size__thm ]);
a(all_fc_tac[ind_ﬁ_finite_thm]);
a(bc_thm_tac ind_sum_local_thm THEN REPEAT strip_tac
	THEN rewrite_tac[]);
a(LEMMA_T¨ì (A ° • {B|∂ j∑ j ç x ± B = U j}) f =
	ì (A ° • {B|∂ j∑ j ç x ± B = U j})
	(Ã x∑ if x ç A then f x else ÓØ 0)Æ
	rewrite_thm_tac);
a(bc_thm_tac ind_sum_local_thm);
a(all_fc_tac[ind_ﬁ_finite_thm]);
a(ALL_FC_T rewrite_tac[°_finite_thm]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val €ind_sum_inc_exc_sym_thm› = save_pop_thm "ind_sum_inc_exc_sym_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µI U A f∑
	I ç Finite ± ≥I = {}
±	(µi∑ i ç I ¥ U i ç Finite)
±	A = ﬁ{B | ∂i∑ i ç I ± B = U i}
¥	ì A f =
	ì
	(I \ {{}})
	(ÃJ∑ ~(ÓØ 1) ^ (#J + 1) * ì (•{B | ∂j∑ j ç J ± B = U j}) f)
Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨A ç FiniteÆ
	THEN all_fc_tac[ind_ﬁ_finite_thm]);
a(lemma_tac¨I ç FiniteÆ
	THEN1 all_fc_tac[ finite_size__thm ]);
a(lemma_tac¨I \ {{}} ç FiniteÆ
	THEN1 (bc_thm_tac Ä_finite_thm
		THEN ∂_tac¨IÆ THEN REPEAT strip_tac
		THEN PC_T1 "sets_ext" prove_tac[]));
a(LEMMA_T¨(Ã J∑ ~ (ÓØ 1) ^ (# J + 1) * ì (• {B|∂ j∑ j ç J ± B = U j}) f) =
	(Ã J∑ ~(ÓØ 1) * (ÃJ∑ ~ (ÓØ 1) ^ # J * ì (• {B|∂ j∑ j ç J ± B = U j}) f) J)Æ
	pure_rewrite_thm_tac
	THEN1 (rewrite_tac[Ø_Ó_exp_def]
		THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(ALL_FC_T pure_rewrite_tac[ind_sum_const_times_thm]);
a(LEMMA_T ¨ ì ( I \ {{}})
	(Ã J∑ ~ (ÓØ 1) ^ # J * ì (• {B|∂ j∑ j ç J ± B = U j}) f) =
	ì ( I \ {{}})
	(Ã J∑ ~ (ÓØ 1) ^ # J * ì (A ° • {B|∂ j∑ j ç J ± B = U j}) f)Æ
	rewrite_thm_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac ind_sum_local_thm);
a(REPEAT strip_tac THEN rewrite_tac[]);
a(LEMMA_T ¨A ° • {B|∂ j∑ j ç x ± B = U j} =
	• {B|∂ j∑ j ç x ± B = U j}Æ
	rewrite_thm_tac);
a(bc_thm_tac (pc_rule1 "sets_ext1" prove_rule[]
	¨µa b∑b Ä a ¥ a ° b = bÆ));
a(all_var_elim_asm_tac1);
a(PC_T "sets_ext" strip_tac THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (PC_T1 "sets_ext" strip_asm_tac));
a(spec_nth_asm_tac 2 ¨U x''Æ);
(* *** Goal "1.1" *** *)
a(spec_nth_asm_tac 1 ¨x''Æ);
(* *** Goal "1.2" *** *)
a(∂_tac ¨U x''Æ THEN REPEAT strip_tac);
a(∂_tac ¨x''Æ THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [4] (PC_T1 "sets_ext1" all_fc_tac));
(* *** Goal "2" *** *)
a(all_fc_tac[ind_sum_inc_exc_sym_thm]);
a(POP_ASM_T (ante_tac o µ_elim¨fÆ));
a(LEMMA_T¨{} ç IÆ asm_tac THEN1 rewrite_tac[]);
a(ALL_FC_T (fn ths => conv_tac (LEFT_C(once_rewrite_conv ths)))
	[pc_rule1 "sets_ext" prove_rule[]
	¨µa x∑x ç a ¥ a = (a \ {x}) ¿ {x}Æ]);
a(lemma_tac¨{{}} ç FiniteÆ THEN1 rewrite_tac[singleton_finite_thm]);
a(ALL_FC_T rewrite_tac[ind_sum_¿_thm]);
a(rewrite_tac[ind_sum_def,
	ind_sum_singleton_thm,
	size_empty_thm,
	pc_rule1 "sets_ext" prove_rule[]
	¨•{B|F} = Universe ± µa b∑(a \ b) ° b = {}Æ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €ind_sum_inc_exc_thm› = save_pop_thm "ind_sum_inc_exc_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µI U A∑
	I ç Finite ± ≥I = {}
±	(µi∑ i ç I ¥ U i ç Finite)
±	A = ﬁ{B | ∂i∑ i ç I ± B = U i}
¥	ÓØ(# A) =
	ì
	(I \ {{}})
	(ÃJ∑ ~(ÓØ 1) ^ (#J + 1) * ÓØ(# (•{B | ∂j∑ j ç J ± B = U j})))
Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨A ç FiniteÆ
	THEN all_fc_tac[ind_ﬁ_finite_thm]);
a(lemma_tac¨I ç FiniteÆ
	THEN1 all_fc_tac[ finite_size__thm ]);
a(ALL_FC_T rewrite_tac[
	conv_rule(ONCE_MAP_C eq_sym_conv) ind_sum_size_thm]);
a(ALL_FC_T rewrite_tac[arb_gen ind_sum_inc_exc_thm]);
a(bc_thm_tac ind_sum_local_thm);
a(lemma_tac¨I \ {{}} ç FiniteÆ
	THEN1 (bc_thm_tac Ä_finite_thm
		THEN ∂_tac¨IÆ THEN REPEAT strip_tac
		THEN PC_T1 "sets_ext" prove_tac[]));
a(REPEAT strip_tac THEN rewrite_tac[]);
a(LEMMA_T ¨• {B|∂ j∑ j ç x ± B = U j} =
	A ° • {B|∂ j∑ j ç x ± B = U j}Æ
	once_rewrite_thm_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac (pc_rule1 "sets_ext1" prove_rule[]
	¨µa b∑b Ä a ¥ b = a ° bÆ));
a(all_var_elim_asm_tac1);
a(PC_T "sets_ext" strip_tac THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (PC_T1 "sets_ext" strip_asm_tac));
a(spec_nth_asm_tac 2 ¨U x''Æ);
(* *** Goal "1.1" *** *)
a(spec_nth_asm_tac 1 ¨x''Æ);
(* *** Goal "1.2" *** *)
a(∂_tac ¨U x''Æ THEN REPEAT strip_tac);
a(∂_tac ¨x''Æ THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [4] (PC_T1 "sets_ext1" all_fc_tac));
a(lemma_tac ¨A ° • {B|∂ j∑ j ç x ± B = U j} ç FiniteÆ
	THEN1 ALL_FC_T rewrite_tac[°_finite_thm]);
a(ALL_FC_T rewrite_tac[ind_sum_size_thm]);
val €size_inc_exc_thm› = save_pop_thm "size_inc_exc_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µn∑ Binomial n 0 = 1 ±
		Binomial 0 (n+1) = 0Æ);
a(rewrite_tac[binomial_def] THEN REPEAT strip_tac);
a(induction_tac¨nÆ THEN asm_rewrite_tac[binomial_def]);
val €binomial_0_clauses› = save_pop_thm "binomial_0_clauses";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µn m∑ n < m ¥ Binomial n m = 0Æ);
a(µ_tac THEN induction_tac ¨n:ÓÆ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T¨1 º mÆ (strip_asm_tac o 
	once_rewrite_rule[plus_comm_thm] o
	rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN rewrite_tac[binomial_0_clauses]);
(* *** Goal "2" *** *)
a(LEMMA_T¨1 º m'Æ (strip_asm_tac o 
	once_rewrite_rule[plus_comm_thm] o
	rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN rewrite_tac[binomial_def]);
a(REPEAT strip_tac THEN DROP_NTH_ASM_T 2 bc_thm_tac
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
val €binomial_less_0_thm› = save_pop_thm "binomial_less_0_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µn∑ Binomial n n = 1Æ);
a(µ_tac THEN induction_tac ¨n:ÓÆ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[binomial_0_clauses]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[binomial_def]);
a(bc_thm_tac binomial_less_0_thm THEN REPEAT strip_tac);
val €binomial_eq_thm› = save_pop_thm "binomial_eq_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA m∑
	A ç Finite
¥	{X | X Ä A ± #X = m} ç Finite
Æ);
a(REPEAT strip_tac THEN bc_thm_tac Ä_finite_thm);
a(∂_tac¨AÆ THEN1 ALL_FC_T rewrite_tac[finite_size__thm]);
a(PC_T1 "sets_ext"prove_tac[]);
val €combinations_finite_lemma› = pop_thm ();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA n m∑
	A ç Finite
±	#A = n
¥	{X | X Ä A ± #X = m} ç Finite
±	#{X | X Ä A ± #X = m} = Binomial n m
Æ);
a(REPEAT strip_tac THEN1 ALL_FC_T rewrite_tac[combinations_finite_lemma]);
a(REPEAT (POP_ASM_T ante_tac));
a(intro_µ_tac(¨AÆ, ¨AÆ) THEN intro_µ_tac(¨mÆ, ¨mÆ) 
	THEN induction_tac¨nÆ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac
	THEN ALL_FC_T1 fc_§_canon rewrite_tac[size_0_thm]
	THEN strip_tac THEN all_var_elim_asm_tac1);
a(strip_asm_tac(µ_elim¨mÆ Ó_cases_thm) THEN all_var_elim_asm_tac1);
(* *** Goal "1.1" *** *)
a(rewrite_tac[binomial_0_clauses]);
a(LEMMA_T ¨{X|X Ä {} ± # X = 0} = {{}}Æ
	(fn th => rewrite_tac[th, size_empty_thm,
		size_singleton_thm, binomial_def]));
a(PC_T "sets_ext" strip_tac THEN REPEAT strip_tac);
(* *** Goal "1.1.1" *** *)
a(swap_nth_asm_concl_tac 2);
a(all_fc_tac[Ä_finite_thm]);
a(ALL_FC_T1 fc_§_canon asm_rewrite_tac[size_0_thm]);
(* *** Goal "1.1.2" *** *)
a(all_var_elim_asm_tac1 THEN REPEAT strip_tac);
(* *** Goal "1.1.3" *** *)
a(asm_rewrite_tac[size_empty_thm]);
(* *** Goal "1.2" *** *)
a(rewrite_tac[binomial_0_clauses]);
a(LEMMA_T ¨{X|X Ä {} ± # X = i + 1} = {}Æ
	(fn th => rewrite_tac[th, size_empty_thm]));
a(LEMMA_T¨µX∑X Ä {} § X = {}Æ rewrite_thm_tac
	THEN1 PC_T1 "sets_ext" prove_tac[]);
a(PC_T "sets_ext" strip_tac THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[size_empty_thm]);
(* *** Goal "2" *** *)
a(strip_asm_tac(µ_elim¨m'Æ Ó_cases_thm) THEN all_var_elim_asm_tac1);
(* *** Goal "2.1" *** *)
a(rewrite_tac[binomial_0_clauses]);
a(LEMMA_T ¨{X|X Ä A ± # X = 0} = {{}}Æ
	(fn th => rewrite_tac[th, size_empty_thm,
		size_singleton_thm, binomial_def]));
a(PC_T "sets_ext" strip_tac THEN REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(swap_nth_asm_concl_tac 2);
a(all_fc_tac[Ä_finite_thm]);
a(ALL_FC_T1 fc_§_canon asm_rewrite_tac[size_0_thm]);
(* *** Goal "2.1.2" *** *)
a(all_var_elim_asm_tac1 THEN REPEAT strip_tac);
(* *** Goal "2.1.3" *** *)
a(asm_rewrite_tac[size_empty_thm]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[binomial_def]);
a(cases_tac¨A = {}Æ
	THEN1 (all_var_elim_asm_tac1 THEN POP_ASM_T ante_tac
		THEN rewrite_tac[size_empty_thm]));
a(POP_ASM_T (PC_T1 "sets_ext1" strip_asm_tac));
a(lemma_tac¨∂B∑B Ä A ± ≥x ç B ± A = {x} ¿ BÆ
	THEN1 (∂_tac¨A \ {x}Æ THEN PC_T1 "sets_ext" asm_prove_tac[]));
a(all_fc_tac[Ä_finite_thm] THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 4 ante_tac);
a(ALL_FC_T rewrite_tac[size_singleton_¿_thm]
	THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [6] all_fc_tac);
a(lemma_tac ¨
	{X|X Ä {x} ¿ B ± # X = i + 1} ç FiniteÆ
	THEN1 (bc_thm_tac combinations_finite_lemma
		THEN strip_tac));
a(lemma_tac ¨
	{X | X Ä B ± # X = i + 1} Ä
	{X|X Ä {x} ¿ B ± # X = i + 1}Æ
	THEN1 PC_T1 "sets_ext" prove_tac[]);
a(ALL_FC_T asm_rewrite_tac[size_Ä_diff_thm]);
a(ante_tac(list_µ_elim[¨{X|X Ä B ± # X = i}Æ,
	¨{X|X Ä {x} ¿ B ± # X = i + 1} \ {X|X Ä B ± # X = i + 1}Æ,
	¨ÃY∑{x} ¿ YÆ] bijection_finite_size_thm));
a(ALL_FC_T asm_rewrite_tac[combinations_finite_lemma]);
a(REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(i_contr_tac THEN LIST_DROP_NTH_ASM_T [1, 2, 4, 6, 12]
	(MAP_EVERY ante_tac) THEN DROP_ASMS_T discard_tac);
a(PC_T1 "sets_ext1" rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.2.1.1" *** *)
a(spec_nth_asm_tac 2 ¨x''Æ THEN all_var_elim_asm_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2.1.2" *** *)
a(spec_nth_asm_tac 2 ¨x''Æ THEN all_var_elim_asm_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2" *** *)
a(i_contr_tac THEN swap_nth_asm_concl_tac 1);
a(LEMMA_T ¨{X|X Ä {x} ¿ B ± # X = i + 1} \
	{X|X Ä B ± # X = i + 1} =
	{X|X Ä {x} ¿ B ± # X = i + 1 ± x ç X}Æ
	rewrite_thm_tac
	THEN1 (DROP_NTH_ASM_T 6 ante_tac
		THEN DROP_ASMS_T discard_tac
		THEN PC_T1 "sets_ext1" prove_tac[]));
(* *** Goal "2.2.2.1" *** *)
a(spec_nth_asm_tac 4 ¨x''Æ THEN all_var_elim_asm_tac);
(* *** Goal "2.2.2.2" *** *)
a(LIST_DROP_NTH_ASM_T [5, 6, 8]
	(MAP_EVERY ante_tac) THEN DROP_ASMS_T discard_tac
	THEN REPEAT strip_tac);
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(∂_tac¨x' \ {x}Æ THEN REPEAT strip_tac
	THEN_TRY SOLVED_T (PC_T1 "sets_ext" asm_prove_tac[]));
a(all_fc_tac[Ä_finite_thm]);
a(lemma_tac¨{x} Ä x'Æ THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(DROP_NTH_ASM_T 4 ante_tac THEN ALL_FC_T rewrite_tac[size_Ä_diff_thm]);
a(rewrite_tac[size_singleton_thm]);
(* *** Goal "2.2.2.2.2" *** *)
a(all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.2.2.2.3" *** *)
a(all_var_elim_asm_tac1);
a(all_fc_tac[Ä_finite_thm]);
a(lemma_tac¨≥x ç x''Æ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[size_singleton_¿_thm]);
(* *** Goal "2.2.2.2.4" *** *)
a(all_var_elim_asm_tac1 THEN PC_T1 "sets_ext1" prove_tac[]);
val €combinations_finite_size_thm› = save_pop_thm "combinations_finite_size_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx n∑
	(ÓØ 1 + x) ^ n =
	Series (Ãm∑ÓØ(Binomial n m) * x ^ m) (n+1)
Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[Ø_Ó_exp_def, series_def, binomial_0_clauses]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[Ø_Ó_exp_def] THEN POP_ASM_T discard_tac);
a(conv_tac (RIGHT_C(once_rewrite_conv[series_induction_thm1])));
a(rewrite_tac[binomial_def, ÓØ_plus_homomorphism_thm,
	Ø_times_plus_distrib_thm]);
a(conv_tac(RIGHT_C(RIGHT_C(RATOR_C(RAND_C(SIMPLE_Ã_C(
	RANDS_C(un_¬_conv¨m:ÓÆ))))))));
a(pure_rewrite_tac[plus_series_thm] THEN rewrite_tac[]);
a(bc_thm_tac (pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µx y a b∑x = a ± y = ÓØ 1 + b ¥ y + x = ÓØ 1 + a + bÆ)
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[Ø_Ó_exp_def,
	pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µa b∑a * x * b = x * a * bÆ]);
a(conv_tac(RIGHT_C(RATOR_C(RAND_C(SIMPLE_Ã_C(
	RIGHT_C(un_¬_conv¨m:ÓÆ)))))));
a(pure_rewrite_tac[const_times_series_thm] THEN rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(conv_tac (LEFT_C(rewrite_conv[series_induction_thm1])));
a(rewrite_tac[binomial_0_clauses]);
a(rewrite_tac[series_def]);
a(LEMMA_T ¨Binomial n (n+1) = 0Æ rewrite_thm_tac);
a(bc_thm_tac binomial_less_0_thm THEN rewrite_tac[]);
val €binomial_thm1› = save_pop_thm "binomial_thm1";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx y n∑
	(y + x) ^ n =
	Series (Ãm∑ÓØ(Binomial n m) * x ^ m * y ^ (n - m)) (n+1)
Æ);
a(REPEAT strip_tac);
a(cases_tac¨y = ÓØ 0Æ THEN1 all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(rewrite_tac[series_def, binomial_eq_thm]);
a(LEMMA_T ¨µk∑k º n ¥ Series (Ã m∑ ÓØ (Binomial n m) * x ^ m * ÓØ 0 ^ (n - m)) k = ÓØ 0Æ
	(fn th => rewrite_tac[rewrite_rule[](µ_elim¨nÆ th)]));
a(µ_tac THEN induction_tac ¨k:ÓÆ
	THEN asm_rewrite_tac[series_def]
	THEN_TRY PC_T1 "lin_arith" asm_prove_tac[]
	THEN rewrite_tac[º_def]
	THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(rewrite_tac[pc_rule1"lin_arith" prove_rule[]
	¨(k+1)+i = (i+1)+kÆ,
	Ø_Ó_exp_0_1_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨(y + x) ^ n = y^n *(ÓØ 1 + y õ-õ1 * x)^nÆ
	(fn th => rewrite_tac[th, binomial_thm1]));
(* *** Goal "2.1" *** *)
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) Ø_Ó_exp_times_thm,
	Ø_times_plus_distrib_thm,
	Ø_times_assoc_thm1]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(LEMMA_T ¨µk∑k º n + 1 ¥
	y ^ n * Series (Ã m∑ ÓØ (Binomial n m) * (y õ-õ1 * x) ^ m) k =
	Series (Ã m∑ ÓØ (Binomial n m) * x ^ m * y ^ (n - m)) kÆ
	(fn th => rewrite_tac[rewrite_rule[](µ_elim¨n+1Æ th)]));
a(µ_tac THEN induction_tac ¨k:ÓÆ
	THEN asm_rewrite_tac[series_def,
		Ø_times_plus_distrib_thm]
	THEN_TRY PC_T1 "lin_arith" asm_prove_tac[]
	THEN rewrite_tac[º_def]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
a(rewrite_tac[Ø_Ó_exp_plus_thm, Ø_Ó_exp_times_thm,
	µ_elim¨(y õ-õ1)^kÆ Ø_times_order_thm]);
a(rewrite_tac[Ø_times_assoc_thm1]);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) Ø_Ó_exp_times_thm]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(rewrite_tac[Ø_Ó_exp_0_1_thm] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €binomial_thm› = save_pop_thm "binomial_thm";
=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val €sections› = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="wrk073.th.doc", theory="-"};
end;
=TEX
} %\Hide
\end{document}

=TEX
%%%%
%%%%
=IGN
