=IGN
********************************************************************************
wrk073.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
$Id: wrk073.doc,v 1.36 2011/02/11 17:47:01 rda Exp rda $
********************************************************************************
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}

\def\ThmsII#1#2{%
{\vertbarfalse
\begin{minipage}[t]{0.48\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.48\hsize}
#2
\end{minipage}}}

\def\ThmsIII#1#2#3{%
{\vertbarfalse
\begin{minipage}[t]{0.32\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#2
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#3
\end{minipage}}}
\def\Hide#1{\relax}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\C{\mathbb{C}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}

\def\EnumerateName{\mbox{{\sf enumerate}}}
\def\Enumerate#1{\EnumerateName_{#1}}

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}

\def\LogName{\mbox{{\sf log}}}
\def\Log#1{\LogName(#1)}

\def\SinName{\mbox{{\sf sin}}}
\def\Sin#1{\SinName(#1)}

\def\CosName{\mbox{{\sf cos}}}
\def\Cos#1{\CosName(#1)}

\def\Abs#1{|#1|}

\def\ElemsName{\mbox{{\em Elems}}}
\def\Elems#1{\ElemsName(#1)}

\def\SizeName{\#}
\def\Size#1{\#\left(#1\right)}

%\def\Binomial#1#2{\left(\begin{array}{c}#1\\#2\end{array}\right)}
\def\Binomial#1#2{C_{#2}^{#1}}

\title{Mathematical Case Studies: Finite Combinatorics\thanks{Copyright {\copyright} Lemma 1 Ltd. \number\year; filed in the {\Product} source code repository as {\tt wrk073.doc}; $Revision: 1.36 $.}}
\author{Rob Arthan\\{\tt rda@lemma-one.com}}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}

This document presents some definitions and theorems from elementary finite combinatorics.
The definitions include a ``fold'' operator for finite sets and the operation that sums a real-valued function on a finite indexed set.
The theorems include: more facts about finiteness and the size of finite sets; algebraic properties of indexed sums; induction over finitely-supported functions; the inclusion/exclusion principle;
the binomial coefficients and their basic properties, including the formula for the number of combinations and the binomial theorem.

\end{abstract}
%\newpage
%\tableofcontents
%\newpage
\section{INTRODUCTION}
This document is one of a set of documents containing mathematical case studies in  {\ProductHOL}.
It deals with some finite combinatorics.
Notable results include the inclusion/exclusion principle, the formula for the number of combinations and the binomial theorem.

Section~\ref{theory} below gives an overview of the theory, including all the specifications and a guide to the theorems proved.
Section~\ref{listing} contains a listing of all the theorems proved in the theory.
An index to the specifications and the theorems is given at the end of the document.

\section{THE THEORY {\em fincomb}}\label{theory}

\subsection{Preliminaries}
The following commands set up a theory to hold the definitions, theorems, etc.,  and a proof context that is convenient for the work.
The theory is a child of the theory ``analysis'' (defined in~\cite{LEMMA1/HOL/WRK066}) from which we use several definitions, in particular, the characteristic function $\chi_A$ of a set $A$.

=SML
force_delete_theory"fincomb" handle Fail _ => ();
open_theory"analysis";
new_theory"fincomb";
new_parent "set_thms";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙", "'Ø"];
=IGN
open_theory "fincomb";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙", "'Ø"];
=TEX
\subsection{Folding Binary Operators over Finite Sets}

The following definition of a ``fold'' operation for finite sets is parametrised by three things: an associative and commutative binary operator, $p$, with identity element, $e$, and a ``valuation'' function $v$; the operation maps the valuation function over a set combining the resulting values with the product operation.


πHOLCONST
‹ €SetFold› : 'a ≠ ('a ≠ 'a ≠ 'a) ≠ ('b ≠ 'a) ≠ 'b SET ≠ 'a
˜¸¸¸¸¸¸
‹ µe p v∑
‹	(µx∑ p x e = x)
‹ ±	(µx y∑ p x y = p y x)
‹ ±	(µx y z∑ p (p x y) z = p x (p y z))
‹ ¥	SetFold e p v {}  = e
‹ ±	µx a∑	a ç Finite ± ≥x ç a
‹	¥	SetFold e p v ({x} ¿ a) = p (v x) (SetFold e p v a)
∞
The parametrisation of {\em SetFold} is as recommended by Nipkow and Paulson and works nicely. An alternative would be to combine $p$ and $v$ into a single function, say $f = \lambda x y \bullet p(v x) y$
but then the algebraic laws that $f$ must satisfy have an unfamiliar form. The two approaches are interdefinable.

The theorems in the theory begin by with some lemmas about finite sets and their sizes.
These are then used to prove two lemmas needed to prove the consistency of the definition of {\em SetFold}.

\ThmsIII{%
=GFT
¿_finite_thm
elems_finite_thm
list_finite_size_thm1
=TEX
}{%
=GFT
list_finite_size_thm
set_fold_consistent_lemma1
set_fold_consistent_lemma2
=TEX
}{%
=GFT
SetFold_consistent
set_fold_def
=TEX
}

\subsection{Further Theorems About Finiteness}
The first block of theorems extends the repertoire of lemmas about finite sets and their sizes.
The approach to this topic in the {\ProductHOL} library tends to characterise a finite set, $A$, as one that can be written as $\Elems{L}$ for some list $L$ and the size $\Size{A}$ as the length $\Size{L}$ where $L$ is a list of distinct elements with $\Elems{L} = A$.

The first few theorems are aimed at an alternative characterisation of a finite set $A$ as one that is in one-one correspondence with an initial subset of the natural numbers, $\{i | i < m\}$ for some $m$.
{\em En route} are proved various useful facts, e.g., that finiteness and size are preserved under bijections.

\ThmsIII{%
=GFT
singleton_finite_thm
size_Ä_diff_thm
Ä_finite_size_thm
Ä_size_eq_thm
size_disjoint_¿_thm
¿_finite_size_º_thm
=TEX
}{%
=GFT
range_finite_size_thm
length_map_thm
elems_map_thm
map_distinct_thm
nth_ç_elems_thm
elems_nth_thm
=TEX
}{%
=GFT
distinct_nth_thm
bijection_finite_size_thm
bijection_finite_size_thm1
range_bijection_finite_size_thm
surjection_finite_size_thm
range_finite_size_thm1
=TEX
}

The next block of theorems deal with the power set operator.
$\Zpset\,a$
 is defined in the {\ProductHOL} library by the bi-implication
$x \in \Zpset a \iff x \subseteq a$.
The first theorem below just recasts this as an equation.
There are then two trivial but quite useful lemmas about binary partitions of a power set.
This is followed by the theorem that, if $a$ is finite, then so is $\Zpset a$ and $\Size{\Zpset a} = 2^{\Size{a}}$

\ThmsII{%
=GFT
_thm
_split_thm
=TEX
}{%
=GFT
_split_thm1
_finite_size_thm
=TEX
}

\subsection{Sums over Finite Indexed Sets}
A useful application of the set fold operation is to define the following indexed sum operation. Given an index set, $a$, and a function, $f$, assigning a real number to each member of $a$,
=INLINEFT
IndSum a f
=TEX
\ is the indexed sum $\sum_{x\in a}f(x)$, and is defined for any set $a$ in which $f$ has finite support.


πHOLCONST
‹ €IndSum› : 'a SET ≠ ('a ≠ Ø) ≠ Ø
˜¸¸¸¸¸¸
‹ µf∑	IndSum {} f = ÓØ 0
‹ ±	µx a∑	a ç Finite ± ≥x ç a
‹	¥	IndSum ({x} ¿ a) f = f x + IndSum a f
∞

We will write $\sum\,a\,f$ as shorthand for
=INLINEFT
IndSum a f
=TEX
.
=SML
declare_alias("ì", ¨IndSumÆ);
=TEX

The consistency proof for {\em IndSum} is very simple given the set fold operation.
As with {\em SetFold}, the definition is intended to cover the two important cases where $a$ is finite ({\em ind\_sum\_def1}) or where $f$ has finite support ({\em ind\_sum\_def2}).

\ThmsII{%
=GFT
IndSum_consistent
=TEX
}{%
=GFT
ind_sum_def
=TEX
}

We now begin to develop the theory of indexed sums.
The first result is an example: if $A$ is finite,
then its size $\Size{A}$ may be calculated as the indexed sum $\sum_A\,1$.
The next few theorems show that the indexed sum operator $\sum_A\,f$ is linear in $f$ (i.e., it respects addition and multiplication by a constant) and give some useful consequences of this.

A principle that is applied almost unconsciously in informal reasoning is that the indexed sum $\sum_A f$ is a local property of $f$, in the sense that, if $f$ and $g$ are functions that agree on $A$, then $\sum_A f = \sum_A g$.
This block  of theorems concludes with one showing how indexed sums behave when the function is composed with a bijection: if $b$ is a bijection on the set $A$ and $B$ is the image of $A$ under $b$, then $\sum_B f = \sum_A (\lambda x\bullet f(b(x)))$

\ThmsIII{%
=GFT
ind_sum_size_thm
ind_sum_plus_thm
ind_sum_minus_thm
=TEX
}{%
=GFT
ind_sum_const_times_thm
ind_sum_0_thm
ind_sum_diff_0_thm
=TEX
}{%
=GFT
ind_sum_local_thm
ind_sum_0_bc_thm
bijection_ind_sum_thm
=TEX
}

We now have two lemmas for calculating the indexed sum in two cases where there is at most one non-zero value in the sum:

\ThmsII{
=GFT
ind_sum_—_singleton_thm
=TEX
}{%
=GFT
ind_sum_singleton_thm
=TEX
}

Now we define the support of a real valued function.
πHOLCONST
‹ €Supp› : ('a ≠ Ø) ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ f∑ Supp f = {x | ≥f x = ÓØ 0}
∞

Next comes an induction principle for functions of finite support, i.e., functions $f$ such that $f(x) \not= 0$ for at most finitely many $x$.
If $p$ is any property of functions that is true for the characteristic function, $\chi_{\{x\}}$, of any singleton set, $\{x\}$, and that is preserved under addition and multiplication by a constant (for operands of finite support), then $p(f)$ holds for any function $f$ of finite support.

In working with an indexed sum $\sum_A f$, one can always assume that $f$ has finite support (by adjusting it to be 0 outside $A$ if necessary). This induction principle gives a different line of attack on $\sum_A f$, which can be particularly useful if the internal structure of $A$ is complex.

\ThmsIII{
=GFT
fin_supp_induction_thm
=TEX
}{
=GFT
fin_supp_induction_thm1
=TEX
}{
=GFT
supp_clauses
=TEX
}

We will use the induction principle for functions of finite support to tackle the inclusion/exclusion principle.
The inclusion/exclusion principle deals with a family $U_i$ of sets where $i$ range over a finite and non-empty index set $I$.
The inclusion/exclusion principle is the following equation giving the size of the union of the $U_i$.
\begin{equation}
\Size{\bigcup_{i \in I} U_i} =
\sum_%
	{\begin{array}{c}J \in \Zpset I\\ J \not= \{\}\end{array}}%
		(-1)^{\Size{J} + 1}%
	\Size{\bigcap_{j \in J}U_j}
\end{equation}

This is a special case of a more general statement about indexed sums and the more general statement is actually rather simpler to prove.
The more general statement is the following, which holds for $U_i$ and $I$ above and any real-valued function $f$:
\begin{equation}
\sum_{x \in \bigcup_{i \in I} U_i} f(x)=
\sum_%
	{\begin{array}{c}J \in \Zpset I\\ J \not= \{\}\end{array}}%
		(-1)^{\Size{J} + 1}%
	\left(\sum_%
		{z \in \bigcap_{j \in J}U_j}%
			f(z)%
	\right)
\end{equation}

The statement about sizes follows immediately from the statement about indexed sums by applying it to the function $f(x) = 1$.
The statement about sums is better understood in the following more symmetric form in which $A = \bigcup_{i \in I}U_i$ is the range of the sum on the left-hand side of the above equation:
\begin{equation}
\sum_%
	{J \in \Zpset I}%
		(-1)^{\Size{J}}%
	\left(\sum_%
		{z \in A \cap \bigcap_{j \in J}U_j}%
			f(z)%
	\right) %
	= 0 \label{sym_inc_exc}
\end{equation}

Here, the intersections with $A$ in the range of the inner sum have no effect except when $J$ is empty.
The previous statement thus follows from the above simply by subtracting the sum over the non-empty $J$ from both sides of the equation.

It is quite natural to attempt to prove equation (\ref{sym_inc_exc}) by induction on $I$ (or on the size of $I$). This works, but the proof is somewhat complicated. Somewhat simpler is to work by induction on $A$, but it it still quite complex.
Instead, our proof of the inclusion/exclusion principle implements the above remarks together with the proof of equation (\ref{sym_inc_exc}) sketched below which works by induction on the structure of $f$.



Changing it to be identically 0 outside A if necessary, we may assume $f$ has finite support, and, as the left-hand side of (\ref{sym_inc_exc}) is easily seen to be linear in $f$, the principle of induction for functions of finite support means it is sufficient to prove (\ref{sym_inc_exc}) when $f = \chi_{\{x\}}$ is the characteristic function of a singleton set $\{x\}$.
For $f = \chi_{\{x\}}$, the summand $f(z)$ on the left-hand side of (\ref{sym_inc_exc}) is 1 or 0 according as $z = x$ or not.
Thus the inner sum is 1 if $x \in U_j$ for all $j \in J$ and vanishes otherwise.

So, if $x$ is not in any $U_j$, the left-hand side of (\ref{sym_inc_exc}) vanishes and we are done, and, if $x$ is in some $U_j$, (\ref{sym_inc_exc}) reduces to:
\begin{equation}
\sum_%
	{J \in \Zpset \{j \in I | x \in U_j\}}%
		(-1)^{\Size{J}}%
	= 0 \label{ind_sum_p}
\end{equation}

(Formally, we are appealing here to the special case of the inclusion/exclusion principle when $\Size{I}=2$, which states that $\sum_{B \cup C}f = \sum_B f + \sum_C f - \sum_{B \cap C}f$, with $B = \Zpset \{j \in I | x \in U_j\}$ and $C = \Zpset I \backslash B$.)

But now I claim that 
$
\sum_%
	{J \in \Zpset K}%
		(-1)^{\Size{J}}%
	= 0
$ for any non-empty indexed set $K$, which, taking $K=\{j \in I | x \in U_j\}$ in (\ref{ind_sum_p}) will complete the proof.

To see that $
\sum_%
	{J \in \Zpset K}%
		(-1)^{\Size{J}}%
	= 0
$ for any non-empty indexed set $K$, pick $k \in K$, then, as $J$ ranges over $\Zpset(K \backslash \{k\})$, the sets $J$ and $J \cup \{i\}$ range over $\Zpset K$ (with every member of $\Zpset K$ appearing exactly once).
As $(-1)^{\Size{J}} = -(-1)^{\Size{J \cup \{i\}}}$, the contributions of $J$ and $J \cup \{i\}$ cancel out and the sum is zero. (Formally, we are again using the special case of the principle for $\Size{I} = 2$ together with the result about indexed sums composed with a bijection.)

The above proof is captured in the following series of theorems, which give the main steps in the above argument in bottom-up order:

\ThmsIII{%
=GFT
ind_sum_¿_thm
ind_sum__thm
=TEX
}{%
=GFT
ind_ﬁ_finite_thm
ind_sum_inc_exc_sym_thm
=TEX
}{%
=GFT
ind_sum_inc_exc_thm
size_inc_exc_thm
=TEX
}

A final block of theorems in this section are useful facts about supports and indexed sums of use elsewhere.



\ThmsIII{%
=GFT
supp_—_thm
supp_plus_thm
=TEX
}{%
=GFT
ind_sum_supp_thm
ind_sum_transfer_thm
=TEX
}{%
=GFT
ind_sum_singleton_∏_thm
ind_sum_∏_thm
=TEX
}

\subsection{Binomial Coefficients}

We define the binomial coefficient $\Binomial{n}{m}$ by recursion equations in the usual way.
The consistency of the definition is proved automatically.

πHOLCONST
‹ €Binomial› : Ó ≠ Ó ≠ Ó 
˜¸¸¸¸¸¸
‹	Binomial 0 0 = 1
‹ ±	(µm∑Binomial 0 (m+1) = 0)
‹ ±	(µn∑Binomial (n+1) 0 = 1)
‹ ±	(µn m∑ Binomial (n+1) (m+1) = Binomial n m + Binomial n (m+1))
∞

After the inclusion/exclusion principle, we turn to something  a little simpler, proving that if $A$ is a set of size $n$, then $A$ has $\Binomial{n}{m}$ subsets of size $m$.
In a related vein we also prove the binomial theorem (but apart from the algebraic facts about the binomial function that are used, the proofs are separate).

We then have a couple of useful lemmas about the factorial function which are used to prove the formula $\Binomial{m+n}{m} = (n+m)!/m!*n!$.

\ThmsIII{%
=GFT
binomial_0_clauses
binomial_less_0_thm
binomial_eq_thm
=TEX
}{
=GFT
combinations_finite_size_thm
binomial_thm1
binomial_thm
=TEX
}{
=GFT
factorial_not_0_recip_thm
factorial_times_thm
binomial_factorial_thm
=TEX
}

\subsection{Sampling}

If $A$ is a finite set of size $s$ say, there are $s^n$ ways of taking an ordered sample of $m$ not necessarily distinct elements of $A$ (``sampling with replacement'').
If the samples are required to be distinct, then there are no samples unless $s = m + n \ge n$, say, and then the number of samples is $(m+n)(m+n-1)\ldots (m+1)$ (``sampling without replacement'').
The following function gives this quantity as a function of $m$ and $n$.
 
πHOLCONST
‹ €DistinctSamples› : Ó ≠ Ó ≠ Ó
˜¸¸¸¸¸¸
‹ 	(µn∑ DistinctSamples n 0 = 1)
‹ ±	(µm n∑ DistinctSamples n (m+1) = (n+m+1) * DistinctSamples n m)
∞

The following block of theorems help deal with sampling and provide some further useful combinatorial facts.
The first in the block proves the existence of a polymorphic enumeration function assigning to each finite set $A$,
a function $\Enumerate{A}$ which maps the set of natural numbers less than $\Size{A}$ bijectively onto $A$.
This is used to prove a theorem about ``coverings'': let us say a set $B$ {\em covers} another set $A$, if there is a function $f$ and a natural number $m$ mapping $B$ to $A$ such that the inverse images $f^{-1}(y)$ as $y$ ranges over $A$ are all finite and of size $m$; in these circumstances, then if $A$ is finite, so is $B$ and $\Size{B} = m \times \Size{A}$.

These facts (together with earlier counting principles) are then used to prove the statements made above about sampling, in which we use lists to represent ordered samples. This representation fits in nicely with earlier results connecting lists and finite sets.

\ThmsII{%
=GFT
enumerate_thm
covering_finite_size_thm
samples_finite_size_thm
=TEX
}{%
=GFT
distinct_samples_rw_thm
distinct_samples_up_thm
distinct_samples_finite_size_thm
=TEX
}

Determining probabilities in finite sample spaces is ``simply'' a matter of counting: if $S$ is finite sample space with $\Size{S} \not= 0$ and $X$ is a subset of $S$, then the probability that an event in $S$ belongs to $X$ is $\Size{X}/\Size{S}$.

The next theorem gives the well-known calculation that in a group of 23 people, the probability that at least two people have the same birthday is greater than $1/2$.
This is a simple consequence of the above theorems on sampling ($S$ and $S \ X$ being the set of samples of size 23 out of a set of size 365 with and without replacement respectively).
In section~\ref{ballot}, we do a harder example.

\ThmsIII{}{%
=GFT
birthdays_thm
=TEX
}{}

\subsection{Application: Bertrand's Ballot Theorem}\label{ballot}

In Bertrand's ballot problem a ballot is held between two candidates, North and South, say.
North beats South, the votes being counted one at a time by a single clerk.
The problem is to calculate the probability that at all times during the count, North had a majority over South.


The answer is the result of dividing the North's final majority by the total number of votes cast.
I.e., if the North receives $M$ votes and South $N$, the probability is $(M - N)/(M + N)$.

Following Feller~\cite{Feller68}, we represent the ballot problem using {\em walks} (also called ``paths'' in~\cite{Feller68}).
We define a {\em walk} of length $n$ starting at $x$ is a sequence of integers $s_i$ such that $s_0 = x$, $|s_{m+1} - s_m| = 1$ for $0 \le i < n$ and (for definiteness) $s_{m+1} = s_n$ for $m \ge n$.

πHOLCONST
‹ €Walk› : Ó ≠ ˙ ≠ (Ó ≠ ˙) SET
˜¸¸¸¸¸¸
‹ µn x s∑
‹	s ç Walk n x
‹ §	s 0 = x
‹ ±	(µm∑m < n ¥ Abs(s(m+1) - s(m)) = Ó˙ 1)
‹ ±	(µm∑n º m ¥ s m = s n)
∞

In talking about walks, we often identify a walk $s_i$ with the polygonal path obtained by joining the points $(i, s_i)$ in the plane. Under this identification a walk starting at $x$ of length $n$ begins at $(0, x)$, takes $n$ diagonal north-east or south-east steps and then heads directly east indefinitely.
The following definition captures the final $y$-value taken on by a walk.

πHOLCONST
‹ €WalkTo› : Ó ≠ ˙ ≠ ˙ ≠ (Ó ≠ ˙) SET
˜¸¸¸¸¸¸
‹ µn x y s∑
‹	s ç WalkTo n x y
‹ §	s ç Walk n x ± s n = y
∞

Walks satisfy a discrete version of the intermediate value theorem: if $x$, $y$ and $z$ are integers such that $z$ lies between $x$ and $y$ then any walk from $x$ to $y$ takes the value $z$ at some stage.



In the ballot problem, define $t_i$ to be the (possibly zero or negative) majority of North over South when the $i$-th vote is counted.
Then $t_i$ is a walk of length $M + N$ from $0$ to $M - N$ and any such walk corresponds to exactly one possible order in which to count the votes.

πHOLCONST
‹ €BallotCounts› : Ó ≠ Ó ≠ (Ó ≠ ˙) SET
˜¸¸¸¸¸¸
‹ µm n∑ BallotCounts m n = WalkTo (m + n) (Ó˙ 0) (Ó˙ m - Ó˙ n)
∞

Thus the probability we have to calculate is $x/s$, where $s$ is the total number of walks, $t_i$, of length $M + N$ from $0$ to $M - N$, and where $x$ is the number of these that are {\em favourable}, i.e., that are such that $t_i > 0$ for $i > 0$.
For any $Q$, a walk of length $M + N$ from $Q$ to $Q + M - N$ is uniquely determined by the set of indices $i$ for which $t_{i+1} - t_i = 1$.
Thus the number of such walks is the number of ways of choosing $M$ numbers less than $M + N$, i.e., $s = \Binomial{M+N}{M}$.

To calculate the number of favourable walks, we use what Feller calls the {\em reflection principle}. This says that, if $i$ and $j$ are positive integers, then there is a one-to-one correspondence between walks of length $M+N$, $s_i$, from $i$ to $j$ which cross the $x$-axis and arbitrary walks of length $M+N$ from $-i$ to $j$. To see this one observes that, by the intermediate value theorem for walks, a walk, $t_i$, of the second sort must have $t_i = 0$ for some $i$; reflecting the initial negative segment of $t_i$ in the $x$-axis gives a walk $s_i$ of the first sort. This reflection defines the required one-to-one correspondence.

Now if $t_i$ is a favourable walk of length $M+N$ from $0$ to $M-N$ then $u_i = t_{i+1}$ defines a walk from $1$ to $M-N > 0$ which does not cross the $x$-axis.
From the reflection principle, we have that the number of such walks is $a = \Binomial{M+N-1}{M-1} - \Binomial{M+N-1}{M}$.
It then follows from a calculation using the expression of the binomial function in terms of factorials, that $x/s = (M-N)/(M+N)$.

The following block of theorems implements the proof sketched above.

\ThmsII{%
=GFT
walk_thm
walk_to_thm
walk_finite_size_thm
walk_to_finite_size_thm
walk_to_empty_thm
walk_to_finite_thm
walk_walk_to_thm
walk_shift_thm
walk_minus_thm
=TEX
}{%
=GFT
walk_to_minus_thm
walk_to_intermediate_value_thm
walk_to_reflection_thm
ballot_lemma1
ballot_lemma2
ballot_lemma3
ballot_lemma4
ballot_lemma5
ballot_thm
=TEX
}

\subsection{Involutions}

Involutions give some useful counting principles.

πHOLCONST
‹ €Involution› : 'a SET ≠ ('a ≠ 'a) SET
˜¸¸¸¸¸¸
‹ µf A∑ f ç Involution A § (µx∑ x ç A ¥ f x ç A ± f(f x) = x)
∞
Fixed points are important:

πHOLCONST
‹ €Fixed› : ('a ≠ 'a) ≠ 'a SET
˜¸¸¸¸¸¸
‹ µx f∑ x ç Fixed f § f x = x
∞


We prove that every involution $f$ on a set $X$ has a fundamental region:
i.e., a subset $A$ such that $X$ decomposes as the disjoint
union of $A$, $f(A)$ and the fixed point set of $f$.
We use Zorn's lemma for this in the special case where the
ordered set comprises sets and inclusion.
The formulation of this case of Zorn's lemma in some versions
of {\Product} is hard to use directly, so we provide a more
convenient formulation.
After a few convenience lemmas, we then give the main
counting principles for involutions on finite sets:
if a set admits an involution with no fixed points, its size is even;
an involution on a set with an odd size has at least one fixed point;
if a set admits an involution with a unique fixed point, its size is odd.

\ThmsIII{%
=GFT
zorn_thm2
fund_region_thm
involution_one_one_thm
involution_def_thm1
=TEX
}{%
=GFT
involution_def_thm2
involution_size_thm
involution_even_size_thm
=TEX
}{%
=GFT
involution_odd_size_thm
involution_set_dif_fixed_thm
involution_fixed_singleton_thm
=TEX
}

\subsection{Application: the Two Squares Theorem}
We apply the theorems on involutions to do the combinatorial
part of Heath-Brown's ingenious proof of the theorem that
every prime congruent to 1 modulo 4 is the sum of two squares.
This requires a few preliminary lemmas on integer arithmetic.
Apart from variable names, the proof then follows closely the presentation of~\cite{Aigner00} (our sets $A$, $B$ and $C$ are Aigner \& G\"{u}nter's $S$, $T$ and $U$).
At each stage, rather than assume primality, we make the exact assumptions the combinatorial arguments require.
The proof is completed in ~\cite{LEMMA1/HOL/WRK074} where prime numbers are defined.

\ThmsIII{%
=GFT
˙_interval_finite_thm
˙_0_º_square_thm
˙_0_less_0_less_times_thm
˙_0_less_times_thm
˙_0_less_times_thm1
˙_º_square_thm
=TEX
}{%
=GFT
a_finite_thm
f_involution_a_thm
size_a_size_b_thm
size_a_size_c_thm
size_c_size_c_thm
=TEX
}{%
=GFT
g_involution_c_thm
size_c_thm
h_involution_b_thm
h_fixed_in_b_thm
two_squares_lemma
=TEX
}

\bibliographystyle{fmu}
\bibliography{fmu}

%\appendix
{%\HOLindexOff
\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{wrk073.th}}

=TEX

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
=TEX
%%%%
%%%%
=SML
val €supp_def› = get_spec ¨SuppÆ;
val €binomial_def› = get_spec ¨BinomialÆ;
val €distinct_samples_def› = get_spec ¨DistinctSamplesÆ;
val €walk_def› = get_spec ¨WalkÆ;
val €walk_to_def› = get_spec ¨WalkToÆ;
val €ballot_counts_def› = get_spec ¨BallotCountsÆ;
val €Ó_exp_def› = get_spec ¨1 ^ 2Æ;
val €involution_def› = get_spec ¨InvolutionÆ;
val €fixed_def› = get_spec ¨FixedÆ;
=TEX
%%%%
%%%%

=SML
val €ÓØ_Ó_exp_thm› = save_thm ( "ÓØ_Ó_exp_thm", (
set_goal([], ¨µm n:Ó∑ÓØ (m^n) = ÓØ m ^ nÆ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ
	THEN  rewrite_tac[Ø_Ó_exp_def, Ó_exp_def]);
a(asm_rewrite_tac[ÓØ_times_homomorphism_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €˙_abs_eq_1_thm› = save_thm ( "˙_abs_eq_1_thm", (
set_goal([], ¨µx∑ Abs x = Ó˙ 1 § x = Ó˙ 1 ≤ x = ~(Ó˙ 1)Æ);
a(µ_tac THEN PC_T1 "predicates" cases_tac¨Ó˙ 0 º xÆ
	THEN asm_rewrite_tac[˙_abs_def]
	THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €walk_def1› = save_thm("walk_def1", rewrite_rule[˙_abs_eq_1_thm] walk_def);
=TEX
The following three should definitely go in the finite sets theory soon. !!! TBD !!!
%%%%
%%%%
=SML
val €¿_finite_thm› = save_thm ( "¿_finite_thm", (
set_goal([], ¨µA B∑
	 (A ¿ B) ç Finite § A ç Finite ± B ç Finite
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac ¨A Ä A ¿ BÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
(* *** Goal "2" *** *)
a(lemma_tac ¨B Ä A ¿ BÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨BÆ, ¨BÆ));
a(finite_induction_tac ¨AÆ THEN1 asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(LEMMA_T¨({x} ¿ A) ¿ B = {x} ¿ A ¿ BÆ
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(bc_thm_tac singleton_¿_finite_thm THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML
val €min_ç_thm› = save_thm ( "min_ç_thm", (
set_goal([], ¨µn a∑ n ç a ¥ Min a ç aÆ);
a(µ_tac THEN cov_induction_tac ¨n:ÓÆ THEN REPEAT strip_tac);
a(cases_tac¨∂m∑ m < n ± m ç aÆ);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨Min a = nÆ asm_rewrite_thm_tac);
a(bc_thm_tac(get_spec¨MinÆ) THEN REPEAT strip_tac);
a(spec_nth_asm_tac 2 ¨iÆ);
a(PC_T1 "lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML
val €min_º_thm› = save_thm ( "min_º_thm", (
set_goal([], ¨µn a∑ n ç a ¥ Min a º nÆ);
a(µ_tac THEN cov_induction_tac ¨n:ÓÆ THEN REPEAT strip_tac);
a(cases_tac¨∂m∑ m < n ± m ç aÆ);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨Min a = nÆ rewrite_thm_tac);
a(bc_thm_tac(get_spec¨MinÆ) THEN REPEAT strip_tac);
a(spec_nth_asm_tac 2 ¨iÆ);
a(PC_T1 "lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €elems_finite_thm› = save_thm ( "elems_finite_thm", (
set_goal([], ¨µlist∑ Elems list ç FiniteÆ);
a(REPEAT strip_tac);
a(list_induction_tac ¨listÆ
	THEN asm_rewrite_tac[elems_def, empty_finite_thm]);
a(ALL_FC_T rewrite_tac[singleton_¿_finite_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €list_finite_size_thm1› = save_thm ( "list_finite_size_thm1", (
set_goal([], ¨µa∑
	 a ç Finite
§	∂list∑list ç Distinct ± Elems list = a ± #list = #aÆ);
a(REPEAT_UNTIL is_± strip_tac THEN strip_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN all_fc_tac[finite_distinct_elems_thm]);
a(∂_tac¨listÆ THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[distinct_size_length_thm]);
(* *** Goal "2" *** *)
a(strip_tac THEN all_var_elim_asm_tac1 THEN rewrite_tac[elems_finite_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €list_finite_size_thm› = save_thm ( "list_finite_size_thm", (
set_goal([], ¨µa m∑
	 a ç Finite ± #a = m
§	∂list∑list ç Distinct ± Elems list = a ± #list = mÆ);
a(REPEAT_UNTIL is_± strip_tac THEN strip_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN all_var_elim_asm_tac1 THEN POP_ASM_T ante_tac);
a(rewrite_tac[list_finite_size_thm1]);
(* *** Goal "2" *** *)
a(strip_tac THEN all_fc_tac[distinct_size_length_thm]
	THEN all_var_elim_asm_tac1
	THEN asm_rewrite_tac[elems_finite_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €set_fold_consistent_lemma1› = save_thm ( "set_fold_consistent_lemma1", (
set_goal([], ¨µx list1 n∑
	x ç Elems list1 ± list1 ç Distinct ± #list1 = n + 1 
¥	∂list2∑ list2 ç Distinct ± Elems list2 = Elems list1 \ {x}
	± #list2 = nÆ);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) list_finite_size_thm]);
a(REPEAT µ_tac THEN ¥_tac);
a(once_rewrite_tac[prove_rule[]¨µp q∑p ± q § (p ± (p ¥ q))Æ]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ä_finite_thm);
a(∂_tac¨Elems list1Æ THEN rewrite_tac[elems_finite_thm]);
a(PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T¨#(Elems list1) = #list1Æ ante_tac
	THEN1 (bc_thm_tac distinct_size_length_thm
		THEN REPEAT strip_tac));
a(LEMMA_T¨Elems list1 = {x} ¿ Elems list1 \ {x}Æ (fn th => conv_tac(LEFT_C(once_rewrite_conv[th])))
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(LEMMA_T¨≥x ç Elems list1 \ {x}Æ asm_tac
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(ALL_FC_T rewrite_tac[size_singleton_¿_thm]);
a(asm_rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €set_fold_consistent_lemma2› = save_thm ( "set_fold_consistent_lemma2", (
set_goal([], ¨µe p v∑
	(µx∑ p x e = x)
±	(µx y∑ p x y = p y x)
±	(µx y z∑ p (p x y) z = p x (p y z))
¥	µn list1 list2∑
	list1 ç Distinct ± list2 ç Distinct
±	#list1 = n
±	Elems list1 = Elems list2
¥	Fold (Ã x y∑ p (v x) y) list1 e
=	Fold (Ã x y∑ p (v x) y) list2 eÆ);
a(REPEAT µ_tac THEN ¥_tac THEN µ_tac);
a(induction_tac¨nÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T ¨list1 = [] ± list2 = []Æ
	(fn th => rewrite_tac[th, fold_def]));
a(DROP_NTH_ASM_T 2 ante_tac);
a(strip_asm_tac (µ_elim¨list1Æ list_cases_thm)
	THEN asm_rewrite_tac[length_def]
	THEN all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN rewrite_tac[elems_def]);
a(strip_asm_tac (µ_elim¨list2Æ list_cases_thm)
	THEN asm_rewrite_tac[elems_def]
	THEN all_var_elim_asm_tac1);
a(PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T¨#(Elems list1) = #list1Æ ante_tac
	THEN1 (bc_thm_tac distinct_size_length_thm
		THEN REPEAT strip_tac));
a(TOP_ASM_T rewrite_thm_tac);
a(LEMMA_T¨#(Elems list2) = #list2Æ rewrite_thm_tac
	THEN1 (bc_thm_tac distinct_size_length_thm
		THEN REPEAT strip_tac));
a(GET_NTH_ASM_T 2 rewrite_thm_tac THEN strip_tac);
a(DROP_NTH_ASM_T 3 ante_tac);
a(strip_asm_tac (µ_elim¨list1Æ list_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN rewrite_tac[length_def]
	THEN strip_tac);
a(DROP_NTH_ASM_T 2 ante_tac);
a(strip_asm_tac (µ_elim¨list2Æ list_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN rewrite_tac[length_def]);
a(rename_tac[(¨list2'Æ, "L1"), (¨list2''Æ, "L2")]
	THEN strip_tac);
a(cases_tac¨x' = xÆ
	THEN1 all_var_elim_asm_tac);
(* *** Goal "2.1" *** *)
a(LIST_DROP_NTH_ASM_T [3, 4]
	(MAP_EVERY (strip_asm_tac o rewrite_rule[distinct_def])));
a(DROP_NTH_ASM_T 6 ante_tac);
a(rewrite_tac[elems_def] THEN REPEAT strip_tac);
a(LEMMA_T¨µa b∑≥x ç a ± ≥ x ç b ± {x} ¿ a = {x} ¿ b ¥ a = bÆ (fn th => all_fc_tac[th])
	THEN1 PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(spec_nth_asm_tac 2 ¨x'Æ THEN all_var_elim_asm_tac1);
(* *** Goal "2.1.2" *** *)
a(spec_nth_asm_tac 2 ¨x'Æ THEN all_var_elim_asm_tac1);
(* *** Goal "2.1.3" *** *)
a(rewrite_tac[fold_def]);
a(bc_thm_tac(prove_rule [] ¨µa b ∑a = b ¥ p (v x') a = p (v x') bÆ));
a(DROP_NTH_ASM_T 8 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(LIST_DROP_NTH_ASM_T [4, 5]
	(MAP_EVERY (strip_asm_tac o rewrite_rule[distinct_def])));
a(LEMMA_T¨x' ç Elems(Cons x L1)Æ ante_tac
	THEN1 (DROP_NTH_ASM_T 7 rewrite_thm_tac
		THEN PC_T1 "sets_ext1" rewrite_tac[elems_def]));
a(PC_T1 "sets_ext1" rewrite_tac[elems_def]);
a(REPEAT strip_tac);
a(lemma_tac¨≥#L1 = 0Æ
	THEN1 (strip_asm_tac (µ_elim¨L1Æ list_cases_thm)
		THEN all_var_elim_asm_tac1
		THEN all_asm_ante_tac
		THEN rewrite_tac[length_def, elems_def]));
a(LEMMA_T¨1 º #L1Æ (strip_asm_tac o
	once_rewrite_rule[plus_comm_thm] o
		rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(POP_ASM_T (strip_asm_tac o eq_sym_rule));
a(all_fc_tac[set_fold_consistent_lemma1]);
a(rename_tac[(¨list2Æ, "T1")]
	THEN rewrite_tac[fold_def]);
a(LEMMA_T¨
	Fold (Ã x'' y∑ p (v x'') y) L1 e =
	Fold (Ã x'' y∑ p (v x'') y) (Cons x' T1) eÆ
	rewrite_thm_tac);
(* *** Goal "2.2.1" *** *)
a(DROP_NTH_ASM_T 14 bc_thm_tac);
a(asm_rewrite_tac[distinct_def, elems_def]);
a(PC_T1 "sets_ext1" rewrite_tac[]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac);
(* *** Goal "2.2.2" *** *)
a(rewrite_tac[fold_def]);
a(GET_NTH_ASM_T 15 (rewrite_thm_tac o conv_rule(ONCE_MAP_C eq_sym_conv)));
a(DROP_NTH_ASM_T 16 (fn th => conv_tac
(LEFT_C(RATOR_C(RAND_C(once_rewrite_conv[th]))))));
a(DROP_NTH_ASM_T 15 rewrite_thm_tac);
a(bc_thm_tac(prove_rule [] ¨µa b ∑a = b ¥ p (v x') a = p (v x') bÆ));
a(LEMMA_T¨
	Fold (Ã x'' y∑ p (v x'') y) L2 e =
	Fold (Ã x'' y∑ p (v x'') y) (Cons x T1) eÆ
	(rewrite_thm_tac o rewrite_rule[fold_def]));
a(DROP_NTH_ASM_T 14 bc_thm_tac);
a(DROP_NTH_ASM_T 13 ante_tac);
a(asm_rewrite_tac[distinct_def, elems_def]);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 12 (strip_asm_tac o conv_rule(RAND_C eq_sym_conv)));
a(ALL_FC_T rewrite_tac[pc_rule1 "sets_ext1" prove_rule[]
	¨µx y a∑ ≥x = y ¥ {x} ¿ a \ {y} = ({x} ¿ a) \ {y}Æ]);
a(asm_rewrite_tac[]);
a(PC_T1 "sets_ext1" rewrite_tac[]);
a(contr_tac THEN all_var_elim_asm_tac);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
(*
drop_main_goal();
*)
push_consistency_goal ¨SetFoldÆ;
a(lemma_tac¨∂r∑ µa:'b SET∑ a ç Finite ¥ r a ç Distinct
	± Elems(r a) = a
	± #(r a) = #aÆ);
(* *** Goal "1" *** *)
a(prove_∂_tac THEN strip_tac);
a(cases_tac¨a' ç FiniteÆ THEN asm_rewrite_tac[]);
a(asm_rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) list_finite_size_thm]);
(* *** Goal "2" *** *)
a(prove_∂_tac THEN REPEAT strip_tac);
a(∂_tac ¨Ãa∑ Fold (Ãx y∑p' (v' x) y) (r a) e'Æ
	THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(LEMMA_T¨r{} = []Æ (fn th => rewrite_tac[th, fold_def]));
a(DROP_NTH_ASM_T 4 (ante_tac o µ_elim¨{}:'b SETÆ));
a(strip_asm_tac (µ_elim¨r{}Æ list_cases_thm)
	THEN asm_rewrite_tac[]);
a(rewrite_tac[empty_finite_thm, size_empty_thm, length_def]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨{x} ¿ a ç FiniteÆ 
	THEN1 (bc_thm_tac singleton_¿_finite_thm
		THEN REPEAT strip_tac));
a(LIST_DROP_NTH_ASM_T [7] all_fc_tac);
a(LEMMA_T¨
	Fold (Ã x y∑ p' (v' x) y) (r ({x} ¿ a)) e' =
	(Fold (Ã x y∑ p' (v' x) y) (Cons x (r a)) e')Æ
	(rewrite_thm_tac o rewrite_rule[fold_def]));
a(ante_tac(list_µ_elim[¨e'Æ, ¨p'Æ, ¨v'Æ]set_fold_consistent_lemma2));
a(PC_T1 "'propositions" asm_rewrite_tac[]);
a(STRIP_T bc_thm_tac);
a(∂_tac¨#a + 1Æ THEN asm_rewrite_tac[distinct_def, elems_def]);
a(bc_thm_tac size_singleton_¿_thm THEN REPEAT strip_tac);
val _ = save_consistency_thm ¨SetFoldÆ (pop_thm());
val €set_fold_def› = save_thm("set_fold_def", get_spec ¨SetFoldÆ);
=TEX
%%%%
%%%%
=SML
(*
drop_main_goal();
*)
push_consistency_goal ¨IndSumÆ;
a(∂_tac ¨Ãa f∑SetFold (ÓØ 0) ($ +) f aÆ);
a(µ_tac THEN rewrite_tac[] THEN bc_thm_tac(set_fold_def));
a(rewrite_tac[Ø_plus_assoc_thm]);
val _ = save_consistency_thm ¨ìÆ (pop_thm());
val €ind_sum_def› = save_thm("ind_sum_def", get_spec ¨ìÆ);
=TEX
%%%%
%%%%
=SML
val €singleton_finite_thm› = save_thm("singleton_finite_thm",
	rewrite_rule[empty_finite_thm]
		(µ_elim¨{}Æ singleton_¿_finite_thm));
=TEX
%%%%
%%%%
=SML
val €size_Ä_diff_thm› = save_thm ( "size_Ä_diff_thm", (
set_goal([], ¨µa b∑ a ç Finite ± b Ä a ¥ #a = #(a \ b) + #bÆ);
a(REPEAT strip_tac);
a(lemma_tac¨a \ b Ä a ± (a \ b) ° b = {} ± a = (a \ b) ¿ bÆ
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
a(DROP_NTH_ASM_T 3 (fn th => (conv_tac(LEFT_C(once_rewrite_conv[th])))));
a(ante_tac (list_µ_elim[¨a \ bÆ, ¨bÆ] size_¿_thm));
a(asm_rewrite_tac[size_empty_thm]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML
val €Ä_finite_size_thm› = save_thm("Ä_finite_size_thm", (
set_goal([], ¨µa b∑ a ç Finite ± b Ä a ¥ b ç Finite ± #b º #aÆ);
a(REPEAT strip_tac THEN1 all_fc_tac[Ä_finite_thm]);
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨bÆ, ¨bÆ));
a(finite_induction_tac¨aÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T ¨b = {}Æ rewrite_thm_tac);
a(PC_T1"sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(cases_tac¨x ç bÆ);
(* *** Goal "2.1" *** *)
a(PC_T1 "predicates" lemma_tac¨b \ {x} Ä a ± ≥x ç b \ {x}Æ
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
a(LEMMA_T¨b = {x} ¿ (b \ {x})Æ once_rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[size_singleton_¿_thm]);
a(all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨b Ä aÆ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2.2.1" *** *)
a(asm_fc_tac[] THEN all_var_elim_asm_tac);
(* *** Goal "2.2.2" *** *)
a(ALL_FC_T rewrite_tac[size_singleton_¿_thm]);
a(asm_fc_tac[] THEN PC_T1 "lin_arith" asm_prove_tac[]);
pop_thm()
));
=TEX
%%%%
%%%%

=SML
val €Ä_size_eq_thm› = save_thm ("Ä_size_eq_thm", (
set_goal([],¨µa b∑ a ç Finite ± b Ä a ± #b = #a ¥ b = aÆ);
a(contr_tac);
a(lemma_tac¨a \ b Ä a ± ≥a \ b = {}Æ THEN1
	PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
a(LEMMA_T ¨# (b ¿ (a \ b)) + # (b ° (a \ b)) = # b + # (a \ b)Æ ante_tac THEN1
	(bc_thm_tac size_¿_thm THEN REPEAT strip_tac));
a(LEMMA_T ¨b ¿ (a \ b) = a ± b ° (a \ b) = {}Æ rewrite_thm_tac THEN1
	PC_T1 "sets_ext1" asm_prove_tac[]);
a(rewrite_tac[size_empty_thm]);
a(lemma_tac ¨≥ #(a \ b) = 0Æ THEN_LIST
	[id_tac, PC_T1 "lin_arith" asm_prove_tac[]]);
a(ALL_FC_T1 fc_§_canon asm_rewrite_tac[size_0_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €size_disjoint_¿_thm› = save_thm ( "size_disjoint_¿_thm", (
set_goal([], ¨µa b c∑
	a ç Finite
±	a = b ¿ c
±	b ° c = {}
¥	#a = #b + #c
Æ);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(all_asm_ante_tac THEN rewrite_tac[¿_finite_thm]
	THEN REPEAT strip_tac);
a(LEMMA_T¨# (b ¿ c) + # (b ° c) = # b + # cÆ ante_tac
	THEN1 all_fc_tac[size_¿_thm]);
a(asm_rewrite_tac[size_empty_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €¿_finite_size_º_thm› = save_thm ( "¿_finite_size_º_thm", (
set_goal([], ¨µa b∑
	a ç Finite
±	b ç Finite
¥	a ¿ b ç Finite ± #(a ¿ b) º #a + #b
Æ);
a(REPEAT strip_tac THEN1 asm_rewrite_tac[¿_finite_thm]);
a(LEMMA_T¨# (a ¿ b) + # (a ° b) = # a + # bÆ ante_tac
	THEN1 all_fc_tac[size_¿_thm]);
a(PC_T1 "lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €range_finite_size_thm› = save_thm ( "range_finite_size_thm", (
set_goal([], ¨µm∑ {i | i < m} ç Finite ± #{i | i < m} = mÆ);
a(µ_tac THEN rewrite_tac[list_finite_size_thm]);
a(induction_tac¨mÆ);
(* *** Goal "1" *** *)
a(∂_tac¨[]Æ THEN rewrite_tac[distinct_def,
	elems_def, length_def]);
a(PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨Cons m listÆ THEN asm_rewrite_tac[distinct_def,
	elems_def, length_def]);
a(DROP_ASMS_T discard_tac
	THEN PC_T1 "sets_ext1" REPEAT strip_tac
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €length_map_thm› = save_thm ( "length_map_thm", (
set_goal([], ¨µf list∑ #(Map f list) = # listÆ);
a(REPEAT strip_tac);
a(list_induction_tac ¨listÆ
	THEN asm_rewrite_tac[map_def, length_def]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €elems_map_thm› = save_thm ( "elems_map_thm", (
set_goal([], ¨µf list∑ 
	Elems (Map f list) = {y | ∂x∑x ç Elems list ± y = f x}Æ);
a(REPEAT strip_tac);
a(list_induction_tac ¨listÆ
	THEN asm_rewrite_tac[map_def, elems_def]
	THEN REPEAT strip_tac
	THEN PC_T1 "sets_ext1" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €map_distinct_thm› = save_thm ( "map_distinct_thm", (
set_goal([], ¨µf list∑ 
	(µ x y∑ x ç Elems list ± y ç Elems list ± f x = f y ¥ x = y)
±	list ç Distinct
¥	Map f list ç DistinctÆ);
a(REPEAT µ_tac);
a(intro_µ_tac(¨fÆ, ¨fÆ) THEN list_induction_tac ¨listÆ
	THEN asm_rewrite_tac[map_def, distinct_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[elems_map_thm] THEN REPEAT strip_tac);
a(swap_nth_asm_concl_tac 3);
a(LEMMA_T¨x = x'Æ asm_rewrite_thm_tac);
a(DROP_NTH_ASM_T 4 bc_thm_tac);
a(PC_T1 "sets_ext1" asm_rewrite_tac[elems_def]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 bc_thm_tac);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 6 bc_thm_tac);
a(PC_T1 "sets_ext1" asm_rewrite_tac[elems_def]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €nth_ç_elems_thm› = save_thm ( "nth_ç_elems_thm", (
set_goal([], ¨µlist i∑ 
	i < #list
¥	Nth list (i+1) ç Elems listÆ);
a(µ_tac);
a(list_induction_tac ¨listÆ
	THEN asm_rewrite_tac[elems_def, nth_def, length_def]);
a(REPEAT µ_tac);
a(cases_tac¨i = 0Æ THEN asm_rewrite_tac[]
	THEN1 PC_T1 "sets_ext1" rewrite_tac[]);
a(REPEAT strip_tac);
a(lemma_tac¨1 º iÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[º_def]));
a(DROP_NTH_ASM_T 4 discard_tac THEN all_var_elim_asm_tac1);
a(once_rewrite_tac[plus_comm_thm]);
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN PC_T1 "lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €elems_nth_thm› = save_thm ( "elems_nth_thm", (
set_goal([], ¨µlist∑ 
	Elems list = {x | ∂i∑ i < #list ± Nth list (i+1) = x}Æ);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨xÆ, ¨xÆ));
a(list_induction_tac ¨listÆ
	THEN MERGE_PCS_T1 ["sets_ext1", "basic_hol"]
		asm_rewrite_tac[elems_def, nth_def, length_def]);
a(REPEAT µ_tac);
a(cases_tac¨x' = xÆ THEN asm_rewrite_tac[]
	THEN1 (∂_tac¨0Æ THEN asm_rewrite_tac[]));
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(∂_tac¨i+1Æ THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a(all_var_elim_asm_tac1 THEN all_fc_tac[nth_ç_elems_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €distinct_nth_thm› = save_thm ( "distinct_nth_thm", (
set_goal([], ¨µlist i j∑ 
	list ç Distinct
±	i < #list ± j < #list
±	Nth list (i+1) = Nth list (j+1)
¥	i = jÆ);
a(µ_tac);
a(list_induction_tac ¨listÆ
	THEN asm_rewrite_tac[length_def, nth_def, distinct_def]);
a(REPEAT µ_tac);
a(cases_tac¨i = 0Æ THEN cases_tac¨j = 0Æ
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(i_contr_tac THEN swap_nth_asm_concl_tac 3);
a(LEMMA_T ¨1 º jÆ (strip_asm_tac o once_rewrite_rule[plus_comm_thm]
		o rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 4 discard_tac THEN all_var_elim_asm_tac1);
a(bc_thm_tac nth_ç_elems_thm THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_T ¨1 º iÆ (strip_asm_tac o once_rewrite_rule[plus_comm_thm]
		o rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 4 discard_tac THEN all_var_elim_asm_tac1);
a(bc_thm_tac nth_ç_elems_thm THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(LEMMA_T ¨1 º i ± 1 º jÆ (strip_asm_tac o once_rewrite_rule[plus_comm_thm]
		o rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [8, 9] discard_tac THEN all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [6] (ALL_FC_T rewrite_tac));
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €bijection_finite_size_thm› = save_thm ( "bijection_finite_size_thm", (
set_goal([], ¨µa b f∑
	 a ç Finite
±	(µx y∑x ç a ± y ç a ± f x = f y ¥ x = y)
±	b = {z | ∂x∑x ç a ± z = f x}
¥	b ç Finite ± #b = #aÆ);
a(rewrite_tac[list_finite_size_thm] THEN REPEAT strip_tac);
a(all_fc_tac[finite_distinct_elems_thm]);
a(all_fc_tac[distinct_size_length_thm]);
a(all_var_elim_asm_tac1 THEN ∂_tac ¨Map f listÆ);
a(asm_rewrite_tac[length_map_thm, elems_map_thm]
	THEN REPEAT strip_tac);
a(bc_thm_tac map_distinct_thm);
a(REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [6] all_fc_tac);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €bijection_finite_size_thm1› = save_thm ( "bijection_finite_size_thm1", (
set_goal([], ¨µa b f∑
	 a ç Finite
±	(µx y∑x ç b ± y ç b ± f x = f y ¥ x = y)
±	a = {z | ∂x∑x ç b ± z = f x}
¥	b ç Finite ± #b = #aÆ);
a(REPEAT µ_tac THEN ¥_tac THEN bc_thm_tac bijection_finite_size_thm);
a(∂_tac¨Ãz∑≈x∑x ç b ± f x = zÆ THEN rewrite_tac[]
	THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1 THEN all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN all_≈_tac
	THEN_TRY SOLVED_T (asm_prove_tac[]));
a(LIST_DROP_NTH_ASM_T[7] (ALL_FC_T rewrite_tac));
a(STRIP_T rewrite_thm_tac);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(∂_tac¨f xÆ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN1 asm_prove_tac[]);
(* *** Goal "2" *** *)
a(all_≈_tac THEN1 asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T[4] (ALL_FC_T rewrite_tac));
(* *** Goal "3" *** *)
a(all_var_elim_asm_tac1 THEN all_var_elim_asm_tac1);
a(all_≈_tac THEN asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €range_bijection_finite_size_thm› = save_thm ( "range_bijection_finite_size_thm", (
set_goal([], ¨µa m∑
	 a ç Finite ± #a = m
§	∂f∑	(µi j∑i < m ± j < m ± f i = f j ¥ i = j)
	± 	a = {x | ∂i∑i < m ± f i = x}Æ);
a(REPEAT_UNTIL is_± strip_tac THEN strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[list_finite_size_thm]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(∂_tac¨Ãi∑Nth list (i+1)Æ THEN rewrite_tac[]);
a(REPEAT strip_tac THEN1 all_fc_tac[distinct_nth_thm]);
a(rewrite_tac[elems_nth_thm]);
(* *** Goal "2" *** *)
a(strip_tac);
a(once_rewrite_tac[
	eq_sym_rule(±_right_elim(µ_elim¨mÆ range_finite_size_thm))]);
a(bc_thm_tac bijection_finite_size_thm);
a(∂_tac¨fÆ THEN asm_rewrite_tac[range_finite_size_thm]);
a(conv_tac(LEFT_C (ONCE_MAP_C eq_sym_conv)));
a(rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €surjection_finite_size_thm› = save_thm( "surjection_finite_size_thm", (
set_goal([], ¨µa b f∑
	a ç Finite
±	b Ä {z | ∂x∑x ç a ± z = f x}
¥	b ç Finite ± #b º #aÆ);
a(REPEAT µ_tac THEN ¥_tac);
a(lemma_tac¨{z | ∂x∑x ç a ± z = f x} ç Finite ± #{z | ∂x∑x ç a ± z = f x} º #aÆ);
(* *** Goal "1" *** *)
a(POP_ASM_T discard_tac THEN finite_induction_tac¨aÆ);
(* *** Goal "1.1" *** *)
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨{x|F}= {}Æ,
	empty_finite_thm, size_empty_thm]);
(* *** Goal "1.2" *** *)
a(ALL_FC_T rewrite_tac[size_singleton_¿_thm]);
a(cases_tac¨{z|∂ x'∑ x' ç {x} ¿ a ± z = f x'} = 
	{z|∂ x∑ x ç a ± z = f x}Æ
	THEN1 (asm_rewrite_tac[]
		THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(LEMMA_T¨{z|∂ x'∑ x' ç {x} ¿ a ± z = f x'} = 
	{f x} ¿ {z|∂ x∑ x ç a ± z = f x}Æ rewrite_thm_tac
	THEN1 (PC_T1 "sets_ext1" prove_tac[]));
a(CASES_T¨≥f x ç {z|∂ x∑ x ç a ± z = f x}Æ asm_tac
	THEN1 (all_fc_tac[singleton_¿_finite_thm,
		size_singleton_¿_thm]
		THEN asm_rewrite_tac[]));
a(i_contr_tac THEN POP_ASM_T ante_tac THEN POP_ASM_T ante_tac);
a(DROP_ASMS_T discard_tac THEN PC_T1 "sets_ext1" rewrite_tac[]
	THEN_TRY all_var_elim_asm_tac1
	THEN asm_prove_tac[]
	THEN all_var_elim_asm_tac1 THEN asm_prove_tac[]);
(* *** Goal "2" *** *)
a(all_fc_tac[Ä_finite_size_thm] THEN REPEAT strip_tac);
a(PC_T1 "lin_arith" asm_prove_tac[]);
pop_thm()
));
=TEX
%%%%
%%%%
=SML
val €range_finite_size_thm1› = save_thm ( "range_finite_size_thm1", (
set_goal([], ¨µm∑ {i | 1 º i ± i º m} ç Finite ± #{i | 1 º i  ± i º m} = mÆ);
a(µ_tac THEN strip_asm_tac(µ_elim¨m:ÓÆrange_finite_size_thm));
a(POP_ASM_T(fn th => conv_tac(RIGHT_C(RIGHT_C(once_rewrite_conv[eq_sym_rule th])))));
a(bc_thm_tac bijection_finite_size_thm);
a(∂_tac¨Ãk∑k + 1Æ THEN asm_rewrite_tac[]
	THEN PC_T1 "sets_ext" REPEAT strip_tac
	THEN_TRY (all_var_elim_asm_tac1 THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(all_asm_ante_tac THEN rewrite_tac[º_def] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
a(∂_tac¨iÆ THEN PC_T1 "lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €range_bijection_finite_size_thm1› = save_thm ( "range_bijection_finite_size_thm1", (
set_goal([], ¨µa∑
	 a ç Finite
§	∂f∑	(µi j∑i < #a ± j < #a ± f i = f j ¥ i = j)
	± 	a = {x | ∂i∑i < #a ± f i = x}Æ);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) range_bijection_finite_size_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €Ó_exp_def› = get_spec ¨1 ^ 2Æ;
=TEX
%%%%
%%%%
=SML
val €_thm› = save_thm ( "_thm", (
set_goal([], ¨µa∑  a = {b | b Ä a}Æ);
a(REPEAT strip_tac THEN PC_T "sets_ext1" strip_tac);
a(rewrite_tac[_def]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €_split_thm› = save_thm ( "_split_thm", (
set_goal([], ¨µx a∑
	 a = {b | b Ä a ± x ç b} ¿ {b | b Ä a ± ≥x ç b}
±	{b | b Ä a ± x ç b} ° {b | b Ä a ± ≥x ç b} = {}
Æ);
a(rewrite_tac[_thm] THEN PC_T1 "sets_ext1" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €_split_thm1› = save_thm ( "_split_thm1", (
set_goal([], ¨µa b∑ b Ä a ¥
	 a =  b ¿ {c | c Ä a ± ∂x∑ x ç c ± ≥x ç b}
±	 b ° {c | c Ä a ± ∂x∑ x ç c ± ≥x ç b} = {}
Æ);
a(rewrite_tac[_thm] THEN PC_T1 "sets_ext1" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €_finite_size_thm› = save_thm ( "_finite_size_thm", (
set_goal([], ¨µa∑
	 a ç Finite
¥	 a ç Finite ± #( a) = 2 ^ #aÆ);
a(REPEAT µ_tac THEN ¥_tac);
a(rewrite_tac[_thm] THEN finite_induction_tac¨aÆ);
(* *** Goal "1" *** *)
a(LEMMA_T¨{b|b Ä {}} = {{}}Æ rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(rewrite_tac[size_empty_thm, Ó_exp_def,
	size_singleton_thm, singleton_finite_thm]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac[size_singleton_¿_thm]);
a(rewrite_tac[Ó_exp_def]);
a(LEMMA_T¨{b|b Ä {x} ¿ a} =
	{b|b Ä a} ¿ {c|∂b∑b Ä a ± c = {x} ¿ b}Æ
	rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(∂_tac¨x' ° aÆ THEN PC_T1 "sets_ext1" asm_prove_tac[]);
a(spec_nth_asm_tac 3 ¨x''Æ THEN all_var_elim_asm_tac);
(* *** Goal "2.1.2" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2.1.3" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
a(spec_nth_asm_tac 3 ¨x''Æ);
a(spec_nth_asm_tac 5 ¨x''Æ);
(* *** Goal "2.2" *** *)
a(lemma_tac¨
	{c|∂ b∑ b Ä a ± c = {x} ¿ b} ç Finite ±
	#{c|∂ b∑ b Ä a ± c = {x} ¿ b} = #{b|b Ä a}Æ
	THEN1 bc_thm_tac bijection_finite_size_thm);
(* *** Goal "2.2.1" *** *)
a(∂_tac¨Ãb∑{x} ¿ bÆ THEN asm_rewrite_tac[]);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "2.2.1.1" *** *)
a(swap_nth_asm_concl_tac 2 THEN strip_tac);
a(∂_tac¨x''Æ THEN PC_T1 "sets_ext1" asm_rewrite_tac[]);
a(contr_tac THEN all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
(* *** Goal "2.2.1.2" *** *)
a(swap_nth_asm_concl_tac 2 THEN strip_tac);
a(∂_tac¨x''Æ THEN PC_T1 "sets_ext1" asm_rewrite_tac[]);
a(contr_tac THEN all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac);
a(asm_rewrite_tac[¿_finite_thm]);
(* *** Goal "2.2.2" *** *)
a(lemma_tac¨{b|b Ä a} ° {c|∂ b∑ b Ä a ± c = {x} ¿ b} = {}Æ);
(* *** Goal "2.2.2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨xÆ);
a(spec_nth_asm_tac 2 ¨xÆ);
(* *** Goal "2.2.2.2" *** *)
a(ante_tac(list_µ_elim[¨{b|b Ä a}Æ,
	¨{c|∂ b∑ b Ä a ± c = {x} ¿ b}Æ]
	size_¿_thm));
a(asm_rewrite_tac[size_empty_thm]);
a(STRIP_T rewrite_thm_tac);
a(PC_T1 "lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €∏_finite_size_thm› = save_thm ( "∏_finite_size_thm", (
set_goal([], ¨µa b∑
	a ç Finite ± b ç Finite
¥	(a ∏ b) ç Finite ± #(a ∏ b) = #a * #b
Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(finite_induction_tac¨aÆ);
(* *** Goal "1" *** *)
a(LEMMA_T ¨({} ∏ b) = {}Æ
	(fn th => rewrite_tac[th, empty_finite_thm, size_empty_thm]));
a(PC_T1 "sets_ext1" prove_tac[∏_def]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨({x} ¿ a ∏ b) = ({x} ∏ b) ¿ (a ∏ b)Æ
	(fn th => asm_rewrite_tac[th, ¿_finite_thm])
	THEN1 PC_T1 "sets_ext1" prove_tac[∏_def]);
a(lemma_tac¨({x} ∏ b) ° (a ∏ b) = {}Æ
	THEN1 (PC_T1 "sets_ext1" asm_prove_tac[∏_def]
		THEN contr_tac THEN all_var_elim_asm_tac1));
a(lemma_tac¨({x} ∏ b) ç Finite ± #({x} ∏ b) = #bÆ);
(* *** Goal "2.1" *** *)
a(bc_thm_tac bijection_finite_size_thm);
a(∂_tac¨Ãy∑ (x, y)Æ THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" rewrite_tac[∏_def]);
a(rewrite_tac[]);
a(contr_tac THEN_TRY all_var_elim_asm_tac);
a(spec_nth_asm_tac 1 ¨x2Æ);
(* *** Goal "2.2" *** *)
a(REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[size_singleton_¿_thm]);
a(ante_tac(list_µ_elim[¨{x} ∏ bÆ, ¨a ∏ bÆ] size_¿_thm));
a(asm_rewrite_tac[size_empty_thm, times_plus_distrib_thm]);
a(PC_T1 "lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ind_sum_size_thm› = save_thm ( "ind_sum_size_thm", (
set_goal([], ¨µA∑
	A ç Finite
¥	ì A (Ãx∑ÓØ 1) = ÓØ (#A)Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨AÆ
	THEN1 rewrite_tac[ind_sum_def, size_empty_thm]);
a(ALL_FC_T rewrite_tac[ind_sum_def, size_singleton_¿_thm]);
a(asm_rewrite_tac[ÓØ_plus_homomorphism_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ind_sum_plus_thm› = save_thm ( "ind_sum_plus_thm", (
set_goal([], ¨µA f g∑
	A ç Finite
¥	ì A (Ãx∑f x + g x) = ì A f + ì A gÆ);
a(REPEAT strip_tac);
a(finite_induction_tac¨AÆ
	THEN1 rewrite_tac[ind_sum_def]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ind_sum_minus_thm› = save_thm ( "ind_sum_minus_thm", (
set_goal([], ¨µA f∑
	A ç Finite
¥	ì A (Ãx∑~(f x)) = ~(ì A f)Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨AÆ
	THEN1 rewrite_tac[ind_sum_def]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ind_sum_const_times_thm› = save_thm ( "ind_sum_const_times_thm", (
set_goal([], ¨µA f c∑
	A ç Finite
¥	ì A (Ãx∑c*(f x)) = c*(ì A f)Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨AÆ
	THEN1 rewrite_tac[ind_sum_def]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ind_sum_0_thm› = save_thm ( "ind_sum_0_thm", (
set_goal([], ¨µA f∑
	A ç Finite
¥	ì A  (Ã x∑ ÓØ 0) = ÓØ 0Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨AÆ
	THEN1 rewrite_tac[ind_sum_def]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ind_sum_diff_0_thm› = save_thm ( "ind_sum_diff_0_thm", (
set_goal([], ¨µA f g∑
	A ç Finite
±	ì A (Ãx∑f x - g x) = ÓØ 0
¥	ì A f = ì A gÆ);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(LEMMA_T ¨f = Ãx∑(Ãx∑ f x + ~(g x)) x + g xÆ pure_once_rewrite_thm_tac
	THEN1 rewrite_tac[Ø_plus_assoc_thm]);
a(ALL_FC_T pure_rewrite_tac[ind_sum_plus_thm]);
a(asm_rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ind_sum_local_thm› = save_thm ( "ind_sum_local_thm", (
set_goal([], ¨µA f g∑
	A ç Finite
± 	(µx∑x ç A ¥ f x = g x)
¥	ì A f = ì A gÆ);
a(REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN intro_µ_tac(¨fÆ, ¨fÆ));
a(finite_induction_tac¨AÆ
	THEN1 rewrite_tac[ind_sum_def]);
a(REPEAT strip_tac);
a(lemma_tac¨µ x∑ x ç A ¥ f x = g xÆ
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
a(ALL_ASM_FC_T rewrite_tac[ind_sum_def]);
a(spec_nth_asm_tac 2 ¨xÆ);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ind_sum_0_bc_thm› = save_thm ( "ind_sum_0_bc_thm", (
set_goal([], ¨µA f∑
	A ç Finite
±	(µx∑x ç A ¥ f x = ÓØ 0)
¥	ì A f = ÓØ 0Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨ì A (ÃJ∑ ÓØ 0) = ÓØ 0Æ
	(pure_once_rewrite_thm_tac o eq_sym_rule)
	THEN1 (bc_thm_tac ind_sum_0_thm
		THEN REPEAT strip_tac));
a(bc_thm_tac ind_sum_local_thm);
a(asm_rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €bijection_ind_sum_thm› = save_thm ( "bijection_ind_sum_thm", (
set_goal([], ¨µA f b∑
	 A ç Finite
±	(µx y∑x ç A ± y ç A ± b x = b y ¥ x = y)
¥	ì {z | ∂x∑x ç A ± z = b x} f = ì A (Ãx∑f(b x))Æ);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(intro_µ_tac(¨bÆ, ¨bÆ) THEN finite_induction_tac¨AÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[ind_sum_def,
	pc_rule1"sets_ext1" prove_rule[]¨{x|F} = {}Æ]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(lemma_tac¨µ x y∑ x ç A ± y ç A ± b x = b y ¥ x = yÆ
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
a(lemma_tac¨∂B∑ B = {z|∂ x'∑ x' ç A ± z = b x'}Æ
	THEN1 prove_∂_tac);
a(all_fc_tac[bijection_finite_size_thm]);
a(all_var_elim_asm_tac1);
a(PC_T1 "predicates" lemma_tac¨
	≥b x ç {z|∂ x'∑ x' ç A ± z = b x'} ±
	{z|∂ x'∑ x' ç {x} ¿ A ± z = b x'} =
	{b x} ¿ {z|∂ x'∑ x' ç A ± z = b x'}Æ
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(cases_tac¨x' = xÆ THEN1 asm_rewrite_tac[]);
a(swap_nth_asm_concl_tac 1 THEN DROP_NTH_ASM_T 6 bc_thm_tac);
a(PC_T1 "sets_ext1" asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(DROP_ASMS_T discard_tac THEN PC_T1 "sets_ext1" rewrite_tac[]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "2.2.1" *** *)
a(∂_tac¨x''Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.3" *** *)
a(∂_tac¨x''Æ THEN REPEAT strip_tac);
(* *** Goal "2.3" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(ALL_FC_T rewrite_tac[ind_sum_def]);
a(LIST_DROP_NTH_ASM_T [7] all_fc_tac);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ind_sum_—_singleton_thm› = save_thm ( "ind_sum_—_singleton_thm", (
set_goal([], ¨µA x∑
	A ç Finite
¥	ì A (—{x}) =
	if x ç A then ÓØ 1 else ÓØ 0Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨AÆ
	THEN1 rewrite_tac[ind_sum_def]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
a(PC_T1 "sets_ext1" asm_rewrite_tac[—_def]);
a(cases_tac¨x' = xÆ THEN1 all_var_elim_asm_tac
	THEN asm_rewrite_tac[]);
a(POP_ASM_T (rewrite_thm_tac o conv_rule(RAND_C eq_sym_conv)));
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ind_sum_singleton_thm› = save_thm ( "ind_sum_singleton_thm", (
set_goal([], ¨µx f∑
	ì {x} f = f xÆ);
a(REPEAT strip_tac);
a(pure_once_rewrite_tac[prove_rule [] ¨{x} = {x} ¿ {}Æ]);
a(lemma_tac¨{} ç FiniteÆ THEN1 rewrite_tac[empty_finite_thm]);
a(LEMMA_T¨≥x ç {}Æ asm_tac THEN1 rewrite_tac[]);
a(ALL_FC_T pure_rewrite_tac[ind_sum_def]);
a(rewrite_tac[ind_sum_def]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €fin_supp_induction_thm1› = save_thm ( "fin_supp_induction_thm1", (
set_goal([], ¨µp∑
	(µx∑p(—{x}))
±	(µf c∑	{x | ≥f x = ÓØ 0} ç Finite
	±	p f
	¥	p (Ãx∑c*(f x)))
±	(µf g∑	{x | ≥f x = ÓØ 0} ç Finite
	±	{x | ≥g x = ÓØ 0} ç Finite
	±	p f ± p g
	¥	p (Ãx∑f x + g x))
¥	(µf∑	{x | ≥f x = ÓØ 0} ç Finite
	¥	p f)
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂A∑ A = {x|≥ f x = ÓØ 0}Æ
	THEN1 prove_∂_tac);
a(lemma_tac¨A ç FiniteÆ
	THEN1 asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 3 discard_tac);
a(DROP_NTH_ASM_T 2 ante_tac);
a(intro_µ_tac(¨fÆ, ¨fÆ) THEN finite_induction_tac ¨AÆ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T¨f = Ãx∑ÓØ 0 * (—{a} x)Æ pure_rewrite_thm_tac);
(* *** Goal "1.1" *** *)
a(rewrite_tac[] THEN POP_ASM_T ante_tac);
a(PC_T1 "sets_ext" rewrite_tac[] THEN rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN POP_ASM_T discard_tac
	THEN asm_rewrite_tac[]);
a(LEMMA_T ¨{x|≥ — {a} x = ÓØ 0} = {a}Æ
	(fn th => rewrite_tac[th, singleton_finite_thm]));
a(PC_T1 "sets_ext1" rewrite_tac[—_def] THEN strip_tac);
a(cases_tac¨x = aÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨f = Ãx∑
	(Ãz∑if z ç A then f z else ÓØ 0) x +
	(Ãz∑if z ç A then ÓØ 0 else f z) xÆ
	pure_once_rewrite_thm_tac
	THEN1 (rewrite_tac[] THEN REPEAT strip_tac
		THEN cases_tac¨x' ç AÆ
		THEN asm_rewrite_tac[]));
a(DROP_NTH_ASM_T 5 bc_thm_tac);
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨AÆ
	THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨{x}Æ
	THEN PC_T1 "sets_ext1" rewrite_tac[singleton_finite_thm]
	THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN
	cases_tac¨x' ç AÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 2 ante_tac);
a(PC_T1 "sets_ext1" rewrite_tac[] THEN REPEAT strip_tac);
a(spec_nth_asm_tac 2 ¨x'Æ);
(* *** Goal "2.3" *** *)
a(DROP_NTH_ASM_T 3 bc_thm_tac);
a(PC_T1 "sets_ext1" rewrite_tac[] THEN REPEAT µ_tac);
a(cases_tac¨x' ç AÆ THEN asm_rewrite_tac[]);
a(LIST_DROP_NTH_ASM_T [2] (PC_T1 "sets_ext" all_fc_tac));
(* *** Goal "2.4" *** *)
a(LEMMA_T¨(Ã z∑ if z ç A then ÓØ 0 else f z) =
	(Ãz∑f x * —{x} z)Æ
	rewrite_thm_tac);
(* *** Goal "2.4.1" *** *)
a(rewrite_tac[—_def] THEN REPEAT strip_tac);
a(cases_tac¨x' = xÆ
	THEN1 all_var_elim_asm_tac1 THEN asm_rewrite_tac[]);
a(cases_tac¨x' ç AÆ THEN asm_rewrite_tac[]);
a(contr_tac THEN LEMMA_T¨x' ç {x} ¿ AÆ ante_tac
	THEN1 asm_rewrite_tac[]);
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2.4.2" *** *)
a(DROP_NTH_ASM_T 5 bc_thm_tac THEN asm_rewrite_tac[]);
a(LEMMA_T ¨{x'|≥ — {x} x' = ÓØ 0} = {x}Æ
	(fn th => rewrite_tac[th, singleton_finite_thm]));
a(PC_T1 "sets_ext" rewrite_tac[—_def] THEN µ_tac);
a(cases_tac¨x' = xÆ THEN asm_rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €fin_supp_induction_thm› = save_thm ( "fin_supp_induction_thm", (
set_goal([], ¨µp∑
	(µx∑p(—{x}))
±	(µf c∑	Supp f ç Finite
	±	p f
	¥	p (Ãx∑c*(f x)))
±	(µf g∑	Supp f ç Finite
	±	Supp g ç Finite
	±	p f ± p g
	¥	p (Ãx∑f x + g x))
¥	(µf∑	Supp f ç Finite
	¥	p f)
Æ);
a(rewrite_tac[supp_def, fin_supp_induction_thm1]);
pop_thm()
));

=TEX
=SML
val €supp_clauses› = save_thm ( "supp_clauses", (
set_goal([], ¨
	Supp (Ãx:'a∑ ÓØ 0) = {}
±	(µf:'a ≠ Ø∑ Supp (Ãx∑~(f x)) = Supp f)
±	(µf g:'a ≠ Ø∑ Supp (Ãx∑ f x + g x) Ä Supp f ¿ Supp g)
±	(µc:Ø; f:'a ≠ Ø∑ Supp (Ãx∑ c*f x) Ä Supp f)
Æ);
a(PC_T1 "sets_ext1" rewrite_tac[supp_def] THEN REPEAT strip_tac
	THEN_TRY PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA∑ ﬁ{A} = AÆ);
a(PC_T "sets_ext1" contr_tac THEN1 all_asm_fc_tac[]);
a(spec_nth_asm_tac 1 ¨AÆ THEN all_var_elim_asm_tac1);
val ﬁ_singleton_thm = pop_thm ();
=TEX
%%%%
%%%%
=SML
val €ind_sum_¿_thm› = save_thm ( "ind_sum_¿_thm", (
set_goal([], ¨µA B f∑
	A ç Finite
±	B ç Finite
¥	ì (A ¿ B) f =
	ì A f + ì B f - ì (A ° B) f
Æ);
a(REPEAT strip_tac);
a(finite_induction_tac ¨AÆ THEN1 rewrite_tac[ind_sum_def]);
a(lemma_tac¨A ¿ B ç Finite ± A ° B ç FiniteÆ
	THEN1 (asm_rewrite_tac[¿_finite_thm]
		THEN ALL_FC_T rewrite_tac[°_finite_thm]));
a(cases_tac¨{x} Ä BÆ);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[pc_rule1 "sets_ext1" prove_rule[]
	¨µa b c∑ a Ä c ¥ 
		(a ¿ b) ¿ c = b ¿ c
	±	(a ¿ b) ° c = a ¿ (b ° c)Æ]);
a(LEMMA_T¨≥x ç A ° BÆ asm_tac THEN1 REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[ind_sum_def]);
a(DROP_NTH_ASM_T 6 ante_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T (PC_T1 "sets_ext" strip_asm_tac)
	THEN all_var_elim_asm_tac);
a(ALL_FC_T rewrite_tac[pc_rule1 "sets_ext1" prove_rule[]
	¨µa b c∑ ≥x ç c ¥ 
		(a ¿ b) ¿ c = a ¿ b ¿ c
	±	({x} ¿ b) ° c = (b ° c)Æ]);
a(LEMMA_T¨≥x ç A ¿ BÆ asm_tac THEN1 REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[ind_sum_def]);
a(DROP_NTH_ASM_T 6 ante_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ind_sum__thm› = save_thm ( "ind_sum__thm", (
set_goal([], ¨µK∑
	K ç Finite ± ≥K = {}
¥	ì (K) (ÃJ∑ ~(ÓØ 1) ^ #J) = ÓØ 0Æ);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(LEMMA_T¨K ç FiniteÆ ante_tac THEN1
	all_fc_tac[_finite_size_thm]);
a(strip_asm_tac (list_µ_elim[¨xÆ, ¨KÆ]_split_thm));
a(DROP_NTH_ASM_T 2 rewrite_thm_tac);
a(rewrite_tac[¿_finite_thm] THEN strip_tac);
a(ALL_FC_T asm_rewrite_tac[ind_sum_¿_thm]);
a(rewrite_tac[ind_sum_def]);
a(lemma_tac¨∂g∑µJ∑g J = J \ {x}Æ THEN1 prove_∂_tac);
a(lemma_tac¨ µ X Y∑ X ç {b|b Ä K ± x ç b}
	± Y ç {b|b Ä K ± x ç b}
	± g X = g Y ¥ X = YÆ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[] THEN DROP_ASMS_T discard_tac
	THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(cases_tac¨x' = xÆ THEN1 asm_rewrite_tac[]);
a(spec_nth_asm_tac 3 ¨x'Æ);
(* *** Goal "1.2" *** *)
a(cases_tac¨x' = xÆ THEN1 asm_rewrite_tac[]);
a(spec_nth_asm_tac 3 ¨x'Æ);
(* *** Goal "2" *** *)
a(ante_tac(list_µ_elim[	¨{b|b Ä K ± x ç b}Æ,
		¨Ã J: 'a SET∑ ~ (ÓØ 1) ^ # JÆ,
		¨gÆ] bijection_ind_sum_thm));
a(asm_rewrite_tac[¿_finite_thm, singleton_finite_thm]);
a(LEMMA_T ¨
	{z|∂ x'∑ (x' Ä K ± x ç x') ± z = x' \ {x}} =
	{b|b Ä K ± ≥x ç b}Æ rewrite_thm_tac);
(* *** Goal ".1" *** *)
a(DROP_ASM_T ¨x ç KÆ ante_tac
	THEN DROP_ASMS_T discard_tac
	THEN PC_T1 "sets_ext1" rewrite_tac[]
	THEN REPEAT strip_tac
	THEN_TRY SOLVED_T (asm_prove_tac[]));
a(∂_tac¨{x} ¿ x'Æ THEN PC_T1 "sets_ext1" asm_prove_tac[]);
a(contr_tac THEN all_var_elim_asm_tac);
(* *** Goal "2.2" *** *)
a(STRIP_T rewrite_thm_tac THEN rename_tac[]);
a(LEMMA_T¨
	ì {b|b Ä K ± x ç b} (Ã x'∑ ~ (ÓØ 1) ^ # (x' \ {x})) =
	ì {b|b Ä K ± x ç b} (ÃK∑~((Ã J∑ ~ (ÓØ 1) ^ # J) K))Æ
	pure_rewrite_thm_tac);
(* *** Goal "2.2.1" *** *)
a(bc_thm_tac ind_sum_local_thm THEN REPEAT strip_tac);
a(LEMMA_T ¨#x' = #(x' \{x}) + 1Æ
	(fn th => rewrite_tac[th, Ø_Ó_exp_def]
		THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(LEMMA_T¨x' = {x} ¿ (x' \ {x})Æ
	(fn th => conv_tac (LEFT_C(once_rewrite_conv[th])))
	THEN1 (POP_ASM_T ante_tac THEN PC_T1 "sets_ext" prove_tac[]));
a(LEMMA_T¨≥x ç x' \ {x}Æ asm_tac
	THEN1 PC_T1 "sets_ext" prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
a(lemma_tac¨x' \ {x} Ä x'Æ 
	THEN1 PC_T1 "sets_ext" prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
a(all_fc_tac[size_singleton_¿_thm]);
(* *** Goal "2.2.2" *** *)
a(ALL_FC_T rewrite_tac[ind_sum_minus_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ind_ﬁ_finite_thm› = save_thm ( "ind_ﬁ_finite_thm", (
set_goal([], ¨µI U A f∑
	I ç Finite
±	(µi∑ i ç I ¥ U i ç Finite)
±	A = ﬁ{B | ∂i∑ i ç I ± B = U i}
¥	A ç FiniteÆ);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac);
a(finite_induction_tac¨IÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[pc_rule1"sets_ext1" prove_rule[]¨ﬁ{B|F} = {}Æ]);
a(REPEAT strip_tac THEN asm_rewrite_tac[empty_finite_thm]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(REPEAT strip_tac);
a(LEMMA_T ¨{B|∂ i∑ i ç {x} ¿ I ± B = U i} =
	{B|∂ i∑ i ç I ± B = U i} ¿ {U x}Æ rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(asm_rewrite_tac[pc_rule1"sets_ext1" prove_rule[]
	¨µV W∑ﬁ(V ¿ W) = ﬁV ¿ ﬁWÆ,
	ﬁ_singleton_thm,
	¿_finite_thm]);
a(POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
set_goal([], ¨µI U A x∑
	I ç Finite ± ≥I = {}
±	(µi∑ i ç I ¥ U i ç Finite)
±	A = ﬁ{B | ∂i∑ i ç I ± B = U i}
¥	ì
	(I)
	(ÃJ∑ ~(ÓØ 1) ^ #J * ì (A ° •{B | ∂j∑ j ç J ± B = U j}) (—{x}))
	= ÓØ 0Æ);
a(REPEAT strip_tac);
a(all_fc_tac[ind_ﬁ_finite_thm]);
a(lemma_tac¨I ç FiniteÆ
	THEN1 all_fc_tac[ _finite_size_thm ]);
a(cases_tac¨≥x ç AÆ);
(* *** Goal "1" *** *)
a(bc_thm_tac ind_sum_0_bc_thm);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(LEMMA_T¨ì (A ° • {B|∂ j∑ j ç x' ± B = U j}) (— {x}) = ÓØ 0Æ
	rewrite_thm_tac);
a(bc_thm_tac ind_sum_0_bc_thm);
a(ALL_FC_T rewrite_tac[°_finite_thm]);
a(REPEAT strip_tac THEN rewrite_tac[—_def]);
a(cases_tac¨x'' = xÆ THEN asm_rewrite_tac[]
	THEN1 all_var_elim_asm_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 (strip_asm_tac o eq_sym_rule));
a(lemma_tac ¨x ç ﬁ {B|∂ i∑ i ç I ± B = U i}Æ
	THEN1 asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a(var_elim_nth_asm_tac 1);
a(lemma_tac¨≥{j | j ç I ± x ç U j} = {} ±
	{j | j ç I ± x ç U j} Ä IÆ
	THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(GET_ASM_T ¨I ç FiniteÆ ante_tac);
a(ALL_FC_T (MAP_EVERY ante_tac) [_split_thm1]);
a(rewrite_tac[] THEN strip_tac);
a(STRIP_T rewrite_thm_tac);
a(rewrite_tac[¿_finite_thm] THEN REPEAT strip_tac);
a(ALL_FC_T asm_rewrite_tac[ind_sum_¿_thm]);
a(rewrite_tac[ind_sum_def]);
a(bc_thm_tac (pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µx y∑ y = ÓØ 0 ± x = ÓØ 0 ¥ x + y = ÓØ 0Æ)
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac ind_sum_0_bc_thm);
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(LIST_DROP_NTH_ASM_T [3] (PC_T1 "sets_ext" all_fc_tac));
(* *** Goal "2.1.2" *** *)
a(LEMMA_T¨ì (A ° • {B|∂ j∑ j ç x' ± B = U j}) (— {x}) = ÓØ 0Æ
	rewrite_thm_tac);
a(bc_thm_tac ind_sum_0_bc_thm);
a(ALL_FC_T rewrite_tac[°_finite_thm]);
a(REPEAT strip_tac THEN rewrite_tac[—_def]);
a(cases_tac¨x''' = xÆ THEN asm_rewrite_tac[]
	THEN1 all_var_elim_asm_tac);
a(POP_ASM_T (ante_tac o µ_elim¨U x''Æ));
a(asm_rewrite_tac[]);
a(∂_tac¨x''Æ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(lemma_tac¨{j|j ç I ± x ç U j} ç FiniteÆ
	THEN1 all_fc_tac[Ä_finite_thm]);
a(DROP_NTH_ASM_T 14 discard_tac
	THEN all_fc_tac[ind_sum__thm]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(bc_thm_tac ind_sum_local_thm THEN REPEAT strip_tac);
a(LEMMA_T¨ì (A ° • {B|∂ j∑ j ç x' ± B = U j}) (— {x}) = ÓØ 1Æ
	rewrite_thm_tac);
a(lemma_tac¨A ° • {B|∂ j∑ j ç x' ± B = U j} ç FiniteÆ
	THEN1 ALL_FC_T rewrite_tac[°_finite_thm]);
a(ALL_FC_T rewrite_tac[ind_sum_—_singleton_thm]);
a(LEMMA_T ¨x ç A ° • {B|∂ j∑ j ç x' ± B = U j}Æ
	rewrite_thm_tac);
a(rename_tac[(¨x'Æ, "J")] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [3] (PC_T1 "sets_ext" all_fc_tac));
val €ind_sum_inc_exc_lemma1› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µI U A f c∑
	I ç Finite ± ≥I = {}
±	(µi∑ i ç I ¥ U i ç Finite)
±	A = ﬁ{B | ∂i∑ i ç I ± B = U i}
±	ì
	(I)
	(ÃJ∑ ~(ÓØ 1) ^ #J * ì (A ° •{B | ∂j∑ j ç J ± B = U j}) f) = ÓØ 0
¥	ì
	(I)
	(ÃJ∑ ~(ÓØ 1) ^ #J * ì (A ° •{B | ∂j∑ j ç J ± B = U j}) (Ãx∑c*f x)) = ÓØ 0
Æ);
a(REPEAT strip_tac);
a(all_fc_tac[ind_ﬁ_finite_thm]);
a(lemma_tac¨I ç FiniteÆ
	THEN1 all_fc_tac[ _finite_size_thm ]);
a(LEMMA_T ¨ì ( I)
	(Ã J∑ ~ (ÓØ 1) ^ # J * ì (A ° • {B|∂ j∑ j ç J ± B = U j}) (Ã x∑ c * f x)) =
	c * ì ( I) (Ã J∑ ~ (ÓØ 1) ^ # J * ì (A ° • {B|∂ j∑ j ç J ± B = U j}) f)Æ
	asm_rewrite_thm_tac);
a(ALL_FC_T rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv)
	ind_sum_const_times_thm]);
a(bc_thm_tac ind_sum_local_thm);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(lemma_tac¨(A ° • {B|∂ j∑ j ç x ± B = U j}) ç FiniteÆ
	THEN1 ALL_FC_T rewrite_tac[°_finite_thm]);
a(ALL_FC_T rewrite_tac[ind_sum_const_times_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €ind_sum_inc_exc_lemma2› = pop_thm ();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µI U A f g∑
	I ç Finite ± ≥I = {}
±	(µi∑ i ç I ¥ U i ç Finite)
±	A = ﬁ{B | ∂i∑ i ç I ± B = U i}
±	ì
	(I)
	(ÃJ∑ ~(ÓØ 1) ^ #J * ì (A ° •{B | ∂j∑ j ç J ± B = U j}) f) = ÓØ 0
±	ì
	(I)
	(ÃJ∑ ~(ÓØ 1) ^ #J * ì (A ° •{B | ∂j∑ j ç J ± B = U j}) g) = ÓØ 0
¥	ì
	(I)
	(ÃJ∑ ~(ÓØ 1) ^ #J * ì (A ° •{B | ∂j∑ j ç J ± B = U j}) (Ãx∑f x + g x)) = ÓØ 0
Æ);
a(REPEAT strip_tac);
a(all_fc_tac[ind_ﬁ_finite_thm]);
a(lemma_tac¨I ç FiniteÆ
	THEN1 all_fc_tac[ _finite_size_thm ]);
a(LEMMA_T ¨ì ( I)
	(Ã J∑ ~ (ÓØ 1) ^ # J * ì (A ° • {B|∂ j∑ j ç J ± B = U j}) (Ã x∑ f x + g x)) =
	ì ( I) (Ã J∑ ~ (ÓØ 1) ^ # J * ì (A ° • {B|∂ j∑ j ç J ± B = U j}) f) + 
	ì ( I) (Ã J∑ ~ (ÓØ 1) ^ # J * ì (A ° • {B|∂ j∑ j ç J ± B = U j}) g)Æ
	asm_rewrite_thm_tac);
a(ALL_FC_T rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv)
	ind_sum_plus_thm]);
a(bc_thm_tac ind_sum_local_thm);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(lemma_tac¨(A ° • {B|∂ j∑ j ç x ± B = U j}) ç FiniteÆ
	THEN1 ALL_FC_T rewrite_tac[°_finite_thm]);
a(ALL_FC_T rewrite_tac[ind_sum_plus_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €ind_sum_inc_exc_lemma3› = pop_thm ();
=TEX
%%%%
%%%%
=SML
val €ind_sum_inc_exc_sym_thm› = save_thm ( "ind_sum_inc_exc_sym_thm", (
set_goal([], ¨µI U A f∑
	I ç Finite ± ≥I = {}
±	(µi∑ i ç I ¥ U i ç Finite)
±	A = ﬁ{B | ∂i∑ i ç I ± B = U i}
¥	ì
	(I)
	(ÃJ∑ ~(ÓØ 1) ^ #J * ì (A ° •{B | ∂j∑ j ç J ± B = U j}) f) = ÓØ 0
Æ);
a(REPEAT strip_tac);
a(ante_tac(µ_elim¨Ãf∑ì (I)
	(ÃJ∑ ~(ÓØ 1) ^ #J * ì (A ° •{B | ∂j∑ j ç J ± B = U j}) f) = ÓØ 0Æ
	fin_supp_induction_thm1));
a(rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(swap_nth_asm_concl_tac 1);
a(ALL_FC_T rewrite_tac[ind_sum_inc_exc_lemma1]);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(ALL_FC_T rewrite_tac[ind_sum_inc_exc_lemma2]);
(* *** Goal "3" *** *)
a(swap_nth_asm_concl_tac 1);
a(ALL_FC_T rewrite_tac[ind_sum_inc_exc_lemma3]);
(* *** Goal "4" *** *)
a(LEMMA_T ¨
	ì ( I) (Ã J∑ ~ (ÓØ 1) ^ # J * ì (A ° • {B|∂ j∑ j ç J ± B = U j})
	(Ãx∑if x ç A then f x else ÓØ 0)) = ÓØ 0Æ
	(once_rewrite_thm_tac o eq_sym_rule));
(* *** Goal "4.1" *** *)
a(POP_ASM_T bc_thm_tac);
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨AÆ);
a(all_fc_tac[ind_ﬁ_finite_thm]);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "4.2" *** *)
a(lemma_tac¨I ç FiniteÆ
	THEN1 all_fc_tac[ _finite_size_thm ]);
a(all_fc_tac[ind_ﬁ_finite_thm]);
a(bc_thm_tac ind_sum_local_thm THEN REPEAT strip_tac
	THEN rewrite_tac[]);
a(LEMMA_T¨ì (A ° • {B|∂ j∑ j ç x ± B = U j}) f =
	ì (A ° • {B|∂ j∑ j ç x ± B = U j})
	(Ã x∑ if x ç A then f x else ÓØ 0)Æ
	rewrite_thm_tac);
a(bc_thm_tac ind_sum_local_thm);
a(all_fc_tac[ind_ﬁ_finite_thm]);
a(ALL_FC_T rewrite_tac[°_finite_thm]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ind_sum_inc_exc_thm› = save_thm ( "ind_sum_inc_exc_thm", (
set_goal([], ¨µI U A f∑
	I ç Finite ± ≥I = {}
±	(µi∑ i ç I ¥ U i ç Finite)
±	A = ﬁ{B | ∂i∑ i ç I ± B = U i}
¥	ì A f =
	ì
	(I \ {{}})
	(ÃJ∑ ~(ÓØ 1) ^ (#J + 1) * ì (•{B | ∂j∑ j ç J ± B = U j}) f)
Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨A ç FiniteÆ
	THEN all_fc_tac[ind_ﬁ_finite_thm]);
a(lemma_tac¨I ç FiniteÆ
	THEN1 all_fc_tac[ _finite_size_thm ]);
a(lemma_tac¨I \ {{}} ç FiniteÆ
	THEN1 (bc_thm_tac Ä_finite_thm
		THEN ∂_tac¨IÆ THEN REPEAT strip_tac
		THEN PC_T1 "sets_ext" prove_tac[]));
a(LEMMA_T¨(Ã J∑ ~ (ÓØ 1) ^ (# J + 1) * ì (• {B|∂ j∑ j ç J ± B = U j}) f) =
	(Ã J∑ ~(ÓØ 1) * (ÃJ∑ ~ (ÓØ 1) ^ # J * ì (• {B|∂ j∑ j ç J ± B = U j}) f) J)Æ
	pure_rewrite_thm_tac
	THEN1 (rewrite_tac[Ø_Ó_exp_def]
		THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(ALL_FC_T pure_rewrite_tac[ind_sum_const_times_thm]);
a(LEMMA_T ¨ ì ( I \ {{}})
	(Ã J∑ ~ (ÓØ 1) ^ # J * ì (• {B|∂ j∑ j ç J ± B = U j}) f) =
	ì ( I \ {{}})
	(Ã J∑ ~ (ÓØ 1) ^ # J * ì (A ° • {B|∂ j∑ j ç J ± B = U j}) f)Æ
	rewrite_thm_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac ind_sum_local_thm);
a(REPEAT strip_tac THEN rewrite_tac[]);
a(LEMMA_T ¨A ° • {B|∂ j∑ j ç x ± B = U j} =
	• {B|∂ j∑ j ç x ± B = U j}Æ
	rewrite_thm_tac);
a(bc_thm_tac (pc_rule1 "sets_ext1" prove_rule[]
	¨µa b∑b Ä a ¥ a ° b = bÆ));
a(all_var_elim_asm_tac1);
a(PC_T "sets_ext" strip_tac THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (PC_T1 "sets_ext" strip_asm_tac));
a(spec_nth_asm_tac 2 ¨U x''Æ);
(* *** Goal "1.1" *** *)
a(spec_nth_asm_tac 1 ¨x''Æ);
(* *** Goal "1.2" *** *)
a(∂_tac ¨U x''Æ THEN REPEAT strip_tac);
a(∂_tac ¨x''Æ THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [4] (PC_T1 "sets_ext1" all_fc_tac));
(* *** Goal "2" *** *)
a(all_fc_tac[ind_sum_inc_exc_sym_thm]);
a(POP_ASM_T (ante_tac o µ_elim¨fÆ));
a(LEMMA_T¨{} ç IÆ asm_tac THEN1 rewrite_tac[]);
a(ALL_FC_T (fn ths => conv_tac (LEFT_C(once_rewrite_conv ths)))
	[pc_rule1 "sets_ext" prove_rule[]
	¨µa x∑x ç a ¥ a = (a \ {x}) ¿ {x}Æ]);
a(lemma_tac¨{{}} ç FiniteÆ THEN1 rewrite_tac[singleton_finite_thm]);
a(ALL_FC_T rewrite_tac[ind_sum_¿_thm]);
a(rewrite_tac[ind_sum_def,
	ind_sum_singleton_thm,
	size_empty_thm,
	pc_rule1 "sets_ext" prove_rule[]
	¨•{B|F} = Universe ± µa b∑(a \ b) ° b = {}Æ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €size_inc_exc_thm› = save_thm ( "size_inc_exc_thm", (
set_goal([], ¨µI U A∑
	I ç Finite ± ≥I = {}
±	(µi∑ i ç I ¥ U i ç Finite)
±	A = ﬁ{B | ∂i∑ i ç I ± B = U i}
¥	ÓØ(# A) =
	ì
	(I \ {{}})
	(ÃJ∑ ~(ÓØ 1) ^ (#J + 1) * ÓØ(# (•{B | ∂j∑ j ç J ± B = U j})))
Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨A ç FiniteÆ
	THEN all_fc_tac[ind_ﬁ_finite_thm]);
a(lemma_tac¨I ç FiniteÆ
	THEN1 all_fc_tac[ _finite_size_thm ]);
a(ALL_FC_T rewrite_tac[
	conv_rule(ONCE_MAP_C eq_sym_conv) ind_sum_size_thm]);
a(ALL_FC_T rewrite_tac[ind_sum_inc_exc_thm]);
a(bc_thm_tac ind_sum_local_thm);
a(lemma_tac¨I \ {{}} ç FiniteÆ
	THEN1 (bc_thm_tac Ä_finite_thm
		THEN ∂_tac¨IÆ THEN REPEAT strip_tac
		THEN PC_T1 "sets_ext" prove_tac[]));
a(REPEAT strip_tac THEN rewrite_tac[]);
a(LEMMA_T ¨• {B|∂ j∑ j ç x ± B = U j} =
	A ° • {B|∂ j∑ j ç x ± B = U j}Æ
	once_rewrite_thm_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac (pc_rule1 "sets_ext1" prove_rule[]
	¨µa b∑b Ä a ¥ b = a ° bÆ));
a(all_var_elim_asm_tac1);
a(PC_T "sets_ext" strip_tac THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (PC_T1 "sets_ext" strip_asm_tac));
a(spec_nth_asm_tac 2 ¨U x''Æ);
(* *** Goal "1.1" *** *)
a(spec_nth_asm_tac 1 ¨x''Æ);
(* *** Goal "1.2" *** *)
a(∂_tac ¨U x''Æ THEN REPEAT strip_tac);
a(∂_tac ¨x''Æ THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [4] (PC_T1 "sets_ext1" all_fc_tac));
a(lemma_tac ¨A ° • {B|∂ j∑ j ç x ± B = U j} ç FiniteÆ
	THEN1 ALL_FC_T rewrite_tac[°_finite_thm]);
a(ALL_FC_T rewrite_tac[ind_sum_size_thm]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML
val €supp_—_thm› = save_thm ( "supp_—_thm", (
set_goal([], ¨µA∑
	Supp (— A) = A
Æ);
a(REPEAT strip_tac THEN PC_T1 "sets_ext1" rewrite_tac[supp_def, —_def]
	THEN µ_tac);
a(cases_tac¨x ç AÆ THEN asm_rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML
val €supp_plus_thm› = save_thm ( "supp_plus_thm", (
set_goal([], ¨µf g∑
	Supp (Ãx∑f x + g x) =
	(Supp f ¿ Supp g) \ {x | f x = ~(g x)}
Æ);
a(REPEAT strip_tac THEN PC_T1 "sets_ext1" rewrite_tac[supp_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML
val €ind_sum_supp_thm› = save_thm ( "ind_sum_supp_thm", (
set_goal([], ¨µA f∑
	A ç Finite
¥	ì A f = ì (A ° Supp f) f
Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨AÆ THEN1 rewrite_tac[ind_sum_def]);
a(cases_tac¨x ç Supp fÆ);
(* *** Goal "1" *** *)
a(LEMMA_T ¨({x} ¿ A) ° Supp f = {x} ¿ (A ° Supp f)Æ
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(LEMMA_T ¨≥x ç (A ° Supp f)Æ asm_tac
	THEN1 REPEAT strip_tac);
a(LEMMA_T ¨A ° Supp f ç FiniteÆ asm_tac
	THEN1 (bc_thm_tac Ä_finite_thm
		THEN ∂_tac¨AÆ  THEN REPEAT strip_tac
		THEN PC_T1 "sets_ext1" prove_tac[]));
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
(* *** Goal "2" *** *)
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[supp_def]));
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
a(LEMMA_T ¨({x} ¿ A) ° Supp f = (A ° Supp f)Æ
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML
val €ind_sum_transfer_thm› = save_thm ( "ind_sum_transfer_thm", (
set_goal([], ¨µA B f g h∑
	A ç Finite
±	B ç Finite
±	(µx∑ x ç A ± ≥f x = ÓØ 0 ¥ h x ç B ± f x = g(h x))
±	(µy∑ y ç B ± ≥ g y = ÓØ 0 ¥ ∂â1x∑ x ç A ± h x = y ± f x = g y)
¥	ì A f = ì B g
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µC∑ C ç Finite ¥
	ì {x | x ç A ± ≥f x = ÓØ 0 ± h x ç C} f =
	ì (B ° C) gÆ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(finite_induction_tac¨CÆ);
(* *** Goal "1" *** *)
(* *** Goal "1.1" *** *)
a(rewrite_tac[ind_sum_def, pc_rule1 "sets_ext1" prove_rule[]¨{x|F} = {}Æ]);
(* *** Goal "1.2" *** *)
a(cases_tac¨x ç BÆ);
a(LEMMA_T¨B ° ({x} ¿ C) = {x} ¿ (B ° C)Æ rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(LEMMA_T¨≥x ç (B ° C)Æ asm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(lemma_tac¨B ° C ç FiniteÆ
	THEN1 (bc_thm_tac °_finite_thm THEN REPEAT strip_tac));
a(cases_tac¨g x = ÓØ 0Æ);
(* *** Goal "1.2.1.1" *** *)
a(LEMMA_T¨{x'|x' ç A ± ≥ f x' = ÓØ 0 ± h x' ç {x} ¿ C}
	= {x|x ç A ± ≥ f x = ÓØ 0 ± h x ç C}Æ
	asm_rewrite_thm_tac);
(* *** Goal "1.2.1.1.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [10] all_fc_tac);
a(swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[]);
(* *** Goal "1.2.1.1.2" *** *)
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
(* *** Goal "1.2.1.2" *** *)
a(spec_nth_asm_tac 8 ¨xÆ THEN 
	PC_T "predicates" all_var_elim_asm_tac1);
a(LEMMA_T¨{x''|x'' ç A ± ≥ f x'' = ÓØ 0 ± h x'' ç {h x'} ¿ C}
	= {x'} ¿ {x|x ç A ± ≥ f x = ÓØ 0 ± h x ç C}Æ
	asm_rewrite_thm_tac);
(* *** Goal "1.2.1.2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN_TRY all_var_elim_asm_tac1);
(* *** Goal "1.2.1.2.1.1" *** *)
a(swap_nth_asm_concl_tac 1);
a(spec_nth_asm_tac 16 ¨xÆ);
a(DROP_NTH_ASM_T 7 bc_thm_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.2.1.2.1.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "1.2.1.2.2" *** *)
a(LEMMA_T¨≥x' ç {x|x ç A ± ≥ f x = ÓØ 0 ± h x ç C}Æ
	asm_tac
	THEN1 asm_rewrite_tac[]);
a(lemma_tac¨{x|x ç A ± ≥ f x = ÓØ 0 ± h x ç C} ç FiniteÆ
	THEN1 (bc_thm_tac Ä_finite_thm
		THEN ∂_tac¨AÆ THEN REPEAT strip_tac
		THEN PC_T1 "sets_ext1" prove_tac[]));
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
(* *** Goal "1.2.2" *** *)
a(LEMMA_T¨B ° ({x} ¿ C) = B ° CÆ rewrite_thm_tac
	THEN1 (POP_ASM_T ante_tac THEN PC_T1 "sets_ext1" prove_tac[]));
a(LEMMA_T¨{x'|x' ç A ± ≥ f x' = ÓØ 0 ± h x' ç {x} ¿ C}
	= {x|x ç A ± ≥ f x = ÓØ 0 ± h x ç C}Æ
	asm_rewrite_thm_tac);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(spec_nth_asm_tac 8 ¨x'Æ);
(* *** Goal "2" *** *)
a(POP_ASM_T (ante_tac o µ_elim¨BÆ) THEN asm_rewrite_tac[]);
a(STRIP_T (rewrite_thm_tac o eq_sym_rule));
a(LEMMA_T ¨{x|x ç A ± ≥ f x = ÓØ 0 ± h x ç B} =
	A ° Supp fÆ rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[supp_def]
	THEN PC_T1 "sets_ext1" REPEAT strip_tac
	THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(ALL_FC_T rewrite_tac[ind_sum_supp_thm]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML
val €ind_sum_singleton_∏_thm› = save_thm ( "ind_sum_singleton_∏_thm", (
set_goal([], ¨µx B; f:'a ∏ 'b ≠ Ø∑
	B ç Finite
¥	ì ({x} ∏ B) f = ì B (Ãy∑f(x, y))
Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨BÆ THEN1 rewrite_tac[ind_sum_def, ∏_def,
	pc_rule1 "sets_ext1" prove_rule[]¨{(x, y)|F} = {}Æ]);
a(LEMMA_T¨({x} ∏ ({x'} ¿ B)) = {(x,  x')} ¿ ({x} ∏ B)Ærewrite_thm_tac
	THEN1 MERGE_PCS_T1 ["'bin_rel", "'pair", "sets_ext1"] prove_tac[]);
a(LEMMA_T¨≥(x,  x') ç ({x} ∏ B)Æ asm_tac
	THEN1 MERGE_PCS_T1 ["'bin_rel", "sets_ext1"] prove_tac[]);
a(strip_asm_tac (µ_elim¨xÆ singleton_finite_thm));
a(lemma_tac¨({x} ∏ B) ç FiniteÆ
	THEN1 all_fc_tac[∏_finite_size_thm]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML
val €ind_sum_∏_thm› = save_thm ( "ind_sum_∏_thm", (
set_goal([], ¨µf:'a ∏ 'b ≠ Ø; A B∑
	A ç Finite ± B ç Finite
¥	ì A (Ãx∑ì B (Ãy∑f(x, y))) = ì (A ∏ B) f
Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨AÆ THEN1 rewrite_tac[ind_sum_def, ∏_def,
	pc_rule1 "sets_ext1" prove_rule[]¨{(x, y)|F} = {}Æ]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
a(LEMMA_T¨(({x} ¿ A) ∏ B) = ({x} ∏ B) ¿ (A ∏ B)Ærewrite_thm_tac
	THEN1 MERGE_PCS_T1 ["'bin_rel", "'pair", "sets_ext1"] prove_tac[]);
a(strip_asm_tac (µ_elim¨xÆ singleton_finite_thm));
a(lemma_tac¨({x} ∏ B) ç Finite ± (A ∏ B) ç Finite Æ
	THEN1 ALL_FC_T rewrite_tac[∏_finite_size_thm]);
a(ALL_FC_T rewrite_tac[ind_sum_¿_thm, ind_sum_singleton_∏_thm]);
a(LEMMA_T¨({x} ∏ B) ° (A ∏ B) = {}Ærewrite_thm_tac
	THEN1 (MERGE_PCS_T1 ["'bin_rel", "'pair", "sets_ext1"] rewrite_tac[]
		THEN contr_tac THEN all_var_elim_asm_tac1));
a(rewrite_tac[ind_sum_def]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €binomial_0_clauses› = save_thm ( "binomial_0_clauses", (
set_goal([], ¨µn∑ Binomial n 0 = 1 ±
		Binomial 0 (n+1) = 0Æ);
a(rewrite_tac[binomial_def] THEN REPEAT strip_tac);
a(induction_tac¨nÆ THEN asm_rewrite_tac[binomial_def]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €binomial_less_0_thm› = save_thm ( "binomial_less_0_thm", (
set_goal([], ¨µn m∑ n < m ¥ Binomial n m = 0Æ);
a(µ_tac THEN induction_tac ¨n:ÓÆ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T¨1 º mÆ (strip_asm_tac o 
	once_rewrite_rule[plus_comm_thm] o
	rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN rewrite_tac[binomial_0_clauses]);
(* *** Goal "2" *** *)
a(LEMMA_T¨1 º m'Æ (strip_asm_tac o 
	once_rewrite_rule[plus_comm_thm] o
	rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN rewrite_tac[binomial_def]);
a(REPEAT strip_tac THEN DROP_NTH_ASM_T 2 bc_thm_tac
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €binomial_eq_thm› = save_thm ( "binomial_eq_thm", (
set_goal([], ¨µn∑ Binomial n n = 1Æ);
a(µ_tac THEN induction_tac ¨n:ÓÆ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[binomial_0_clauses]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[binomial_def]);
a(bc_thm_tac binomial_less_0_thm THEN REPEAT strip_tac);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
set_goal([], ¨µA m∑
	A ç Finite
¥	{X | X Ä A ± #X = m} ç Finite
Æ);
a(REPEAT strip_tac THEN bc_thm_tac Ä_finite_thm);
a(∂_tac¨AÆ THEN1 ALL_FC_T rewrite_tac[_finite_size_thm]);
a(PC_T1 "sets_ext"prove_tac[]);
val €combinations_finite_lemma› = pop_thm ();
=TEX
%%%%
%%%%
=SML
val €combinations_finite_size_thm› = save_thm ( "combinations_finite_size_thm", (
set_goal([], ¨µA n m∑
	A ç Finite
±	#A = n
¥	{X | X Ä A ± #X = m} ç Finite
±	#{X | X Ä A ± #X = m} = Binomial n m
Æ);
a(REPEAT strip_tac THEN1 ALL_FC_T rewrite_tac[combinations_finite_lemma]);
a(REPEAT (POP_ASM_T ante_tac));
a(intro_µ_tac(¨AÆ, ¨AÆ) THEN intro_µ_tac(¨mÆ, ¨mÆ) 
	THEN induction_tac¨nÆ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac
	THEN ALL_FC_T1 fc_§_canon rewrite_tac[size_0_thm]
	THEN strip_tac THEN all_var_elim_asm_tac1);
a(strip_asm_tac(µ_elim¨mÆ Ó_cases_thm) THEN all_var_elim_asm_tac1);
(* *** Goal "1.1" *** *)
a(rewrite_tac[binomial_0_clauses]);
a(LEMMA_T ¨{X|X Ä {} ± # X = 0} = {{}}Æ
	(fn th => rewrite_tac[th, size_empty_thm,
		size_singleton_thm, binomial_def]));
a(PC_T "sets_ext" strip_tac THEN REPEAT strip_tac);
(* *** Goal "1.1.1" *** *)
a(swap_nth_asm_concl_tac 2);
a(all_fc_tac[Ä_finite_thm]);
a(ALL_FC_T1 fc_§_canon asm_rewrite_tac[size_0_thm]);
(* *** Goal "1.1.2" *** *)
a(all_var_elim_asm_tac1 THEN REPEAT strip_tac);
(* *** Goal "1.1.3" *** *)
a(asm_rewrite_tac[size_empty_thm]);
(* *** Goal "1.2" *** *)
a(rewrite_tac[binomial_0_clauses]);
a(LEMMA_T ¨{X|X Ä {} ± # X = i + 1} = {}Æ
	(fn th => rewrite_tac[th, size_empty_thm]));
a(LEMMA_T¨µX∑X Ä {} § X = {}Æ rewrite_thm_tac
	THEN1 PC_T1 "sets_ext" prove_tac[]);
a(PC_T "sets_ext" strip_tac THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[size_empty_thm]);
(* *** Goal "2" *** *)
a(strip_asm_tac(µ_elim¨m'Æ Ó_cases_thm) THEN all_var_elim_asm_tac1);
(* *** Goal "2.1" *** *)
a(rewrite_tac[binomial_0_clauses]);
a(LEMMA_T ¨{X|X Ä A ± # X = 0} = {{}}Æ
	(fn th => rewrite_tac[th, size_empty_thm,
		size_singleton_thm, binomial_def]));
a(PC_T "sets_ext" strip_tac THEN REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(swap_nth_asm_concl_tac 2);
a(all_fc_tac[Ä_finite_thm]);
a(ALL_FC_T1 fc_§_canon asm_rewrite_tac[size_0_thm]);
(* *** Goal "2.1.2" *** *)
a(all_var_elim_asm_tac1 THEN REPEAT strip_tac);
(* *** Goal "2.1.3" *** *)
a(asm_rewrite_tac[size_empty_thm]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[binomial_def]);
a(cases_tac¨A = {}Æ
	THEN1 (all_var_elim_asm_tac1 THEN POP_ASM_T ante_tac
		THEN rewrite_tac[size_empty_thm]));
a(POP_ASM_T (PC_T1 "sets_ext1" strip_asm_tac));
a(lemma_tac¨∂B∑B Ä A ± ≥x ç B ± A = {x} ¿ BÆ
	THEN1 (∂_tac¨A \ {x}Æ THEN PC_T1 "sets_ext" asm_prove_tac[]));
a(all_fc_tac[Ä_finite_thm] THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 4 ante_tac);
a(ALL_FC_T rewrite_tac[size_singleton_¿_thm]
	THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [6] all_fc_tac);
a(lemma_tac ¨
	{X|X Ä {x} ¿ B ± # X = i + 1} ç FiniteÆ
	THEN1 (bc_thm_tac combinations_finite_lemma
		THEN strip_tac));
a(lemma_tac ¨
	{X | X Ä B ± # X = i + 1} Ä
	{X|X Ä {x} ¿ B ± # X = i + 1}Æ
	THEN1 PC_T1 "sets_ext" prove_tac[]);
a(ALL_FC_T asm_rewrite_tac[size_Ä_diff_thm]);
a(ante_tac(list_µ_elim[¨{X|X Ä B ± # X = i}Æ,
	¨{X|X Ä {x} ¿ B ± # X = i + 1} \ {X|X Ä B ± # X = i + 1}Æ,
	¨ÃY∑{x} ¿ YÆ] bijection_finite_size_thm));
a(ALL_FC_T asm_rewrite_tac[combinations_finite_lemma]);
a(REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(i_contr_tac THEN LIST_DROP_NTH_ASM_T [1, 2, 4, 6, 12]
	(MAP_EVERY ante_tac) THEN DROP_ASMS_T discard_tac);
a(PC_T1 "sets_ext1" rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.2.1.1" *** *)
a(spec_nth_asm_tac 2 ¨x''Æ THEN all_var_elim_asm_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2.1.2" *** *)
a(spec_nth_asm_tac 2 ¨x''Æ THEN all_var_elim_asm_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2" *** *)
a(i_contr_tac THEN swap_nth_asm_concl_tac 1);
a(LEMMA_T ¨{X|X Ä {x} ¿ B ± # X = i + 1} \
	{X|X Ä B ± # X = i + 1} =
	{X|X Ä {x} ¿ B ± # X = i + 1 ± x ç X}Æ
	rewrite_thm_tac
	THEN1 (DROP_NTH_ASM_T 6 ante_tac
		THEN DROP_ASMS_T discard_tac
		THEN PC_T1 "sets_ext1" prove_tac[]));
(* *** Goal "2.2.2.1" *** *)
a(spec_nth_asm_tac 4 ¨x''Æ THEN all_var_elim_asm_tac);
(* *** Goal "2.2.2.2" *** *)
a(LIST_DROP_NTH_ASM_T [5, 6, 8]
	(MAP_EVERY ante_tac) THEN DROP_ASMS_T discard_tac
	THEN REPEAT strip_tac);
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(∂_tac¨x' \ {x}Æ THEN REPEAT strip_tac
	THEN_TRY SOLVED_T (PC_T1 "sets_ext" asm_prove_tac[]));
a(all_fc_tac[Ä_finite_thm]);
a(lemma_tac¨{x} Ä x'Æ THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(DROP_NTH_ASM_T 4 ante_tac THEN ALL_FC_T rewrite_tac[size_Ä_diff_thm]);
a(rewrite_tac[size_singleton_thm]);
(* *** Goal "2.2.2.2.2" *** *)
a(all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.2.2.2.3" *** *)
a(all_var_elim_asm_tac1);
a(all_fc_tac[Ä_finite_thm]);
a(lemma_tac¨≥x ç x''Æ THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[size_singleton_¿_thm]);
(* *** Goal "2.2.2.2.4" *** *)
a(all_var_elim_asm_tac1 THEN PC_T1 "sets_ext1" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €binomial_thm1› = save_thm ( "binomial_thm1", (
set_goal([], ¨µx n∑
	(ÓØ 1 + x) ^ n =
	Series (Ãm∑ÓØ(Binomial n m) * x ^ m) (n+1)
Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[Ø_Ó_exp_def, series_def, binomial_0_clauses]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[Ø_Ó_exp_def] THEN POP_ASM_T discard_tac);
a(conv_tac (RIGHT_C(once_rewrite_conv[series_induction_thm1])));
a(rewrite_tac[binomial_def, ÓØ_plus_homomorphism_thm,
	Ø_times_plus_distrib_thm]);
a(EXTEND_PC_T1 "'sho_rw" pure_rewrite_tac[plus_series_thm] THEN rewrite_tac[]);
a(bc_thm_tac (pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µx y a b∑x = a ± y = ÓØ 1 + b ¥ y + x = ÓØ 1 + a + bÆ)
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[Ø_Ó_exp_def,
	pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µa b∑a * x * b = x * a * bÆ]);
a(EXTEND_PC_T1 "'sho_rw" pure_rewrite_tac[const_times_series_thm] THEN rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(conv_tac (LEFT_C(rewrite_conv[series_induction_thm1])));
a(rewrite_tac[binomial_0_clauses]);
a(rewrite_tac[series_def]);
a(LEMMA_T ¨Binomial n (n+1) = 0Æ rewrite_thm_tac);
a(bc_thm_tac binomial_less_0_thm THEN rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
For historical reasons, the meat of the following proof deals with $(y+x)^n$ not $(x+y)^n$.

=SML
val €binomial_thm› = save_thm ( "binomial_thm", (
set_goal([], ¨µx y n∑
	(x + y) ^ n =
	Series (Ãm∑ÓØ(Binomial n m) * x ^ m * y ^ (n - m)) (n+1)
Æ);
a(REPEAT strip_tac THEN once_rewrite_tac[Ø_plus_comm_thm]);
a(cases_tac¨y = ÓØ 0Æ THEN1 all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(rewrite_tac[series_def, binomial_eq_thm]);
a(LEMMA_T ¨µk∑k º n ¥ Series (Ã m∑ ÓØ (Binomial n m) * x ^ m * ÓØ 0 ^ (n - m)) k = ÓØ 0Æ
	(fn th => rewrite_tac[rewrite_rule[](µ_elim¨nÆ th)]));
a(µ_tac THEN induction_tac ¨k:ÓÆ
	THEN asm_rewrite_tac[series_def]
	THEN_TRY PC_T1 "lin_arith" asm_prove_tac[]
	THEN rewrite_tac[º_def]
	THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(rewrite_tac[pc_rule1"lin_arith" prove_rule[]
	¨(k+1)+i = (i+1)+kÆ,
	Ø_Ó_exp_0_1_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨(y + x) ^ n = y^n *(ÓØ 1 + y õ-õ1 * x)^nÆ
	(fn th => rewrite_tac[th, binomial_thm1]));
(* *** Goal "2.1" *** *)
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) Ø_Ó_exp_times_thm,
	Ø_times_plus_distrib_thm,
	Ø_times_assoc_thm1]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(LEMMA_T ¨µk∑k º n + 1 ¥
	y ^ n * Series (Ã m∑ ÓØ (Binomial n m) * (y õ-õ1 * x) ^ m) k =
	Series (Ã m∑ ÓØ (Binomial n m) * x ^ m * y ^ (n - m)) kÆ
	(fn th => rewrite_tac[rewrite_rule[](µ_elim¨n+1Æ th)]));
a(µ_tac THEN induction_tac ¨k:ÓÆ
	THEN asm_rewrite_tac[series_def,
		Ø_times_plus_distrib_thm]
	THEN_TRY PC_T1 "lin_arith" asm_prove_tac[]
	THEN rewrite_tac[º_def]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
a(rewrite_tac[Ø_Ó_exp_plus_thm, Ø_Ó_exp_times_thm,
	µ_elim¨(y õ-õ1)^kÆ Ø_times_order_thm]);
a(rewrite_tac[Ø_times_assoc_thm1]);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) Ø_Ó_exp_times_thm]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(rewrite_tac[Ø_Ó_exp_0_1_thm] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €factorial_not_0_thm› = save_thm ( "factorial_not_0_thm", (
set_goal([], ¨µm∑ ≥ÓØ(m!) = ÓØ 0Æ);
a(strip_tac);
a(strip_asm_tac(µ_elim¨mÆfactorial_0_less_thm));
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €factorial_times_thm› = save_thm ( "factorial_times_thm", (
set_goal([], ¨µm∑ ÓØ(m!) * ÓØ(m!) õ-õ1 = ÓØ 1 ± ÓØ(m!) õ-õ1 * ÓØ(m!) = ÓØ 1 Æ);
a(strip_tac);
a(strip_asm_tac(µ_elim¨mÆfactorial_not_0_thm));
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €binomial_factorial_thm› = save_thm ( "binomial_factorial_thm", (
set_goal([], ¨µm n∑
	ÓØ (Binomial (m+n) m) = ÓØ((m+n)!) * ÓØ(m!) õ-õ1 * ÓØ(n!) õ-õ1
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂t∑m + n = tÆ THEN1 prove_∂_tac
	THEN POP_ASM_T ante_tac);
a(intro_µ_tac(¨nÆ, ¨nÆ) THEN intro_µ_tac(¨mÆ, ¨mÆ));
a(induction_tac¨tÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[binomial_0_clauses, factorial_def,
	factorial_times_thm,
	ÓØ_times_homomorphism_thm]);
(* *** Goal "2" *** *)
a(strip_asm_tac(µ_elim¨m'ÆÓ_cases_thm)
	THEN all_var_elim_asm_tac1);
(* *** Goal "2.1" *** *)
a(rewrite_tac[binomial_0_clauses,
	±_left_elim factorial_def,
	factorial_times_thm]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[pc_rule1 "lin_arith" prove_rule[]
	¨(i+1)+n = (i+n)+1Æ,
	ÓØ_plus_homomorphism_thm,
	binomial_def]);
a(lemma_tac¨i + n = tÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T [3] (ALL_FC_T rewrite_tac));
a(strip_asm_tac(µ_elim¨nÆÓ_cases_thm)
	THEN var_elim_nth_asm_tac 1);
(* *** Goal "2.2.1" *** *)
a(LEMMA_T ¨Binomial i (i+1) = 0Æ rewrite_thm_tac
	THEN1 (bc_thm_tac binomial_less_0_thm
		THEN REPEAT strip_tac));
a(asm_rewrite_tac[binomial_0_clauses,
	±_left_elim factorial_def,
	factorial_times_thm]);
(* *** Goal "2.2.2" *** *)
a(rename_tac[(¨iÆ, "M"), (¨i'Æ, "N")]
	THEN POP_ASM_T ante_tac);
a(rewrite_tac[pc_rule1 "lin_arith" prove_rule[]
	¨M + N + 1 = (M + 1) + NÆ]
	THEN strip_tac);
a(LIST_DROP_NTH_ASM_T [3] (ALL_FC_T rewrite_tac));
a(rewrite_tac[pc_rule1 "lin_arith" prove_rule[]
	¨(M + 1) + N = (M + N) + 1Æ]);
a(strip_asm_tac(µ_elim¨N+1Æ factorial_not_0_thm));
a(ALL_FC_T1 fc_§_canon once_rewrite_tac[
	conv_rule(ONCE_MAP_C (RIGHT_C eq_sym_conv)) Ø_times_cancel_thm]);
a(POP_ASM_T discard_tac);
a(rewrite_tac[Ø_times_assoc_thm, factorial_times_thm]);
a(strip_asm_tac(µ_elim¨M+1Æ factorial_not_0_thm));
a(ALL_FC_T1 fc_§_canon once_rewrite_tac[
	conv_rule(ONCE_MAP_C (RIGHT_C eq_sym_conv)) Ø_times_cancel_thm]);
a(POP_ASM_T discard_tac);
a(rewrite_tac[Ø_times_assoc_thm,
	factorial_times_thm]);
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µMN1 M N Mi Ni M1 N1 M1i N1i:Ø∑
	(MN1 * Mi * N1i + MN1 * M1i * Ni) * N1 * M1
	= (MN1 * Mi * (N1i * N1) * M1 + MN1 * (M1i * M1) * Ni *N1)
Æ]);
a(rewrite_tac[factorial_times_thm]);
a(rewrite_tac[eq_sym_rule(µ_elim¨MÆfactorial_times_recip_thm)]);
a(rewrite_tac[eq_sym_rule(µ_elim¨NÆfactorial_times_recip_thm)]);
a(rewrite_tac[Ø_times_assoc_thm,
	factorial_times_thm]);
a(conv_tac(RIGHT_C(once_rewrite_conv[factorial_def])));
a(rewrite_tac[ÓØ_plus_homomorphism_thm,
	ÓØ_times_homomorphism_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €enumerate_thm› = save_thm ( "enumerate_thm", (
set_goal([], ¨∂enumerate∑µa ∑
	a ç Finite
§	(µ i j∑ i < #a ± j < #a ± enumerate a i = enumerate a j ¥ i = j)
±	a = {x|∂ i∑ i < #a ± enumerate a i = x}
Æ);
a(prove_∂_tac THEN strip_tac);
a(cases_tac¨a' ç FiniteÆ THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[range_bijection_finite_size_thm1]);
(* *** Goal "2" *** *)
a(∂_tac¨Ãm:Ó∑ (y:'a)Æ THEN rewrite_tac[]);
a(strip_tac THEN ≤_right_tac);
a(swap_nth_asm_concl_tac 1);
a(once_asm_rewrite_tac[] THEN DROP_ASMS_T discard_tac);
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨{y}Æ
	THEN rewrite_tac[singleton_finite_thm]
	THEN PC_T1 "sets_ext1" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €covering_finite_size_thm› = save_thm ( "covering_finite_size_thm", (
set_goal([], ¨µa b f m∑
	a ç Finite
±	(µx∑x ç b ¥ f x ç a)
±	(µy∑y ç a ¥ {x | x ç b ± y = f x} ç Finite ± #{x | x ç b ± y = f x} = m)
¥	b ç Finite ± #b = m * #aÆ);
a(REPEAT µ_tac THEN ¥_tac);
a(strip_asm_tac(µ_elim¨mÆ range_finite_size_thm));
a(LEMMA_T¨({i | i < m} ∏ a) ç Finite ± #({i | i < m} ∏ a) = # {i|i < m} * #aÆ
	ante_tac
	THEN1 (bc_thm_tac ∏_finite_size_thm THEN REPEAT strip_tac));
a(asm_rewrite_tac[] THEN strip_tac);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(bc_thm_tac(bijection_finite_size_thm));
a(strip_asm_tac enumerate_thm);
a(∂_tac¨Ã(i, y)∑enumerate {x | x ç b ± y = f x} iÆ
	THEN rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN DROP_NTH_ASM_T 2 ante_tac);
a(rewrite_tac[∏_def]);
a(strip_asm_tac (µ_elim¨mÆÓ_cases_thm)
	THEN all_var_elim_asm_tac1 THEN1 asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 10 (fn th =>
		ante_tac (µ_elim¨Snd xÆ th)
	THEN ante_tac (µ_elim¨Snd yÆ th)));
a(DROP_NTH_ASM_T 6 rewrite_thm_tac
	THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T[2, 3, 5, 6]
	(MAP_EVERY ante_tac));
a(rename_tac[] THEN LIST_GET_NTH_ASM_T [1, 2] rewrite_tac
	THEN REPEAT strip_tac);
a(lemma_tac¨enumerate {x'|x' ç b ± Snd x = f x'} (Fst x) ç
	{x'|x' ç b ± Snd x = f x'}Æ);
(* *** Goal "1.1" *** *)
a(POP_ASM_T (fn th => conv_tac(RIGHT_C (once_rewrite_conv[th]))));
a(rewrite_tac[]);
a(∂_tac¨Fst xÆ THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(lemma_tac¨enumerate {x'|x' ç b ± Snd x = f x'} (Fst x) ç
	{x'|x' ç b ± Snd y = f x'}Æ);
(* *** Goal "1.2.1" *** *)
a(DROP_NTH_ASM_T 13 pure_rewrite_thm_tac);
a(DROP_NTH_ASM_T 5 (fn th => conv_tac(RIGHT_C (once_rewrite_conv[th]))));
a(rewrite_tac[]);
a(∂_tac¨Fst yÆ THEN REPEAT strip_tac);
a(LEMMA_T ¨Snd x = Snd yÆ 
	(fn th => all_asm_ante_tac
		THEN asm_tac th
		THEN asm_rewrite_tac[]
		THEN REPEAT strip_tac)
	THEN1 (POP_ASM_T rewrite_thm_tac
		THEN strip_tac));
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
a(PC_T1 "prop_eq_pair" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(LIST_GET_NTH_ASM_T [7] all_fc_tac);
a(LIST_GET_NTH_ASM_T [7] (ALL_FC_T(MAP_EVERY ante_tac)));
a(DROP_NTH_ASM_T 3 rewrite_thm_tac
	THEN REPEAT strip_tac);
a(LEMMA_T ¨x ç {x'|x' ç b ± f x = f x'}Æ
	ante_tac THEN1 asm_rewrite_tac[]);
a(POP_ASM_T pure_once_rewrite_thm_tac);
a(rewrite_tac[] THEN strip_tac);
a(all_var_elim_asm_tac1);
a(∂_tac¨(i, f x)Æ THEN asm_rewrite_tac[∏_def]);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[∏_def]));
a(LIST_GET_NTH_ASM_T [8] (ALL_FC_T(MAP_EVERY ante_tac)));
a(DROP_NTH_ASM_T 4 rewrite_thm_tac
	THEN REPEAT strip_tac);
a(LEMMA_T¨x ç {x|x ç b ± Snd x' = f x}Æ
	(fn th => ante_tac th THEN PC_T1 "sets_ext1" prove_tac[]));
a(POP_ASM_T pure_once_rewrite_thm_tac THEN rewrite_tac[]);
a(all_var_elim_asm_tac1 THEN ∂_tac¨Fst x'Æ THEN REPEAT strip_tac);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €samples_finite_size_thm› = save_thm ( "samples_finite_size_thm", (
set_goal([], ¨µa n∑
	a ç Finite
¥	{L | Elems L Ä a ± #L = n} ç Finite
±	#{L | Elems L Ä a ± #L = n} = #a ^ n
Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(induction_tac¨nÆ THEN rewrite_tac[Ó_exp_def]);
(* *** Goal "1" *** *)
a(LEMMA_T ¨{L|Elems L Ä a ± # L = 0} = {[]}Æ
	(fn th => rewrite_tac[th, size_singleton_thm, singleton_finite_thm]));
a(PC_T "sets_ext1" strip_tac THEN µ_tac THEN rewrite_tac[]);
a(strip_asm_tac(µ_elim¨xÆlist_cases_thm)
	THEN asm_rewrite_tac[elems_def, length_def]);
(* *** Goal "2" *** *)
a(ante_tac(list_µ_elim[¨aÆ, ¨{L | Elems L Ä a ± #L = n}Æ]
	∏_finite_size_thm));
a(asm_rewrite_tac[]);
a(REPEAT ¥_tac THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(bc_thm_tac(bijection_finite_size_thm));
a(∂_tac¨Uncurry ConsÆ THEN rewrite_tac[uncurry_def]
	THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(PC_T1 "prop_eq_pair" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(POP_ASM_T ante_tac THEN strip_asm_tac(µ_elim¨xÆlist_cases_thm)
	THEN all_var_elim_asm_tac1 
	THEN rewrite_tac[length_def]);
a(REPEAT strip_tac);
a(∂_tac¨(x', list2)Æ THEN asm_rewrite_tac[∏_def]);
a(DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac[elems_def]);
a(PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2.3" *** *)
a(all_var_elim_asm_tac1);
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(rewrite_tac[elems_def, ∏_def]);
a(REPEAT strip_tac THEN1 all_var_elim_asm_tac1);
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2.4" *** *)
a(all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN rewrite_tac[∏_def, length_def]
	THEN REPEAT strip_tac);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €distinct_samples_rw_thm› = save_thm ( "distinct_samples_rw_thm", (
set_goal([], ¨µn m∑
	DistinctSamples n m =
	if m = 0
	then 1
	else (n+m) * DistinctSamples n (m-1)
Æ);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim¨mÆÓ_cases_thm) THEN asm_rewrite_tac[distinct_samples_def]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €distinct_samples_up_thm› = save_thm ( "distinct_samples_up_thm", (
set_goal([], ¨µn m∑
	DistinctSamples n (m+1) = (n+1) * DistinctSamples (n+1) m
Æ);
a(REPEAT strip_tac);
a(induction_tac¨mÆ);
(* *** Goal "1" *** *)
a(rewrite_tac [distinct_samples_def]);
(* *** Goal "2" *** *)
a(once_rewrite_tac[distinct_samples_def]);
a(asm_rewrite_tac[]);
a(PC_T1 "lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €distinct_samples_finite_size_thm› = save_thm ( "distinct_samples_finite_size_thm", (
set_goal([], ¨µa n∑a ç Finite ± n º #a
¥	{L | Elems L Ä a ± # L = n ± L ç Distinct} ç Finite
±	#{L | Elems L Ä a ± # L = n ± L ç Distinct} = DistinctSamples (#a - n) n
Æ);
a(REPEAT µ_tac THEN ¥_tac THEN POP_ASM_T ante_tac);
a(induction_tac¨n:ÓÆ);
(* *** Goal "1" *** *)
a(LEMMA_T ¨{L|Elems L Ä a ± # L = 0 ± L ç Distinct} = {[]}Æ
	(fn th => asm_rewrite_tac[th, size_singleton_thm, singleton_finite_thm,
	distinct_samples_def]));
a(PC_T "sets_ext1" strip_tac THEN µ_tac THEN rewrite_tac[]);
a(strip_asm_tac(µ_elim¨xÆlist_cases_thm)
	THEN asm_rewrite_tac[elems_def, length_def, distinct_def]);
(* *** Goal "2" *** *)
a(strip_tac THEN i_contr_tac THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(¥_tac);
a(DROP_NTH_ASM_T 2 ante_tac);
a(POP_ASM_T (strip_asm_tac o once_rewrite_rule[plus_comm_thm]
	 o rewrite_rule[º_def]));
a(TOP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[distinct_samples_up_thm, µ_elim¨nÆ plus_order_thm]);
a(STRIP_T (rewrite_thm_tac o eq_sym_rule));
a(bc_thm_tac covering_finite_size_thm);
(* *** Goal "3" *** *)
a(∂_tac¨TailÆ THEN rewrite_tac[] THEN REPEAT_UNTIL is_± strip_tac
	THEN REPEAT_N 3 strip_tac THEN1 REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac
	THEN DROP_NTH_ASM_T 2 ante_tac
	THEN strip_asm_tac (µ_elim¨xÆ list_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN asm_rewrite_tac[length_def, elems_def, tail_def]
	THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "3.2" *** *)
a(DROP_NTH_ASM_T 4 ante_tac
	THEN DROP_NTH_ASM_T 2 ante_tac
	THEN strip_asm_tac (µ_elim¨xÆ list_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN asm_rewrite_tac[length_def, tail_def]
	THEN taut_tac);
(* *** Goal "3.3" *** *)
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac
	THEN strip_asm_tac (µ_elim¨xÆ list_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN asm_rewrite_tac[length_def, distinct_def, tail_def]
	THEN taut_tac);
(* *** Goal "3.4" *** *)
a(REPEAT ¥_tac);
a(ante_tac(list_µ_elim[¨aÆ, ¨Elems yÆ] size_Ä_diff_thm)
	THEN DROP_NTH_ASM_T 4 (asm_rewrite_thm_tac o eq_sym_rule));
a(LEMMA_T ¨#(Elems y) = #yÆ asm_rewrite_thm_tac
	THEN1 (bc_thm_tac distinct_size_length_thm
		THEN REPEAT strip_tac));
a(rewrite_tac[µ_elim¨nÆ plus_order_thm]);
a(STRIP_T rewrite_thm_tac);
a(bc_thm_tac bijection_finite_size_thm);
a(∂_tac¨Ãx∑Cons x yÆ THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "3.4.1" *** *)
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨aÆ THEN REPEAT strip_tac
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "3.4.2" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "3.4.2.1" *** *)
a(LIST_DROP_NTH_ASM_T [2, 3, 5, 7] (MAP_EVERY ante_tac)
	THEN strip_asm_tac (µ_elim¨xÆ list_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN rewrite_tac[length_def, tail_def, distinct_def, elems_def]);
a(REPEAT strip_tac THEN ∂_tac¨x'Æ THEN PC_T1 "sets_ext1" asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 4 bc_thm_tac THEN rewrite_tac[elems_def]
	THEN REPEAT strip_tac);
(* *** Goal "3.4.2.2" *** *)
a(POP_ASM_T ante_tac THEN all_var_elim_asm_tac1
	THEN asm_rewrite_tac[elems_def]);
a(REPEAT strip_tac THEN1 all_var_elim_asm_tac);
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "3.4.2.3" *** *)
a(asm_rewrite_tac[length_def]);
(* *** Goal "3.4.2.4" *** *)
a(asm_rewrite_tac[distinct_def]);
(* *** Goal "3.4.2.5" *** *)
a(asm_rewrite_tac[tail_def]);
pop_thm()
));

=TEX
%%%%
%%%%
If a naive approach to the calculations were taken, the following would take 15 seconds or so to run through (prior to version 2.7.7 of ProofPower).
The contrivances below cut this down to a second or so (as also do performance enhancements in versions 2.7.7 and later of ProofPower).

=SML
val €birthdays_thm› = save_thm ( "birthdays_thm", (
set_goal([], ¨
	let	S = {L | Elems L Ä {i | 1 º i ± i º 365} ± # L = 23} 
	in let	X = {L | L ç S ± ≥L ç Distinct}
	in	S ç Finite
	±	≥#S = 0
	±	X Ä S
	±	#X / #S > 1/2
Æ);
a(rewrite_tac[let_def]);
a(strip_asm_tac(µ_elim¨365Æ range_finite_size_thm1));
a(lemma_tac¨23 º #{i | 1 º i ± i º 365}Æ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[distinct_samples_finite_size_thm]);
a(all_fc_tac[samples_finite_size_thm]);
a(REPEAT_N 2 (POP_ASM_T(ante_tac o µ_elim¨23Æ)) );
a(POP_ASM_T discard_tac THEN strip_tac THEN strip_tac);
a(pure_asm_rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv)ÓØ_one_one_thm,
	ÓØ_Ó_exp_thm,
	Ø_frac_def]);
a(asm_tac(rewrite_conv[]¨ÓØ 365 ^ 23Æ));
a(PC_T1"predicates" rewrite_tac[] THEN strip_tac
	THEN1 (pure_asm_rewrite_tac[ÓØ_one_one_thm]
		THEN PC_T1 "lin_arith" prove_tac[]));
a(REPEAT strip_tac THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(pure_rewrite_tac[ÓØ_one_one_thm]);
a(LEMMA_T¨{L | (Elems L Ä {i | 1 º i ± i º 365} ± # L = 23) ± ≥L ç Distinct}
 = {L | Elems L Ä {i | 1 º i ± i º 365} ± # L = 23} \
	{L | Elems L Ä {i | 1 º i ± i º 365} ± # L = 23 ± L ç Distinct}Æ
	pure_rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(lemma_tac¨{L | Elems L Ä {i | 1 º i ± i º 365} ± # L = 23 ± L ç Distinct} Ä
	{L | Elems L Ä {i | 1 º i ± i º 365} ± # L = 23}Æ
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(ALL_FC_T (MAP_EVERY (ante_tac o
	once_rewrite_rule[conv_rule(ONCE_MAP_C eq_sym_conv)ÓØ_one_one_thm])) [size_Ä_diff_thm]);
a(pure_rewrite_tac[ÓØ_plus_homomorphism_thm,
	pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µa b c:Ø∑a = b + c § b = a - cÆ]
	THEN STRIP_T pure_rewrite_thm_tac);
a(LIST_DROP_NTH_ASM_T [3, 6, 9] pure_rewrite_tac);
a(LEMMA_T ¨µa b c d:Ø∑ÓØ 0 < b ± ÓØ 0 < d ± a*d < b*c ¥ a/b < c/dÆ
	bc_thm_tac
	THEN1 (REPEAT strip_tac
		THEN1 ALL_FC_T1 fc_§_canon asm_rewrite_tac[Ø_cross_mult_less_thm]));
a(pure_asm_rewrite_tac[ÓØ_Ó_exp_thm,
	pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µa b c:Ø∑a < ÓØ 2 * (b - c) § a + ÓØ 2 * c < ÓØ 2 * bÆ,
	REPEAT_C (once_rewrite_conv[distinct_samples_rw_thm] THEN_C rewrite_conv[])
	¨DistinctSamples (365-23) 23Æ]);
a(pure_rewrite_tac[ÓØ_plus_homomorphism_thm1,
	ÓØ_times_homomorphism_thm1,
	ÓØ_less_thm]);
a(rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €walk_thm› = save_thm ( "walk_thm", (
set_goal([], ¨µn x∑
	Walk n x =
	{s
	| ∂a∑	(µm∑m ç a ¥ m < n)
	± 	(µm∑ s m = x + Ó˙(#({k | k < m ± k < n} ° a)) - Ó˙(#({k | k < m ± k < n} \ a)))}Æ);
a(PC_T1 "sets_ext1" rewrite_tac[walk_def1] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rename_tac[(¨x'Æ, "s")] THEN ∂_tac¨{m | m < n ± s(m+1) - s m = Ó˙ 1}Æ);
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(induction_tac¨mÆ THEN1 asm_rewrite_tac[
	pc_rule1 "sets_ext1" prove_rule[]¨{x|F} = {}Æ,
	size_empty_thm]);
a(cases_tac¨≥m < nÆ);
(* *** Goal "1.1" *** *)
a(lemma_tac¨n º m ± n º m+1Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [5] all_fc_tac);
a(DROP_NTH_ASM_T 2 rewrite_thm_tac
	THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(DROP_NTH_ASM_T 4 (fn th => conv_tac(LEFT_C (eq_match_conv th)))
	THEN rewrite_tac[]);
a(LEMMA_T ¨µa b c d x y:Ó SET∑
	a = c ± b = d ¥ Ó˙(#(a ° x)) + ~(Ó˙(#(b \ x))) = Ó˙(#(c ° x)) + ~(Ó˙(#(d \ x)))Æ bc_thm_tac
	THEN1 (REPEAT strip_tac THEN asm_rewrite_tac[]));
a(PC_T1 "sets_ext" rewrite_tac[]);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 4 (strip_asm_tac o µ_elim¨mÆ));
(* *** Goal "1.2.1" *** *)
a(ALL_FC_T rewrite_tac[pc_rule1 "˙_lin_arith" prove_rule[]
	¨µx y∑x + ~y = Ó˙ 1 ¥ x = y + Ó˙ 1Æ]);
a(DROP_NTH_ASM_T 3 (fn th => conv_tac(LEFT_C (LEFT_C(eq_match_conv th))))
	THEN rewrite_tac[˙_plus_assoc_thm]);
a(LEMMA_T ¨µb d:Ó SET; r s∑
	b = d ± s = r + Ó˙ 1 ¥ r + ~(Ó˙(#b)) + Ó˙ 1 = s + ~(Ó˙(#d))Æ bc_thm_tac
	THEN1 (REPEAT strip_tac THEN asm_rewrite_tac[]
		THEN PC_T1 "˙_lin_arith" prove_tac[]));
a(REPEAT strip_tac
	THEN1 (PC_T1 "sets_ext" REPEAT strip_tac
		THEN_TRY PC_T1 "lin_arith" asm_prove_tac[]));
(* *** Goal "1.2.1.1" *** *)
a(contr_tac THEN lemma_tac¨x' = mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1);
(* *** Goal "1.2.1.2" *** *)
a(rewrite_tac[Ó˙_plus_homomorphism_thm1, Ó˙_one_one_thm]);
a(LEMMA_T¨
	{k|k < m + 1 ± k < n} ° {m|m < n ± s (m + 1) + ~ (s m) = Ó˙ 1} =
	{m} ¿ ({k|k < m ± k < n} ° {m|m < n ± s (m + 1) + ~ (s m) = Ó˙ 1})Æ
	rewrite_thm_tac
	THEN PC_T1 "sets_ext" REPEAT strip_tac
		THEN_TRY PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.1.2.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "1.2.1.2.2" *** *)
a(bc_thm_tac size_singleton_¿_thm);
a(REPEAT strip_tac);
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨{k|k < m}Æ);
a(rewrite_tac[range_finite_size_thm]);
a(PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "1.2.2" *** *)
a(ALL_FC_T rewrite_tac[pc_rule1 "˙_lin_arith" prove_rule[]
	¨µx y∑x + ~y = ~(Ó˙ 1) ¥ x = y + ~(Ó˙ 1)Æ]);
a(DROP_NTH_ASM_T 3 (fn th => conv_tac(LEFT_C (LEFT_C(eq_match_conv th))))
	THEN rewrite_tac[˙_plus_assoc_thm]);
a(LEMMA_T ¨µb d:Ó SET; r s∑
	b = d ± s = r + ~(Ó˙ 1) ¥ Ó˙(#b) + r + ~(Ó˙ 1) = Ó˙(#d) + sÆ bc_thm_tac
	THEN1 (REPEAT strip_tac THEN asm_rewrite_tac[]
		THEN PC_T1 "˙_lin_arith" prove_tac[]));
a(REPEAT strip_tac
	THEN1 (PC_T1 "sets_ext" REPEAT strip_tac
		THEN_TRY PC_T1 "lin_arith" asm_prove_tac[]));
(* *** Goal "1.2.2.1" *** *)
a(contr_tac THEN lemma_tac¨x' = mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.2" *** *)
a(rewrite_tac[Ó˙_plus_homomorphism_thm1, Ó˙_one_one_thm,
	pc_rule1 "˙_lin_arith" prove_rule[]
	¨µx y∑~x = ~y + ~(Ó˙ 1) § x = y + Ó˙ 1Æ]);
a(LEMMA_T¨
	{k|k < m + 1 ± k < n} \ {m|m < n ± s (m + 1) + ~ (s m) = Ó˙ 1} =
	{m} ¿ ({k|k < m ± k < n} \ {m|m < n ± s (m + 1) + ~ (s m) = Ó˙ 1})Æ
	rewrite_thm_tac
	THEN PC_T1 "sets_ext" REPEAT strip_tac
		THEN_TRY PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2.2.1" *** *)
a(all_var_elim_asm_tac1 THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.2.2" *** *)
a(bc_thm_tac size_singleton_¿_thm);
a(REPEAT strip_tac);
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨{k|k < m}Æ);
a(rewrite_tac[range_finite_size_thm]);
a(PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[
	pc_rule1 "sets_ext1" prove_rule[]¨{x|F} = {}Æ,
	size_empty_thm]);
(* *** Goal "3" *** *)
a(lemma_tac¨≥m ç aÆ);
(* *** Goal "3.1" *** *)
a(swap_nth_asm_concl_tac 1);
a(DROP_NTH_ASM_T 3 (fn th => conv_tac(once_rewrite_conv[th])));
a(LEMMA_T ¨µa b c d x y:Ó SET; t : ˙∑
	b = d ± Ó˙(#a) = Ó˙(#c) + Ó˙ 1¥
	(t + Ó˙(#a) - Ó˙(#b)) +
	~(t + Ó˙(#c) - Ó˙(#d)) = Ó˙ 1Æ bc_thm_tac
	THEN1 (REPEAT strip_tac THEN asm_rewrite_tac[]
		THEN PC_T1 "˙_lin_arith" asm_prove_tac[]));
a(REPEAT strip_tac);
(* *** Goal "3.1.1" *** *)
a(PC_T1 "sets_ext" asm_rewrite_tac[]);
a(REPEAT strip_tac THEN_TRY PC_T1 "lin_arith" asm_prove_tac[]);
a(contr_tac THEN lemma_tac¨x = mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1);
(* *** Goal "3.1.2" *** *)
a(rewrite_tac[Ó˙_plus_homomorphism_thm1, Ó˙_one_one_thm]);
a(LEMMA_T¨
	{k|k < m + 1 ± k < n} ° a =
	{m} ¿ ({k|k < m ± k < n} ° a)Æ
	rewrite_thm_tac
	THEN PC_T1 "sets_ext" REPEAT strip_tac
		THEN_TRY PC_T1 "lin_arith" asm_prove_tac[]
		THEN1 all_var_elim_asm_tac1);
a(bc_thm_tac size_singleton_¿_thm);
a(REPEAT strip_tac);
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨{k|k < m}Æ);
a(rewrite_tac[range_finite_size_thm]);
a(PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "3.2" *** *)
a(DROP_NTH_ASM_T 4 (fn th => conv_tac(once_rewrite_conv[th])));
a(LEMMA_T ¨µa b c d x y:Ó SET; t : ˙∑
	a = c ± Ó˙(#b) = Ó˙(#d) + Ó˙ 1 ¥
	(t + Ó˙(#a) - Ó˙(#b)) +
	~(t + Ó˙(#c) - Ó˙(#d)) = ~(Ó˙ 1)Æ bc_thm_tac
	THEN1 (REPEAT strip_tac THEN asm_rewrite_tac[]
		THEN PC_T1 "˙_lin_arith" asm_prove_tac[]));
a(REPEAT strip_tac);
(* *** Goal "3.2.1" *** *)
a(PC_T1 "sets_ext" asm_rewrite_tac[]);
a(REPEAT strip_tac THEN_TRY PC_T1 "lin_arith" asm_prove_tac[]);
a(contr_tac THEN lemma_tac¨x = mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1);
(* *** Goal "3.2.2" *** *)
a(rewrite_tac[Ó˙_plus_homomorphism_thm1, Ó˙_one_one_thm]);
a(LEMMA_T¨
	{k|k < m + 1 ± k < n} \ a =
	{m} ¿ ({k|k < m ± k < n} \ a)Æ
	rewrite_thm_tac
	THEN PC_T1 "sets_ext" REPEAT strip_tac
		THEN_TRY PC_T1 "lin_arith" asm_prove_tac[]
		THEN1 all_var_elim_asm_tac1);
a(bc_thm_tac size_singleton_¿_thm);
a(REPEAT strip_tac);
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨{k|k < m}Æ);
a(rewrite_tac[range_finite_size_thm]);
a(PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "4" *** *)
a(DROP_NTH_ASM_T 2 rewrite_thm_tac);
a(LEMMA_T ¨{k|k < m ± k < n} = {k|k < n}Æ rewrite_thm_tac);
a(PC_T1 "sets_ext" asm_rewrite_tac[]);
a(REPEAT strip_tac THEN PC_T1 "lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €walk_to_thm› = save_thm ( "walk_to_thm", (
set_goal([], ¨µn x y∑
	WalkTo n x y =
	{s
	| ∂a∑	(µm∑m ç a ¥ m < n)
	± 	(µm∑ s m = x + Ó˙(#({k | k < m ± k < n} ° a)) - Ó˙(#({k | k < m ± k < n} \ a)))
	±	s n = y}Æ);
a(REPEAT strip_tac THEN PC_T "sets_ext1" strip_tac);
a(rewrite_tac[walk_to_def, walk_thm] THEN PC_T1 "sets_ext1" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €walk_finite_size_thm› = save_thm ( "walk_finite_size_thm", (
set_goal([], ¨µn x∑ Walk n x ç Finite ± #(Walk n x) = 2 ^ nÆ);
a(REPEAT µ_tac);
a(strip_asm_tac(µ_elim¨nÆ range_finite_size_thm));
a(ALL_FC_T(MAP_EVERY ante_tac)[_finite_size_thm]);
a(asm_rewrite_tac[] THEN REPEAT ¥_tac);
a(GET_NTH_ASM_T 2 (rewrite_thm_tac o eq_sym_rule));
a(bc_thm_tac bijection_finite_size_thm);
a(asm_rewrite_tac[]);
a(∂_tac¨Ãa∑Ãm∑x + Ó˙ (# ({k|k < m ± k < n} ° a)) - Ó˙ (# ({k|k < m ± k < n} \ a))Æ);
a(rewrite_tac[walk_thm, _def, Ä_def,
	pc_rule1 "˙_lin_arith" prove_rule[]
	¨µx y z w:˙∑x + ~y = z + ~w § x + w = z + yÆ,
	Ó˙_plus_homomorphism_thm1, Ó˙_one_one_thm]
	THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [4, 5, 6, 7] discard_tac);
a(PC_T1 "sets_ext1" rewrite_tac[] THEN µ_tac);
a(rename_tac[(¨x'Æ, "X"), (¨yÆ, "Y"), (¨xÆ, "i")]
	THEN cov_induction_tac¨i:ÓÆ);
a(cases_tac¨≥i < nÆ
	THEN1 (lemma_tac¨≥i ç XÆ THEN1 (contr_tac THEN all_asm_fc_tac[])
	THEN lemma_tac¨≥i ç YÆ THEN1 (contr_tac THEN all_asm_fc_tac[])
	THEN REPEAT strip_tac));
a(DROP_NTH_ASM_T 3 (strip_asm_tac o µ_elim¨i+1Æ));
a(cases_tac¨i ç XÆ THEN contr_tac);
(* *** Goal "1" *** *)
a(swap_nth_asm_concl_tac 3);
a(LEMMA_T¨
	{k|k < i + 1 ± k < n} ° X =
	{i} ¿ ({k|k < i ± k < n} ° X) ±
	{k|k < i + 1 ± k < n} ° Y =
	({k|k < i ± k < n} ° Y) ±
	{k|k < i + 1 ± k < n} \ X =
	({k|k < i ± k < n} \ X) ±
	{k|k < i + 1 ± k < n} \ Y =
	{i} ¿ ({k|k < i ± k < n} \ Y)Æ
	rewrite_thm_tac);
(* *** Goal "1.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1
	THEN_TRY PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.1.1" *** *)
a(cases_tac¨x = iÆ THEN1 all_var_elim_asm_tac1);
a(lemma_tac¨x < iÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.1.2" *** *)
a(cases_tac¨x = iÆ THEN1 all_var_elim_asm_tac1);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(LEMMA_T¨
	{k|k < i ± k < n} ° X =
	({k|k < i ± k < n} ° Y) ±
	{k|k < i ± k < n} \ X =
	({k|k < i ± k < n} \ Y)Æ
	rewrite_thm_tac);
(* *** Goal "1.2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac
	THEN_TRY ALL_ASM_FC_T1 fc_§_canon (MAP_EVERY strip_asm_tac)[]);
(* *** Goal "1.2.2" *** *)
a(strip_asm_tac(µ_elim¨iÆ range_finite_size_thm));
a(lemma_tac¨
	({k|k < i ± k < n} ° Y) ç Finite ±
	({k|k < i ± k < n} \ Y) ç FiniteÆ
	THEN1 (REPEAT strip_tac
		THEN bc_thm_tac Ä_finite_thm
		THEN ∂_tac¨{j|j < i}Æ THEN REPEAT strip_tac
		THEN PC_T1 "sets_ext1" prove_tac[]));
a(LEMMA_T¨
	≥i ç ({k|k < i ± k < n} ° Y) ±
	≥i ç ({k|k < i ± k < n} \ Y)Æ (±_THEN asm_tac)
	THEN1 (REPEAT strip_tac
		THEN PC_T1 "lin_arith" prove_tac[]));
a(ALL_FC_T rewrite_tac[size_singleton_¿_thm]);
a(PC_T1 "lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 3);
a(LEMMA_T¨
	{k|k < i + 1 ± k < n} ° Y =
	{i} ¿ ({k|k < i ± k < n} ° Y) ±
	{k|k < i + 1 ± k < n} ° X =
	({k|k < i ± k < n} ° X) ±
	{k|k < i + 1 ± k < n} \ Y =
	({k|k < i ± k < n} \ Y) ±
	{k|k < i + 1 ± k < n} \ X =
	{i} ¿ ({k|k < i ± k < n} \ X)Æ
	rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1
	THEN_TRY PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2.1.1" *** *)
a(cases_tac¨x = iÆ THEN1 all_var_elim_asm_tac1);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2.1.2" *** *)
a(cases_tac¨x = iÆ THEN1 all_var_elim_asm_tac1);
a(lemma_tac¨x < iÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(LEMMA_T¨
	{k|k < i ± k < n} ° X =
	({k|k < i ± k < n} ° Y) ±
	{k|k < i ± k < n} \ X =
	({k|k < i ± k < n} \ Y)Æ
	rewrite_thm_tac);
(* *** Goal "2.2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac
	THEN_TRY ALL_ASM_FC_T1 fc_§_canon (MAP_EVERY strip_asm_tac)[]);
(* *** Goal "2.2.2" *** *)
a(strip_asm_tac(µ_elim¨iÆ range_finite_size_thm));
a(lemma_tac¨
	({k|k < i ± k < n} ° Y) ç Finite ±
	({k|k < i ± k < n} \ Y) ç FiniteÆ
	THEN1 (REPEAT strip_tac
		THEN bc_thm_tac Ä_finite_thm
		THEN ∂_tac¨{j|j < i}Æ THEN REPEAT strip_tac
		THEN PC_T1 "sets_ext1" prove_tac[]));
a(LEMMA_T¨
	≥i ç ({k|k < i ± k < n} ° Y) ±
	≥i ç ({k|k < i ± k < n} \ Y)Æ (±_THEN asm_tac)
	THEN1 (REPEAT strip_tac
		THEN PC_T1 "lin_arith" prove_tac[]));
a(ALL_FC_T rewrite_tac[size_singleton_¿_thm]);
a(PC_T1 "lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €walk_to_finite_size_thm› = save_thm ( "walk_to_finite_size_thm", (
set_goal([], ¨µx m n∑ WalkTo (m + n) x (x + Ó˙ m - Ó˙ n) ç Finite ± #(WalkTo (m + n) x (x + Ó˙ m - Ó˙ n)) = Binomial (m + n) mÆ);
a(REPEAT µ_tac);
a(strip_asm_tac(µ_elim¨m+nÆrange_finite_size_thm));
a(all_fc_tac[combinations_finite_size_thm]);
a(LIST_DROP_NTH_ASM_T [1, 2] (MAP_EVERY (strip_asm_tac o µ_elim¨mÆ)));
a(GET_NTH_ASM_T 2 (rewrite_thm_tac o eq_sym_rule));
a(bc_thm_tac bijection_finite_size_thm);
a(asm_rewrite_tac[]);
a(∂_tac¨Ãa∑Ãl∑x + Ó˙ (# ({k|k < l ± k < m + n} ° a)) - Ó˙ (# ({k|k < l ± k < m + n} \ a))Æ);
a(rewrite_tac[walk_to_thm, _def, Ä_def,
	pc_rule1 "˙_lin_arith" prove_rule[]
	¨µx y z w:˙∑x + ~y = z + ~w § x + w = z + yÆ,
	Ó˙_plus_homomorphism_thm1, Ó˙_one_one_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LIST_DROP_NTH_ASM_T [6, 7, 8, 9] discard_tac);
a(PC_T1 "sets_ext1" rewrite_tac[] THEN µ_tac);
a(rename_tac[(¨x'Æ, "X"), (¨yÆ, "Y"), (¨xÆ, "i")]
	THEN cov_induction_tac¨i:ÓÆ);
a(cases_tac¨≥i < m + nÆ
	THEN1 (lemma_tac¨≥i ç XÆ THEN1 (contr_tac THEN all_asm_fc_tac[])
	THEN lemma_tac¨≥i ç YÆ THEN1 (contr_tac THEN all_asm_fc_tac[])
	THEN REPEAT strip_tac));
a(DROP_NTH_ASM_T 3 (strip_asm_tac o µ_elim¨i+1Æ));
a(cases_tac¨i ç XÆ THEN contr_tac);
(* *** Goal "1" *** *)
a(swap_nth_asm_concl_tac 3);
a(LEMMA_T¨
	{k|k < i + 1 ± k < m + n} ° X =
	{i} ¿ ({k|k < i ± k < m + n} ° X) ±
	{k|k < i + 1 ± k < m + n} ° Y =
	({k|k < i ± k < m + n} ° Y) ±
	{k|k < i + 1 ± k < m + n} \ X =
	({k|k < i ± k < m + n} \ X) ±
	{k|k < i + 1 ± k < m + n} \ Y =
	{i} ¿ ({k|k < i ± k < m + n} \ Y)Æ
	rewrite_thm_tac);
(* *** Goal "1.1.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1
	THEN_TRY PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.1.1.1" *** *)
a(cases_tac¨x = iÆ THEN1 all_var_elim_asm_tac1);
a(lemma_tac¨x < iÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.1.1.2" *** *)
a(cases_tac¨x = iÆ THEN1 all_var_elim_asm_tac1);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.1.2" *** *)
a(LEMMA_T¨
	{k|k < i ± k < m + n} ° X =
	({k|k < i ± k < m + n} ° Y) ±
	{k|k < i ± k < m + n} \ X =
	({k|k < i ± k < m + n} \ Y)Æ
	rewrite_thm_tac);
(* *** Goal "1.2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac
	THEN_TRY ALL_ASM_FC_T1 fc_§_canon (MAP_EVERY strip_asm_tac)[]);
(* *** Goal "1.1.2.2" *** *)
a(strip_asm_tac(µ_elim¨iÆ range_finite_size_thm));
a(lemma_tac¨
	({k|k < i ± k < m + n} ° Y) ç Finite ±
	({k|k < i ± k < m + n} \ Y) ç FiniteÆ
	THEN1 (REPEAT strip_tac
		THEN bc_thm_tac Ä_finite_thm
		THEN ∂_tac¨{j|j < i}Æ THEN REPEAT strip_tac
		THEN PC_T1 "sets_ext1" prove_tac[]));
a(LEMMA_T¨
	≥i ç ({k|k < i ± k < m + n} ° Y) ±
	≥i ç ({k|k < i ± k < m + n} \ Y)Æ (±_THEN asm_tac)
	THEN1 (REPEAT strip_tac
		THEN PC_T1 "lin_arith" prove_tac[]));
a(ALL_FC_T rewrite_tac[size_singleton_¿_thm]);
a(PC_T1 "lin_arith" prove_tac[]);
(* *** Goal "1.2" *** *)
a(swap_nth_asm_concl_tac 3);
a(LEMMA_T¨
	{k|k < i + 1 ± k < m + n} ° Y =
	{i} ¿ ({k|k < i ± k < m + n} ° Y) ±
	{k|k < i + 1 ± k < m + n} ° X =
	({k|k < i ± k < m + n} ° X) ±
	{k|k < i + 1 ± k < m + n} \ Y =
	({k|k < i ± k < m + n} \ Y) ±
	{k|k < i + 1 ± k < m + n} \ X =
	{i} ¿ ({k|k < i ± k < m + n} \ X)Æ
	rewrite_thm_tac);
(* *** Goal "1.2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1
	THEN_TRY PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.1.1" *** *)
a(cases_tac¨x = iÆ THEN1 all_var_elim_asm_tac1);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.1.2" *** *)
a(cases_tac¨x = iÆ THEN1 all_var_elim_asm_tac1);
a(lemma_tac¨x < iÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2" *** *)
a(LEMMA_T¨
	{k|k < i ± k < m + n} ° X =
	({k|k < i ± k < m + n} ° Y) ±
	{k|k < i ± k < m + n} \ X =
	({k|k < i ± k < m + n} \ Y)Æ
	rewrite_thm_tac);
(* *** Goal "1.2.2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac
	THEN_TRY ALL_ASM_FC_T1 fc_§_canon (MAP_EVERY strip_asm_tac)[]);
(* *** Goal "1.2.2.2" *** *)
a(strip_asm_tac(µ_elim¨iÆ range_finite_size_thm));
a(lemma_tac¨
	({k|k < i ± k < m + n} ° Y) ç Finite ±
	({k|k < i ± k < m + n} \ Y) ç FiniteÆ
	THEN1 (REPEAT strip_tac
		THEN bc_thm_tac Ä_finite_thm
		THEN ∂_tac¨{j|j < i}Æ THEN REPEAT strip_tac
		THEN PC_T1 "sets_ext1" prove_tac[]));
a(LEMMA_T¨
	≥i ç ({k|k < i ± k < m + n} ° Y) ±
	≥i ç ({k|k < i ± k < m + n} \ Y)Æ (±_THEN asm_tac)
	THEN1 (REPEAT strip_tac
		THEN PC_T1 "lin_arith" prove_tac[]));
a(ALL_FC_T rewrite_tac[size_singleton_¿_thm]);
a(PC_T1 "lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(rename_tac[(¨x'Æ, "s")] THEN ∂_tac¨aÆ
	THEN asm_rewrite_tac[]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[
	pc_rule1 "˙_lin_arith" prove_rule[]
	¨µx y z w:˙∑x + ~y = z + ~w § x + w = z + yÆ,
	Ó˙_plus_homomorphism_thm1, Ó˙_one_one_thm]);
a(LEMMA_T ¨{k|k < m + n} ° a = aÆ rewrite_thm_tac);
(* *** Goal "2.1.1" *** *)
a(REPEAT strip_tac THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2.1.2" *** *)
a(DROP_NTH_ASM_T 5 ante_tac);
a(lemma_tac ¨
	a Ä {i|i < m + n} ±
	({k|k < m + n} \ a) Ä {i|i < m + n} ±
	a ° ({k|k < m + n} \ a) = {} ±
	{k|k < m + n}  = a ¿ ({k|k < m + n} \ a)Æ 
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(POP_ASM_T (fn th => conv_tac( LEFT_C(once_rewrite_conv[th]))));
a(all_fc_tac[Ä_finite_thm]);
a(ante_tac(list_µ_elim[¨aÆ, ¨{k|k < m + n} \ aÆ] size_¿_thm));
a(asm_rewrite_tac[size_empty_thm]);
a(PC_T1 "lin_arith" prove_tac[]);
(* *** Goal "2.2" *** *)
a(rename_tac[(¨x'Æ, "s"), (¨x''Æ, "a")] THEN ∂_tac¨a:Ó SETÆ
	THEN asm_rewrite_tac[]);
a(rewrite_tac[
	pc_rule1 "˙_lin_arith" prove_rule[]
	¨µx y z w:˙∑x + ~y = z + ~w § x + w = z + yÆ,
	Ó˙_plus_homomorphism_thm1, Ó˙_one_one_thm]);
a(LEMMA_T ¨{k|k < m + n} ° a = aÆ rewrite_thm_tac);
(* *** Goal "2.2.1" *** *)
a(REPEAT strip_tac THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2.2.2" *** *)
a(lemma_tac ¨
	a Ä {i|i < m + n} ±
	({k|k < m + n} \ a) Ä {i|i < m + n} ±
	a ° ({k|k < m + n} \ a) = {} ±
	a ¿ ({k|k < m + n} \ a) = {k|k < m + n}Æ 
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
a(ante_tac(list_µ_elim[¨aÆ, ¨{k|k < m + n} \ aÆ] size_¿_thm));
a(asm_rewrite_tac[size_empty_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €walk_to_empty_thm› = save_thm ( "walk_to_empty_thm", (
set_goal([], ¨µn x y∑ 
	(µp q∑ ≥(p + q = n ± y = x + Ó˙ p - Ó˙ q))
§	WalkTo n x y = {}
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[walk_to_thm] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(POP_ASM_T (ante_tac o µ_elim¨nÆ)
	THEN rewrite_tac[] THEN contr_tac);
a(DROP_NTH_ASM_T 3 (ante_tac o list_µ_elim[
	¨# ({k|k < n} ° a)Æ,
	¨# ({k|k < n} \ a)Æ]));
a(asm_rewrite_tac[]);
a(lemma_tac¨
	({k|k < n} ° a) Ä {k|k < n}
±	({k|k < n } \ a) Ä {k|k < n}
±	({k|k < n} ° a) ° ({k|k < n} \ a) = {}
±	{k|k < n} = ({k|k < n} ° a) ¿ ({k|k < n} \ a)Æ
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(strip_asm_tac(µ_elim¨nÆ range_finite_size_thm));
a(POP_ASM_T ante_tac);
a(DROP_NTH_ASM_T 2 (fn th => conv_tac (LEFT_C(once_rewrite_conv[th]))));
a(all_fc_tac[Ä_finite_thm]);
a(LEMMA_T ¨# ({k|k < n} ° a ¿ {k|k < n} \ a) =
	# ({k|k < n} ° a ¿ {k|k < n} \ a) +
	# (({k|k < n} ° a) ° ({k|k < n} \ a))Æ
	once_rewrite_thm_tac
	THEN1 (asm_rewrite_tac[size_empty_thm]));
a(ALL_FC_T rewrite_tac[size_¿_thm]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac);
a(PC_T1 "sets_ext1" rewrite_tac[]);
a(rewrite_tac[walk_to_def, walk_def1]);
a(REPEAT strip_tac);
a(swap_nth_asm_concl_tac 1 THEN strip_tac
	THEN all_var_elim_asm_tac1);
a(∂_tac¨Ãk∑
	if k º p
	then x + Ó˙ k
	else if k º p + q
	then x + Ó˙ 2 * Ó˙ p - Ó˙ k
	else x + Ó˙ p - Ó˙ qÆ);
a(rewrite_tac[] THEN REPEAT
	(±_tac ORELSE µ_tac ORELSE ¥_tac));
(* *** Goal "2.1" *** *)
a(LEMMA_T¨m º p + q ± m + 1 º p + qÆ rewrite_thm_tac
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(cases_tac¨m + 1 º pÆ THEN asm_rewrite_tac[Ó˙_plus_homomorphism_thm]);
(* *** Goal "2.1.1" *** *)
a(≤_left_tac);
a(LEMMA_T¨m º pÆ rewrite_thm_tac
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(PC_T1 "˙_lin_arith" prove_tac[]);
(* *** Goal "2.1.2" *** *)
a(≤_right_tac);
a(cases_tac ¨m = pÆ
	THEN1 (asm_rewrite_tac[]
		THEN PC_T1 "˙_lin_arith" prove_tac[]));
a(LEMMA_T¨≥m º pÆ rewrite_thm_tac
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(PC_T1 "˙_lin_arith" prove_tac[]);
(* *** Goal "2.2" *** *)
a(cases_tac¨q = 0Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
a(all_var_elim_asm_tac1 THEN POP_ASM_T ante_tac
	THEN rewrite_tac[] THEN strip_tac);
a(cases_tac¨m = pÆ THEN1 asm_rewrite_tac[]);
a(LEMMA_T¨≥m º pÆ rewrite_thm_tac
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2.2.2" *** *)
a(LEMMA_T¨≥m º pÆ rewrite_thm_tac
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(cases_tac¨m = p + qÆ THEN1 asm_rewrite_tac[]);
a(LEMMA_T¨≥m º p + qÆ rewrite_thm_tac
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(rewrite_tac[Ó˙_plus_homomorphism_thm]);
a(PC_T1 "˙_lin_arith" prove_tac[]);
(* *** Goal "2.3" *** *)
a(cases_tac¨q = 0Æ THEN asm_rewrite_tac[Ó˙_plus_homomorphism_thm]
	THEN PC_T1 "˙_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €walk_to_finite_thm› = save_thm ( "walk_to_finite_thm", (
set_goal([], ¨µn x y∑ 
	WalkTo n x y ç Finite
Æ);
a(REPEAT strip_tac
	THEN cases_tac¨µ p q∑ ≥ (p + q = n ± y = x + Ó˙ p - Ó˙ q)Æ);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac [walk_to_empty_thm]);
a(rewrite_tac[empty_finite_thm]);
a(all_var_elim_asm_tac1);
a(rewrite_tac[walk_to_finite_size_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €walk_walk_to_thm› = save_thm ( "walk_walk_to_thm", (
set_goal([], ¨µm n x s∑ 
	m º n
±	s ç Walk n x
¥	(Ãk∑if k º m then s k else s m) ç WalkTo m x (s m)
Æ);
a(rewrite_tac[walk_def1, walk_to_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac);
a(LEMMA_T¨m' + 1 º m ± m' º mÆ rewrite_thm_tac
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(lemma_tac¨m' < nÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(REPEAT strip_tac);
a(spec_nth_asm_tac 5 ¨m'Æ);
(* *** Goal "2" *** *)
a(cases_tac¨m' º mÆ THEN asm_rewrite_tac[]);
a(LEMMA_T¨m' = mÆ rewrite_thm_tac
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €walk_shift_thm› = save_thm ( "walk_shift_thm", (
set_goal([], ¨µm n x∑ 
	s ç Walk (m + n) x
¥	(Ãk∑s (k + m)) ç Walk n (s m)
Æ);
a(rewrite_tac[walk_def1] THEN REPEAT (¥_tac ORELSE µ_tac ORELSE ±_tac));
(* *** Goal "1" *** *)
a(LEMMA_T¨(m' + 1) + m = (m' + m) + 1Æ rewrite_thm_tac
	THEN1 PC_T1 "lin_arith" prove_tac[]);
a(LEMMA_T ¨m' + m < m + nÆ asm_tac
	THEN1 asm_rewrite_tac[]);
a(LIST_DROP_NTH_ASM_T [4] fc_tac
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_T ¨m + n º m' + mÆ asm_tac
	THEN1 asm_rewrite_tac[]);
a(LIST_DROP_NTH_ASM_T[3] (ALL_FC_T rewrite_tac));
a(LEMMA_T¨m + n = n + mÆ rewrite_thm_tac THEN rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €walk_minus_thm› = save_thm ( "walk_minus_thm", (
set_goal([], ¨µs n x∑ 
	s ç Walk n x
¥	(Ãk∑~(s k)) ç Walk n (~x)
Æ);
a(rewrite_tac[walk_def1] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac);
a(rewrite_tac[pc_rule1 "˙_lin_arith" prove_rule[]
		¨µx y z:˙∑~x + y = z § x + ~y = ~zÆ]);
a(REPEAT strip_tac THEN spec_nth_asm_tac 4 ¨mÆ);
(* *** Goal "3" *** *)
a(LIST_DROP_NTH_ASM_T [2] (ALL_FC_T asm_rewrite_tac));
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €walk_to_minus_thm› = save_thm ( "walk_to_minus_thm", (
set_goal([], ¨µs n x y∑ 
	s ç WalkTo n x y
¥	(Ãk∑~(s k)) ç WalkTo n (~x) (~y)
Æ);
a(rewrite_tac[walk_to_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[walk_minus_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €walk_to_intermediate_value_thm› = save_thm ( "walk_to_intermediate_value_thm", (
set_goal([], ¨µn x y s z∑ 
	s ç WalkTo n x y
±	(x º z ± z º y ≤ y º z ± z º x)
¥	∂k∑k º n ± s k = z 
Æ);
a(lemma_tac¨µn x y s z∑ 
	s ç WalkTo n x y
±	(x º z ± z º y)
¥	∂k∑k º n ± s k = zÆ);
(* *** Goal "1" *** *)
a(µ_tac THEN induction_tac¨n:ÓÆ
	THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(DROP_NTH_ASM_T 3 (strip_asm_tac o
	rewrite_rule[walk_def1, walk_to_def]));
a(all_var_elim_asm_tac1);
a(∂_tac¨0Æ THEN rewrite_tac[]
	THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(GET_NTH_ASM_T 3 (strip_asm_tac o
	rewrite_rule[walk_def1, walk_to_def]));
a(DROP_NTH_ASM_T 3 (strip_asm_tac o µ_elim¨nÆ));
(* *** Goal "1.2.1" *** *)
a(cases_tac¨z = yÆ
	THEN1 (∂_tac¨n+1Æ THEN asm_rewrite_tac[]));
a(lemma_tac¨z º s nÆ THEN1 PC_T1 "˙_lin_arith" asm_prove_tac[]);
a(ante_tac (list_µ_elim[¨nÆ, ¨n+1Æ]walk_walk_to_thm)
	THEN rewrite_tac[]);
a(GET_NTH_ASM_T 9 (strip_asm_tac o
	rewrite_rule[walk_to_def]));
a(STRIP_T (fn th => all_fc_tac[th]));
a(DROP_NTH_ASM_T 12 (fn th => all_fc_tac[th]));
a(∂_tac¨kÆ THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2" *** *)
a(lemma_tac¨z º s n ± s 0 º s n Æ THEN1 PC_T1 "˙_lin_arith" asm_prove_tac[]);
a(ante_tac (list_µ_elim[¨nÆ, ¨n+1Æ]walk_walk_to_thm)
	THEN rewrite_tac[]);
a(GET_NTH_ASM_T 9 (strip_asm_tac o
	rewrite_rule[walk_to_def]));
a(STRIP_T (fn th => all_fc_tac[th]));
a(DROP_NTH_ASM_T 12 (fn th => all_fc_tac[th]));
a(∂_tac¨kÆ THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 4 bc_thm_tac THEN asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(all_fc_tac[walk_to_minus_thm]);
a(lemma_tac¨~x º ~z ± ~z º ~yÆ THEN1 PC_T1 "˙_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [7] all_fc_tac);
a(∂_tac¨kÆ THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(PC_T1 "˙_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
(*
drop_main_goal();
*)
push_goal([], ¨µp q; x y z w:˙∑
	((x = if p then y else z)
§	(if p then x = y else x = z))
±	((x = ~(if p then y else z))
§	(if p then x = ~y else x = ~z))
±	(((if p then y else z) < w)
§	(if p then y < w else z < w))
±	((if p then q else T) § ≥p ≤ q)
±	((if p then T else q) § p ≤ q)
Æ);
a(REPEAT µ_tac THEN cases_tac¨p:BOOLÆ
	THEN asm_rewrite_tac[]);
val €if_out_lemma› = pop_thm();
=TEX
%%%%
%%%%
=SML
(*
drop_main_goal();
*)
push_goal([], ¨µp; x :˙∑
	(if p then x else ~x) = Ó˙ 0 
§	x = Ó˙ 0Æ);
a(REPEAT µ_tac THEN cases_tac¨p:BOOLÆ
	THEN asm_rewrite_tac[]
	THEN PC_T1 "˙_lin_arith" prove_tac[]);
val €if_plus_minus_lemma› = pop_thm();
=TEX
%%%%
%%%%
=SML
val €walk_to_reflection_thm› = save_thm ( "walk_to_reflection_thm", (
set_goal([], ¨µm n k z∑ 
	Ó˙ 0 < z ± 0 < k ± n < k + m
¥	#(WalkTo (m+n) (~(Ó˙ k)) z) =
	#{s | s ç WalkTo (m+n) (Ó˙ k) z
		± ∂i∑s i = Ó˙ 0}
Æ);
a(REPEAT µ_tac THEN ¥_tac THEN conv_tac eq_sym_conv);
a(bc_thm_tac (taut_rule¨µp∑
	{s | s ç WalkTo (m+n) (Ó˙ k) z
	 ± ∂i∑s i = Ó˙ 0} ç Finite ± p ¥ pÆ));
a(MAP_EVERY ∂_tac [¨zÆ, ¨kÆ, ¨nÆ, ¨mÆ]);
a(lemma_tac¨µs∑
	s ç WalkTo (m + n) (~ (Ó˙ k)) z
¥	s (Min {l | s l = Ó˙ 0}) = Ó˙ 0
±	(µk∑s k = Ó˙ 0 ¥ Min {l | s l = Ó˙ 0} º k)
Æ);
(* *** Goal "1" *** *)
a(REPEAT µ_tac THEN ¥_tac);
a(lemma_tac¨∂j∑j º m + n ± s j = Ó˙ 0Æ);
(* *** Goal "1.1" *** *)
a(pure_rewrite_tac[pc_rule1 "˙_lin_arith" prove_rule[]
	¨Ó˙ 0 = ~(Ó˙ k) + Ó˙ kÆ]
	THEN bc_thm_tac walk_to_intermediate_value_thm);
a(∂_tac¨ z Æ THEN ∂_tac¨~ (Ó˙ k) Æ);
a(asm_rewrite_tac[pc_rule1 "˙_lin_arith" prove_rule[]
	¨µa b c:˙∑ (~a º b + ~c § c º a + b)Æ,
	Ó˙_plus_homomorphism_thm1, Ó˙_º_thm]);
a(REPEAT strip_tac THEN
	PC_T1 "˙_lin_arith" asm_prove_tac[]
	ORELSE PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(strip_asm_tac (list_µ_elim[¨jÆ, ¨{l | s l = Ó˙ 0}Æ] min_ç_thm)
	THEN REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim[¨k'Æ, ¨{l | s l = Ó˙ 0}Æ] min_º_thm)
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(bc_thm_tac bijection_finite_size_thm);
a(∂_tac¨Ãs∑Ãj∑ if Min{l | s l = Ó˙ 0} º j then s j else ~(s j)Æ
	THEN rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[walk_to_finite_thm]);
(* *** Goal "2.2" *** *)
a(LEMMA_T¨µ x'∑
	(if Min {l|x l = Ó˙ 0} º x' then x x' else ~ (x x')) = Ó˙ 0
§	(if Min {l|y l = Ó˙ 0} º x' then y x' else ~ (y x')) = Ó˙ 0Æ ante_tac
	THEN1 asm_rewrite_tac[]);
a(rewrite_tac[if_plus_minus_lemma] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
a(STRIP_T (ante_tac o µ_elim¨x'Æ));
a(cases_tac¨Min {l|y l = Ó˙ 0} º x'Æ
	THEN asm_rewrite_tac[]
	THEN PC_T1 "˙_lin_arith" prove_tac[]);
(* *** Goal "2.3" *** *)
a(PC_T1"sets_ext1" REPEAT strip_tac);
(* *** Goal "2.3.1" *** *)
a(rename_tac[(¨xÆ, "s")]
	THEN ∂_tac¨Ãj:Ó∑
		if Min {l | s l = Ó˙ 0} º j
		then s j
		else ~(s j)Æ);
a(DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac[walk_def1, walk_to_def]
	THEN strip_tac);
a(lemma_tac¨Min {l|s l = Ó˙ 0} º m + nÆ);
(* *** Goal "2.3.1.1" *** *)
a(bc_thm_tac º_trans_thm);
a(cases_tac¨i º m + nÆ 
	THEN1 (∂_tac¨iÆ THEN REPEAT strip_tac
		THEN bc_thm_tac min_º_thm
		THEN REPEAT strip_tac));
a(lemma_tac¨m + n º iÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(∂_tac¨m+nÆ THEN REPEAT strip_tac);
a(bc_thm_tac min_º_thm THEN rewrite_tac[]);
a(SPEC_NTH_ASM_T 4 ¨iÆ ante_tac);
a(POP_ASM_T rewrite_thm_tac);
a(STRIP_T (rewrite_thm_tac o eq_sym_rule));
a(REPEAT strip_tac);
(* *** Goal "2.3.1.2" *** *)
a(REPEAT (±_tac ORELSE µ_tac ORELSE ¥_tac)
	THEN1 asm_rewrite_tac[]);
(* *** Goal "2.3.1.2.1" *** *)
a(LEMMA_T ¨≥Min {l|s l = Ó˙ 0} = 0Æ rewrite_thm_tac
	THEN contr_tac);
a(ante_tac (list_µ_elim[¨iÆ, ¨{l | s l = Ó˙ 0}Æ] min_ç_thm));
a(asm_rewrite_tac[Ó˙_one_one_thm]
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2.3.1.2.2" *** *)
a(CASES_T ¨Min {l|s l = Ó˙ 0} º m'Æ
	(fn th => rewrite_thm_tac th 
		THEN strip_asm_tac th));
(* *** Goal "2.3.1.2.2.1" *** *)
a(LEMMA_T¨Min {l|s l = Ó˙ 0} º m' + 1Æ
	rewrite_thm_tac
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 6 ¨m'Æ
	THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
(* *** Goal "2.3.1.2.2.2" *** *)
a(CASES_T ¨Min {l|s l = Ó˙ 0} º m' + 1Æ
	(fn th => rewrite_thm_tac th 
		THEN strip_asm_tac th));
(* *** Goal "2.3.1.2.2.2.1" *** *)
a(lemma_tac¨Min {l|s l = Ó˙ 0} = m' + 1Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(ante_tac (list_µ_elim[¨iÆ, ¨{l | s l = Ó˙ 0}Æ] min_ç_thm));
a(asm_rewrite_tac[] THEN strip_tac);
a(SPEC_NTH_ASM_T 9 ¨m'Æ ante_tac);
a(LIST_GET_NTH_ASM_T [1, 5] rewrite_tac);
a(PC_T1"˙_lin_arith" prove_tac[]);
(* *** Goal "2.3.1.2.2.2.2" *** *)
a(SPEC_NTH_ASM_T 7 ¨m'Æ ante_tac);
a(LIST_GET_NTH_ASM_T [3] rewrite_tac);
a(PC_T1"˙_lin_arith" prove_tac[]);
(* *** Goal "2.3.1.2.3" *** *)
a(LEMMA_T¨Min {l|s l = Ó˙ 0} º m'Æ asm_rewrite_thm_tac
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [4] (ALL_FC_T asm_rewrite_tac));
(* *** Goal "2.3.1.2.4" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2.3.1.2.5" *** *)
a(rewrite_tac[if_plus_minus_lemma, if_out_lemma]);
a(cases_tac¨Min {l|s l = Ó˙ 0} º x''Æ
	THEN asm_rewrite_tac[]);
(* *** Goal "2.3.2" *** *)
a(rename_tac[(¨x'Æ, "s")]
	THEN DROP_NTH_ASM_T 3 (strip_asm_tac o µ_elim¨s:Ó≠˙Æ));
a(DROP_NTH_ASM_T 4 ante_tac THEN rewrite_tac[walk_def1, walk_to_def]
	THEN strip_tac);
a(lemma_tac¨Min {l|s l = Ó˙ 0} º m + nÆ);
(* *** Goal "2.3.2.1" *** *)
a(bc_thm_tac º_trans_thm);
a(cases_tac¨Min {l|s l = Ó˙ 0} º m + nÆ 
	THEN1 (∂_tac¨Min {l|s l = Ó˙ 0}Æ
		THEN REPEAT strip_tac
		THEN bc_thm_tac min_º_thm
		THEN REPEAT strip_tac));
a(lemma_tac¨m + n º Min {l|s l = Ó˙ 0}Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(∂_tac¨m+nÆ THEN REPEAT strip_tac);
a(bc_thm_tac min_º_thm THEN rewrite_tac[]);
a(SPEC_NTH_ASM_T 4 ¨Min {l|s l = Ó˙ 0}Æ ante_tac);
a(POP_ASM_T rewrite_thm_tac);
a(STRIP_T (rewrite_thm_tac o eq_sym_rule));
a(REPEAT strip_tac);
(* *** Goal "2.3.2.2" *** *)
a(REPEAT (±_tac ORELSE µ_tac ORELSE ¥_tac)
	THEN asm_rewrite_tac[]);
(* *** Goal "2.3.2.2.1" *** *)
a(LEMMA_T ¨≥Min {l|s l = Ó˙ 0} = 0Æ rewrite_thm_tac);
a(swap_nth_asm_concl_tac 7 THEN asm_rewrite_tac[]);
a(LEMMA_T ¨Ó˙ 0 < Ó˙ kÆ ante_tac	
	THEN1 asm_rewrite_tac[Ó˙_less_thm]);
a(PC_T1"˙_lin_arith" prove_tac[]);
(* *** Goal "2.3.2.2.2" *** *)
a(CASES_T ¨Min {l|s l = Ó˙ 0} º m'Æ
	(fn th => rewrite_thm_tac th 
		THEN strip_asm_tac th));
(* *** Goal "2.3.2.2.2,1" *** *)
a(LEMMA_T¨Min {l|s l = Ó˙ 0} º m' + 1Æ
	rewrite_thm_tac
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 6 ¨m'Æ
	THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
(* *** Goal "2.3.2.2.2.2" *** *)
a(CASES_T ¨Min {l|s l = Ó˙ 0} º m' + 1Æ
	(fn th => rewrite_thm_tac th 
		THEN strip_asm_tac th));
a(lemma_tac¨Min {l|s l = Ó˙ 0} = m' + 1Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 11 ante_tac);
a(asm_rewrite_tac[] THEN strip_tac);
a(SPEC_NTH_ASM_T 9 ¨m'Æ ante_tac);
a(LIST_GET_NTH_ASM_T [1, 5] rewrite_tac);
a(PC_T1"˙_lin_arith" prove_tac[]);
(* *** Goal "2.3.2.2.2.2.2" *** *)
a(SPEC_NTH_ASM_T 7 ¨m'Æ ante_tac);
a(LIST_GET_NTH_ASM_T [3] rewrite_tac);
a(PC_T1"˙_lin_arith" prove_tac[]);
(* *** Goal "2.3.2.3" *** *)
a(LEMMA_T¨Min {l|s l = Ó˙ 0} º m'Æ asm_rewrite_thm_tac
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [4] (ALL_FC_T asm_rewrite_tac));
(* *** Goal "2.3.3" *** *)
a(rename_tac[(¨x'Æ, "s")]
	THEN DROP_NTH_ASM_T 3 (strip_asm_tac o µ_elim¨s:Ó≠˙Æ));
a(∂_tac¨Min {l|s l = Ó˙ 0}Æ THEN asm_rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ballot_lemma1› = save_thm ( "ballot_lemma1", (
set_goal([], ¨µm n y∑
	#{s | s ç WalkTo (m+n+1) (Ó˙ 0) y ± µi∑Ó˙ 0 < s (i+1)} =
	#{s | s ç WalkTo (m+n) (Ó˙ 1) y ± µ i∑ Ó˙ 0 < s i}
Æ);
a(REPEAT µ_tac);
a(bc_thm_tac (taut_rule¨µp∑
	{s | s ç WalkTo (m+n+1) (Ó˙ 0) y ± µi∑Ó˙ 0 < s (i+1)} ç Finite ± p ¥ pÆ));
a(MAP_EVERY ∂_tac [¨yÆ, ¨nÆ, ¨mÆ]);
a(bc_thm_tac bijection_finite_size_thm1);
a(∂_tac¨Ãs∑Ãk∑s(k+1)Æ);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ä_finite_thm
	THEN ∂_tac¨ WalkTo (m + n) (Ó˙ 1) y Æ
	THEN rewrite_tac[walk_to_finite_thm]
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[]
	THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o rewrite_rule[walk_def1, walk_to_def]));
a(DROP_NTH_ASM_T 8 (strip_asm_tac o rewrite_rule[walk_def1, walk_to_def]));
a(strip_asm_tac(µ_elim¨x'ÆÓ_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(rewrite_tac[]);
a(lemma_tac¨∂s∑s 0 = Ó˙ 0 ± µk∑s(k+1) = x kÆ
	THEN1 prove_∂_tac);
a(∂_tac¨sÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 4 ante_tac
	THEN rewrite_tac[walk_to_def, walk_def1]
	THEN REPEAT (µ_tac ORELSE ¥_tac ORELSE ±_tac)
	THEN1 asm_rewrite_tac[]);
(* *** Goal "3.1" *** *)
a(strip_asm_tac(µ_elim¨m'Æ Ó_cases_thm)
	THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 5 bc_thm_tac);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "3.2" *** *)
a(POP_ASM_T (strip_asm_tac o 
	once_rewrite_rule[plus_comm_thm] o rewrite_rule[º_def]));
a(all_var_elim_asm_tac1 THEN asm_rewrite_tac[plus_assoc_thm1]);
a(POP_ASM_T bc_thm_tac THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "3.3" *** *)
a(asm_rewrite_tac[plus_assoc_thm1]);
(* *** Goal "4" *** *)
a(all_var_elim_asm_tac1 THEN rewrite_tac[]);
a(DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac[walk_to_def, plus_assoc_thm]
	THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[walk_def1]));
a(DROP_NTH_ASM_T 2 (ante_tac o µ_elim¨0Æ));
a(asm_rewrite_tac[plus_assoc_thm1]);
a(REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(bc_thm_tac walk_shift_thm);
a(∂_tac¨Ó˙ 0Æ THEN asm_rewrite_tac[pc_rule1"lin_arith" prove_rule[]
	¨1 + m + n = m + n + 1Æ]);
(* *** Goal "4.2" *** *)
a(SPEC_NTH_ASM_T 6 ¨0Æ ante_tac);
a(POP_ASM_T rewrite_thm_tac);
(* *** Goal "5" *** *)
a(all_var_elim_asm_tac1 THEN asm_rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ballot_lemma2› = save_thm ( "ballot_lemma2", (
set_goal([], ¨µm n∑ 
	0 < n ± n < m + 1
¥	ÓØ(#{s | s ç WalkTo (m+n+1) (Ó˙ 0) (Ó˙ (m+1) - Ó˙ n)
		± µi∑Ó˙ 0 < s (i+1)}) =
	ÓØ(Binomial (m + n) m) - ÓØ(Binomial (m+n) (m+1))Æ);
a(REPEAT strip_tac);
a(pure_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
	¨µx y z:Ø∑x = y - z § y = x + zÆ,
	ÓØ_plus_homomorphism_thm1, ÓØ_one_one_thm,
	ballot_lemma1]);
a(strip_asm_tac (µ_elim ¨mÆ Ó_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN rename_tac[(¨i:ÓÆ, "M")]
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(strip_asm_tac (µ_elim ¨nÆ Ó_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN rename_tac[(¨i:ÓÆ, "N")]);
a(pure_rewrite_tac[
	conv_rule(ONCE_MAP_C eq_sym_conv)
		(list_µ_elim[¨Ó˙ 1Æ, ¨M+1Æ, ¨N+1Æ]
			walk_to_finite_size_thm),
	rewrite_rule[pc_rule1"lin_arith" prove_rule[]
		¨((M+1)+1)+N = ((M+1)+N+1)Æ]
	(conv_rule(ONCE_MAP_C eq_sym_conv)
		(list_µ_elim[¨~(Ó˙ 1)Æ, ¨(M+1)+1Æ, ¨NÆ]
			walk_to_finite_size_thm))]);
a(rewrite_tac[Ó˙_plus_homomorphism_thm]
	THEN conv_tac (ONCE_MAP_C ˙_anf_conv));
a(ante_tac(
	list_µ_elim[¨M+1Æ, ¨N+1Æ, ¨1Æ,
			¨Ó˙ 1 + Ó˙ M + ~ (Ó˙ N)Æ]
	walk_to_reflection_thm));
a(LEMMA_T¨Ó˙ 0 < Ó˙ 1 + Ó˙ M + ~(Ó˙ N)Æ asm_rewrite_thm_tac
	THEN1 asm_rewrite_tac[pc_rule1"˙_lin_arith" prove_rule[]
	¨µa b c ∑ Ó˙ 0 < a + b + ~c § c < b + aÆ,
	Ó˙_plus_homomorphism_thm1, Ó˙_less_thm]);
a(STRIP_T rewrite_thm_tac);
a(bc_thm_tac size_disjoint_¿_thm);
a(rewrite_tac[walk_to_finite_thm]);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(GET_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[walk_to_def]));
a(lemma_tac¨∂j∑j º (M+1) + N + 1 ± x j º Ó˙ 0Æ
	THEN cases_tac¨M' º (M+1)+N+1Æ
	THEN1 (∂_tac¨M'Æ
		THEN REPEAT strip_tac
		THEN PC_T1 "˙_lin_arith" asm_prove_tac[]));
(* *** Goal "1.1" *** *)
a(∂_tac¨(M+1)+N+1Æ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o rewrite_rule[walk_def1]));
a(lemma_tac¨(M+1)+N+1 º M'Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 7 ante_tac);
a(LIST_DROP_NTH_ASM_T [2] (ALL_FC_T rewrite_tac));
(* *** Goal "1.2" *** *)
a(LIST_DROP_NTH_ASM_T [1, 6] discard_tac);
a(all_fc_tac[walk_walk_to_thm]);
a(LEMMA_T¨Ó˙ 0 º Ó˙ 1Æ asm_tac THEN1 rewrite_tac[]);
a(all_fc_tac[walk_to_intermediate_value_thm]);
a(∂_tac¨kÆ THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.3" *** *)
a(all_fc_tac[walk_walk_to_thm]);
a(LEMMA_T¨Ó˙ 0 º Ó˙ 1Æ asm_tac THEN1 rewrite_tac[]);
a(all_fc_tac[walk_to_intermediate_value_thm]);
a(∂_tac¨kÆ THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(SPEC_NTH_ASM_T 2 ¨iÆ ante_tac);
a(asm_rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
set_goal([], ¨µm n k∑
	(ÓØ(m!) * ÓØ(n!) õ-õ1 * ÓØ(k!) õ-õ1) õ-õ1 = ÓØ(m!) õ-õ1 * ÓØ(n!) * ÓØ(k!)Æ);
a(REPEAT µ_tac);
a(strip_asm_tac(µ_elim¨nÆ factorial_not_0_thm));
a(strip_asm_tac(µ_elim¨kÆ factorial_not_0_thm));
a(all_fc_tac[Ø_≥_recip_0_thm]);
a(strip_asm_tac(µ_elim¨mÆ factorial_not_0_thm));
a(lemma_tac ¨≥ÓØ(n!) õ-õ1 * ÓØ(k!) õ-õ1 = ÓØ 0Æ
	THEN1 asm_rewrite_tac[Ø_times_eq_0_thm]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
val  €ballot_lemma3a› = pop_thm();
=TEX
%%%%
%%%%
=SML
val €ballot_lemma3› = save_thm ( "ballot_lemma3", (
set_goal([], ¨µm n∑
	0 < n ± n < m + 1
¥	(ÓØ (Binomial (m + n) m) - ÓØ (Binomial (m + n) (m + 1))) *
	ÓØ(Binomial (m+n+1) (m+1)) õ-õ1 =
	((m + 1) - n) / ((m+1) + n) Æ);
a(REPEAT strip_tac);
a(rewrite_tac[Ø_frac_def]);
a(lemma_tac¨≥ÓØ((m+1)+n) = ÓØ 0Æ
	THEN1 (rewrite_tac[ÓØ_one_one_thm]
		THEN PC_T1"lin_arith" asm_prove_tac[]));
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(ALL_FC_T1 fc_§_canon once_rewrite_tac[conv_rule(ONCE_MAP_C (RIGHT_C eq_sym_conv)) Ø_times_cancel_thm]);
a(rewrite_tac[Ø_times_assoc_thm]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(POP_ASM_T discard_tac);
a(LEMMA_T¨1 º n ± n º mÆ (strip_asm_tac o
	once_rewrite_rule[plus_comm_thm] o
	rewrite_rule[º_def])
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]
	THEN all_var_elim_asm_tac1);
a(rename_tac[(¨i'Æ, "M"), (¨iÆ, "N")]
	THEN rewrite_tac[binomial_factorial_thm]);
a(rewrite_tac[pc_rule1"lin_arith" prove_rule[]
	¨(M + N + 1) + N + 1 = ((M + N + 1) + 1) + N
	± ((M + N + 1) + (N + 1) + 1) = ((M + N + 1) + 1) + (N+1)Æ,
	binomial_factorial_thm]);
a(rewrite_tac[pc_rule1"lin_arith" prove_rule[]
	¨(M + N + 1) + 1 = (M + 1) + (N + 1)Æ,
	Ø_times_plus_distrib_thm]);
a(rewrite_tac[ballot_lemma3a]);
a(rewrite_tac[µ_elim¨ÓØ((((M + 1) + N + 1) + N + 1)!) õ-õ1Æ
	Ø_times_order_thm]);
a(rewrite_tac[µ_elim¨ÓØ(((M + 1) + N + 1) + N + 1)Æ
	Ø_times_order_thm]);
a(rewrite_tac[Ø_times_assoc_thm1,
	plus_assoc_thm1,
	factorial_times_recip_thm]);
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µx y:Ø∑x * ~y = ~(x*y)Æ,
	Ø_times_assoc_thm1,
	factorial_times_thm]);
a(rewrite_tac[µ_elim¨ÓØ((N + 1)!)Æ	Ø_times_order_thm]);
a(rewrite_tac[µ_elim¨ÓØ((N + 1)!) õ-õ1Æ	Ø_times_order_thm]);
a(rewrite_tac[Ø_times_assoc_thm1,
	factorial_times_thm]);
a(rewrite_tac[µ_elim¨ÓØ((((M + 1) + N) + 1)!)Æ Ø_times_order_thm]);
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µx y:Ø ∑ ~(x*y) = x * ~yÆ,
	µ_elim¨ÓØ((((M + 1) + N) + 1)!) õ-õ1Æ Ø_times_order_thm]);
a(rewrite_tac[Ø_times_assoc_thm1,
	factorial_times_thm]);
a(conv_tac(ONCE_MAP_C (LEFT_C(RAND_C (eq_match_conv (±_right_elim factorial_def))))));
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µx y:Ø ∑ x * ~y = ~(x * y)Æ,
pc_rule1 "lin_arith" prove_rule[]
	¨(M + 1) + N = (M + N) + 1Æ,
	Ø_times_assoc_thm,
	ÓØ_times_homomorphism_thm,
	factorial_times_thm]);
a(rewrite_tac[ÓØ_plus_homomorphism_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ballot_lemma4› = save_thm ( "ballot_lemma4", (
set_goal([], ¨µm n∑
	≥ #(WalkTo (m + n) (Ó˙ 0) (Ó˙ m - Ó˙ n)) = 0
Æ);
a(REPEAT µ_tac);
a(lemma_tac¨WalkTo (m + n) (Ó˙ 0) (Ó˙ m - Ó˙ n) ç FiniteÆ
	THEN1 rewrite_tac[walk_to_finite_thm]);
a(ALL_FC_T1 fc_§_canon rewrite_tac[size_0_thm]);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) walk_to_empty_thm]);
a(REPEAT strip_tac THEN ∂_tac¨mÆ);
a(REPEAT strip_tac THEN ∂_tac¨nÆ THEN REPEAT strip_tac);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ballot_lemma5› = save_thm ( "ballot_lemma5", (
set_goal([], ¨µm∑
	let	S = WalkTo m (Ó˙ 0) (Ó˙ m)
	in let	X = {s | s ç S ± µ i∑ Ó˙ 0 < s (i+1)}
	in	0 < m ¥ X = S
Æ);
a(rewrite_tac[let_def] THEN REPEAT strip_tac);
a(PC_T "sets_ext1" strip_tac THEN rewrite_tac[]);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨Ó˙ 0Æ, ¨mÆ, ¨0Æ]
	walk_to_finite_size_thm));
a(rewrite_tac[binomial_eq_thm]);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(ALL_FC_T1 fc_§_canon rewrite_tac[size_1_thm]);
a(REPEAT strip_tac);
a(lemma_tac¨(Ãk∑if k º m then Ó˙ k else Ó˙ m) ç WalkTo m (Ó˙ 0) (Ó˙ m)Æ
	THEN1 rewrite_tac[walk_to_def, walk_def1]
	THEN REPEAT (µ_tac ORELSE ¥_tac ORELSE ±_tac));
(* *** Goal "1" *** *)
a(LEMMA_T ¨m' + 1 º m ± m' º mÆ asm_rewrite_thm_tac
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(rewrite_tac[Ó˙_plus_homomorphism_thm]);
a(PC_T1 "˙_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(cases_tac¨m' = mÆ THEN1 asm_rewrite_tac[]);
a(LEMMA_T¨≥m' º mÆ rewrite_thm_tac
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(DROP_NTH_ASM_T 2 (fn th =>
	all_asm_ante_tac THEN rewrite_tac[th]
	THEN REPEAT strip_tac));
a(POP_ASM_T (asm_rewrite_thm_tac o conv_rule(ONCE_MAP_C eq_sym_conv)));
a(cases_tac¨i + 1 º mÆ THEN asm_rewrite_tac[Ó˙_less_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €ballot_thm› = save_thm ( "ballot_thm", (
set_goal([], ¨µm n∑
	let	S = BallotCounts m n
	in let	X = {s | s ç S ± µ i∑ Ó˙ 0 < s (i+1)}
	in	S ç Finite
	±	≥#S = 0
	±	X Ä S
	±	(n < m ¥ #X / #S = (m - n) / (m + n))
Æ);
a(once_rewrite_tac[taut_rule¨µp1 p2 p3 p4∑
	p1 ± p2 ± p3 ± p4 § p3 ± p1 ± (p1 ¥ p2) ± (p1 ± p2 ¥ p4)Æ]);
a(rewrite_tac[let_def, ballot_counts_def]);
a(REPEAT strip_tac THEN1 PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1" *** *)
a(rewrite_tac[walk_to_finite_thm]);
(* *** Goal "2" *** *)
a(ALL_FC_T1 fc_§_canon rewrite_tac[size_0_thm]);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) walk_to_empty_thm]);
a(REPEAT strip_tac THEN ∂_tac¨mÆ);
a(REPEAT strip_tac THEN ∂_tac¨nÆ THEN rewrite_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨≥ÓØ (m + n) = ÓØ 0
	± ≥ÓØ (# (WalkTo (m + n) (Ó˙ 0) (Ó˙ m + ~ (Ó˙ n)))) = ÓØ 0Æ
	THEN1 (rewrite_tac[ÓØ_one_one_thm]
		THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(rewrite_tac[Ø_frac_def] THEN
	ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(strip_asm_tac (µ_elim¨nÆ Ó_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN rename_tac[(¨i:ÓÆ, "N")]);
(* *** Goal "3.1" *** *)
a(DROP_NTH_ASM_T 3 (fn th =>
	all_asm_ante_tac THEN rewrite_tac[]
	THEN asm_tac th));
a(ALL_FC_T rewrite_tac[rewrite_rule[let_def] ballot_lemma5]);
a(REPEAT strip_tac THEN ALL_FC_T rewrite_tac[Ø_recip_clauses]);
(* *** Goal "3.2" *** *)
a(strip_asm_tac (µ_elim¨mÆ Ó_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN rename_tac[(¨i:ÓÆ, "M")]);
a(ante_tac(list_µ_elim[¨MÆ, ¨N+1Æ] ballot_lemma2));
a(asm_rewrite_tac[Ó˙_plus_homomorphism_thm,
	pc_rule1 "lin_arith" prove_rule[]
	¨(M + (N + 1) + 1) = (M + 1) + N + 1Æ]
	THEN conv_tac(ONCE_MAP_C ˙_anf_conv));
a(STRIP_T rewrite_thm_tac);
a(ante_tac(±_right_elim(list_µ_elim[¨Ó˙ 0Æ, ¨M+1Æ, ¨N+1Æ] walk_to_finite_size_thm)));
a(asm_rewrite_tac[Ó˙_plus_homomorphism_thm]
	THEN conv_tac(ONCE_MAP_C ˙_anf_conv));
a(STRIP_T rewrite_thm_tac);
a(ante_tac(list_µ_elim[¨MÆ, ¨N+1Æ] ballot_lemma3));
a(asm_rewrite_tac [] THEN conv_tac(ONCE_MAP_C anf_conv));
a(STRIP_T rewrite_thm_tac);
a(lemma_tac¨≥ÓØ(2 + M + N) = ÓØ 0Æ
	THEN1 (rewrite_tac[ÓØ_one_one_thm]
		THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(rewrite_tac[Ø_frac_def] THEN
	ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
pop_thm()
));

=TEX
=SML
set_goal([], ¨µ u a b∑ Nest u ± a ç u ± b ç u ¥ a ¿ b ç uÆ);
a(rewrite_tac[nest_def] THEN REPEAT strip_tac);
a(lemma_tac¨a Ä b ≤ b Ä aÆ
	THEN1 (DROP_NTH_ASM_T 3 bc_thm_tac THEN REPEAT strip_tac)
	THEN ALL_FC_T asm_rewrite_tac[
		pc_rule1 "sets_ext1" prove_rule[]
			¨µA B∑A Ä B ¥ A ¿ B = B ± B ¿ A = BÆ]);
val €ç_nest_¿_thm› = pop_thm () (* "ç_nest_¿_thm"; *);
=TEX
=SML
set_goal([], ¨µ u∑
	(µv∑ v ç u ¥ Nest v)
±	Nest u
¥	Nest(ﬁu)Æ);
a(REPEAT strip_tac THEN
	rewrite_tac[nest_def] THEN REPEAT_UNTIL is_≤ strip_tac);
a(LEMMA_T¨Nest(s ¿ s')Æ(bc_thm_tac o rewrite_rule[nest_def])
	THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 6 bc_thm_tac);
a(all_fc_tac[ç_nest_¿_thm]);
val €nest_nest_ﬁ_thm› = pop_thm () (* "nest_nest_ﬁ_thm"; *);
=TEX
=SML
set_goal([], ¨µ u a∑
	Nest u
±	ﬁu Ä a
¥	Nest(u ¿ {a})Æ);
a(rewrite_tac[nest_def] THEN REPEAT_UNTIL is_≤ strip_tac
	THEN_TRY all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 3 discard_tac);
a(≤_left_tac THEN PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(DROP_NTH_ASM_T 3 discard_tac);
a(≤_right_tac THEN PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "4" *** *)
a(REPEAT strip_tac);
val €nest_¿_upb_thm› = pop_thm () (* "nest_¿_upb_thm"; *);
=TEX
=SML
set_goal([], ¨µ u∑
	≥ u = {}
±	NestClosed u
¥	(∂ a∑ MaximalâÄ u a)Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂N∑MaximalâÄ {n | n Ä u ± Nest n} NÆ);
(* *** Goal "1" *** *)
a(bc_thm_tac zorn_thm1 THEN all_asm_ante_tac);
a(rewrite_tac[subset_closed_def, nest_closed_def]
	THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(∂_tac¨{}Æ THEN rewrite_tac[nest_def]);
(* *** Goal "1.2" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "1.3" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac[nest_def]
	THEN REPEAT_UNTIL is_≤ strip_tac);
a(DROP_NTH_ASM_T 3 bc_thm_tac
	THEN PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "1.4" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.5" *** *)
a(bc_thm_tac nest_nest_ﬁ_thm THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨ﬁNÆ THEN POP_ASM_T ante_tac
	THEN rewrite_tac[maximalâÄ_def]
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 4 (bc_thm_tac o rewrite_rule[nest_closed_def])
	THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(bc_tac(map (pc_rule1 "sets_ext1" prove_rule[])
	[¨µA B∑A Ä B ± B Ä A ¥ A = BÆ,
	¨µA U∑ A ç U ¥ A Ä ﬁUÆ,
	¨µx A∑ A ¿ {x} = A ¥ x ç AÆ])
	THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 bc_thm_tac);
a(asm_rewrite_tac[pc_rule1 "sets_ext1" prove_rule[]
	¨µA B C x∑ A Ä A ¿ B ±
		(A ¿ B Ä C § A Ä C ± B Ä C) ±
		({x} Ä A § x ç A)Æ]);
a(bc_thm_tac nest_¿_upb_thm THEN REPEAT strip_tac);
val €zorn_nearly_there_thm› = pop_thm ();
=TEX
=SML
val €zorn_thm2› = save_thm ( "zorn_thm2", (
set_goal([], ¨µ u∑
	≥ u = {}
±	(µ v∑ ≥v = {} ± v Ä u ± Nest v ¥ ﬁ v ç u)
¥	(∂ a∑ MaximalâÄ u a)Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂a∑MaximalâÄ (u ¿ {{}}) aÆ);
a(bc_thm_tac zorn_nearly_there_thm THEN rewrite_tac[nest_closed_def]
	THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(bc_thm_tac (pc_rule1 "sets_ext1" prove_rule[]
	¨µa b∑≥a = {} ¥ ≥a ¿ b = {}Æ)
	THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(swap_nth_asm_concl_tac 2);
a(once_rewrite_tac[pc_rule1 "sets_ext1" prove_rule []
	¨µU∑ﬁU = ﬁ(U \ {{}})Æ]
	THEN DROP_NTH_ASM_T 4 bc_thm_tac
	THEN REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(swap_nth_asm_concl_tac 1 THEN
	once_rewrite_tac[pc_rule1 "sets_ext1" prove_rule []
	¨µU∑ﬁU = ﬁ(U \ {{}})Æ]
	THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.2.3" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac[nest_def]
	THEN REPEAT_UNTIL is_≤ strip_tac);
a(DROP_NTH_ASM_T 5 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(∂_tac¨aÆ THEN POP_ASM_T ante_tac 
	THEN rewrite_tac[maximalâÄ_def]
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 4 (PC_T1 "sets_ext1" strip_asm_tac)
	THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o µ_elim¨xÆ)
	THEN all_var_elim_asm_tac1);
(* *** Goal "2.3" *** *)
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN REPEAT strip_tac);
pop_thm()
));

=TEX
=SML
val €fund_region_thm› = save_thm ( "fund_region_thm", (
set_goal([], ¨µf X∑
	f ç Involution X
¥	∂A∑ 	A Ä X
	±	µx∑
		(x ç A ¥ ≥f x ç A)
	±	(x ç X ± ≥x ç A ± ≥f x ç A ¥ x ç Fixed f)
Æ);
a(rewrite_tac[involution_def, fixed_def] THEN REPEAT strip_tac);
a(LEMMA_T¨∂A∑ MaximalâÄ {B | B Ä X ± µy∑ y ç B ¥ ≥f y ç B} AÆ
	(strip_asm_tac o rewrite_rule[maximalâÄ_def]));
a(bc_thm_tac zorn_thm2 THEN rewrite_tac[nest_def]
	THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(∂_tac¨{}Æ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "1.3" *** *)
a(lemma_tac¨s Ä s' ≤ s' Ä sÆ
	THEN1 (DROP_NTH_ASM_T 4 bc_thm_tac
		THEN REPEAT strip_tac));
(* *** Goal "1.3.1" *** *)
a(LIST_DROP_NTH_ASM_T [1] (PC_T1 "sets_ext1" all_fc_tac));
a(LIST_DROP_NTH_ASM_T [6] (PC_T1 "sets_ext1" all_fc_tac));
(* *** Goal "1.3.2" *** *)
a(LIST_DROP_NTH_ASM_T [6] (PC_T1 "sets_ext1" all_fc_tac));
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨AÆ THEN contr_tac THEN1 all_asm_fc_tac[]);
a(swap_nth_asm_concl_tac 3);
a(LEMMA_T¨A ¿ {x} = AÆ (once_rewrite_thm_tac o eq_sym_rule)
	THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 bc_thm_tac);
a(contr_tac THEN PC_T1 "sets_ext1" asm_prove_tac[]);
a(var_elim_nth_asm_tac 1);
a(swap_nth_asm_concl_tac 3);
a(LIST_DROP_NTH_ASM_T [5] all_fc_tac);
a(LIST_DROP_NTH_ASM_T [6] (ALL_FC_T asm_rewrite_tac));
pop_thm()
));

=TEX
=SML
val €involution_one_one_thm› = save_thm ( "involution_one_one_thm", (
set_goal([], ¨µf X x y∑
	f ç Involution X
±	x ç X ± y ç X ± f x = f y
¥	x = y
Æ);
a(rewrite_tac[involution_def] THEN REPEAT strip_tac);
a(LEMMA_T¨f(f x) = f(f y)Æ ante_tac
	THEN1 ALL_FC_T asm_rewrite_tac[]);
a(POP_ASM_T discard_tac THEN ALL_ASM_FC_T rewrite_tac[]);
pop_thm()
));

=TEX
=SML
val €involution_def_thm1› = save_thm ( "involution_def_thm1", (
set_goal([], ¨µf X x∑
	f ç Involution X
±	x ç X
¥	f(f x) = x
Æ);
a(rewrite_tac[involution_def] THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
pop_thm()
));

=TEX
=SML
val €involution_def_thm2› = save_thm ( "involution_def_thm2", (
set_goal([], ¨µf X x∑
	f ç Involution X
±	x ç X
¥	f x ç X
Æ);
a(rewrite_tac[involution_def] THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
pop_thm()
));

=TEX
=SML
val €involution_size_thm› = save_thm ( "involution_size_thm", (
set_goal([], ¨µf X∑
	f ç Involution X
±	X ç Finite
±	A Ä X
±	(µx∑x ç A ¥ ≥f x ç A)
±	(µx∑x ç X ¥ x ç A ≤ f x ç A)
¥	#X = 2 * #A
Æ);
a(REPEAT strip_tac THEN all_fc_tac[Ä_finite_thm]);
a(lemma_tac¨X \ A Ä X ± A ° (X \ A) = {}Æ
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(lemma_tac¨X \ A ç Finite ± #(X \ A) = #AÆ
	THEN1 bc_thm_tac bijection_finite_size_thm);
(* *** Goal "1" *** *)
a(∂_tac¨fÆ THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(LIST_DROP_NTH_ASM_T [9] (PC_T1 "sets_ext1" all_fc_tac));
a(ALL_FC_T rewrite_tac[involution_one_one_thm]);
(* *** Goal "1.2" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(∂_tac¨f xÆ THEN ALL_FC_T rewrite_tac[involution_def_thm1]);
a(LIST_DROP_NTH_ASM_T [6] all_fc_tac);
(* *** Goal "1.2.2" *** *)
a(all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [7] (PC_T1 "sets_ext1" all_fc_tac));
a(all_fc_tac[involution_def_thm2]);
(* *** Goal "1.2.3" *** *)
a(all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [6] all_fc_tac);
(* *** Goal "2" *** *)
a(LEMMA_T ¨X = A ¿ (X \ A)Æ once_rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(LEMMA_T ¨#(A ¿ (X \ A)) = #(A ¿ (X \ A)) + #(A ° (X \ A))Æ once_rewrite_thm_tac
	THEN1 asm_rewrite_tac[size_empty_thm]);
a(ALL_FC_T asm_rewrite_tac[size_¿_thm]
	THEN PC_T1 "lin_arith" prove_tac[]);
pop_thm()
));

=TEX
=SML
val €involution_even_size_thm› = save_thm ( "involution_even_size_thm", (
set_goal([], ¨µf X∑
	f ç Involution X
±	X ç Finite
±	X ° Fixed f = {}
¥	∂k∑ #X = 2*k
Æ);
a(REPEAT strip_tac THEN all_fc_tac[fund_region_thm]);
a(∂_tac¨#AÆ THEN bc_thm_tac involution_size_thm);
a(∂_tac¨fÆ THEN contr_tac THEN all_asm_fc_tac[]);
a(LIST_DROP_NTH_ASM_T [1, 7] (MAP_EVERY ante_tac));
a(PC_T1 "sets_ext" asm_prove_tac[]);
pop_thm()
));

=TEX
=SML
val €involution_odd_size_thm› = save_thm ( "involution_odd_size_thm", (
set_goal([], ¨µf X k∑
	f ç Involution X
±	X ç Finite
±	#X = 2*k + 1
¥	≥X ° Fixed f = {}
Æ);
a(contr_tac THEN all_fc_tac[involution_even_size_thm]);
a(LEMMA_T¨(2*k + 1) Mod 2 = (2 * k') Mod 2Æ ante_tac
	THEN1 (DROP_ASMS_T (rewrite_tac o mapfilter eq_sym_rule)));
a(rewrite_tac[mod_2_div_2_thm]);
pop_thm()
));

=TEX
=SML
val €involution_set_dif_fixed_thm› = save_thm ( "involution_set_dif_fixed_thm", (
set_goal([], ¨µf X k∑
	f ç Involution X
¥	f ç Involution (X \ Fixed f)
Æ);
a(PC_T1 "sets_ext1" rewrite_tac[involution_def, fixed_def]
	THEN REPEAT strip_tac
	THEN_TRY (ALL_ASM_FC_T rewrite_tac[]));
a(conv_tac(RAND_C eq_sym_conv) THEN strip_tac);
pop_thm()
));

=TEX
=SML
val €involution_fixed_singleton_thm› = save_thm ( "involution_fixed_singleton_thm", (
set_goal([], ¨µf X x∑
	f ç Involution X
±	X ç Finite
±	X ° Fixed f = {x}
¥	∂k∑#X = 2*k + 1
Æ);
a(REPEAT strip_tac THEN all_fc_tac[involution_set_dif_fixed_thm]);
a(lemma_tac¨(X \ Fixed f) Ä X ±
	(X ° Fixed f) Ä X ±
	(X \ Fixed f) ° Fixed f = {} ±
	(X \ Fixed f) ° (X ° Fixed f) = {}Æ
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(all_fc_tac[Ä_finite_thm]);
a(all_fc_tac[involution_even_size_thm]);
a(∂_tac ¨kÆ);
a(LEMMA_T¨X = (X \ Fixed f) ¿ (X ° Fixed f)Æ once_rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(LEMMA_T ¨#((X \ Fixed f) ¿ (X ° Fixed f)) =
	#((X \ Fixed f) ¿ (X ° Fixed f)) +
		#((X \ Fixed f) ° (X ° Fixed f))Æ once_rewrite_thm_tac
	THEN1 asm_rewrite_tac[size_empty_thm]);
a(ALL_FC_T asm_rewrite_tac[size_¿_thm]);
a(rewrite_tac[size_singleton_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
local
val thm1 = taut_rule ¨µp1 p2 p3∑ (p1 ¥ p2 ± p3) ¥ p1 ¥ p2Æ;
in
fun €finite_bc_rule› (thm : THM) = (
	all_µ_intro(simple_¥_match_mp_rule thm1 (all_µ_elim thm))
);
end;
=SML
val €˙_interval_finite_thm› = save_thm ( "˙_interval_finite_thm", (
set_goal([], ¨µm n : ˙∑ {i : ˙ | m º i ± i º n} ç FiniteÆ);
a(REPEAT strip_tac THEN cases_tac¨m > (n:˙)Æ);
(* *** Goal "1" *** *)
a(LEMMA_T¨{i|m º i ± i º n} = {}Æ
	(fn th => rewrite_tac[th, empty_finite_thm])
	THEN PC_T1 "sets_ext1" REPEAT strip_tac
	THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(˙_º_induction_tac¨nÆ);
(* *** Goal "2.1" *** *)
a(LEMMA_T¨{i|m º i ± i º m} = {m}Æ
	(fn th => rewrite_tac[th, singleton_finite_thm])
	THEN PC_T1 "sets_ext1" REPEAT strip_tac
	THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(LEMMA_T¨{n'|m º n' ± n' º n + Ó˙ 1} = {n'|m º n' ± n' º n} ¿ {n + Ó˙ 1}Æ
	(fn th => asm_rewrite_tac[th, ¿_finite_thm, singleton_finite_thm])
	THEN PC_T1 "sets_ext1" REPEAT strip_tac
	THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

=SML
val €˙_0_º_square_thm› = save_thm ( "˙_0_º_square_thm", (
set_goal([], ¨µi : ˙∑ Ó˙ 0 º i*iÆ);
a(REPEAT strip_tac THEN strip_asm_tac(µ_elim¨i:˙Æ˙_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN_TRY conv_tac (RIGHT_C ˙_anf_conv)
	THEN bc_thm_tac ˙_Ó_times_thm
	THEN rewrite_tac[Ó˙_º_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

=SML
val €˙_0_less_0_less_times_thm› = save_thm ( "˙_0_less_0_less_times_thm", (
set_goal([], ¨µi j: ˙∑ Ó˙ 0 < i ± Ó˙ 0 < j ¥ Ó˙ 0 < i*jÆ);
a(REPEAT strip_tac THEN lemma_tac¨Ó˙ 1 º iÆ
	THEN1 PC_T1 "˙_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 3 discard_tac THEN ˙_º_induction_tac¨iÆ
	THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML
val €˙_0_less_times_thm› = save_thm ( "˙_0_less_times_thm", (
set_goal([], ¨µi j: ˙∑ Ó˙ 0 < i ± Ó˙ 0 < j ¥ j º i * jÆ);
a(REPEAT strip_tac THEN lemma_tac¨Ó˙ 1 º iÆ
	THEN1 PC_T1 "˙_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 3 discard_tac THEN ˙_º_induction_tac¨iÆ
	THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
pop_thm()
));

val €˙_0_less_times_thm1› = save_thm(
	"˙_0_less_times_thm1",
	conv_rule(once_rewrite_conv[˙_times_comm_thm]) ˙_0_less_times_thm);
=TEX
%%%%
%%%%
=SML
val €˙_º_square_thm› = save_thm ( "˙_º_square_thm", (
set_goal([], ¨µi: ˙∑ i º i*iÆ);
a(REPEAT strip_tac THEN cases_tac¨i º Ó˙ 0Æ);
(* *** Goal "1" *** *)
a(strip_asm_tac(µ_elim¨iÆ˙_0_º_square_thm)
	THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(bc_thm_tac ˙_0_less_times_thm THEN REPEAT strip_tac);
pop_thm()
));

=TEX
=SML
set_goal([], ¨µm i∑
	≥Ó˙ 4 * m + Ó˙ 1 = Ó˙ 4 * i
Æ);
a(once_rewrite_tac[˙_times_comm_thm] THEN contr_tac);
a(lemma_tac¨Ó˙ 0 = Ó˙ 1Æ
	THEN1 pure_once_rewrite_tac(map (rewrite_rule[]) [
		list_µ_elim
		[¨m * Ó˙ 4 + Ó˙ 1Æ, ¨Ó˙ 4Æ, ¨mÆ, ¨Ó˙ 1Æ]
		˙_div_mod_unique_thm,
		list_µ_elim
		[¨i * Ó˙ 4Æ, ¨Ó˙ 4Æ, ¨iÆ, ¨Ó˙ 0Æ]
		˙_div_mod_unique_thm]));
a(asm_rewrite_tac[]);
val €˙_mod_4_lemma› = pop_thm();
=TEX
%%%%
%%%%
=SML
val €a_finite_thm› = save_thm ( "a_finite_thm", (
set_goal([], ¨µp A∑
	A = {(x, y, z) | Ó˙ 0 < x ± Ó˙ 0 < y ± Ó˙ 4*x*y + z*z = p}
¥	A ç Finite
Æ);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(bc_thm_tac Ä_finite_thm
	THEN ∂_tac ¨{x : ˙ | ~p º x ± x º p} ∏
		{x : ˙ | ~p º x ± x º p} ∏
		{x : ˙ | ~p º x ± x º p} Æ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(REPEAT (bc_thm_tac (finite_bc_rule ∏_finite_size_thm) THEN REPEAT strip_tac)
	THEN rewrite_tac[˙_interval_finite_thm]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN rewrite_tac[∏_def]);
a(lemma_tac¨Ó˙ 0 º x3 * x3Æ THEN1 rewrite_tac[˙_0_º_square_thm]);
a(lemma_tac¨Ó˙ 0 < x1 * x2Æ THEN1 all_fc_tac[˙_0_less_0_less_times_thm]);
a(lemma_tac¨x2 º x1 * x2Æ THEN1 all_fc_tac[˙_0_less_times_thm]);
a(lemma_tac¨x1 º x1 * x2Æ THEN1 all_fc_tac[˙_0_less_times_thm1]);
a(lemma_tac¨x3 º x3 * x3 ± ~x3 º ~x3 * ~x3Æ
	THEN1 rewrite_tac[˙_º_square_thm]);
a(PC_T1 "˙_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
=SML
val €f_involution_a_thm› = save_thm ( "f_involution_a_thm", (
set_goal([], ¨µp A f∑
	A = {(x, y, z) | Ó˙ 0 < x ± Ó˙ 0 < y ± Ó˙ 4*x*y + z*z = p}
¥	(Ã(x, y, z)∑ (y, x, ~z)) ç Involution A
Æ);
a(REPEAT strip_tac THEN asm_rewrite_tac[involution_def]
	THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
The following tactic is parameterised by a list of terms of
the form $x = (a, b)$ where $x$, $a$ and $b$ are variables
and each $x$ is expected to occur free in the goal.
It replace each $x$ by the corresponding pair $(a, b)$.
The tactic is useful in bridging the gap between the definitions
in the theory (which tend to use the form $(a, b)$ for clarity when
arithmetic needs to be done on the components of the pair)
and the conjectures (which use the form $x$ wherever
possible for brevity and generality).
=SML
local
val fst_tm = ¨Fst : 'a ∏ 'b ≠ 'aÆ;
val snd_tm = ¨Snd : 'a ∏ 'b ≠ 'bÆ;
val a_ty = î'aÆ;
val b_ty = î'bÆ;
val def_thm = get_spec fst_tm;
in
fun €pair_tac› (tm : TERM) : TACTIC = (
	let	val (x, ab) = dest_eq tm;
		val (a, b) = dest_pair ab;
		val lemma = list_mk_∂ ([a, b], tm);
		val type_map = [(type_of a, a_ty), (type_of b, b_ty)];
		val fst_witness = mk_app(inst [] type_map fst_tm, x);
		val snd_witness = mk_app(inst [] type_map snd_tm, x);
	in	PC_T1 "basic_hol" lemma_tac lemma THEN_LIST
		[	∂_tac fst_witness THEN
			∂_tac snd_witness THEN DROP_ASMS_T discard_tac THEN
			pure_rewrite_tac[def_thm] THEN REPEAT strip_tac,
			var_elim_asm_tac tm]
	end
);
end;
=TEX
=SML
val €size_a_size_b_thm› = save_thm ( "size_a_size_b_thm", (
set_goal([], ¨µp m A B∑
	p = Ó˙ 4 * m + Ó˙ 1
±	A = {(x, y, z) | Ó˙ 0 < x ± Ó˙ 0 < y ± Ó˙ 4*x*y + z*z = p}
±	B = {(x, y, z) | (x, y, z) ç A ± z > Ó˙ 0}
¥	#A = 2 * #B
Æ);
a(REPEAT strip_tac THEN bc_thm_tac involution_size_thm);
a(∂_tac¨Ã(x, y, z) : ˙ ∏ ˙ ∏ ˙∑ (y, x, ~z)Æ);
a(ALL_FC_T rewrite_tac[f_involution_a_thm, a_finite_thm]);
a(REPEAT ±_tac THEN_TRY µ_tac
	THEN all_var_elim_asm_tac1
	THEN1 PC_T1 "sets_ext1" prove_tac[]
	THEN1 (REPEAT strip_tac
		THEN PC_T1 "˙_lin_arith" asm_prove_tac[]));
a(pair_tac¨x = (a, bc)Æ THEN rewrite_tac[]);
a(pair_tac¨bc = (b, c)Æ THEN rewrite_tac[] THEN REPEAT strip_tac
	THEN_TRY PC_T1 "˙_lin_arith" asm_prove_tac[]);
a(lemma_tac¨≥c = Ó˙ 0Æ
	THEN_LIST [id_tac, PC_T1 "˙_lin_arith" asm_prove_tac[]]);
a(swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[]);
a(conv_tac(RAND_C eq_sym_conv) THEN rewrite_tac[˙_mod_4_lemma]);
pop_thm()
));

=TEX
=SML
val €size_a_size_c_thm› = save_thm ( "size_a_size_c_thm", (
set_goal([], ¨µp A C∑
	(µi∑ ≥p = i * i)
±	A = {(x, y, z) | Ó˙ 0 < x ± Ó˙ 0 < y ± Ó˙ 4*x*y + z*z = p}
±	C = {(x, y, z) | (x, y, z) ç A ± (x - y) + z > Ó˙ 0}
¥	#A = 2 * #C
Æ);
a(REPEAT strip_tac THEN bc_thm_tac involution_size_thm);
a(∂_tac¨Ã(x, y, z) : ˙ ∏ ˙ ∏ ˙∑ (y, x, ~z)Æ);
a(ALL_FC_T rewrite_tac[f_involution_a_thm, a_finite_thm]);
a(REPEAT ±_tac THEN_TRY µ_tac
	THEN all_var_elim_asm_tac1
	THEN1 PC_T1 "sets_ext1" prove_tac[]
	THEN1 (REPEAT strip_tac
		THEN PC_T1 "˙_lin_arith" asm_prove_tac[]));
a(pair_tac¨x = (a, bc)Æ THEN rewrite_tac[]);
a(pair_tac¨bc = (b, c)Æ THEN rewrite_tac[] THEN REPEAT strip_tac
	THEN_TRY PC_T1 "˙_lin_arith" asm_prove_tac[]);
a(lemma_tac¨≥c = b + ~aÆ
	THEN_LIST [id_tac, PC_T1 "˙_lin_arith" asm_prove_tac[]]);
a(contr_tac THEN all_var_elim_asm_tac1);
a(swap_nth_asm_concl_tac 4 THEN strip_tac);
a(∂_tac¨a + bÆ THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
=SML
val €size_b_size_c_thm› = save_thm ( "size_b_size_c_thm", (
set_goal([], ¨µp m A B C∑
	p = Ó˙ 4 * m + Ó˙ 1
±	(µi∑ ≥p = i * i)
±	A = {(x, y, z) | Ó˙ 0 < x ± Ó˙ 0 < y ± Ó˙ 4*x*y + z*z = p}
±	B = {(x, y, z) | (x, y, z) ç A ± z > Ó˙ 0}
±	C = {(x, y, z) | (x, y, z) ç A ± (x - y) + z > Ó˙ 0}
¥	#B = #C
Æ);
a(REPEAT strip_tac
	THEN all_fc_tac[size_a_size_b_thm, size_a_size_c_thm]
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
=SML
val €g_involution_c_thm› = save_thm ( "g_involution_c_thm", (
set_goal([], ¨µp A C∑
	A = {(x, y, z) | Ó˙ 0 < x ± Ó˙ 0 < y ± Ó˙ 4*x*y + z*z = p}
±	C = {(x, y, z) | (x, y, z) ç A ± (x - y) + z > Ó˙ 0}
¥	(Ã(x, y, z)∑ ((x - y) + z, y, Ó˙ 2*y - z)) ç Involution C
Æ);
a(REPEAT strip_tac THEN asm_rewrite_tac[involution_def]
	THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
=SML
val €size_c_thm› = save_thm ( "size_c_thm", (
set_goal([], ¨µp m A C∑
	p = Ó˙ 4 * m + Ó˙ 1
±	Ó˙ 1 < p
±	(µa b∑ Ó˙ 0 < a ± Ó˙ 0 < b ± p = (Ó˙ 4 * a + b) * b ¥ b = Ó˙ 1)
±	A = {(x, y, z) | Ó˙ 0 < x ± Ó˙ 0 < y ± Ó˙ 4*x*y + z*z = p}
±	C = {(x, y, z) | (x, y, z) ç A ± (x - y) + z > Ó˙ 0}
¥	∂k∑ #C = 2*k + 1
Æ);
a(REPEAT strip_tac THEN bc_thm_tac involution_fixed_singleton_thm);
a(lemma_tac¨C Ä AÆ THEN1 (asm_rewrite_tac[] THEN PC_T1 "sets_ext1" prove_tac[]));
a(all_fc_tac[a_finite_thm]);
a(∂_tac¨(m, Ó˙ 1, Ó˙ 1)Æ
	THEN ∂_tac¨(Ã(x, y, z)∑ ((x - y) + z, y, Ó˙ 2*y - z))Æ
	THEN1 ALL_FC_T rewrite_tac[g_involution_c_thm, Ä_finite_thm]);
a(PC_T1 "sets_ext1" rewrite_tac[fixed_def]);
a(LIST_DROP_NTH_ASM_T [1, 2] discard_tac
	THEN all_var_elim_asm_tac1
	THEN rewrite_tac[˙_plus_assoc_thm]
	THEN REPEAT_UNTIL is_¥ strip_tac
	THEN strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨x3 = x2Æ THEN1 PC_T1 "˙_lin_arith" asm_prove_tac[]
	THEN all_var_elim_asm_tac);
a(lemma_tac¨x2 = Ó˙ 1Æ
	THEN1 (DROP_NTH_ASM_T 7 bc_thm_tac THEN ∂_tac¨x1Æ)
	THEN1 PC_T1 "˙_lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(PC_T1 "˙_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1 THEN rewrite_tac[]
	THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
=SML
val €h_involution_b_thm› = save_thm ( "h_involution_b_thm", (
set_goal([], ¨µp A B∑
	A = {(x, y, z) | Ó˙ 0 < x ± Ó˙ 0 < y ± Ó˙ 4*x*y + z*z = p}
±	B = {(x, y, z) | (x, y, z) ç A ± z > Ó˙ 0}
¥	(Ã(x, y, z)∑ (y, x, z)) ç Involution B
Æ);
a(REPEAT strip_tac THEN asm_rewrite_tac[involution_def]
	THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
=SML
val €h_fixed_in_b_thm› = save_thm ( "h_fixed_in_b_thm", (
set_goal([], ¨µp m A B∑
	p = Ó˙ 4 * m + Ó˙ 1
±	Ó˙ 1 < p
±	(µi∑ ≥p = i * i)
±	(µa b∑ Ó˙ 0 < a ± Ó˙ 0 < b ± p = (Ó˙ 4 * a + b) * b ¥ b = Ó˙ 1)
±	A = {(x, y, z) | Ó˙ 0 < x ± Ó˙ 0 < y ± Ó˙ 4*x*y + z*z = p}
±	B = {(x, y, z) | (x, y, z) ç A ± z > Ó˙ 0}
¥	≥B ° Fixed (Ã(x, y, z)∑ (y, x, z)) = {}
Æ);
a(REPEAT strip_tac THEN bc_thm_tac involution_odd_size_thm);
a(lemma_tac¨∂C∑
	C = {(x, y, z) | (x, y, z) ç A ± (x - y) + z > Ó˙ 0}Æ
	THEN1 prove_∂_tac);
a(lemma_tac¨B Ä AÆ THEN1 (asm_rewrite_tac[] THEN PC_T1 "sets_ext1" prove_tac[]));
a(all_fc_tac[a_finite_thm]);
a(all_fc_tac[size_c_thm]);
a(∂_tac¨kÆ THEN ALL_FC_T rewrite_tac[h_involution_b_thm, Ä_finite_thm]);
a(ALL_FC_T asm_rewrite_tac[size_b_size_c_thm]);
pop_thm()
));

=TEX
=SML
val €two_squares_lemma› = save_thm ( "two_squares_lemma", (
set_goal([], ¨µp m∑
	p = Ó˙ 4 * m + Ó˙ 1
±	Ó˙ 1 < p
±	(µi∑ ≥p = i * i)
±	(µa b∑ Ó˙ 0 < a ± Ó˙ 0 < b ± p = (Ó˙ 4 * a + b) * b ¥ b = Ó˙ 1)
¥	∂a b∑p = a*a + b*b
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂A B C∑
	A = {(x, y, z) | Ó˙ 0 < x ± Ó˙ 0 < y ± Ó˙ 4*x*y + z*z = p}
±	B = {(x, y, z) | (x, y, z) ç A ± z > Ó˙ 0}
±	C = {(x, y, z) | (x, y, z) ç A ± (x - y) + z > Ó˙ 0}Æ
	THEN1 REPEAT (prove_∂_tac THEN strip_tac));
a(ALL_FC_T (MAP_EVERY ante_tac) [h_fixed_in_b_thm]);
a(all_var_elim_asm_tac1
	THEN PC_T1 "sets_ext1" rewrite_tac[fixed_def]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac);
a(∂_tac¨Ó˙ 2 * x1Æ THEN ∂_tac¨x3Æ THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val €sections› = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="wrk073.th.doc", theory="-"};
end;
=TEX
} %\Hide
\end{document}

=TEX
%%%%
%%%%
=IGN
