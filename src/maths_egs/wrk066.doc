pp_make_database -f -p hol analysis
docsml analysis wrk044
hol -f wrk044.sml -d analysis
xpp -file analysis.doc -com pp -d analysis -i analysis &
doctex analysis analysis.th; texdvi analysis
=TEX
\documentclass[10pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\title{Basic Analysis}
\author{Rob Arthan}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
This {\ProductHOL} command script contains definitions and proofs concerning
the basics of analysis.

\end{abstract}
\vfill
\newpage
\tableofcontents
\newpage
\section{INTRODUCTION}
This document defines a theory
=INLINEFT
analysis
=TEX
\ which contains the definitions and proofs concerned with the basics of analysis.
The subjects covered are the basic facts about:
\begin{itemize}
\item polynomial functions on the real numbers
\item limits of sequences
\item continuity of functions
\item differentiation
\end{itemize}
=SML
force_delete_theory"analysis" handle Fail _ => ();
open_theory"Ø";
set_merge_pcs["basic_hol1", "'sets_alg", "'Ø"];
new_theory"analysis";
new_parent"fin_thms";
=TEX
\section{DEFINITIONS}\label{DEFINITIONS}
We define the polynomial functions on the real numbers to be the smallest set
of functions containing the constant functions and the identity function
and closed under (point-wise) addition and multiplication.
\subsection{Polynomials}
πHOLCONST
‹ €PolyFunc› : (Ø ≠ Ø) SET
˜¸¸¸¸¸¸
‹ PolyFunc = •
‹	{	A
‹	|	(µc∑ (Ãx∑c) ç A)
‹	±	(Ãx∑x) ç A
‹	±	(µf g∑f ç A ± g ç A ¥ (Ãx∑f x + g x) ç A)
‹	±	(µf g∑f ç A ± g ç A ¥ (Ãx∑f x * g x) ç A) }
∞
We will show that every polynomial function can be represented as
a (point-wise) sum, $\lambda x \bullet a_0 + a_1x + a_2 x^2 + \ldots a_n x^n$
for some list of coefficients $[a_0; a_1; a_2 \ldots; a_n]$.
The following function maps such a list of coefficients into the polynomial
function it represents.
πHOLCONST
‹ $€PolyEval› : Ø LIST ≠ (Ø ≠ Ø)
˜¸¸¸¸¸¸
‹ 	(µx∑ PolyEval [] x = ÓØ 0)
‹±	(µc l x∑ PolyEval (Cons c l) x = c + x * PolyEval l x)
∞
We now define the operations on lists of coefficients that
correspond to addition of polynomials \ldots
πHOLCONST
‹ €PlusCoeffs› : Ø LIST ≠ Ø LIST ≠ Ø LIST
˜¸¸¸¸¸¸
‹ 	(µl∑ PlusCoeffs [] l = l)
‹±	(µl∑ PlusCoeffs l [] = l)
‹±	(µc1 l1 c2 l2∑
‹	PlusCoeffs (Cons c1 l1) (Cons c2 l2) =
‹	Cons (c1 + c2) (PlusCoeffs l1 l2))
∞
\ldots and to multiplication of one polynomial by another.
πHOLCONST
‹ €TimesCoeffs› : Ø LIST ≠ Ø LIST ≠ Ø LIST
˜¸¸¸¸¸¸
‹ 	(µl∑ TimesCoeffs [] l = [])
‹±	(µc l1 l2∑
‹	TimesCoeffs (Cons c l1) l2 =
‹	PlusCoeffs (Cons (ÓØ 0) (TimesCoeffs l1 l2)) (Map (Ãx∑c * x) l2) )
∞
The following is useful in forming polynomials whose list
of coefficients is given by a function:
=SML
declare_infix(310, "To");

πHOLCONST
‹ $€To› : (Ó ≠ 'a) ≠ Ó ≠ 'a LIST
˜¸¸¸¸¸¸
‹ 	(µf∑ f To 0 = [])
‹±	(µf n∑ f To (n+1) = f To n @ [f n])
∞


\subsection{Limits}
We will write $s {-}{-}{>} x$ to indicate that the sequence $s_n$, indexed by
natural numbers, tends to the limit $x$ as $n$ tends to infinity:
=SML
declare_infix(200, "-->");

πHOLCONST
‹ $€-->› : (Ó ≠ Ø) ≠ Ø ≠ BOOL
˜¸¸¸¸¸¸
‹µs x∑ s --> x § µe∑ÓØ 0 < e ¥ ∂n∑µm∑n º m ¥ Abs(s m - x) < e
∞
The following definition is a tentative one that is under experimentation.
We write $(u {-}{-}{-}{>} h) x$ to indicate that the sequence of functions $u_n$, indexed by
natural numbers, tends to uniformly to the limit function $h$ in some
neighbourhood $x$ as $n$ tends to infinity.
This is a notion, which one might call {\em local uniform convergence},
that doesn't tend to appear as such in the calculus text books (which would
normally talk about uniform convergence of a sequence of functions on some set).
It seems however to give a convenient sufficient condition for several of
the usual results that fits better into the general style of the other results
proved.
=SML
declare_infix(200, "--->");

πHOLCONST
‹ $€--->› : (Ó ≠ Ø ≠ Ø) ≠ (Ø ≠ Ø) ≠ Ø ≠ BOOL
˜¸¸¸¸¸¸
‹µu h x∑ (u ---> h) x §
‹	∂b∑ÓØ 0 < b ± µe∑ÓØ 0 < e ¥ ∂n∑µm y∑ n º m ± Abs(y - x) < b ¥ Abs(u m y - h y) < e
∞
\subsection{Continuity}
Now we give the usual $\epsilon$-$\delta$ definition for continuity of
a function, $f$ at a point $x$. Both kinds of $\epsilon$ are tied
up in the {\ProductHOL} library for something else (viz. Hilbert's choice
operator and set-membership). We therefore just use $e$ and $d$.
Continuity is formulated as an infix relation between a function and
the point at which its continuity is asserted.
=SML
declare_infix(200, "CtsAt");
πHOLCONST
‹ $€CtsAt› : (Ø ≠ Ø) ≠ Ø ≠ BOOL
˜¸¸¸¸¸¸
‹ µf x∑ f CtsAt x § µe∑ÓØ 0 < e ¥ ∂d∑ÓØ 0 < d ± µy∑ Abs(y - x) < d ¥ Abs(f y - f x) < e
∞
\subsection{Derivatives}
Now we give the usual $\epsilon-\delta$ definition for the derivative of
a function, $f$ at a point $x$. 
The notion of a derivative as formulated here is really a ternary
relation: ``$f$ has derivative $c$ at $x$''.
We represent this as the infix operation between $f$ and $c$ whose
value is the propositional function that characterises the values$x$ for
which the derivative $f$ is $c$.
=SML
declare_infix(200, "HasDeriv");
πHOLCONST
‹ $€HasDeriv› : (Ø ≠ Ø) ≠ Ø ≠ Ø ≠ BOOL
˜¸¸¸¸¸¸
‹ µf c x∑
‹	(f HasDeriv c) x §
‹	µe∑ÓØ 0 < e ¥ ∂d∑
‹		ÓØ 0 < d
‹	±	µy∑ Abs(y - x) < d ± ≥y = x ¥ Abs((f y - f x)/(y-x) - c) < e
∞
\subsection{Intervals and Open Sets}
The language of intervals and of open sets is very useful in stating
some results:
=SML
πHOLCONST
‹ €ClosedInterval› : Ø ≠ Ø ≠ Ø SET
˜¸¸¸¸¸¸
‹ µx y∑ ClosedInterval x y = {t | x º t ± t º y}
∞
πHOLCONST
‹ €OpenInterval› : Ø ≠ Ø ≠ Ø SET
˜¸¸¸¸¸¸
‹ µx y∑ OpenInterval x y = {t | x < t ± t < y}
∞
πHOLCONST
‹ €OpenSets› : Ø SET SET
˜¸¸¸¸¸¸
‹ OpenSets = {A | µt∑t ç A ¥ ∂x y∑t ç OpenInterval x y ± OpenInterval x y Ä A}
∞
=TEX
{\HOLindexOff
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{analysis.th}}
\section{THEOREMS}
\subsection{The Definitions and Their Consistency}
We give bindings for the definitions and discharge any consistency
proof obligations.
=SML
val €poly_func_def› = get_spec¨PolyFuncÆ;
val €poly_eval_def› = get_spec¨PolyEvalÆ;
=TEX
Here is the only consistency proof obligation, which just arises
because the definition of {\it PlusCoeffs} is not quite in the
form that the existence prover for recursive definitions over
the natural numbers expects.
=SML
push_consistency_goal¨PlusCoeffsÆ;
a(lemma_tac¨∂ac∑
 	(µl∑ ac [] l = l)
±	(µc1 : Ø; l1∑
	ac (Cons c1 l1) [] = Cons c1 l1
±	(µc2 l2∑ ac (Cons c1 l1) (Cons c2 l2) =
	Cons (c1 + c2) (ac l1 l2)))
Æ THEN1 prove_∂_tac);
a(∂_tac ¨acÆ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(list_induction_tac¨lÆ THEN asm_rewrite_tac[]);
val _ = save_consistency_thm ¨PlusCoeffsÆ (pop_thm());
val €plus_coeffs_def› = get_spec¨PlusCoeffsÆ;
val €times_coeffs_def› = get_spec¨TimesCoeffsÆ;
val €to_def› = get_spec¨$ToÆ;
val €lim_seq_def› = get_spec¨$-->Æ;
val €unif_lim_seq_def› = get_spec¨$--->Æ;
val €cts_at_def› = get_spec¨$CtsAtÆ;
val €has_deriv_def› = get_spec¨$HasDerivÆ;
val €closed_interval_def› = get_spec¨ClosedIntervalÆ;
val €open_interval_def› = get_spec¨OpenIntervalÆ;
val €open_sets_def› = get_spec¨OpenSetsÆ;
=TEX
The next two are an omission in {\Product} V2.5.1:
=SML
val €Ø_Ó_exp_def› = get_spec¨$^âNÆ;
val €Ø_abs_def› = get_spec¨AbsâRÆ;
=TEX
\subsection{Polynomials}
Now we will show that any polynomial can be represented by a list of coefficients.
The first part of the proof follows a pattern which will be repeated several times.
First we prove something for constant functions, then for the identity functions,
then for sums and products possibly on the assumption that the ``something'' holds for
the operands. In this case ``something'' is the existence of a list of
coefficients that represent a function, which we give explicitly for later use.

Constants \ldots
=SML
set_goal([], ¨µc∑(Ãx∑c) = PolyEval [c]Æ);
a(rewrite_tac[poly_eval_def]);
val €const_eval_thm› = save_pop_thm "const_eval_thm";
=TEX
\ldots identity function \ldots
=SML
set_goal([], ¨(Ãx∑x) = PolyEval [ÓØ 0; ÓØ 1]Æ);
a(rewrite_tac[poly_eval_def]);
val €id_eval_thm› = save_pop_thm "id_eval_thm";
=TEX
\ldots sums \ldots
=SML
set_goal([], ¨µl1 l2∑
	(Ãx∑PolyEval l1 x + PolyEval l2 x) =
	PolyEval (PlusCoeffs l1 l2)Æ);
a(strip_tac);
a(list_induction_tac¨l1Æ THEN rewrite_tac[plus_coeffs_def, poly_eval_def]);
a(REPEAT strip_tac);
a(list_induction_tac¨l2Æ THEN rewrite_tac[plus_coeffs_def, poly_eval_def]);
a(DROP_NTH_ASM_T 2 (rewrite_thm_tac o conv_rule (BINDER_C eq_sym_conv)));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €plus_eval_thm› = save_pop_thm "plus_eval_thm";
=TEX
\ldots and products, which in this case require a little lemma first:
=SML
set_goal([], ¨µc l∑(Ãx∑c * PolyEval l x) = PolyEval (Map (Ãy∑c * y) l)Æ);
a(REPEAT strip_tac);
a(list_induction_tac¨lÆ THEN rewrite_tac[map_def, poly_eval_def]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €const_times_eval_thm› = save_pop_thm "const_times_eval_thm";
=TEX
=SML
set_goal([], ¨µl1 l2∑
	(Ãx∑PolyEval l1 x * PolyEval l2 x) =
	PolyEval (TimesCoeffs l1 l2)Æ);
a(strip_tac);
a(list_induction_tac¨l1Æ THEN
	rewrite_tac[times_coeffs_def, poly_eval_def, plus_coeffs_def]);
a(REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[]));
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) plus_eval_thm,
	conv_rule (ONCE_MAP_C eq_sym_conv) const_times_eval_thm,
	poly_eval_def]);
a(conv_tac (RANDS_C Ø_anf_conv));
a(asm_rewrite_tac[]);
val €times_eval_thm› = save_pop_thm "times_eval_thm";
=TEX
We can now show that the set of all polynomial functions is the
range of the polynomial evaluation function. I.e., a function
is polynomial iff. it can be represented by a list of coefficients.
We prove the two inclusions separately:
=SML
set_goal([], ¨{f | ∂l∑ f = PolyEval l} Ä PolyFuncÆ);
a(pure_rewrite_tac[poly_func_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN list_induction_tac¨lÆ);
(* *** Goal "1" *** *)
a(list_spec_nth_asm_tac 4 [¨ÓØ 0Æ]);
a(LEMMA_T ¨PolyEval [] = (Ãx∑ ÓØ 0)Æ asm_rewrite_thm_tac
	THEN1 rewrite_tac[poly_eval_def]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(LEMMA_T ¨PolyEval (Cons x l) = (Ãt∑ (Ãu∑x) t + (Ãv∑ (Ãw∑w)v * PolyEval l v)t)Æ
	pure_rewrite_thm_tac THEN1 rewrite_tac[poly_eval_def]);
a(GET_NTH_ASM_T 3 bc_thm_tac THEN strip_tac THEN1 asm_rewrite_tac[]);
a(GET_NTH_ASM_T 2 bc_thm_tac THEN strip_tac THEN asm_rewrite_tac[]);
val €poly_eval_Ä_poly_thm› = pop_thm ();
=TEX
For the reverse inclusion, and for later use, it is convenient
to prove an induction theorem for polynomials and use it
to derive an induction tactic:
=SML
set_goal([], ¨µp∑
		(µc∑p(Ãx∑c))
	±	(p(Ãx∑x))
	±	(µf g∑p f ± p g ¥  p(Ãx∑f x + g x))
	±	(µf g∑p f ± p g ¥ p(Ãx∑f x * g x))
	¥	(µh∑ h ç PolyFunc ¥ p h)
Æ);
a(rewrite_tac[poly_func_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(PC_T1 "sets_ext1" POP_ASM_T (strip_asm_tac o µ_elim ¨{h | p h}Æ)
	THEN1 asm_prove_tac[] THEN all_asm_fc_tac[]);
val €poly_induction_thm› = save_pop_thm "poly_induction_thm";
=TEX
Now the tactic, which expects a term of the form $f \in \mbox{\it PolyFunc}$ to
be in the assumptions (where $f$ is the induction variable).
=SML
fun €poly_induction_tac› (tm : TERM) : TACTIC = (
	if not (is_var tm andalso type_of tm =: îØ ≠ ØÆ)
	then term_fail "poly_induction_tac" 999001 [tm]
	else ( fn(asms, conc) =>
	let	val asm = find asms (fn t =>  
			let	val (x, s) = dest_bin_op "" 0 "ç" t;
			in	x =$ tm andalso s =$ ¨PolyFuncÆ
			end	handle Fail _ => false)
			handle Fail _ => fail "poly_induction_tac" 999002 [];
	in	if not (is_free_in tm conc)
			then term_fail "poly_induction_tac" 999003 [tm]
		else if any (asms drop (fn t => t =$ asm)) (is_free_in tm)
			then term_fail "poly_induction_tac" 999004 [tm]
		else	(asm_ante_tac asm THEN gen_induction_tac1 poly_induction_thm) (asms, conc)
	end
	)
);
=TEX
=SML
set_goal([], ¨PolyFunc Ä {f | ∂l∑ f = PolyEval l}Æ);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(poly_induction_tac¨xÆ);
(* *** Goal "1" *** *)
a(ante_tac const_eval_thm THEN prove_tac[]);
(* *** Goal "2" *** *)
a(ante_tac id_eval_thm THEN prove_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨PlusCoeffs l l'Æ THEN pure_asm_rewrite_tac[plus_eval_thm] THEN strip_tac);
(* *** Goal "4" *** *)
a(∂_tac¨TimesCoeffs l l'Æ THEN pure_asm_rewrite_tac[times_eval_thm] THEN strip_tac);
val €poly_Ä_poly_eval_thm› = pop_thm ();
=TEX
=SML
set_goal([], ¨PolyFunc = {f | ∂l∑ f = PolyEval l}Æ);
a(rewrite_tac[poly_Ä_poly_eval_thm, poly_eval_Ä_poly_thm,
	pc_rule1 "sets_ext1" prove_rule[] ¨µa b∑a = b § a Ä b ± b Ä aÆ]);
val €poly_func_eq_poly_eval_thm› = save_pop_thm "poly_func_eq_poly_eval_thm";
=TEX
For convenience, it is useful to have the theorems that say that the
different kinds of polynomial construction do lead to polynomial functions:
=SML
set_goal([], ¨µc∑(Ãx∑c) ç PolyFuncÆ);
a(pure_rewrite_tac[const_eval_thm, poly_func_eq_poly_eval_thm]);
a(PC_T1 "sets_ext1" prove_tac[]);
val €const_poly_func_thm› = save_pop_thm "const_poly_func_thm";
=TEX
=SML
set_goal([], ¨(Ãx∑x) ç PolyFuncÆ);
a(pure_rewrite_tac[id_eval_thm, poly_func_eq_poly_eval_thm]);
a(PC_T1 "sets_ext1" prove_tac[]);
val €id_poly_func_thm› = save_pop_thm "id_poly_func_thm";
=TEX
=SML
set_goal([], ¨µf g∑ f ç PolyFunc ± g ç PolyFunc ¥ (Ãx∑f x + g x) ç PolyFuncÆ);
a(pure_rewrite_tac[poly_func_eq_poly_eval_thm] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN pure_rewrite_tac[plus_eval_thm]
	THEN PC_T1 "predicates" prove_tac[]);
val €plus_poly_func_thm› = save_pop_thm "plus_poly_func_thm";
=TEX
=SML
set_goal([], ¨µf g∑ f ç PolyFunc ± g ç PolyFunc ¥ (Ãx∑f x * g x) ç PolyFuncÆ);
a(pure_rewrite_tac[poly_func_eq_poly_eval_thm] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN pure_rewrite_tac[times_eval_thm]
	THEN PC_T1 "predicates" prove_tac[]);
val €times_poly_func_thm› = save_pop_thm "times_poly_func_thm";
=TEX
=SML
set_goal([], ¨µf g∑ f ç PolyFunc ± g ç PolyFunc ¥ (Ãx∑f(g x)) ç PolyFuncÆ);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(intro_µ_tac(¨gÆ, ¨gÆ) THEN poly_induction_tac¨fÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[const_poly_func_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[»_axiom]);
(* *** Goal "3" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(rewrite_tac[] THEN ALL_FC_T (MAP_EVERY ante_tac) [plus_poly_func_thm]);
a(rewrite_tac[] THEN taut_tac);
(* *** Goal "4" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(rewrite_tac[] THEN ALL_FC_T (MAP_EVERY ante_tac) [times_poly_func_thm]);
a(rewrite_tac[] THEN taut_tac);
val €comp_poly_func_thm› = save_pop_thm "comp_poly_thm";
=TEX
=SML
set_goal([], ¨
	µl1 l2 x∑ PolyEval (l1 @ l2) x = PolyEval l1 x + x^Length l1 * PolyEval l2 x
Æ);
a(REPEAT strip_tac THEN list_induction_tac¨l1:Ø LISTÆ THEN
	asm_rewrite_tac[rev_def, poly_eval_def, length_def, Ø_Ó_exp_def, append_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €poly_eval_append_thm› = save_pop_thm "poly_eval_append_thm";
=TEX
We are now going to prove various identities for polynomials.
We need a few general lemmas about lists first:
=SML
set_goal([], ¨
	(µl1 l2 : 'a LIST∑ Length(l1 @ l2) = Length l1 + Length l2)
±	(µl:'a LIST∑ Length(Rev l) = Length l)
Æ);
a(once_rewrite_tac[taut_rule¨µp q∑ p ± q § p ± (p ¥ q)Æ]);
a(±_tac THEN1 (REPEAT strip_tac THEN list_induction_tac¨l1:'a LISTÆ THEN
	asm_rewrite_tac[rev_def, length_def, append_def] THEN PC_T1 "lin_arith" prove_tac[]));
a(REPEAT strip_tac THEN list_induction_tac¨l:'a LISTÆ THEN
	asm_rewrite_tac[rev_def, length_def] THEN PC_T1 "lin_arith" prove_tac[]);
val €length_rev_append_thm› = pop_thm();
=TEX
=SML
set_goal([], ¨
	µl: 'a LIST∑ Length l = 0 § l = []
Æ);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[length_def]);
a(strip_asm_tac (µ_elim¨lÆlist_cases_thm));
a(all_var_elim_asm_tac1 THEN all_asm_ante_tac THEN rewrite_tac[length_def]);
val €length_eq_0_thm› = pop_thm();
=TEX
=SML
set_goal([], ¨
	µl1 l2 l3:'a LIST∑ (l1 @ l2) @ l3 = l1 @ l2 @ l3
Æ);
a(REPEAT strip_tac THEN list_induction_tac¨l1:'a LISTÆ THEN
	asm_rewrite_tac[append_def]);
val €append_assoc_thm› = pop_thm();
=TEX
=SML
set_goal([], ¨
	µl∑ [] @ l = l ± l @ [] = l
Æ);
a(rewrite_tac[append_def]
	THEN REPEAT strip_tac THEN list_induction_tac¨l:'a LISTÆ THEN
	asm_rewrite_tac[append_def]);
val €append_empty_thm› = pop_thm();
=TEX
=SML
set_goal([], ¨
	µl1 l2 ∑ Rev (l1 @ l2) = Rev l2 @ Rev l1
Æ);
a(REPEAT strip_tac THEN list_induction_tac¨l1:'a LISTÆ THEN
	asm_rewrite_tac[rev_def, append_def, append_assoc_thm, append_empty_thm]);
val €rev_append_thm› = pop_thm();
=TEX
=SML
set_goal([], ¨
	µl1 l2 ∑ l1 @ l2 = [] § l1 = [] ± l2 = []
Æ);
a(µ_tac THEN list_induction_tac¨l1: 'a LISTÆ THEN asm_rewrite_tac[append_def]);
val €append_eq_empty_thm› = pop_thm();
=TEX
=SML
set_goal([], ¨
	µl ∑ Rev l = [] § l = []
Æ);
a(µ_tac THEN list_induction_tac¨l: 'a LISTÆ THEN asm_rewrite_tac[append_eq_empty_thm, rev_def]);
val €rev_eq_empty_thm› = pop_thm();
=TEX
=SML
set_goal([], ¨
	µl ∑ Rev(Rev l) = l
Æ);
a(µ_tac THEN list_induction_tac¨l: 'a LISTÆ THEN
	asm_rewrite_tac[rev_def, rev_append_thm, append_empty_thm, append_def]);
val €rev_rev_thm› = pop_thm();
=TEX
=SML
set_goal([], ¨
	(µf n∑ Length(f To n) = n)
Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ THEN
	asm_rewrite_tac[length_rev_append_thm, length_def, to_def]);
val €length_to_thm› = pop_thm();
=TEX
=SML
set_goal([], ¨
	(µf:'a ≠ 'b; l∑ Length(Map f l) = Length l)
Æ);
a(REPEAT strip_tac THEN list_induction_tac¨l:'a LISTÆ THEN
	asm_rewrite_tac[length_def, map_def]);
val €length_map_thm› = pop_thm();
=TEX
The next result gives the rule for evaluating a polynomial starting with the
leading term.
=SML
set_goal([], ¨
	(µx∑ PolyEval (Rev []) x = ÓØ 0)
±	(µc l x∑ PolyEval (Rev (Cons c l)) x = c*x^Length l + PolyEval (Rev l) x)
Æ);
a(REPEAT strip_tac THEN1 rewrite_tac[rev_def, poly_eval_def]);
a(intro_µ_tac(¨cÆ, ¨cÆ) THEN list_induction_tac¨lÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[rev_def, poly_eval_def, length_def, Ø_Ó_exp_def, append_def]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
a(rewrite_tac[rev_def, poly_eval_def, length_def, Ø_Ó_exp_def, append_def,
	poly_eval_append_thm, length_rev_append_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €poly_eval_rev_thm› = save_pop_thm "poly_eval_rev_thm";
=TEX
The following is the identity for the difference of two like powers:
\[
(x-y)(x^n + yx^{n-1} + \ldots + y^jx^{n-j} + \ldots y^n) = x^{n+1} - y^{n+1}
\]
=SML
set_goal([], ¨
	µn x y∑ (x - y)*PolyEval (Rev((Ãm∑y^m) To (n+1))) x = x^(n+1) - y^(n+1)
Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ);
(* *** Goal "1" *** *)
a(pure_rewrite_tac[to_def, Ø_Ó_exp_def, append_def, poly_eval_def, rev_def]);
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(pure_once_rewrite_tac[to_def, Ø_Ó_exp_def]);
a(pure_asm_rewrite_tac[rev_append_thm, rev_def, poly_eval_append_thm,
	append_empty_thm, Ø_times_plus_distrib_thm, length_def, Ø_Ó_exp_def,
	µ_elim¨x * ÓØ 1Æ Ø_times_order_thm]);
a(rewrite_tac[poly_eval_def, Ø_Ó_exp_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €poly_diff_powers_thm› = save_pop_thm "poly_diff_powers_thm";
=TEX
=SML
set_goal([], ¨
	µl1 l2∑ Length(PlusCoeffs l1 l2) = if Length l2 < Length l1 then Length l1 else Length l2
Æ);
a(µ_tac THEN list_induction_tac¨l1:Ø LISTÆ THEN1 rewrite_tac[length_def, plus_coeffs_def]);
a(REPEAT strip_tac THEN list_induction_tac¨l2:Ø LISTÆ THEN
	 asm_rewrite_tac[length_def, plus_coeffs_def]);
a(cases_tac¨Length l2 < Length l1Æ THEN asm_rewrite_tac[]);
val €length_plus_coeffs_thm› = save_pop_thm "length_plus_coeffs_thm";
=TEX
The following is the special case of polynomial division in which the divisor
is linear. In this special case, we do not need the notion of the degree of
a polynomial to state the result (which is very fortunate, since we plan to
use this in deriving the theory of polynomial degrees). In informal notation
the result is that if $f$ is any polynomial (the one whose coefficient
list is given by $l1$ in the formal statement), then there is another polynomial
$g$ (the one whose coefficients are given by $l2$ in the formal statement)
with a shorter list of coefficients and such that $f(x) = (x-a)g(x) + r$
for some real number $r$.

The proof below follows a slightly different pattern from the text book
proof, which works by induction on the degree of the dividend (to divide
$f = a_{n+1}x^{n+1} + a_{n}x^{n} + \ldots + a_0$ by $x - c$, one has
$f - a_nx^{n}(x-c) = g$ where $g$ has degree less than that of $f$ and
one proceeds by induction on the degrees). Here, we use list induction
on the list of coefficients (reversed, i.e., leading coefficient first).
If $f =a_{n+1}x^n + a_{n}x^{n} + \ldots + a_0$, then by a list induction,
we can write $h = a_{n}x^{n} + \ldots + a_0$ as $(x-c)h_1 + r_1$
where the list of coefficients for $h_1$ is shorter than that for
$h$ and we can write $a_{n+1}x^{n+1}$ as $a_{n+1}(x - c)(x^n + cx^{n-1} + \ldots + c^n) + a_{n+1}c^{n+1}$, by the identity for the difference of two like powers. Adding
these representations for $h$ and $a_{n+1}x^{n+1}$ gives the required representation
for $f$. There is not much to choose between the two approaches except that this one
involves less fiddling around with lists of coefficients given the tools we have to hand.

=SML
set_goal([], ¨
	µl1 c∑ ≥l1 = []
¥	∂l2 r∑
		Length l2 < Length l1 
	±	(Ãx∑ PolyEval l1 x) = (Ãx∑ (x - c)*PolyEval l2 x + r)
Æ);
a(lemma_tac¨
	µl1 c∑ ≥l1 = []
¥	∂l2 r∑
		Length l2 < Length l1 
	±	(Ãx∑ PolyEval (Rev l1) x) = (Ãx∑ (x - c)*PolyEval l2 x + r)Æ);
(* *** Goal "1" *** *)
a(REPEAT µ_tac THEN list_induction_tac¨l1 : Ø LISTÆ THEN1 rewrite_tac[]);
(* *** Goal "1.1" *** *)
a(all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(∂_tac¨[]Æ THEN ∂_tac¨xÆ THEN
	rewrite_tac[length_def, rev_def, poly_eval_def, append_empty_thm]);
(* *** Goal "1.2" *** *)
a(pure_rewrite_tac[poly_eval_rev_thm]);
a(REPEAT strip_tac);
a(lemma_tac¨∂m∑m + 1 = Length l1Æ THEN1
	(GET_NTH_ASM_T 3 ante_tac THEN rewrite_tac[less_def, º_def]
	THEN REPEAT strip_tac THEN ∂_tac¨Length l2 + iÆ
	THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(∂_tac¨PlusCoeffs(Map (Ãt∑x*t) (Rev ((Ã j∑ c ^ j) To (m + 1)))) l2Æ
	THEN ∂_tac¨x*c^(m+1) + rÆ);
a(REPEAT strip_tac THEN1
	asm_rewrite_tac[length_to_thm, length_plus_coeffs_thm,
		length_rev_append_thm, length_def, length_map_thm]);
a(pure_rewrite_tac (map (conv_rule (ONCE_MAP_C eq_sym_conv))
		[const_times_eval_thm, plus_eval_thm]));
a(GET_NTH_ASM_T 3 (pure_rewrite_thm_tac o rewrite_rule[]));
a(PC_T1 "predicates" rewrite_tac[]);
a(pure_asm_rewrite_tac[µ_elim¨xÆØ_times_order_thm,
	Ø_times_plus_distrib_thm, poly_diff_powers_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(lemma_tac¨≥Rev l1 = []Æ THEN1 asm_rewrite_tac[rev_eq_empty_thm]);
a(list_spec_nth_asm_tac 3 [¨Rev l1Æ, ¨cÆ]);
a(DROP_NTH_ASM_T 2 (asm_tac o rewrite_rule[length_rev_append_thm]));
a(DROP_NTH_ASM_T 2 (asm_tac o rewrite_rule[rev_rev_thm]));
a(∂_tac ¨l2Æ THEN ∂_tac ¨rÆ THEN asm_rewrite_tac[]);
val €poly_linear_div_thm› = save_pop_thm "poly_linear_div_thm";
=TEX
We can now prove that a polynomial in $x$ which vanishes for all sufficiently
large $x$ is identically zero.
=SML
set_goal([], ¨µf c∑
	f ç PolyFunc ± (µx∑ c < x ¥ f x = ÓØ 0)
¥	(µx∑f x = ÓØ 0)
Æ);
a(lemma_tac¨µm l c∑ Length l º m ± (µx∑ c < x ¥ PolyEval l x = ÓØ 0)
¥	(µx∑PolyEval l x = ÓØ 0)
Æ);
(* *** Goal "1" *** *)
a(µ_tac THEN induction_tac¨m:ÓÆ THEN1 REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(all_fc_tac[length_eq_0_thm] THEN asm_rewrite_tac[poly_eval_def]);
(* *** Goal "1.2" *** *)
a(REPEAT µ_tac THEN ¥_tac);
a(cases_tac¨Length l º mÆ THEN1
	(GET_NTH_ASM_T 4 bc_thm_tac THEN asm_prove_tac[]));
a(lemma_tac ¨Length l = m + 1Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(lemma_tac¨≥l = []Æ THEN1
	(contr_tac THEN all_var_elim_asm_tac1 THEN all_asm_ante_tac
	THEN rewrite_tac[length_def]));
a(strip_asm_tac(rewrite_rule[]
	(list_µ_elim[¨lÆ, ¨c + ÓØ 1Æ] poly_linear_div_thm)));
a(TOP_ASM_T (ante_tac o µ_elim¨c + ÓØ 1Æ) THEN
	conv_tac(ONCE_MAP_C Ø_anf_conv));
a(GET_NTH_ASM_T 6 (rewrite_thm_tac o rewrite_rule[] o µ_elim¨ÓØ 1 + cÆ));
a(strip_tac THEN all_var_elim_asm_tac1);
a(lemma_tac¨Length l2 º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(lemma_tac¨µ x∑ c + ÓØ 1 < x ¥ PolyEval l2 x = ÓØ 0Æ);
(* *** Goal "1.2.1" *** *)
a(swap_nth_asm_concl_tac 2 THEN REPEAT strip_tac);
a(lemma_tac¨c < xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(∂_tac¨xÆ THEN LIST_GET_NTH_ASM_T [9] (ALL_FC_T rewrite_tac));
a(conv_tac (RAND_C eq_sym_conv) THEN rewrite_tac[Ø_times_eq_0_thm]);
a(REPEAT strip_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2" *** *)
a(list_spec_nth_asm_tac 10 [¨l2Æ, ¨c + ÓØ 1Æ] THEN1 all_asm_fc_tac[]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext" rewrite_tac[poly_func_eq_poly_eval_thm] THEN
	REPEAT µ_tac THEN ¥_tac);
a(asm_rewrite_tac[] THEN GET_NTH_ASM_T 3 bc_thm_tac);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a(∂_tac¨cÆ THEN ∂_tac¨Length lÆ THEN asm_rewrite_tac[]);
val €poly_eventually_0_eq_0_thm› = save_pop_thm "poly_eventually_0_eq_0_thm";
=TEX
\subsection{Limits and Continuity}
\subsubsection{Lemmas about the Absolute Value Function Etc.}
We will need a number of facts about absolute values etc.
Firstly, reciprocals of positive numbers are positive.
=TEX
=SML
set_goal([], ¨µx∑ ÓØ 0 < x ¥ ÓØ 0 < x õ-õ1Æ);
a(contr_tac);
a(lemma_tac¨≥x = ÓØ 0 ± (x õ-õ1 = ÓØ 0 ≤ ÓØ 0 < ~(x õ-õ1))Æ THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1" *** *)
a(ALL_FC_T (MAP_EVERY ante_tac) [Ø_times_recip_thm] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_fc_tac [Ø_times_recip_thm, Ø_0_less_0_less_times_thm]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_0_less_recip_thm› = save_pop_thm "Ø_0_less_recip_thm";
=TEX
Absolute values are non-negative:
=TEX
=SML
set_goal([], ¨µx:Ø∑ ÓØ 0 º Abs xÆ);
a(REPEAT strip_tac THEN rewrite_tac[get_spec¨AbsâRÆ]);
a(cases_tac ¨ÓØ 0 º xÆ
	THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_0_º_abs_thm› = save_pop_thm "Ø_0_º_abs_thm";
=TEX
Next, the triangle inequality:
=SML
set_goal([], ¨µx y:Ø∑ Abs(x + y) º Abs x + Abs yÆ);
a(REPEAT strip_tac THEN rewrite_tac[get_spec¨AbsâRÆ]);
a(MAP_EVERY cases_tac [¨ÓØ 0 º xÆ, ¨ÓØ 0 º yÆ, ¨ÓØ 0 º x + yÆ]
	THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_abs_plus_thm› = save_pop_thm "Ø_abs_plus_thm";
=TEX
\ldots and again in a formulation that is nice for back-chaining:
=SML
set_goal([], ¨µx y z:Ø∑ Abs x º Abs (y + z) ¥ Abs x º Abs y + Abs zÆ);
a(REPEAT strip_tac THEN bc_thm_tac Ø_º_trans_thm);
a(∂_tac¨Abs(y + z)Æ THEN asm_rewrite_tac[Ø_abs_plus_thm]);
val €Ø_abs_plus_bc_thm› = save_pop_thm "Ø_abs_plus_bc_thm";
=TEX
Absolute values kill signs:
=SML
set_goal([], ¨µx:Ø∑ Abs(~x) = Abs xÆ);
a(REPEAT strip_tac THEN rewrite_tac[get_spec¨AbsâRÆ]);
a(MAP_EVERY cases_tac [¨ÓØ 0 º xÆ, ¨ÓØ 0 º ~xÆ]
	THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_abs_minus_thm› = save_pop_thm "Ø_abs_minus_thm";
=TEX
Absolute values commute with multiplication:
=SML
set_goal([], ¨µx y:Ø∑ Abs(x * y) = Abs x * Abs yÆ);
a(lemma_tac ¨µx y:Ø∑ ÓØ 0 º x ± ÓØ 0 º y ¥ Abs(x * y) = Abs x * Abs yÆ
	THEN REPEAT strip_tac THEN1 (all_fc_tac[Ø_0_º_0_º_times_thm]
		THEN asm_rewrite_tac[get_spec¨AbsâRÆ]));
a(cases_tac¨ÓØ 0 º xÆ THEN cases_tac¨ÓØ 0 º yÆ THEN1 all_asm_fc_tac[]);
(* *** Goal "1" *** *)
a(lemma_tac¨ÓØ 0 º ~yÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_ASM_FC_T (MAP_EVERY ante_tac)[]);
a(LEMMA_T ¨x* ~y = ~(x*y)Æ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(rewrite_tac[Ø_abs_minus_thm]);
(* *** Goal "2" *** *)
a(lemma_tac¨ÓØ 0 º ~xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_ASM_FC_T (MAP_EVERY ante_tac)[]);
a(LEMMA_T ¨~x * y = ~(x*y)Æ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(rewrite_tac[Ø_abs_minus_thm] THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(lemma_tac¨ÓØ 0 º ~x ± ÓØ 0 º ~yÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_ASM_FC_T (MAP_EVERY ante_tac)[]);
a(LEMMA_T ¨~x * ~y = (x*y)Æ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(rewrite_tac[Ø_abs_minus_thm]);
val €Ø_abs_times_thm› = save_pop_thm "Ø_abs_times_thm";
=TEX
Only 0 has absolute value 0:
=SML
set_goal([], ¨µx∑ Abs x = ÓØ 0 § x = ÓØ 0Æ);
a(strip_tac THEN rewrite_tac[get_spec¨AbsâRÆ]);
a(cases_tac¨ÓØ 0 º xÆ THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €Ø_abs_eq_0_thm› = save_pop_thm "Ø_abs_eq_0_thm";
=TEX
=SML
set_goal([], ¨Abs (ÓØ 0) = ÓØ 0Æ);
a(rewrite_tac[get_spec¨AbsâRÆ]);
val €Ø_abs_0_thm› = save_pop_thm "Ø_abs_0_thm";
=TEX
Absolute values commute with reciprocal:
=SML
set_goal([], ¨µx∑ ≥x = ÓØ 0 ¥ Abs (x õ-õ1) = (Abs x) õ-õ1Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨Abs(x * x õ-õ1) = ÓØ 1Æ ante_tac THEN1
	(ALL_FC_T rewrite_tac[Ø_times_recip_thm]));
a(rewrite_tac[Ø_abs_times_thm] THEN strip_tac);
a(lemma_tac¨≥Abs x = ÓØ 0ÆTHEN1 asm_rewrite_tac[Ø_abs_eq_0_thm]);
a(LEMMA_T¨(Abs x * (Abs x) õ-õ1) * Abs(x õ-õ1) = (Abs x)õ-õ1Æ ante_tac THEN1
	asm_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b c:Ø∑(a*b)*c = b*a*cÆ]);
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
val €Ø_abs_recip_thm› = save_pop_thm "Ø_abs_recip_thm";
=TEX
A monotonicity property for absolute values and multiplication:
=SML
set_goal([], ¨µx t y u:Ø∑ Abs x < t ± Abs y < u ¥ Abs x * Abs y < t*uÆ);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim¨xÆ Ø_0_º_abs_thm));
a(strip_asm_tac (µ_elim¨yÆ Ø_0_º_abs_thm));
a(lemma_tac¨ÓØ 0 < t ± ÓØ 0 < uÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(cases_tac ¨Abs x = ÓØ 0Æ THEN1 
	(all_fc_tac[Ø_0_less_0_less_times_thm] THEN asm_rewrite_tac[]));
a(cases_tac ¨Abs y = ÓØ 0Æ THEN1 
	(all_fc_tac[Ø_0_less_0_less_times_thm] THEN asm_rewrite_tac[]));
a(lemma_tac ¨ÓØ 0 < Abs x ± ÓØ 0 < Abs yÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(bc_thm_tac Ø_less_trans_thm);
a(∂_tac¨Abs x * uÆ THEN REPEAT strip_tac
	THEN1 bc_thm_tac Ø_times_mono_thm THEN REPEAT strip_tac);
a(once_rewrite_tac[Ø_times_comm_thm]
	THEN bc_thm_tac Ø_times_mono_thm THEN REPEAT strip_tac);
val €Ø_abs_less_times_thm› = save_pop_thm "Ø_abs_less_times_thm";
=TEX
Now a result about absolute values and reciprocals (of positive
reals).
Reciprocal of positive reals is order reversing:
=SML
set_goal([], ¨µx y:Ø∑ ÓØ 0 < x ± ÓØ 0 < y ± x < y ¥ y õ-õ1 < x õ-õ1Æ);
a(REPEAT strip_tac);
a(lemma_tac¨y õ-õ1 * x õ-õ1 * x < y õ-õ1 * x õ-õ1 * yÆ);
(* *** Goal "1" *** *)
a(all_fc_tac[Ø_0_less_recip_thm]);
a(REPEAT (bc_thm_tac Ø_times_mono_thm THEN REPEAT strip_tac));
(* *** Goal "2" *** *)
a(lemma_tac¨≥x = ÓØ 0 ± ≥y = ÓØ 0Æ THEN1
	(LIST_GET_NTH_ASM_T [3, 4] (MAP_EVERY ante_tac) THEN
		PC_T1 "Ø_lin_arith" prove_tac[]));
a(DROP_NTH_ASM_T 3 ante_tac);
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨
	y õ-õ1 * x õ-õ1 * x = y õ-õ1 * (x * x õ-õ1)
±	y õ-õ1 * x õ-õ1 * y = x õ-õ1 * (y * y õ-õ1)Æ]);
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
val €Ø_less_recip_less_thm› = save_pop_thm "Ø_less_recip_less_thm";
=TEX
Non-zero numbers have positive absolute values:
=SML
set_goal([], ¨µx∑ ≥x = ÓØ 0 § ÓØ 0 < Abs xÆ);
a(REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 º Abs xÆ THEN1 rewrite_tac[Ø_0_º_abs_thm]);
a(lemma_tac¨≥ Abs x = ÓØ 0Æ THEN1 asm_rewrite_tac[Ø_abs_eq_0_thm]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
val €Ø_≥_0_abs_thm› = save_pop_thm "Ø_≥_0_abs_thm";
=TEX
\subsubsection{The Archimedean Property}
We present the archimedean property in two guises:
the usual formulation, any real is bounded above by some natural number:
=SML
set_goal([], ¨µx:Ø∑ ∂m∑ x < ÓØ mÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨xÆ, ¨ÓØ 0Æ]Ø_less_cases_thm) THEN1 asm_prove_tac[]
	THEN1 ∂_tac¨1Æ THEN1 asm_rewrite_tac[]);
a(Ø_delta_induction_tac¨xÆ);
a(∂_tac¨ÓØ 1Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨ÓØ 2Æ THEN REPEAT strip_tac);
a(∂_tac¨3Æ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨m+1Æ THEN rewrite_tac[ÓØ_plus_homomorphism_thm]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_archimedean_thm› = save_pop_thm "Ø_archimedean_thm";
=TEX
\ldots and a reciprocal version: any positive real is bounded
below by the reciprocal of a positive natural number.
=SML
set_goal([], ¨µx:Ø∑ ÓØ 0 < x ¥ ∂m∑ (ÓØ (m+1))õ-õ1 < xÆ);
a(REPEAT strip_tac THEN all_fc_tac[Ø_0_less_recip_thm]);
a(strip_asm_tac(µ_elim¨x õ-õ1ÆØ_archimedean_thm));
a(lemma_tac¨x õ-õ1 < ÓØ (m+1)Æ THEN1
	(rewrite_tac[ÓØ_plus_homomorphism_thm] THEN
		bc_thm_tac Ø_less_trans_thm THEN ∂_tac ¨ÓØ mÆ THEN REPEAT strip_tac));
a(DROP_NTH_ASM_T 2 discard_tac);
a(lemma_tac¨ÓØ 0 < ÓØ (m+1)Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [Ø_less_recip_less_thm]);
a(lemma_tac¨≥x = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses] THEN prove_tac[]);
val €Ø_archimedean_recip_thm› = save_pop_thm "Ø_archimedean_recip_thm";
=TEX
\subsubsection{Theorems about Limits}
We now prove some basic facts about limits.

Firstly, constant sequences have limits:
=SML
set_goal([], ¨µc∑(Ãm∑ c) --> cÆ);
a(REPEAT strip_tac THEN rewrite_tac[lim_seq_def]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val €const_lim_seq_thm› = save_pop_thm "const_lim_seq_thm";
=TEX
Secondly, if two sequences each have a limit, then so does their
sum and its limit is the sum of the limits:
=SML
set_goal([], ¨µs1 c1 s2 c2∑
	s1 --> c1 ± s2 --> c2 ¥ (Ãm∑s1 m + s2 m) --> c1 + c2Æ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac ¨ÓØ 0 < e / ÓØ 2 Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 2 discard_tac THEN asm_fc_tac[]);
a(∂_tac¨n + n'Æ THEN REPEAT strip_tac);
a(lemma_tac¨n º m ± n' º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T [4, 5] all_fc_tac);
a(LEMMA_T ¨(s1 m + s2 m) + ~c1 + ~c2 = (s1 m + ~c1) + (s2 m + ~c2)Æ
	rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(bc_thm_tac Ø_º_less_trans_thm);
a(∂_tac¨Abs (s1 m + ~ c1) + Abs (s2 m + ~ c2)Æ THEN rewrite_tac[Ø_abs_plus_thm]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €plus_lim_seq_thm› = save_pop_thm "plus_lim_seq_thm";
=TEX
We now want to give the expected result on the product of two sequences
with limits. We need some preliminaries. The first is of general use,
it says that any sequence with a limit has bounded absolute values:
=SML
set_goal([], ¨µs c∑ s --> c ¥ ∂b∑ ÓØ 0 < b ± µm∑ Abs(s m) < bÆ);
a(lemma_tac¨µn; s: Ó ≠ Ø; b1∑ ÓØ 0 < b1 ± (µm∑n º m ¥ Abs(s m) < b1) ¥
	(∂b2∑ÓØ 0 < b2 ± µ m∑ Abs(s m) < b2)Æ);
(* *** Goal "1" *** *)
a(strip_tac THEN induction_tac ¨n:ÓÆ THEN1 prove_tac[]);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 bc_thm_tac);
a(∂_tac¨Abs(s n) + b1Æ);
a(spec_nth_asm_tac 1 ¨n+1Æ);
a(strip_asm_tac(µ_elim¨s(n+1)Æ Ø_0_º_abs_thm));
a(strip_asm_tac(µ_elim¨s nÆ Ø_0_º_abs_thm));
a(REPEAT strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(cases_tac¨m' = nÆ THEN1 (all_var_elim_asm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨n + 1 º m'Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 bc_thm_tac);
a(spec_nth_asm_tac 1 ¨ÓØ 1Æ);
a(∂_tac¨nÆ THEN ∂_tac¨Abs c + ÓØ 2Æ);
a(REPEAT strip_tac THEN1
	(strip_asm_tac(µ_elim¨cÆ Ø_0_º_abs_thm) THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(all_asm_fc_tac[]);
a(ante_tac (list_µ_elim[¨s m + ~cÆ, ¨cÆ]Ø_abs_plus_thm));
a(rewrite_tac[Ø_plus_assoc_thm] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €lim_seq_bounded_thm› = save_pop_thm "lim_seq_bounded_thm";
=TEX
Now a more specialised lemma which is the arithmetic core
of the argument about the product of two sequences:
=SML
set_goal([], ¨µe t x y c d∑
	Abs(x - c) < e * (ÓØ 2*t)õ-õ1
±	Abs(y - d) < e * (ÓØ 2*t)õ-õ1
±	Abs x < t
±	Abs d < t
¥	Abs (x*y - c*d) < e	Æ);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(LEMMA_T ¨x*y + ~(c*d) = x*(y + ~d) + (x + ~c)*dÆ rewrite_thm_tac
	THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨Abs(x*(y + ~d)) + Abs((x + ~c)*d)Æ
	THEN rewrite_tac[Ø_abs_plus_thm, Ø_abs_times_thm]);
a(bc_thm_tac Ø_less_º_trans_thm THEN ∂_tac¨t*e*(ÓØ 2*t)õ-õ1 + t*e*(ÓØ 2*t)õ-õ1Æ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ø_plus_mono_thm2);
a(REPEAT strip_tac THEN1 (bc_thm_tac Ø_abs_less_times_thm THEN REPEAT strip_tac));
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µx∑t*e*x = (e*x)*tÆ]);
a(bc_thm_tac Ø_abs_less_times_thm THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(conv_tac (LEFT_C Ø_anf_conv));
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µx y∑x*e*t*y = e*(x*t)*yÆ]);
a(lemma_tac¨≥ ÓØ 2 * t = ÓØ 0Æ THEN1
	(strip_asm_tac(µ_elim¨xÆ Ø_0_º_abs_thm) THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
val €times_lim_seq_thm› = pop_thm ();
=TEX
Now we can prove that the product of two sequences each of which has a limit has
the product of the limits as its limit:
=SML
set_goal([], ¨µs1 c1 s2 c2∑
	s1 --> c1 ± s2 --> c2 ¥ (Ãm∑s1 m * s2 m) --> c1 * c2Æ);
a(REPEAT strip_tac THEN rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[lim_seq_def]));
a(all_fc_tac[lim_seq_bounded_thm]);
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[lim_seq_def]));
a(strip_asm_tac(µ_elim¨c2Æ Ø_0_º_abs_thm));
a(lemma_tac¨ÓØ 0 < e*(ÓØ 2 * (b + Abs c2))õ-õ1Æ);
(* *** Goal "1" *** *)
a(bc_thm_tac Ø_0_less_0_less_times_thm THEN REPEAT strip_tac);
a(bc_thm_tac Ø_0_less_recip_thm THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T [5, 7] (MAP_EVERY ante_tac));
a(all_asm_fc_tac[] THEN REPEAT strip_tac);
a(∂_tac¨n+n'Æ THEN REPEAT strip_tac);
a(lemma_tac¨n º m ± n' º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T[6, 7] all_fc_tac);
a(bc_thm_tac (rewrite_rule[]times_lim_seq_thm));
a(∂_tac¨b + Abs c2Æ THEN asm_rewrite_tac[]);
a(spec_nth_asm_tac 13 ¨mÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €times_lim_seq_thm› = save_pop_thm "times_lim_seq_thm";
=TEX
We can now show by polynomial induction that polynomial functions preserve limits.
As we will see shortly, this shows that every polynomial function is continuous.
=SML
set_goal([], ¨µf s t∑f ç PolyFunc ± s --> t ¥ (Ãx∑ f (s x)) --> f tÆ);
a(REPEAT strip_tac);
a(poly_induction_tac ¨fÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[const_lim_seq_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[»_axiom]);
(* *** Goal "3" *** *)
a(ALL_FC_T (MAP_EVERY ante_tac) [plus_lim_seq_thm]);
a(rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(ALL_FC_T (MAP_EVERY ante_tac) [times_lim_seq_thm]);
a(rewrite_tac[] THEN REPEAT strip_tac);
val €poly_lim_seq_thm› = save_pop_thm "poly_lim_seq_thm";
=TEX
Finally, moving on from polynomials, we will need to reason
about (particular) rational functions from time to time and
this requires the usual result about the limit of
a sequence of reciprocals. First a purely algebraic lemma:
=SML
set_goal([], ¨µx y∑ ≥x = ÓØ 0 ± ≥y = ÓØ 0 ¥
	(x õ-õ1 + y õ-õ1) = (x + y) * x õ-õ1 * y õ-õ1Æ);
a(REPEAT strip_tac THEN conv_tac (RIGHT_C Ø_anf_conv));
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
a(rewrite_tac[Ø_times_assoc_thm1] THEN ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
val €Ø_plus_recip_thm› = save_pop_thm"Ø_plus_recip_thm";
=SML
set_goal([], ¨µs∑ s --> t ± ≥t = ÓØ 0 ¥ (Ãm∑ (s m) õ-õ1) --> t õ-õ1Æ);
a(REPEAT strip_tac THEN all_fc_tac [lim_seq_bounded_thm]);
a(DROP_NTH_ASM_T 4 ante_tac THEN
	rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(all_fc_tac[Ø_≥_0_abs_thm]);
a(lemma_tac¨ÓØ 0 < (1/2)*Abs tÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨∂n1∑µ m∑ n1 º m ¥ (1/2)*Abs t < Abs(s m)Æ);
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 4 ¨(1/2)*Abs tÆ);
a(∂_tac ¨nÆ THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [2] all_fc_tac);
a(CONTR_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(lemma_tac¨Abs t < Abs tÆ);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨Abs(s m) + Abs(~(s m + ~t))Æ);
a(REPEAT strip_tac THEN_LIST
	[bc_thm_tac Ø_abs_plus_bc_thm,
	rewrite_tac[Ø_abs_minus_thm] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]]);
a(conv_tac (ONCE_MAP_C Ø_anf_conv) THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(lemma_tac ¨ÓØ 0 < Abs t*Abs t*eÆ THEN1
	(all_fc_tac[Ø_0_less_0_less_times_thm] THEN all_fc_tac[Ø_0_less_0_less_times_thm]));
a(lemma_tac ¨ÓØ 0 < (1/2)*Abs t*Abs t*eÆ THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 7 ¨(1/2)*Abs t*Abs t*eÆ);
a(∂_tac¨n1 + nÆ THEN REPEAT strip_tac);
a(lemma_tac¨n1 º m ± n º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 7 ¨mÆ);
a(LEMMA_T¨≥Abs(s m) = ÓØ 0Æ (asm_tac o rewrite_rule[Ø_abs_eq_0_thm])
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨≥ ~ t = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[
	conv_rule(ONCE_MAP_C (RIGHT_C eq_sym_conv)) Ø_minus_recip_thm,
	Ø_plus_recip_thm]);
a(spec_nth_asm_tac 7 ¨mÆ);
a(once_rewrite_tac[Ø_abs_times_thm]);
a(lemma_tac¨≥Abs t = ÓØ 0Æ THEN1 asm_rewrite_tac[Ø_abs_eq_0_thm]);
a(LEMMA_T ¨e = ((1/2)*Abs t * Abs t * e)*(Abs ((1/2)*t))õ-õ1*(Abs t)õ-õ1Æ once_rewrite_thm_tac
	THEN1 (rewrite_tac[Ø_abs_times_thm] THEN
		ALL_FC_T rewrite_tac[
			rewrite_rule[](µ_elim¨1/2Æ(hd(rev(strip_±_rule Ø_recip_clauses))))] THEN
			rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
			¨µx y∑((1/2)*x*x*y)*(ÓØ 2 * x õ-õ1)*x õ-õ1=
				 (x*x õ-õ1) * (x*x õ-õ1) * yÆ]
		THEN ALL_FC_T rewrite_tac[Ø_times_recip_thm]));
a(bc_thm_tac Ø_abs_less_times_thm THEN REPEAT strip_tac);
a(once_rewrite_tac[Ø_times_comm_thm] THEN rewrite_tac[Ø_abs_times_thm]);
a(ALL_FC_T rewrite_tac[Ø_minus_recip_thm] THEN rewrite_tac[Ø_abs_minus_thm]);
a(ALL_FC_T rewrite_tac[Ø_abs_recip_thm] THEN bc_thm_tac Ø_times_mono_thm);
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac Ø_0_less_recip_thm THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(bc_thm_tac Ø_less_recip_less_thm THEN
	LIST_GET_NTH_ASM_T [14, 5] (MAP_EVERY ante_tac) THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €recip_lim_seq_thm› = save_pop_thm "recip_lim_seq_thm";
=TEX
\subsubsection{Theorems about Continuity}
Most of the work on continuity duplicates reasoning for sequences if carried
out from first principles. To allow us to reuse the material on sequences,
we prove that a function is continuous iff. it preserves limits:
=TEX
=SML
set_goal([], ¨µf x∑ f CtsAt x § µs∑ s --> x ¥ (Ãm∑f(s m)) --> f xÆ);
a(rewrite_tac[cts_at_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨eÆ);
a(spec_nth_asm_tac 4 ¨dÆ);
a(∂_tac¨nÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(contr_tac THEN lemma_tac¨
	∂s∑µm∑ Abs(s m + ~x) < (ÓØ (m+1)) õ-õ1 ± e º Abs(f(s m) + ~(f x))
Æ THEN1 prove_∂_tac THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(lemma_tac¨ÓØ 0 < ÓØ (m' + 1) õ-õ1Æ THEN1
	(bc_thm_tac Ø_0_less_recip_thm THEN rewrite_tac[ÓØ_less_thm]));
a(spec_nth_asm_tac 2 ¨ÓØ (m' + 1) õ-õ1Æ);
a(∂_tac¨yÆ THEN REPEAT strip_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨s --> xÆ THEN1 rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(DROP_NTH_ASM_T 4 discard_tac THEN all_asm_fc_tac[Ø_archimedean_recip_thm]);
a(∂_tac¨m + 2Æ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨ÓØ (m'+1)õ-õ1Æ THEN asm_rewrite_tac[]);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨ÓØ (m+1)õ-õ1Æ THEN asm_rewrite_tac[]);
a(bc_thm_tac Ø_less_recip_less_thm THEN
	rewrite_tac[ÓØ_plus_homomorphism_thm, ÓØ_less_thm]
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2.2.2" *** *)
a(ALL_ASM_FC_T (MAP_EVERY ante_tac)[]);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(∂_tac ¨eÆ THEN REPEAT strip_tac);
a(∂_tac ¨nÆ THEN asm_rewrite_tac[Ø_≥_less_º_thm]);
val €cts_lim_seq_thm› = save_pop_thm "cts_lim_seq_thm";
=TEX
It is occasionally convenient to have the following stronger variant
on the previous theorem, which lets us demonstrate continuity of a function $f$
at a point $x$ by considering sequences that tend to $x$ without ever being
equal to $x$.
Deriving this from the previous theorem is conveniently done using some
lemmas that should be of general use.
=SML
set_goal([], ¨µp s1 s2 x∑ s1 --> x ± s2 --> x ¥ (Ãm∑if p m then s1 m else s2 m) --> xÆ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(∂_tac¨n + n'Æ THEN REPEAT strip_tac);
a(lemma_tac¨n º m ± n' º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T [4, 5] all_fc_tac);
a(cases_tac¨p mÆ THEN asm_rewrite_tac[]);
val €lim_seq_choice_thm› = save_pop_thm "lim_seq_choice_thm";
=TEX
=SML
set_goal([], ¨µx∑ (Ãm∑x + ÓØ(m+1)õ-õ1) --> xÆ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(all_fc_tac[Ø_archimedean_recip_thm]);
a(∂_tac¨m+1Æ THEN REPEAT strip_tac);
a(conv_tac(ONCE_MAP_C Ø_anf_conv));
a(lemma_tac¨ÓØ 0 < ÓØ (m+1) ± ÓØ 0 < ÓØ (m'+1)Æ THEN1 rewrite_tac[ÓØ_0_less_thm]);
a(lemma_tac¨ÓØ (m+1) < ÓØ (m'+1)Æ THEN1 
	(asm_rewrite_tac[ÓØ_less_thm] THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(lemma_tac¨ÓØ 0 º ÓØ (m' + 1) õ-õ1Æ THEN1
	(rewrite_tac[Ø_º_def] THEN all_fc_tac[Ø_0_less_recip_thm] THEN asm_rewrite_tac[]));
a(asm_rewrite_tac[Ø_abs_def]);
a(all_fc_tac[Ø_less_recip_less_thm]);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨ÓØ (m + 1) õ-õ1Æ THEN REPEAT strip_tac);
val €lim_seq_recip_Ó_thm› = save_pop_thm "lim_seq_recip_Ó_thm";
=TEX
=SML
set_goal([], ¨µx∑ ∂s∑ s --> x ± (µm∑≥s m = x)Æ);
a(REPEAT strip_tac);
a(∂_tac¨(Ãm∑x + ÓØ(m+1)õ-õ1)Æ THEN rewrite_tac[lim_seq_recip_Ó_thm]);
a(REPEAT strip_tac THEN lemma_tac¨ÓØ 0 < ÓØ (m + 1) õ-õ1Æ THEN_LIST
	[id_tac, PC_T1 "Ø_lin_arith" asm_prove_tac[]]);
a(bc_tac[Ø_0_less_recip_thm] THEN rewrite_tac[ÓØ_0_less_thm]);
val €lim_seq_≥_eq_thm› = save_pop_thm "lim_seq_≥_eq_thm";
=TEX
=SML
set_goal([], ¨µf x∑ f CtsAt x § µs∑ s --> x ± (µm∑≥s m = x) ¥ (Ãm∑f(s m)) --> f xÆ);
a(REPEAT strip_tac THEN1 all_fc_tac[cts_lim_seq_thm]);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨xÆ lim_seq_≥_eq_thm));
a(strip_asm_tac(rewrite_rule[](list_µ_elim[¨Ãm∑s m = xÆ, ¨s'Æ, ¨sÆ, ¨xÆ]lim_seq_choice_thm)));
a(lemma_tac¨µm∑ ≥(Ãm∑ if s m = x then s' m else s m) m = xÆ THEN1 
	(REPEAT strip_tac THEN cases_tac ¨s m = xÆ THEN asm_rewrite_tac[]));
a(DROP_NTH_ASM_T  6 (ante_tac o µ_elim ¨(Ãm∑ if s m = x then s' m else s m)Æ) THEN
	asm_rewrite_tac[]);
a(DROP_ASMS_T discard_tac THEN rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(∂_tac¨nÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(DROP_NTH_ASM_T 2 ante_tac THEN cases_tac¨s m = xÆ THEN asm_rewrite_tac[]);
val €cts_lim_seq_thm1› = save_pop_thm "cts_lim_seq_thm1";
=TEX
A few other simple facts about limits of sequences will be useful.
The following shows that we can ignore any finite leading subsequence of
a sequence when we calculate its limit:
=SML
set_goal([], ¨µm s x∑ (s --> x) § (Ãn∑s (m+n)) --> xÆ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN ∂_tac¨nÆ THEN REPEAT strip_tac);
a(lemma_tac¨n º m+m'Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[] THEN ∂_tac¨n + mÆ THEN REPEAT strip_tac);
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[º_def]) THEN all_var_elim_asm_tac1);
a(SPEC_NTH_ASM_T 1 ¨n+iÆ ante_tac THEN conv_tac (ONCE_MAP_C anf_conv) THEN REPEAT strip_tac);
val €lim_seq_shift_thm› = save_pop_thm "lim_seq_shift_thm";
=TEX
=SML
set_goal([], ¨µs x∑ (s --> x) ± ≥x = ÓØ 0 ¥ ∂n∑µm∑ n º m ¥ ≥s m = ÓØ 0Æ);
a(rewrite_tac[lim_seq_def] THEN contr_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[Ø_≥_0_abs_thm] THEN all_asm_fc_tac[]);
a(spec_nth_asm_tac 3 ¨nÆ);
a(spec_nth_asm_tac 3 ¨mÆ);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[Ø_abs_minus_thm]);
val €lim_seq_≥_0_thm› = save_pop_thm "lim_seq_≥_0_thm";
=TEX
We now show that the polynomial constructions preserve limits.

=SML
set_goal([], ¨µc t∑ (Ãx∑c) CtsAt tÆ);
a(REPEAT strip_tac THEN rewrite_tac[cts_lim_seq_thm, const_lim_seq_thm]);
val €const_cts_thm› = save_pop_thm "const_cts_thm";
=TEX
=SML
set_goal([], ¨µt∑ (Ãx∑x) CtsAt tÆ);
a(REPEAT strip_tac THEN rewrite_tac[cts_lim_seq_thm, »_axiom]);
val €id_cts_thm› = save_pop_thm "id_cts_thm";
=TEX
=SML
set_goal([], ¨µf g t∑ f CtsAt t ± g CtsAt t ¥ (Ãx∑f x + g x) CtsAt tÆ);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [plus_lim_seq_thm]);
a(rewrite_tac[] THEN taut_tac);
val €plus_cts_thm› = save_pop_thm "plus_cts_thm";
=TEX
=SML
set_goal([], ¨µf g t∑ f CtsAt t ± g CtsAt t ¥ (Ãx∑f x * g x) CtsAt tÆ);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [times_lim_seq_thm]);
a(rewrite_tac[] THEN taut_tac);
val €times_cts_thm› = save_pop_thm "times_cts_thm";
=TEX
Now we can show that polynomial functions are continuous everywhere.
We could do this by polynomial induction using the theorems just
proved, but it's even easier to use the last result from the previous section:
=SML
set_goal([], ¨µf t∑ f ç PolyFunc ¥ f CtsAt tÆ);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac
	THEN ALL_FC_T rewrite_tac[poly_lim_seq_thm]);
val €poly_cts_thm› = save_pop_thm "poly_cts_thm";
=TEX
=SML
set_goal([], ¨µf g t∑ f CtsAt g t ± g CtsAt t ¥ (Ãx∑f(g x)) CtsAt tÆ);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac[»_axiom]);
val €comp_cts_thm› = save_pop_thm "comp_cts_thm";
=TEX
=SML
set_goal([], ¨µt∑~ CtsAt tÆ);
a(LEMMA_T ¨~ = (Ãx∑(Ãx∑~(ÓØ 1)) x * (Ãx∑x) x)Æ pure_once_rewrite_thm_tac
	THEN1 (rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(strip_tac THEN bc_thm_tac times_cts_thm);
a(rewrite_tac[const_cts_thm, id_cts_thm]);
val €minus_cts_thm› = save_pop_thm "minus_cts_thm";
=TEX
=SML
set_goal([], ¨µf t∑f CtsAt t ¥ (Ãx∑~(f x)) CtsAt tÆ);
a(REPEAT strip_tac);
a(bc_thm_tac comp_cts_thm THEN REPEAT strip_tac);
a(rewrite_tac[minus_cts_thm]);
val €minus_comp_cts_thm› = save_pop_thm "minus_comp_cts_thm";
=TEX
=SML
set_goal([], ¨µt∑ ≥t = ÓØ 0 ¥ $õ-õ1 CtsAt tÆ);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(bc_thm_tac recip_lim_seq_thm THEN REPEAT strip_tac);
val €recip_cts_thm› = save_pop_thm "recip_cts_thm";
=TEX
=SML
set_goal([], ¨µf t∑f CtsAt t ± ≥f t = ÓØ 0 ¥ (Ãx∑(f x)õ-õ1) CtsAt tÆ);
a(REPEAT strip_tac);
a(bc_thm_tac comp_cts_thm THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[recip_cts_thm]);
val €recip_comp_cts_thm› = save_pop_thm "recip_comp_cts_thm";
=TEX
=SML
fun €un_¬_conv› (v : TERM) : CONV = (fn tm =>
	let	val lhs = mk_app(mk_Ã(v, tm), v);
	in	eq_sym_rule (¬_conv lhs)
	end
);
val €Ã_un_¬_rands_conv› : CONV = (fn tm =>
	let	val (v, _) = dest_Ã tm;
	in	SIMPLE_Ã_C (RANDS_C (un_¬_conv v)) tm
	end
);
=TEX
=SML
val €simple_cts_tac› : TACTIC = (fn gl as (_, tm) => 
	let	val x = snd(dest_app tm);
		val const_thm = all_µ_intro(§_t_intro(all_µ_elim const_cts_thm));
		val id_thm = all_µ_intro(§_t_intro(all_µ_elim id_cts_thm));
	in
	conv_tac (simple_eq_match_conv const_thm) ORELSE
	conv_tac (simple_eq_match_conv id_thm) ORELSE
	(conv_tac (LEFT_C Ã_un_¬_rands_conv) THEN FIRST (map bc_thm_tac [
			plus_cts_thm, times_cts_thm, minus_comp_cts_thm, recip_comp_cts_thm]
		)) ORELSE
	conv_tac (LEFT_C »_conv ORELSE_C RAND_C (LEFT_C ¬_conv))
	end	gl
);
=IGN
set_goal([], ¨(Ãx∑c) CtsAt (ÓØ 2)Æ);
a simple_cts_tac;
val test1 = pop_thm();
set_goal([], ¨(Ãx∑x*y + ÓØ 3) CtsAt tÆ);
a(REPEAT (simple_cts_tac THEN REPEAT strip_tac));
val test2 = pop_thm();
set_goal([], ¨(Ãx∑ÓØ 3 * ((1/2)+x)õ-õ1) CtsAt 1/3Æ);
a(REPEAT (simple_cts_tac THEN REPEAT strip_tac));
a(rewrite_tac[]);
val test2 = pop_thm();
=TEX
\subsection{Derivatives}
Following Harrison, we make much use of Carath\'{e}odory's characterisation
of the derivative in terms of the continuity of a certain function:
=SML
set_goal([], ¨µf c x∑
	(f HasDeriv c) x
§	(∂g∑ (µy∑f y - f x = g(y)*(y - x)) ± g CtsAt x ± g x = c)
Æ);
a(rewrite_tac[has_deriv_def, cts_at_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨Ãz∑ if z = x then c else (f z - f x)/(z - x)Æ
	THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(cases_tac¨y = xÆ THEN asm_rewrite_tac[]);
a(lemma_tac¨≥(y + ~x) = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(rename_tac[(¨xÆ, "x'")] THEN
	ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b∑(a*b)*(y + ~x') = a * (y + ~x') * bÆ]);
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
(* *** Goal "1.2" *** *)
a(all_asm_fc_tac[]);
a(∂_tac¨dÆ THEN REPEAT strip_tac);
a(lemma_tac¨Abs(ÓØ 0) = ÓØ 0Æ THEN1 rewrite_tac[Ø_abs_eq_0_thm]);
a(cases_tac¨y = xÆ THEN1 asm_rewrite_tac[]);
a(ALL_ASM_FC_T asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
a(∂_tac¨dÆ THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
a(lemma_tac¨≥(y + ~x) = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(rename_tac[(¨xÆ, "x'")] THEN
	ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(rewrite_tac[Ø_times_assoc_thm] THEN ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
a(all_var_elim_asm_tac1 THEN DROP_NTH_ASM_T 4 bc_thm_tac THEN REPEAT strip_tac);
val €caratheodory_deriv_thm› = save_pop_thm "caratheodory_deriv_thm";
=TEX
=SML
set_goal([], ¨µf c x∑ (f HasDeriv c) x ¥ f CtsAt xÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(LEMMA_T ¨f = Ãz∑g z *(z + ~x) + f xÆ once_rewrite_thm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[] THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨x'Æ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT (simple_cts_tac THEN REPEAT strip_tac));
val €has_deriv_cts_thm› = save_pop_thm "has_deriv_cts_thm";
=TEX
=SML
set_goal([], ¨µf1 c1 x f2 c2∑
	(f1 HasDeriv c1) x ± (f2 HasDeriv c2) x
¥	((Ãy∑f1 y + f2 y) HasDeriv (c1 + c2)) xÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(rename_tac[(¨gÆ, "g1"), (¨g'Æ, "g2")] THEN
	∂_tac¨Ãz:Ø∑ g1 z + g2 z:ØÆ THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[plus_cts_thm]);
a(once_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
	¨µa b c d:Ø∑ (a + b) + c + d = (a + c) + b + dÆ]);
a(asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €plus_deriv_thm› = save_pop_thm "plus_deriv_thm";
=TEX
=SML
set_goal([], ¨µf1 c1 x f2 c2∑
	(f1 HasDeriv c1) x ± (f2 HasDeriv c2) x
¥	((Ãy∑f1 y * f2 y) HasDeriv (c1*f2 x + f1 x*c2)) xÆ);
a(REPEAT strip_tac THEN lemma_tac¨f2 CtsAt xÆ 
	THEN1 all_fc_tac[has_deriv_cts_thm]);
a(all_asm_ante_tac THEN
	rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(rename_tac[(¨gÆ, "g1"), (¨g'Æ, "g2")] THEN
	∂_tac¨Ãz:Ø∑ g1 z*f2 z +  f1 x*g2 z:ØÆ THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[pc_rule1"Ø_lin_arith"prove_rule[]
	¨µa b c d:Ø∑a*b + ~(c*d) = (a + ~c)*b + c*(b + ~d)Æ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT (simple_cts_tac THEN REPEAT strip_tac));
val €times_deriv_thm› = save_pop_thm "times_deriv_thm";
=TEX
=SML
set_goal([], ¨µf1 c1 f2 c2 x∑
	(f1 HasDeriv c1) (f2 x) ± (f2 HasDeriv c2) x
¥	((Ãy∑f1(f2 y)) HasDeriv (c1*c2)) xÆ);
a(REPEAT strip_tac THEN lemma_tac¨f2 CtsAt xÆ 
	THEN1 all_fc_tac[has_deriv_cts_thm]);
a(all_asm_ante_tac THEN
	rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(rename_tac[(¨gÆ, "g1"), (¨g'Æ, "g2")] THEN
	∂_tac¨Ãz:Ø∑ g1(f2 z)*g2 z:ØÆ THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT (simple_cts_tac THEN REPEAT strip_tac));
a(bc_thm_tac comp_cts_thm THEN REPEAT strip_tac);
val €comp_deriv_thm› = save_pop_thm "comp_deriv_thm";
=TEX
=SML
set_goal([], ¨µc t∑ ((Ãx∑c) HasDeriv ÓØ 0) tÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(∂_tac¨Ãz∑ÓØ 0Æ THEN rewrite_tac[]);
a(simple_cts_tac);
val €const_deriv_thm› = save_pop_thm "const_deriv_thm";
=TEX
=SML
set_goal([], ¨µc t∑ ((Ãx∑x) HasDeriv ÓØ 1) tÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(∂_tac¨Ãz∑ÓØ 1Æ THEN rewrite_tac[]);
a(simple_cts_tac);
val €id_deriv_thm› = save_pop_thm "id_deriv_thm";
=TEX
=SML
set_goal([], ¨µn t∑ ((Ãx∑x^(n+1)) HasDeriv (ÓØ n + ÓØ 1)*t^n) tÆ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ);
(* *** Goal "1" *** *)
a(pure_rewrite_tac[Ø_Ó_exp_def] THEN rewrite_tac[id_deriv_thm]);
(* *** Goal "2" *** *)
a(pure_once_rewrite_tac[Ø_Ó_exp_def]);
a(pure_rewrite_tac[prove_rule[]¨
	(Ã x:Ø∑ x * x ^ (n + 1)) = Ã x∑ (Ãx∑x) x * (Ãx∑x ^ (n + 1))xÆ]);
a(LEMMA_T¨
	(ÓØ (n + 1) + ÓØ 1) * t * t ^ n =
	ÓØ 1*(Ãx∑x^(n + 1))t + (Ãx∑x) t*(ÓØ n + ÓØ 1)*t^nÆ
	pure_rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[ÓØ_plus_homomorphism_thm, Ø_Ó_exp_def]);
a(conv_tac(RANDS_C Ø_anf_conv) THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(bc_thm_tac times_deriv_thm);
a(asm_rewrite_tac[id_deriv_thm]);
val €power_deriv_thm› = save_pop_thm "power_deriv_thm";
=TEX
=SML
set_goal([], ¨µt∑ ≥t = ÓØ 0 ¥ ($õ-õ1 HasDeriv ~(t õ-õ1 * t õ-õ1)) tÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(∂_tac¨Ãy∑
	if	y = t
	then	~(t õ-õ1 * t õ-õ1)
	else	(y õ-õ1 + ~t õ-õ1)*(y + ~t)õ-õ1Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(cases_tac¨y = tÆ THEN asm_rewrite_tac[Ø_times_assoc_thm]);
a(POP_ASM_T (asm_tac o once_rewrite_rule[Ø_eq_thm]));
a(ALL_FC_T rewrite_tac[Ø_recip_clauses, Ø_minus_recip_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[cts_lim_seq_thm1] THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
a(all_fc_tac[lim_seq_≥_0_thm]);
a(once_rewrite_tac[µ_elim¨nÆ lim_seq_shift_thm] THEN rewrite_tac[]);
a(LEMMA_T ¨µn'∑(s (n + n') õ-õ1 + ~ t õ-õ1) * (s (n + n') + ~ t) õ-õ1
	= ~(s (n + n') õ-õ1 * t õ-õ1)Æ rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(lemma_tac¨≥s (n+n') = ÓØ 0Æ THEN1
	(TOP_ASM_T bc_thm_tac THEN REPEAT strip_tac));
a(lemma_tac¨≥~t = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[Ø_plus_recip_thm]);
a(lemma_tac¨≥s(n+n') + ~ t = ÓØ 0Æ THEN1
	(spec_nth_asm_tac 4 ¨n+n'Æ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b c∑
	(a * b * c) * a õ-õ1= b * c * a * a õ-õ1Æ]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses, Ø_minus_recip_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2.2" *** *)
a(LEMMA_T ¨~ (t õ-õ1 * t õ-õ1) = t õ-õ1 * ~(t õ-õ1) ±
	(Ã n'∑ ~ (s (n + n') õ-õ1 * t õ-õ1)) =
	(Ã n'∑ (Ãm∑ (Ãm'∑s (n + m')) m õ-õ1) n' * (Ãm∑~ (t õ-õ1)) n')Æ
	 pure_rewrite_thm_tac THEN1
	(conv_tac (ONCE_MAP_C Ø_anf_conv) THEN rewrite_tac[]));
a(bc_thm_tac times_lim_seq_thm THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(bc_thm_tac recip_lim_seq_thm THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[lim_seq_shift_thm]);
(* *** Goal "2.2.2" *** *)
a(rewrite_tac[const_lim_seq_thm]);
(* *** Goal "3" *** *)
a(rewrite_tac[]);
val €recip_deriv_thm› = save_pop_thm "recip_deriv_thm";
=TEX
\subsubsection{Some of the Classical Theorems}
First of all we prove the following rather unusual result which works out
nicely in many cases where we would otherwise have to work directly with
suprema. For the want of a better name, we call it the ``curtain
induction principle'' (think of sliding a curtain along the real line starting
from $-\infty$).
=SML
set_goal([], ¨µp:Ø≠BOOL∑
	(∂x∑p x)
±	(µx∑p x ¥ µy∑y < x ¥ p y)
±	(µx∑∂y z∑ y < x ± x < z ± (p y ¥ p z))
¥	(µx∑p x) 
Æ);
a(contr_tac);
a(lemma_tac¨∂P∑P = {t | p t}Æ THEN1 prove_∂_tac);
a(lemma_tac¨≥P = {} ± ∂c∑µx∑x ç P ¥ x º cÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨x'Æ THEN all_var_elim_asm_tac1 THEN contr_tac);
a(lemma_tac¨x' < x''Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_fc_tac[Ø_sup_thm] THEN fc_tac[Ø_sup_thm]);
a(LIST_DROP_NTH_ASM_T [1,2] fc_tac);
a(spec_nth_asm_tac 8 ¨Sup PÆ);
(* *** Goal "3.1" *** *)
a(swap_nth_asm_concl_tac 3 THEN rewrite_tac[Ø_≥_less_º_thm]);
a(bc_thm_tac Ø_sup_º_bc_thm THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN1 (∂_tac¨cÆ THEN asm_rewrite_tac[]));
a(contr_tac THEN lemma_tac¨y < y'Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(lemma_tac ¨∂w∑Sup P < w ± w < zÆ THEN1
	(bc_thm_tac Ø_less_dense_thm THEN REPEAT strip_tac));
a(lemma_tac¨w º zÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨w ç PÆ THEN1 (asm_rewrite_tac[] THEN all_asm_fc_tac[]));
a(lemma_tac¨w º Sup PÆ THEN1 all_asm_fc_tac[]);
a(PC_T1"Ø_lin_arith" asm_prove_tac[]);
val €curtain_induction_thm› = save_pop_thm "curtain_induction_thm";
=TEX
=SML
val €curtain_induction_tac› = gen_induction_tac curtain_induction_thm;
=IGN
set_goal([], ¨µx:Ø∑∂y∑x º yÆ);
a(strip_tac);
a(curtain_induction_tac¨xÆ);
(* *** Goal "1" *** *)
a(∂_tac ¨xÆ THEN ∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN ∂_tac¨yÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨x + ~(1/2)Æ THEN ∂_tac¨x + (1/2)Æ THEN REPEAT strip_tac);
a(∂_tac¨y'+3/2Æ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val test10 = pop_thm();
=TEX
Heine-Borel theorem: nearly all the work is in the following lemma:
=SML
set_goal([], ¨µV x y∑
	V Ä OpenSets
±	(µz∑ z ç ﬁV)
¥	∂W∑ W Ä V ± W ç Finite ± ClosedInterval x y Ä ﬁ WÆ);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(curtain_induction_tac¨y:ØÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨x + ~(ÓØ 1)Æ THEN REPEAT strip_tac);
a(∂_tac¨{}Æ THEN PC_T1 "sets_ext1" rewrite_tac[fin_set_thm2, closed_interval_def]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext1" (spec_nth_asm_tac 1) ¨zÆ THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨ClosedInterval x y Ä ClosedInterval x y'Æ THEN1
	(rewrite_tac[closed_interval_def] THEN
	PC_T1 "sets_ext1" REPEAT strip_tac THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(all_fc_tac[
	pc_rule1 "sets_ext1" prove_rule[]¨µA B C∑A Ä B ± B Ä C ¥ A Ä CÆ]);
a(∂_tac¨WÆ THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(PC_T1 "'propositions" cases_tac¨≥(µ z∑ z ç ﬁ V)Æ THEN asm_rewrite_tac[]);
(* *** Goal "4.1" *** *)
a(∂_tac¨y' + ~(ÓØ 1)Æ THEN ∂_tac¨y' + ÓØ 1Æ THEN REPEAT strip_tac);
(* *** Goal "4.2" *** *)
a(POP_ASM_T (strip_asm_tac o µ_elim¨y'Æ o pc_rule1 "sets_ext1" rewrite_rule[]));
a(DROP_NTH_ASM_T 3 ante_tac THEN
	rewrite_tac[open_sets_def, open_interval_def] THEN
	PC_T1 "sets_ext" REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_fc_tac[Ø_less_dense_thm]);
a(∂_tac¨z'Æ THEN ∂_tac¨zÆ THEN REPEAT strip_tac);
a(∂_tac¨{s} ¿ WÆ THEN ALL_FC_T rewrite_tac[fin_set_thm3]);
a(rewrite_tac[closed_interval_def] THEN REPEAT strip_tac);
(* *** Goal "4.2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac THEN1 all_var_elim_asm_tac1);
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
(* *** Goal "4.2.2" *** *)
a(GET_NTH_ASM_T 8 ante_tac THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (strip_asm_tac o pc_rule1 "sets_ext1" rewrite_rule[closed_interval_def]));
a(cases_tac¨x' < x''Æ);
(* *** Goal "4.2.2.1" *** *)
a(∂_tac ¨sÆ THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 5 bc_thm_tac THEN REPEAT strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "4.2.2.2" *** *)
a(lemma_tac¨x'' º z'Æ  THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T [3] all_fc_tac);
a(∂_tac ¨s'Æ THEN REPEAT strip_tac);
val €heine_borel_lemma› = pop_thm();
=TEX
=SML
set_goal([], ¨µV x y∑
	V Ä OpenSets
±	ClosedInterval x y Ä ﬁV
¥	∂W∑ W Ä V ± W ç Finite ± ClosedInterval x y Ä ﬁ WÆ);
a(REPEAT strip_tac);
a(lemma_tac¨{{t | ≥t ç ClosedInterval x y}} ¿ V Ä OpenSets
	± (µz∑ z ç ﬁ({{t | ≥t ç ClosedInterval x y}} ¿ V))Æ THEN
	PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[open_sets_def, open_interval_def] THEN REPEAT strip_tac);
a(ALL_ASM_FC_T (MAP_EVERY ante_tac)[]);
a(rewrite_tac[closed_interval_def] THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(∂_tac¨t + ~(ÓØ 1)Æ THEN ∂_tac ¨xÆ THEN PC_T1 "sets_ext1" REPEAT strip_tac THEN REPEAT strip_tac);
a(asm_rewrite_tac[closed_interval_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(∂_tac¨yÆ THEN ∂_tac ¨t + ÓØ 1Æ THEN PC_T1 "sets_ext1" REPEAT strip_tac THEN REPEAT strip_tac);
a(asm_rewrite_tac[closed_interval_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(cases_tac¨≥z ç ClosedInterval x yÆ THEN1
	(∂_tac¨{t|≥ t ç ClosedInterval x y}Æ THEN REPEAT strip_tac));
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µA B∑z ç A ± A Ä B ¥ z ç BÆ]);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(all_fc_tac[heine_borel_lemma]);
a(∂_tac¨W \ {{t|≥ t ç ClosedInterval x y}}Æ THEN REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN
	all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µA B∑x' ç A ± A Ä B ¥ x' ç BÆ] THEN
	all_var_elim_asm_tac1);
(* *** Goal "4.2" *** *)
a(bc_thm_tac size_thm4 THEN ∂_tac¨WÆ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "4.3" *** *)
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(∂_tac¨sÆ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(∂_tac¨x'Æ THEN REPEAT strip_tac);
val €heine_borel_thm› = save_pop_thm "heine_borel_thm";
=TEX
Bolzano's principle of bijection:
=SML
set_goal([], ¨µp∑
	(µx y∑y < x ¥ p x y)
±	(µx y z∑ x º y ± y º z ± p x y ± p y z ¥ p x z)
±	(µy∑∂d∑ ÓØ 0 < d ± (µx z∑  x º y ± y º z ± Abs(z - x) < d ¥ p x z))
¥	(µx y∑p x y)
Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨µt∑t º y ¥ p x tÆ (strip_asm_tac o µ_elim¨yÆ));
a(lemma_tac¨µc∑p c cÆ THEN1
	(REPEAT strip_tac THEN
	POP_ASM_T (strip_asm_tac o µ_elim¨c:ØÆ) THEN
	POP_ASM_T bc_thm_tac THEN asm_rewrite_tac[]));
a(curtain_induction_tac¨y:ØÆ);
(* *** Goal "1" *** *)
a(∂_tac¨x + ~(ÓØ 1)Æ THEN REPEAT strip_tac);
a(lemma_tac¨t < xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(GET_NTH_ASM_T 3 bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(cases_tac¨y' < xÆ);
(* *** Goal "3.1" *** *)
a(∂_tac¨y' + ~(ÓØ 1)Æ THEN ∂_tac¨xÆ THEN REPEAT strip_tac);
a(cases_tac¨t < xÆ THEN1 all_asm_fc_tac[]);
a(lemma_tac¨t = xÆ THEN_LIST[PC_T1"Ø_lin_arith"asm_prove_tac[], all_var_elim_asm_tac1]);
a(asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(cases_tac¨≥µb∑b < y' ¥ p x bÆ);
(* *** Goal "3.2.1" *** *)
a(∂_tac¨bÆ THEN ∂_tac¨y' + ÓØ 1Æ THEN REPEAT strip_tac);
a(spec_nth_asm_tac 2 ¨bÆ);
(* *** Goal "3.2.2" *** *)
a(spec_nth_asm_tac 4 ¨y'Æ);
a(∂_tac¨y' + ~(1/3*d)Æ THEN ∂_tac¨y' + 1/3*dÆ THEN REPEAT strip_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(cases_tac¨t < y'Æ THEN1 all_asm_fc_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(lemma_tac¨∂a∑x º a ± a º y' ± Abs(y' - a) º 1/3*d ± p x aÆ);
(* *** Goal "3.2.2.1" *** *)
a(lemma_tac¨ÓØ 0 º 1/3*dÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(cases_tac¨x º y' + ~(1/3*d)Æ);
(* *** Goal "3.2.2.1.1" *** *)
a(∂_tac¨y' + ~(1/3*d)Æ THEN REPEAT strip_tac THEN_LIST
	[PC_T1"Ø_lin_arith" asm_prove_tac[],
	conv_tac (ONCE_MAP_C Ø_anf_conv) THEN asm_rewrite_tac[Ø_abs_def],
	id_tac]);
a(spec_nth_asm_tac 8 ¨y' + ~(1/3*d)Æ);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.2.1.2" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "3.2.2.1.2.1" *** *)
a(lemma_tac¨ÓØ 0 º y' + ~xÆ THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.2.1.2.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3.2.2.2" *** *)
a(GET_NTH_ASM_T 14 bc_thm_tac);
a(∂_tac¨aÆ THEN REPEAT strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(GET_NTH_ASM_T 8 bc_thm_tac THEN REPEAT strip_tac);
a(lemma_tac¨Abs(t - y') º 1/3*dÆ);
(* *** Goal "3.2.2.2.1" *** *)
a(lemma_tac¨ÓØ 0 º t + ~y'Æ THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.2.2.2" *** *)
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨Abs(t - y') + Abs(y' - a)Æ);
a(REPEAT strip_tac THEN_LIST
	[bc_thm_tac Ø_abs_plus_bc_thm,
	PC_T1"Ø_lin_arith" asm_prove_tac[]]);
a(conv_tac (ONCE_MAP_C Ø_anf_conv) THEN REPEAT strip_tac);
val €bisection_lemma› = pop_thm();
=TEX
=SML
set_goal([], ¨µp∑
	(µx y z∑ x º y ± y º z ± p x y ± p y z ¥ p x z)
±	(µy∑∂d∑ ÓØ 0 < d ± (µx z∑  x º y ± y º z ± Abs(z - x) < d ¥ p x z))
¥	(µx y∑ x º y ¥ p x y)
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µx y∑(Ã x y∑if x º y then p x y else T)x yÆ THEN1
	(bc_thm_tac bisection_lemma THEN rewrite_tac[] THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" (= 3, 4, and 5) *** *)
a(all_asm_fc_tac[]);
(* *** Goal "6" *** *)
a(spec_nth_asm_tac 2 ¨y'Æ);
a(∂_tac¨dÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[]));
a(all_asm_fc_tac[]);
(* *** Goal "7" *** *)
a(POP_ASM_T (ante_tac o list_µ_elim[¨xÆ, ¨yÆ]) THEN asm_rewrite_tac[]);
val €bisection_thm› = save_pop_thm"bisection_thm";
=TEX
\subsubsection{Theorems about Uniform Limits}
We now prove some basic facts about limits of locally uniformly convergent
sequences of functions.
N.b., the definition on which these facts depend is a tentative one, and
this section should be considered experimental.

Firstly, constant sequences have limits:
=SML
set_goal([], ¨µh x∑((Ãm∑ h) ---> h) xÆ);
a(REPEAT strip_tac THEN rewrite_tac[unif_lim_seq_def]);
a(∂_tac¨ÓØ 1Æ THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
val €const_unif_lim_seq_thm› = save_pop_thm "const_unif_lim_seq_thm";
=TEX
Secondly, if two locally uniformly convergent
sequences of functions each have a limit, then so does their
sum and its limit is the sum of the limits.
Thee proof is a cut-and-paste generalisation of the analogous proof
for the limit of sequences of numbers.
=SML
set_goal([], ¨µu1 h1 x u2 h2∑
	(u1 ---> h1) x ± (u2 ---> h2) x ¥ ((Ãm y∑u1 m y + u2 m y) ---> (Ãy∑h1 y + h2 y)) xÆ);
a(rewrite_tac[unif_lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac¨∂b1∑ÓØ 0 < b1 ± b1 < b ± b1 < b'Æ THEN1 (
	∂_tac¨if b < b' then b / ÓØ 2 else b' / ÓØ 2Æ THEN
	cases_tac¨b < b'Æ THEN asm_rewrite_tac[] THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(∂_tac¨b1Æ THEN REPEAT strip_tac);
a(lemma_tac ¨ÓØ 0 < e / ÓØ 2 Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 8 ¨e / ÓØ 2Æ THEN spec_nth_asm_tac 7  ¨e / ÓØ 2Æ);
a(∂_tac¨n + n'Æ THEN REPEAT strip_tac);
a(lemma_tac¨n º m ± n' º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(lemma_tac¨Abs (y + ~ x) < b ± Abs (y + ~ x) < b'Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T [7, 8] all_fc_tac);
a(LEMMA_T ¨(u1 m y + u2 m y) + ~(h1 y) + ~(h2 y) = (u1 m y + ~(h1 y)) + (u2 m y + ~(h2 y))Æ
	rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(bc_thm_tac Ø_º_less_trans_thm);
a(∂_tac¨Abs (u1 m y + ~ (h1 y)) + Abs (u2 m y + ~(h2 y))Æ THEN rewrite_tac[Ø_abs_plus_thm]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €plus_unif_lim_seq_thm› = save_pop_thm "plus_unif_lim_seq_thm";
=TEX
One might now want to give the analogous result on the product of two sequences
of functions with uniform limits. However, this is false in general. For the purposes
we have in mind, it is sufficient to consider the product of a sequence of
functions and a given function which is bounded in some neighbourhood of
the point of interest:

=SML
set_goal([], ¨µu h x f∑
	(u ---> h) x
±	(∂d c∑ÓØ 0 < d ± ÓØ 0 < c ± µy∑Abs(y - x) < d ¥ Abs(f y) < c)
¥	((Ãm y∑u m y*f y) ---> (Ãy∑h y*f y)) xÆ);
a(rewrite_tac[unif_lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac¨∂b1∑ÓØ 0 < b1 ± b1 < b ± b1 < dÆ THEN1 (
	∂_tac¨if b < d then b / ÓØ 2 else d / ÓØ 2Æ THEN
	cases_tac¨b < dÆ THEN asm_rewrite_tac[] THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(∂_tac ¨b1Æ THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < e * c õ-õ1Æ THEN1 
	(bc_thm_tac Ø_0_less_0_less_times_thm THEN
	REPEAT strip_tac THEN bc_thm_tac Ø_0_less_recip_thm THEN REPEAT strip_tac));
a(spec_nth_asm_tac 9 ¨e * c õ-õ1Æ);
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µA B∑A*f y + ~(B * f y) = (A + ~B)*f yÆ,
	Ø_abs_times_thm]);
a(lemma_tac¨Abs (y + ~ x) < b ± Abs (y + ~ x) < dÆ THEN1 
	(LIST_GET_NTH_ASM_T [1, 6, 7] (MAP_EVERY ante_tac) THEN
	PC_T1 "Ø_lin_arith" prove_tac[]));
a(LIST_GET_NTH_ASM_T [5, 11] all_fc_tac);
a(lemma_tac¨≥ c = ÓØ 0Æ THEN1 (contr_tac THEN all_var_elim_asm_tac1));
a(LEMMA_T¨e = (e * c õ-õ1) * cÆ once_rewrite_thm_tac THEN1
	(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µA B C:Ø∑(A*B)*C = A*C*BÆ] THEN
	ALL_FC_T rewrite_tac[Ø_times_recip_thm]));
a(bc_thm_tac Ø_abs_less_times_thm THEN REPEAT strip_tac);
val €times_unif_lim_seq_thm› = save_pop_thm "times_unif_lim_seq_thm";
=TEX
Now the main result of this section: if a sequence
of functions, all continuous at some point $x$, is locally uniformly convergent
at $x$, then the limit function is continuous at $x$.
We prove a little lemma first:
=SML
set_goal([], ¨µa b c d:Ø∑Abs(a - d) º Abs(a - b) + Abs(b - c) + Abs(c - d)Æ);
a(REPEAT strip_tac);
a(lemma_tac¨Abs(b - d) º Abs(b - c) + Abs(c - d)Æ THEN1
	(pure_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
		¨b - d = (b - c) + (c - d)Æ, Ø_abs_plus_thm]));
a(lemma_tac¨Abs(a - d) º Abs(a - b) + Abs(b - d)Æ THEN1
	(pure_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
		¨a - d = (a - b) + (b - d)Æ, Ø_abs_plus_thm]));
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_abs_abcd_thm› = pop_thm ();
=TEX
Now we prove the main result on the continuity of limits of sequences
functions. We use
the $\epsilon$-$\delta$ definition of continuity directly --- to use
the alternative characterisation in terms of sequences involves too
many subscripts for comfort!
=SML
set_goal([], ¨µu h x∑
	(u ---> h) x ± (µm∑u m CtsAt x) ¥ h CtsAt xÆ);
a(rewrite_tac[cts_at_def, unif_lim_seq_def, lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < (1/3)*eÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 4 ¨(1/3)*eÆ);
a(SPEC_NTH_ASM_T 1 ¨nÆ ante_tac THEN rewrite_tac[] THEN REPEAT strip_tac);
a(list_spec_nth_asm_tac 5 [¨nÆ, ¨(1/3)*eÆ]);
a(lemma_tac¨∂b1∑ÓØ 0 < b1 ± b1 < b ± b1 < dÆ THEN1 (
	∂_tac¨if b < d then b / ÓØ 2 else d / ÓØ 2Æ THEN
	cases_tac¨b < dÆ THEN asm_rewrite_tac[] THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(∂_tac¨b1Æ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac ¨
	Abs(h y - u n y) + Abs(u n y - u n x) + Abs(u n x - h x)Æ
	THEN rewrite_tac[rewrite_rule[]Ø_abs_abcd_thm] THEN REPEAT strip_tac);
a(lemma_tac ¨Abs(h y + ~(u n y)) < (1/3)*e
	± Abs(u n y + ~(u n x)) < (1/3)*e
	± Abs(u n x + ~(h x)) < (1/3)*eÆ
	THEN_LIST [id_tac, PC_T1 "Ø_lin_arith" asm_prove_tac[]]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(pure_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µz∑h y + ~z = ~(z + ~(h y))Æ,
	Ø_abs_minus_thm]);
a(GET_NTH_ASM_T 7 bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(GET_NTH_ASM_T 5 bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(GET_NTH_ASM_T 7 bc_thm_tac THEN rewrite_tac[Ø_abs_0_thm] THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €unif_lim_seq_cts_thm› = save_pop_thm "unif_lim_seq_cts_thm";
=TEX
=SML
(*
set_goal([], ¨µu h x s∑
	(u ---> h) x ± (µm∑(u m HasDeriv s m) x) ¥
	(∂d∑ s --> d ± (h HasDeriv d) x)Æ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o conv_rule simple_µ_∂_conv));

val €unif_lim_seq_deriv_thm› = save_pop_thm "unif_lim_seq_deriv_thm";
*)
=TEX
\subsection{Epilogue}
=TEX
=SML
output_theory{out_file="analysis.th.doc", theory="-"};
=TEX
\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}
\end{document}


