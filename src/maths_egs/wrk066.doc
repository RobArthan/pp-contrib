pp_make_database -f -p hol analysis
docsml analysis
xpp -file analysis.doc -com pp -d analysis -i analysis &
doctex analysis analysis.th; texdvi analysis
=TEX
\documentclass[10pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\title{Basic Analysis}
\author{Rob Arthan}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
This {\ProductHOL} script contains definitions and proofs concerning
the basics of analysis.

\end{abstract}
\vfill
\newpage
\tableofcontents
\newpage
%%%%
%%%%
%%%%
%%%%
\section{INTRODUCTION}
%%%%
%%%%
%%%%
%%%%
This document defines a theory
=INLINEFT
analysis
=TEX
\ which contains the definitions and proofs concerned with the basics of analysis.
The subjects covered are the basic facts about:
\begin{itemize}
\item polynomial functions on the real numbers
\item limits of sequences
\item continuity of functions
\item differentiation
\end{itemize}
%%%%
%%%%
=SML
force_delete_theory"analysis" handle Fail _ => ();
open_theory"Ø";
set_merge_pcs["basic_hol1", "'sets_alg", "'Ø"];
new_theory"analysis";
new_parent"fin_set";
=TEX
%%%%
%%%%
%%%%
%%%%
\section{DEFINITIONS}\label{DEFINITIONS}
%%%%
%%%%
%%%%
%%%%
We define the polynomial functions on the real numbers to be the smallest set
of functions containing the constant functions and the identity function
and closed under (point-wise) addition and multiplication.
%%%%
%%%%
%%%%
%%%%
\subsection{Polynomials}
%%%%
%%%%
%%%%
%%%%
πHOLCONST
‹ €PolyFunc› : (Ø ≠ Ø) SET
˜¸¸¸¸¸¸
‹ PolyFunc = •
‹	{	A
‹	|	(µc∑ (Ãx∑c) ç A)
‹	±	(Ãx∑x) ç A
‹	±	(µf g∑f ç A ± g ç A ¥ (Ãx∑f x + g x) ç A)
‹	±	(µf g∑f ç A ± g ç A ¥ (Ãx∑f x * g x) ç A) }
∞
We will show that every polynomial function can be represented as
a (point-wise) sum, $\lambda x \bullet a_0 + a_1x + a_2 x^2 + \ldots a_n x^n$
for some list of coefficients $[a_0; a_1; a_2 \ldots; a_n]$.
The following function maps such a list of coefficients into the polynomial
function it represents.
πHOLCONST
‹ $€PolyEval› : Ø LIST ≠ (Ø ≠ Ø)
˜¸¸¸¸¸¸
‹ 	(µx∑ PolyEval [] x = ÓØ 0)
‹±	(µc l x∑ PolyEval (Cons c l) x = c + x * PolyEval l x)
∞
We now define the operations on lists of coefficients that
correspond to addition of polynomials \ldots
πHOLCONST
‹ €PlusCoeffs› : Ø LIST ≠ Ø LIST ≠ Ø LIST
˜¸¸¸¸¸¸
‹ 	(µl∑ PlusCoeffs [] l = l)
‹±	(µl∑ PlusCoeffs l [] = l)
‹±	(µc1 l1 c2 l2∑
‹	PlusCoeffs (Cons c1 l1) (Cons c2 l2) =
‹	Cons (c1 + c2) (PlusCoeffs l1 l2))
∞
\ldots and to multiplication of one polynomial by another.
πHOLCONST
‹ €TimesCoeffs› : Ø LIST ≠ Ø LIST ≠ Ø LIST
˜¸¸¸¸¸¸
‹ 	(µl∑ TimesCoeffs [] l = [])
‹±	(µc l1 l2∑
‹	TimesCoeffs (Cons c l1) l2 =
‹	PlusCoeffs (Cons (ÓØ 0) (TimesCoeffs l1 l2)) (Map (Ãx∑c * x) l2) )
∞
The following is useful in forming polynomials whose list
of coefficients is given by a function:
%%%%
%%%%
=SML
declare_infix(310, "To");

πHOLCONST
‹ $€To› : (Ó ≠ 'a) ≠ Ó ≠ 'a LIST
˜¸¸¸¸¸¸
‹ 	(µf∑ f To 0 = [])
‹±	(µf n∑ f To (n+1) = f To n @ [f n])
∞


%%%%
%%%%
%%%%
%%%%
\subsection{Limits}
%%%%
%%%%
%%%%
%%%%
We will write $s {-}{-}{>} x$ to indicate that the sequence $s_n$, indexed by
natural numbers, tends to the limit $x$ as $n$ tends to infinity:
%%%%
%%%%
=SML
declare_infix(200, "-->");

πHOLCONST
‹ $€-->› : (Ó ≠ Ø) ≠ Ø ≠ BOOL
˜¸¸¸¸¸¸
‹µs x∑ s --> x § µe∑ÓØ 0 < e ¥ ∂n∑µm∑n º m ¥ Abs(s m - x) < e
∞
The following definition is a tentative one that is under experimentation.
We write $(u {-}{-}{-}{>} h) x$ to indicate that the sequence of functions $u_n$, indexed by
natural numbers, tends to uniformly to the limit function $h$ in some
neighbourhood $x$ as $n$ tends to infinity.
This is a notion, which one might call {\em local uniform convergence},
that doesn't tend to appear as such in the calculus text books (which would
normally talk about uniform convergence of a sequence of functions on some set).
It seems however to give a convenient sufficient condition for several of
the usual results that fits nicely into the general style adopted here.
%%%%
%%%%
=SML
declare_infix(200, "--->");

πHOLCONST
‹ $€--->› : (Ó ≠ Ø ≠ Ø) ≠ (Ø ≠ Ø) ≠ Ø ≠ BOOL
˜¸¸¸¸¸¸
‹µu h x∑
‹	(u ---> h) x
‹ §	∂b∑ÓØ 0 < b
‹	±	µe∑ÓØ 0 < e
‹	¥	∂n∑µm y∑ n º m ± Abs(y - x) < b ¥ Abs(u m y - h y) < e
∞
%%%%
%%%%
%%%%
%%%%
\subsection{Continuity}
%%%%
%%%%
%%%%
%%%%
Now we give the usual $\epsilon$-$\delta$ definition for continuity of
a function, $f$ at a point $x$. Both kinds of $\epsilon$ are tied
up in the {\ProductHOL} library for something else (viz. Hilbert's choice
operator and set-membership). We therefore just use $e$ and $d$.
Continuity is formulated as an infix relation between a function and
the point at which its continuity is asserted.
%%%%
%%%%
=SML
declare_infix(200, "CtsAt");
πHOLCONST
‹ $€CtsAt› : (Ø ≠ Ø) ≠ Ø ≠ BOOL
˜¸¸¸¸¸¸
‹ µf x∑ f CtsAt x § µe∑ÓØ 0 < e ¥ ∂d∑ÓØ 0 < d ± µy∑ Abs(y - x) < d ¥ Abs(f y - f x) < e
∞
%%%%
%%%%
%%%%
%%%%
\subsection{Derivatives}
%%%%
%%%%
%%%%
%%%%
Now we give the usual $\epsilon$-$\delta$ definition for the derivative of
a function, $f$ at a point $x$. 
The notion of a derivative as formulated here is really a ternary
relation: ``$f$ has derivative $c$ at $x$''.
We represent this as the infix operation between $f$ and $c$ whose
value is the propositional function that characterises the values$x$ for
which the derivative $f$ is $c$.
%%%%
%%%%
=SML
declare_infix(200, "HasDeriv");
πHOLCONST
‹ $€HasDeriv› : (Ø ≠ Ø) ≠ Ø ≠ Ø ≠ BOOL
˜¸¸¸¸¸¸
‹ µf c x∑
‹	(f HasDeriv c) x §
‹	µe∑ÓØ 0 < e ¥ ∂d∑
‹		ÓØ 0 < d
‹	±	µy∑ Abs(y - x) < d ± ≥y = x ¥ Abs((f y - f x)/(y-x) - c) < e
∞
%%%%
%%%%
%%%%
%%%%
\subsection{Intervals}
%%%%
%%%%
%%%%
%%%%
The notions of closed and open intervals make some of the results
slightly more readable.
%%%%
%%%%
πHOLCONST
‹ €ClosedInterval› : Ø ≠ Ø ≠ Ø SET
˜¸¸¸¸¸¸
‹ µx y∑ ClosedInterval x y = {t | x º t ± t º y}
∞
πHOLCONST
‹ €OpenInterval› : Ø ≠ Ø ≠ Ø SET
˜¸¸¸¸¸¸
‹ µx y∑ OpenInterval x y = {t | x < t ± t < y}
∞
%%%%
%%%%
%%%%
%%%%
\subsection{Open, Closed and Compact Sets}
%%%%
%%%%
%%%%
%%%%
The notions of open, closed and compact sets are useful:
%%%%
%%%%
πHOLCONST
‹ €OpenSets› : Ø SET SET
˜¸¸¸¸¸¸
‹ OpenSets = {A | µt∑t ç A ¥ ∂x y∑t ç OpenInterval x y ± OpenInterval x y Ä A}
∞
[Note that
=INLINEFT
~
=TEX
\ here is not arithmetic negation, but the operation
of complementing a set with respect to the universe of its type..]
πHOLCONST
‹ €ClosedSets› : Ø SET SET
˜¸¸¸¸¸¸
‹ ClosedSets = {A | ~ A ç OpenSets}
∞
πHOLCONST
‹ €CompactSets› : Ø SET SET
˜¸¸¸¸¸¸
‹ CompactSets =
‹ {A | µ V∑ V Ä OpenSets ± A Ä ﬁV ¥ ∂W∑ W Ä V ± W ç Finite ± A Ä ﬁ W}
∞
=TEX
%%%%
%%%%
%%%%
%%%%
{\HOLindexOff
\include{analysis.th}}
%%%%
%%%%
%%%%
%%%%
\section{THEOREMS}
%%%%
%%%%
%%%%
%%%%
\subsection{The Definitions and Their Consistency}
%%%%
%%%%
%%%%
%%%%
We give bindings for the definitions and discharge any consistency
proof obligations.
%%%%
%%%%
=SML
val €poly_func_def› = get_spec¨PolyFuncÆ;
val €poly_eval_def› = get_spec¨PolyEvalÆ;
=TEX
Here is the only consistency proof obligation, which just arises
because the definition of {\it PlusCoeffs} is not quite in the
form that the existence prover for recursive definitions over
the natural numbers expects.
%%%%
%%%%
=SML
push_consistency_goal¨PlusCoeffsÆ;
a(lemma_tac¨∂ac∑
 	(µl∑ ac [] l = l)
±	(µc1 : Ø; l1∑
	ac (Cons c1 l1) [] = Cons c1 l1
±	(µc2 l2∑ ac (Cons c1 l1) (Cons c2 l2) =
	Cons (c1 + c2) (ac l1 l2)))
Æ THEN1 prove_∂_tac);
a(∂_tac ¨acÆ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(list_induction_tac¨lÆ THEN asm_rewrite_tac[]);
val _ = save_consistency_thm ¨PlusCoeffsÆ (pop_thm());
val €plus_coeffs_def› = get_spec¨PlusCoeffsÆ;
val €times_coeffs_def› = get_spec¨TimesCoeffsÆ;
val €to_def› = get_spec¨$ToÆ;
val €lim_seq_def› = get_spec¨$-->Æ;
val €unif_lim_seq_def› = get_spec¨$--->Æ;
val €cts_at_def› = get_spec¨$CtsAtÆ;
val €has_deriv_def› = get_spec¨$HasDerivÆ;
val €closed_interval_def› = get_spec¨ClosedIntervalÆ;
val €open_interval_def› = get_spec¨OpenIntervalÆ;
val €open_sets_def› = get_spec¨OpenSetsÆ;
val €closed_sets_def› = get_spec¨ClosedSetsÆ;
val €compact_sets_def› = get_spec¨CompactSetsÆ;
=TEX
The next two are an omission in {\Product} V2.5.1:
%%%%
%%%%
=SML
val €Ø_Ó_exp_def› = get_spec¨$^âNÆ;
val €Ø_abs_def› = get_spec¨AbsâRÆ;
=TEX
%%%%
%%%%
%%%%
%%%%
%%%%
%%%%
%%%%
%%%%
\subsection{Lemmas about Lists and Sets}
=TEX
The following lemma is useful in connection with certain compactness arguments:
=SML
set_goal([], ¨µV∑
	V ç Finite
±	≥V = {}
±	(µA B∑ A ç V ± B ç V ¥ A Ä B ≤ B Ä A)
¥	∂A∑ A ç V ± ﬁV = A	
Æ);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac THEN POP_ASM_T ante_tac);
a(finite_induction_tac ¨VÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1 THEN ∂_tac¨xÆ THEN PC_T1 "sets_ext1" prove_tac[]);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(i_contr_tac THEN lemma_tac¨A Ä B ≤ B Ä AÆ THEN1 POP_ASM_T bc_thm_tac);
a(REPEAT strip_tac);
(* *** Goal "3" *** *)
a(lemma_tac¨A Ä x ≤ x Ä AÆ THEN1 POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac);
a(lemma_tac¨ﬁ{x} = xÆ THEN1
	(PC_T1 "sets_ext1" prove_tac[] THEN ∂_tac¨xÆ THEN REPEAT strip_tac));
a(asm_rewrite_tac[pc_rule1"sets_ext1"prove_rule[]¨µX Y∑ﬁ (X ¿ Y) = ﬁX ¿ ﬁYÆ]);
a(GET_NTH_ASM_T 2 ante_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "3.2" *** *)
a(∂_tac¨AÆ THEN REPEAT strip_tac);
a(lemma_tac¨ﬁ{x} = xÆ THEN1
	(PC_T1 "sets_ext1" prove_tac[] THEN ∂_tac¨xÆ THEN REPEAT strip_tac));
a(asm_rewrite_tac[pc_rule1"sets_ext1"prove_rule[]¨µX Y∑ﬁ (X ¿ Y) = ﬁX ¿ ﬁYÆ]);
a(GET_NTH_ASM_T 2 ante_tac THEN PC_T1 "sets_ext1" prove_tac[]);
val €finite_chain_thm› = save_pop_thm"finite_chain_thm";
=TEX
We also need a few general lemmas about lists:
%%%%
%%%%
=SML
set_goal([], ¨
	(µl1 l2 : 'a LIST∑ Length(l1 @ l2) = Length l1 + Length l2)
±	(µl:'a LIST∑ Length(Rev l) = Length l)
Æ);
a(once_rewrite_tac[taut_rule¨µp q∑ p ± q § p ± (p ¥ q)Æ]);
a(±_tac THEN1 (REPEAT strip_tac THEN list_induction_tac¨l1:'a LISTÆ THEN
	asm_rewrite_tac[rev_def, length_def, append_def] THEN PC_T1 "lin_arith" prove_tac[]));
a(REPEAT strip_tac THEN list_induction_tac¨l:'a LISTÆ THEN
	asm_rewrite_tac[rev_def, length_def] THEN PC_T1 "lin_arith" prove_tac[]);
val €length_rev_append_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl: 'a LIST∑ Length l = 0 § l = []
Æ);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[length_def]);
a(strip_asm_tac (µ_elim¨lÆlist_cases_thm));
a(all_var_elim_asm_tac1 THEN all_asm_ante_tac THEN rewrite_tac[length_def]);
val €length_eq_0_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl1 l2 l3:'a LIST∑ (l1 @ l2) @ l3 = l1 @ l2 @ l3
Æ);
a(REPEAT strip_tac THEN list_induction_tac¨l1:'a LISTÆ THEN
	asm_rewrite_tac[append_def]);
val €append_assoc_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl∑ [] @ l = l ± l @ [] = l
Æ);
a(rewrite_tac[append_def]
	THEN REPEAT strip_tac THEN list_induction_tac¨l:'a LISTÆ THEN
	asm_rewrite_tac[append_def]);
val €append_empty_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl1 l2 ∑ Rev (l1 @ l2) = Rev l2 @ Rev l1
Æ);
a(REPEAT strip_tac THEN list_induction_tac¨l1:'a LISTÆ THEN
	asm_rewrite_tac[rev_def, append_def, append_assoc_thm, append_empty_thm]);
val €rev_append_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl1 l2 ∑ l1 @ l2 = [] § l1 = [] ± l2 = []
Æ);
a(µ_tac THEN list_induction_tac¨l1: 'a LISTÆ THEN asm_rewrite_tac[append_def]);
val €append_eq_empty_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl ∑ Rev l = [] § l = []
Æ);
a(µ_tac THEN list_induction_tac¨l: 'a LISTÆ THEN asm_rewrite_tac[append_eq_empty_thm, rev_def]);
val €rev_eq_empty_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl ∑ Rev(Rev l) = l
Æ);
a(µ_tac THEN list_induction_tac¨l: 'a LISTÆ THEN
	asm_rewrite_tac[rev_def, rev_append_thm, append_empty_thm, append_def]);
val €rev_rev_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	(µf n∑ Length(f To n) = n)
Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ THEN
	asm_rewrite_tac[length_rev_append_thm, length_def, to_def]);
val €length_to_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	(µf:'a ≠ 'b; l∑ Length(Map f l) = Length l)
Æ);
a(REPEAT strip_tac THEN list_induction_tac¨l:'a LISTÆ THEN
	asm_rewrite_tac[length_def, map_def]);
val €length_map_thm› = pop_thm();
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Polynomials}
%%%%
%%%%
%%%%
%%%%
Now we will show that any polynomial can be represented by a list of coefficients.
The first part of the proof follows a pattern which will be repeated several times.
First we prove something for constant functions, then for the identity functions,
then for sums and products possibly on the assumption that the ``something'' holds for
the operands. In this case ``something'' is the existence of a list of
coefficients that represent a function, which we give explicitly for later use.

Constants \ldots
%%%%
%%%%
=SML
set_goal([], ¨µc∑(Ãx∑c) = PolyEval [c]Æ);
a(rewrite_tac[poly_eval_def]);
val €const_eval_thm› = save_pop_thm "const_eval_thm";
=TEX
\ldots identity function \ldots
%%%%
%%%%
=SML
set_goal([], ¨(Ãx∑x) = PolyEval [ÓØ 0; ÓØ 1]Æ);
a(rewrite_tac[poly_eval_def]);
val €id_eval_thm› = save_pop_thm "id_eval_thm";
=TEX
\ldots sums \ldots
%%%%
%%%%
=SML
set_goal([], ¨µl1 l2∑
	(Ãx∑PolyEval l1 x + PolyEval l2 x) =
	PolyEval (PlusCoeffs l1 l2)Æ);
a(strip_tac);
a(list_induction_tac¨l1Æ THEN rewrite_tac[plus_coeffs_def, poly_eval_def]);
a(REPEAT strip_tac);
a(list_induction_tac¨l2Æ THEN rewrite_tac[plus_coeffs_def, poly_eval_def]);
a(DROP_NTH_ASM_T 2 (rewrite_thm_tac o conv_rule (BINDER_C eq_sym_conv)));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €plus_eval_thm› = save_pop_thm "plus_eval_thm";
=TEX
\ldots and products, which in this case require a little lemma first:
%%%%
%%%%
=SML
set_goal([], ¨µc l∑(Ãx∑c * PolyEval l x) = PolyEval (Map (Ãy∑c * y) l)Æ);
a(REPEAT strip_tac);
a(list_induction_tac¨lÆ THEN rewrite_tac[map_def, poly_eval_def]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €const_times_eval_thm› = save_pop_thm "const_times_eval_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µl1 l2∑
	(Ãx∑PolyEval l1 x * PolyEval l2 x) =
	PolyEval (TimesCoeffs l1 l2)Æ);
a(strip_tac);
a(list_induction_tac¨l1Æ THEN
	rewrite_tac[times_coeffs_def, poly_eval_def, plus_coeffs_def]);
a(REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[]));
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) plus_eval_thm,
	conv_rule (ONCE_MAP_C eq_sym_conv) const_times_eval_thm,
	poly_eval_def]);
a(conv_tac (RANDS_C Ø_anf_conv));
a(asm_rewrite_tac[]);
val €times_eval_thm› = save_pop_thm "times_eval_thm";
=TEX
We can now show that the set of all polynomial functions is the
range of the polynomial evaluation function. I.e., a function
is polynomial iff. it can be represented by a list of coefficients.
We prove the two inclusions separately:
%%%%
%%%%
=SML
set_goal([], ¨{f | ∂l∑ f = PolyEval l} Ä PolyFuncÆ);
a(pure_rewrite_tac[poly_func_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN list_induction_tac¨lÆ);
(* *** Goal "1" *** *)
a(list_spec_nth_asm_tac 4 [¨ÓØ 0Æ]);
a(LEMMA_T ¨PolyEval [] = (Ãx∑ ÓØ 0)Æ asm_rewrite_thm_tac
	THEN1 rewrite_tac[poly_eval_def]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(LEMMA_T ¨PolyEval (Cons x l) = (Ãt∑ (Ãu∑x) t + (Ãv∑ (Ãw∑w)v * PolyEval l v)t)Æ
	pure_rewrite_thm_tac THEN1 rewrite_tac[poly_eval_def]);
a(GET_NTH_ASM_T 3 bc_thm_tac THEN strip_tac THEN1 asm_rewrite_tac[]);
a(GET_NTH_ASM_T 2 bc_thm_tac THEN strip_tac THEN asm_rewrite_tac[]);
val €poly_eval_Ä_poly_thm› = pop_thm ();
=TEX
For the reverse inclusion, and for later use, it is convenient
to prove an induction theorem for polynomials and use it
to derive an induction tactic:
%%%%
%%%%
=SML
set_goal([], ¨µp∑
		(µc∑p(Ãx∑c))
	±	(p(Ãx∑x))
	±	(µf g∑p f ± p g ¥  p(Ãx∑f x + g x))
	±	(µf g∑p f ± p g ¥ p(Ãx∑f x * g x))
	¥	(µh∑ h ç PolyFunc ¥ p h)
Æ);
a(rewrite_tac[poly_func_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(PC_T1 "sets_ext1" POP_ASM_T (strip_asm_tac o µ_elim ¨{h | p h}Æ)
	THEN1 asm_prove_tac[] THEN all_asm_fc_tac[]);
val €poly_induction_thm› = save_pop_thm "poly_induction_thm";
=TEX
Now the tactic, which expects a term of the form $f \in \mbox{\it PolyFunc}$ to
be in the assumptions (where $f$ is the induction variable).
%%%%
%%%%
=SML
fun €poly_induction_tac› (tm : TERM) : TACTIC = (
	if not (is_var tm andalso type_of tm =: îØ ≠ ØÆ)
	then term_fail "poly_induction_tac" 999001 [tm]
	else ( fn(asms, conc) =>
	let	val asm = find asms (fn t =>  
			let	val (x, s) = dest_bin_op "" 0 "ç" t;
			in	x =$ tm andalso s =$ ¨PolyFuncÆ
			end	handle Fail _ => false)
			handle Fail _ => fail "poly_induction_tac" 999002 [];
	in	if not (is_free_in tm conc)
			then term_fail "poly_induction_tac" 999003 [tm]
		else if any (asms drop (fn t => t =$ asm)) (is_free_in tm)
			then term_fail "poly_induction_tac" 999004 [tm]
		else	(asm_ante_tac asm THEN gen_induction_tac1 poly_induction_thm) (asms, conc)
	end
	)
);
=TEX
%%%%
%%%%
=SML
set_goal([], ¨PolyFunc Ä {f | ∂l∑ f = PolyEval l}Æ);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(poly_induction_tac¨xÆ);
(* *** Goal "1" *** *)
a(ante_tac const_eval_thm THEN prove_tac[]);
(* *** Goal "2" *** *)
a(ante_tac id_eval_thm THEN prove_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨PlusCoeffs l l'Æ THEN pure_asm_rewrite_tac[plus_eval_thm] THEN strip_tac);
(* *** Goal "4" *** *)
a(∂_tac¨TimesCoeffs l l'Æ THEN pure_asm_rewrite_tac[times_eval_thm] THEN strip_tac);
val €poly_Ä_poly_eval_thm› = pop_thm ();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨PolyFunc = {f | ∂l∑ f = PolyEval l}Æ);
a(rewrite_tac[poly_Ä_poly_eval_thm, poly_eval_Ä_poly_thm,
	pc_rule1 "sets_ext1" prove_rule[] ¨µa b∑a = b § a Ä b ± b Ä aÆ]);
val €poly_func_eq_poly_eval_thm› = save_pop_thm "poly_func_eq_poly_eval_thm";
=TEX
For convenience, it is useful to have the theorems that say that the
different kinds of polynomial construction do lead to polynomial functions:
%%%%
%%%%
=SML
set_goal([], ¨µc∑(Ãx∑c) ç PolyFuncÆ);
a(pure_rewrite_tac[const_eval_thm, poly_func_eq_poly_eval_thm]);
a(PC_T1 "sets_ext1" prove_tac[]);
val €const_poly_func_thm› = save_pop_thm "const_poly_func_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨(Ãx∑x) ç PolyFuncÆ);
a(pure_rewrite_tac[id_eval_thm, poly_func_eq_poly_eval_thm]);
a(PC_T1 "sets_ext1" prove_tac[]);
val €id_poly_func_thm› = save_pop_thm "id_poly_func_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g∑ f ç PolyFunc ± g ç PolyFunc ¥ (Ãx∑f x + g x) ç PolyFuncÆ);
a(pure_rewrite_tac[poly_func_eq_poly_eval_thm] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN pure_rewrite_tac[plus_eval_thm]
	THEN PC_T1 "predicates" prove_tac[]);
val €plus_poly_func_thm› = save_pop_thm "plus_poly_func_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g∑ f ç PolyFunc ± g ç PolyFunc ¥ (Ãx∑f x * g x) ç PolyFuncÆ);
a(pure_rewrite_tac[poly_func_eq_poly_eval_thm] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN pure_rewrite_tac[times_eval_thm]
	THEN PC_T1 "predicates" prove_tac[]);
val €times_poly_func_thm› = save_pop_thm "times_poly_func_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g∑ f ç PolyFunc ± g ç PolyFunc ¥ (Ãx∑f(g x)) ç PolyFuncÆ);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(intro_µ_tac(¨gÆ, ¨gÆ) THEN poly_induction_tac¨fÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[const_poly_func_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[»_axiom]);
(* *** Goal "3" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(rewrite_tac[] THEN ALL_FC_T (MAP_EVERY ante_tac) [plus_poly_func_thm]);
a(rewrite_tac[] THEN taut_tac);
(* *** Goal "4" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(rewrite_tac[] THEN ALL_FC_T (MAP_EVERY ante_tac) [times_poly_func_thm]);
a(rewrite_tac[] THEN taut_tac);
val €comp_poly_func_thm› = save_pop_thm "comp_poly_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl1 l2 x∑ PolyEval (l1 @ l2) x = PolyEval l1 x + x^Length l1 * PolyEval l2 x
Æ);
a(REPEAT strip_tac THEN list_induction_tac¨l1:Ø LISTÆ THEN
	asm_rewrite_tac[rev_def, poly_eval_def, length_def, Ø_Ó_exp_def, append_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €poly_eval_append_thm› = save_pop_thm "poly_eval_append_thm";
=TEX
We are now going to prove various identities for polynomials.
The following result gives the rule for evaluating a polynomial starting with the
leading term.
%%%%
%%%%
=SML
set_goal([], ¨
	(µx∑ PolyEval (Rev []) x = ÓØ 0)
±	(µc l x∑ PolyEval (Rev (Cons c l)) x = c*x^Length l + PolyEval (Rev l) x)
Æ);
a(REPEAT strip_tac THEN1 rewrite_tac[rev_def, poly_eval_def]);
a(intro_µ_tac(¨cÆ, ¨cÆ) THEN list_induction_tac¨lÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[rev_def, poly_eval_def, length_def, Ø_Ó_exp_def, append_def]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
a(rewrite_tac[rev_def, poly_eval_def, length_def, Ø_Ó_exp_def, append_def,
	poly_eval_append_thm, length_rev_append_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €poly_eval_rev_thm› = save_pop_thm "poly_eval_rev_thm";
=TEX
The following is the identity for the difference of two like powers:
\[
(x-y)(x^n + yx^{n-1} + \ldots + y^jx^{n-j} + \ldots y^n) = x^{n+1} - y^{n+1}
\]
%%%%
%%%%
=SML
set_goal([], ¨
	µn x y∑ (x - y)*PolyEval (Rev((Ãm∑y^m) To (n+1))) x = x^(n+1) - y^(n+1)
Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ);
(* *** Goal "1" *** *)
a(pure_rewrite_tac[to_def, Ø_Ó_exp_def, append_def, poly_eval_def, rev_def]);
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(pure_once_rewrite_tac[to_def, Ø_Ó_exp_def]);
a(pure_asm_rewrite_tac[rev_append_thm, rev_def, poly_eval_append_thm,
	append_empty_thm, Ø_times_plus_distrib_thm, length_def, Ø_Ó_exp_def,
	µ_elim¨x * ÓØ 1Æ Ø_times_order_thm]);
a(rewrite_tac[poly_eval_def, Ø_Ó_exp_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €poly_diff_powers_thm› = save_pop_thm "poly_diff_powers_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl1 l2∑ Length(PlusCoeffs l1 l2) = if Length l2 < Length l1 then Length l1 else Length l2
Æ);
a(µ_tac THEN list_induction_tac¨l1:Ø LISTÆ THEN1 rewrite_tac[length_def, plus_coeffs_def]);
a(REPEAT strip_tac THEN list_induction_tac¨l2:Ø LISTÆ THEN
	 asm_rewrite_tac[length_def, plus_coeffs_def]);
a(cases_tac¨Length l2 < Length l1Æ THEN asm_rewrite_tac[]);
val €length_plus_coeffs_thm› = save_pop_thm "length_plus_coeffs_thm";
=TEX
The following is the special case of polynomial division in which the divisor
is linear. In this special case, we do not need the notion of the degree of
a polynomial to state the result (which is very fortunate, since we plan to
use this in deriving the theory of polynomial degrees). In informal notation
the result is that if $f$ is any polynomial (the one whose coefficient
list is given by $l1$ in the formal statement), then there is another polynomial
$g$ (the one whose coefficients are given by $l2$ in the formal statement)
with a shorter list of coefficients and such that $f(x) = (x-a)g(x) + r$
for some real number $r$.

The proof below follows a slightly different pattern from the text book
proof, which works by induction on the degree of the dividend (to divide
$f = a_{n+1}x^{n+1} + a_{n}x^{n} + \ldots + a_0$ by $x - c$, one has
$f - a_nx^{n}(x-c) = g$ where $g$ has degree less than that of $f$ and
one proceeds by induction on the degrees). Here, we use list induction
on the list of coefficients (reversed, i.e., leading coefficient first).
If $f =a_{n+1}x^n + a_{n}x^{n} + \ldots + a_0$, then by a list induction,
we can write $h = a_{n}x^{n} + \ldots + a_0$ as $(x-c)h_1 + r_1$
where the list of coefficients for $h_1$ is shorter than that for
$h$ and we can write $a_{n+1}x^{n+1}$ as $a_{n+1}(x - c)(x^n + cx^{n-1} + \ldots + c^n) + a_{n+1}c^{n+1}$, by the identity for the difference of two like powers. Adding
these representations for $h$ and $a_{n+1}x^{n+1}$ gives the required representation
for $f$. There is not much to choose between the two approaches except that this one
involves less fiddling around with lists of coefficients given the tools we have to hand.

%%%%
%%%%
=SML
set_goal([], ¨
	µl1 c∑ ≥l1 = []
¥	∂l2 r∑
		Length l2 < Length l1 
	±	(Ãx∑ PolyEval l1 x) = (Ãx∑ (x - c)*PolyEval l2 x + r)
Æ);
a(lemma_tac¨
	µl1 c∑ ≥l1 = []
¥	∂l2 r∑
		Length l2 < Length l1 
	±	(Ãx∑ PolyEval (Rev l1) x) = (Ãx∑ (x - c)*PolyEval l2 x + r)Æ);
(* *** Goal "1" *** *)
a(REPEAT µ_tac THEN list_induction_tac¨l1 : Ø LISTÆ THEN1 rewrite_tac[]);
(* *** Goal "1.1" *** *)
a(all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(∂_tac¨[]Æ THEN ∂_tac¨xÆ THEN
	rewrite_tac[length_def, rev_def, poly_eval_def, append_empty_thm]);
(* *** Goal "1.2" *** *)
a(pure_rewrite_tac[poly_eval_rev_thm]);
a(REPEAT strip_tac);
a(lemma_tac¨∂m∑m + 1 = Length l1Æ THEN1
	(GET_NTH_ASM_T 3 ante_tac THEN rewrite_tac[less_def, º_def]
	THEN REPEAT strip_tac THEN ∂_tac¨Length l2 + iÆ
	THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(∂_tac¨PlusCoeffs(Map (Ãt∑x*t) (Rev ((Ã j∑ c ^ j) To (m + 1)))) l2Æ
	THEN ∂_tac¨x*c^(m+1) + rÆ);
a(REPEAT strip_tac THEN1
	asm_rewrite_tac[length_to_thm, length_plus_coeffs_thm,
		length_rev_append_thm, length_def, length_map_thm]);
a(pure_rewrite_tac (map (conv_rule (ONCE_MAP_C eq_sym_conv))
		[const_times_eval_thm, plus_eval_thm]));
a(GET_NTH_ASM_T 3 (pure_rewrite_thm_tac o rewrite_rule[]));
a(PC_T1 "predicates" rewrite_tac[]);
a(pure_asm_rewrite_tac[µ_elim¨xÆØ_times_order_thm,
	Ø_times_plus_distrib_thm, poly_diff_powers_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(lemma_tac¨≥Rev l1 = []Æ THEN1 asm_rewrite_tac[rev_eq_empty_thm]);
a(list_spec_nth_asm_tac 3 [¨Rev l1Æ, ¨cÆ]);
a(DROP_NTH_ASM_T 2 (asm_tac o rewrite_rule[length_rev_append_thm]));
a(DROP_NTH_ASM_T 2 (asm_tac o rewrite_rule[rev_rev_thm]));
a(∂_tac ¨l2Æ THEN ∂_tac ¨rÆ THEN asm_rewrite_tac[]);
val €poly_linear_div_thm› = save_pop_thm "poly_linear_div_thm";
=TEX
We can now prove that a polynomial in $x$ which vanishes for all sufficiently
large $x$ is identically zero.
%%%%
%%%%
=SML
set_goal([], ¨µf c∑
	f ç PolyFunc ± (µx∑ c < x ¥ f x = ÓØ 0)
¥	(µx∑f x = ÓØ 0)
Æ);
a(lemma_tac¨µm l c∑ Length l º m ± (µx∑ c < x ¥ PolyEval l x = ÓØ 0)
¥	(µx∑PolyEval l x = ÓØ 0)
Æ);
(* *** Goal "1" *** *)
a(µ_tac THEN induction_tac¨m:ÓÆ THEN1 REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(all_fc_tac[length_eq_0_thm] THEN asm_rewrite_tac[poly_eval_def]);
(* *** Goal "1.2" *** *)
a(REPEAT µ_tac THEN ¥_tac);
a(cases_tac¨Length l º mÆ THEN1
	(GET_NTH_ASM_T 4 bc_thm_tac THEN asm_prove_tac[]));
a(lemma_tac ¨Length l = m + 1Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(lemma_tac¨≥l = []Æ THEN1
	(contr_tac THEN all_var_elim_asm_tac1 THEN all_asm_ante_tac
	THEN rewrite_tac[length_def]));
a(strip_asm_tac(rewrite_rule[]
	(list_µ_elim[¨lÆ, ¨c + ÓØ 1Æ] poly_linear_div_thm)));
a(TOP_ASM_T (ante_tac o µ_elim¨c + ÓØ 1Æ) THEN
	conv_tac(ONCE_MAP_C Ø_anf_conv));
a(GET_NTH_ASM_T 6 (rewrite_thm_tac o rewrite_rule[] o µ_elim¨ÓØ 1 + cÆ));
a(strip_tac THEN all_var_elim_asm_tac1);
a(lemma_tac¨Length l2 º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(lemma_tac¨µ x∑ c + ÓØ 1 < x ¥ PolyEval l2 x = ÓØ 0Æ);
(* *** Goal "1.2.1" *** *)
a(swap_nth_asm_concl_tac 2 THEN REPEAT strip_tac);
a(lemma_tac¨c < xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(∂_tac¨xÆ THEN LIST_GET_NTH_ASM_T [9] (ALL_FC_T rewrite_tac));
a(conv_tac (RAND_C eq_sym_conv) THEN rewrite_tac[Ø_times_eq_0_thm]);
a(REPEAT strip_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2" *** *)
a(list_spec_nth_asm_tac 10 [¨l2Æ, ¨c + ÓØ 1Æ] THEN1 all_asm_fc_tac[]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext" rewrite_tac[poly_func_eq_poly_eval_thm] THEN
	REPEAT µ_tac THEN ¥_tac);
a(asm_rewrite_tac[] THEN GET_NTH_ASM_T 3 bc_thm_tac);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a(∂_tac¨cÆ THEN ∂_tac¨Length lÆ THEN asm_rewrite_tac[]);
val €poly_eventually_0_eq_0_thm› = save_pop_thm "poly_eventually_0_eq_0_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Lemmas about Real Arithmetic}
%%%%
%%%%
%%%%
%%%%
\subsubsection{Lemmas about the Absolute Value Function Etc.}
%%%%
%%%%
%%%%
%%%%
We will need a number of facts about absolute values etc.
=TEX
Absolute values are non-negative:
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx:Ø∑ ÓØ 0 º Abs xÆ);
a(REPEAT strip_tac THEN rewrite_tac[get_spec¨AbsâRÆ]);
a(cases_tac ¨ÓØ 0 º xÆ
	THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_0_º_abs_thm› = save_pop_thm "Ø_0_º_abs_thm";
=TEX
Next, the triangle inequality:
%%%%
%%%%
=SML
set_goal([], ¨µx y:Ø∑ Abs(x + y) º Abs x + Abs yÆ);
a(REPEAT strip_tac THEN rewrite_tac[get_spec¨AbsâRÆ]);
a(MAP_EVERY cases_tac [¨ÓØ 0 º xÆ, ¨ÓØ 0 º yÆ, ¨ÓØ 0 º x + yÆ]
	THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_abs_plus_thm› = save_pop_thm "Ø_abs_plus_thm";
=TEX
\ldots and again in a formulation that is nice for back-chaining:
%%%%
%%%%
=SML
set_goal([], ¨µx y z:Ø∑ Abs x º Abs (y + z) ¥ Abs x º Abs y + Abs zÆ);
a(REPEAT strip_tac THEN bc_thm_tac Ø_º_trans_thm);
a(∂_tac¨Abs(y + z)Æ THEN asm_rewrite_tac[Ø_abs_plus_thm]);
val €Ø_abs_plus_bc_thm› = save_pop_thm "Ø_abs_plus_bc_thm";
=TEX
Absolute values commute with multiplication:
%%%%
%%%%
=SML
set_goal([], ¨µx y:Ø∑ Abs(x * y) = Abs x * Abs yÆ);
a(lemma_tac ¨µx y:Ø∑ ÓØ 0 º x ± ÓØ 0 º y ¥ Abs(x * y) = Abs x * Abs yÆ
	THEN REPEAT strip_tac THEN1 (all_fc_tac[Ø_0_º_0_º_times_thm]
		THEN asm_rewrite_tac[get_spec¨AbsâRÆ]));
a(cases_tac¨ÓØ 0 º xÆ THEN cases_tac¨ÓØ 0 º yÆ THEN1 all_asm_fc_tac[]);
(* *** Goal "1" *** *)
a(lemma_tac¨ÓØ 0 º ~yÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_ASM_FC_T (MAP_EVERY ante_tac)[]);
a(LEMMA_T ¨x* ~y = ~(x*y)Æ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(rewrite_tac[Ø_abs_minus_thm]);
(* *** Goal "2" *** *)
a(lemma_tac¨ÓØ 0 º ~xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_ASM_FC_T (MAP_EVERY ante_tac)[]);
a(LEMMA_T ¨~x * y = ~(x*y)Æ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(rewrite_tac[Ø_abs_minus_thm] THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(lemma_tac¨ÓØ 0 º ~x ± ÓØ 0 º ~yÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_ASM_FC_T (MAP_EVERY ante_tac)[]);
a(LEMMA_T ¨~x * ~y = (x*y)Æ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(rewrite_tac[Ø_abs_minus_thm]);
val €Ø_abs_times_thm› = save_pop_thm "Ø_abs_times_thm";
=TEX
Only 0 has absolute value 0:
%%%%
%%%%
=SML
set_goal([], ¨µx∑ Abs x = ÓØ 0 § x = ÓØ 0Æ);
a(strip_tac THEN rewrite_tac[get_spec¨AbsâRÆ]);
a(cases_tac¨ÓØ 0 º xÆ THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €Ø_abs_eq_0_thm› = save_pop_thm "Ø_abs_eq_0_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨Abs (ÓØ 0) = ÓØ 0Æ);
a(rewrite_tac[get_spec¨AbsâRÆ]);
val €Ø_abs_0_thm› = save_pop_thm "Ø_abs_0_thm";
=TEX
Absolute values commute with reciprocal:
%%%%
%%%%
=SML
set_goal([], ¨µx∑ ≥x = ÓØ 0 ¥ Abs (x õ-õ1) = (Abs x) õ-õ1Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨Abs(x * x õ-õ1) = ÓØ 1Æ ante_tac THEN1
	(ALL_FC_T rewrite_tac[Ø_times_recip_thm]));
a(rewrite_tac[Ø_abs_times_thm] THEN strip_tac);
a(lemma_tac¨≥Abs x = ÓØ 0ÆTHEN1 asm_rewrite_tac[Ø_abs_eq_0_thm]);
a(LEMMA_T¨(Abs x * (Abs x) õ-õ1) * Abs(x õ-õ1) = (Abs x)õ-õ1Æ ante_tac THEN1
	asm_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b c:Ø∑(a*b)*c = b*a*cÆ]);
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
val €Ø_abs_recip_thm› = save_pop_thm "Ø_abs_recip_thm";
=TEX
A monotonicity property for absolute values and multiplication:
%%%%
%%%%
=SML
set_goal([], ¨µx t y u:Ø∑ Abs x < t ± Abs y < u ¥ Abs x * Abs y < t*uÆ);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim¨xÆ Ø_0_º_abs_thm));
a(strip_asm_tac (µ_elim¨yÆ Ø_0_º_abs_thm));
a(lemma_tac¨ÓØ 0 < t ± ÓØ 0 < uÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(cases_tac ¨Abs x = ÓØ 0Æ THEN1 
	(all_fc_tac[Ø_0_less_0_less_times_thm] THEN asm_rewrite_tac[]));
a(cases_tac ¨Abs y = ÓØ 0Æ THEN1 
	(all_fc_tac[Ø_0_less_0_less_times_thm] THEN asm_rewrite_tac[]));
a(lemma_tac ¨ÓØ 0 < Abs x ± ÓØ 0 < Abs yÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(bc_thm_tac Ø_less_trans_thm);
a(∂_tac¨Abs x * uÆ THEN REPEAT strip_tac
	THEN1 bc_thm_tac Ø_times_mono_thm THEN REPEAT strip_tac);
a(once_rewrite_tac[Ø_times_comm_thm]
	THEN bc_thm_tac Ø_times_mono_thm THEN REPEAT strip_tac);
val €Ø_abs_less_times_thm› = save_pop_thm "Ø_abs_less_times_thm";
=TEX
Now a result about absolute values and reciprocals (of positive
reals).
Reciprocal of positive reals is order reversing:
%%%%
%%%%
=SML
set_goal([], ¨µx y:Ø∑ ÓØ 0 < x ± ÓØ 0 < y ± x < y ¥ y õ-õ1 < x õ-õ1Æ);
a(REPEAT strip_tac);
a(lemma_tac¨y õ-õ1 * x õ-õ1 * x < y õ-õ1 * x õ-õ1 * yÆ);
(* *** Goal "1" *** *)
a(all_fc_tac[Ø_0_less_0_less_recip_thm]);
a(REPEAT (bc_thm_tac Ø_times_mono_thm THEN REPEAT strip_tac));
(* *** Goal "2" *** *)
a(lemma_tac¨≥x = ÓØ 0 ± ≥y = ÓØ 0Æ THEN1
	(LIST_GET_NTH_ASM_T [3, 4] (MAP_EVERY ante_tac) THEN
		PC_T1 "Ø_lin_arith" prove_tac[]));
a(DROP_NTH_ASM_T 3 ante_tac);
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨
	y õ-õ1 * x õ-õ1 * x = y õ-õ1 * (x * x õ-õ1)
±	y õ-õ1 * x õ-õ1 * y = x õ-õ1 * (y * y õ-õ1)Æ]);
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
val €Ø_less_recip_less_thm› = save_pop_thm "Ø_less_recip_less_thm";
=TEX
Non-zero numbers have positive absolute values:
%%%%
%%%%
=SML
set_goal([], ¨µx∑ ≥x = ÓØ 0 § ÓØ 0 < Abs xÆ);
a(REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 º Abs xÆ THEN1 rewrite_tac[Ø_0_º_abs_thm]);
a(lemma_tac¨≥ Abs x = ÓØ 0Æ THEN1 asm_rewrite_tac[Ø_abs_eq_0_thm]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
val €Ø_≥_0_abs_thm› = save_pop_thm "Ø_≥_0_abs_thm";
=TEX
The following algebraic lemma is used often enough to be worth recording:
it says that, providing both sides are well-defined, $1/x+1/y = (x+y)/xy$.
%%%%
%%%%
=SML
set_goal([], ¨µx y∑ ≥x = ÓØ 0 ± ≥y = ÓØ 0 ¥
	(x õ-õ1 + y õ-õ1) = (x + y) * x õ-õ1 * y õ-õ1Æ);
a(REPEAT strip_tac THEN conv_tac (RIGHT_C Ø_anf_conv));
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
a(rewrite_tac[Ø_times_assoc_thm1] THEN ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
val €Ø_plus_recip_thm› = save_pop_thm"Ø_plus_recip_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsubsection{The Archimedean Property}
%%%%
%%%%
%%%%
%%%%
We present the archimedean property in two guises:
the usual formulation, any real is bounded above by some natural number:
%%%%
%%%%
=SML
set_goal([], ¨µx:Ø∑ ∂m∑ x < ÓØ mÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨xÆ, ¨ÓØ 0Æ]Ø_less_cases_thm) THEN1 asm_prove_tac[]
	THEN1 ∂_tac¨1Æ THEN1 asm_rewrite_tac[]);
a(Ø_delta_induction_tac¨xÆ);
a(∂_tac¨ÓØ 1Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨ÓØ 2Æ THEN REPEAT strip_tac);
a(∂_tac¨3Æ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨m+1Æ THEN rewrite_tac[ÓØ_plus_homomorphism_thm]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_archimedean_thm› = save_pop_thm "Ø_archimedean_thm";
=TEX
\ldots and a reciprocal version: any positive real is bounded
below by the reciprocal of a positive natural number.
%%%%
%%%%
=SML
set_goal([], ¨µx:Ø∑ ÓØ 0 < x ¥ ∂m∑ (ÓØ (m+1))õ-õ1 < xÆ);
a(REPEAT strip_tac THEN all_fc_tac[Ø_0_less_0_less_recip_thm]);
a(strip_asm_tac(µ_elim¨x õ-õ1ÆØ_archimedean_thm));
a(lemma_tac¨x õ-õ1 < ÓØ (m+1)Æ THEN1
	(rewrite_tac[ÓØ_plus_homomorphism_thm] THEN
		bc_thm_tac Ø_less_trans_thm THEN ∂_tac ¨ÓØ mÆ THEN REPEAT strip_tac));
a(DROP_NTH_ASM_T 2 discard_tac);
a(lemma_tac¨ÓØ 0 < ÓØ (m+1)Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [Ø_less_recip_less_thm]);
a(lemma_tac¨≥x = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses] THEN prove_tac[]);
val €Ø_archimedean_recip_thm› = save_pop_thm "Ø_archimedean_recip_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Limits}
%%%%
%%%%
%%%%
%%%%
We now prove some basic facts about limits.

Firstly, constant sequences have limits:
%%%%
%%%%
=SML
set_goal([], ¨µc∑(Ãm∑ c) --> cÆ);
a(REPEAT strip_tac THEN rewrite_tac[lim_seq_def]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val €const_lim_seq_thm› = save_pop_thm "const_lim_seq_thm";
=TEX
Secondly, if two sequences each have a limit, then so does their
sum and its limit is the sum of the limits:
%%%%
%%%%
=SML
set_goal([], ¨µs1 c1 s2 c2∑
	s1 --> c1 ± s2 --> c2 ¥ (Ãm∑s1 m + s2 m) --> c1 + c2Æ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac ¨ÓØ 0 < e / ÓØ 2 Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 2 discard_tac THEN asm_fc_tac[]);
a(∂_tac¨n + n'Æ THEN REPEAT strip_tac);
a(lemma_tac¨n º m ± n' º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T [4, 5] all_fc_tac);
a(LEMMA_T ¨(s1 m + s2 m) + ~c1 + ~c2 = (s1 m + ~c1) + (s2 m + ~c2)Æ
	rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(bc_thm_tac Ø_º_less_trans_thm);
a(∂_tac¨Abs (s1 m + ~ c1) + Abs (s2 m + ~ c2)Æ THEN rewrite_tac[Ø_abs_plus_thm]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €plus_lim_seq_thm› = save_pop_thm "plus_lim_seq_thm";
=TEX
We now want to give the expected result on the product of two sequences
with limits. We need some preliminaries. The first is of general use,
it says that any sequence with a limit has bounded absolute values:
%%%%
%%%%
=SML
set_goal([], ¨µs c∑ s --> c ¥ ∂b∑ ÓØ 0 < b ± µm∑ Abs(s m) < bÆ);
a(lemma_tac¨µn; s: Ó ≠ Ø; b1∑ ÓØ 0 < b1 ± (µm∑n º m ¥ Abs(s m) < b1) ¥
	(∂b2∑ÓØ 0 < b2 ± µ m∑ Abs(s m) < b2)Æ);
(* *** Goal "1" *** *)
a(strip_tac THEN induction_tac ¨n:ÓÆ THEN1 prove_tac[]);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 bc_thm_tac);
a(∂_tac¨Abs(s n) + b1Æ);
a(spec_nth_asm_tac 1 ¨n+1Æ);
a(strip_asm_tac(µ_elim¨s(n+1)Æ Ø_0_º_abs_thm));
a(strip_asm_tac(µ_elim¨s nÆ Ø_0_º_abs_thm));
a(REPEAT strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(cases_tac¨m' = nÆ THEN1 (all_var_elim_asm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨n + 1 º m'Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 bc_thm_tac);
a(spec_nth_asm_tac 1 ¨ÓØ 1Æ);
a(∂_tac¨nÆ THEN ∂_tac¨Abs c + ÓØ 2Æ);
a(REPEAT strip_tac THEN1
	(strip_asm_tac(µ_elim¨cÆ Ø_0_º_abs_thm) THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(all_asm_fc_tac[]);
a(ante_tac (list_µ_elim[¨s m + ~cÆ, ¨cÆ]Ø_abs_plus_thm));
a(rewrite_tac[Ø_plus_assoc_thm] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €lim_seq_bounded_thm› = save_pop_thm "lim_seq_bounded_thm";
=TEX
Now a more specialised lemma which is the arithmetic core
of the argument about the product of two sequences:
%%%%
%%%%
=SML
set_goal([], ¨µe t x y c d∑
	Abs(x - c) < e * (ÓØ 2*t)õ-õ1
±	Abs(y - d) < e * (ÓØ 2*t)õ-õ1
±	Abs x < t
±	Abs d < t
¥	Abs (x*y - c*d) < e	Æ);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(LEMMA_T ¨x*y + ~(c*d) = x*(y + ~d) + (x + ~c)*dÆ rewrite_thm_tac
	THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨Abs(x*(y + ~d)) + Abs((x + ~c)*d)Æ
	THEN rewrite_tac[Ø_abs_plus_thm, Ø_abs_times_thm]);
a(bc_thm_tac Ø_less_º_trans_thm THEN ∂_tac¨t*e*(ÓØ 2*t)õ-õ1 + t*e*(ÓØ 2*t)õ-õ1Æ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ø_plus_mono_thm2);
a(REPEAT strip_tac THEN1 (bc_thm_tac Ø_abs_less_times_thm THEN REPEAT strip_tac));
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µx∑t*e*x = (e*x)*tÆ]);
a(bc_thm_tac Ø_abs_less_times_thm THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(conv_tac (LEFT_C Ø_anf_conv));
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µx y∑x*e*t*y = e*(x*t)*yÆ]);
a(lemma_tac¨≥ ÓØ 2 * t = ÓØ 0Æ THEN1
	(strip_asm_tac(µ_elim¨xÆ Ø_0_º_abs_thm) THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
val €times_lim_seq_lemma› = pop_thm ();
=TEX
Now we can prove that the product of two sequences each of which has a limit has
the product of the limits as its limit:
%%%%
%%%%
=SML
set_goal([], ¨µs1 c1 s2 c2∑
	s1 --> c1 ± s2 --> c2 ¥ (Ãm∑s1 m * s2 m) --> c1 * c2Æ);
a(REPEAT strip_tac THEN rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[lim_seq_def]));
a(all_fc_tac[lim_seq_bounded_thm]);
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[lim_seq_def]));
a(strip_asm_tac(µ_elim¨c2Æ Ø_0_º_abs_thm));
a(lemma_tac¨ÓØ 0 < e*(ÓØ 2 * (b + Abs c2))õ-õ1Æ);
(* *** Goal "1" *** *)
a(bc_thm_tac Ø_0_less_0_less_times_thm THEN REPEAT strip_tac);
a(bc_thm_tac Ø_0_less_0_less_recip_thm THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T [5, 7] (MAP_EVERY ante_tac));
a(all_asm_fc_tac[] THEN REPEAT strip_tac);
a(∂_tac¨n+n'Æ THEN REPEAT strip_tac);
a(lemma_tac¨n º m ± n' º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T[6, 7] all_fc_tac);
a(bc_thm_tac (rewrite_rule[]times_lim_seq_lemma));
a(∂_tac¨b + Abs c2Æ THEN asm_rewrite_tac[]);
a(spec_nth_asm_tac 13 ¨mÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €times_lim_seq_thm› = save_pop_thm "times_lim_seq_thm";
=TEX
We can now show by polynomial induction that polynomial functions preserve limits.
As we will see shortly, this shows that every polynomial function is continuous.
%%%%
%%%%
=SML
set_goal([], ¨µf s t∑f ç PolyFunc ± s --> t ¥ (Ãx∑ f (s x)) --> f tÆ);
a(REPEAT strip_tac);
a(poly_induction_tac ¨fÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[const_lim_seq_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[»_axiom]);
(* *** Goal "3" *** *)
a(ALL_FC_T (MAP_EVERY ante_tac) [plus_lim_seq_thm]);
a(rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(ALL_FC_T (MAP_EVERY ante_tac) [times_lim_seq_thm]);
a(rewrite_tac[] THEN REPEAT strip_tac);
val €poly_lim_seq_thm› = save_pop_thm "poly_lim_seq_thm";
=TEX
Finally, moving on from polynomials, we will need to reason
about (particular) rational functions from time to time and
this requires the usual result about the limit of
a sequence of reciprocals.
%%%%
%%%%
=SML
set_goal([], ¨µs∑ s --> t ± ≥t = ÓØ 0 ¥ (Ãm∑ (s m) õ-õ1) --> t õ-õ1Æ);
a(REPEAT strip_tac THEN all_fc_tac [lim_seq_bounded_thm]);
a(DROP_NTH_ASM_T 4 ante_tac THEN
	rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(all_fc_tac[Ø_≥_0_abs_thm]);
a(lemma_tac¨ÓØ 0 < (1/2)*Abs tÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨∂n1∑µ m∑ n1 º m ¥ (1/2)*Abs t < Abs(s m)Æ);
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 4 ¨(1/2)*Abs tÆ);
a(∂_tac ¨nÆ THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [2] all_fc_tac);
a(CONTR_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(lemma_tac¨Abs t < Abs tÆ);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨Abs(s m) + Abs(~(s m + ~t))Æ);
a(REPEAT strip_tac THEN_LIST
	[bc_thm_tac Ø_abs_plus_bc_thm,
	rewrite_tac[Ø_abs_minus_thm] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]]);
a(conv_tac (ONCE_MAP_C Ø_anf_conv) THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(lemma_tac ¨ÓØ 0 < Abs t*Abs t*eÆ THEN1
	(all_fc_tac[Ø_0_less_0_less_times_thm] THEN all_fc_tac[Ø_0_less_0_less_times_thm]));
a(lemma_tac ¨ÓØ 0 < (1/2)*Abs t*Abs t*eÆ THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 7 ¨(1/2)*Abs t*Abs t*eÆ);
a(∂_tac¨n1 + nÆ THEN REPEAT strip_tac);
a(lemma_tac¨n1 º m ± n º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 7 ¨mÆ);
a(LEMMA_T¨≥Abs(s m) = ÓØ 0Æ (asm_tac o rewrite_rule[Ø_abs_eq_0_thm])
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨≥ ~ t = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[
	conv_rule(ONCE_MAP_C (RIGHT_C eq_sym_conv)) Ø_minus_recip_thm,
	Ø_plus_recip_thm]);
a(spec_nth_asm_tac 7 ¨mÆ);
a(once_rewrite_tac[Ø_abs_times_thm]);
a(lemma_tac¨≥Abs t = ÓØ 0Æ THEN1 asm_rewrite_tac[Ø_abs_eq_0_thm]);
a(LEMMA_T ¨e = ((1/2)*Abs t * Abs t * e)*(Abs ((1/2)*t))õ-õ1*(Abs t)õ-õ1Æ once_rewrite_thm_tac
	THEN1 (rewrite_tac[Ø_abs_times_thm] THEN
		ALL_FC_T rewrite_tac[
			rewrite_rule[](µ_elim¨1/2Æ(hd(rev(strip_±_rule Ø_recip_clauses))))] THEN
			rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
			¨µx y∑((1/2)*x*x*y)*(ÓØ 2 * x õ-õ1)*x õ-õ1=
				 (x*x õ-õ1) * (x*x õ-õ1) * yÆ]
		THEN ALL_FC_T rewrite_tac[Ø_times_recip_thm]));
a(bc_thm_tac Ø_abs_less_times_thm THEN REPEAT strip_tac);
a(once_rewrite_tac[Ø_times_comm_thm] THEN rewrite_tac[Ø_abs_times_thm]);
a(ALL_FC_T rewrite_tac[Ø_minus_recip_thm] THEN rewrite_tac[Ø_abs_minus_thm]);
a(ALL_FC_T rewrite_tac[Ø_abs_recip_thm] THEN bc_thm_tac Ø_times_mono_thm);
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac Ø_0_less_0_less_recip_thm THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(bc_thm_tac Ø_less_recip_less_thm THEN
	LIST_GET_NTH_ASM_T [14, 5] (MAP_EVERY ante_tac) THEN
	PC_T1 "Ø_lin_arith" prove_tac[]);
val €recip_lim_seq_thm› = save_pop_thm "recip_lim_seq_thm";
=TEX
Some further generalities about sequences are useful.
The following theorem says that an arbitrary interleaving of two
sequences that converge to the same limit itself converges to that limit:
%%%%
%%%%
=SML
set_goal([], ¨µp s1 s2 x∑ s1 --> x ± s2 --> x ¥ (Ãm∑if p m then s1 m else s2 m) --> xÆ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(∂_tac¨n + n'Æ THEN REPEAT strip_tac);
a(lemma_tac¨n º m ± n' º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T [4, 5] all_fc_tac);
a(cases_tac¨p mÆ THEN asm_rewrite_tac[]);
val €lim_seq_choice_thm› = save_pop_thm "lim_seq_choice_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx∑ (Ãm∑x + ÓØ(m+1)õ-õ1) --> xÆ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(all_fc_tac[Ø_archimedean_recip_thm]);
a(∂_tac¨m+1Æ THEN REPEAT strip_tac);
a(conv_tac(ONCE_MAP_C Ø_anf_conv));
a(lemma_tac¨ÓØ 0 < ÓØ (m+1) ± ÓØ 0 < ÓØ (m'+1)Æ THEN1 rewrite_tac[ÓØ_0_less_thm]);
a(lemma_tac¨ÓØ (m+1) < ÓØ (m'+1)Æ THEN1 
	(asm_rewrite_tac[ÓØ_less_thm] THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(lemma_tac¨ÓØ 0 º ÓØ (m' + 1) õ-õ1Æ THEN1
	(rewrite_tac[Ø_º_def] THEN all_fc_tac[Ø_0_less_0_less_recip_thm] THEN asm_rewrite_tac[]));
a(asm_rewrite_tac[Ø_abs_def]);
a(all_fc_tac[Ø_less_recip_less_thm]);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨ÓØ (m + 1) õ-õ1Æ THEN REPEAT strip_tac);
val €lim_seq_recip_Ó_thm› = save_pop_thm "lim_seq_recip_Ó_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx∑ ∂s∑ s --> x ± (µm∑≥s m = x)Æ);
a(REPEAT strip_tac);
a(∂_tac¨(Ãm∑x + ÓØ(m+1)õ-õ1)Æ THEN rewrite_tac[lim_seq_recip_Ó_thm]);
a(REPEAT strip_tac THEN lemma_tac¨ÓØ 0 < ÓØ (m + 1) õ-õ1Æ THEN_LIST
	[id_tac, PC_T1 "Ø_lin_arith" asm_prove_tac[]]);
a(bc_tac[Ø_0_less_0_less_recip_thm] THEN rewrite_tac[ÓØ_0_less_thm]);
val €lim_seq_≥_eq_thm› = save_pop_thm "lim_seq_≥_eq_thm";
=TEX
The following ``shift theorem''
shows that we can ignore any finite leading subsequence of
a sequence when we calculate its limit:
%%%%
%%%%
=SML
set_goal([], ¨µm s x∑ (s --> x) § (Ãn∑s (m+n)) --> xÆ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN ∂_tac¨nÆ THEN REPEAT strip_tac);
a(lemma_tac¨n º m+m'Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[] THEN ∂_tac¨n + mÆ THEN REPEAT strip_tac);
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[º_def]) THEN all_var_elim_asm_tac1);
a(SPEC_NTH_ASM_T 1 ¨n+iÆ ante_tac THEN
	conv_tac (ONCE_MAP_C anf_conv) THEN
	REPEAT strip_tac);
val €lim_seq_shift_thm› = save_pop_thm "lim_seq_shift_thm";
=TEX
A sequences that converges to a non-zero limit can have
at most finitely many zero values:
%%%%
%%%%
=SML
set_goal([], ¨µs x∑ (s --> x) ± ≥x = ÓØ 0 ¥ ∂n∑µm∑ n º m ¥ ≥s m = ÓØ 0Æ);
a(rewrite_tac[lim_seq_def] THEN contr_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[Ø_≥_0_abs_thm] THEN all_asm_fc_tac[]);
a(spec_nth_asm_tac 3 ¨nÆ);
a(spec_nth_asm_tac 3 ¨mÆ);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[Ø_abs_minus_thm]);
val €lim_seq_≥_0_thm› = save_pop_thm "lim_seq_≥_0_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Continuity}
%%%%
%%%%
%%%%
%%%%
Most of the work on continuity duplicates reasoning for sequences if carried
out from first principles. To allow us to reuse the material on sequences,
we prove that a function is continuous iff. it preserves limits:
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf x∑ f CtsAt x § µs∑ s --> x ¥ (Ãm∑f(s m)) --> f xÆ);
a(rewrite_tac[cts_at_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨eÆ);
a(spec_nth_asm_tac 4 ¨dÆ);
a(∂_tac¨nÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(contr_tac THEN lemma_tac¨
	∂s∑µm∑ Abs(s m + ~x) < (ÓØ (m+1)) õ-õ1 ± e º Abs(f(s m) + ~(f x))
Æ THEN1 prove_∂_tac THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(lemma_tac¨ÓØ 0 < ÓØ (m' + 1) õ-õ1Æ THEN1
	(bc_thm_tac Ø_0_less_0_less_recip_thm THEN rewrite_tac[ÓØ_less_thm]));
a(spec_nth_asm_tac 2 ¨ÓØ (m' + 1) õ-õ1Æ);
a(∂_tac¨yÆ THEN REPEAT strip_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨s --> xÆ THEN1 rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(DROP_NTH_ASM_T 4 discard_tac THEN all_asm_fc_tac[Ø_archimedean_recip_thm]);
a(∂_tac¨m + 2Æ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨ÓØ (m'+1)õ-õ1Æ THEN asm_rewrite_tac[]);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨ÓØ (m+1)õ-õ1Æ THEN asm_rewrite_tac[]);
a(bc_thm_tac Ø_less_recip_less_thm THEN
	rewrite_tac[ÓØ_plus_homomorphism_thm, ÓØ_less_thm]
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2.2.2" *** *)
a(ALL_ASM_FC_T (MAP_EVERY ante_tac)[]);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(∂_tac ¨eÆ THEN REPEAT strip_tac);
a(∂_tac ¨nÆ THEN asm_rewrite_tac[Ø_≥_less_º_thm]);
val €cts_lim_seq_thm› = save_pop_thm "cts_lim_seq_thm";
=TEX
It is occasionally convenient to have the following stronger variant
on the previous theorem, which lets us demonstrate continuity of a function $f$
at a point $x$ by considering sequences that tend to $x$ without ever being
equal to $x$.
%%%%
%%%%
=SML
set_goal([], ¨µf x∑ f CtsAt x § µs∑ s --> x ± (µm∑≥s m = x) ¥ (Ãm∑f(s m)) --> f xÆ);
a(REPEAT strip_tac THEN1 all_fc_tac[cts_lim_seq_thm]);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨xÆ lim_seq_≥_eq_thm));
a(strip_asm_tac(rewrite_rule[](list_µ_elim[¨Ãm∑s m = xÆ, ¨s'Æ, ¨sÆ, ¨xÆ]lim_seq_choice_thm)));
a(lemma_tac¨µm∑ ≥(Ãm∑ if s m = x then s' m else s m) m = xÆ THEN1 
	(REPEAT strip_tac THEN cases_tac ¨s m = xÆ THEN asm_rewrite_tac[]));
a(DROP_NTH_ASM_T  6 (ante_tac o µ_elim ¨(Ãm∑ if s m = x then s' m else s m)Æ) THEN
	asm_rewrite_tac[]);
a(DROP_ASMS_T discard_tac THEN rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(∂_tac¨nÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(DROP_NTH_ASM_T 2 ante_tac THEN cases_tac¨s m = xÆ THEN asm_rewrite_tac[]);
val €cts_lim_seq_thm1› = save_pop_thm "cts_lim_seq_thm1";
=TEX
Using the shift theorem, we can now prove a further sharpening of
the characterisation of continuity in terms of sequence convergence.
%%%%
%%%%
=SML
set_goal([], ¨µf x∑
	f CtsAt x §
	∂a b∑ a < x ± x < b ±
	(µs∑ s --> x ± (µm∑≥s m = x ± a < s m ± s m < b) ¥ (Ãm∑f(s m)) --> f x)Æ);
a(rewrite_tac[cts_lim_seq_thm1] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨x + ~(ÓØ 1)Æ THEN ∂_tac¨x + ÓØ 1Æ THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 3 bc_thm_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(GET_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[lim_seq_def]));
a(LIST_GET_NTH_ASM_T [5, 6]
	(MAP_EVERY(strip_asm_tac o once_rewrite_rule[Ø_less_0_less_thm])));
a(LIST_GET_NTH_ASM_T [3] all_fc_tac);
a(once_rewrite_tac[µ_elim¨n + n'Ælim_seq_shift_thm]);
a(rewrite_tac[]);
a(LEMMA_T¨µi j k∑ s((i+j)+k)=(Ãk∑s((i + j) + k))kÆ once_rewrite_thm_tac THEN1
	rewrite_tac[]);
a(DROP_NTH_ASM_T 8 bc_thm_tac);
a(ALL_FC_T asm_rewrite_tac[lim_seq_shift_thm] THEN contr_tac
	THEN POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
(* *** Goal "2.1" *** *)
a(lemma_tac ¨ÓØ 0 º ~(s((n+n')+m)) + xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨≥Abs(~(~(s((n+n')+m)) + x)) < x + ~aÆ ante_tac THEN1
	(asm_rewrite_tac[Ø_abs_minus_thm] THEN 
	asm_rewrite_tac[Ø_abs_def] THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(rewrite_tac[] THEN GET_NTH_ASM_T 4 bc_thm_tac THEN PC_T1 "lin_arith" prove_tac[]);
(* *** Goal "2.2" *** *)
a(lemma_tac ¨ÓØ 0 º s((n+n')+m) + ~xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨≥Abs(s((n+n')+m) + ~x) < b + ~xÆ ante_tac THEN1
	(asm_rewrite_tac[Ø_abs_def] THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(rewrite_tac[] THEN GET_NTH_ASM_T 3 bc_thm_tac THEN PC_T1 "lin_arith" prove_tac[]);
val €cts_lim_seq_thm2› = save_pop_thm "cts_lim_seq_thm2";
=TEX
Now we give the useful result that continuity is a local property: i.e.,
if two functions agree in a neighbourhood of a point and
one is continuous at that point then so is the other:
%%%%
%%%%
=SML
set_goal([], ¨µf g x a b∑
	a < x ± x < b
±	(µy∑ a < y ± y < b ¥ f y = g y)
±	g CtsAt x
¥	f CtsAt x Æ);
a(REPEAT strip_tac THEN rewrite_tac[cts_lim_seq_thm2]);
a(∂_tac¨aÆ THEN ∂_tac¨bÆ THEN REPEAT strip_tac);
a(LEMMA_T¨µm∑f(s m) = g(s m)Ærewrite_thm_tac THEN1
	(REPEAT strip_tac THEN
	spec_nth_asm_tac 1 ¨m:ÓÆ THEN
	all_asm_fc_tac[]));
a(LEMMA_T¨f x = g xÆrewrite_thm_tac THEN1 all_asm_fc_tac[]);
a(GET_NTH_ASM_T 3 (bc_thm_tac o rewrite_rule[cts_lim_seq_thm]) THEN asm_rewrite_tac[]);
val €cts_local_thm› = save_pop_thm"cts_local_thm";
=TEX
We now show that the polynomial constructions preserve limits.
%%%%
%%%%
=SML
set_goal([], ¨µc t∑ (Ãx∑c) CtsAt tÆ);
a(REPEAT strip_tac THEN rewrite_tac[cts_lim_seq_thm, const_lim_seq_thm]);
val €const_cts_thm› = save_pop_thm "const_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µt∑ (Ãx∑x) CtsAt tÆ);
a(REPEAT strip_tac THEN rewrite_tac[cts_lim_seq_thm, »_axiom]);
val €id_cts_thm› = save_pop_thm "id_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g t∑ f CtsAt t ± g CtsAt t ¥ (Ãx∑f x + g x) CtsAt tÆ);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [plus_lim_seq_thm]);
a(rewrite_tac[] THEN taut_tac);
val €plus_cts_thm› = save_pop_thm "plus_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g t∑ f CtsAt t ± g CtsAt t ¥ (Ãx∑f x * g x) CtsAt tÆ);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [times_lim_seq_thm]);
a(rewrite_tac[] THEN taut_tac);
val €times_cts_thm› = save_pop_thm "times_cts_thm";
=TEX
Now we can show that polynomial functions are continuous everywhere.
We could do this by polynomial induction using the theorems just
proved, but it's even easier to use the last result from the previous section:
%%%%
%%%%
=SML
set_goal([], ¨µf t∑ f ç PolyFunc ¥ f CtsAt tÆ);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac
	THEN ALL_FC_T rewrite_tac[poly_lim_seq_thm]);
val €poly_cts_thm› = save_pop_thm "poly_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g t∑ f CtsAt g t ± g CtsAt t ¥ (Ãx∑f(g x)) CtsAt tÆ);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac[»_axiom]);
val €comp_cts_thm› = save_pop_thm "comp_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µt∑~ CtsAt tÆ);
a(LEMMA_T ¨~ = (Ãx∑(Ãx∑~(ÓØ 1)) x * (Ãx∑x) x)Æ pure_once_rewrite_thm_tac
	THEN1 (rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(strip_tac THEN bc_thm_tac times_cts_thm);
a(rewrite_tac[const_cts_thm, id_cts_thm]);
val €minus_cts_thm› = save_pop_thm "minus_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf t∑f CtsAt t ¥ (Ãx∑~(f x)) CtsAt tÆ);
a(REPEAT strip_tac);
a(bc_thm_tac comp_cts_thm THEN REPEAT strip_tac);
a(rewrite_tac[minus_cts_thm]);
val €minus_comp_cts_thm› = save_pop_thm "minus_comp_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µt∑ ≥t = ÓØ 0 ¥ $õ-õ1 CtsAt tÆ);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(bc_thm_tac recip_lim_seq_thm THEN REPEAT strip_tac);
val €recip_cts_thm› = save_pop_thm "recip_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf t∑f CtsAt t ± ≥f t = ÓØ 0 ¥ (Ãx∑(f x)õ-õ1) CtsAt tÆ);
a(REPEAT strip_tac);
a(bc_thm_tac comp_cts_thm THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[recip_cts_thm]);
val €recip_comp_cts_thm› = save_pop_thm "recip_comp_cts_thm";
=TEX
%%%%
%%%%
=SML
fun €un_¬_conv› (v : TERM) : CONV = (fn tm =>
	let	val lhs = mk_app(mk_Ã(v, tm), v);
	in	eq_sym_rule (¬_conv lhs)
	end
);
val €Ã_un_¬_rands_conv› : CONV = (fn tm =>
	let	val (v, _) = dest_Ã tm;
	in	SIMPLE_Ã_C (RANDS_C (un_¬_conv v)) tm
	end
);
=TEX
%%%%
%%%%
=SML
val €simple_cts_tac› : TACTIC = (fn gl as (_, tm) => 
	let	val x = snd(dest_app tm);
		val const_thm = all_µ_intro(§_t_intro(all_µ_elim const_cts_thm));
		val id_thm = all_µ_intro(§_t_intro(all_µ_elim id_cts_thm));
	in
	conv_tac (simple_eq_match_conv const_thm) ORELSE
	conv_tac (simple_eq_match_conv id_thm) ORELSE
	(conv_tac (LEFT_C Ã_un_¬_rands_conv) THEN FIRST (map bc_thm_tac [
			plus_cts_thm, times_cts_thm, minus_comp_cts_thm, recip_comp_cts_thm]
		)) ORELSE
	conv_tac (LEFT_C »_conv ORELSE_C RAND_C (LEFT_C ¬_conv))
	end	gl
);
=IGN
set_goal([], ¨(Ãx∑c) CtsAt (ÓØ 2)Æ);
a simple_cts_tac;
val test1 = pop_thm();
set_goal([], ¨(Ãx∑x*y + ÓØ 3) CtsAt tÆ);
a(REPEAT (simple_cts_tac THEN REPEAT strip_tac));
val test2 = pop_thm();
set_goal([], ¨(Ãx∑ÓØ 3 * ((1/2)+x)õ-õ1) CtsAt 1/3Æ);
a(REPEAT (simple_cts_tac THEN REPEAT strip_tac));
a(rewrite_tac[]);
val test2 = pop_thm();
=TEX
Another useful lemma says any function continuous
on a closed interval can be extended to a function continuous
on the whole line.
It is occasionally useful to know the chosen values of the continuous extension
so we prove that stronger form first and then derive the weaker one from it.
For various reasons, we formulate the stronger form with the equations
arranged to map in the other order.
%%%%
%%%%
=SML
set_goal([], ¨µa b f∑
	a < b
±	(µx∑ a º x ± x º b ¥ f CtsAt x)
¥	(∂g∑
		(µx∑ a º x ± x º b ¥ g x = f x)
	±	(µx∑x < a ¥ g x = f a)
	±	(µx∑b < x ¥ g x = f b)
	±	(µx∑ g CtsAt x)) Æ);
a(REPEAT strip_tac);
a(∂_tac¨Ãz∑
	if	z < a
	then	f a
	else if	b < z
	then	f b
	else	f zÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T¨≥x < a ± ≥ b < xÆ asm_rewrite_thm_tac THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(LEMMA_T¨≥x < aÆ  asm_rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "4" *** *)
a(cases_tac¨x < aÆ THEN1 bc_thm_tac cts_local_thm);
(* *** Goal "4.1" *** *)
a(∂_tac¨Ãx∑f aÆ THEN ∂_tac¨aÆ THEN ∂_tac¨x + ~(ÓØ 1)Æ THEN
	asm_rewrite_tac[const_cts_thm] THEN REPEAT strip_tac THEN
	asm_rewrite_tac[]);
(* *** Goal "4.2" *** *)
a(cases_tac¨x = aÆ THEN1 all_var_elim_asm_tac1);
(* *** Goal "4.2.1" *** *)
a(rewrite_tac[cts_lim_seq_thm2]);
a(POP_ASM_T ante_tac THEN rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(∂_tac¨a + ~(ÓØ 1)Æ THEN ∂_tac¨bÆ THEN REPEAT strip_tac);
a(LEMMA_T¨≥b < a Æ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨µm∑≥b < s mÆrewrite_thm_tac THEN1
	(REPEAT strip_tac THEN
	spec_nth_asm_tac 1 ¨m:ÓÆ THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(LEMMA_T ¨µm:Ó∑
	f a = (Ãi∑ f a)m
± 	f (s m) = (Ãi∑f(s i))m
±	(s m < a § (Ãi∑s i < a) m)Æ once_rewrite_thm_tac
	THEN1 rewrite_tac[]);
a(bc_thm_tac lim_seq_choice_thm THEN rewrite_tac[const_lim_seq_thm]);
a(SPEC_NTH_ASM_T 3 ¨aÆ ante_tac);
a(LEMMA_T ¨a º bÆ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "4.2.2" *** *)
a(cases_tac¨x < bÆ THEN1 bc_thm_tac cts_local_thm);
(* *** Goal "4.2.2.1" *** *)
a(lemma_tac ¨a < xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(∂_tac¨fÆ THEN ∂_tac¨bÆ THEN ∂_tac¨aÆ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN1 
	(LEMMA_T ¨≥y < a ± ≥b < yÆrewrite_thm_tac THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(GET_NTH_ASM_T 5 bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "4.2.2.2" *** *)
a(cases_tac¨x = bÆ THEN1 all_var_elim_asm_tac1);
(* *** Goal "4.2.2.2.1" *** *)
a(LIST_DROP_NTH_ASM_T [1,2] discard_tac THEN rewrite_tac[cts_lim_seq_thm2]);
a(POP_ASM_T ante_tac THEN rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(∂_tac¨aÆ THEN ∂_tac¨b + ÓØ 1Æ THEN REPEAT strip_tac);
a(LEMMA_T¨≥b < a Æ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨µm∑≥s m < aÆrewrite_thm_tac THEN1
	(REPEAT strip_tac THEN
	spec_nth_asm_tac 1 ¨m:ÓÆ THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(LEMMA_T ¨µm:Ó∑
	f b = (Ãi∑ f b)m
± 	f (s m) = (Ãi∑f(s i))m
±	(b < s m § (Ãi∑b < s i) m)Æ once_rewrite_thm_tac
	THEN1 rewrite_tac[]);
a(bc_thm_tac lim_seq_choice_thm THEN rewrite_tac[const_lim_seq_thm]);
a(SPEC_NTH_ASM_T 3 ¨bÆ ante_tac);
a(LEMMA_T ¨a º bÆ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "4.2.2.2.2" *** *)
a(LEMMA_T ¨b < xÆ ante_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [1,2,3,4] discard_tac THEN strip_tac);
a(all_fc_tac[µ_elim¨bÆØ_less_dense_thm]);
a(bc_thm_tac cts_local_thm);
a(∂_tac¨Ãx∑f bÆ THEN ∂_tac¨x + ÓØ 1Æ THEN ∂_tac¨bÆ THEN
	asm_rewrite_tac[const_cts_thm] THEN REPEAT strip_tac THEN
	asm_rewrite_tac[]);
a(LEMMA_T ¨≥y < aÆ rewrite_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €cts_extension_thm1› = save_pop_thm"cts_extension_thm1";
=TEX
The weaker form of the extension theorem can now easily be derived:
%%%%
%%%%
=SML
set_goal([], ¨µa b f∑
	a < b
±	(µx∑ a º x ± x º b ¥ f CtsAt x)
¥	(∂g∑ (µx∑ a º x ± x º b ¥ g x = f x) ± (µx∑ g CtsAt x)) Æ);
a(REPEAT strip_tac);
a(all_fc_tac[cts_extension_thm1]);
a(∂_tac¨gÆ THEN asm_rewrite_tac[]);
val €cts_extension_thm› = save_pop_thm"cts_extension_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{A little Topology}
%%%%
%%%%
%%%%
%%%%
Mainly for use in one or two applications of the compactness of a closed interval
we need some elementary facts of a topological nature.

Our definition of an open set is the standard one.
A ``$\delta$'' characterisation which is closer to the style
used in the definitions of sequence convergence etc. is useful.
%%%%
%%%%
=SML
set_goal([], ¨µA∑
	A ç OpenSets
§	(µt∑ t ç A ¥ ∂d∑ÓØ 0 < d ± µy∑ Abs(y - t) < d ¥ y ç A)
Æ);
a(rewrite_tac[open_sets_def, open_interval_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
a(cases_tac¨t + ~x < y + ~tÆ);
(* *** Goal "1.1" *** *)
a(∂_tac¨t + ~xÆ THEN REPEAT strip_tac THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨x < y' ± y' < yÆ THEN1
	(LIST_DROP_NTH_ASM_T [1,2,4,5] (MAP_EVERY ante_tac) THEN
	DROP_ASMS_T discard_tac THEN
	cases_tac¨ÓØ 0 º y' + ~tÆ THEN
	asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a(∂_tac¨y + ~tÆ THEN REPEAT strip_tac THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨x < y' ± y' < yÆ THEN1
	(LIST_DROP_NTH_ASM_T [1,2,4,5] (MAP_EVERY ante_tac) THEN
	DROP_ASMS_T discard_tac THEN
	cases_tac¨ÓØ 0 º y' + ~tÆ THEN
	asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
a(∂_tac¨t + ~dÆ THEN ∂_tac¨t + dÆ THEN REPEAT strip_tac THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(GET_NTH_ASM_T 3 bc_thm_tac);
a(LIST_DROP_NTH_ASM_T [1,2,4] (MAP_EVERY ante_tac) THEN
	DROP_ASMS_T discard_tac THEN
	cases_tac¨ÓØ 0 º x + ~tÆ THEN
	asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €open_sets_delta_thm›  = save_pop_thm "open_sets_delta_thm";
=TEX
Now we give the topological characterisation of sequence convergence.
%%%%
%%%%
=SML
set_goal([], ¨µs x∑
	(s --> x)
§	(µA∑ A ç OpenSets ± x ç A ¥ ∂n∑µm∑ n º m ¥ s m ç A)Æ);
a(rewrite_tac[lim_seq_def] THEN REPEAT µ_tac THEN §_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[open_sets_delta_thm] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(LIST_GET_NTH_ASM_T [5] all_fc_tac);
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [2,3] bc_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN
	rewrite_tac[open_sets_def, open_interval_def] THEN
	REPEAT strip_tac);
a(swap_nth_asm_concl_tac 2 THEN REPEAT strip_tac);
a(∂_tac ¨{z | x + ~e < z ± z < x + e}Æ THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(∂_tac¨x + ~eÆ THEN ∂_tac¨x + eÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.3" *** *)
a(swap_nth_asm_concl_tac 1 THEN REPEAT strip_tac);
a(∂_tac¨nÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(LIST_DROP_NTH_ASM_T [1,2] (MAP_EVERY ante_tac) THEN
	DROP_ASMS_T discard_tac THEN
	cases_tac¨ÓØ 0 º s m + ~xÆ THEN
	asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €lim_seq_open_sets_thm› = save_pop_thm "lim_seq_open_sets_thm";
=TEX
We now prove the usual topological characterisation of continuity in
terms of open sets. To avoid complications with relative topologies
we just do the case where the function is continuous on the whole line.
%%%%
%%%%
=SML
set_goal([], ¨µf∑
	(µx∑ f CtsAt x)
§	(µA∑ A ç OpenSets ¥ {x | f x ç A} ç OpenSets)
Æ);
a(REPEAT_N 3 strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[cts_at_def, open_sets_delta_thm] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(list_spec_nth_asm_tac 5 [¨tÆ, ¨dÆ]);
a(∂_tac¨d'Æ THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T[2, 4] bc_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[cts_lim_seq_thm, lim_seq_open_sets_thm] THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
a(spec_nth_asm_tac 4 ¨{x | f x ç A}Æ);
a(∂_tac¨nÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val €cts_open_sets_thm› = save_pop_thm"cts_open_sets_thm";
=TEX
The following is used in our proof of the fact that closed intervals are compact:
%%%%
%%%%
=SML
set_goal([], ¨µx y∑ClosedInterval x y ç ClosedSetsÆ);
a(rewrite_tac[
	closed_interval_def, closed_sets_def, open_sets_def, open_interval_def] THEN 
	REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(∂_tac¨t + ~(ÓØ 1)Æ THEN ∂_tac ¨xÆ THEN
	PC_T1 "sets_ext1" REPEAT strip_tac THEN
	REPEAT strip_tac);
a(rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(∂_tac¨yÆ THEN ∂_tac ¨t + ÓØ 1Æ THEN
	PC_T1 "sets_ext1" REPEAT strip_tac
	THEN REPEAT strip_tac);
a(rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €closed_interval_closed_thm› = save_pop_thm"closed_interval_closed_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Derivatives}
%%%%
%%%%
%%%%
%%%%
Following Harrison, we make much use of Carath\'{e}odory's characterisation
of the derivative in terms of the continuity of a certain function:
%%%%
%%%%
=SML
set_goal([], ¨µf c x∑
	(f HasDeriv c) x
§	(∂g∑ (µy∑f y - f x = g(y)*(y - x)) ± g CtsAt x ± g x = c)
Æ);
a(rewrite_tac[has_deriv_def, cts_at_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨Ãz∑ if z = x then c else (f z - f x)/(z - x)Æ
	THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(cases_tac¨y = xÆ THEN asm_rewrite_tac[]);
a(lemma_tac¨≥(y + ~x) = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(rename_tac[(¨xÆ, "x'")] THEN
	ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b∑(a*b)*(y + ~x') = a * (y + ~x') * bÆ]);
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
(* *** Goal "1.2" *** *)
a(all_asm_fc_tac[]);
a(∂_tac¨dÆ THEN REPEAT strip_tac);
a(lemma_tac¨Abs(ÓØ 0) = ÓØ 0Æ THEN1 rewrite_tac[Ø_abs_eq_0_thm]);
a(cases_tac¨y = xÆ THEN1 asm_rewrite_tac[]);
a(ALL_ASM_FC_T asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
a(∂_tac¨dÆ THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
a(lemma_tac¨≥(y + ~x) = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(rename_tac[(¨xÆ, "x'")] THEN
	ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(rewrite_tac[Ø_times_assoc_thm] THEN ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
a(all_var_elim_asm_tac1 THEN DROP_NTH_ASM_T 4 bc_thm_tac THEN REPEAT strip_tac);
val €caratheodory_deriv_thm› = save_pop_thm "caratheodory_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf c x∑ (f HasDeriv c) x ¥ f CtsAt xÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(LEMMA_T ¨f = Ãz∑g z *(z + ~x) + f xÆ once_rewrite_thm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[] THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨x'Æ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT (simple_cts_tac THEN REPEAT strip_tac));
val €has_deriv_cts_thm› = save_pop_thm "has_deriv_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf1 c1 x f2 c2∑
	(f1 HasDeriv c1) x ± (f2 HasDeriv c2) x
¥	((Ãy∑f1 y + f2 y) HasDeriv (c1 + c2)) xÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(rename_tac[(¨gÆ, "g1"), (¨g'Æ, "g2")] THEN
	∂_tac¨Ãz:Ø∑ g1 z + g2 z:ØÆ THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[plus_cts_thm]);
a(once_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
	¨µa b c d:Ø∑ (a + b) + c + d = (a + c) + b + dÆ]);
a(asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €plus_deriv_thm› = save_pop_thm "plus_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf1 c1 x f2 c2∑
	(f1 HasDeriv c1) x ± (f2 HasDeriv c2) x
¥	((Ãy∑f1 y * f2 y) HasDeriv (c1*f2 x + f1 x*c2)) xÆ);
a(REPEAT strip_tac THEN lemma_tac¨f2 CtsAt xÆ 
	THEN1 all_fc_tac[has_deriv_cts_thm]);
a(all_asm_ante_tac THEN
	rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(rename_tac[(¨gÆ, "g1"), (¨g'Æ, "g2")] THEN
	∂_tac¨Ãz:Ø∑ g1 z*f2 z +  f1 x*g2 z:ØÆ THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[pc_rule1"Ø_lin_arith"prove_rule[]
	¨µa b c d:Ø∑a*b + ~(c*d) = (a + ~c)*b + c*(b + ~d)Æ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT (simple_cts_tac THEN REPEAT strip_tac));
val €times_deriv_thm› = save_pop_thm "times_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf1 c1 f2 c2 x∑
	(f1 HasDeriv c1) (f2 x) ± (f2 HasDeriv c2) x
¥	((Ãy∑f1(f2 y)) HasDeriv (c1*c2)) xÆ);
a(REPEAT strip_tac THEN lemma_tac¨f2 CtsAt xÆ 
	THEN1 all_fc_tac[has_deriv_cts_thm]);
a(all_asm_ante_tac THEN
	rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(rename_tac[(¨gÆ, "g1"), (¨g'Æ, "g2")] THEN
	∂_tac¨Ãz:Ø∑ g1(f2 z)*g2 z:ØÆ THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT (simple_cts_tac THEN REPEAT strip_tac));
a(bc_thm_tac comp_cts_thm THEN REPEAT strip_tac);
val €comp_deriv_thm› = save_pop_thm "comp_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µc t∑ ((Ãx∑c) HasDeriv ÓØ 0) tÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(∂_tac¨Ãz∑ÓØ 0Æ THEN rewrite_tac[]);
a(simple_cts_tac);
val €const_deriv_thm› = save_pop_thm "const_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µc t∑ ((Ãx∑x) HasDeriv ÓØ 1) tÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(∂_tac¨Ãz∑ÓØ 1Æ THEN rewrite_tac[]);
a(simple_cts_tac);
val €id_deriv_thm› = save_pop_thm "id_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µn t∑ ((Ãx∑x^(n+1)) HasDeriv (ÓØ n + ÓØ 1)*t^n) tÆ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ);
(* *** Goal "1" *** *)
a(pure_rewrite_tac[Ø_Ó_exp_def] THEN rewrite_tac[id_deriv_thm]);
(* *** Goal "2" *** *)
a(pure_once_rewrite_tac[Ø_Ó_exp_def]);
a(pure_rewrite_tac[prove_rule[]¨
	(Ã x:Ø∑ x * x ^ (n + 1)) = Ã x∑ (Ãx∑x) x * (Ãx∑x ^ (n + 1))xÆ]);
a(LEMMA_T¨
	(ÓØ (n + 1) + ÓØ 1) * t * t ^ n =
	ÓØ 1*(Ãx∑x^(n + 1))t + (Ãx∑x) t*(ÓØ n + ÓØ 1)*t^nÆ
	pure_rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[ÓØ_plus_homomorphism_thm, Ø_Ó_exp_def]);
a(conv_tac(RANDS_C Ø_anf_conv) THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(bc_thm_tac times_deriv_thm);
a(asm_rewrite_tac[id_deriv_thm]);
val €power_deriv_thm› = save_pop_thm "power_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µt∑ ≥t = ÓØ 0 ¥ ($õ-õ1 HasDeriv ~(t õ-õ1 * t õ-õ1)) tÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(∂_tac¨Ãy∑
	if	y = t
	then	~(t õ-õ1 * t õ-õ1)
	else	(y õ-õ1 + ~t õ-õ1)*(y + ~t)õ-õ1Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(cases_tac¨y = tÆ THEN asm_rewrite_tac[Ø_times_assoc_thm]);
a(POP_ASM_T (asm_tac o once_rewrite_rule[Ø_eq_thm]));
a(ALL_FC_T rewrite_tac[Ø_recip_clauses, Ø_minus_recip_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[cts_lim_seq_thm1] THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
a(all_fc_tac[lim_seq_≥_0_thm]);
a(once_rewrite_tac[µ_elim¨nÆ lim_seq_shift_thm] THEN rewrite_tac[]);
a(LEMMA_T ¨µn'∑(s (n + n') õ-õ1 + ~ t õ-õ1) * (s (n + n') + ~ t) õ-õ1
	= ~(s (n + n') õ-õ1 * t õ-õ1)Æ rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(lemma_tac¨≥s (n+n') = ÓØ 0Æ THEN1
	(TOP_ASM_T bc_thm_tac THEN REPEAT strip_tac));
a(lemma_tac¨≥~t = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[Ø_plus_recip_thm]);
a(lemma_tac¨≥s(n+n') + ~ t = ÓØ 0Æ THEN1
	(spec_nth_asm_tac 4 ¨n+n'Æ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b c∑
	(a * b * c) * a õ-õ1= b * c * a * a õ-õ1Æ]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses, Ø_minus_recip_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2.2" *** *)
a(LEMMA_T ¨~ (t õ-õ1 * t õ-õ1) = t õ-õ1 * ~(t õ-õ1) ±
	(Ã n'∑ ~ (s (n + n') õ-õ1 * t õ-õ1)) =
	(Ã n'∑ (Ãm∑ (Ãm'∑s (n + m')) m õ-õ1) n' * (Ãm∑~ (t õ-õ1)) n')Æ
	 pure_rewrite_thm_tac THEN1
	(conv_tac (ONCE_MAP_C Ø_anf_conv) THEN rewrite_tac[]));
a(bc_thm_tac times_lim_seq_thm THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(bc_thm_tac recip_lim_seq_thm THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[lim_seq_shift_thm]);
(* *** Goal "2.2.2" *** *)
a(rewrite_tac[const_lim_seq_thm]);
(* *** Goal "3" *** *)
a(rewrite_tac[]);
val €recip_deriv_thm› = save_pop_thm "recip_deriv_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Some Classical Theorems}
%%%%
%%%%
%%%%
%%%%
First of all we prove the following rather unusual result which works out
nicely in some cases where we would otherwise have to work directly with
suprema. For the want of a better name, we call it the ``curtain
induction principle'' (think of sliding a curtain along the real line starting
from $-\infty$).
%%%%
%%%%
=SML
set_goal([], ¨µp:Ø≠BOOL∑
	(∂x∑p x)
±	(µx∑p x ¥ µy∑y < x ¥ p y)
±	(µx∑∂y z∑ y < x ± x < z ± (p y ¥ p z))
¥	(µx∑p x) 
Æ);
a(contr_tac);
a(lemma_tac¨∂P∑P = {t | p t}Æ THEN1 prove_∂_tac);
a(lemma_tac¨≥P = {} ± ∂c∑µx∑x ç P ¥ x º cÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨x'Æ THEN all_var_elim_asm_tac1 THEN contr_tac);
a(lemma_tac¨x' < x''Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_fc_tac[Ø_sup_thm] THEN fc_tac[Ø_sup_thm]);
a(LIST_DROP_NTH_ASM_T [1,2] fc_tac);
a(spec_nth_asm_tac 8 ¨Sup PÆ);
(* *** Goal "3.1" *** *)
a(swap_nth_asm_concl_tac 3 THEN rewrite_tac[Ø_≥_less_º_thm]);
a(bc_thm_tac Ø_sup_º_bc_thm THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN1 (∂_tac¨cÆ THEN asm_rewrite_tac[]));
a(contr_tac THEN lemma_tac¨y < y'Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(lemma_tac ¨∂w∑Sup P < w ± w < zÆ THEN1
	(bc_thm_tac Ø_less_dense_thm THEN REPEAT strip_tac));
a(lemma_tac¨w º zÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨w ç PÆ THEN1 (asm_rewrite_tac[] THEN all_asm_fc_tac[]));
a(lemma_tac¨w º Sup PÆ THEN1 all_asm_fc_tac[]);
a(PC_T1"Ø_lin_arith" asm_prove_tac[]);
val €curtain_induction_thm› = save_pop_thm "curtain_induction_thm";
=TEX
%%%%
%%%%
=SML
val €curtain_induction_tac› = gen_induction_tac curtain_induction_thm;
=IGN
set_goal([], ¨µx:Ø∑∂y∑x º yÆ);
a(strip_tac);
a(curtain_induction_tac¨xÆ);
(* *** Goal "1" *** *)
a(∂_tac ¨xÆ THEN ∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN ∂_tac¨yÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨x + ~(1/2)Æ THEN ∂_tac¨x + (1/2)Æ THEN REPEAT strip_tac);
a(∂_tac¨y'+3/2Æ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val test10 = pop_thm();
=TEX
Bolzano's principle of bisection, via a lemma which contains most
of the argument:
%%%%
%%%%
=SML
set_goal([], ¨µp∑
	(µx y∑y < x ¥ p x y)
±	(µx y z∑ x º y ± y º z ± p x y ± p y z ¥ p x z)
±	(µy∑∂d∑ ÓØ 0 < d ± (µx z∑  x º y ± y º z ± z - x < d ¥ p x z))
¥	(µx y∑p x y)
Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨µt∑t º y ¥ p x tÆ (strip_asm_tac o µ_elim¨yÆ));
a(lemma_tac¨µc∑p c cÆ THEN1
	(REPEAT strip_tac THEN
	POP_ASM_T (strip_asm_tac o µ_elim¨c:ØÆ) THEN
	POP_ASM_T bc_thm_tac THEN asm_rewrite_tac[]));
a(curtain_induction_tac¨y:ØÆ);
(* *** Goal "1" *** *)
a(∂_tac¨x + ~(ÓØ 1)Æ THEN REPEAT strip_tac);
a(lemma_tac¨t < xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(GET_NTH_ASM_T 3 bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(cases_tac¨y' < xÆ);
(* *** Goal "3.1" *** *)
a(∂_tac¨y' + ~(ÓØ 1)Æ THEN ∂_tac¨xÆ THEN REPEAT strip_tac);
a(cases_tac¨t < xÆ THEN1 all_asm_fc_tac[]);
a(lemma_tac¨t = xÆ THEN_LIST[PC_T1"Ø_lin_arith"asm_prove_tac[], all_var_elim_asm_tac1]);
a(asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(cases_tac¨≥µb∑b < y' ¥ p x bÆ);
(* *** Goal "3.2.1" *** *)
a(∂_tac¨bÆ THEN ∂_tac¨y' + ÓØ 1Æ THEN REPEAT strip_tac);
a(spec_nth_asm_tac 2 ¨bÆ);
(* *** Goal "3.2.2" *** *)
a(spec_nth_asm_tac 4 ¨y'Æ);
a(∂_tac¨y' + ~(1/3*d)Æ THEN ∂_tac¨y' + 1/3*dÆ THEN REPEAT strip_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(cases_tac¨t < y'Æ THEN1 all_asm_fc_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(lemma_tac¨∂a∑x º a ± a º y' ± y' - a º 1/3*d ± p x aÆ);
(* *** Goal "3.2.2.1" *** *)
a(cases_tac¨x º y' + ~(1/3*d)Æ);
(* *** Goal "3.2.2.1.1" *** *)
a(∂_tac¨y' + ~(1/3*d)Æ THEN REPEAT strip_tac THEN_TRY
	PC_T1"Ø_lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 7 ¨y' + ~(1/3*d)Æ);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.2.1.2" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[]);
(* *** Goal "3.2.2.2" *** *)
a(GET_NTH_ASM_T 14 bc_thm_tac);
a(∂_tac¨aÆ THEN REPEAT strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(GET_NTH_ASM_T 8 bc_thm_tac THEN REPEAT strip_tac);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €bisection_lemma› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µp∑
	(µx y z∑ x º y ± y º z ± p x y ± p y z ¥ p x z)
±	(µy∑∂d∑ ÓØ 0 < d ± (µx z∑  x º y ± y º z ± z - x < d ¥ p x z))
¥	(µa b∑ a º b ¥ p a b)
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µa b∑(Ã x y∑if x º y then p x y else T)a bÆ THEN1
	(bc_thm_tac bisection_lemma THEN rewrite_tac[] THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" (= 3, 4, and 5) *** *)
a(all_asm_fc_tac[]);
(* *** Goal "6" *** *)
a(spec_nth_asm_tac 2 ¨yÆ);
a(∂_tac¨dÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[]));
a(all_asm_fc_tac[]);
(* *** Goal "7" *** *)
a(POP_ASM_T (ante_tac o list_µ_elim[¨aÆ, ¨bÆ]) THEN asm_rewrite_tac[]);
val €bisection_thm› = save_pop_thm"bisection_thm";
=TEX
One half of the Heine-Borel theorem says that every closed interval is compact;
i.e., every covering of the closed interval by a family
of open sets has a finite subcovering.
Nearly all the analysis is in the following lemma, which deals with
the case where the covering actually covers the whole real line:
%%%%
%%%%
=SML
set_goal([], ¨µV x y∑
	V Ä OpenSets
±	(µz∑ z ç ﬁV)
¥	∂W∑ W Ä V ± W ç Finite ± ClosedInterval x y Ä ﬁ WÆ);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(curtain_induction_tac¨y:ØÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨x + ~(ÓØ 1)Æ THEN REPEAT strip_tac);
a(∂_tac¨{}Æ THEN PC_T1 "sets_ext1" rewrite_tac[empty_finite_thm, closed_interval_def]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext1" (spec_nth_asm_tac 1) ¨zÆ THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨ClosedInterval x y Ä ClosedInterval x y'Æ THEN1
	(rewrite_tac[closed_interval_def] THEN
	PC_T1 "sets_ext1" REPEAT strip_tac THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(all_fc_tac[
	pc_rule1 "sets_ext1" prove_rule[]¨µA B C∑A Ä B ± B Ä C ¥ A Ä CÆ]);
a(∂_tac¨WÆ THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(PC_T1 "'propositions" cases_tac¨≥(µ z∑ z ç ﬁ V)Æ THEN asm_rewrite_tac[]);
(* *** Goal "4.1" *** *)
a(∂_tac¨y' + ~(ÓØ 1)Æ THEN ∂_tac¨y' + ÓØ 1Æ THEN REPEAT strip_tac);
(* *** Goal "4.2" *** *)
a(POP_ASM_T (strip_asm_tac o µ_elim¨y'Æ o pc_rule1 "sets_ext1" rewrite_rule[]));
a(DROP_NTH_ASM_T 3 ante_tac THEN
	rewrite_tac[open_sets_def, open_interval_def] THEN
	PC_T1 "sets_ext" REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_fc_tac[Ø_less_dense_thm]);
a(∂_tac¨z'Æ THEN ∂_tac¨zÆ THEN REPEAT strip_tac);
a(∂_tac¨{s} ¿ WÆ THEN ALL_FC_T rewrite_tac[singleton_¿_finite_thm]);
a(rewrite_tac[closed_interval_def] THEN REPEAT strip_tac);
(* *** Goal "4.2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac THEN1 all_var_elim_asm_tac1);
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
(* *** Goal "4.2.2" *** *)
a(GET_NTH_ASM_T 8 ante_tac THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (strip_asm_tac o pc_rule1 "sets_ext1" rewrite_rule[closed_interval_def]));
a(cases_tac¨x' < x''Æ);
(* *** Goal "4.2.2.1" *** *)
a(∂_tac ¨sÆ THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 5 bc_thm_tac THEN
	REPEAT strip_tac THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "4.2.2.2" *** *)
a(lemma_tac¨x'' º z'Æ  THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T [3] all_fc_tac);
a(∂_tac ¨s'Æ THEN REPEAT strip_tac);
val €heine_borel_lemma› = pop_thm();
=TEX
The theorem follows from the lemma by a simple
argument showing that, w.l.o.g., we may assume that the open covering
of the closed interval is actually an open covering of the whole real line
(because one can throw in the complement of the interval first and then
afterwards discard it from the finite subcovering).
%%%%
%%%%
=SML
set_goal([], ¨µx y∑ ClosedInterval x y ç CompactSetsÆ);
a(rewrite_tac[compact_sets_def] THEN REPEAT strip_tac);
a(lemma_tac¨{~(ClosedInterval x y)} ¿ V Ä OpenSets
	± (µz∑ z ç ﬁ({~(ClosedInterval x y)} ¿ V))Æ THEN
	REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac(pc_rule1 "sets_ext1" prove_rule[]
	¨µx A B∑ x ç B ± A Ä B ¥ {x} ¿ A Ä BÆ) THEN REPEAT strip_tac);
a(rewrite_tac[rewrite_rule[closed_sets_def] closed_interval_closed_thm]);
(* *** Goal "2" *** *)
a(cases_tac¨≥z ç ClosedInterval x yÆ THEN1
	(∂_tac¨~(ClosedInterval x y)Æ THEN PC_T1 "sets_ext1" asm_rewrite_tac[]
	THEN asm_rewrite_tac[]));
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µA B∑z ç A ± A Ä B ¥ z ç BÆ]);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(all_fc_tac[heine_borel_lemma]);
a(∂_tac¨W \ {~(ClosedInterval x y)}Æ THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN
	all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µA B∑x' ç A ± A Ä B ¥ x' ç BÆ] THEN
	all_var_elim_asm_tac1);
(* *** Goal "3.2" *** *)
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨WÆ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "3.3" *** *)
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(∂_tac¨sÆ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(∂_tac¨x'Æ THEN asm_rewrite_tac[]);
val €closed_interval_compact_thm› = save_pop_thm "closed_interval_compact_thm";
=TEX
The next classical result is that a function continuous on a closed
attains is bounded and, indeed, attains its upper bound.
We do the special case where the function is continuous everywhere
as a lemma first. However, we do the special case in the more general
context of a function on an arbitrary compact set.
%%%%
%%%%
=SML
set_goal([], ¨µX f∑
	≥X = {}
±	X ç CompactSets
±	(µx∑ f CtsAt x)
¥	∂x∑ x ç X ± µz∑z ç X ¥ f z º f xÆ);
a(contr_tac);
a(lemma_tac¨{A | ∂x∑ x ç X ± A = {z | f z < f x}} Ä OpenSetsÆ);
(* *** Goal "1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(lemma_tac¨{y | y < f x'} ç OpenSetsÆ);
(* *** Goal "1.1" *** *)
a(rewrite_tac[open_sets_def, open_interval_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_fc_tac[Ø_less_dense_thm]);
a(∂_tac¨t + ~(ÓØ 1)Æ THEN ∂_tac¨zÆ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(all_var_elim_asm_tac1 THEN fc_tac[cts_open_sets_thm]);
a(LEMMA_T ¨{z | f z < f x'} = {z | f z ç {y | y < f x'}}Æ pure_rewrite_thm_tac THEN1
	rewrite_tac[]);
a(POP_ASM_T bc_thm_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨X Ä ﬁ{A | ∂x∑ x ç X ± A = {z | f z < f x}}Æ);
(* *** Goal "2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨xÆ);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(∂_tac¨{a | f a < f z}Æ THEN asm_rewrite_tac[]);
a(∂_tac¨zÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 5 (fn th => all_fc_tac[rewrite_rule[compact_sets_def]th]));
a(lemma_tac¨µA B∑ A ç W ± B ç W ¥ A Ä B ≤ B Ä AÆ);
(* *** Goal "2.2.1" *** *)
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(lemma_tac¨A ç {A | ∂x∑ x ç X ± A = {z | f z < f x}} ±
	B ç {A | ∂x∑ x ç X ± A = {z | f z < f x}}Æ THEN1
	(ALL_FC_T rewrite_tac[pc_rule1 "sets_ext1" prove_rule[]
		¨µ x y X Y∑ x ç X ± X Ä Y ¥ x ç YÆ]));
a(all_var_elim_asm_tac1);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2.2" *** *)
a(lemma_tac¨≥W = {}Æ);
(* *** Goal "2.2.2.1" *** *)
a(swap_nth_asm_concl_tac 2 THEN all_var_elim_asm_tac1);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(DROP_NTH_ASM_T 7 (PC_T1 "sets_ext" strip_asm_tac));
a(∂_tac¨xÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(all_fc_tac[finite_chain_thm]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]
		¨µ x y X Y∑ x ç X ± X Ä Y ¥ x ç YÆ]);
a(swap_nth_asm_concl_tac 7 THEN asm_rewrite_tac[]);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(∂_tac¨xÆ THEN asm_rewrite_tac[]);
val €cts_compact_bounded_thm› = save_pop_thm"cts_compact_bounded_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf a b∑
	a º b
±	(µx∑ f CtsAt x)
¥	∂x∑ a º x ± x º b ± µz∑a º z ± z º b ¥ f z º f xÆ);
a(REPEAT strip_tac);
a(lemma_tac¨≥ClosedInterval a b = {} ± ClosedInterval a b ç CompactSetsÆ THEN1
	(rewrite_tac[closed_interval_compact_thm] THEN
	rewrite_tac[closed_interval_def] THEN
	PC_T1 "sets_ext1" REPEAT strip_tac THEN
	∂_tac¨aÆ THEN REPEAT strip_tac));
a(all_fc_tac[cts_compact_bounded_thm]);
a(∂_tac ¨xÆ THEN POP_ASM_T ante_tac THEN POP_ASM_T ante_tac);
a(rewrite_tac[closed_interval_def] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
val €cts_bounded_lemma› = pop_thm();
=TEX
Now the general result on the boundedness of a function continuous on
some closed interval:
%%%%
%%%%
=SML
set_goal([], ¨µf a b∑
	a º b
±	(µx∑ a º x ± x º b ¥ f CtsAt x)
¥	∂x∑ a º x ± x º b ± µz∑ a º z ± z º b ¥ f z º f xÆ);
a(REPEAT strip_tac);
a(cases_tac¨a = bÆ THEN1 all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(∂_tac¨bÆ THEN REPEAT strip_tac THEN
	LEMMA_T ¨z = bÆ rewrite_thm_tac THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac ¨a < bÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_fc_tac[conv_rule (ONCE_MAP_C eq_sym_conv) cts_extension_thm]);
a(all_fc_tac[cts_bounded_lemma]);
a(∂_tac¨xÆ THEN REPEAT strip_tac THEN ALL_ASM_FC_T rewrite_tac[]);
val €cts_bounded_thm› = save_pop_thm "cts_bounded_thm";
=TEX
The next classical result will be the intermediate value theorem.
As so often, a lemma containing the main part of the argument comes first.
We follow many authors in doing the case where the intermediate value is $0$
first to simplify the absolute value reasoning and we restrict to the case
where the function is negative towards the left of the interval and positive
towards the right. The proof is by bisection.
%%%%
%%%%
=SML
set_goal([], ¨µf∑
	(µx∑ f CtsAt x)
¥	µa b∑ a º b ¥ f a < ÓØ 0 ± ÓØ 0 < f b ¥ ∂x∑a º x ± x º b ± f x = ÓØ 0Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(bc_thm_tac (rewrite_rule[]
	(µ_elim¨Ãa b∑f a < ÓØ 0 ± ÓØ 0 < f b ¥ ∂x∑a º x ± x º b ± f x = ÓØ 0Æ
	bisection_thm)));
a(REPEAT strip_tac THEN_TRY SOLVED_T
	(contr_tac THEN all_asm_fc_tac[Ø_º_trans_thm] THEN all_asm_fc_tac[]));
(* *** Goal "1" *** *)
a(lemma_tac¨f y = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(cases_tac¨f y = ÓØ 0Æ THEN1
	(∂_tac¨ÓØ 1Æ THEN contr_tac THEN all_asm_fc_tac[]));
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[cts_at_def] o µ_elim¨yÆ));
a(lemma_tac ¨ÓØ 0 < (1/3)*Abs (f y)Æ THEN1
	(lemma_tac ¨≥Abs (f y) = ÓØ 0Æ THEN1
	asm_rewrite_tac[Ø_abs_eq_0_thm] THEN
	strip_asm_tac(µ_elim¨f yÆØ_0_º_abs_thm) THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(all_asm_fc_tac[]);
a(∂_tac¨dÆ THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 º ~(x + ~y) ± ÓØ 0 º z + ~yÆ THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨Abs(~(x + ~y)) < d ± Abs(z + ~y) < dÆ ante_tac THEN1
	(asm_rewrite_tac[Ø_abs_def] THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(rewrite_tac[Ø_abs_minus_thm] THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [10] all_fc_tac);
a(LIST_DROP_NTH_ASM_T [1, 2, 7, 8, 14] (MAP_EVERY ante_tac) THEN
	DROP_ASMS_T discard_tac THEN
	MAP_EVERY cases_tac
		[¨ÓØ 0 º f z + ~(f y)Æ, ¨ÓØ 0 º f x + ~(f y)Æ, ¨ÓØ 0 º f yÆ] THEN
	asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €intermediate_value_lemma› = pop_thm();
=TEX
With the lemma, we can prove the intermediate value theorem proper.
There is a small amount of doubt about what the exact statement should be.
We interpret the weasel word ``between'' which occurs in so many textbook
accounts as meaning ``strictly between''. (The more general formulation with
non-strict inequalities is only vacuously more general --- it just gives
one the trivial cases where the interval consists of a point or where the
intermediate value is achieved at one of the end-points; and, of course,
the statement is vacuously true if the interval is empty).
%%%%
%%%%
=SML
set_goal([], ¨µf a b∑
	a < b
±	(µx∑a º x ± x º b ¥ f CtsAt x)
¥	(µy∑(f a < y ± y < f b ≤ f b < y ± y < f a) ¥ ∂x∑ a < x ± x < b ± f x = y)Æ);
a(lemma_tac¨µf a b∑
	a < b
±	(µx∑a º x ± x º b ¥ f CtsAt x)
¥	(µy∑(f a < y ± y < f b) ¥ ∂x∑ a < x ± x < b ± f x = y)Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µx∑a º x ± x º b ¥ (Ãz∑f z + ~y) CtsAt xÆ THEN1
	(REPEAT (simple_cts_tac ORELSE strip_tac) THEN ALL_ASM_FC_T rewrite_tac[]));
a(DROP_NTH_ASM_T 4 discard_tac);
a(all_fc_tac[conv_rule (ONCE_MAP_C eq_sym_conv) cts_extension_thm]);
a(LEMMA_T¨(Ãz∑f z + ~y) a < ÓØ 0 ± ÓØ 0 < (Ãz∑f z + ~y) bÆ ante_tac THEN1
	(rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac ¨a º bÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 3 ¨aÆ THEN POP_ASM_T pure_rewrite_thm_tac);
a(spec_nth_asm_tac 3 ¨bÆ THEN POP_ASM_T rewrite_thm_tac THEN REPEAT strip_tac);
a(all_fc_tac[intermediate_value_lemma]);
a(lemma_tac¨≥x = a ± ≥x = bÆ THEN1
	(contr_tac THEN all_var_elim_asm_tac1 THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨a < x ± x < bÆ THEN1
	(PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(∂_tac ¨xÆ THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [12] (ALL_FC_T (MAP_EVERY ante_tac)));
a(asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN1 (contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]));
a(lemma_tac¨µ x∑ a º x ± x º b ¥ (Ãx∑ ~(f x)) CtsAt xÆ THEN1
	(REPEAT (simple_cts_tac ORELSE strip_tac) THEN ALL_ASM_FC_T rewrite_tac[]));
a(lemma_tac¨ (Ãx∑ ~(f x)) a < ~y ± ~y < (Ãx∑ ~(f x)) bÆ THEN1
	(rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(all_asm_fc_tac[]);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €intermediate_value_thm› = save_pop_thm"intermediate_value_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Uniform Convergence}
%%%%
%%%%
%%%%
%%%%
We now prove some basic facts about limits of locally uniformly convergent
sequences of functions.
N.b., the definition on which these facts depend is a tentative one, and
this section should be considered experimental.

Firstly, constant sequences have limits:
%%%%
%%%%
=SML
set_goal([], ¨µh x∑((Ãm∑ h) ---> h) xÆ);
a(REPEAT strip_tac THEN rewrite_tac[unif_lim_seq_def]);
a(∂_tac¨ÓØ 1Æ THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
val €const_unif_lim_seq_thm› = save_pop_thm "const_unif_lim_seq_thm";
=TEX
Secondly, if two locally uniformly convergent
sequences of functions each have a limit, then so does their
sum and its limit is the sum of the limits.
Thee proof is a cut-and-paste generalisation of the analogous proof
for the limit of sequences of numbers.
%%%%
%%%%
=SML
set_goal([], ¨µu1 h1 x u2 h2∑
	(u1 ---> h1) x
±	(u2 ---> h2) x
¥	((Ãm y∑u1 m y + u2 m y) ---> (Ãy∑h1 y + h2 y)) xÆ);
a(rewrite_tac[unif_lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac¨∂b1∑ÓØ 0 < b1 ± b1 < b ± b1 < b'Æ THEN1 (
	∂_tac¨if b < b' then b / ÓØ 2 else b' / ÓØ 2Æ THEN
	cases_tac¨b < b'Æ THEN asm_rewrite_tac[] THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(∂_tac¨b1Æ THEN REPEAT strip_tac);
a(lemma_tac ¨ÓØ 0 < e / ÓØ 2 Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 8 ¨e / ÓØ 2Æ THEN spec_nth_asm_tac 7  ¨e / ÓØ 2Æ);
a(∂_tac¨n + n'Æ THEN REPEAT strip_tac);
a(lemma_tac¨n º m ± n' º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(lemma_tac¨Abs (y + ~ x) < b ± Abs (y + ~ x) < b'Æ THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T [7, 8] all_fc_tac);
a(LEMMA_T ¨
	(u1 m y + u2 m y) + ~(h1 y) + ~(h2 y) =
	(u1 m y + ~(h1 y)) + (u2 m y + ~(h2 y))Æ
	rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(bc_thm_tac Ø_º_less_trans_thm);
a(∂_tac¨Abs (u1 m y + ~ (h1 y)) + Abs (u2 m y + ~(h2 y))Æ THEN rewrite_tac[Ø_abs_plus_thm]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €plus_unif_lim_seq_thm› = save_pop_thm "plus_unif_lim_seq_thm";
=TEX
One might now want to give the analogous result on the product of two sequences
of functions with uniform limits. However, this is false in general. For the purposes
we have in mind, it is sufficient to consider the product of a sequence of
functions and a given fixed function which is bounded in some neighbourhood of
the point of interest:

%%%%
%%%%
=SML
set_goal([], ¨µu h x f∑
	(u ---> h) x
±	(∂d c∑ÓØ 0 < d ± ÓØ 0 < c ± µy∑Abs(y - x) < d ¥ Abs(f y) < c)
¥	((Ãm y∑u m y*f y) ---> (Ãy∑h y*f y)) xÆ);
a(rewrite_tac[unif_lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac¨∂b1∑ÓØ 0 < b1 ± b1 < b ± b1 < dÆ THEN1 (
	∂_tac¨if b < d then b / ÓØ 2 else d / ÓØ 2Æ THEN
	cases_tac¨b < dÆ THEN asm_rewrite_tac[] THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(∂_tac ¨b1Æ THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < e * c õ-õ1Æ THEN1 
	(bc_thm_tac Ø_0_less_0_less_times_thm THEN
	REPEAT strip_tac THEN bc_thm_tac Ø_0_less_0_less_recip_thm THEN REPEAT strip_tac));
a(spec_nth_asm_tac 9 ¨e * c õ-õ1Æ);
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µA B∑A*f y + ~(B * f y) = (A + ~B)*f yÆ,
	Ø_abs_times_thm]);
a(lemma_tac¨Abs (y + ~ x) < b ± Abs (y + ~ x) < dÆ THEN1 
	(LIST_GET_NTH_ASM_T [1, 6, 7] (MAP_EVERY ante_tac) THEN
	PC_T1 "Ø_lin_arith" prove_tac[]));
a(LIST_GET_NTH_ASM_T [5, 11] all_fc_tac);
a(lemma_tac¨≥ c = ÓØ 0Æ THEN1 (contr_tac THEN all_var_elim_asm_tac1));
a(LEMMA_T¨e = (e * c õ-õ1) * cÆ once_rewrite_thm_tac THEN1
	(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µA B C:Ø∑(A*B)*C = A*C*BÆ] THEN
	ALL_FC_T rewrite_tac[Ø_times_recip_thm]));
a(bc_thm_tac Ø_abs_less_times_thm THEN REPEAT strip_tac);
val €times_unif_lim_seq_thm› = save_pop_thm "times_unif_lim_seq_thm";
=TEX
Now the main result of this section: if a sequence
of functions, all continuous at some point $x$, is locally uniformly convergent
at $x$, then the limit function is continuous at $x$.
We prove a little lemma first:
%%%%
%%%%
=SML
set_goal([], ¨µa b c d:Ø∑Abs(a - d) º Abs(a - b) + Abs(b - c) + Abs(c - d)Æ);
a(REPEAT strip_tac);
a(lemma_tac¨Abs(b - d) º Abs(b - c) + Abs(c - d)Æ THEN1
	(pure_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
		¨b - d = (b - c) + (c - d)Æ, Ø_abs_plus_thm]));
a(lemma_tac¨Abs(a - d) º Abs(a - b) + Abs(b - d)Æ THEN1
	(pure_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
		¨a - d = (a - b) + (b - d)Æ, Ø_abs_plus_thm]));
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_abs_abcd_thm› = pop_thm ();
=TEX
Now we prove the main result on the continuity of limits of sequences of
functions. We use
the $\epsilon$-$\delta$ definition of continuity directly --- to use
the alternative characterisation in terms of sequences involves too
many subscripts for comfort!
%%%%
%%%%
=SML
set_goal([], ¨µu h x∑
	(u ---> h) x ± (µm∑u m CtsAt x) ¥ h CtsAt xÆ);
a(rewrite_tac[cts_at_def, unif_lim_seq_def, lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < (1/3)*eÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 4 ¨(1/3)*eÆ);
a(SPEC_NTH_ASM_T 1 ¨nÆ ante_tac THEN rewrite_tac[] THEN REPEAT strip_tac);
a(list_spec_nth_asm_tac 5 [¨nÆ, ¨(1/3)*eÆ]);
a(lemma_tac¨∂b1∑ÓØ 0 < b1 ± b1 < b ± b1 < dÆ THEN1 (
	∂_tac¨if b < d then b / ÓØ 2 else d / ÓØ 2Æ THEN
	cases_tac¨b < dÆ THEN asm_rewrite_tac[] THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(∂_tac¨b1Æ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac ¨
	Abs(h y - u n y) + Abs(u n y - u n x) + Abs(u n x - h x)Æ
	THEN rewrite_tac[rewrite_rule[]Ø_abs_abcd_thm] THEN REPEAT strip_tac);
a(lemma_tac ¨Abs(h y + ~(u n y)) < (1/3)*e
	± Abs(u n y + ~(u n x)) < (1/3)*e
	± Abs(u n x + ~(h x)) < (1/3)*eÆ
	THEN_LIST [id_tac, PC_T1 "Ø_lin_arith" asm_prove_tac[]]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(pure_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µz∑h y + ~z = ~(z + ~(h y))Æ,
	Ø_abs_minus_thm]);
a(GET_NTH_ASM_T 7 bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(GET_NTH_ASM_T 5 bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(GET_NTH_ASM_T 7 bc_thm_tac THEN rewrite_tac[Ø_abs_0_thm] THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €unif_lim_seq_cts_thm› = save_pop_thm "unif_lim_seq_cts_thm";
=TEX
%%%%
%%%%
=SML
(*
set_goal([], ¨µu h x s∑
	(u ---> h) x ± (µm∑(u m HasDeriv s m) x) ¥
	(∂d∑ s --> d ± (h HasDeriv d) x)Æ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o conv_rule simple_µ_∂_conv));

val €unif_lim_seq_deriv_thm› = save_pop_thm "unif_lim_seq_deriv_thm";
*)
=TEX
\subsection{Uncountabiliy of the Reals}
We prove Cantor's thorem that the reals are uncountable and develop some useful
facts about sequences and nested intervals {\it en route}.
The first two facts about sequences just give the obvious one-step criteria for a sequence
to be monotone increasing or decreasing.
=SML
set_goal([], ¨µf : Ó ≠ Ø∑ (µm∑f m º f (m+1)) ¥ (µm n∑f m º f(m + n))Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ THEN1 rewrite_tac[]);
a(bc_thm_tac Ø_º_trans_thm);
a(∂_tac¨f(m+n)Æ THEN  REPEAT strip_tac);
a(once_rewrite_tac[plus_assoc_thm1] THEN asm_rewrite_tac[]);
val €Ø_mono_inc_seq_thm› = save_pop_thm "Ø_mono_inc_seq_thm";
=TEX
=SML
set_goal([], ¨µf : Ó ≠ Ø∑ (µm∑f(m+1) º f m) ¥ (µm n∑ f(m+n) º f m)Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ THEN1 rewrite_tac[]);
a(bc_thm_tac Ø_º_trans_thm);
a(∂_tac¨f (m+n)Æ THEN  REPEAT strip_tac);
a(once_rewrite_tac[plus_assoc_thm1] THEN asm_rewrite_tac[]);
val Ø_mono_dec_seq_thm = save_pop_thm "Ø_mono_dec_seq_thm";
=TEX
We now want to investigate the ordering relations that hold between the lower and upper
bounds of  a sequence of nested closed intervals.
In the applications, it is easier to work with sequences of lower and upper bounds rather
than the sequences of intervals themselves, and so we do this, while making the names of the
theorems reflect their intended purpose.
We first of all want to prove that no lower bound is greater than any upper bound. We do
the two parts of this assertion as lemmas first:
=SML
set_goal([], ¨µL U: Ó ≠ Ø∑
	(µm∑L m º L (m+1) ± U (m+1) º U m ± L m º U m)
¥	(µm n∑L m º U (m+n))Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µm∑L m º L(m+1)Æ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[Ø_mono_inc_seq_thm]);
a(bc_thm_tac Ø_º_trans_thm THEN ∂_tac¨L(m+n)Æ THEN asm_rewrite_tac[]);
val nested_interval_lemma1 = pop_thm();
=TEX
=SML
set_goal([], ¨µL U : Ó ≠ Ø∑
	(µm∑L m º L (m+1) ± U (m+1) º U m ± L m º U m)
¥	(µm n∑L (m+n) º U m)Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µm∑U (m+1) º U mÆ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[Ø_mono_dec_seq_thm]);
a(bc_thm_tac Ø_º_trans_thm THEN ∂_tac¨U(m+n)Æ THEN asm_rewrite_tac[]);
val nested_interval_lemma2 = pop_thm();
=TEX
The two parts now fit together to give the theorem that no lower bound of a sequence
of nested intervals is greater than any upper bound.
=SML
set_goal([], ¨µL U : Ó ≠ Ø∑
	(µm∑L m º L (m+1) ± U (m+1) º U m ± L m º U m)
¥	(µm n∑L m º U n)Æ);
a(REPEAT strip_tac THEN LEMMA_T ¨m:Ó º n ≤ n º mÆ ante_tac THEN1
	rewrite_tac[º_cases_thm]);
a(rewrite_tac[º_def] THEN REPEAT strip_tac THEN all_var_elim_asm_tac1 THEN
	ALL_FC_T rewrite_tac [nested_interval_lemma1, nested_interval_lemma2]);
val €nested_interval_bounds_thm› = save_pop_thm "nested_interval_bounds_thm";
=TEX
We can now prove Cantor's theorem that the reals are uncountable given two more
rather specific lemmas. The first of these lemmas says that given a closed interval containing
more than one point and any real number, there is a sub-interval, also containing more than
one point, that does not contain the given number.
=SML
set_goal([], ¨µa b x : Ø∑
	a < b
¥	(∂c d∑ a º c ± c < d ± d º b ± (x < c ≤ d < x))Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂u∑a < u ± u < bÆ THEN1
	(all_fc_tac [Ø_less_dense_thm] THEN contr_tac THEN all_asm_fc_tac[]));
a(lemma_tac¨∂v∑u < v ± v < bÆ THEN1
	(all_fc_tac [Ø_less_dense_thm] THEN contr_tac THEN all_asm_fc_tac[]));
a(cases_tac¨x º uÆ THEN1
	(∂_tac¨vÆ THEN ∂_tac¨bÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(∂_tac¨aÆ THEN ∂_tac¨uÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €cantor_lemma1› = pop_thm();
=TEX
The second lemma simply makes the previous one easier to use to define the sequences
of lower and upper bounds of a sequence of nested closed intervals whose intersection
will miss a given attempt to enumerate the reals.
=SML
set_goal([], ¨∂f g: Ø ≠ Ø ≠ Ø ≠ Ø∑ µx a b∑
	a < b
¥	a º f x a b ± g x a b º b ± f x a b < g x a b ± (x < f x a b ≤ g x a b < x)Æ);
a(prove_∂_tac THEN REPEAT strip_tac);
a(cases_tac¨≥a'' < b''Æ THEN asm_rewrite_tac[]);
a(all_fc_tac[cantor_lemma1] THEN (POP_ASM_T (strip_asm_tac o µ_elim ¨x''Æ))
	THEN ∂_tac¨dÆ THEN ∂_tac¨cÆ THEN REPEAT strip_tac);
val €cantor_lemma2› = pop_thm();
=TEX
Now the main part of the proof of Cantor's theorem: if a sequence $X_m$ of real numbers is given,
we can find a sequence of closed intervals $[L_m, U_m]$, such that $X_m \not\in [L_m, U_m]$.
=SML
set_goal([], ¨µX : Ó ≠ Ø∑ ∂L U: Ó ≠ Ø∑µm∑
	L m º L (m+1)
±	U (m+1) º U m
±	L m < U  m
±	(X m < L m ≤ U m< X m)Æ);
a(REPEAT strip_tac);
a(lemma_tac¨ ∂L U: Ó ≠ Ø∑
	L 0 < U 0
±	µm∑L m < U m 
	¥	L m º L (m+1)
	±	U (m+1) º U m
	±	L (m+1) < U  (m+1)
	±	(X m < L (m+1) ≤ U (m+1) < X m)Æ);
(* *** Goal "1" *** *)
a(lemma_tac¨∂a b:Ø∑ a < bÆ THEN1 (∂_tac¨ÓØ 0Æ THEN ∂_tac¨ÓØ 1Æ THEN REPEAT strip_tac));
a(strip_asm_tac cantor_lemma2);
a(lemma_tac¨∂h : Ó ≠ Ø ∏ Ø∑
	h 0 = (a, b)
±	µm∑ h(m + 1) = (f (X m) (Fst(h m)) (Snd(h m)), g (X m) (Fst(h m)) (Snd(h m)))
Æ THEN1 prove_∂_tac);
a(∂_tac¨Ãm∑Fst (h m)Æ THEN ∂_tac ¨Ãm∑Snd (h m)Æ THEN strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨µm∑L m < U mÆ THEN1
	(strip_tac THEN induction_tac¨m:ÓÆ THEN
	REPEAT strip_tac THEN all_asm_fc_tac[]));
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨Ãm∑L(m+1)Æ THEN ∂_tac ¨Ãm∑U(m+1)Æ THEN asm_rewrite_tac[]);
val €nested_interval_diag_thm› = save_pop_thm"nested_interval_diag_thm";
=TEX
Now we show that any sequence of nested closed intervals has non-empty intersection:
=SML
set_goal([], ¨µL U: Ó ≠ Ø∑
	(µm∑L m º L (m+1) ± U (m+1) º U m ± L m º U m)
¥	(∂x∑µm∑L m º x ± x ºU m)Æ);
a(REPEAT strip_tac);
a(LEMMA_T ¨
	≥ {x|∂ m∑ x = L m} = {}
±	(∂ a∑ µ x∑ x ç {x|∂ m∑ x = L m} ¥ x º a)Æ (±_THEN asm_tac));
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext" prove_tac[]);
a(∂_tac¨U kÆ THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(all_fc_tac[nested_interval_bounds_thm] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨Sup{x|∂ m∑ x = L m}Æ THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac Ø_º_sup_bc_thm THEN asm_rewrite_tac[]);
a(prove_tac[]);
(* *** Goal "2.2" *** *)
a(bc_thm_tac Ø_sup_º_bc_thm THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(all_fc_tac[nested_interval_bounds_thm] THEN asm_rewrite_tac[]);
val €nested_interval_intersection_thm› = save_pop_thm"nested_interval_intersection_thm";
=TEX
Putting the last two theorems together gives us Cantor's theorem:
=SML
set_goal([], ¨µX: Ó ≠ Ø∑ ∂x∑µm∑≥x = X mÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨XÆ nested_interval_diag_thm));
a(lemma_tac¨∂x∑µm∑L m º x ± x ºU mÆ THEN1
	(bc_thm_tac nested_interval_intersection_thm THEN asm_rewrite_tac[]
	THEN asm_rewrite_tac[Ø_º_def]));
a(∂_tac¨xÆ THEN contr_tac THEN all_var_elim_asm_tac1);
a(spec_nth_asm_tac 1 ¨mÆ);
a(spec_nth_asm_tac 4 ¨mÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_uncountable_thm ›= list_save_thm(["Ø_uncountable_thm", "cantor_Ø_thm"], pop_thm());
=TEX
\subsection{More Topology}
We now develop some more topological results.
First of all we prove the standard facts about unions and intersections of open and closed sets
(which comprise the axioms for same in abstract topology).
These facts depend in turn on simpler facts about open and closed intervals:
=TEX
=SML
set_goal([], ¨µx1 y1 x2 y2∑∂x y∑ OpenInterval x1 y1 ° OpenInterval x2 y2 = OpenInterval x yÆ);
a(REPEAT strip_tac THEN cases_tac¨(x1:Ø) < x2Æ THEN cases_tac¨(y1:Ø) < y2Æ);
(* *** Goal "1" *** *)
a(∂_tac¨x2Æ THEN ∂_tac¨y1Æ THEN PC_T1 "sets_ext" rewrite_tac[get_spec¨OpenIntervalÆ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨x2Æ THEN ∂_tac¨y2Æ THEN PC_T1 "sets_ext" rewrite_tac[get_spec¨OpenIntervalÆ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨x1Æ THEN ∂_tac¨y1Æ THEN PC_T1 "sets_ext" rewrite_tac[get_spec¨OpenIntervalÆ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "4" *** *)
a(∂_tac¨x1Æ THEN ∂_tac¨y2Æ THEN PC_T1 "sets_ext" rewrite_tac[get_spec¨OpenIntervalÆ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €°_open_interval_thm›=save_pop_thm "°_open_interval_thm";
=TEX
=SML
set_goal([], ¨µx1 y1 x2 y2∑∂x y∑ ClosedInterval x1 y1 ° ClosedInterval x2 y2 = ClosedInterval x yÆ);
a(REPEAT strip_tac THEN cases_tac¨(x1:Ø) < x2Æ THEN cases_tac¨(y1:Ø) < y2Æ);
(* *** Goal "1" *** *)
a(∂_tac¨x2Æ THEN ∂_tac¨y1Æ THEN PC_T1 "sets_ext" rewrite_tac[get_spec¨ClosedIntervalÆ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨x2Æ THEN ∂_tac¨y2Æ THEN PC_T1 "sets_ext" rewrite_tac[get_spec¨ClosedIntervalÆ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨x1Æ THEN ∂_tac¨y1Æ THEN PC_T1 "sets_ext" rewrite_tac[get_spec¨ClosedIntervalÆ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "4" *** *)
a(∂_tac¨x1Æ THEN ∂_tac¨y2Æ THEN PC_T1 "sets_ext" rewrite_tac[get_spec¨ClosedIntervalÆ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €°_closed_interval_thm›=save_pop_thm "°_closed_interval_thm";
=TEX
Now we show that open sets are closed under arbitrary unions \ldots
=SML
set_goal([], ¨µV∑ V Ä OpenSets ¥ ﬁV ç OpenSetsÆ);
a(PC_T1"sets_ext" rewrite_tac[get_spec¨OpenSetsÆ] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(∂_tac¨x'Æ THEN ∂_tac¨yÆ THEN contr_tac THEN all_asm_fc_tac[]);
val €ﬁ_open_sets_thm›=save_pop_thm "ﬁ_open_sets_thm";
=TEX
\ldots and hence under binary unions \ldots
=SML
set_goal([], ¨µX Y∑ X ç OpenSets ± Y ç OpenSets ¥ X ¿ Y ç OpenSetsÆ);
a(REPEAT µ_tac);
a(ante_tac(µ_elim¨{X; Y}Æ ﬁ_open_sets_thm));
a(rewrite_tac[pc_rule1"sets_ext" prove_rule[]¨µx y c∑ {x; y} Ä c § x ç c ± y ç cÆ]);
(* Need lemma which is easier to prove generically: *)
	push_goal([], ¨µx y∑ ﬁ{x; y} = x ¿ yÆ);
	a(PC_T1 "sets_ext" REPEAT strip_tac THEN all_asm_fc_tac[]);
	(* *** Goal "1" *** *)
	a(∂_tac¨xÆ THEN PC_T1 "sets_ext" REPEAT strip_tac);
	(* *** Goal "2" *** *)
	a(∂_tac¨yÆ THEN PC_T1 "sets_ext" REPEAT strip_tac);
(a o rewrite_thm_tac o pop_thm)();
val €¿_open_sets_thm ›=save_pop_thm "¿_open_sets_thm";
=TEX
\ldots and under binary intersections \ldots
=SML
set_goal([], ¨µX Y∑ X ç OpenSets ± Y ç OpenSets ¥ X ° Y ç OpenSetsÆ);
a(rewrite_tac[get_spec¨OpenSetsÆ] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(strip_asm_tac (list_µ_elim[¨xÆ, ¨yÆ, ¨x'Æ , ¨y'Æ] °_open_interval_thm));
a(∂_tac¨x''Æ THEN ∂_tac¨y''Æ THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(REPEAT_N 4 (POP_ASM_T ante_tac) THEN PC_T1 "sets_ext" prove_tac[]);
val €°_open_sets_thm ›=save_pop_thm "°_open_sets_thm";
=TEX
To get the analogous fcts for closed sets, we need a lemma about complements of
intersections:
=SML
set_goal([], ¨µv∑~(•v) = ﬁ{a | ~a ç v}Æ);
a(PC_T1"sets_ext" rewrite_tac[complement_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨~sÆ THEN rewrite_tac[complement_def] THEN REPEAT strip_tac);
a(asm_rewrite_tac[pc_rule1"sets_ext" prove_rule[complement_def]¨µa:'a SET∑~ (~ a) = aÆ]);
(* *** Goal "2" *** *)
a(∂_tac¨~sÆ THEN rewrite_tac[complement_def] THEN REPEAT strip_tac);
val €complement_•_lemma› = pop_thm();
=TEX
\ldots whence closed sets are closed under arbitrary intersections \ldots
=SML
set_goal([], ¨µV∑ V Ä ClosedSets ¥ •V ç ClosedSetsÆ);
a(rewrite_tac[get_spec¨ClosedSetsÆ, complement_•_lemma]);
a(REPEAT strip_tac THEN bc_thm_tac ﬁ_open_sets_thm);
a(PC_T1"sets_ext" asm_prove_tac []);
a(ALL_ASM_FC_T (MAP_EVERY ante_tac) []);
a(rewrite_tac[pc_rule1"sets_ext" prove_rule[complement_def]¨µa:'a SET∑~ (~ a) = aÆ]);
val €•_closed_sets_thm›=save_pop_thm "•_closed_sets_thm";
=TEX
\ldots and under binary intersections \ldots
=SML
set_goal([], ¨µX Y∑ X ç ClosedSets ± Y ç ClosedSets ¥ X ° Y ç ClosedSetsÆ);
a(rewrite_tac[get_spec¨ClosedSetsÆ,
	pc_rule1"sets_ext" prove_rule[complement_def]¨µa b∑~(a ° b) = ~a ¿ ~bÆ]);
a(REPEAT strip_tac THEN bc_thm_tac ¿_open_sets_thm THEN REPEAT strip_tac);
val €°_closed_sets_thm›=save_pop_thm "°_closed_sets_thm";
=TEX
\ldots and under binary unions:
=SML
set_goal([], ¨µX Y∑ X ç ClosedSets ± Y ç ClosedSets ¥ X ¿ Y ç ClosedSetsÆ);
a(rewrite_tac[get_spec¨ClosedSetsÆ,
	pc_rule1"sets_ext" prove_rule[complement_def]¨µa b∑~(a ¿ b) = ~a ° ~bÆ]);
a(REPEAT strip_tac THEN bc_thm_tac °_open_sets_thm THEN REPEAT strip_tac);
val €¿_closed_sets_thm›=save_pop_thm "¿_closed_sets_thm";
=TEX
We have already proved that closed intervals are closed sets.
We now prove that opern intervals are open sets and various facts about complements
of intervals and half-infinite intervals (which we just write out as set comprehensions):
=SML
set_goal([], ¨µx y∑ OpenInterval x y ç OpenSetsÆ);
a(rewrite_tac[get_spec¨OpenSetsÆ] THEN REPEAT strip_tac);
a(∂_tac¨xÆ THEN ∂_tac¨yÆ THEN PC_T1 "sets_ext" REPEAT strip_tac);
val €open_interval_open_thm›=save_pop_thm "open_interval_open_thm";
=TEX
The complement of an open interval is the union of two closed half-infinite intervals:
=SML
set_goal([], ¨µx y∑ ~(OpenInterval x y) = {t | t º x} ¿ {t | y º t}Æ);
a(rewrite_tac(map get_spec[ ¨OpenIntervalÆ]));
a(PC_T1"sets_ext" rewrite_tac[complement_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €complement_open_interval_thm›=save_pop_thm "complement_open_interval_thm";
=TEX
The complement of a closed interval is the union of two open half-infinite intervals:
=SML
set_goal([], ¨µx y∑ ~(ClosedInterval x y) = {t | t < x} ¿ {t | y < t}Æ);
a(rewrite_tac(map get_spec[ ¨ClosedIntervalÆ]));
a(PC_T1"sets_ext" rewrite_tac[complement_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €complement_closed_interval_thm›=save_pop_thm "complement_closed_interval_thm";
=TEX
Open half-infinite intervals are open sets:
=SML
set_goal([], ¨µx∑ {t | t < x} ç OpenSets ± {t | x < t} ç OpenSetsÆ);
a(rewrite_tac [get_spec ¨OpenSetsÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[Ø_less_dense_thm]);
a(strip_asm_tac (µ_elim¨tÆØ_unbounded_below_thm));
a(∂_tac¨yÆ THEN  ∂_tac¨zÆ THEN PC_T1 "sets_ext" rewrite_tac[open_interval_def]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(all_fc_tac[Ø_less_dense_thm]);
a(strip_asm_tac (µ_elim¨tÆØ_unbounded_above_thm));
a(∂_tac¨zÆ THEN  ∂_tac¨yÆ THEN PC_T1 "sets_ext" rewrite_tac[open_interval_def]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €half_infinite_intervals_open_thm›=save_pop_thm "half_infinite_intervals_open_thm";
=TEX
Closed half-infinite intervals are closed sets:
=SML
set_goal([], ¨µx∑ {t | t º x} ç ClosedSets ± {t | x º t} ç ClosedSetsÆ);
a(rewrite_tac [get_spec ¨ClosedSetsÆ]);
a(LEMMA_T¨µx:Ø∑ ~ {t|t º x} = {t | x < t} ± ~ {t|x º t} = {t | t < x}Æ
	(fn th => rewrite_tac[th, half_infinite_intervals_open_thm]));
a(PC_T1 "sets_ext" rewrite_tac[complement_def] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €half_infinite_intervals_closed_thm›=save_pop_thm "half_infinite_intervals_closed_thm";
=TEX
The empty set and the set of all real numbers are both open and closed:
=SML
set_goal([], ¨{} ç OpenSets ± Universe ç OpenSets ± {} ç ClosedSets ± Universe ç ClosedSetsÆ);
a(rewrite_tac [get_spec ¨ClosedSetsÆ, taut_rule¨µp q∑ p ± q ± q ± p § p ± qÆ]);
a(rewrite_tac[get_spec¨OpenSetsÆ] THEN REPEAT strip_tac);
a(rewrite_tac[get_spec¨OpenIntervalÆ]);
a(∂_tac ¨t + ~(ÓØ 1)Æ THEN ∂_tac¨t + (ÓØ 1)Æ THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €empty_universe_open_closed_thm›=save_pop_thm "empty_universe_closed_thm";
=TEX
A set is open iff. it contains an open  neighbourhood of any of its points:
=SML
set_goal([], ¨µX∑ X ç OpenSets § (µx∑x ç X ¥ ∂Y∑Y ç OpenSets ± x ç Y ± Y Ä X)Æ);
a(REPEAT strip_tac THEN1 (∂_tac¨XÆ THEN REPEAT strip_tac));
a(POP_ASM_T ante_tac THEN rewrite_tac[open_sets_def] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(LIST_GET_NTH_ASM_T [3] all_fc_tac);
a(lemma_tac¨OpenInterval x y Ä XÆ THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(contr_tac THEN all_asm_fc_tac[]);
val €open_open_neighbourhodd_thm›=save_pop_thm "open_open_neighbourhood_thm";
=TEX
Now we can prove that compact sets are closed:
=SML
set_goal([], ¨CompactSets Ä ClosedSetsÆ);
a(PC_T1 "sets_ext" rewrite_tac[]);
a(rewrite_tac(map get_spec[¨CompactSetsÆ]));
a(REPEAT strip_tac THEN rename_tac[(¨x:Ø SETÆ, "C")]);
a(cases_tac¨C = {}Æ THEN1 asm_rewrite_tac[empty_universe_open_closed_thm]);
a(rewrite_tac(map get_spec[¨ClosedSetsÆ]) THEN REPEAT strip_tac);
a(rewrite_tac[pc_rule1"sets_ext"prove_rule[complement_def]¨µa:'a SET∑~a = {z | ≥z ç a}Æ]);
a(rewrite_tac[open_sets_def] THEN REPEAT strip_tac);
a(lemma_tac¨∂V∑V = {X | ∂e∑ ÓØ 0 < e ± X = {z | z < t + ~e} ¿{z | t + e < z}}Æ
	THEN1 prove_∂_tac);
a(lemma_tac¨V Ä OpenSets ± C Ä ﬁ VÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T "sets_ext" strip_tac THEN all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN bc_thm_tac ¿_open_sets_thm);
a(rewrite_tac[half_infinite_intervals_open_thm]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨xÆ, ¨tÆ]Ø_less_cases_thm) THEN_TRY (SOLVED_T all_var_elim_asm_tac)
	THEN all_fc_tac[Ø_less_dense_thm]);
(* *** Goal "2.1" *** *)
a(∂_tac¨{w|w < t + ~(t + ~z)} ¿ {w|t + (t + ~z) < w}Æ THEN REPEAT strip_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(∂_tac¨t + ~zÆ THEN REPEAT strip_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(∂_tac¨{w|w < t + ~(z + ~t)} ¿ {w|t + (z + ~t) < w}Æ THEN REPEAT strip_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(∂_tac¨z + ~tÆ THEN REPEAT strip_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
a(cases_tac¨W = {}Æ THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(lemma_tac¨µA B∑ A ç W ± B ç W ¥ A Ä B ≤ B Ä AÆ);
(* *** Goal "3.1" *** *)
a(REPEAT µ_tac THEN ¥_tac);
a(LEMMA_T¨A ç V ± B ç VÆ ante_tac THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(asm_rewrite_tac[] THEN ¥_tac THEN asm_rewrite_tac[]);
a(strip_asm_tac(list_µ_elim[¨eÆ, ¨e'Æ] Ø_º_cases_thm) THEN_LIST
	[≤_right_tac, ≤_left_tac] THEN PC_T1 "sets_ext" REPEAT strip_tac
	THEN PC_T1"Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2" *** *)
a(all_fc_tac[finite_chain_thm]);
a(LEMMA_T ¨A ç VÆ ante_tac THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(var_elim_nth_asm_tac 10 THEN REPEAT strip_tac);
a(∂_tac¨t + ~eÆ THEN ∂_tac¨t + eÆ THEN rewrite_tac[open_interval_def] THEN
	PC_T1 "sets_ext" REPEAT strip_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨C Ä AÆ ante_tac THEN1 (var_elim_nth_asm_tac 5 THEN strip_tac));
a(LEMMA_T¨≥x ç AÆ ante_tac THEN_LIST
	[asm_rewrite_tac[], PC_T1 "sets_ext" prove_tac[]]);
a(PC_T1 "sets_ext" REPEAT strip_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €compact_closed_thm ›= save_pop_thm "compact_closed_thm";
=TEX
Compact sets contain their minimum and maximum values:
=SML
set_goal([], ¨µX∑
	≥X = {}
±	X ç CompactSets
¥	∂L U∑ L ç X ± U ç X ± µx∑x ç X ¥ L º x ± x º UÆ);
a(REPEAT strip_tac);
a(strip_asm_tac id_cts_thm);
a(LEMMA_T¨µt∑ (Ãx∑~((Ãx∑ x)x)) CtsAt tÆ ante_tac THEN1
	(µ_tac THEN bc_thm_tac minus_comp_cts_thm THEN asm_rewrite_tac[]));
a(rewrite_tac[] THEN strip_tac);
a(ALL_FC_T (MAP_EVERY ante_tac) [cts_compact_bounded_thm]);
a(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µx y:Ø∑~x º ~y § y º xÆ] THEN REPEAT strip_tac);
a(∂_tac¨x'Æ THEN ∂_tac¨xÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val €compact_min_max_thm ›= save_pop_thm "compact_min_max_thm ";
=TEX
Closed subsets of compact sets are compact:
=SML
set_goal([], ¨µX Y∑
	Y ç ClosedSets ± Y Ä X ± X ç CompactSets
¥	Y ç CompactSetsÆ);
a(rewrite_tac[closed_sets_def, compact_sets_def] THEN REPEAT strip_tac);
a(lemma_tac¨{~Y} ¿ V Ä OpenSets ± X Ä ﬁ({~Y} ¿ V)Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac (pc_rule1 "sets_ext" prove_rule[] ¨µx b c∑x ç c ± b Ä c ¥ {x} ¿ b Ä cÆ)
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(cases_tac¨x ç YÆ);
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 3 (PC_T1 "sets_ext" strip_asm_tac));
a(PC_T1 "sets_ext" all_asm_fc_tac[]);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(∂_tac¨~YÆ THEN rewrite_tac[complement_def] THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
a(∂_tac¨W \ {~Y}Æ THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(bc_thm_tac (pc_rule1 "sets_ext" prove_rule[] ¨µa b c∑a Ä b ¿ c ¥ a \ b Ä cÆ)
	THEN REPEAT strip_tac);
(* *** Goal "3.2" *** *)
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨WÆ THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "3.3" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(lemma_tac¨Y Ä ﬁWÆ THEN1
	all_fc_tac [pc_rule1 "sets_ext" prove_rule[] ¨µa b c∑a Ä b ± b Ä  c ¥ a Ä cÆ]);
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN DROP_ASMS_T discard_tac
	THEN PC_T1 "sets_ext" REPEAT strip_tac);
a(PC_T1 "sets_ext" all_asm_fc_tac[]);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
a(contr_tac THEN all_var_elim_asm_tac1);
a(PC_T1 "sets_ext" asm_prove_tac[complement_def]);
val €closed_Ä_compact_thm ›= save_pop_thm "closed_Ä_compact_thm";
=TEX
The empty set is compact but the set of all real numbers is not:
=SML
set_goal([], ¨{} ç CompactSets ± ≥Universe ç CompactSetsÆ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[compact_sets_def] THEN REPEAT strip_tac THEN ∂_tac¨{}Æ
	THEN rewrite_tac[empty_finite_thm]);
(* *** Goal "2" *** *)
a(contr_tac THEN LEMMA_T¨≥(Universe:Ø SET) = {}Æ asm_tac THEN1
	PC_T1 "sets_ext" rewrite_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [compact_min_max_thm ]);
a(rewrite_tac[] THEN contr_tac);
a(strip_asm_tac(µ_elim¨LÆ Ø_unbounded_below_thm));
a(lemma_tac¨L º yÆ THEN1 asm_rewrite_tac[]);
a(PC_T1"Ø_lin_arith" asm_prove_tac[]);
val €empty_universe_compact_thm ›= save_pop_thm "empty_universe_compact_thm";
=TEX
The Heine-Borel theorem: a set is compact iff. it is closed and bounded:
=SML
set_goal([], ¨µX∑
	X ç CompactSets
§	X ç ClosedSets ± ∂L U∑ µx∑x ç X ¥ L º x ± x º UÆ);
a(µ_tac);
a(cases_tac¨X = {}Æ THEN1 asm_rewrite_tac[
	empty_universe_open_closed_thm, empty_universe_compact_thm]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext" all_fc_tac[compact_closed_thm]);
(* *** Goal "2" *** *)
a(all_fc_tac[compact_min_max_thm]);
a(∂_tac¨LÆ THEN ∂_tac¨UÆ THEN POP_ASM_T accept_tac);
(* *** Goal "3" *** *)
a(lemma_tac¨X Ä ClosedInterval L UÆ THEN1
	PC_T1 "sets_ext" asm_rewrite_tac[closed_interval_def]);
a(bc_thm_tac closed_Ä_compact_thm);
a(∂_tac¨ClosedInterval L UÆ THEN asm_rewrite_tac[closed_interval_compact_thm]);
val €heine_borel_thm ›= save_pop_thm "heine_borel_thm";
=TEX
The following lemma contains most of the proof that the real numbers are connected.
It says that if $X$ and $Y$ are non-empty open sets whose union is the set of all real numbers
then $X$ and $Y$ are not disjoint, under the hypothesis that $X$ contains
an element that is smaller than some element of $Y$ (which is a technical convenience to
simplify the case analysis in the general result):
=SML
set_goal([], ¨µX Y x y∑
	x ç X ± X ç OpenSets ± y ç Y ± Y ç OpenSets ± (µx∑x ç X ¿ Y) ± x < y
¥	(∂x∑ x ç X ° Y)Æ);
a(PC_T "sets_ext" contr_tac);
a(LEMMA_T¨∂f∑ f = (Ãt∑ if t ç X then x else y)Æ (∂_THEN asm_tac) THEN1 prove_∂_tac);
a(lemma_tac¨µt∑x º t ± t º y ¥ f CtsAt tÆ THEN1 (strip_tac THEN STRIP_T discard_tac));
a(all_var_elim_asm_tac1 THEN intro_µ_tac(¨tÆ, ¨tÆ));
(* *** Goal "1" *** *)
a(rewrite_tac[cts_open_sets_thm] THEN REPEAT strip_tac);
a(cases_tac¨x ç AÆ THEN cases_tac ¨y ç AÆ);
(* *** Goal "1.1" *** *)
a(lemma_tac¨{x'|(if x' ç X then x else y) ç A} = UniverseÆ THEN_LIST
	[id_tac, asm_rewrite_tac[empty_universe_open_closed_thm]]);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(cases_tac¨x' ç XÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(lemma_tac¨{x'|(if x' ç X then x else y) ç A} = XÆ THEN_LIST
	[id_tac, asm_rewrite_tac[]]);
a(PC_T1 "sets_ext" REPEAT strip_tac THEN POP_ASM_T ante_tac
	THEN cases_tac¨x' ç XÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.3" *** *)
a(lemma_tac¨{x'|(if x' ç X then x else y) ç A} = YÆ THEN_LIST
	[id_tac, asm_rewrite_tac[]]);
a(PC_T1 "sets_ext" REPEAT strip_tac THEN POP_ASM_T ante_tac
	THEN cases_tac¨x' ç XÆ THEN asm_rewrite_tac[]
	THEN PC_T1 "sets_ext" asm_prove_tac[]);
(* *** Goal "1.4" *** *)
a(lemma_tac¨{x'|(if x' ç X then x else y) ç A} = {}Æ THEN_LIST
	[id_tac, asm_rewrite_tac[empty_universe_open_closed_thm]]);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN cases_tac¨x' ç XÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨≥y ç XÆ THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(all_fc_tac[Ø_less_dense_thm]);
a(lemma_tac¨f x < z ± z < f yÆ THEN1 asm_rewrite_tac[]);
a(strip_asm_tac intermediate_value_thm THEN rename_tac[]);
a(LIST_DROP_NTH_ASM_T [1] all_fc_tac);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(cases_tac¨x' ç XÆ THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €connected_lemma› = pop_thm();
=TEX
Now we can prove the general result that the real numbers cannot be written as the union of
two disjoint non-empty open sets. I.e., the topological space of real numbers is connected.
=SML
set_goal([], ¨µX Y∑
	≥X = {} ± X ç OpenSets ± ≥Y = {} ± Y ç OpenSets ± (µx∑x ç X ¿ Y)
¥	(∂x∑ x ç X ° Y)Æ);
a(PC_T1 "sets_ext" REPEAT strip_tac THEN rename_tac[(¨x':ØÆ, "y")]);
a(strip_asm_tac(list_µ_elim[¨xÆ, ¨yÆ]Ø_less_cases_thm) THEN_LIST [
	bc_thm_tac connected_lemma,
	PC_T1 "sets_ext" asm_prove_tac[],
	bc_thm_tac (once_rewrite_rule[
		pc_rule1"sets_ext" prove_rule[]¨µa b∑a ¿ b = b ¿ a ± a ° b = b ° aÆ]
			connected_lemma)]
	THEN contr_tac THEN rename_tac[] THEN all_asm_fc_tac[]);
val €Ø_connected_thm ›= save_pop_thm "Ø_connected_thm";
=TEX
\subsection{Cauchy Sequences}
In this section we prove that a sequence of real numbers converges iff. it is a Cauchy
sequence. The easy direction is to show that any convergent sequence is a Cauchy sequence:
=SML
set_goal([], ¨µs x∑s --> x ¥ µe∑ ÓØ 0 < e ¥∂n∑µk m∑n º k ± n º m ¥ Abs(s k - s m) < eÆ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < (1/2)*eÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 2 discard_tac THEN all_asm_fc_tac[]);
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 discard_tac THEN all_asm_fc_tac[]);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨Abs(s k + ~x) + Abs(~(s m + ~x))Æ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ø_abs_plus_bc_thm);
a(conv_tac (ONCE_MAP_C Ø_anf_conv) THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a (rewrite_tac[Ø_abs_minus_thm] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €lim_seq_cauchy_seq_thm ›= save_pop_thm "lim_seq_cauchy_seq_thm";
=TEX
For the converse, we will need to know that finite sequences are bounded above \ldots
=SML
set_goal([], ¨µs : Ó ≠ Ø; n∑ ∂b∑ µm∑ m º n ¥ s m < bÆ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ);
(* *** Goal "1" *** *)
a(∂_tac¨s 0 + ÓØ 1Æ THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1 THEN PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac(list_µ_elim[¨s(n+1)Æ, ¨bÆ]Ø_º_cases_thm));
(* *** Goal "2.1" *** *)
a(∂_tac¨b + ÓØ 1Æ THEN REPEAT strip_tac);
a(cases_tac¨m' º nÆ THEN1 (all_asm_fc_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨m' = n + 1Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(∂_tac¨s(n+1) + ÓØ 1Æ THEN REPEAT strip_tac);
a(cases_tac¨m' º nÆ THEN1 (all_asm_fc_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨m' = n + 1Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €fin_seq_bounded_thm› = save_pop_thm "fin_seq_bounded_thm";
=TEX
\ldots and that Cauchy sequences are bounded above \ldots
=SML
set_goal([], ¨µs : Ó ≠ Ø∑
	(µe∑ ÓØ 0 < e ¥∂n∑µk m∑n º k ± n º m ¥ Abs(s k - s m) < e)
¥	∂b∑ µm∑s m < bÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨ÓØ 0ÆØ_unbounded_above_thm));
a(all_asm_fc_tac[] THEN LIST_DROP_NTH_ASM_T [3] discard_tac);
a(strip_asm_tac(list_µ_elim[¨sÆ, ¨nÆ]fin_seq_bounded_thm));
a(∂_tac¨b + yÆ THEN REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨mÆ, ¨nÆ]º_cases_thm));
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(SPEC_NTH_ASM_T 3 ¨nÆ (fn th => all_fc_tac[th]));
a(spec_nth_asm_tac 3 ¨nÆ);
a(cases_tac¨ÓØ 0 º s n + ~ (s m)Æ);
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[Ø_abs_def]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[Ø_abs_def]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €cauchy_seq_bounded_above_thm ›= save_pop_thm "cauchy_seq_bounded_above_thm";
=TEX
\ldots and below (so that we can argue about suprema and infima of subsets of
the range of the sequence):
=SML
set_goal([], ¨µs : Ó ≠ Ø∑
	(µe∑ ÓØ 0 < e ¥∂n∑µk m∑n º k ± n º m ¥ Abs(s k - s m) < e)
¥	∂b∑ µm∑b  < s mÆ);
a(LEMMA_T¨µx y:Ø∑Abs (x - y) = Abs(~x + y)Æ once_rewrite_thm_tac THEN1
	(once_rewrite_tac[pc_rule1"Ø_lin_arith"prove_rule[]¨µx y:Ø∑ ~x + y = ~(x + ~y)Æ]
	THEN rewrite_tac[Ø_abs_minus_thm]));
a(REPEAT strip_tac);
a(all_fc_tac[rewrite_rule[](µ_elim¨Ãm∑~(s m)Æ cauchy_seq_bounded_above_thm)]);
a(∂_tac¨~bÆ THEN REPEAT strip_tac);
a(asm_rewrite_tac[pc_rule1"Ø_lin_arith"prove_rule[]¨µx y:Ø∑ ~x <  y § ~y < xÆ]);
val €cauchy_seq_bounded_below_thm ›= save_pop_thm "cauchy_seq_bounded_below_thm";
=TEX
The proof that Cauchy sequences is long but rather mechanical.
Given a Cauchy sequence $s_m$, we construct sequences $U_m$ (resp. $L_m$) such
that $U_m$ is the supremum (resp. infimum) of $s_m, s_{m+1}\ldots$,
The $U_m$ are monotone decreasing, the $L_m$ are monotone increasing and
any $L_m \le s_m \le U_m$ for all $m$. (So much is true of any bounded sequence.)
By an earlier theorem on nested closed intervals, there is an $x$ such that $L_m \le x \le U_m$
for all $m$.
Since the sequence is Cauchy, for given $\epsilon$, we have that $s_m - \epsilon \le L_m$ and $U_m \le s_m + \epsilon$ for all sufficently large $m$.
It follows that $s_m$ tends to $x$ as $m$ tends to $\infty$.
=SML
set_goal([], ¨µs∑
	(µe∑ ÓØ 0 < e ¥∂n∑µk m∑n º k ± n º m ¥ Abs(s k - s m) < e)
¥	∂x∑ s --> xÆ);
a(REPEAT strip_tac);
a(lemma_tac¨∂U∑µm∑U m = Sup{t | ∂n∑m º n ± t =s n}Æ THEN1 prove_∂_tac);
a(lemma_tac¨µm∑
	≥{t | ∂n∑m º n ± t =s n} = {}
±	(∂a∑ µx∑x ç {t | ∂n∑m º n ± t =s n} ¥ x º a)Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac THEN ∂_tac¨s mÆ THEN rewrite_tac[]);
a(∂_tac¨mÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(all_fc_tac[cauchy_seq_bounded_above_thm]);
a(∂_tac ¨bÆ THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨nÆ THEN all_var_elim_asm_tac1 THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨µm∑U (m+1) º U mÆ THEN1
	(strip_tac THEN asm_rewrite_tac[] THEN
	bc_thm_tac Ø_Ä_sup_thm THEN asm_rewrite_tac[]));
(* *** Goal "3.1" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(∂_tac ¨nÆ THEN asm_rewrite_tac[] THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "3.2" *** *)
a(lemma_tac¨∂L∑µm∑L m = ~(Sup{t | ∂n∑m º n ± t =~(s n)})Æ THEN1 prove_∂_tac);
a(lemma_tac¨µm∑
	≥{t | ∂n∑m º n ± t =~(s n)} = {}
±	(∂a∑ µx∑x ç {t | ∂n∑m º n ± t =~(s n)} ¥ x º a)Æ THEN REPEAT strip_tac);
(* *** Goal "3.2.1" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac THEN ∂_tac¨~(s m)Æ THEN rewrite_tac[]);
a(∂_tac¨mÆ THEN REPEAT strip_tac);
(* *** Goal "3.2.2" *** *)
a(all_fc_tac[cauchy_seq_bounded_below_thm]);
a(∂_tac ¨~bÆ THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨nÆ THEN all_var_elim_asm_tac1 THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.3" *** *)
a(lemma_tac¨µm∑L m º L (m+1)Æ THEN1
	(strip_tac THEN asm_rewrite_tac[
		pc_rule1"Ø_lin_arith" prove_rule[]¨µx y:Ø∑~x º ~y §y º xÆ] THEN
	bc_thm_tac Ø_Ä_sup_thm THEN asm_rewrite_tac[]));
(* *** Goal "3.2.3.1" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(∂_tac ¨nÆ THEN asm_rewrite_tac[] THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.3.2" *** *)
a(lemma_tac¨µm∑L m º U mÆ THEN REPEAT strip_tac);
(* *** Goal "3.2.3.2.1" *** *)
a(asm_rewrite_tac[] THEN bc_thm_tac Ø_º_sup_bc_thm THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a(once_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µx y:Ø∑~x º y § ~y º xÆ]);
a(bc_thm_tac Ø_º_sup_bc_thm THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(bc_thm_tac Ø_º_trans_thm THEN ∂_tac ¨~(s m)Æ THEN REPEAT strip_tac);
(* *** Goal "3.2.3.2.1.1" *** *)
a(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µx y:Ø∑~x º ~y § y º xÆ]);
a(GET_NTH_ASM_T 2 bc_thm_tac THEN ∂_tac¨mÆ THEN REPEAT strip_tac);
(* *** Goal "3.2.3.2.1.2" *** *)
a(POP_ASM_T  bc_thm_tac THEN ∂_tac¨mÆ THEN REPEAT strip_tac);
(* *** Goal "3.2.3.2.2" *** *)
a(lemma_tac¨µm∑s  m º U mÆ THEN1
	(REPEAT strip_tac THEN asm_rewrite_tac[] THEN bc_thm_tac Ø_º_sup_bc_thm
	THEN asm_rewrite_tac[] THEN REPEAT strip_tac));
(* *** Goal "3.2.3.2.2.1" *** *)
a(POP_ASM_T bc_thm_tac THEN ∂_tac¨mÆ THEN REPEAT strip_tac);
(* *** Goal "3.2.3.2.2.2" *** *)
a(lemma_tac¨µm∑L  m º s mÆ THEN1
	(REPEAT strip_tac THEN asm_rewrite_tac[]
	THEN once_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µx y:Ø∑~x º y § ~y º xÆ]
	THEN  bc_thm_tac Ø_º_sup_bc_thm
	THEN asm_rewrite_tac[] THEN REPEAT strip_tac));
(* *** Goal "3.2.3.2.2.1" *** *)
a(POP_ASM_T bc_thm_tac THEN ∂_tac¨mÆ THEN REPEAT strip_tac);
(* *** Goal "3.2.3.2.2.2.2" *** *)
a(lemma_tac¨µe∑ÓØ 0 < e ¥ ∂n∑ µm∑n º m ¥ U m º s m + eÆ);
(* *** Goal "3.2.3.2.2.2.2.1" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(∂_tac¨nÆ THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
a(bc_thm_tac Ø_sup_º_bc_thm THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(lemma_tac¨n º n'Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(list_spec_nth_asm_tac 4 [¨mÆ, ¨n'Æ]);
a(swap_nth_asm_concl_tac 1 THEN rewrite_tac[]);
a(lemma_tac¨≥(ÓØ 0 º s m + ~(s n'))Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.3.2.2.2.2.2" *** *)
a(lemma_tac¨µe∑ÓØ 0 < e ¥ ∂n∑ µm∑n º m ¥ s m + ~e  º L mÆ);
(* *** Goal "3.2.3.2.2.2.2.2.1" *** *)
a(REPEAT strip_tac THEN spec_nth_asm_tac 12 ¨e:ØÆ);
a(∂_tac¨nÆ THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
a(once_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µx y:Ø∑x º ~y § y º ~xÆ]);
a(bc_thm_tac Ø_sup_º_bc_thm THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(lemma_tac¨n º n'Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(list_spec_nth_asm_tac 4 [¨mÆ, ¨n'Æ]);
a(swap_nth_asm_concl_tac 1 THEN rewrite_tac[]);
a(lemma_tac¨(ÓØ 0 º s m + ~(s n'))Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.3.2.2.2.2.2.2" *** *)
a(lemma_tac¨∂x∑µm∑ L m º x ± x º U mÆ THEN1
	(bc_thm_tac nested_interval_intersection_thm THEN asm_rewrite_tac[]));
a(∂_tac¨xÆ THEN rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < (1/2)*eÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 2 discard_tac THEN LIST_GET_NTH_ASM_T [3, 4] all_fc_tac);
a(∂_tac¨n+n'Æ THEN REPEAT strip_tac);
a(lemma_tac¨n º m ± n' º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 7 ¨mÆ);
a(LIST_GET_NTH_ASM_T [6, 7] all_fc_tac);
a(cases_tac¨ÓØ 0 º s m + ~xÆ THEN asm_rewrite_tac[Ø_abs_def]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €cauchy_seq_lim_seq_thm ›= save_pop_thm "cauchy_seq_lim_seq_thm";
=SML
set_goal([], ¨µs∑
	(∂x∑s --> x)
§	(µe∑ ÓØ 0 < e ¥∂n∑µk m∑n º k ± n º m ¥ Abs(s k - s m) < e)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[lim_seq_cauchy_seq_thm]);
a(∂_tac¨nÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(bc_thm_tac cauchy_seq_lim_seq_thm THEN POP_ASM_T accept_tac);
val €lim_seq_§_cauchy_seq_thm ›= save_pop_thm "lim_seq_§_cauchy_seq_thm";
=TEX
\subsection{Epilogue}
=TEX
%%%%
%%%%
=SML
output_theory{out_file="analysis.th.doc", theory="-"};
=TEX
\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}
\end{document}


