pp_make_database -f -p hol analysis
docsml analysis
xpp -file analysis.doc -com pp -d analysis -i analysis &
doctex analysis analysis.th; texdvi analysis
=TEX
\documentclass[10pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\def\Lim{\mbox{{\sf lim}}}
\def\LimInf{\mbox{{\sf lim inf}}}
\def\LimSup{\mbox{{\sf lim sup}}}
\def\Abs#1{|#1|}

\title{Mathematical Case Studies: \\ --- \\ Basic Analysis}
\author{Rob Arthan}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
This {\ProductHOL} script contains definitions and proofs concerning
the basics of analysis.

\end{abstract}
\vfill
\newpage
\tableofcontents
\newpage
%%%%
%%%%
%%%%
%%%%
\section{INTRODUCTION}
%%%%
%%%%
%%%%
%%%%
This document defines a theory
=INLINEFT
analysis
=TEX
\ which contains the definitions and proofs concerned with the basics of analysis.
The subjects covered are the basic facts about:
\begin{itemize}
\item polynomial functions on the real numbers
\item limits of sequences
\item continuity of functions
\item differentiation
\item power series
\item special functions such as the exponential function
\end{itemize}

TO DO:

1) Some kind of tool to automate calculation of derivatives

2) Definitions and basic properties of sine and cosine functions

3) TIdy-up of the organisation of the last few results on power series (e.g.,
to make it trivial to show that a function defined by a differential equation
satisfied by some power series is the limit of that power series).

4) Make systematic use of open and closed interval functions in the statements
of the basic theorems on limits etc.

%%%%
%%%%
=SML
force_delete_theory"analysis" handle Fail _ => ();
open_theory"Ø";
set_merge_pcs["basic_hol1", "'sets_alg", "'Ø"];
new_theory"analysis";
new_parent"fin_set";
=TEX
%%%%
%%%%
%%%%
%%%%
\section{DEFINITIONS}\label{DEFINITIONS}
%%%%
%%%%
%%%%
%%%%
\subsection{Polynomials}
We define the polynomial functions on the real numbers to be the smallest set
of functions containing the constant functions and the identity function
and closed under (point-wise) addition and multiplication.
%%%%
%%%%
%%%%
%%%%
πHOLCONST
‹ €PolyFunc› : (Ø ≠ Ø) SET
˜¸¸¸¸¸¸
‹ PolyFunc = •
‹	{	A
‹	|	(µc∑ (Ãx∑c) ç A)
‹	±	(Ãx∑x) ç A
‹	±	(µf g∑f ç A ± g ç A ¥ (Ãx∑f x + g x) ç A)
‹	±	(µf g∑f ç A ± g ç A ¥ (Ãx∑f x * g x) ç A) }
∞
We will show that every polynomial function can be represented as
a (point-wise) sum, $\lambda x \bullet a_0 + a_1x + a_2 x^2 + \ldots a_n x^n$
for some list of coefficients $[a_0; a_1; a_2 \ldots; a_n]$.
The following function maps such a list of coefficients into the polynomial
function it represents.
πHOLCONST
‹ $€PolyEval› : Ø LIST ≠ (Ø ≠ Ø)
˜¸¸¸¸¸¸
‹ 	(µx∑ PolyEval [] x = ÓØ 0)
‹±	(µc l x∑ PolyEval (Cons c l) x = c + x * PolyEval l x)
∞
We now define the operations on lists of coefficients that
correspond to addition of polynomials \ldots
πHOLCONST
‹ €PlusCoeffs› : Ø LIST ≠ Ø LIST ≠ Ø LIST
˜¸¸¸¸¸¸
‹ 	(µl∑ PlusCoeffs [] l = l)
‹±	(µl∑ PlusCoeffs l [] = l)
‹±	(µc1 l1 c2 l2∑
‹	PlusCoeffs (Cons c1 l1) (Cons c2 l2) =
‹	Cons (c1 + c2) (PlusCoeffs l1 l2))
∞
\ldots and to multiplication of one polynomial by another.
πHOLCONST
‹ €TimesCoeffs› : Ø LIST ≠ Ø LIST ≠ Ø LIST
˜¸¸¸¸¸¸
‹ 	(µl∑ TimesCoeffs [] l = [])
‹±	(µc l1 l2∑
‹	TimesCoeffs (Cons c l1) l2 =
‹	PlusCoeffs (Cons (ÓØ 0) (TimesCoeffs l1 l2)) (Map (Ãx∑c * x) l2) )
∞
\ldots and to the derivative of a polynomial:
πHOLCONST
‹ €DerivCoeffs› : Ø LIST ≠ Ø LIST
˜¸¸¸¸¸¸
‹ 	DerivCoeffs [] = []
‹±	(µc l∑
‹	DerivCoeffs (Cons c l) = PlusCoeffs l (Cons (ÓØ 0) (DerivCoeffs l)))
∞
=TEX
The following is useful in forming polynomials whose list
of coefficients is given by a function:
%%%%
%%%%
=SML
declare_infix(310, "To");

πHOLCONST
‹ $€To› : (Ó ≠ 'a) ≠ Ó ≠ 'a LIST
˜¸¸¸¸¸¸
‹ 	(µf∑ f To 0 = [])
‹±	(µf n∑ f To (n+1) = f To n @ [f n])
∞

\subsection{Series and Power Series}
The {\em series} defined by a sequence of real terms is, to all intents and
purposes, the sequence of partial sums of the sequence:
%%%%
%%%%
%%%%
%%%%
πHOLCONST
‹ €Series› : (Ó ≠ Ø) ≠ (Ó ≠ Ø)
˜¸¸¸¸¸¸
‹	(µs∑ Series s 0 = ÓØ 0)
‹ ±	(µs n∑ Series s (n+1) = Series s n + s n)
∞
The {\em power series} defined by a sequence of real coefficients is, in a similar vein,
the sequence of polynomial functions whose coefficients are given by leading
subsequences of the sequence:
%%%%
%%%%
%%%%
%%%%
πHOLCONST
‹ €PowerSeries› : (Ó ≠ Ø) ≠ (Ó ≠ Ø ≠ Ø)
˜¸¸¸¸¸¸
‹ µs n∑ PowerSeries s n = PolyEval (s To n)
∞

%%%%
%%%%
%%%%
%%%%
\subsection{Limits}
%%%%
%%%%
%%%%
%%%%
We will write $s {-}{>} x$ to indicate that the sequence $s_n$, indexed by
natural numbers, tends to the limit $x$ as $n$ tends to infinity:
%%%%
%%%%
=SML
declare_infix(200, "->");

πHOLCONST
‹ $€->› : (Ó ≠ Ø) ≠ Ø ≠ BOOL
˜¸¸¸¸¸¸
‹µs x∑ s -> x § µe∑ÓØ 0 < e ¥ ∂n∑µm∑n º m ¥ Abs(s m - x) < e
∞
We will write $(f {-}{-}{>} c)x$ to indicate that $f(t)$
tends to the limit $c$ as $t$ tends to $x$:
%%%%
%%%%
=SML
declare_infix(200, "-->");

πHOLCONST
‹ $€-->› : (Ø ≠ Ø) ≠ Ø ≠ Ø ≠ BOOL
˜¸¸¸¸¸¸
‹µf c x∑
‹	(f --> c) x
‹ §	µe∑ÓØ 0 < e
‹	¥	∂d∑ÓØ 0 < d ± µy∑ Abs(y - x) < d ± ≥y = x ¥ Abs(f y - c) < e
∞

We write $(u {-}{-}{-}{>} h) X$ to indicate that the sequence of functions $u_n$, indexed by
natural numbers, tends uniformly to the limit function $h$ on the
set $X$ as $n$ tends to infinity. The definition requires $a < b$.
%%%%
%%%%
=SML
declare_infix(200, "--->");

πHOLCONST
‹ $€--->› : (Ó ≠ Ø ≠ Ø) ≠ (Ø ≠ Ø) ≠ Ø SET ≠ BOOL
˜¸¸¸¸¸¸
‹µu h X∑
‹	(u ---> h) X
‹ §	µe∑ÓØ 0 < e ¥ ∂n∑µm y∑ n º m ± y ç X ¥ Abs(u m y - h y) < e
∞
%%%%
%%%%
%%%%
%%%%
\subsection{Continuity}
%%%%
%%%%
%%%%
%%%%
Now we give the usual $\epsilon$-$\delta$ definition for continuity of
a function, $f$ at a point $x$. Both kinds of $\epsilon$ are tied
up in the {\ProductHOL} library for something else (viz. Hilbert's choice
operator and set-membership). We therefore just use $e$ and $d$.
Continuity is formulated as an infix relation between a function and
the point at which its continuity is asserted.
%%%%
%%%%
=SML
declare_infix(200, "CtsAt");
πHOLCONST
‹ $€CtsAt› : (Ø ≠ Ø) ≠ Ø ≠ BOOL
˜¸¸¸¸¸¸
‹ µf x∑ f CtsAt x § µe∑ÓØ 0 < e ¥ ∂d∑ÓØ 0 < d ± µy∑ Abs(y - x) < d ¥ Abs(f y - f x) < e
∞
%%%%
%%%%
%%%%
%%%%
\subsection{Derivatives}
%%%%
%%%%
%%%%
%%%%
Now we give the usual $\epsilon$-$\delta$ definition for the derivative of
a function, $f$ at a point $x$. 
The notion of a derivative as formulated here is really a ternary
relation: ``$f$ has derivative $c$ at $x$''.
We represent this as the infix operation between $f$ and $c$ whose
value is the propositional function that characterises the values$x$ for
which the derivative $f$ is $c$.
%%%%
%%%%
=SML
declare_infix(200, "HasDeriv");
πHOLCONST
‹ $€HasDeriv› : (Ø ≠ Ø) ≠ Ø ≠ Ø ≠ BOOL
˜¸¸¸¸¸¸
‹ µf c x∑
‹	(f HasDeriv c) x §
‹	µe∑ÓØ 0 < e ¥ ∂d∑
‹		ÓØ 0 < d
‹	±	µy∑ Abs(y - x) < d ± ≥y = x ¥ Abs((f y - f x)/(y-x) - c) < e
∞
%%%%
%%%%
%%%%
%%%%
\subsection{Intervals}
%%%%
%%%%
%%%%
%%%%
The notions of closed and open intervals make some of the results
slightly more readable.
%%%%
%%%%
πHOLCONST
‹ €ClosedInterval› : Ø ≠ Ø ≠ Ø SET
˜¸¸¸¸¸¸
‹ µx y∑ ClosedInterval x y = {t | x º t ± t º y}
∞
πHOLCONST
‹ €OpenInterval› : Ø ≠ Ø ≠ Ø SET
˜¸¸¸¸¸¸
‹ µx y∑ OpenInterval x y = {t | x < t ± t < y}
∞
%%%%
%%%%
%%%%
%%%%
\subsection{Open, Closed and Compact Sets}
%%%%
%%%%
%%%%
%%%%
The notions of open, closed and compact sets are useful:
%%%%
%%%%
πHOLCONST
‹ €OpenâR› : Ø SET SET
˜¸¸¸¸¸¸
‹ OpenâR = {A | µt∑t ç A ¥ ∂x y∑t ç OpenInterval x y ± OpenInterval x y Ä A}
∞
[Note that
=INLINEFT
~
=TEX
\ here is not arithmetic negation, but the operation
of complementing a set with respect to the universe of its type..]
πHOLCONST
‹ €ClosedâR› : Ø SET SET
˜¸¸¸¸¸¸
‹ ClosedâR = {A | ~ A ç OpenâR}
∞
πHOLCONST
‹ €CompactâR› : Ø SET SET
˜¸¸¸¸¸¸
‹ CompactâR =
‹ {A | µ V∑ V Ä OpenâR ± A Ä ﬁV ¥ ∂W∑ W Ä V ± W ç Finite ± A Ä ﬁ W}
∞
%%%%
%%%%
%%%%
%%%%
\subsection{Some Special Functions}
%%%%
%%%%
%%%%
%%%%
The factorial function. We make this a postfix operator with precedence higher
than all the binary arithmetic operators.
%%%%
%%%%
=SML
declare_postfix(330, "!");
πHOLCONST
‹ 	€$!› : Ó≠ Ø
˜¸¸¸¸¸¸
‹	0 ! = ÓØ 1
‹ ±	(µm∑(m+1)! = ÓØ(m+1)*m!)
∞
The exponential function, which we define by a differential equation.
%%%%
%%%%
=SML
πHOLCONST
‹ 	€Exp› : Ø ≠ Ø
˜¸¸¸¸¸¸
‹	Exp (ÓØ 0) = ÓØ 1
‹ ±	(µx∑ (Exp HasDeriv Exp x) x)
∞
The natural logarithm function, which we define as the right inverse of
the exponential function:
%%%%
%%%%
=SML
πHOLCONST
‹ 	€Log› : Ø ≠ Ø
˜¸¸¸¸¸¸
‹	µx∑ Log (Exp x) = x
∞
=TEX
%%%%
%%%%
%%%%
%%%%
{\HOLindexOff
\include{analysis.th}}
%%%%
%%%%
%%%%
%%%%
\section{THEOREMS}
%%%%
%%%%
%%%%
%%%%
\subsection{The Definitions and Their Consistency}
%%%%
%%%%
%%%%
%%%%
We give bindings for the definitions and discharge the easy consistency
proof obligations.
The consistency of the definitions of the transcendental functions will depend on
most of the theory that we develop.
%%%%
%%%%
=SML
val €poly_func_def› = get_spec¨PolyFuncÆ;
val €poly_eval_def› = get_spec¨PolyEvalÆ;
=TEX
Here is the only easy consistency proof obligation, which just arises
because the definition of {\it PlusCoeffs} is not quite in the
form that the existence prover for recursive definitions over
the natural numbers expects.
%%%%
%%%%
=SML
push_consistency_goal¨PlusCoeffsÆ;
a(lemma_tac¨∂ac∑
 	(µl∑ ac [] l = l)
±	(µc1 : Ø; l1∑
	ac (Cons c1 l1) [] = Cons c1 l1
±	(µc2 l2∑ ac (Cons c1 l1) (Cons c2 l2) =
	Cons (c1 + c2) (ac l1 l2)))
Æ THEN1 prove_∂_tac);
a(∂_tac ¨acÆ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(list_induction_tac¨lÆ THEN asm_rewrite_tac[]);
val _ = save_consistency_thm ¨PlusCoeffsÆ (pop_thm());
val €plus_coeffs_def› = get_spec¨PlusCoeffsÆ;
val €times_coeffs_def› = get_spec¨TimesCoeffsÆ;
val €deriv_coeffs_def› = get_spec¨DerivCoeffsÆ;
val €to_def› = get_spec¨$ToÆ;
val €series_def› = get_spec¨SeriesÆ;
val €power_series_def› = get_spec¨PowerSeriesÆ;
val €lim_seq_def› = get_spec¨$->Æ;
val €lim_fun_def› = get_spec¨$-->Æ;
val €unif_lim_seq_def› = get_spec¨$--->Æ;
val €cts_at_def› = get_spec¨$CtsAtÆ;
val €has_deriv_def› = get_spec¨$HasDerivÆ;
val €closed_interval_def› = get_spec¨ClosedIntervalÆ;
val €open_interval_def› = get_spec¨OpenIntervalÆ;
val €open_Ø_def› = get_spec¨OpenâRÆ;
val €closed_Ø_def› = get_spec¨ClosedâRÆ;
val €compact_Ø_def› = get_spec¨CompactâRÆ;
val €factorial_def› = get_spec¨$!Æ;
=TEX
%%%%
%%%%
%%%%
%%%%
%%%%
%%%%
%%%%
%%%%
\subsection{Lemmas about Lists and Sets}
=TEX
The following lemma is useful in connection with certain compactness arguments:
=SML
set_goal([], ¨µV∑
	V ç Finite
±	≥V = {}
±	(µA B∑ A ç V ± B ç V ¥ A Ä B ≤ B Ä A)
¥	∂A∑ A ç V ± ﬁV = A	
Æ);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac THEN POP_ASM_T ante_tac);
a(finite_induction_tac ¨VÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1 THEN ∂_tac¨xÆ THEN PC_T1 "sets_ext1" prove_tac[]);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(i_contr_tac THEN lemma_tac¨A Ä B ≤ B Ä AÆ THEN1 POP_ASM_T bc_thm_tac);
a(REPEAT strip_tac);
(* *** Goal "3" *** *)
a(lemma_tac¨A Ä x ≤ x Ä AÆ THEN1 POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac);
a(lemma_tac¨ﬁ{x} = xÆ THEN1
	(PC_T1 "sets_ext1" prove_tac[] THEN ∂_tac¨xÆ THEN REPEAT strip_tac));
a(asm_rewrite_tac[pc_rule1"sets_ext1"prove_rule[]¨µX Y∑ﬁ (X ¿ Y) = ﬁX ¿ ﬁYÆ]);
a(GET_NTH_ASM_T 2 ante_tac THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "3.2" *** *)
a(∂_tac¨AÆ THEN REPEAT strip_tac);
a(lemma_tac¨ﬁ{x} = xÆ THEN1
	(PC_T1 "sets_ext1" prove_tac[] THEN ∂_tac¨xÆ THEN REPEAT strip_tac));
a(asm_rewrite_tac[pc_rule1"sets_ext1"prove_rule[]¨µX Y∑ﬁ (X ¿ Y) = ﬁX ¿ ﬁYÆ]);
a(GET_NTH_ASM_T 2 ante_tac THEN PC_T1 "sets_ext1" prove_tac[]);
val €finite_chain_thm› = save_pop_thm"finite_chain_thm";
=TEX
We also need a few general lemmas about lists:
%%%%
%%%%
=SML
set_goal([], ¨
	(µl1 l2 : 'a LIST∑ Length(l1 @ l2) = Length l1 + Length l2)
±	(µl:'a LIST∑ Length(Rev l) = Length l)
Æ);
a(once_rewrite_tac[taut_rule¨µp q∑ p ± q § p ± (p ¥ q)Æ]);
a(±_tac THEN1 (REPEAT strip_tac THEN list_induction_tac¨l1:'a LISTÆ THEN
	asm_rewrite_tac[rev_def, length_def, append_def] THEN PC_T1 "lin_arith" prove_tac[]));
a(REPEAT strip_tac THEN list_induction_tac¨l:'a LISTÆ THEN
	asm_rewrite_tac[rev_def, length_def] THEN PC_T1 "lin_arith" prove_tac[]);
val €length_rev_append_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl: 'a LIST∑ Length l = 0 § l = []
Æ);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[length_def]);
a(strip_asm_tac (µ_elim¨lÆlist_cases_thm));
a(all_var_elim_asm_tac1 THEN all_asm_ante_tac THEN rewrite_tac[length_def]);
val €length_eq_0_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl1 l2 l3:'a LIST∑ (l1 @ l2) @ l3 = l1 @ l2 @ l3
Æ);
a(REPEAT strip_tac THEN list_induction_tac¨l1:'a LISTÆ THEN
	asm_rewrite_tac[append_def]);
val €append_assoc_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl∑ [] @ l = l ± l @ [] = l
Æ);
a(rewrite_tac[append_def]
	THEN REPEAT strip_tac THEN list_induction_tac¨l:'a LISTÆ THEN
	asm_rewrite_tac[append_def]);
val €append_empty_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl1 l2 ∑ Rev (l1 @ l2) = Rev l2 @ Rev l1
Æ);
a(REPEAT strip_tac THEN list_induction_tac¨l1:'a LISTÆ THEN
	asm_rewrite_tac[rev_def, append_def, append_assoc_thm, append_empty_thm]);
val €rev_append_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl1 l2 ∑ l1 @ l2 = [] § l1 = [] ± l2 = []
Æ);
a(µ_tac THEN list_induction_tac¨l1: 'a LISTÆ THEN asm_rewrite_tac[append_def]);
val €append_eq_empty_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl ∑ Rev l = [] § l = []
Æ);
a(µ_tac THEN list_induction_tac¨l: 'a LISTÆ THEN asm_rewrite_tac[append_eq_empty_thm, rev_def]);
val €rev_eq_empty_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl ∑ Rev(Rev l) = l
Æ);
a(µ_tac THEN list_induction_tac¨l: 'a LISTÆ THEN
	asm_rewrite_tac[rev_def, rev_append_thm, append_empty_thm, append_def]);
val €rev_rev_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µc n∑ Rev ((Ãm∑ c) To n) = (Ãm∑ c) To n
Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ THEN
	asm_rewrite_tac[rev_def, to_def, rev_append_thm]);
a(rewrite_tac[append_def]);
a(POP_ASM_T discard_tac THEN induction_tac¨n:ÓÆ THEN
	asm_rewrite_tac[to_def, append_def]);
a(LEMMA_T ¨µc l1 l2∑ Cons c (l1 @ l2) = Cons c l1 @ l2Æ asm_rewrite_thm_tac);
a(REPEAT strip_tac THEN list_induction_tac ¨l1:'a LISTÆ
	THEN asm_rewrite_tac[append_def]);
val €rev_const_to_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	(µf n∑ Length(f To n) = n)
Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ THEN
	asm_rewrite_tac[length_rev_append_thm, length_def, to_def]);
val €length_to_thm› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	(µf:'a ≠ 'b; l∑ Length(Map f l) = Length l)
Æ);
a(REPEAT strip_tac THEN list_induction_tac¨l:'a LISTÆ THEN
	asm_rewrite_tac[length_def, map_def]);
val €length_map_thm› = pop_thm();
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Polynomials}
%%%%
%%%%
%%%%
%%%%
Now we will show that any polynomial can be represented by a list of coefficients.
The first part of the proof follows a pattern which will be repeated several times.
First we prove something for constant functions, then for the identity functions,
then for sums and products possibly on the assumption that the ``something'' holds for
the operands. In this case ``something'' is the existence of a list of
coefficients that represent a function, which we give explicitly for later use.

Constants \ldots
%%%%
%%%%
=SML
set_goal([], ¨µc∑(Ãx∑c) = PolyEval [c]Æ);
a(rewrite_tac[poly_eval_def]);
val €const_eval_thm› = save_pop_thm "const_eval_thm";
=TEX
\ldots identity function \ldots
%%%%
%%%%
=SML
set_goal([], ¨(Ãx∑x) = PolyEval [ÓØ 0; ÓØ 1]Æ);
a(rewrite_tac[poly_eval_def]);
val €id_eval_thm› = save_pop_thm "id_eval_thm";
=TEX
\ldots sums \ldots
%%%%
%%%%
=SML
set_goal([], ¨µl1 l2∑
	(Ãx∑PolyEval l1 x + PolyEval l2 x) =
	PolyEval (PlusCoeffs l1 l2)Æ);
a(strip_tac);
a(list_induction_tac¨l1Æ THEN rewrite_tac[plus_coeffs_def, poly_eval_def]);
a(REPEAT strip_tac);
a(list_induction_tac¨l2Æ THEN rewrite_tac[plus_coeffs_def, poly_eval_def]);
a(DROP_NTH_ASM_T 2 (rewrite_thm_tac o conv_rule (BINDER_C eq_sym_conv)));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €plus_eval_thm› = save_pop_thm "plus_eval_thm";
=TEX
\ldots and products, which in this case require a little lemma first:
%%%%
%%%%
=SML
set_goal([], ¨µc l∑(Ãx∑c * PolyEval l x) = PolyEval (Map (Ãy∑c * y) l)Æ);
a(REPEAT strip_tac);
a(list_induction_tac¨lÆ THEN rewrite_tac[map_def, poly_eval_def]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €const_times_eval_thm› = save_pop_thm "const_times_eval_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µl1 l2∑
	(Ãx∑PolyEval l1 x * PolyEval l2 x) =
	PolyEval (TimesCoeffs l1 l2)Æ);
a(strip_tac);
a(list_induction_tac¨l1Æ THEN
	rewrite_tac[times_coeffs_def, poly_eval_def, plus_coeffs_def]);
a(REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[]));
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) plus_eval_thm,
	conv_rule (ONCE_MAP_C eq_sym_conv) const_times_eval_thm,
	poly_eval_def]);
a(conv_tac (RANDS_C Ø_anf_conv));
a(asm_rewrite_tac[]);
val €times_eval_thm› = save_pop_thm "times_eval_thm";
=TEX
We can now show that the set of all polynomial functions is the
range of the polynomial evaluation function. I.e., a function
is polynomial iff. it can be represented by a list of coefficients.
We prove the two inclusions separately:
%%%%
%%%%
=SML
set_goal([], ¨{f | ∂l∑ f = PolyEval l} Ä PolyFuncÆ);
a(pure_rewrite_tac[poly_func_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN list_induction_tac¨lÆ);
(* *** Goal "1" *** *)
a(list_spec_nth_asm_tac 4 [¨ÓØ 0Æ]);
a(LEMMA_T ¨PolyEval [] = (Ãx∑ ÓØ 0)Æ asm_rewrite_thm_tac
	THEN1 rewrite_tac[poly_eval_def]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(LEMMA_T ¨PolyEval (Cons x l) = (Ãt∑ (Ãu∑x) t + (Ãv∑ (Ãw∑w)v * PolyEval l v)t)Æ
	pure_rewrite_thm_tac THEN1 rewrite_tac[poly_eval_def]);
a(GET_NTH_ASM_T 3 bc_thm_tac THEN strip_tac THEN1 asm_rewrite_tac[]);
a(GET_NTH_ASM_T 2 bc_thm_tac THEN strip_tac THEN asm_rewrite_tac[]);
val €poly_eval_Ä_poly_thm› = pop_thm ();
=TEX
For the reverse inclusion, and for later use, it is convenient
to prove an induction theorem for polynomials and use it
to derive an induction tactic:
%%%%
%%%%
=SML
set_goal([], ¨µp∑
		(µc∑p(Ãx∑c))
	±	(p(Ãx∑x))
	±	(µf g∑p f ± p g ¥  p(Ãx∑f x + g x))
	±	(µf g∑p f ± p g ¥ p(Ãx∑f x * g x))
	¥	(µh∑ h ç PolyFunc ¥ p h)
Æ);
a(rewrite_tac[poly_func_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(PC_T1 "sets_ext1" POP_ASM_T (strip_asm_tac o µ_elim ¨{h | p h}Æ)
	THEN1 asm_prove_tac[] THEN all_asm_fc_tac[]);
val €poly_induction_thm› = save_pop_thm "poly_induction_thm";
=TEX
Now the tactic, which expects a term of the form $f \in \mbox{\it PolyFunc}$ to
be in the assumptions (where $f$ is the induction variable).
%%%%
%%%%
=SML
fun €poly_induction_tac› (tm : TERM) : TACTIC = (
	if not (is_var tm andalso type_of tm =: îØ ≠ ØÆ)
	then term_fail "poly_induction_tac" 999001 [tm]
	else ( fn(asms, conc) =>
	let	val asm = find asms (fn t =>  
			let	val (x, s) = dest_bin_op "" 0 "ç" t;
			in	x =$ tm andalso s =$ ¨PolyFuncÆ
			end	handle Fail _ => false)
			handle Fail _ => fail "poly_induction_tac" 999002 [];
	in	if not (is_free_in tm conc)
			then term_fail "poly_induction_tac" 999003 [tm]
		else if any (asms drop (fn t => t =$ asm)) (is_free_in tm)
			then term_fail "poly_induction_tac" 999004 [tm]
		else	(asm_ante_tac asm THEN gen_induction_tac1 poly_induction_thm) (asms, conc)
	end
	)
);
=TEX
%%%%
%%%%
=SML
set_goal([], ¨PolyFunc Ä {f | ∂l∑ f = PolyEval l}Æ);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(poly_induction_tac¨xÆ);
(* *** Goal "1" *** *)
a(ante_tac const_eval_thm THEN prove_tac[]);
(* *** Goal "2" *** *)
a(ante_tac id_eval_thm THEN prove_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨PlusCoeffs l l'Æ THEN pure_asm_rewrite_tac[plus_eval_thm] THEN strip_tac);
(* *** Goal "4" *** *)
a(∂_tac¨TimesCoeffs l l'Æ THEN pure_asm_rewrite_tac[times_eval_thm] THEN strip_tac);
val €poly_Ä_poly_eval_thm› = pop_thm ();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨PolyFunc = {f | ∂l∑ f = PolyEval l}Æ);
a(rewrite_tac[poly_Ä_poly_eval_thm, poly_eval_Ä_poly_thm,
	pc_rule1 "sets_ext1" prove_rule[] ¨µa b∑a = b § a Ä b ± b Ä aÆ]);
val €poly_func_eq_poly_eval_thm› = save_pop_thm "poly_func_eq_poly_eval_thm";
=TEX
For convenience, it is useful to have the theorems that say that the
different kinds of polynomial construction do lead to polynomial functions:
%%%%
%%%%
=SML
set_goal([], ¨µc∑(Ãx∑c) ç PolyFuncÆ);
a(pure_rewrite_tac[const_eval_thm, poly_func_eq_poly_eval_thm]);
a(PC_T1 "sets_ext1" prove_tac[]);
val €const_poly_func_thm› = save_pop_thm "const_poly_func_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨(Ãx∑x) ç PolyFuncÆ);
a(pure_rewrite_tac[id_eval_thm, poly_func_eq_poly_eval_thm]);
a(PC_T1 "sets_ext1" prove_tac[]);
val €id_poly_func_thm› = save_pop_thm "id_poly_func_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g∑ f ç PolyFunc ± g ç PolyFunc ¥ (Ãx∑f x + g x) ç PolyFuncÆ);
a(pure_rewrite_tac[poly_func_eq_poly_eval_thm] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN pure_rewrite_tac[plus_eval_thm]
	THEN PC_T1 "predicates" prove_tac[]);
val €plus_poly_func_thm› = save_pop_thm "plus_poly_func_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g∑ f ç PolyFunc ± g ç PolyFunc ¥ (Ãx∑f x * g x) ç PolyFuncÆ);
a(pure_rewrite_tac[poly_func_eq_poly_eval_thm] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN pure_rewrite_tac[times_eval_thm]
	THEN PC_T1 "predicates" prove_tac[]);
val €times_poly_func_thm› = save_pop_thm "times_poly_func_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g∑ f ç PolyFunc ± g ç PolyFunc ¥ (Ãx∑f(g x)) ç PolyFuncÆ);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(intro_µ_tac(¨gÆ, ¨gÆ) THEN poly_induction_tac¨fÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[const_poly_func_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[»_axiom]);
(* *** Goal "3" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(rewrite_tac[] THEN ALL_FC_T (MAP_EVERY ante_tac) [plus_poly_func_thm]);
a(rewrite_tac[] THEN taut_tac);
(* *** Goal "4" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(rewrite_tac[] THEN ALL_FC_T (MAP_EVERY ante_tac) [times_poly_func_thm]);
a(rewrite_tac[] THEN taut_tac);
val €comp_poly_func_thm› = save_pop_thm "comp_poly_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl1 l2 x∑ PolyEval (l1 @ l2) x = PolyEval l1 x + x^Length l1 * PolyEval l2 x
Æ);
a(REPEAT strip_tac THEN list_induction_tac¨l1:Ø LISTÆ THEN
	asm_rewrite_tac[rev_def, poly_eval_def, length_def, Ø_Ó_exp_def, append_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €poly_eval_append_thm› = save_pop_thm "poly_eval_append_thm";
=TEX
We are now going to prove various identities for polynomials.
The following result gives the rule for evaluating a polynomial starting with the
leading term.
%%%%
%%%%
=SML
set_goal([], ¨
	(µx∑ PolyEval (Rev []) x = ÓØ 0)
±	(µc l x∑ PolyEval (Rev (Cons c l)) x = c*x^Length l + PolyEval (Rev l) x)
Æ);
a(REPEAT strip_tac THEN1 rewrite_tac[rev_def, poly_eval_def]);
a(intro_µ_tac(¨cÆ, ¨cÆ) THEN list_induction_tac¨lÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[rev_def, poly_eval_def, length_def, Ø_Ó_exp_def, append_def]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
a(rewrite_tac[rev_def, poly_eval_def, length_def, Ø_Ó_exp_def, append_def,
	poly_eval_append_thm, length_rev_append_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €poly_eval_rev_thm› = save_pop_thm "poly_eval_rev_thm";
=TEX
The following is the identity for the difference of two like powers:
\[
(x-y)(x^n + yx^{n-1} + \ldots + y^jx^{n-j} + \ldots y^n) = x^{n+1} - y^{n+1}
\]
%%%%
%%%%
=SML
set_goal([], ¨
	µn x y∑ (x - y)*PolyEval (Rev((Ãm∑y^m) To (n+1))) x = x^(n+1) - y^(n+1)
Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ);
(* *** Goal "1" *** *)
a(pure_rewrite_tac[to_def, Ø_Ó_exp_def, append_def, poly_eval_def, rev_def]);
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(pure_once_rewrite_tac[to_def, Ø_Ó_exp_def]);
a(pure_asm_rewrite_tac[rev_append_thm, rev_def, poly_eval_append_thm,
	append_empty_thm, Ø_times_plus_distrib_thm, length_def, Ø_Ó_exp_def,
	µ_elim¨x * ÓØ 1Æ Ø_times_order_thm]);
a(rewrite_tac[poly_eval_def, Ø_Ó_exp_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €poly_diff_powers_thm› = save_pop_thm "poly_diff_powers_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨
	µl1 l2∑ Length(PlusCoeffs l1 l2) = if Length l2 < Length l1 then Length l1 else Length l2
Æ);
a(µ_tac THEN list_induction_tac¨l1:Ø LISTÆ THEN1 rewrite_tac[length_def, plus_coeffs_def]);
a(REPEAT strip_tac THEN list_induction_tac¨l2:Ø LISTÆ THEN
	 asm_rewrite_tac[length_def, plus_coeffs_def]);
a(cases_tac¨Length l2 < Length l1Æ THEN asm_rewrite_tac[]);
val €length_plus_coeffs_thm› = save_pop_thm "length_plus_coeffs_thm";
=TEX
The following is the special case of polynomial division in which the divisor
is linear. In this special case, we do not need the notion of the degree of
a polynomial to state the result (which is very fortunate, since we plan to
use this in deriving the theory of polynomial degrees). In informal notation
the result is that if $f$ is any polynomial (the one whose coefficient
list is given by $l1$ in the formal statement), then there is another polynomial
$g$ (the one whose coefficients are given by $l2$ in the formal statement)
with a shorter list of coefficients and such that $f(x) = (x-a)g(x) + r$
for some real number $r$.

The proof below follows a slightly different pattern from the text book
proof, which works by induction on the degree of the dividend (to divide
$f = a_{n+1}x^{n+1} + a_{n}x^{n} + \ldots + a_0$ by $x - c$, one has
$f - a_nx^{n}(x-c) = g$ where $g$ has degree less than that of $f$ and
one proceeds by induction on the degrees). Here, we use list induction
on the list of coefficients (reversed, i.e., leading coefficient first).
If $f =a_{n+1}x^n + a_{n}x^{n} + \ldots + a_0$, then by a list induction,
we can write $h = a_{n}x^{n} + \ldots + a_0$ as $(x-c)h_1 + r_1$
where the list of coefficients for $h_1$ is shorter than that for
$h$ and we can write $a_{n+1}x^{n+1}$ as $a_{n+1}(x - c)(x^n + cx^{n-1} + \ldots + c^n) + a_{n+1}c^{n+1}$, by the identity for the difference of two like powers. Adding
these representations for $h$ and $a_{n+1}x^{n+1}$ gives the required representation
for $f$. There is not much to choose between the two approaches except that this one
involves less fiddling around with lists of coefficients given the tools we have to hand.

%%%%
%%%%
=SML
set_goal([], ¨
	µl1 c∑ ≥l1 = []
¥	∂l2 r∑
		Length l2 < Length l1 
	±	(Ãx∑ PolyEval l1 x) = (Ãx∑ (x - c)*PolyEval l2 x + r)
Æ);
a(lemma_tac¨
	µl1 c∑ ≥l1 = []
¥	∂l2 r∑
		Length l2 < Length l1 
	±	(Ãx∑ PolyEval (Rev l1) x) = (Ãx∑ (x - c)*PolyEval l2 x + r)Æ);
(* *** Goal "1" *** *)
a(REPEAT µ_tac THEN list_induction_tac¨l1 : Ø LISTÆ THEN1 rewrite_tac[]);
(* *** Goal "1.1" *** *)
a(all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(∂_tac¨[]Æ THEN ∂_tac¨xÆ THEN
	rewrite_tac[length_def, rev_def, poly_eval_def, append_empty_thm]);
(* *** Goal "1.2" *** *)
a(pure_rewrite_tac[poly_eval_rev_thm]);
a(REPEAT strip_tac);
a(lemma_tac¨∂m∑m + 1 = Length l1Æ THEN1
	(GET_NTH_ASM_T 3 ante_tac THEN rewrite_tac[less_def, º_def]
	THEN REPEAT strip_tac THEN ∂_tac¨Length l2 + iÆ
	THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(∂_tac¨PlusCoeffs(Map (Ãt∑x*t) (Rev ((Ã j∑ c ^ j) To (m + 1)))) l2Æ
	THEN ∂_tac¨x*c^(m+1) + rÆ);
a(REPEAT strip_tac THEN1
	asm_rewrite_tac[length_to_thm, length_plus_coeffs_thm,
		length_rev_append_thm, length_def, length_map_thm]);
a(pure_rewrite_tac (map (conv_rule (ONCE_MAP_C eq_sym_conv))
		[const_times_eval_thm, plus_eval_thm]));
a(GET_NTH_ASM_T 3 (pure_rewrite_thm_tac o rewrite_rule[]));
a(PC_T1 "predicates" rewrite_tac[]);
a(pure_asm_rewrite_tac[µ_elim¨xÆØ_times_order_thm,
	Ø_times_plus_distrib_thm, poly_diff_powers_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(lemma_tac¨≥Rev l1 = []Æ THEN1 asm_rewrite_tac[rev_eq_empty_thm]);
a(list_spec_nth_asm_tac 3 [¨Rev l1Æ, ¨cÆ]);
a(DROP_NTH_ASM_T 2 (asm_tac o rewrite_rule[length_rev_append_thm]));
a(DROP_NTH_ASM_T 2 (asm_tac o rewrite_rule[rev_rev_thm]));
a(∂_tac ¨l2Æ THEN ∂_tac ¨rÆ THEN asm_rewrite_tac[]);
val €poly_linear_div_thm› = save_pop_thm "poly_linear_div_thm";
=TEX
We can now prove that a polynomial in $x$ which vanishes for all sufficiently
large $x$ is identically zero.
%%%%
%%%%
=SML
set_goal([], ¨µf c∑
	f ç PolyFunc ± (µx∑ c < x ¥ f x = ÓØ 0)
¥	(µx∑f x = ÓØ 0)
Æ);
a(lemma_tac¨µm l c∑ Length l º m ± (µx∑ c < x ¥ PolyEval l x = ÓØ 0)
¥	(µx∑PolyEval l x = ÓØ 0)
Æ);
(* *** Goal "1" *** *)
a(µ_tac THEN induction_tac¨m:ÓÆ THEN1 REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(all_fc_tac[length_eq_0_thm] THEN asm_rewrite_tac[poly_eval_def]);
(* *** Goal "1.2" *** *)
a(REPEAT µ_tac THEN ¥_tac);
a(cases_tac¨Length l º mÆ THEN1
	(GET_NTH_ASM_T 4 bc_thm_tac THEN asm_prove_tac[]));
a(lemma_tac ¨Length l = m + 1Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(lemma_tac¨≥l = []Æ THEN1
	(contr_tac THEN all_var_elim_asm_tac1 THEN all_asm_ante_tac
	THEN rewrite_tac[length_def]));
a(strip_asm_tac(rewrite_rule[]
	(list_µ_elim[¨lÆ, ¨c + ÓØ 1Æ] poly_linear_div_thm)));
a(TOP_ASM_T (ante_tac o µ_elim¨c + ÓØ 1Æ) THEN
	conv_tac(ONCE_MAP_C Ø_anf_conv));
a(GET_NTH_ASM_T 6 (rewrite_thm_tac o rewrite_rule[] o µ_elim¨ÓØ 1 + cÆ));
a(strip_tac THEN all_var_elim_asm_tac1);
a(lemma_tac¨Length l2 º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(lemma_tac¨µ x∑ c + ÓØ 1 < x ¥ PolyEval l2 x = ÓØ 0Æ);
(* *** Goal "1.2.1" *** *)
a(swap_nth_asm_concl_tac 2 THEN REPEAT strip_tac);
a(lemma_tac¨c < xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(∂_tac¨xÆ THEN LIST_GET_NTH_ASM_T [9] (ALL_FC_T rewrite_tac));
a(conv_tac (RAND_C eq_sym_conv) THEN rewrite_tac[Ø_times_eq_0_thm]);
a(REPEAT strip_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2" *** *)
a(list_spec_nth_asm_tac 10 [¨l2Æ, ¨c + ÓØ 1Æ] THEN1 all_asm_fc_tac[]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext" rewrite_tac[poly_func_eq_poly_eval_thm] THEN
	REPEAT µ_tac THEN ¥_tac);
a(asm_rewrite_tac[] THEN GET_NTH_ASM_T 3 bc_thm_tac);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a(∂_tac¨cÆ THEN ∂_tac¨Length lÆ THEN asm_rewrite_tac[]);
val €poly_eventually_0_eq_0_thm› = save_pop_thm "poly_eventually_0_eq_0_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Lemmas about Real Arithmetic}
%%%%
%%%%
%%%%
%%%%
\subsubsection{Lemmas about the Absolute Value Function}
%%%%
%%%%
%%%%
%%%%
We will need a number of facts about absolute values etc.
=TEX
Absolute values are non-negative:
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx:Ø∑ ÓØ 0 º Abs xÆ);
a(REPEAT strip_tac THEN rewrite_tac[get_spec¨AbsâRÆ]);
a(cases_tac ¨ÓØ 0 º xÆ
	THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_0_º_abs_thm› = save_pop_thm "Ø_0_º_abs_thm";
=TEX
Next, the triangle inequality:
%%%%
%%%%
=SML
set_goal([], ¨µx y:Ø∑ Abs(x + y) º Abs x + Abs yÆ);
a(REPEAT strip_tac THEN rewrite_tac[get_spec¨AbsâRÆ]);
a(MAP_EVERY cases_tac [¨ÓØ 0 º xÆ, ¨ÓØ 0 º yÆ, ¨ÓØ 0 º x + yÆ]
	THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_abs_plus_thm› = save_pop_thm "Ø_abs_plus_thm";
=TEX
\ldots and the triangle inequality for subtraction:
%%%%
%%%%
=SML
set_goal([], ¨µx y:Ø∑ Abs(x - y) º Abs x + Abs yÆ);
a(REPEAT strip_tac THEN rewrite_tac[get_spec¨AbsâRÆ]);
a(MAP_EVERY cases_tac [¨ÓØ 0 º xÆ, ¨ÓØ 0 º yÆ, ¨ÓØ 0 º x + ~yÆ]
	THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_abs_subtract_thm› = save_pop_thm "Ø_abs_subtract_thm";
val €Ø_abs_plus_minus_thm› = save_thm ("Ø_abs_plus_minus_thm", rewrite_rule[]Ø_abs_subtract_thm);
=TEX
\ldots and again in a formulation that is nice for back-chaining:
%%%%
%%%%
=SML
set_goal([], ¨µx y z:Ø∑ ÓØ 0 < z ¥ (Abs (x + ~y) < z § y + ~z <  x ± x < y + z)Æ);
a(REPEAT µ_tac THEN ¥_tac THEN cases_tac¨ÓØ 0 º x + ~yÆ THEN
	asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_abs_diff_bounded_thm› = save_pop_thm "Ø_abs_diff_bounded_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx y z:Ø∑ Abs x º Abs (y + z) ¥ Abs x º Abs y + Abs zÆ);
a(REPEAT strip_tac THEN bc_thm_tac Ø_º_trans_thm);
a(∂_tac¨Abs(y + z)Æ THEN asm_rewrite_tac[Ø_abs_plus_thm]);
val €Ø_abs_plus_bc_thm› = save_pop_thm "Ø_abs_plus_bc_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx y:Ø∑ Abs (Abs x - Abs y) º Abs (x - y)Æ);
a(REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨x - yÆ, ¨yÆ]Ø_abs_plus_thm) THEN rewrite_tac[Ø_plus_assoc_thm]);
a(strip_tac THEN lemma_tac ¨Abs x + ~(Abs y) º Abs (x + ~y)Æ THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ante_tac(list_µ_elim[¨y - xÆ, ¨xÆ]Ø_abs_plus_thm) THEN rewrite_tac[Ø_plus_assoc_thm]);
a(strip_tac THEN LEMMA_T ¨Abs y + ~(Abs x) º Abs (~(~y + x))Æ ante_tac THEN1
	(rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(rewrite_tac[Ø_abs_minus_thm, pc_rule1 "Ø_lin_arith" prove_rule[]¨~y + x = x + ~yÆ]);
a(strip_tac THEN conv_tac(LEFT_C (once_rewrite_conv[Ø_abs_def])));
a(cases_tac¨ÓØ 0 º Abs x + ~(Abs y)Æ THEN asm_rewrite_tac[] THEN_TRY
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_abs_abs_minus_thm› = save_pop_thm "Ø_abs_abs_minus_thm";
=TEX
The absolute value function is idempotent:
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx:Ø∑ Abs(Abs x) = Abs(x)Æ);
a(REPEAT strip_tac);
a(conv_tac (LEFT_C (once_rewrite_conv[Ø_abs_def])));
a(rewrite_tac [Ø_0_º_abs_thm]);
val €Ø_abs_abs_thm› = save_pop_thm "Ø_abs_abs_thm";
=TEX
Absolute values commute with multiplication:
%%%%
%%%%
=SML
set_goal([], ¨µx y:Ø∑ Abs(x * y) = Abs x * Abs yÆ);
a(lemma_tac ¨µx y:Ø∑ ÓØ 0 º x ± ÓØ 0 º y ¥ Abs(x * y) = Abs x * Abs yÆ
	THEN REPEAT strip_tac THEN1 (all_fc_tac[Ø_0_º_0_º_times_thm]
		THEN asm_rewrite_tac[get_spec¨AbsâRÆ]));
a(cases_tac¨ÓØ 0 º xÆ THEN cases_tac¨ÓØ 0 º yÆ THEN1 all_asm_fc_tac[]);
(* *** Goal "1" *** *)
a(lemma_tac¨ÓØ 0 º ~yÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_ASM_FC_T (MAP_EVERY ante_tac)[]);
a(LEMMA_T ¨x* ~y = ~(x*y)Æ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(rewrite_tac[Ø_abs_minus_thm]);
(* *** Goal "2" *** *)
a(lemma_tac¨ÓØ 0 º ~xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_ASM_FC_T (MAP_EVERY ante_tac)[]);
a(LEMMA_T ¨~x * y = ~(x*y)Æ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(rewrite_tac[Ø_abs_minus_thm] THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(lemma_tac¨ÓØ 0 º ~x ± ÓØ 0 º ~yÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_ASM_FC_T (MAP_EVERY ante_tac)[]);
a(LEMMA_T ¨~x * ~y = (x*y)Æ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(rewrite_tac[Ø_abs_minus_thm]);
val €Ø_abs_times_thm› = save_pop_thm "Ø_abs_times_thm";
=TEX
Absolute values commute with powers:
%%%%
%%%%
=SML
set_goal([], ¨µx:Ø; m∑ Abs(x ^ m) = Abs x ^ mÆ);
a(REPEAT strip_tac THEN induction_tac¨m:ÓÆ THEN asm_rewrite_tac[Ø_Ó_exp_def, Ø_abs_times_thm]);
val €Ø_abs_Ø_Ó_exp_thm› = save_pop_thm "Ø_abs_Ø_Ó_exp_thm";
=TEX
Only 0 has absolute value 0:
%%%%
%%%%
=SML
set_goal([], ¨µx∑ Abs x = ÓØ 0 § x = ÓØ 0Æ);
a(strip_tac THEN rewrite_tac[get_spec¨AbsâRÆ]);
a(cases_tac¨ÓØ 0 º xÆ THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €Ø_abs_eq_0_thm› = save_pop_thm "Ø_abs_eq_0_thm";
=TEX
Only 0 has a non-positive absolute value:
%%%%
%%%%
=SML
set_goal([], ¨µx∑ Abs x º ÓØ 0 § x = ÓØ 0Æ);
a(strip_tac THEN rewrite_tac[get_spec¨AbsâRÆ]);
a(cases_tac¨ÓØ 0 º xÆ THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_abs_º_0_thm› = save_pop_thm "Ø_abs_º_0_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨Abs (ÓØ 0) = ÓØ 0Æ);
a(rewrite_tac[]);
val €Ø_abs_0_thm› = save_pop_thm "Ø_abs_0_thm";
=TEX
Absolute values commute with reciprocal:
%%%%
%%%%
=SML
set_goal([], ¨µx∑ ≥x = ÓØ 0 ¥ Abs (x õ-õ1) = (Abs x) õ-õ1Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨Abs(x * x õ-õ1) = ÓØ 1Æ ante_tac THEN1
	(ALL_FC_T rewrite_tac[Ø_times_recip_thm]));
a(rewrite_tac[Ø_abs_times_thm] THEN strip_tac);
a(lemma_tac¨≥Abs x = ÓØ 0ÆTHEN1 asm_rewrite_tac[Ø_abs_eq_0_thm]);
a(LEMMA_T¨(Abs x * (Abs x) õ-õ1) * Abs(x õ-õ1) = (Abs x)õ-õ1Æ ante_tac THEN1
	asm_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b c:Ø∑(a*b)*c = b*a*cÆ]);
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
val €Ø_abs_recip_thm› = save_pop_thm "Ø_abs_recip_thm";
=TEX
A monotonicity property for absolute values and multiplication:
%%%%
%%%%
=SML
set_goal([], ¨µx t y u:Ø∑ Abs x < t ± Abs y < u ¥ Abs x * Abs y < t*uÆ);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim¨xÆ Ø_0_º_abs_thm));
a(strip_asm_tac (µ_elim¨yÆ Ø_0_º_abs_thm));
a(lemma_tac¨ÓØ 0 < t ± ÓØ 0 < uÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(cases_tac ¨Abs x = ÓØ 0Æ THEN1 
	(all_fc_tac[Ø_0_less_0_less_times_thm] THEN asm_rewrite_tac[]));
a(cases_tac ¨Abs y = ÓØ 0Æ THEN1 
	(all_fc_tac[Ø_0_less_0_less_times_thm] THEN asm_rewrite_tac[]));
a(lemma_tac ¨ÓØ 0 < Abs x ± ÓØ 0 < Abs yÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(bc_thm_tac Ø_less_trans_thm);
a(∂_tac¨Abs x * uÆ THEN REPEAT strip_tac
	THEN1 bc_thm_tac Ø_times_mono_thm THEN REPEAT strip_tac);
a(once_rewrite_tac[Ø_times_comm_thm]
	THEN bc_thm_tac Ø_times_mono_thm THEN REPEAT strip_tac);
val €Ø_abs_less_times_thm› = save_pop_thm "Ø_abs_less_times_thm";
=TEX
Non-zero numbers have positive absolute values:
%%%%
%%%%
=SML
set_goal([], ¨µx∑ ≥x = ÓØ 0 § ÓØ 0 < Abs xÆ);
a(REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 º Abs xÆ THEN1 rewrite_tac[Ø_0_º_abs_thm]);
a(lemma_tac¨≥ Abs x = ÓØ 0Æ THEN1 asm_rewrite_tac[Ø_abs_eq_0_thm]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
val €Ø_≥_0_abs_thm› = save_pop_thm "Ø_≥_0_abs_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µa x b d:Ø∑a < x ± x < b ± ÓØ 0 < d
¥	∂c∑ÓØ 0 < c ± c < d ± µy∑Abs(y + ~x) < c ¥ a < y ± y < bÆ);
a(REPEAT strip_tac);
a(∂_tac¨ (1/2)*
	if	x + ~ a º b + ~ x ± x + ~ a º d
	then	x + ~ a
	else if	d º x + ~ a ± d º b + ~x
	then	d
	else	b + ~ x Æ THEN REPEAT_UNTIL is_¥ strip_tac
	THEN_TRY(cases_tac¨ÓØ 0 º y +  ~xÆ THEN asm_rewrite_tac[Ø_abs_def]) THEN
	cases_tac¨x + ~ a º b + ~ x ± x + ~ a º dÆ THEN
	cases_tac ¨d º x + ~ a ± d º b + ~xÆ THEN_TRY
	asm_rewrite_tac[] THEN_TRY
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €axbd_thm› = pop_thm ();
=TEX
\subsection{Other Algebraic Lemmas}
Reciprocal of positive reals is order reversing:
%%%%
%%%%
=SML
set_goal([], ¨µx y:Ø∑ ÓØ 0 < x ± ÓØ 0 < y ± x < y ¥ y õ-õ1 < x õ-õ1Æ);
a(REPEAT strip_tac);
a(lemma_tac¨y õ-õ1 * x õ-õ1 * x < y õ-õ1 * x õ-õ1 * yÆ);
(* *** Goal "1" *** *)
a(all_fc_tac[Ø_0_less_0_less_recip_thm]);
a(REPEAT (bc_thm_tac Ø_times_mono_thm THEN REPEAT strip_tac));
(* *** Goal "2" *** *)
a(lemma_tac¨≥x = ÓØ 0 ± ≥y = ÓØ 0Æ THEN1
	(LIST_GET_NTH_ASM_T [3, 4] (MAP_EVERY ante_tac) THEN
		PC_T1 "Ø_lin_arith" prove_tac[]));
a(DROP_NTH_ASM_T 3 ante_tac);
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨
	y õ-õ1 * x õ-õ1 * x = y õ-õ1 * (x * x õ-õ1)
±	y õ-õ1 * x õ-õ1 * y = x õ-õ1 * (y * y õ-õ1)Æ]);
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
val €Ø_less_recip_less_thm› = save_pop_thm "Ø_less_recip_less_thm";
=TEX
The following algebraic lemma is used often enough to be worth recording:
it says that, providing both sides are well-defined, $1/x+1/y = (x+y)/xy$.
%%%%
%%%%
=SML
set_goal([], ¨µx y∑ ≥x = ÓØ 0 ± ≥y = ÓØ 0 ¥
	(x õ-õ1 + y õ-õ1) = (x + y) * x õ-õ1 * y õ-õ1Æ);
a(REPEAT strip_tac THEN conv_tac (RIGHT_C Ø_anf_conv));
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
a(rewrite_tac[Ø_times_assoc_thm1] THEN ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
val €Ø_plus_recip_thm› = save_pop_thm"Ø_plus_recip_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µm∑ ÓØ 0 ^ (m+1) = ÓØ 0 ± ÓØ 1 ^ m = ÓØ 1Æ);
a(µ_tac THEN induction_tac¨m:ÓÆ THEN asm_rewrite_tac[Ø_Ó_exp_def]);
val €Ø_Ó_exp_0_1_thm› = save_pop_thm "Ø_Ó_exp_0_1_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µm x ∑ ÓØ 0 < x ¥ ÓØ 0 < x^mÆ);
a(REPEAT strip_tac THEN induction_tac¨m:ÓÆ THEN asm_rewrite_tac[Ø_Ó_exp_def]);
a(all_fc_tac[Ø_0_less_0_less_times_thm]);
val €Ø_Ó_exp_0_less_thm› = save_pop_thm "Ø_Ó_exp_0_less_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µx m∑ ÓØ 1 < x ¥ x^m < x^(m+1) Æ);
a(REPEAT strip_tac THEN induction_tac¨m:ÓÆ THEN1 asm_rewrite_tac[Ø_Ó_exp_def]);
a(once_rewrite_tac[Ø_Ó_exp_def]);
a(bc_thm_tac Ø_times_mono_thm THEN REPEAT strip_tac);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_Ó_exp_1_less_mono_thm› = save_pop_thm "Ø_Ó_exp_1_less_mono_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µx m n∑ÓØ 1 < x ± m < n ¥ x^m < x^n Æ);
a(REPEAT µ_tac THEN induction_tac¨n:ÓÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a( lemma_tac¨n = mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac THEN ALL_FC_T rewrite_tac [Ø_Ó_exp_1_less_mono_thm]);
(* *** Goal "2" *** *)
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨x^nÆ THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac [Ø_Ó_exp_1_less_mono_thm]);
val €Ø_Ó_exp_1_less_mono_thm1› = save_pop_thm "Ø_Ó_exp_1_less_mono_thm1";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µx y z ∑ ÓØ 0 º x ± y º z ¥ x*y º x*zÆ);
a(rewrite_tac[Ø_º_def] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(all_fc_tac[Ø_times_mono_thm]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1 THEN rewrite_tac[]);
val €Ø_º_times_mono_thm› = save_pop_thm "Ø_º_times_mono_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µm x ∑ ≥x = ÓØ 0 ¥ ≥ x^m = ÓØ 0Æ);
a(REPEAT strip_tac THEN induction_tac¨m:ÓÆ THEN asm_rewrite_tac[Ø_Ó_exp_def]);
a(rewrite_tac[Ø_times_eq_0_thm] THEN REPEAT strip_tac);
val €Ø_Ó_exp_≥_eq_0_thm› = save_pop_thm "Ø_Ó_exp_≥_eq_0_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µx:Ø; m n∑ x^(m+n) = x^m * x^nÆ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ THEN
	asm_rewrite_tac[Ø_Ó_exp_def, plus_assoc_thm1]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €Ø_Ó_exp_plus_thm› = save_pop_thm "Ø_Ó_exp_plus_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µx y:Ø; m∑ (x*y)^m = x^m * y^mÆ);
a(REPEAT strip_tac THEN induction_tac¨m:ÓÆ THEN rewrite_tac[Ø_Ó_exp_def]);
a(asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €Ø_Ó_exp_times_thm› = save_pop_thm "Ø_Ó_exp_times_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µm x ∑ ≥x = ÓØ 0 ¥ (x^m)õ-õ1 = (x õ-õ1)^mÆ);
a(REPEAT strip_tac THEN induction_tac¨m:ÓÆ THEN asm_rewrite_tac[Ø_Ó_exp_def]);
a(lemma_tac ¨≥ x^m = ÓØ 0Æ THEN1 (bc_thm_tac Ø_Ó_exp_≥_eq_0_thm THEN REPEAT strip_tac));
a(ALL_FC_T asm_rewrite_tac[Ø_recip_clauses]);
val €Ø_Ó_exp_recip_thm› = save_pop_thm "Ø_Ó_exp_recip_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µm x ∑ ≥x = ÓØ 0 ¥  (x õ-õ1)^m = (x^m)õ-õ1Æ);
a(REPEAT strip_tac THEN ALL_FC_T rewrite_tac[Ø_Ó_exp_recip_thm]);
val €Ø_Ó_exp_recip_thm1› = save_pop_thm "Ø_Ó_exp_recip_thm1";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µm x ∑ ÓØ 1 º x ¥ ÓØ 1 º x^m Æ);
a(REPEAT strip_tac THEN induction_tac¨m:ÓÆ THEN1 asm_rewrite_tac[Ø_Ó_exp_def]);
a(rewrite_tac[Ø_Ó_exp_def] THEN bc_thm_tac Ø_º_trans_thm);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
a(conv_tac (LEFT_C(pure_once_rewrite_conv[prove_rule[]¨x = x * ÓØ 1Æ])));
a(bc_thm_tac Ø_º_times_mono_thm THEN REPEAT strip_tac);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_Ó_exp_1_º_thm› = save_pop_thm "Ø_Ó_exp_1_º_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µx m∑ÓØ 0 < x ± x < ÓØ 1 ¥ x^(m+1) < x^m Æ);
a(REPEAT strip_tac THEN induction_tac¨m:ÓÆ THEN1 asm_rewrite_tac[Ø_Ó_exp_def]);
a(once_rewrite_tac[Ø_Ó_exp_def]);
a(bc_thm_tac Ø_times_mono_thm THEN REPEAT strip_tac);
val €Ø_Ó_exp_less_1_mono_thm› = save_pop_thm "Ø_Ó_exp_less_1_mono_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µx m∑ÓØ 0 < x ¥ ÓØ 0 < x^m Æ);
a(REPEAT strip_tac THEN induction_tac¨m:ÓÆ THEN asm_rewrite_tac[Ø_Ó_exp_def]);
a(bc_thm_tac Ø_0_less_0_less_times_thm THEN REPEAT strip_tac);
val €Ø_Ó_exp_less_mono_thm› = save_pop_thm "Ø_Ó_exp_less_mono_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx m n∑ÓØ 0 < x ± x < ÓØ 1 ± m < n ¥ x^n < x^m Æ);
a(REPEAT µ_tac THEN induction_tac¨n:ÓÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a( lemma_tac¨n = mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac THEN ALL_FC_T rewrite_tac [Ø_Ó_exp_less_1_mono_thm]);
(* *** Goal "2" *** *)
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨x^nÆ THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac [Ø_Ó_exp_less_1_mono_thm]);
val €Ø_Ó_exp_less_1_mono_thm1› = save_pop_thm "Ø_Ó_exp_less_1_mono_thm1";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx m∑ÓØ 0 < x ¥ ÓØ 1 + ÓØ m*x º (ÓØ 1 + x)^m Æ);
a(REPEAT strip_tac THEN induction_tac¨m:ÓÆ THEN
	once_asm_rewrite_tac[Ø_Ó_exp_def]
	THEN1 rewrite_tac[Ø_Ó_exp_0_1_thm]);
a(rewrite_tac[ÓØ_plus_homomorphism_thm, Ø_times_plus_distrib_thm]);
a(contr_tac);
a(all_fc_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b c d:Ø∑a º b ± ≥d º c ¥ a + c < b + dÆ]);
a(POP_ASM_T ante_tac THEN rewrite_tac[]);
a(once_rewrite_tac[Ø_less_0_less_thm] THEN rewrite_tac[] THEN conv_tac(ONCE_MAP_C Ø_anf_conv));
a(rewrite_tac[Ø_≥_less_º_thm]);
a(lemma_tac¨ÓØ 1 º (ÓØ 1 + x)^mÆ THEN1
	(bc_thm_tac Ø_Ó_exp_1_º_thm THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(LEMMA_T¨x º x*(ÓØ 1 + x) ^mÆ ante_tac THEN_LIST [id_tac, PC_T1 "Ø_lin_arith" prove_tac[]]);
a(conv_tac(LEFT_C(pure_once_rewrite_conv[prove_rule[]¨x = x * ÓØ 1Æ])));
a(bc_thm_tac Ø_º_times_mono_thm THEN REPEAT strip_tac);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_Ó_exp_linear_estimate_thm› = save_pop_thm "Ø_Ó_exp_linear_estimate_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsubsection{The Archimedean Property}
%%%%
%%%%
%%%%
%%%%
We present the archimedean property in two guises:
the usual formulation, any real is bounded above by some natural number:
%%%%
%%%%
=SML
set_goal([], ¨µx:Ø∑ ∂m∑ x < ÓØ mÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨xÆ, ¨ÓØ 0Æ]Ø_less_cases_thm) THEN1 asm_prove_tac[]
	THEN1 ∂_tac¨1Æ THEN1 asm_rewrite_tac[]);
a(Ø_delta_induction_tac¨xÆ);
a(∂_tac¨ÓØ 1Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨ÓØ 2Æ THEN REPEAT strip_tac);
a(∂_tac¨3Æ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨m+1Æ THEN rewrite_tac[ÓØ_plus_homomorphism_thm]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_archimedean_thm› = save_pop_thm "Ø_archimedean_thm";
=TEX
\ldots and a reciprocal version: any positive real is bounded
below by the reciprocal of a positive natural number.
%%%%
%%%%
=SML
set_goal([], ¨µx:Ø∑ ÓØ 0 < x ¥ ∂m∑ (ÓØ (m+1))õ-õ1 < xÆ);
a(REPEAT strip_tac THEN all_fc_tac[Ø_0_less_0_less_recip_thm]);
a(strip_asm_tac(µ_elim¨x õ-õ1ÆØ_archimedean_thm));
a(lemma_tac¨x õ-õ1 < ÓØ (m+1)Æ THEN1
	(rewrite_tac[ÓØ_plus_homomorphism_thm] THEN
		bc_thm_tac Ø_less_trans_thm THEN ∂_tac ¨ÓØ mÆ THEN REPEAT strip_tac));
a(DROP_NTH_ASM_T 2 discard_tac);
a(lemma_tac¨ÓØ 0 < ÓØ (m+1)Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [Ø_less_recip_less_thm]);
a(lemma_tac¨≥x = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses] THEN prove_tac[]);
val €Ø_archimedean_recip_thm› = save_pop_thm "Ø_archimedean_recip_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx y∑ÓØ 0 < x ¥ ∂m∑ y < ÓØ m * xÆ);
a(REPEAT strip_tac THEN cases_tac¨≥ÓØ 0 < yÆ THEN1
	(∂_tac¨1Æ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(strip_asm_tac(µ_elim¨yÆØ_archimedean_thm));
a(strip_asm_tac(µ_elim¨xÆØ_archimedean_recip_thm));
a(lemma_tac ¨y < ÓØ(m+1)Æ THEN1
	(rewrite_tac[ÓØ_plus_homomorphism_thm] THEN
		all_fc_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b∑a < b ¥ a < b + ÓØ 1Æ]));
a(DROP_NTH_ASM_T 3 discard_tac);
a(∂_tac¨ (m+1)*(m'+1)Æ);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac ¨(ÓØ ((m + 1)  * (m' + 1))) * ÓØ (m' + 1) õ-õ1Æ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨≥ÓØ(m'+1) = ÓØ 0Æ THEN1 rewrite_tac[ÓØ_one_one_thm]);
a(rewrite_tac[Ø_times_assoc_thm, ÓØ_times_homomorphism_thm]);
a(ALL_FC_T asm_rewrite_tac[Ø_recip_clauses]);
(* *** Goal "2" *** *)
a(bc_thm_tac Ø_times_mono_thm THEN REPEAT strip_tac);
a(rewrite_tac [ÓØ_less_thm]);
a(PC_T1 "lin_arith" prove_tac[]);
val €Ø_archimedean_times_thm› = save_pop_thm "Ø_archimedean_times_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µd y∑ÓØ 0 < d ± ÓØ 0 º y ¥ ∂q r∑ y = ÓØ q * d + r ± ÓØ 0 º r ± r < dÆ);
a(REPEAT strip_tac);
a(lemma_tac¨µm y∑ÓØ 0 º  y ± y < ÓØ m * d ¥ ∂q r∑ y = ÓØ q * d + r ± ÓØ 0 º r ± r < dÆ);
(* *** Goal "1" *** *)
a(POP_ASM_T discard_tac THEN strip_tac THEN induction_tac¨m:ÓÆ);
(* *** Goal "1.1" *** *)
a(rewrite_tac[] THEN REPEAT strip_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(REPEAT strip_tac);
a(cases_tac¨y < dÆ);
(* *** Goal "1.2.1" *** *)
a(∂_tac¨0Æ THEN ∂_tac¨yÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2" *** *)
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[ÓØ_plus_homomorphism_thm]));
a(lemma_tac¨ÓØ 0 º y + ~d Æ	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_fc_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa ∑ y < (a + ÓØ 1) * d ¥ y + ~d< a * dÆ]);
a(LIST_DROP_NTH_ASM_T [6] all_fc_tac);
a(∂_tac¨q + 1Æ THEN ∂_tac¨rÆ THEN
	rewrite_tac[ÓØ_plus_homomorphism_thm, Ø_times_plus_distrib_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1.2.2.1" *** *)
a(all_fc_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa ∑ y + ~d  = a *d + r¥y = (a*d+d)+rÆ]);
(* *** Goal "2" *** *)
a(lemma_tac ¨∂m∑ y < ÓØ m * dÆ THEN1
	(bc_thm_tac Ø_archimedean_times_thm THEN REPEAT strip_tac));
a(LIST_DROP_NTH_ASM_T [2] all_fc_tac);
a(∂_tac¨qÆ THEN ∂_tac¨rÆ THEN REPEAT strip_tac);
val €Ø_archimedean_division_thm› = save_pop_thm "Ø_archimedean_division_thm";
=TEX
\subsection{Further Miscellanea}
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx y∑ÓØ 1 < x ¥ ∂m∑ y <  x^mÆ);
a(REPEAT µ_tac THEN STRIP_T (strip_asm_tac o once_rewrite_rule[Ø_less_0_less_thm]));
a(strip_asm_tac (list_µ_elim[¨x + ~ (ÓØ 1)Æ, ¨yÆ] Ø_archimedean_times_thm));
a(strip_asm_tac (list_µ_elim[¨x + ~ (ÓØ 1)Æ, ¨mÆ] Ø_Ó_exp_linear_estimate_thm));
a(∂_tac¨mÆ THEN1 bc_thm_tac Ø_less_trans_thm);
a(∂_tac¨ÓØ m * (x + ~ (ÓØ 1))Æ THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN conv_tac(ONCE_MAP_C Ø_anf_conv));
a(rewrite_tac[] THEN_TRY conv_tac(ONCE_MAP_C Ø_anf_conv));
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b∑ÓØ 1 + a º b ¥ a < bÆ]);
val €Ø_Ó_exp_tends_to_infinity_thm› = save_pop_thm "Ø_Ó_exp_tends_to_infinity_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx y∑ÓØ 0 < x ± x < ÓØ 1 ± ÓØ 0 < y ¥ ∂m∑ x^m < yÆ);
a(REPEAT strip_tac);
a(lemma_tac¨≥x = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_fc_tac[Ø_≥_recip_0_thm]);
a(strip_asm_tac (rewrite_rule[](list_µ_elim[¨xÆ, ¨ÓØ 1Æ] Ø_less_recip_less_thm)));
a(strip_asm_tac (list_µ_elim[¨x õ-õ1Æ, ¨y õ-õ1Æ] Ø_Ó_exp_tends_to_infinity_thm));
a(∂_tac¨mÆ THEN POP_ASM_T ante_tac);
a(ALL_FC_T rewrite_tac[Ø_Ó_exp_recip_thm1] THEN strip_tac);
a(all_fc_tac[Ø_0_less_0_less_recip_thm]);
a(lemma_tac¨ÓØ 0 < x^mÆ THEN1 ALL_FC_T rewrite_tac[Ø_Ó_exp_0_less_thm]);
a(lemma_tac¨ÓØ 0 < (x^m) õ-õ1Æ THEN1 ALL_FC_T rewrite_tac[Ø_0_less_0_less_recip_thm]);
a(ante_tac (list_µ_elim[¨y õ-õ1Æ, ¨(x^m) õ-õ1Æ] Ø_less_recip_less_thm));
a(lemma_tac¨≥y = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨≥(x^m) = ÓØ 0Æ THEN1 ALL_FC_T rewrite_tac[Ø_Ó_exp_≥_eq_0_thm]);
a(ALL_FC_T asm_rewrite_tac[Ø_recip_clauses]);
val €Ø_Ó_exp_tends_to_0_thm› = save_pop_thm "Ø_Ó_exp_tends_to_0_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx y∑ ÓØ 0 < x ± ÓØ 0 < y ¥ ∂d∑ÓØ 0 < d ± d < x ± d < yÆ);
a(REPEAT strip_tac);
a(cases_tac¨x  <  yÆ THEN_LIST [∂_tac¨(1/2)*xÆ, ∂_tac¨(1/2)*yÆ]
		THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_bound_below_2_thm› = save_pop_thm "Ø_bound_below_2_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µx y z∑ ÓØ 0 < x ± ÓØ 0 < y ± ÓØ 0 <  z ¥ ∂d∑ÓØ 0 < d ± d < x ± d < y ± d < zÆ);
a(REPEAT strip_tac);
a(lemma_tac¨∂c∑ÓØ 0 < c ± c < x ± c < yÆ THEN1
	(bc_thm_tac Ø_bound_below_2_thm THEN REPEAT strip_tac));
a(lemma_tac¨∂d∑ÓØ 0 < d ± d < c ± d < zÆ THEN1
	(bc_thm_tac Ø_bound_below_2_thm THEN REPEAT strip_tac));
a(∂_tac¨dÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_bound_below_3_thm› = save_pop_thm "Ø_bound_below_3_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Limits}
%%%%
%%%%
%%%%
%%%%
We now prove some basic facts about limits.

Firstly, constant sequences have limits:
%%%%
%%%%
=SML
set_goal([], ¨µc∑(Ãm∑ c) -> cÆ);
a(REPEAT strip_tac THEN rewrite_tac[lim_seq_def]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val €const_lim_seq_thm› = save_pop_thm "const_lim_seq_thm";
=TEX
Secondly, if two sequences each have a limit, then so does their
sum and its limit is the sum of the limits:
%%%%
%%%%
=SML
set_goal([], ¨µs1 c1 s2 c2∑
	s1 -> c1 ± s2 -> c2 ¥ (Ãm∑s1 m + s2 m) -> c1 + c2Æ);
a(once_rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac ¨ÓØ 0 < (1/2)*e Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 2  (fn th =>  asm_fc_tac[] THEN asm_tac th));
a(∂_tac¨n + n'Æ THEN REPEAT strip_tac);
a(lemma_tac¨n º m ± n' º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T [5, 6] (ALL_FC_T (MAP_EVERY ante_tac)));
a(rewrite_tac[] THEN
	pure_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[] ¨µa b:Ø∑~a + ~b = ~(a + b)Æ]);
a(FC_T1 fc_§_canon  pure_rewrite_tac[Ø_abs_diff_bounded_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €plus_lim_seq_thm› = save_pop_thm "plus_lim_seq_thm";
=TEX
We now want to give the expected result on the product of two sequences
with limits. We need some preliminaries. The first is of general use,
it says that any sequence with a limit has bounded absolute values:
%%%%
%%%%
=SML
set_goal([], ¨µs c∑ s -> c ¥ ∂b∑ ÓØ 0 < b ± µm∑ Abs(s m) < bÆ);
a(lemma_tac¨µn; s: Ó ≠ Ø; b1∑ ÓØ 0 < b1 ± (µm∑n º m ¥ Abs(s m) < b1) ¥
	(∂b2∑ÓØ 0 < b2 ± µ m∑ Abs(s m) < b2)Æ);
(* *** Goal "1" *** *)
a(strip_tac THEN induction_tac ¨n:ÓÆ THEN1 prove_tac[]);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 bc_thm_tac);
a(∂_tac¨Abs(s n) + b1Æ);
a(spec_nth_asm_tac 1 ¨n+1Æ);
a(strip_asm_tac(µ_elim¨s(n+1)Æ Ø_0_º_abs_thm));
a(strip_asm_tac(µ_elim¨s nÆ Ø_0_º_abs_thm));
a(REPEAT strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(cases_tac¨m' = nÆ THEN1 (all_var_elim_asm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨n + 1 º m'Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 bc_thm_tac);
a(spec_nth_asm_tac 1 ¨ÓØ 1Æ);
a(∂_tac¨nÆ THEN ∂_tac¨Abs c + ÓØ 2Æ);
a(REPEAT strip_tac THEN1
	(strip_asm_tac(µ_elim¨cÆ Ø_0_º_abs_thm) THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(all_asm_fc_tac[]);
a(ante_tac (list_µ_elim[¨s m + ~cÆ, ¨cÆ]Ø_abs_plus_thm));
a(rewrite_tac[Ø_plus_assoc_thm] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €lim_seq_bounded_thm› = save_pop_thm "lim_seq_bounded_thm";
=TEX
Now a more specialised lemma which is the arithmetic core
of the argument about the product of two sequences:
%%%%
%%%%
=SML
set_goal([], ¨µe t x y c d∑
	Abs(x - c) < e * (ÓØ 2*t)õ-õ1
±	Abs(y - d) < e * (ÓØ 2*t)õ-õ1
±	Abs x < t
±	Abs d < t
¥	Abs (x*y - c*d) < e	Æ);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(LEMMA_T ¨x*y + ~(c*d) = x*(y + ~d) + (x + ~c)*dÆ rewrite_thm_tac
	THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨Abs(x*(y + ~d)) + Abs((x + ~c)*d)Æ
	THEN rewrite_tac[Ø_abs_plus_thm, Ø_abs_times_thm]);
a(bc_thm_tac Ø_less_º_trans_thm THEN ∂_tac¨t*e*(ÓØ 2*t)õ-õ1 + t*e*(ÓØ 2*t)õ-õ1Æ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ø_plus_mono_thm2);
a(REPEAT strip_tac THEN1 (bc_thm_tac Ø_abs_less_times_thm THEN REPEAT strip_tac));
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µx∑t*e*x = (e*x)*tÆ]);
a(bc_thm_tac Ø_abs_less_times_thm THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(conv_tac (LEFT_C Ø_anf_conv));
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µx y∑x*e*t*y = e*(x*t)*yÆ]);
a(lemma_tac¨≥ ÓØ 2 * t = ÓØ 0Æ THEN1
	(strip_asm_tac(µ_elim¨xÆ Ø_0_º_abs_thm) THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
val €times_lim_seq_lemma› = pop_thm ();
=TEX
Now we can prove that the product of two sequences each of which has a limit has
the product of the limits as its limit:
%%%%
%%%%
=SML
set_goal([], ¨µs1 c1 s2 c2∑
	s1 -> c1 ± s2 -> c2 ¥ (Ãm∑s1 m * s2 m) -> c1 * c2Æ);
a(REPEAT strip_tac THEN rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[lim_seq_def]));
a(all_fc_tac[lim_seq_bounded_thm]);
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[lim_seq_def]));
a(strip_asm_tac(µ_elim¨c2Æ Ø_0_º_abs_thm));
a(lemma_tac¨ÓØ 0 < e*(ÓØ 2 * (b + Abs c2))õ-õ1Æ);
(* *** Goal "1" *** *)
a(bc_thm_tac Ø_0_less_0_less_times_thm THEN REPEAT strip_tac);
a(bc_thm_tac Ø_0_less_0_less_recip_thm THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T [5, 7] (MAP_EVERY ante_tac));
a(all_asm_fc_tac[] THEN REPEAT strip_tac);
a(∂_tac¨n+n'Æ THEN REPEAT strip_tac);
a(lemma_tac¨n º m ± n' º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T[6, 7] all_fc_tac);
a(bc_thm_tac (rewrite_rule[]times_lim_seq_lemma));
a(∂_tac¨b + Abs c2Æ THEN asm_rewrite_tac[]);
a(spec_nth_asm_tac 13 ¨mÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €times_lim_seq_thm› = save_pop_thm "times_lim_seq_thm";
=TEX
Now we prove that the negative of a sequence which has a limit has
thenegative of the limit as its limit:
%%%%
%%%%
=SML
set_goal([], ¨µs c∑ s -> c § (Ãm∑~(s m)) ->  ~cÆ);
a(lemma_tac¨µs c∑ s -> c ¥ (Ãm∑~(s m)) ->  ~cÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [2] all_fc_tac);
a(pure_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[] ¨~(s m) + c = ~ (s m + ~c)Æ]);
a(asm_rewrite_tac[Ø_abs_minus_thm]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac[»_axiom]);
val €minus_lim_seq_thm› = save_pop_thm "minus_lim_seq_thm";
=TEX
We can now show by polynomial induction that polynomial functions preserve limits.
As we will see shortly, this shows that every polynomial function is continuous.
%%%%
%%%%
=SML
set_goal([], ¨µf s t∑f ç PolyFunc ± s -> t ¥ (Ãx∑ f (s x)) -> f tÆ);
a(REPEAT strip_tac);
a(poly_induction_tac ¨fÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[const_lim_seq_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[»_axiom]);
(* *** Goal "3" *** *)
a(ALL_FC_T (MAP_EVERY ante_tac) [plus_lim_seq_thm]);
a(rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(ALL_FC_T (MAP_EVERY ante_tac) [times_lim_seq_thm]);
a(rewrite_tac[] THEN REPEAT strip_tac);
val €poly_lim_seq_thm› = save_pop_thm "poly_lim_seq_thm";
=TEX
Finally, moving on from polynomials, we will need to reason
about (particular) rational functions from time to time and
this requires the usual result about the limit of
a sequence of reciprocals.
%%%%
%%%%
=SML
set_goal([], ¨µs∑ s -> t ± ≥t = ÓØ 0 ¥ (Ãm∑ (s m) õ-õ1) -> t õ-õ1Æ);
a(REPEAT strip_tac THEN all_fc_tac [lim_seq_bounded_thm]);
a(DROP_NTH_ASM_T 4 ante_tac THEN
	rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(all_fc_tac[Ø_≥_0_abs_thm]);
a(lemma_tac¨ÓØ 0 < (1/2)*Abs tÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨∂n1∑µ m∑ n1 º m ¥ (1/2)*Abs t < Abs(s m)Æ);
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 4 ¨(1/2)*Abs tÆ);
a(∂_tac ¨nÆ THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [2] all_fc_tac);
a(CONTR_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(lemma_tac¨Abs t < Abs tÆ);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨Abs(s m) + Abs(~(s m + ~t))Æ);
a(REPEAT strip_tac THEN_LIST
	[bc_thm_tac Ø_abs_plus_bc_thm,
	rewrite_tac[Ø_abs_minus_thm] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]]);
a(conv_tac (ONCE_MAP_C Ø_anf_conv) THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(lemma_tac ¨ÓØ 0 < Abs t*Abs t*eÆ THEN1
	(all_fc_tac[Ø_0_less_0_less_times_thm] THEN all_fc_tac[Ø_0_less_0_less_times_thm]));
a(lemma_tac ¨ÓØ 0 < (1/2)*Abs t*Abs t*eÆ THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 7 ¨(1/2)*Abs t*Abs t*eÆ);
a(∂_tac¨n1 + nÆ THEN REPEAT strip_tac);
a(lemma_tac¨n1 º m ± n º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 7 ¨mÆ);
a(LEMMA_T¨≥Abs(s m) = ÓØ 0Æ (asm_tac o rewrite_rule[Ø_abs_eq_0_thm])
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨≥ ~ t = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[
	conv_rule(ONCE_MAP_C (RIGHT_C eq_sym_conv)) Ø_minus_recip_thm,
	Ø_plus_recip_thm]);
a(spec_nth_asm_tac 7 ¨mÆ);
a(once_rewrite_tac[Ø_abs_times_thm]);
a(lemma_tac¨≥Abs t = ÓØ 0Æ THEN1 asm_rewrite_tac[Ø_abs_eq_0_thm]);
a(LEMMA_T ¨e = ((1/2)*Abs t * Abs t * e)*(Abs ((1/2)*t))õ-õ1*(Abs t)õ-õ1Æ once_rewrite_thm_tac
	THEN1 (rewrite_tac[Ø_abs_times_thm] THEN
		ALL_FC_T rewrite_tac[
			rewrite_rule[](µ_elim¨1/2Æ(hd(rev(strip_±_rule Ø_recip_clauses))))] THEN
			rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
			¨µx y∑((1/2)*x*x*y)*(ÓØ 2 * x õ-õ1)*x õ-õ1=
				 (x*x õ-õ1) * (x*x õ-õ1) * yÆ]
		THEN ALL_FC_T rewrite_tac[Ø_times_recip_thm]));
a(bc_thm_tac Ø_abs_less_times_thm THEN REPEAT strip_tac);
a(once_rewrite_tac[Ø_times_comm_thm] THEN rewrite_tac[Ø_abs_times_thm]);
a(ALL_FC_T rewrite_tac[Ø_minus_recip_thm] THEN rewrite_tac[Ø_abs_minus_thm]);
a(ALL_FC_T rewrite_tac[Ø_abs_recip_thm] THEN bc_thm_tac Ø_times_mono_thm);
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac Ø_0_less_0_less_recip_thm THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(bc_thm_tac Ø_less_recip_less_thm THEN
	LIST_GET_NTH_ASM_T [14, 5] (MAP_EVERY ante_tac) THEN
	PC_T1 "Ø_lin_arith" prove_tac[]);
val €recip_lim_seq_thm› = save_pop_thm "recip_lim_seq_thm";
=TEX
The following conversions are useful in applying some of the previous results (and later
ones) which require the matrix of a $\lambda$-abstraction to be converted
into a suitable form by introducing $\beta$-redexes.
%%%%
%%%%
=SML
fun €un_¬_conv› (v : TERM) : CONV = (fn tm =>
	let	val lhs = mk_app(mk_Ã(v, tm), v);
	in	eq_sym_rule (¬_conv lhs)
	end
);
val €Ã_un_¬_rands_conv› : CONV = (fn tm =>
	let	val (v, _) = dest_Ã tm;
	in	SIMPLE_Ã_C (RANDS_C (un_¬_conv v)) tm
	end
);
=TEX
Some further generalities about sequences are useful.
The following theorem says that an arbitrary interleaving of two
sequences that converge to the same limit itself converges to that limit:
%%%%
%%%%
=SML
set_goal([], ¨µp s1 s2 x∑ s1 -> x ± s2 -> x ¥ (Ãm∑if p m then s1 m else s2 m) -> xÆ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(∂_tac¨n + n'Æ THEN REPEAT strip_tac);
a(lemma_tac¨n º m ± n' º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T [4, 5] all_fc_tac);
a(cases_tac¨p mÆ THEN asm_rewrite_tac[]);
val €lim_seq_choice_thm› = save_pop_thm "lim_seq_choice_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µs x∑ s -> x  ¥ (Ãm∑Abs(s m)) -> Abs xÆ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(∂_tac¨nÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨Abs(s m + ~x)Æ THEN REPEAT strip_tac);
a(rewrite_tac[rewrite_rule[]Ø_abs_abs_minus_thm]);
val €abs_lim_seq_thm› = save_pop_thm "abs_lim_seq_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx∑ (Ãm∑x + ÓØ(m+1)õ-õ1) -> xÆ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(all_fc_tac[Ø_archimedean_recip_thm]);
a(∂_tac¨m+1Æ THEN REPEAT strip_tac);
a(conv_tac(ONCE_MAP_C Ø_anf_conv));
a(lemma_tac¨ÓØ 0 < ÓØ (m+1) ± ÓØ 0 < ÓØ (m'+1)Æ THEN1 rewrite_tac[ÓØ_0_less_thm]);
a(lemma_tac¨ÓØ (m+1) < ÓØ (m'+1)Æ THEN1 
	(asm_rewrite_tac[ÓØ_less_thm] THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(lemma_tac¨ÓØ 0 º ÓØ (m' + 1) õ-õ1Æ THEN1
	(rewrite_tac[Ø_º_def] THEN all_fc_tac[Ø_0_less_0_less_recip_thm] THEN asm_rewrite_tac[]));
a(asm_rewrite_tac[Ø_abs_def]);
a(all_fc_tac[Ø_less_recip_less_thm]);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨ÓØ (m + 1) õ-õ1Æ THEN REPEAT strip_tac);
val €lim_seq_recip_Ó_thm› = save_pop_thm "lim_seq_recip_Ó_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx∑ ∂s∑ s -> x ± (µm∑≥s m = x)Æ);
a(REPEAT strip_tac);
a(∂_tac¨(Ãm∑x + ÓØ(m+1)õ-õ1)Æ THEN rewrite_tac[lim_seq_recip_Ó_thm]);
a(REPEAT strip_tac THEN lemma_tac¨ÓØ 0 < ÓØ (m + 1) õ-õ1Æ THEN_LIST
	[id_tac, PC_T1 "Ø_lin_arith" asm_prove_tac[]]);
a(bc_tac[Ø_0_less_0_less_recip_thm] THEN rewrite_tac[ÓØ_0_less_thm]);
val €lim_seq_≥_eq_thm› = save_pop_thm "lim_seq_≥_eq_thm";
=TEX
The following ``shift theorem''
shows that we can ignore any finite leading subsequence of
a sequence when we calculate its limit:
%%%%
%%%%
=SML
set_goal([], ¨µm s x∑ (s -> x) § (Ãn∑s (n + m)) -> xÆ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN ∂_tac¨nÆ THEN REPEAT strip_tac);
a(lemma_tac¨n º m'+mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[] THEN ∂_tac¨n + mÆ THEN REPEAT strip_tac);
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[º_def]) THEN all_var_elim_asm_tac1);
a(SPEC_NTH_ASM_T 1 ¨n+iÆ ante_tac THEN
	conv_tac (ONCE_MAP_C anf_conv) THEN
	REPEAT strip_tac);
val €lim_seq_shift_thm› = save_pop_thm "lim_seq_shift_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx d∑ ÓØ 0 < d ¥ ∂s∑ s -> x ± (µm∑Abs(s m - x) <  d ± ≥s m = x)Æ);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim¨xÆ lim_seq_≥_eq_thm));
a(GET_NTH_ASM_T 2 (fn th => all_fc_tac[rewrite_rule[lim_seq_def]th]));
a(∂_tac¨Ãp∑s(p + n)Æ THEN asm_rewrite_tac[]);
a(strip_tac THEN1 bc_thm_tac lim_seq_shift_thm THEN REPEAT strip_tac);
a(TOP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
val €lim_seq_≥_eq_thm1› = save_pop_thm "lim_seq_≥_eq_thm1";
=TEX
A sequences that converges to a non-zero limit can have
at most finitely many zero values:
%%%%
%%%%
=SML
set_goal([], ¨µs x∑ (s -> x) ± ≥x = ÓØ 0 ¥ ∂n∑µm∑ n º m ¥ ≥s m = ÓØ 0Æ);
a(rewrite_tac[lim_seq_def] THEN contr_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[Ø_≥_0_abs_thm] THEN all_asm_fc_tac[]);
a(spec_nth_asm_tac 3 ¨nÆ);
a(spec_nth_asm_tac 3 ¨mÆ);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[Ø_abs_minus_thm]);
val €lim_seq_≥_0_thm› = save_pop_thm "lim_seq_≥_0_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µs b c∑ (µm∑s m º  b) ± s -> c ¥ c º bÆ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(contr_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(lemma_tac ¨ÓØ 0 < c + ~bÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac);
a(POP_ASM_T (strip_asm_tac o µ_elim¨nÆ));
a(POP_ASM_T ante_tac THEN spec_nth_asm_tac 3 ¨nÆ);
a(LEMMA_T¨≥ÓØ 0 º s n + ~cÆ (fn th => rewrite_tac[th, Ø_abs_def]) THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €lim_seq_upper_bound_thm› = save_pop_thm "lim_seq_upper_bound_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µs b c∑ s -> b ± s -> c¥ b = cÆ);
a(rewrite_tac[lim_seq_def] THEN contr_tac);
a(lemma_tac¨b < c ≤ c < bÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1" *** *)
a(lemma_tac¨ÓØ 0 < (1/2)*(c + ~b)Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [4, 5] all_fc_tac);
a(REPEAT_N 2 (POP_ASM_T (ante_tac o µ_elim¨n'+nÆ)));
a(rewrite_tac[]);
a(cases_tac¨ÓØ 0 º (s (n' + n) + ~c)Æ THEN cases_tac ¨ÓØ 0 º s (n' + n) + ~bÆ THEN
	asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨ÓØ 0 < (1/2)*(b + ~c)Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [4, 5] all_fc_tac);
a(REPEAT_N 2 (POP_ASM_T (ante_tac o µ_elim¨n'+nÆ)));
a(rewrite_tac[]);
a(cases_tac¨ÓØ 0 º (s (n' + n) + ~c)Æ THEN cases_tac ¨ÓØ 0 º s (n' + n) + ~bÆ THEN
	asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €lim_seq_unique_thm› = save_pop_thm "lim_seq_unique_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µs c∑ s -> c ¥ (Ãm∑ s(m+1) - s m) -> ÓØ 0Æ);
a(REPEAT strip_tac);
a(TOP_ASM_T (strip_asm_tac o once_rewrite_rule[µ_elim¨1Ælim_seq_shift_thm]));
a(rewrite_tac[] THEN conv_tac(LEFT_C Ã_un_¬_rands_conv));
a(pure_once_rewrite_tac[prove_rule[]¨ÓØ 0 = c + ~cÆ]);
a(bc_thm_tac plus_lim_seq_thm THEN REPEAT strip_tac);
a(bc_thm_tac minus_lim_seq_thm THEN REPEAT strip_tac);
val €lim_seq_diffs_tend_to_0_thm› = save_pop_thm "lim_seq_diffs_tend_to_0_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Continuity}
%%%%
%%%%
%%%%
%%%%
Most of the work on continuity duplicates reasoning for sequences if carried
out from first principles. To allow us to reuse the material on sequences,
we prove that a function is continuous iff. it preserves limits:
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf x∑ f CtsAt x § µs∑ s -> x ¥ (Ãm∑f(s m)) -> f xÆ);
a(rewrite_tac[cts_at_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨eÆ);
a(spec_nth_asm_tac 4 ¨dÆ);
a(∂_tac¨nÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(contr_tac THEN lemma_tac¨
	∂s∑µm∑ Abs(s m + ~x) < (ÓØ (m+1)) õ-õ1 ± e º Abs(f(s m) + ~(f x))
Æ THEN1 prove_∂_tac THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(lemma_tac¨ÓØ 0 < ÓØ (m' + 1) õ-õ1Æ THEN1
	(bc_thm_tac Ø_0_less_0_less_recip_thm THEN rewrite_tac[ÓØ_less_thm]));
a(spec_nth_asm_tac 2 ¨ÓØ (m' + 1) õ-õ1Æ);
a(∂_tac¨yÆ THEN REPEAT strip_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨s -> xÆ THEN1 rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(DROP_NTH_ASM_T 4 discard_tac THEN all_asm_fc_tac[Ø_archimedean_recip_thm]);
a(∂_tac¨m + 2Æ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨ÓØ (m'+1)õ-õ1Æ THEN asm_rewrite_tac[]);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨ÓØ (m+1)õ-õ1Æ THEN asm_rewrite_tac[]);
a(bc_thm_tac Ø_less_recip_less_thm THEN
	rewrite_tac[ÓØ_plus_homomorphism_thm, ÓØ_less_thm]
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2.2.2" *** *)
a(ALL_ASM_FC_T (MAP_EVERY ante_tac)[]);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(∂_tac ¨eÆ THEN REPEAT strip_tac);
a(∂_tac ¨nÆ THEN asm_rewrite_tac[Ø_≥_less_º_thm]);
val €cts_lim_seq_thm› = save_pop_thm "cts_lim_seq_thm";
=TEX
It is occasionally convenient to have the following stronger variant
on the previous theorem, which lets us demonstrate continuity of a function $f$
at a point $x$ by considering sequences that tend to $x$ without ever being
equal to $x$.
%%%%
%%%%
=SML
set_goal([], ¨µf x∑ f CtsAt x § µs∑ s -> x ± (µm∑≥s m = x) ¥ (Ãm∑f(s m)) -> f xÆ);
a(REPEAT strip_tac THEN1 all_fc_tac[cts_lim_seq_thm]);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨xÆ lim_seq_≥_eq_thm));
a(strip_asm_tac(rewrite_rule[](list_µ_elim[¨Ãm∑s m = xÆ, ¨s'Æ, ¨sÆ, ¨xÆ]lim_seq_choice_thm)));
a(lemma_tac¨µm∑ ≥(Ãm∑ if s m = x then s' m else s m) m = xÆ THEN1 
	(REPEAT strip_tac THEN cases_tac ¨s m = xÆ THEN asm_rewrite_tac[]));
a(DROP_NTH_ASM_T  6 (ante_tac o µ_elim ¨(Ãm∑ if s m = x then s' m else s m)Æ) THEN
	asm_rewrite_tac[]);
a(DROP_ASMS_T discard_tac THEN rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(∂_tac¨nÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(DROP_NTH_ASM_T 2 ante_tac THEN cases_tac¨s m = xÆ THEN asm_rewrite_tac[]);
val €cts_lim_seq_thm1› = save_pop_thm "cts_lim_seq_thm1";
=TEX
Using the shift theorem, we can now prove a further sharpening of
the characterisation of continuity in terms of sequence convergence.
%%%%
%%%%
=SML
set_goal([], ¨µf x∑
	f CtsAt x §
	∂a b∑ a < x ± x < b ±
	(µs∑ s -> x ± (µm∑≥s m = x ± a < s m ± s m < b) ¥ (Ãm∑f(s m)) -> f x)Æ);
a(rewrite_tac[cts_lim_seq_thm1] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨x + ~(ÓØ 1)Æ THEN ∂_tac¨x + ÓØ 1Æ THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 3 bc_thm_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(GET_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[lim_seq_def]));
a(LIST_GET_NTH_ASM_T [5, 6]
	(MAP_EVERY(strip_asm_tac o once_rewrite_rule[Ø_less_0_less_thm])));
a(LIST_GET_NTH_ASM_T [3] all_fc_tac);
a(once_rewrite_tac[µ_elim¨n + n'Ælim_seq_shift_thm]);
a(rewrite_tac[]);
a(LEMMA_T¨µi j k∑ s(i+j+k)=(Ãi∑s(i + j + k))iÆ once_rewrite_thm_tac THEN1
	rewrite_tac[]);
a(DROP_NTH_ASM_T 8 bc_thm_tac);
a(ALL_FC_T asm_rewrite_tac[lim_seq_shift_thm] THEN contr_tac
	THEN POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
(* *** Goal "2.1" *** *)
a(lemma_tac ¨ÓØ 0 º ~(s(m+n+n')) + xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨≥Abs(~(~(s(m+n+n')) + x)) < x + ~aÆ ante_tac THEN1
	(asm_rewrite_tac[Ø_abs_minus_thm] THEN 
	asm_rewrite_tac[Ø_abs_def] THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(rewrite_tac[] THEN GET_NTH_ASM_T 4 bc_thm_tac THEN PC_T1 "lin_arith" prove_tac[]);
(* *** Goal "2.2" *** *)
a(lemma_tac ¨ÓØ 0 º s(m+n+n') + ~xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨≥Abs(s(m+n+n') + ~x) < b + ~xÆ ante_tac THEN1
	(asm_rewrite_tac[Ø_abs_def] THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(rewrite_tac[] THEN GET_NTH_ASM_T 3 bc_thm_tac THEN PC_T1 "lin_arith" prove_tac[]);
val €cts_lim_seq_thm2› = save_pop_thm "cts_lim_seq_thm2";
=TEX
Now we give the useful result that continuity is a local property: i.e.,
if two functions agree in a neighbourhood of a point and
one is continuous at that point then so is the other:
%%%%
%%%%
=SML
set_goal([], ¨µf g x a b∑
	a < x ± x < b
±	(µy∑ a < y ± y < b ¥ f y = g y)
±	g CtsAt x
¥	f CtsAt x Æ);
a(REPEAT strip_tac THEN rewrite_tac[cts_lim_seq_thm2]);
a(∂_tac¨aÆ THEN ∂_tac¨bÆ THEN REPEAT strip_tac);
a(LEMMA_T¨µm∑f(s m) = g(s m)Ærewrite_thm_tac THEN1
	(REPEAT strip_tac THEN
	spec_nth_asm_tac 1 ¨m:ÓÆ THEN
	all_asm_fc_tac[]));
a(LEMMA_T¨f x = g xÆrewrite_thm_tac THEN1 all_asm_fc_tac[]);
a(GET_NTH_ASM_T 3 (bc_thm_tac o rewrite_rule[cts_lim_seq_thm]) THEN asm_rewrite_tac[]);
val €cts_local_thm› = save_pop_thm"cts_local_thm";
=TEX
We now show that the polynomial constructions preserve limits.
%%%%
%%%%
=SML
set_goal([], ¨µc t∑ (Ãx∑c) CtsAt tÆ);
a(REPEAT strip_tac THEN rewrite_tac[cts_lim_seq_thm, const_lim_seq_thm]);
val €const_cts_thm› = save_pop_thm "const_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µt∑ (Ãx∑x) CtsAt tÆ);
a(REPEAT strip_tac THEN rewrite_tac[cts_lim_seq_thm, »_axiom]);
val €id_cts_thm› = save_pop_thm "id_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g t∑ f CtsAt t ± g CtsAt t ¥ (Ãx∑f x + g x) CtsAt tÆ);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [plus_lim_seq_thm]);
a(rewrite_tac[] THEN taut_tac);
val €plus_cts_thm› = save_pop_thm "plus_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g t∑ f CtsAt t ± g CtsAt t ¥ (Ãx∑f x * g x) CtsAt tÆ);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [times_lim_seq_thm]);
a(rewrite_tac[] THEN taut_tac);
val €times_cts_thm› = save_pop_thm "times_cts_thm";
=TEX
Now we can show that polynomial functions are continuous everywhere.
We could do this by polynomial induction using the theorems just
proved, but it's even easier to use the last result from the previous section:
%%%%
%%%%
=SML
set_goal([], ¨µf t∑ f ç PolyFunc ¥ f CtsAt tÆ);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac
	THEN ALL_FC_T rewrite_tac[poly_lim_seq_thm]);
val €poly_cts_thm› = save_pop_thm "poly_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g t∑ f CtsAt g t ± g CtsAt t ¥ (Ãx∑f(g x)) CtsAt tÆ);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac[»_axiom]);
val €comp_cts_thm› = save_pop_thm "comp_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µt∑~ CtsAt tÆ);
a(LEMMA_T ¨~ = (Ãx∑(Ãx∑~(ÓØ 1)) x * (Ãx∑x) x)Æ pure_once_rewrite_thm_tac
	THEN1 (rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(strip_tac THEN bc_thm_tac times_cts_thm);
a(rewrite_tac[const_cts_thm, id_cts_thm]);
val €minus_cts_thm› = save_pop_thm "minus_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf t∑f CtsAt t ¥ (Ãx∑~(f x)) CtsAt tÆ);
a(REPEAT strip_tac);
a(bc_thm_tac comp_cts_thm THEN REPEAT strip_tac);
a(rewrite_tac[minus_cts_thm]);
val €minus_comp_cts_thm› = save_pop_thm "minus_comp_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µt∑ ≥t = ÓØ 0 ¥ $õ-õ1 CtsAt tÆ);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(bc_thm_tac recip_lim_seq_thm THEN REPEAT strip_tac);
val €recip_cts_thm› = save_pop_thm "recip_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf t∑f CtsAt t ± ≥f t = ÓØ 0 ¥ (Ãx∑(f x)õ-õ1) CtsAt tÆ);
a(REPEAT strip_tac);
a(bc_thm_tac comp_cts_thm THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[recip_cts_thm]);
val €recip_comp_cts_thm› = save_pop_thm "recip_comp_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µt∑ Abs CtsAt tÆ);
a(rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(all_fc_tac[abs_lim_seq_thm]);
val €abs_cts_thm› = save_pop_thm "abs_cts_thm";
=TEX
%%%%
%%%%
=SML
val €simple_cts_tac› : TACTIC = (fn gl as (_, tm) => 
	let	val x = snd(dest_app tm);
		val const_thm = all_µ_intro(§_t_intro(all_µ_elim const_cts_thm));
		val id_thm = all_µ_intro(§_t_intro(all_µ_elim id_cts_thm));
	in
	conv_tac (simple_eq_match_conv const_thm) ORELSE
	conv_tac (simple_eq_match_conv id_thm) ORELSE
	(conv_tac (LEFT_C Ã_un_¬_rands_conv) THEN FIRST (map bc_thm_tac [
			plus_cts_thm, times_cts_thm, minus_comp_cts_thm, recip_comp_cts_thm]
		)) ORELSE
	conv_tac (LEFT_C »_conv ORELSE_C RAND_C (LEFT_C ¬_conv))
	end	gl
);
=IGN
set_goal([], ¨(Ãx∑c) CtsAt (ÓØ 2)Æ);
a simple_cts_tac;
val test1 = pop_thm();
set_goal([], ¨(Ãx∑x*y + ÓØ 3) CtsAt tÆ);
a(REPEAT (simple_cts_tac THEN REPEAT strip_tac));
val test2 = pop_thm();
set_goal([], ¨(Ãx∑ÓØ 3 * ((1/2)+x)õ-õ1) CtsAt 1/3Æ);
a(REPEAT (simple_cts_tac THEN REPEAT strip_tac));
a(rewrite_tac[]);
val test2 = pop_thm();
=TEX
Another useful lemma says any function continuous
on a closed interval can be extended to a function continuous
on the whole line.
It is occasionally useful to know the chosen values of the continuous extension
so we prove that stronger form first and then derive the weaker one from it.
For various reasons, we formulate the stronger form with the equations
arranged to map in the other order.
%%%%
%%%%
=SML
set_goal([], ¨µa b f∑
	a < b
±	(µx∑ a º x ± x º b ¥ f CtsAt x)
¥	(∂g∑
		(µx∑ a º x ± x º b ¥ g x = f x)
	±	(µx∑x < a ¥ g x = f a)
	±	(µx∑b < x ¥ g x = f b)
	±	(µx∑ g CtsAt x)) Æ);
a(REPEAT strip_tac);
a(∂_tac¨Ãz∑
	if	z < a
	then	f a
	else if	b < z
	then	f b
	else	f zÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T¨≥x < a ± ≥ b < xÆ asm_rewrite_thm_tac THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(LEMMA_T¨≥x < aÆ  asm_rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "4" *** *)
a(cases_tac¨x < aÆ THEN1 bc_thm_tac cts_local_thm);
(* *** Goal "4.1" *** *)
a(∂_tac¨Ãx∑f aÆ THEN ∂_tac¨aÆ THEN ∂_tac¨x + ~(ÓØ 1)Æ THEN
	asm_rewrite_tac[const_cts_thm] THEN REPEAT strip_tac THEN
	asm_rewrite_tac[]);
(* *** Goal "4.2" *** *)
a(cases_tac¨x = aÆ THEN1 all_var_elim_asm_tac1);
(* *** Goal "4.2.1" *** *)
a(rewrite_tac[cts_lim_seq_thm2]);
a(POP_ASM_T ante_tac THEN rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(∂_tac¨a + ~(ÓØ 1)Æ THEN ∂_tac¨bÆ THEN REPEAT strip_tac);
a(LEMMA_T¨≥b < a Æ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨µm∑≥b < s mÆrewrite_thm_tac THEN1
	(REPEAT strip_tac THEN
	spec_nth_asm_tac 1 ¨m:ÓÆ THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(LEMMA_T ¨µm:Ó∑
	f a = (Ãi∑ f a)m
± 	f (s m) = (Ãi∑f(s i))m
±	(s m < a § (Ãi∑s i < a) m)Æ once_rewrite_thm_tac
	THEN1 rewrite_tac[]);
a(bc_thm_tac lim_seq_choice_thm THEN rewrite_tac[const_lim_seq_thm]);
a(SPEC_NTH_ASM_T 3 ¨aÆ ante_tac);
a(LEMMA_T ¨a º bÆ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "4.2.2" *** *)
a(cases_tac¨x < bÆ THEN1 bc_thm_tac cts_local_thm);
(* *** Goal "4.2.2.1" *** *)
a(lemma_tac ¨a < xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(∂_tac¨fÆ THEN ∂_tac¨bÆ THEN ∂_tac¨aÆ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN1 
	(LEMMA_T ¨≥y < a ± ≥b < yÆrewrite_thm_tac THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(GET_NTH_ASM_T 5 bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "4.2.2.2" *** *)
a(cases_tac¨x = bÆ THEN1 all_var_elim_asm_tac1);
(* *** Goal "4.2.2.2.1" *** *)
a(LIST_DROP_NTH_ASM_T [1,2] discard_tac THEN rewrite_tac[cts_lim_seq_thm2]);
a(POP_ASM_T ante_tac THEN rewrite_tac[cts_lim_seq_thm] THEN REPEAT strip_tac);
a(∂_tac¨aÆ THEN ∂_tac¨b + ÓØ 1Æ THEN REPEAT strip_tac);
a(LEMMA_T¨≥b < a Æ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨µm∑≥s m < aÆrewrite_thm_tac THEN1
	(REPEAT strip_tac THEN
	spec_nth_asm_tac 1 ¨m:ÓÆ THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(LEMMA_T ¨µm:Ó∑
	f b = (Ãi∑ f b)m
± 	f (s m) = (Ãi∑f(s i))m
±	(b < s m § (Ãi∑b < s i) m)Æ once_rewrite_thm_tac
	THEN1 rewrite_tac[]);
a(bc_thm_tac lim_seq_choice_thm THEN rewrite_tac[const_lim_seq_thm]);
a(SPEC_NTH_ASM_T 3 ¨bÆ ante_tac);
a(LEMMA_T ¨a º bÆ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "4.2.2.2.2" *** *)
a(LEMMA_T ¨b < xÆ ante_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [1,2,3,4] discard_tac THEN strip_tac);
a(all_fc_tac[µ_elim¨bÆØ_less_dense_thm]);
a(bc_thm_tac cts_local_thm);
a(∂_tac¨Ãx∑f bÆ THEN ∂_tac¨x + ÓØ 1Æ THEN ∂_tac¨bÆ THEN
	asm_rewrite_tac[const_cts_thm] THEN REPEAT strip_tac THEN
	asm_rewrite_tac[]);
a(LEMMA_T ¨≥y < aÆ rewrite_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €cts_extension_thm1› = save_pop_thm"cts_extension_thm1";
=TEX
The weaker form of the extension theorem can now easily be derived:
%%%%
%%%%
=SML
set_goal([], ¨µa b f∑
	a < b
±	(µx∑ a º x ± x º b ¥ f CtsAt x)
¥	(∂g∑ (µx∑ a º x ± x º b ¥ g x = f x) ± (µx∑ g CtsAt x)) Æ);
a(REPEAT strip_tac);
a(all_fc_tac[cts_extension_thm1]);
a(∂_tac¨gÆ THEN asm_rewrite_tac[]);
val €cts_extension_thm› = save_pop_thm"cts_extension_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{A little Topology}
%%%%
%%%%
%%%%
%%%%
Mainly for use in one or two applications of the compactness of a closed interval
we need some elementary facts of a topological nature.

Our definition of an open set is the standard one.
A ``$\delta$'' characterisation which is closer to the style
used in the definitions of sequence convergence etc. is useful.
%%%%
%%%%
=SML
set_goal([], ¨µA∑
	A ç OpenâR
§	(µt∑ t ç A ¥ ∂d∑ÓØ 0 < d ± µy∑ Abs(y - t) < d ¥ y ç A)
Æ);
a(rewrite_tac[open_Ø_def, open_interval_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
a(cases_tac¨t + ~x < y + ~tÆ);
(* *** Goal "1.1" *** *)
a(∂_tac¨t + ~xÆ THEN REPEAT strip_tac THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨x < y' ± y' < yÆ THEN1
	(LIST_DROP_NTH_ASM_T [1,2,4,5] (MAP_EVERY ante_tac) THEN
	DROP_ASMS_T discard_tac THEN
	cases_tac¨ÓØ 0 º y' + ~tÆ THEN
	asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a(∂_tac¨y + ~tÆ THEN REPEAT strip_tac THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨x < y' ± y' < yÆ THEN1
	(LIST_DROP_NTH_ASM_T [1,2,4,5] (MAP_EVERY ante_tac) THEN
	DROP_ASMS_T discard_tac THEN
	cases_tac¨ÓØ 0 º y' + ~tÆ THEN
	asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
a(∂_tac¨t + ~dÆ THEN ∂_tac¨t + dÆ THEN REPEAT strip_tac THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(GET_NTH_ASM_T 3 bc_thm_tac);
a(LIST_DROP_NTH_ASM_T [1,2,4] (MAP_EVERY ante_tac) THEN
	DROP_ASMS_T discard_tac THEN
	cases_tac¨ÓØ 0 º x + ~tÆ THEN
	asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €open_Ø_delta_thm›  = save_pop_thm "open_Ø_delta_thm";
=TEX
Now we give the topological characterisation of sequence convergence.
%%%%
%%%%
=SML
set_goal([], ¨µs x∑
	(s -> x)
§	(µA∑ A ç OpenâR ± x ç A ¥ ∂n∑µm∑ n º m ¥ s m ç A)Æ);
a(rewrite_tac[lim_seq_def] THEN REPEAT µ_tac THEN §_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[open_Ø_delta_thm] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(LIST_GET_NTH_ASM_T [5] all_fc_tac);
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [2,3] bc_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN
	rewrite_tac[open_Ø_def, open_interval_def] THEN
	REPEAT strip_tac);
a(swap_nth_asm_concl_tac 2 THEN REPEAT strip_tac);
a(∂_tac ¨{z | x + ~e < z ± z < x + e}Æ THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(∂_tac¨x + ~eÆ THEN ∂_tac¨x + eÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.3" *** *)
a(swap_nth_asm_concl_tac 1 THEN REPEAT strip_tac);
a(∂_tac¨nÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(LIST_DROP_NTH_ASM_T [1,2] (MAP_EVERY ante_tac) THEN
	DROP_ASMS_T discard_tac THEN
	cases_tac¨ÓØ 0 º s m + ~xÆ THEN
	asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €lim_seq_open_Ø_thm› = save_pop_thm "lim_seq_open_Ø_thm";
=TEX
We now prove the usual topological characterisation of continuity in
terms of open sets. To avoid complications with relative topologies for now
we just do the cases where the function is continuous on the whole line or on an open set:
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf∑
	(µx∑ f CtsAt x)
§	(µA∑ A ç OpenâR ¥ {x | f x ç A} ç OpenâR)
Æ);
a(REPEAT_N 3 strip_tac);
a(rewrite_tac[cts_at_def, open_Ø_delta_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
a(list_spec_nth_asm_tac 5 [¨tÆ, ¨dÆ]);
a(∂_tac¨d'Æ THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T[2, 4] bc_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[cts_lim_seq_thm, lim_seq_open_Ø_thm] THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
a(spec_nth_asm_tac 4 ¨{x | f x ç A}Æ);
a(∂_tac¨nÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val €cts_open_Ø_thm› = save_pop_thm"cts_open_Ø_thm";
=TEX
The following is used in our proof of the fact that closed intervals are compact:
%%%%
%%%%
=SML
set_goal([], ¨µx y∑ClosedInterval x y ç ClosedâRÆ);
a(rewrite_tac[
	closed_interval_def, closed_Ø_def, open_Ø_def, open_interval_def] THEN 
	REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(∂_tac¨t + ~(ÓØ 1)Æ THEN ∂_tac ¨xÆ THEN
	PC_T1 "sets_ext1" REPEAT strip_tac THEN
	REPEAT strip_tac);
a(rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(∂_tac¨yÆ THEN ∂_tac ¨t + ÓØ 1Æ THEN
	PC_T1 "sets_ext1" REPEAT strip_tac
	THEN REPEAT strip_tac);
a(rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €closed_interval_closed_thm› = save_pop_thm"closed_interval_closed_thm";
=TEX
The following is useful later, e.g., in proving that the derivative of a function is zero at a local
maximum.
%%%%
%%%%
=SML
set_goal([], ¨µf x lb ub∑
	f CtsAt x
±	(µd∑ÓØ 0 < d ¥ (∂z∑ Abs(z - x) < d ± lb º f z) ± (∂z∑ Abs(z - x) < d ± f z º ub))
¥	lb º f x ± f x º ubÆ);
a(rewrite_tac[cts_at_def] THEN contr_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨ÓØ 0 < lb + ~(f x)Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
a(DROP_NTH_ASM_T 3 (fn th => LIST_DROP_NTH_ASM_T [4] all_fc_tac THEN asm_tac th));
a(LIST_DROP_NTH_ASM_T [6] (ALL_FC_T (MAP_EVERY ante_tac)));
a(cases_tac ¨ÓØ 0 º f z + ~(f x)Æ THEN asm_rewrite_tac[Ø_abs_def] THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨ÓØ 0 < f x + ~ubÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
a(DROP_NTH_ASM_T 3 (fn th => LIST_DROP_NTH_ASM_T [4] all_fc_tac THEN asm_tac th));
a(LIST_DROP_NTH_ASM_T [6] (ALL_FC_T (MAP_EVERY ante_tac)));
a(cases_tac ¨ÓØ 0 º f z' + ~(f x)Æ THEN asm_rewrite_tac[Ø_abs_def] THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €cts_estimate_thm› = save_pop_thm"cts_estimate_thm";
=TEX
=SML
set_goal([], ¨µf x∑
	f CtsAt x
±	(µd∑ÓØ 0 < d ¥ (∂z∑ Abs(z - x) < d ± ÓØ 0 º f z) ± (∂z∑ Abs(z - x) < d ± f z º ÓØ 0))
¥	f x = ÓØ 0Æ);
a(REPEAT strip_tac);
a(all_fc_tac[cts_estimate_thm] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €cts_estimate_0_thm› = save_pop_thm"cts_estimate_0_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g x a b∑
	a < x ± x < b
±	f CtsAt x ± g CtsAt x
±	(µy∑a < y ± y < b ± ≥y = x ¥ f y = g y)
¥	f x = g xÆ);
a(REPEAT strip_tac);
a(LEMMA_T ¨(Ãz∑f z + ~(g z)) x = ÓØ 0Æ
	(fn th => ante_tac th THEN rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(bc_thm_tac cts_estimate_0_thm THEN ±_tac
	THEN1 REPEAT (simple_cts_tac THEN REPEAT strip_tac));
a(REPEAT µ_tac THEN ¥_tac THEN rewrite_tac[]);
a(lemma_tac¨∂ z∑ Abs (z + ~x) < d ±  f z + ~ (g z) = ÓØ 0 Æ);
(* *** Goal "1" *** *)
a(lemma_tac¨∂c∑ÓØ 0 < c ± c < b + ~x ± c < dÆ THEN1
	(bc_thm_tac Ø_bound_below_2_thm THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨a < x + c ± x + c < b ± ≥x + c = x ± ÓØ 0 º (x + c) + ~xÆ
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(∂_tac¨x + cÆ THEN asm_rewrite_tac[Ø_abs_def]);
a(all_asm_fc_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN ∂_tac ¨zÆ THEN asm_rewrite_tac[]);
val €cts_limit_unique_thm› = save_pop_thm"cts_limit_unique_thm";
=TEX
The following theorem is a sometimes useful criterion for continuity, allowing
us to focus attention on values inside an arbitrarily small open interval containing
the point at which continuity is asserted:
%%%%
%%%%
=SML
set_goal([], ¨µf a b x∑
	f x ç OpenInterval a b
±	(µc d∑ f x ç OpenInterval c d  ± ClosedInterval c d Ä OpenInterval a b ¥ 
		∂s t∑x ç OpenInterval s t ± µy∑y ç OpenInterval s t ¥ f y ç OpenInterval c d)
¥	f CtsAt xÆ);
a(rewrite_tac[open_interval_def, closed_interval_def, cts_at_def, Ä_def] THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < b + ~(f x) ± ÓØ 0 < f x + ~aÆ THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(strip_asm_tac (list_µ_elim[¨eÆ, ¨f x + ~aÆ, ¨b + ~(f x)Æ] Ø_bound_below_3_thm));
a(lemma_tac¨a < f x + ~d ± f x + d < bÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 10 (ante_tac o list_µ_elim[¨f x + ~dÆ, ¨f x + dÆ]));
a(asm_rewrite_tac[]);
a(LEMMA_T ¨~ d < ÓØ 0 ± (µ x'∑ f x + ~ d º x' ± x' º f x + d ¥ a < x' ± x' < b)Æ
	rewrite_thm_tac THEN1
	(REPEAT strip_tac THEN_LIST
		[PC_T1 "Ø_lin_arith" asm_prove_tac[],
		all_asm_fc_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[],
		all_asm_fc_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]]));
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(lemma_tac¨ÓØ 0 < x + ~s ± ÓØ 0 < t + ~xÆ THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(strip_asm_tac (list_µ_elim[¨x + ~sÆ, ¨t + ~xÆ] Ø_bound_below_2_thm));
a(∂_tac¨d'Æ THEN ALL_FC_T1 fc_§_canon asm_rewrite_tac [Ø_abs_diff_bounded_thm]);
a(µ_tac THEN ¥_tac);
a(lemma_tac¨s < y ± y < tÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [11] all_fc_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €cts_open_interval_thm› = save_pop_thm "cts_open_interval_thm";
=TEX
The following theorem says that if a function is Darboux continuous (i.e., if it
satisfies the conclusion of the intermediate value theorem) and monotonic
increasing in an interval then it is continuous.
%%%%
%%%%
=SML
set_goal([], ¨µf a b x∑
	(µx y∑ x ç ClosedInterval a b ± y ç ClosedInterval a  b ± x < y ¥ f x < f y)
±	(µy∑ y ç OpenInterval (f a) (f b) ¥ ∂x∑a < x ± x < b  ± f x = y)
±	 x ç OpenInterval a b
¥	f CtsAt xÆ);
a(rewrite_tac[open_interval_def, closed_interval_def] THEN REPEAT strip_tac);
a(bc_thm_tac cts_open_interval_thm THEN
	rewrite_tac[open_interval_def, Ä_def, closed_interval_def] );
a(∂_tac¨f bÆ THEN ∂_tac¨f aÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨c º dÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 2  ¨cÆ THEN spec_nth_asm_tac 4 ¨dÆ);
a(LIST_DROP_NTH_ASM_T [11] all_fc_tac THEN all_var_elim_asm_tac1);
a(rename_tac[(¨x'Æ, "U"), (¨x''Æ, "L")] THEN ∂_tac¨L:ØÆ THEN ∂_tac¨U:ØÆ);
(* *** Goal "3.1" *** *)
a(lemma_tac¨≥x = L ± ≥x = UÆ THEN1 (contr_tac THEN all_var_elim_asm_tac1));
a(lemma_tac¨≥x <  LÆ THEN1
	(contr_tac THEN LEMMA_T¨f x < f LÆ 
		(fn th => ante_tac th THEN GET_ASM_T ¨f L < f xÆ ante_tac
			THEN PC_T1 "Ø_lin_arith" prove_tac[])
		THEN GET_NTH_ASM_T 18 bc_thm_tac
		THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨≥U < xÆ THEN1
	(contr_tac THEN LEMMA_T¨f U < f xÆ 
		(fn th => ante_tac th THEN GET_ASM_T ¨f x < f UÆ ante_tac
			THEN PC_T1 "Ø_lin_arith" prove_tac[])
		THEN GET_NTH_ASM_T 19 bc_thm_tac
		THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨L < x ± x < UÆ THEN1 
	(LIST_DROP_NTH_ASM_T (interval 5 19) discard_tac
		THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(LIST_DROP_NTH_ASM_T [3, 4, 5, 6] discard_tac);
a(asm_rewrite_tac[] THEN REPEAT strip_tac
	THEN DROP_NTH_ASM_T 19 bc_thm_tac THEN
		PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €darboux_cts_mono_thm› = save_pop_thm "darboux_cts_mono_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Derivatives}
%%%%
%%%%
%%%%
%%%%
Following Harrison, we make much use of Carath\'{e}odory's characterisation
of the derivative in terms of the continuity of a certain function:
%%%%
%%%%
=SML
set_goal([], ¨µf c x∑
	(f HasDeriv c) x
§	(∂g∑ (µy∑f y - f x = g(y)*(y - x)) ± g CtsAt x ± g x = c)
Æ);
a(rewrite_tac[has_deriv_def, cts_at_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨Ãz∑ if z = x then c else (f z - f x)/(z - x)Æ
	THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(cases_tac¨y = xÆ THEN asm_rewrite_tac[]);
a(lemma_tac¨≥(y + ~x) = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(rename_tac[(¨xÆ, "x'")] THEN
	ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b∑(a*b)*(y + ~x') = a * (y + ~x') * bÆ]);
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
(* *** Goal "1.2" *** *)
a(all_asm_fc_tac[]);
a(∂_tac¨dÆ THEN REPEAT strip_tac);
a(lemma_tac¨Abs(ÓØ 0) = ÓØ 0Æ THEN1 rewrite_tac[Ø_abs_eq_0_thm]);
a(cases_tac¨y = xÆ THEN1 asm_rewrite_tac[]);
a(ALL_ASM_FC_T asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
a(∂_tac¨dÆ THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
a(lemma_tac¨≥(y + ~x) = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(rename_tac[(¨xÆ, "x'")] THEN
	ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(rewrite_tac[Ø_times_assoc_thm] THEN ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
a(all_var_elim_asm_tac1 THEN DROP_NTH_ASM_T 4 bc_thm_tac THEN REPEAT strip_tac);
val €caratheodory_deriv_thm› = save_pop_thm "caratheodory_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf c x∑ (f HasDeriv c) x ¥ f CtsAt xÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(LEMMA_T ¨f = Ãz∑g z *(z + ~x) + f xÆ once_rewrite_thm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[] THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨x'Æ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT (simple_cts_tac THEN REPEAT strip_tac));
val €has_deriv_cts_thm› = save_pop_thm "has_deriv_cts_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µc t∑ ((Ãx∑c) HasDeriv ÓØ 0) tÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(∂_tac¨Ãz∑ÓØ 0Æ THEN rewrite_tac[]);
a(simple_cts_tac);
val €const_deriv_thm› = save_pop_thm "const_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µt∑ ((Ãx∑x) HasDeriv ÓØ 1) tÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(∂_tac¨Ãz∑ÓØ 1Æ THEN rewrite_tac[]);
a(simple_cts_tac);
val €id_deriv_thm› = save_pop_thm "id_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf1 c1 x f2 c2∑
	(f1 HasDeriv c1) x ± (f2 HasDeriv c2) x
¥	((Ãy∑f1 y + f2 y) HasDeriv (c1 + c2)) xÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(rename_tac[(¨gÆ, "g1"), (¨g'Æ, "g2")] THEN
	∂_tac¨Ãz:Ø∑ g1 z + g2 z:ØÆ THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[plus_cts_thm]);
a(once_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
	¨µa b c d:Ø∑ (a + b) + c + d = (a + c) + b + dÆ]);
a(asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €plus_deriv_thm› = save_pop_thm "plus_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µc x : Ø∑ ($+ c HasDeriv ÓØ 1) xÆ);
a(REPEAT strip_tac);
a(pure_once_rewrite_tac[prove_rule[]¨$+ c = Ãz∑(Ãz∑c) z + (Ãz∑z) zÆ]);
a(conv_tac (RATOR_C (RIGHT_C(eq_match_conv
	(prove_rule[]¨ÓØ 1 = ÓØ 0 + ÓØ 1Æ)))));
a(bc_thm_tac plus_deriv_thm);
a(rewrite_tac [const_deriv_thm, id_deriv_thm]);
val €plus_const_deriv_thm› = save_pop_thm "plus_const_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf1 c1 x f2 c2∑
	(f1 HasDeriv c1) x ± (f2 HasDeriv c2) x
¥	((Ãy∑f1 y * f2 y) HasDeriv (c1*f2 x + f1 x*c2)) xÆ);
a(REPEAT strip_tac THEN lemma_tac¨f2 CtsAt xÆ 
	THEN1 all_fc_tac[has_deriv_cts_thm]);
a(all_asm_ante_tac THEN
	rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(rename_tac[(¨gÆ, "g1"), (¨g'Æ, "g2")] THEN
	∂_tac¨Ãz:Ø∑ g1 z*f2 z +  f1 x*g2 z:ØÆ THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[pc_rule1"Ø_lin_arith"prove_rule[]
	¨µa b c d:Ø∑a*b + ~(c*d) = (a + ~c)*b + c*(b + ~d)Æ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT (simple_cts_tac THEN REPEAT strip_tac));
val €times_deriv_thm› = save_pop_thm "times_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µc x : Ø∑ ($* c HasDeriv c) xÆ);
a(REPEAT strip_tac);
a(pure_once_rewrite_tac[prove_rule[]¨$* c = Ãz∑(Ãz∑c) z * (Ãz∑z) zÆ]);
a(conv_tac (RATOR_C (RIGHT_C(eq_match_conv
	(prove_rule[]¨c = ÓØ 0 * (Ã z∑ z)x + (Ãz∑c)x * ÓØ 1Æ)))));
a(bc_thm_tac times_deriv_thm);
a(rewrite_tac [const_deriv_thm, id_deriv_thm]);
val €times_const_deriv_thm› = save_pop_thm "times_const_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf1 c1 f2 c2 x∑
	(f1 HasDeriv c1) (f2 x) ± (f2 HasDeriv c2) x
¥	((Ãy∑f1(f2 y)) HasDeriv (c1*c2)) xÆ);
a(REPEAT strip_tac THEN lemma_tac¨f2 CtsAt xÆ 
	THEN1 all_fc_tac[has_deriv_cts_thm]);
a(all_asm_ante_tac THEN
	rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(rename_tac[(¨gÆ, "g1"), (¨g'Æ, "g2")] THEN
	∂_tac¨Ãz:Ø∑ g1(f2 z)*g2 z:ØÆ THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT (simple_cts_tac THEN REPEAT strip_tac));
a(bc_thm_tac comp_cts_thm THEN REPEAT strip_tac);
val €comp_deriv_thm› = save_pop_thm "comp_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µc t∑ (~ HasDeriv ~(ÓØ 1)) tÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(∂_tac¨Ãz∑~(ÓØ 1)Æ THEN rewrite_tac[minus_comp_cts_thm, const_cts_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €minus_deriv_thm› = save_pop_thm "minus_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf c t∑ (f HasDeriv c) t ¥ ((Ãx∑~(f x)) HasDeriv ~c) tÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN ∂_tac¨Ãz∑~(g z)Æ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN1 
	(once_rewrite_tac [pc_rule1 "Ø_lin_arith" prove_rule[] ¨µa b:Ø∑a = b § ~a = ~bÆ]
	THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(all_fc_tac[minus_comp_cts_thm]);
val €minus_comp_deriv_thm› = save_pop_thm "minus_comp_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µn t∑ ((Ãx∑x^(n+1)) HasDeriv (ÓØ n + ÓØ 1)*t^n) tÆ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ);
(* *** Goal "1" *** *)
a(pure_rewrite_tac[Ø_Ó_exp_def] THEN rewrite_tac[id_deriv_thm]);
(* *** Goal "2" *** *)
a(pure_once_rewrite_tac[Ø_Ó_exp_def]);
a(pure_rewrite_tac[prove_rule[]¨
	(Ã x:Ø∑ x * x ^ (n + 1)) = Ã x∑ (Ãx∑x) x * (Ãx∑x ^ (n + 1))xÆ]);
a(LEMMA_T¨
	(ÓØ (n + 1) + ÓØ 1) * t * t ^ n =
	ÓØ 1*(Ãx∑x^(n + 1))t + (Ãx∑x) t*(ÓØ n + ÓØ 1)*t^nÆ
	pure_rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[ÓØ_plus_homomorphism_thm, Ø_Ó_exp_def]);
a(conv_tac(RANDS_C Ø_anf_conv) THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(bc_thm_tac times_deriv_thm);
a(asm_rewrite_tac[id_deriv_thm]);
val €power_deriv_thm› = save_pop_thm "power_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µt∑ ≥t = ÓØ 0 ¥ ($õ-õ1 HasDeriv ~(t õ-õ1 * t õ-õ1)) tÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(∂_tac¨Ãy∑
	if	y = t
	then	~(t õ-õ1 * t õ-õ1)
	else	(y õ-õ1 + ~t õ-õ1)*(y + ~t)õ-õ1Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(cases_tac¨y = tÆ THEN asm_rewrite_tac[Ø_times_assoc_thm]);
a(POP_ASM_T (asm_tac o once_rewrite_rule[Ø_eq_thm]));
a(ALL_FC_T rewrite_tac[Ø_recip_clauses, Ø_minus_recip_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[cts_lim_seq_thm1] THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
a(all_fc_tac[lim_seq_≥_0_thm]);
a(once_rewrite_tac[µ_elim¨nÆ lim_seq_shift_thm] THEN rewrite_tac[]);
a(LEMMA_T ¨µn'∑(s (n' + n) õ-õ1 + ~ t õ-õ1) * (s (n' + n) + ~ t) õ-õ1
	= ~(s (n' + n) õ-õ1 * t õ-õ1)Æ rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(lemma_tac¨≥s (n'+n) = ÓØ 0Æ THEN1
	(TOP_ASM_T bc_thm_tac THEN REPEAT strip_tac));
a(lemma_tac¨≥~t = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[Ø_plus_recip_thm]);
a(lemma_tac¨≥s(n'+n) + ~ t = ÓØ 0Æ THEN1
	(spec_nth_asm_tac 4 ¨n'+nÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b c∑
	(a * b * c) * a õ-õ1= b * c * a * a õ-õ1Æ]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses, Ø_minus_recip_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2.2" *** *)
a(LEMMA_T ¨~ (t õ-õ1 * t õ-õ1) = t õ-õ1 * ~(t õ-õ1) ±
	(Ã n'∑ ~ (s (n' + n) õ-õ1 * t õ-õ1)) =
	(Ã n'∑ (Ãm∑ (Ãm'∑s (m' + n)) m õ-õ1) n' * (Ãm∑~ (t õ-õ1)) n')Æ
	 pure_rewrite_thm_tac THEN1
	(conv_tac (ONCE_MAP_C Ø_anf_conv) THEN rewrite_tac[]));
a(bc_thm_tac times_lim_seq_thm THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(bc_thm_tac recip_lim_seq_thm THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[lim_seq_shift_thm]);
(* *** Goal "2.2.2" *** *)
a(rewrite_tac[const_lim_seq_thm]);
(* *** Goal "3" *** *)
a(rewrite_tac[]);
val €recip_deriv_thm› = save_pop_thm "recip_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf c t∑
	(f HasDeriv c) t
±	≥f t = ÓØ 0
¥	((Ãx∑ (f x) õ-õ1) HasDeriv ~((f t) õ-õ1 * (f t) õ-õ1) * c ) tÆ);
a(REPEAT strip_tac);
a(all_fc_tac [recip_deriv_thm]);
a(all_fc_tac [comp_deriv_thm]);
val €recip_comp_deriv_thm› = save_pop_thm "recip_comp_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µl x∑ (PolyEval l HasDeriv PolyEval(DerivCoeffs l) x) xÆ);
a(REPEAT strip_tac THEN list_induction_tac¨l : Ø LISTÆ);
(* *** Goal "1" *** *)
a(rewrite_tac [deriv_coeffs_def]);
a(LEMMA_T ¨PolyEval [] = Ãx∑ÓØ 0Æ rewrite_thm_tac THEN1 rewrite_tac[poly_eval_def]);
a(rewrite_tac[const_deriv_thm]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN rewrite_tac [deriv_coeffs_def] THEN rename_tac[(¨x':ØÆ, "c")]);
a(LEMMA_T ¨PolyEval (Cons c l) = Ãx∑c+ x*PolyEval l xÆ rewrite_thm_tac
	THEN1 rewrite_tac[poly_eval_def]);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) plus_eval_thm]);
a(pure_once_rewrite_tac[prove_rule[]
	¨(Ã x∑ c + x * PolyEval l x) = (Ã x∑ (Ãx∑c) x + (Ãx∑ x * PolyEval l x) x)Æ]);
a(conv_tac(RATOR_C (RIGHT_C (pure_once_rewrite_conv [prove_rule[]¨µx∑x = ÓØ 0 + xÆ]))));
a(bc_thm_tac plus_deriv_thm);
a(rewrite_tac [const_deriv_thm, poly_eval_def]);
a(pure_once_rewrite_tac[prove_rule[]
	¨(Ã x∑ x * PolyEval l x) = (Ã x∑ (Ãx∑ x) x  * PolyEval l x)Æ]);
a(pure_once_rewrite_tac[prove_rule[]
	¨PolyEval l x + x *PolyEval (DerivCoeffs l) x
	= ÓØ 1 * PolyEval l x + (Ãx∑x) x * PolyEval (DerivCoeffs l) xÆ]);
a(bc_thm_tac times_deriv_thm);
a(asm_rewrite_tac[id_deriv_thm]);
val €poly_deriv_thm› = save_pop_thm "poly_deriv_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g x a b c∑
	a < x ± x < b
±	(µy∑ a < y ± y < b ¥ f y = g y)
±	(g HasDeriv c) x
¥	(f HasDeriv c) x Æ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(∂_tac¨Ãz∑if  a < z ± z < b  then g' z else (f z + ~(f x))/(z + ~x)Æ
	THEN all_var_elim_asm_tac1 THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(cases_tac ¨a < y ± y < bÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a(ALL_ASM_FC_T asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(lemma_tac ¨≥y + ~x = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(rename_tac[(¨xÆ, "u")] THEN ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(rewrite_tac[Ø_times_assoc_thm] THEN  ALL_FC_T rewrite_tac[Ø_recip_clauses]);
(* *** Goal "1.3" *** *)
a(lemma_tac ¨≥y + ~x = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(rename_tac[(¨xÆ, "u")] THEN ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(rewrite_tac[Ø_times_assoc_thm] THEN  ALL_FC_T rewrite_tac[Ø_recip_clauses]);
(* *** Goal "2" *** *)
a(bc_thm_tac cts_local_thm);
a(MAP_EVERY ∂_tac [¨g'Æ, ¨bÆ, ¨aÆ] THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
val €deriv_local_thm› = save_pop_thm "deriv_local_thm";
=TEX
A function $f$ is differentiable with derivative $c$ at $x$ iff.
the function $(f(y) - f(x))/(y - x)$ of $y$ tends to $c$ at $x$.
This is a trivial consequence of the definitions.
%%%%
%%%%
=SML
set_goal([], ¨µf c x∑ (f HasDeriv c) x § ((Ãy∑(f y - f x)/(y - x)) --> c) xÆ);
a(rewrite_tac[lim_fun_def, has_deriv_def]);
val €deriv_lim_fun_thm› = save_pop_thm "deriv_lim_fun_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf x c d∑ (f HasDeriv c) x ± (f HasDeriv d) x ¥ c = dÆ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(bc_thm_tac cts_limit_unique_thm);
a(strip_asm_tac(µ_elim¨xÆØ_unbounded_below_thm)
	THEN strip_asm_tac (µ_elim¨xÆØ_unbounded_above_thm));
a(∂_tac¨y'Æ THEN ∂_tac¨yÆ THEN REPEAT strip_tac);
a(lemma_tac¨≥ y'' + ~x = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T ¨µs t∑s = t § s*(y'' + ~x) = t*(y'' + ~x)Æ once_rewrite_thm_tac
	THEN1 (rename_tac[(¨xÆ, "xx")]
		THEN ALL_FC_T1 fc_§_canon rewrite_tac[Ø_times_cancel_thm]));
a(LIST_GET_NTH_ASM_T[8, 10] (rewrite_tac o map (conv_rule(ONCE_MAP_C eq_sym_conv))));
val €deriv_unique_thm› = save_pop_thm"deriv_unique_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Some Classical Theorems}
%%%%
%%%%
%%%%
%%%%
First of all we prove the following rather unusual result which works out
nicely in some cases where we would otherwise have to work directly with
suprema. For the want of a better name, we call it the ``curtain
induction principle'' (think of sliding a curtain along the real line starting
from $-\infty$).
%%%%
%%%%
=SML
set_goal([], ¨µp:Ø≠BOOL∑
	(∂x∑p x)
±	(µx∑p x ¥ µy∑y < x ¥ p y)
±	(µx∑∂y z∑ y < x ± x < z ± (p y ¥ p z))
¥	(µx∑p x) 
Æ);
a(contr_tac);
a(lemma_tac¨∂P∑P = {t | p t}Æ THEN1 prove_∂_tac);
a(lemma_tac¨≥P = {} ± ∂c∑µx∑x ç P ¥ x º cÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨x'Æ THEN all_var_elim_asm_tac1 THEN contr_tac);
a(lemma_tac¨x' < x''Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_fc_tac[Ø_sup_thm] THEN fc_tac[Ø_sup_thm]);
a(LIST_DROP_NTH_ASM_T [1,2] fc_tac);
a(spec_nth_asm_tac 8 ¨Sup PÆ);
(* *** Goal "3.1" *** *)
a(swap_nth_asm_concl_tac 3 THEN rewrite_tac[Ø_≥_less_º_thm]);
a(bc_thm_tac Ø_sup_º_bc_thm THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN1 (∂_tac¨cÆ THEN asm_rewrite_tac[]));
a(contr_tac THEN lemma_tac¨y < y'Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(lemma_tac ¨∂w∑Sup P < w ± w < zÆ THEN1
	(bc_thm_tac Ø_less_dense_thm THEN REPEAT strip_tac));
a(lemma_tac¨w º zÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨w ç PÆ THEN1 (asm_rewrite_tac[] THEN all_asm_fc_tac[]));
a(lemma_tac¨w º Sup PÆ THEN1 all_asm_fc_tac[]);
a(PC_T1"Ø_lin_arith" asm_prove_tac[]);
val €curtain_induction_thm› = save_pop_thm "curtain_induction_thm";
=TEX
%%%%
%%%%
=SML
val €curtain_induction_tac› = gen_induction_tac curtain_induction_thm;
=IGN
set_goal([], ¨µx:Ø∑∂y∑x º yÆ);
a(strip_tac);
a(curtain_induction_tac¨xÆ);
(* *** Goal "1" *** *)
a(∂_tac ¨xÆ THEN ∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN ∂_tac¨yÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨x + ~(1/2)Æ THEN ∂_tac¨x + (1/2)Æ THEN REPEAT strip_tac);
a(∂_tac¨y'+3/2Æ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val test10 = pop_thm();
=TEX
Bolzano's principle of bisection, via a lemma which contains most
of the argument:
%%%%
%%%%
=SML
set_goal([], ¨µp∑
	(µx y∑y < x ¥ p x y)
±	(µx y z∑ x º y ± y º z ± p x y ± p y z ¥ p x z)
±	(µy∑∂d∑ ÓØ 0 < d ± (µx z∑  x º y ± y º z ± z - x < d ¥ p x z))
¥	(µx y∑p x y)
Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨µt∑t º y ¥ p x tÆ (strip_asm_tac o µ_elim¨yÆ));
a(lemma_tac¨µc∑p c cÆ THEN1
	(REPEAT strip_tac THEN
	POP_ASM_T (strip_asm_tac o µ_elim¨c:ØÆ) THEN
	POP_ASM_T bc_thm_tac THEN asm_rewrite_tac[]));
a(curtain_induction_tac¨y:ØÆ);
(* *** Goal "1" *** *)
a(∂_tac¨x + ~(ÓØ 1)Æ THEN REPEAT strip_tac);
a(lemma_tac¨t < xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(GET_NTH_ASM_T 3 bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(cases_tac¨y' < xÆ);
(* *** Goal "3.1" *** *)
a(∂_tac¨y' + ~(ÓØ 1)Æ THEN ∂_tac¨xÆ THEN REPEAT strip_tac);
a(cases_tac¨t < xÆ THEN1 all_asm_fc_tac[]);
a(lemma_tac¨t = xÆ THEN_LIST[PC_T1"Ø_lin_arith"asm_prove_tac[], all_var_elim_asm_tac1]);
a(asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(cases_tac¨≥µb∑b < y' ¥ p x bÆ);
(* *** Goal "3.2.1" *** *)
a(∂_tac¨bÆ THEN ∂_tac¨y' + ÓØ 1Æ THEN REPEAT strip_tac);
a(spec_nth_asm_tac 2 ¨bÆ);
(* *** Goal "3.2.2" *** *)
a(spec_nth_asm_tac 4 ¨y'Æ);
a(∂_tac¨y' + ~(1/3*d)Æ THEN ∂_tac¨y' + 1/3*dÆ THEN REPEAT strip_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(cases_tac¨t < y'Æ THEN1 all_asm_fc_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(lemma_tac¨∂a∑x º a ± a º y' ± y' - a º 1/3*d ± p x aÆ);
(* *** Goal "3.2.2.1" *** *)
a(cases_tac¨x º y' + ~(1/3*d)Æ);
(* *** Goal "3.2.2.1.1" *** *)
a(∂_tac¨y' + ~(1/3*d)Æ THEN REPEAT strip_tac THEN_TRY
	PC_T1"Ø_lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 7 ¨y' + ~(1/3*d)Æ);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.2.1.2" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[]);
(* *** Goal "3.2.2.2" *** *)
a(GET_NTH_ASM_T 14 bc_thm_tac);
a(∂_tac¨aÆ THEN REPEAT strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(GET_NTH_ASM_T 8 bc_thm_tac THEN REPEAT strip_tac);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €bisection_lemma› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µp∑
	(µx y z∑ x º y ± y º z ± p x y ± p y z ¥ p x z)
±	(µy∑∂d∑ ÓØ 0 < d ± (µx z∑  x º y ± y º z ± z - x < d ¥ p x z))
¥	(µa b∑ a º b ¥ p a b)
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µa b∑(Ã x y∑if x º y then p x y else T)a bÆ THEN1
	(bc_thm_tac bisection_lemma THEN rewrite_tac[] THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" (= 3, 4, and 5) *** *)
a(all_asm_fc_tac[]);
(* *** Goal "6" *** *)
a(spec_nth_asm_tac 2 ¨yÆ);
a(∂_tac¨dÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[]));
a(all_asm_fc_tac[]);
(* *** Goal "7" *** *)
a(POP_ASM_T (ante_tac o list_µ_elim[¨aÆ, ¨bÆ]) THEN asm_rewrite_tac[]);
val €bisection_thm› = save_pop_thm"bisection_thm";
=TEX
One half of the Heine-Borel theorem says that every closed interval is compact;
i.e., every covering of the closed interval by a family
of open sets has a finite subcovering.
Nearly all the analysis is in the following lemma, which deals with
the case where the covering actually covers the whole real line:
%%%%
%%%%
=SML
set_goal([], ¨µV x y∑
	V Ä OpenâR
±	(µz∑ z ç ﬁV)
¥	∂W∑ W Ä V ± W ç Finite ± ClosedInterval x y Ä ﬁ WÆ);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(curtain_induction_tac¨y:ØÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨x + ~(ÓØ 1)Æ THEN REPEAT strip_tac);
a(∂_tac¨{}Æ THEN PC_T1 "sets_ext1" rewrite_tac[empty_finite_thm, closed_interval_def]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext1" (spec_nth_asm_tac 1) ¨zÆ THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨ClosedInterval x y Ä ClosedInterval x y'Æ THEN1
	(rewrite_tac[closed_interval_def] THEN
	PC_T1 "sets_ext1" REPEAT strip_tac THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(all_fc_tac[
	pc_rule1 "sets_ext1" prove_rule[]¨µA B C∑A Ä B ± B Ä C ¥ A Ä CÆ]);
a(∂_tac¨WÆ THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(PC_T1 "'propositions" cases_tac¨≥(µ z∑ z ç ﬁ V)Æ THEN asm_rewrite_tac[]);
(* *** Goal "4.1" *** *)
a(∂_tac¨y' + ~(ÓØ 1)Æ THEN ∂_tac¨y' + ÓØ 1Æ THEN REPEAT strip_tac);
(* *** Goal "4.2" *** *)
a(POP_ASM_T (strip_asm_tac o µ_elim¨y'Æ o pc_rule1 "sets_ext1" rewrite_rule[]));
a(DROP_NTH_ASM_T 3 ante_tac THEN
	rewrite_tac[open_Ø_def, open_interval_def] THEN
	PC_T1 "sets_ext" REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_fc_tac[Ø_less_dense_thm]);
a(∂_tac¨z'Æ THEN ∂_tac¨zÆ THEN REPEAT strip_tac);
a(∂_tac¨{s} ¿ WÆ THEN ALL_FC_T rewrite_tac[singleton_¿_finite_thm]);
a(rewrite_tac[closed_interval_def] THEN REPEAT strip_tac);
(* *** Goal "4.2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac THEN1 all_var_elim_asm_tac1);
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
(* *** Goal "4.2.2" *** *)
a(GET_NTH_ASM_T 8 ante_tac THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (strip_asm_tac o pc_rule1 "sets_ext1" rewrite_rule[closed_interval_def]));
a(cases_tac¨x' < x''Æ);
(* *** Goal "4.2.2.1" *** *)
a(∂_tac ¨sÆ THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 5 bc_thm_tac THEN
	REPEAT strip_tac THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "4.2.2.2" *** *)
a(lemma_tac¨x'' º z'Æ  THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T [3] all_fc_tac);
a(∂_tac ¨s'Æ THEN REPEAT strip_tac);
val €heine_borel_lemma› = pop_thm();
=TEX
The theorem follows from the lemma by a simple
argument showing that, w.l.o.g., we may assume that the open covering
of the closed interval is actually an open covering of the whole real line
(because one can throw in the complement of the interval first and then
afterwards discard it from the finite subcovering).
%%%%
%%%%
=SML
set_goal([], ¨µx y∑ ClosedInterval x y ç CompactâRÆ);
a(rewrite_tac[compact_Ø_def] THEN REPEAT strip_tac);
a(lemma_tac¨{~(ClosedInterval x y)} ¿ V Ä OpenâR
	± (µz∑ z ç ﬁ({~(ClosedInterval x y)} ¿ V))Æ THEN
	REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac(pc_rule1 "sets_ext1" prove_rule[]
	¨µx A B∑ x ç B ± A Ä B ¥ {x} ¿ A Ä BÆ) THEN REPEAT strip_tac);
a(rewrite_tac[rewrite_rule[closed_Ø_def] closed_interval_closed_thm]);
(* *** Goal "2" *** *)
a(cases_tac¨≥z ç ClosedInterval x yÆ THEN1
	(∂_tac¨~(ClosedInterval x y)Æ THEN PC_T1 "sets_ext1" asm_rewrite_tac[]
	THEN asm_rewrite_tac[]));
a(all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µA B∑z ç A ± A Ä B ¥ z ç BÆ]);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(all_fc_tac[heine_borel_lemma]);
a(∂_tac¨W \ {~(ClosedInterval x y)}Æ THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN
	all_fc_tac[pc_rule1"sets_ext1" prove_rule[]¨µA B∑x' ç A ± A Ä B ¥ x' ç BÆ] THEN
	all_var_elim_asm_tac1);
(* *** Goal "3.2" *** *)
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨WÆ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "3.3" *** *)
a(POP_ASM_T ante_tac THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(∂_tac¨sÆ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(∂_tac¨x'Æ THEN asm_rewrite_tac[]);
val €closed_interval_compact_thm› = save_pop_thm "closed_interval_compact_thm";
=TEX
The next classical result is that a function continuous on a closed
attains is bounded and, indeed, attains its upper bound.
We do the special case where the function is continuous everywhere
as a lemma first. However, we do the special case in the more general
context of a function on an arbitrary compact set.
%%%%
%%%%
=SML
set_goal([], ¨µX f∑
	≥X = {}
±	X ç CompactâR
±	(µx∑ f CtsAt x)
¥	∂x∑ x ç X ± µz∑z ç X ¥ f z º f xÆ);
a(contr_tac);
a(lemma_tac¨{A | ∂x∑ x ç X ± A = {z | f z < f x}} Ä OpenâRÆ);
(* *** Goal "1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(lemma_tac¨{y | y < f x'} ç OpenâRÆ);
(* *** Goal "1.1" *** *)
a(rewrite_tac[open_Ø_def, open_interval_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_fc_tac[Ø_less_dense_thm]);
a(∂_tac¨t + ~(ÓØ 1)Æ THEN ∂_tac¨zÆ THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(all_var_elim_asm_tac1 THEN fc_tac[cts_open_Ø_thm]);
a(LEMMA_T ¨{z | f z < f x'} = {z | f z ç {y | y < f x'}}Æ pure_rewrite_thm_tac THEN1
	rewrite_tac[]);
a(POP_ASM_T bc_thm_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨X Ä ﬁ{A | ∂x∑ x ç X ± A = {z | f z < f x}}Æ);
(* *** Goal "2.1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨xÆ);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(∂_tac¨{a | f a < f z}Æ THEN asm_rewrite_tac[]);
a(∂_tac¨zÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 5 (fn th => all_fc_tac[rewrite_rule[compact_Ø_def]th]));
a(lemma_tac¨µA B∑ A ç W ± B ç W ¥ A Ä B ≤ B Ä AÆ);
(* *** Goal "2.2.1" *** *)
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(lemma_tac¨A ç {A | ∂x∑ x ç X ± A = {z | f z < f x}} ±
	B ç {A | ∂x∑ x ç X ± A = {z | f z < f x}}Æ THEN1
	(ALL_FC_T rewrite_tac[pc_rule1 "sets_ext1" prove_rule[]
		¨µ x y X Y∑ x ç X ± X Ä Y ¥ x ç YÆ]));
a(all_var_elim_asm_tac1);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2.2" *** *)
a(lemma_tac¨≥W = {}Æ);
(* *** Goal "2.2.2.1" *** *)
a(swap_nth_asm_concl_tac 2 THEN all_var_elim_asm_tac1);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(DROP_NTH_ASM_T 7 (PC_T1 "sets_ext" strip_asm_tac));
a(∂_tac¨xÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(all_fc_tac[finite_chain_thm]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]
		¨µ x y X Y∑ x ç X ± X Ä Y ¥ x ç YÆ]);
a(swap_nth_asm_concl_tac 7 THEN asm_rewrite_tac[]);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(∂_tac¨xÆ THEN asm_rewrite_tac[]);
val €cts_compact_bounded_thm› = save_pop_thm"cts_compact_bounded_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf a b∑
	a º b
±	(µx∑ f CtsAt x)
¥	∂x∑ a º x ± x º b ± µz∑a º z ± z º b ¥ f z º f xÆ);
a(REPEAT strip_tac);
a(lemma_tac¨≥ClosedInterval a b = {} ± ClosedInterval a b ç CompactâRÆ THEN1
	(rewrite_tac[closed_interval_compact_thm] THEN
	rewrite_tac[closed_interval_def] THEN
	PC_T1 "sets_ext1" REPEAT strip_tac THEN
	∂_tac¨aÆ THEN REPEAT strip_tac));
a(all_fc_tac[cts_compact_bounded_thm]);
a(∂_tac ¨xÆ THEN POP_ASM_T ante_tac THEN POP_ASM_T ante_tac);
a(rewrite_tac[closed_interval_def] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
val €cts_bounded_lemma› = pop_thm();
=TEX
Now the general result on the boundedness of a function continuous on
some closed interval:
%%%%
%%%%
=SML
set_goal([], ¨µf a b∑
	a º b
±	(µx∑ a º x ± x º b ¥ f CtsAt x)
¥	∂x∑ a º x ± x º b ± µz∑ a º z ± z º b ¥ f z º f xÆ);
a(REPEAT strip_tac);
a(cases_tac¨a = bÆ THEN1 all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(∂_tac¨bÆ THEN REPEAT strip_tac THEN
	LEMMA_T ¨z = bÆ rewrite_thm_tac THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac ¨a < bÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_fc_tac[conv_rule (ONCE_MAP_C eq_sym_conv) cts_extension_thm]);
a(all_fc_tac[cts_bounded_lemma]);
a(∂_tac¨xÆ THEN REPEAT strip_tac THEN ALL_ASM_FC_T rewrite_tac[]);
val €cts_bounded_thm› = save_pop_thm "cts_bounded_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf a b∑
	a º b
±	(µx∑ a º x ± x º b ¥ f CtsAt x)
¥	∂x∑ a º x ± x º b ± µz∑ a º z ± z º b ¥ Abs(f z) º Abs(f x)Æ);
a(REPEAT strip_tac);
a(bc_thm_tac (rewrite_rule[](µ_elim¨Ãz∑Abs(f z)Æ cts_bounded_thm)));
a(REPEAT strip_tac THEN bc_thm_tac comp_cts_thm);
a(rewrite_tac[abs_cts_thm] THEN all_asm_fc_tac[]);
val €cts_abs_bounded_lemma› =pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf a b∑
	a º b
±	(µx∑ a º x ± x º b ¥ f CtsAt x)
¥	∂c∑ µz∑ a º z ± z º b ¥ Abs(f z) º cÆ);
a(REPEAT strip_tac THEN all_fc_tac[cts_abs_bounded_lemma]);
a(∂_tac¨Abs(f x)Æ THEN asm_rewrite_tac[]);
val €cts_abs_bounded_thm› =save_pop_thm "cts_abs_bounded_thm";
=TEX
The next classical result will be the intermediate value theorem.
As so often, a lemma containing the main part of the argument comes first.
We follow many authors in doing the case where the intermediate value is $0$
first to simplify the absolute value reasoning and we restrict to the case
where the function is negative towards the left of the interval and positive
towards the right. The proof is by bisection.
%%%%
%%%%
=SML
set_goal([], ¨µf∑
	(µx∑ f CtsAt x)
¥	µa b∑ a º b ¥ f a < ÓØ 0 ± ÓØ 0 < f b ¥ ∂x∑a º x ± x º b ± f x = ÓØ 0Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(bc_thm_tac (rewrite_rule[]
	(µ_elim¨Ãa b∑f a < ÓØ 0 ± ÓØ 0 < f b ¥ ∂x∑a º x ± x º b ± f x = ÓØ 0Æ
	bisection_thm)));
a(REPEAT strip_tac THEN_TRY SOLVED_T
	(contr_tac THEN all_asm_fc_tac[Ø_º_trans_thm] THEN all_asm_fc_tac[]));
(* *** Goal "1" *** *)
a(lemma_tac¨f y = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(cases_tac¨f y = ÓØ 0Æ THEN1
	(∂_tac¨ÓØ 1Æ THEN contr_tac THEN all_asm_fc_tac[]));
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[cts_at_def] o µ_elim¨yÆ));
a(lemma_tac ¨ÓØ 0 < (1/3)*Abs (f y)Æ THEN1
	(lemma_tac ¨≥Abs (f y) = ÓØ 0Æ THEN1
	asm_rewrite_tac[Ø_abs_eq_0_thm] THEN
	strip_asm_tac(µ_elim¨f yÆØ_0_º_abs_thm) THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(all_asm_fc_tac[]);
a(∂_tac¨dÆ THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 º ~(x + ~y) ± ÓØ 0 º z + ~yÆ THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨Abs(~(x + ~y)) < d ± Abs(z + ~y) < dÆ ante_tac THEN1
	(asm_rewrite_tac[Ø_abs_def] THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(rewrite_tac[Ø_abs_minus_thm] THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [10] all_fc_tac);
a(LIST_DROP_NTH_ASM_T [1, 2, 7, 8, 14] (MAP_EVERY ante_tac) THEN
	DROP_ASMS_T discard_tac THEN
	MAP_EVERY cases_tac
		[¨ÓØ 0 º f z + ~(f y)Æ, ¨ÓØ 0 º f x + ~(f y)Æ, ¨ÓØ 0 º f yÆ] THEN
	asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €intermediate_value_lemma› = pop_thm();
=TEX
With the lemma, we can prove the intermediate value theorem proper.
There is a small amount of doubt about what the exact statement should be.
We interpret the weasel word ``between'' which occurs in so many textbook
accounts as meaning ``strictly between''. (The more general formulation with
non-strict inequalities is only vacuously more general --- it just gives
one the trivial cases where the interval consists of a point or where the
intermediate value is achieved at one of the end-points; and, of course,
the statement is vacuously true if the interval is empty).
%%%%
%%%%
=SML
set_goal([], ¨µf a b∑
	a < b
±	(µx∑a º x ± x º b ¥ f CtsAt x)
¥	(µy∑(f a < y ± y < f b ≤ f b < y ± y < f a) ¥ ∂x∑ a < x ± x < b ± f x = y)Æ);
a(lemma_tac¨µf a b∑
	a < b
±	(µx∑a º x ± x º b ¥ f CtsAt x)
¥	(µy∑(f a < y ± y < f b) ¥ ∂x∑ a < x ± x < b ± f x = y)Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µx∑a º x ± x º b ¥ (Ãz∑f z + ~y) CtsAt xÆ THEN1
	(REPEAT (simple_cts_tac ORELSE strip_tac) THEN ALL_ASM_FC_T rewrite_tac[]));
a(DROP_NTH_ASM_T 4 discard_tac);
a(all_fc_tac[conv_rule (ONCE_MAP_C eq_sym_conv) cts_extension_thm]);
a(LEMMA_T¨(Ãz∑f z + ~y) a < ÓØ 0 ± ÓØ 0 < (Ãz∑f z + ~y) bÆ ante_tac THEN1
	(rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac ¨a º bÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 3 ¨aÆ THEN POP_ASM_T pure_rewrite_thm_tac);
a(spec_nth_asm_tac 3 ¨bÆ THEN POP_ASM_T rewrite_thm_tac THEN REPEAT strip_tac);
a(all_fc_tac[intermediate_value_lemma]);
a(lemma_tac¨≥x = a ± ≥x = bÆ THEN1
	(contr_tac THEN all_var_elim_asm_tac1 THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨a < x ± x < bÆ THEN1
	(PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(∂_tac ¨xÆ THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [12] (ALL_FC_T (MAP_EVERY ante_tac)));
a(asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN1 (contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]));
a(lemma_tac¨µ x∑ a º x ± x º b ¥ (Ãx∑ ~(f x)) CtsAt xÆ THEN1
	(REPEAT (simple_cts_tac ORELSE strip_tac) THEN ALL_ASM_FC_T rewrite_tac[]));
a(lemma_tac¨ (Ãx∑ ~(f x)) a < ~y ± ~y < (Ãx∑ ~(f x)) bÆ THEN1
	(rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(all_asm_fc_tac[]);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €intermediate_value_thm› = save_pop_thm"intermediate_value_thm";
=TEX
To prove the mean value theorem, we will need the principle that a function which is
differentiable at a local minimum or maximum has a zero derivative there.
Most of the work of this goes into the following special case.
%%%%
%%%%
=SML
set_goal([], ¨µf a b c∑
	a < ÓØ 0 ± ÓØ 0 < b
±	(µy∑a < y ± y < b ¥ ÓØ 0 º f y)
±	f(ÓØ 0) = ÓØ 0
±	(f HasDeriv c)  (ÓØ 0)
¥	c = ÓØ 0Æ);
a(rewrite_tac[caratheodory_deriv_thm] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN all_var_elim_asm_tac1 THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN bc_thm_tac cts_estimate_0_thm THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(cases_tac¨(1/2)*b < (1/2)*dÆ);
(* *** Goal "1.1" *** *)
a(∂_tac¨(1/2)*bÆ THEN rewrite_tac[]);
a(LEMMA_T ¨ÓØ 0 º (1/2)*bÆ (fn th => rewrite_tac[th, Ø_abs_def]) 
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(REPEAT strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨ÓØ 0 º f((1/2)*b)Æ ante_tac THEN1
	((lemma_tac ¨a < (1/2)*b ± (1/2)*b < bÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[])
	THEN all_asm_fc_tac[]));
a(asm_rewrite_tac[]);
a(lemma_tac ¨ÓØ 0 < (1/2)*bÆ  THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(contr_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(ALL_FC_T (MAP_EVERY ante_tac)[µ_elim¨(1/2)*bÆØ_times_mono_thm]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(∂_tac¨(1/2)*dÆ THEN rewrite_tac[]);
a(LEMMA_T ¨ÓØ 0 º (1/2)*dÆ (fn th => rewrite_tac[th, Ø_abs_def]) 
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(REPEAT strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨ÓØ 0 º f((1/2)*d)Æ ante_tac THEN1
	((lemma_tac ¨a < (1/2)*d ± (1/2)*d < bÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[])
	THEN all_asm_fc_tac[]));
a(asm_rewrite_tac[]);
a(lemma_tac ¨ÓØ 0 < (1/2)*dÆ  THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(contr_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(ALL_FC_T (MAP_EVERY ante_tac)[µ_elim¨(1/2)*dÆØ_times_mono_thm]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(cases_tac¨~((1/2)*d) < (1/2)*aÆ);
(* *** Goal "2.1" *** *)
a(∂_tac¨(1/2)*aÆ THEN rewrite_tac[]);
a(LEMMA_T ¨≥ ÓØ 0 º (1/2)*aÆ (fn th => rewrite_tac[th, Ø_abs_def]) 
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(REPEAT strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨ÓØ 0 º f((1/2)*a)Æ ante_tac THEN1
	((lemma_tac ¨a < (1/2)*a ± (1/2)*a < bÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[])
	THEN all_asm_fc_tac[]));
a(asm_rewrite_tac[]);
a(lemma_tac ¨ÓØ 0 < ~((1/2)*a)Æ  THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(contr_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(ALL_FC_T (MAP_EVERY ante_tac)[µ_elim¨~((1/2)*a)ÆØ_times_mono_thm]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(∂_tac¨~((1/2)*d)Æ THEN rewrite_tac[]);
a(LEMMA_T ¨≥ ÓØ 0 º ~((1/2)*d)Æ (fn th => rewrite_tac[th, Ø_abs_def]) 
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(REPEAT strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨ÓØ 0 º f(~((1/2)*d))Æ ante_tac THEN1
	((lemma_tac ¨a < ~((1/2)*d) ± ~((1/2)*d) < bÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[])
	THEN all_asm_fc_tac[]));
a(asm_rewrite_tac[]);
a(lemma_tac ¨ÓØ 0 < (1/2)*dÆ  THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(contr_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(ALL_FC_T (MAP_EVERY ante_tac)[µ_elim¨((1/2)*d)ÆØ_times_mono_thm]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €local_min_lemma› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf x a b c∑
	a < x ± x < b
±	(µy∑a < y ± y < b ¥ f x º f y)
±	(f HasDeriv c)  x
¥	c = ÓØ 0Æ);
a(REPEAT  strip_tac);
a(ante_tac (list_µ_elim[¨Ãz∑f (z + x) + ~(f x)Æ, ¨a + ~xÆ, ¨b + ~xÆ, ¨cÆ]local_min_lemma));
a(STRIP_T bc_thm_tac THEN rewrite_tac[]);
a(strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 (ante_tac o once_rewrite_rule[Ø_º_0_º_thm]));
a(STRIP_T bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(once_rewrite_tac[prove_rule[]¨(Ãz∑f (z + x) + ~(f x)) = (Ãz∑(Ãz∑f (z + x)) z + (Ãz∑~(f x)) z)Æ,
	pc_rule1 "Ø_lin_arith" prove_rule[] ¨c = c + ÓØ 0Æ]);
a(bc_thm_tac plus_deriv_thm THEN rewrite_tac[const_deriv_thm]);
a(once_rewrite_tac[prove_rule[]¨(Ãz∑f (z + x)) = (Ãz∑f((Ãz∑z + x) z))Æ,
	pc_rule1 "Ø_lin_arith" prove_rule[] ¨c = c * ÓØ 1Æ]);
a(bc_thm_tac comp_deriv_thm THEN REPEAT strip_tac THEN1 asm_rewrite_tac[]);
a(once_rewrite_tac[prove_rule[]¨(Ãz∑ z + x) =(Ãz∑(Ãz∑ z) z + (Ãz∑ x) z)Æ,
	pc_rule1 "Ø_lin_arith" prove_rule[] ¨ÓØ 1 = ÓØ 1 + ÓØ 0Æ]);
a(bc_thm_tac plus_deriv_thm THEN rewrite_tac[const_deriv_thm, id_deriv_thm]);
val €local_min_thm› = save_pop_thm"local_min_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf x a b c∑
	a < x ± x < b
±	(µy∑a < y ± y < b ¥ f y º f x)
±	(f HasDeriv c)  x
¥	c = ÓØ 0Æ);
a(REPEAT  strip_tac);
a(ante_tac (list_µ_elim[¨Ãz∑~(f z)Æ, ¨xÆ, ¨aÆ, ¨bÆ, ¨~cÆ]local_min_thm));
a(asm_rewrite_tac[
	pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b:Ø∑(~a º ~b § b º a) ± (~a = b § a = ~b)Æ]);
a(STRIP_T bc_thm_tac);
a(bc_thm_tac minus_comp_deriv_thm THEN REPEAT strip_tac);
val €local_max_thm› = save_pop_thm"local_max_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf a b∑
	a <  b
±	(µx∑a º  x ± x º b ¥ f CtsAt x)
±	(µx∑a <  x ± x < b ¥ ∂c∑ (f HasDeriv c) x)
±	f a = f b
±	(∂x∑a º x ± x º b ± f b < f x)
¥	(∂x∑a <  x ± x < b ± (f HasDeriv (ÓØ 0)) x)Æ);
a(REPEAT  strip_tac);
a(lemma_tac¨a º bÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_fc_tac[cts_bounded_thm]);
a(TOP_ASM_T (ante_tac o µ_elim¨xÆ) THEN LIST_GET_NTH_ASM_T [6, 7] rewrite_tac);
a(once_rewrite_tac[prove_rule[]¨µp q r∑p ± q ± r § p ± q ± (p ± q ¥ r)Æ]);
a(strip_tac THEN ∂_tac¨x'Æ THEN REPEAT strip_tac);
(* *** Goal 1" *** *)
a((cases_tac¨a = x'Æ THEN1 all_var_elim_asm_tac1) THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal 2" *** *)
a((cases_tac¨b = x'Æ THEN1 all_var_elim_asm_tac1) THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal 3" *** *)
a(spec_nth_asm_tac 12 ¨x'Æ);
a(lemma_tac ¨c = ÓØ 0Æ THEN_LIST [bc_thm_tac local_max_thm, all_var_elim_asm_tac1]);
a(MAP_EVERY ∂_tac[¨fÆ, ¨bÆ, ¨x'Æ, ¨aÆ] THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 5 ante_tac THEN DROP_ASMS_T discard_tac);
a(rewrite_tac[Ø_º_def] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val €rolle_lemma› =pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf a b∑
	a <  b
±	(µx∑a º  x ± x º b ¥ f CtsAt x)
±	(µx∑a <  x ± x < b ¥ ∂c∑ (f HasDeriv c) x)
±	f a = f b
¥	(∂x∑a <  x ± x < b ± (f HasDeriv (ÓØ 0)) x)Æ);
a(REPEAT  strip_tac);
a(cases_tac¨µx∑a <  x ± x < b ¥ f x = f bÆ);
(* *** Goal "1" *** *)
a(lemma_tac¨µx∑a º  x ± x º b ¥ f x = f bÆ THEN1
	(rewrite_tac[Ø_º_def] THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1 THEN all_asm_fc_tac[] THEN REPEAT strip_tac));
a(all_fc_tac[Ø_less_dense_thm]);
a(∂_tac¨zÆ THEN REPEAT strip_tac THEN bc_thm_tac deriv_local_thm);
a(MAP_EVERY ∂_tac[¨Ãz:Ø∑f bÆ, ¨bÆ, ¨aÆ] THEN asm_rewrite_tac[const_deriv_thm]);
(* *** Goal "2" *** *)
a(lemma_tac¨f b < f x ≤ f x < f bÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.1" *** *)
a(bc_thm_tac rolle_lemma THEN asm_rewrite_tac[]);
a(∂_tac¨xÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨∂x∑a < x ± x < b ± ((Ãz∑~(f z)) HasDeriv ÓØ 0)xÆ);
a(bc_thm_tac rolle_lemma THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.2.1.1" *** *)
a(bc_thm_tac minus_comp_cts_thm THEN all_asm_fc_tac[]);
(* *** Goal "2.2.1.2" *** *)
a(LIST_GET_NTH_ASM_T [8] all_fc_tac);
a(∂_tac¨~cÆ THEN bc_thm_tac minus_comp_deriv_thm THEN REPEAT strip_tac);
(* *** Goal "2.2.1.3" *** *)
a(∂_tac¨xÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2.2" *** *)
a(∂_tac¨x'Æ THEN REPEAT strip_tac);
a(LEMMA_T¨((Ãz∑~((Ãz∑~(f z)) z)) HasDeriv ~(~(ÓØ 0)))x'Æ
	(fn th => ante_tac th THEN rewrite_tac[»_axiom]));
a(bc_thm_tac minus_comp_deriv_thm);
a(asm_rewrite_tac[]);
val €rolle_thm› = save_pop_thm"rolle_thm";
=TEX
Now the algebraic part of our proof of the mean value theorem
%%%%
%%%%
=SML
set_goal([], ¨µA B a b∑
	a <  b
¥	A + ~( (B + ~A)/(b + ~a) )*a = B + ~( (B + ~A)/(b + ~a) )*bÆ);
a(REPEAT  strip_tac);
a(lemma_tac ¨≥b + ~a = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(LEMMA_T ¨µs t∑s = t § s*(b + ~a) = t*(b + ~a)Æ once_rewrite_thm_tac
	THEN1 ALL_FC_T1 fc_§_canon rewrite_tac[Ø_times_cancel_thm]);
a(once_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
	¨µs t u v w z:Ø∑(s + ~(u*v)*w)*z = s*z + ~(u*w*v*z)Æ]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses] THEN PC_T1"Ø_lin_arith" prove_tac[]);
val €mvt_lemma› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf a b∑
	a <  b
±	(µx∑a º  x ± x º b ¥ f CtsAt x)
±	(µx∑a <  x ± x < b ¥ ∂c∑ (f HasDeriv c) x)
¥	(∂x d∑a <  x ± x < b ± (f HasDeriv d) x ± f(b) - f(a) = (b - a)*d)Æ);
a(rewrite_tac[] THEN REPEAT  strip_tac);
a(lemma_tac¨≥b + ~a = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨∂g∑g = Ãz∑ f z + ~ ( (f b + ~ (f a))/(b + ~a) )*zÆ (∂_THEN asm_tac) THEN1 prove_∂_tac);
a(lemma_tac¨
	(µx∑a º  x ± x º b ¥ g CtsAt x)
±	(µx∑a <  x ± x < b ¥ ∂c∑ (g HasDeriv c) x)
±	g a = g bÆ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN asm_rewrite_tac[
	pc_rule1"Ø_lin_arith" prove_rule[] ¨µs t:Ø∑ (~s)*t = ~(s*t)Æ] THEN simple_cts_tac);
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(rewrite_tac[»_axiom] THEN ALL_ASM_FC_T rewrite_tac[]);
a(REPEAT (simple_cts_tac THEN REPEAT strip_tac));
(* *** Goal "2" *** *)
a(LEMMA_T¨µ t x∑ a < x ± x < b ¥ (∂ c∑ ((Ãz∑f z + ~t*z ) HasDeriv c) x)Æ
	(fn th => asm_rewrite_tac[] THEN bc_thm_tac th THEN REPEAT strip_tac));
a(REPEAT strip_tac);
a(spec_nth_asm_tac 7 ¨x'Æ);
a(∂_tac¨c + ~tÆ THEN pure_once_rewrite_tac[prove_rule[Ø_times_minus_thm]¨µt z:Ø∑~t*z = (Ãz∑~(t*z))zÆ]);
a(bc_thm_tac plus_deriv_thm THEN REPEAT strip_tac);
a(bc_thm_tac minus_comp_deriv_thm);
a(rewrite_tac [times_const_deriv_thm]);
(* *** Goal "3" *** *)
a(ALL_FC_T asm_rewrite_tac[mvt_lemma]);
(* *** Goal "4" *** *)
a(all_fc_tac[rolle_thm]);
a(∂_tac¨xÆ THEN ∂_tac¨ÓØ 0 + (f b + ~(f a))/(b + ~a)Æ THEN REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(LEMMA_T¨f = Ãz∑g z + ((f b + ~ (f a)) / (b + ~ a)) * zÆ
	(conv_tac o RATOR_C o LEFT_C o eq_match_conv));
(* *** Goal "4.1.1" *** *)
a(ALL_FC_T asm_rewrite_tac[Ø_over_times_recip_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "4.1.2" *** *)
a(bc_thm_tac plus_deriv_thm THEN REPEAT strip_tac);
a(rewrite_tac[times_const_deriv_thm]);
(* *** Goal "4.2" *** *)
a(ALL_FC_T asm_rewrite_tac[Ø_over_times_recip_thm]);
a(rewrite_tac[µ_elim¨f b + ~(f a)Æ Ø_times_order_thm]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
val €mean_value_thm› = save_pop_thm"mean_value_thm";
=TEX
In practice the subtleties about not requiring differentiability at the end points of
the interval etc. just adds complication in many uses of the mean value theorem.
%%%%
%%%%
=SML
set_goal([], ¨µf a b∑
	a < b
±	(µx∑a º x ± x º b ¥ ∂c∑ (f HasDeriv c) x)
¥	(∂x d∑a < x ± x <  b ± (f HasDeriv d) x ± f(b) - f(a) = (b - a)*d)Æ);
a(REPEAT strip_tac THEN bc_thm_tac mean_value_thm THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac  has_deriv_cts_thm);
a(contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €mean_value_thm1› = save_pop_thm"mean_value_thm1";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf a b∑
	(µx∑a <  x ± x < b ¥ (f HasDeriv ÓØ 0) x)
¥	(µ x y∑a <  x ± x <  y ± y < b ¥ f x = f y)Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨µ x∑ a < x ± x < b ¥ f CtsAt xÆ THEN1
	(REPEAT strip_tac THEN all_asm_fc_tac[] THEN  all_fc_tac[has_deriv_cts_thm]));
a(lemma_tac ¨µ z∑ x º z ± z º y ¥ f CtsAt zÆ THEN1
	(POP_ASM_T (fn th =>
		(REPEAT strip_tac THEN bc_thm_tac th THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]))));
a(lemma_tac¨µ z∑ x < z ± z < y ¥ ∂ c∑ (f HasDeriv c) zÆ THEN1
	(DROP_NTH_ASM_T 6 (fn th =>
		(REPEAT strip_tac THEN ∂_tac¨ÓØ 0Æ THEN
			bc_thm_tac th THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]))));
a(all_fc_tac[mean_value_thm]);
a(lemma_tac ¨d = ÓØ 0Æ THEN1
	(DROP_NTH_ASM_T 11 (fn th =>
		(bc_thm_tac deriv_unique_thm THEN ∂_tac¨x'Æ THEN ∂_tac¨fÆ
			THEN REPEAT strip_tac THEN bc_thm_tac th
				THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]))));
a(all_var_elim_asm_tac1 THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €deriv_0_thm1› = save_pop_thm"deriv_0_thm1";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf a b∑
	(µx∑a <  x ± x < b ¥ (f HasDeriv ÓØ 0) x)
¥	(∂c∑µ x∑a <  x ± x < b ¥ f x = c)Æ);
a(REPEAT strip_tac);
a(cases_tac¨≥a < bÆ THEN1
	(∂_tac¨cÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(all_fc_tac[Ø_less_dense_thm]);
a(∂_tac¨f zÆ THEN REPEAT strip_tac);
a(cases_tac¨x = zÆ THEN1 asm_rewrite_tac[]);
a(lemma_tac¨x <  z ≤ z < xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]
	THEN all_fc_tac[deriv_0_thm1]);
a(asm_rewrite_tac[]);
val €deriv_0_thm› = save_pop_thm"deriv_0_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf a b∑
	a <  b
±	(µx∑a º  x ± x º b ¥ f CtsAt x)
±	(µx∑a <  x ± x < b ¥ ∂c∑ (f HasDeriv c) x ± ÓØ 0 < c)
¥	(f a < f b)Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨µx∑a <  x ± x < b ¥ ∂c∑ (f HasDeriv c) xÆ  THEN1
	(contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]));
a(all_fc_tac [mean_value_thm]);
a(LIST_DROP_NTH_ASM_T [6] all_fc_tac);
a(all_fc_tac[deriv_unique_thm] THEN all_var_elim_asm_tac);
a(LEMMA_T¨ÓØ 0 < f b - f aÆ (fn th => ante_tac th THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(pure_asm_rewrite_tac[] THEN bc_thm_tac Ø_0_less_0_less_times_thm THEN REPEAT strip_tac);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €deriv_0_less_thm› = save_pop_thm"deriv_0_less_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Uncountabiliy of the Reals}
We prove Cantor's thorem that the reals are uncountable and develop some useful
facts about sequences and nested intervals {\it en route}.
The first two facts about sequences just give the obvious one-step criteria for a sequence
to be monotone increasing or decreasing.
%%%%
%%%%
=SML
set_goal([], ¨µf : Ó ≠ Ø∑ (µm∑f m º f (m+1)) ¥ (µm n∑f m º f(m + n))Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ THEN1 rewrite_tac[]);
a(bc_thm_tac Ø_º_trans_thm);
a(∂_tac¨f(m+n)Æ THEN  REPEAT strip_tac);
a(once_rewrite_tac[plus_assoc_thm1] THEN asm_rewrite_tac[]);
val €Ø_mono_inc_seq_thm› = save_pop_thm "Ø_mono_inc_seq_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf : Ó ≠ Ø∑ (µm∑f(m+1) º f m) ¥ (µm n∑ f(m+n) º f m)Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ THEN1 rewrite_tac[]);
a(bc_thm_tac Ø_º_trans_thm);
a(∂_tac¨f (m+n)Æ THEN  REPEAT strip_tac);
a(once_rewrite_tac[plus_assoc_thm1] THEN asm_rewrite_tac[]);
val Ø_mono_dec_seq_thm = save_pop_thm "Ø_mono_dec_seq_thm";
=TEX
We now want to investigate the ordering relations that hold between the lower and upper
bounds of  a sequence of nested closed intervals.
In the applications, it is easier to work with sequences of lower and upper bounds rather
than the sequences of intervals themselves, and so we do this, while making the names of the
theorems reflect their intended purpose.
We first of all want to prove that no lower bound is greater than any upper bound. We do
the two parts of this assertion as lemmas first:
%%%%
%%%%
=SML
set_goal([], ¨µL U: Ó ≠ Ø∑
	(µm∑L m º L (m+1) ± U (m+1) º U m ± L m º U m)
¥	(µm n∑L m º U (m+n))Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µm∑L m º L(m+1)Æ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[Ø_mono_inc_seq_thm]);
a(bc_thm_tac Ø_º_trans_thm THEN ∂_tac¨L(m+n)Æ THEN asm_rewrite_tac[]);
val nested_interval_lemma1 = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µL U : Ó ≠ Ø∑
	(µm∑L m º L (m+1) ± U (m+1) º U m ± L m º U m)
¥	(µm n∑L (m+n) º U m)Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µm∑U (m+1) º U mÆ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[Ø_mono_dec_seq_thm]);
a(bc_thm_tac Ø_º_trans_thm THEN ∂_tac¨U(m+n)Æ THEN asm_rewrite_tac[]);
val nested_interval_lemma2 = pop_thm();
=TEX
The two parts now fit together to give the theorem that no lower bound of a sequence
of nested intervals is greater than any upper bound.
%%%%
%%%%
=SML
set_goal([], ¨µL U : Ó ≠ Ø∑
	(µm∑L m º L (m+1) ± U (m+1) º U m ± L m º U m)
¥	(µm n∑L m º U n)Æ);
a(REPEAT strip_tac THEN LEMMA_T ¨m:Ó º n ≤ n º mÆ ante_tac THEN1
	rewrite_tac[º_cases_thm]);
a(rewrite_tac[º_def] THEN REPEAT strip_tac THEN all_var_elim_asm_tac1 THEN
	ALL_FC_T rewrite_tac [nested_interval_lemma1, nested_interval_lemma2]);
val €nested_interval_bounds_thm› = save_pop_thm "nested_interval_bounds_thm";
=TEX
We can now prove Cantor's theorem that the reals are uncountable given two more
rather specific lemmas. The first of these lemmas says that given a closed interval containing
more than one point and any real number, there is a sub-interval, also containing more than
one point, that does not contain the given number.
%%%%
%%%%
=SML
set_goal([], ¨µa b x : Ø∑
	a < b
¥	(∂c d∑ a º c ± c < d ± d º b ± (x < c ≤ d < x))Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂u∑a < u ± u < bÆ THEN1
	(all_fc_tac [Ø_less_dense_thm] THEN contr_tac THEN all_asm_fc_tac[]));
a(lemma_tac¨∂v∑u < v ± v < bÆ THEN1
	(all_fc_tac [Ø_less_dense_thm] THEN contr_tac THEN all_asm_fc_tac[]));
a(cases_tac¨x º uÆ THEN1
	(∂_tac¨vÆ THEN ∂_tac¨bÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(∂_tac¨aÆ THEN ∂_tac¨uÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €cantor_lemma1› = pop_thm();
=TEX
The second lemma simply makes the previous one easier to use to define the sequences
of lower and upper bounds of a sequence of nested closed intervals whose intersection
will miss a given attempt to enumerate the reals.
%%%%
%%%%
=SML
set_goal([], ¨∂f g: Ø ≠ Ø ≠ Ø ≠ Ø∑ µx a b∑
	a < b
¥	a º f x a b ± g x a b º b ± f x a b < g x a b ± (x < f x a b ≤ g x a b < x)Æ);
a(prove_∂_tac THEN REPEAT strip_tac);
a(cases_tac¨≥a'' < b''Æ THEN asm_rewrite_tac[]);
a(all_fc_tac[cantor_lemma1] THEN (POP_ASM_T (strip_asm_tac o µ_elim ¨x''Æ))
	THEN ∂_tac¨dÆ THEN ∂_tac¨cÆ THEN REPEAT strip_tac);
val €cantor_lemma2› = pop_thm();
=TEX
Now the main part of the proof of Cantor's theorem: if a sequence $X_m$ of real numbers is given,
we can find a sequence of closed intervals $[L_m, U_m]$, such that $X_m \not\in [L_m, U_m]$.
%%%%
%%%%
=SML
set_goal([], ¨µX : Ó ≠ Ø∑ ∂L U: Ó ≠ Ø∑µm∑
	L m º L (m+1)
±	U (m+1) º U m
±	L m < U  m
±	(X m < L m ≤ U m< X m)Æ);
a(REPEAT strip_tac);
a(lemma_tac¨ ∂L U: Ó ≠ Ø∑
	L 0 < U 0
±	µm∑L m < U m 
	¥	L m º L (m+1)
	±	U (m+1) º U m
	±	L (m+1) < U  (m+1)
	±	(X m < L (m+1) ≤ U (m+1) < X m)Æ);
(* *** Goal "1" *** *)
a(lemma_tac¨∂a b:Ø∑ a < bÆ THEN1 (∂_tac¨ÓØ 0Æ THEN ∂_tac¨ÓØ 1Æ THEN REPEAT strip_tac));
a(strip_asm_tac cantor_lemma2);
a(lemma_tac¨∂h : Ó ≠ Ø ∏ Ø∑
	h 0 = (a, b)
±	µm∑ h(m + 1) = (f (X m) (Fst(h m)) (Snd(h m)), g (X m) (Fst(h m)) (Snd(h m)))
Æ THEN1 prove_∂_tac);
a(∂_tac¨Ãm∑Fst (h m)Æ THEN ∂_tac ¨Ãm∑Snd (h m)Æ THEN strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨µm∑L m < U mÆ THEN1
	(strip_tac THEN induction_tac¨m:ÓÆ THEN
	REPEAT strip_tac THEN all_asm_fc_tac[]));
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨Ãm∑L(m+1)Æ THEN ∂_tac ¨Ãm∑U(m+1)Æ THEN asm_rewrite_tac[]);
val €nested_interval_diag_thm› = save_pop_thm"nested_interval_diag_thm";
=TEX
Now we show that any sequence of nested closed intervals has non-empty intersection:
%%%%
%%%%
=SML
set_goal([], ¨µL U: Ó ≠ Ø∑
	(µm∑L m º L (m+1) ± U (m+1) º U m ± L m º U m)
¥	(∂x∑µm∑L m º x ± x ºU m)Æ);
a(REPEAT strip_tac);
a(LEMMA_T ¨
	≥ {x|∂ m∑ x = L m} = {}
±	(∂ a∑ µ x∑ x ç {x|∂ m∑ x = L m} ¥ x º a)Æ (±_THEN asm_tac));
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext" prove_tac[]);
a(∂_tac¨U kÆ THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(all_fc_tac[nested_interval_bounds_thm] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨Sup{x|∂ m∑ x = L m}Æ THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac Ø_º_sup_bc_thm THEN asm_rewrite_tac[]);
a(prove_tac[]);
(* *** Goal "2.2" *** *)
a(bc_thm_tac Ø_sup_º_bc_thm THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(all_fc_tac[nested_interval_bounds_thm] THEN asm_rewrite_tac[]);
val €nested_interval_intersection_thm› = save_pop_thm"nested_interval_intersection_thm";
=TEX
Putting the last two theorems together gives us Cantor's theorem:
%%%%
%%%%
=SML
set_goal([], ¨µX: Ó ≠ Ø∑ ∂x∑µm∑≥x = X mÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨XÆ nested_interval_diag_thm));
a(lemma_tac¨∂x∑µm∑L m º x ± x ºU mÆ THEN1
	(bc_thm_tac nested_interval_intersection_thm THEN asm_rewrite_tac[]
	THEN asm_rewrite_tac[Ø_º_def]));
a(∂_tac¨xÆ THEN contr_tac THEN all_var_elim_asm_tac1);
a(spec_nth_asm_tac 1 ¨mÆ);
a(spec_nth_asm_tac 4 ¨mÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €Ø_uncountable_thm ›= list_save_thm(["Ø_uncountable_thm", "cantor_Ø_thm"], pop_thm());
=TEX
\subsection{More Topology}
We now develop some more topological results.
First of all we prove the standard facts about unions and intersections of open and closed sets
(which comprise the axioms for same in abstract topology).
These facts depend in turn on simpler facts about open and closed intervals:
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx1 y1 x2 y2∑∂x y∑ OpenInterval x1 y1 ° OpenInterval x2 y2 = OpenInterval x yÆ);
a(REPEAT strip_tac THEN cases_tac¨(x1:Ø) < x2Æ THEN cases_tac¨(y1:Ø) < y2Æ);
(* *** Goal "1" *** *)
a(∂_tac¨x2Æ THEN ∂_tac¨y1Æ THEN PC_T1 "sets_ext" rewrite_tac[get_spec¨OpenIntervalÆ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨x2Æ THEN ∂_tac¨y2Æ THEN PC_T1 "sets_ext" rewrite_tac[get_spec¨OpenIntervalÆ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨x1Æ THEN ∂_tac¨y1Æ THEN PC_T1 "sets_ext" rewrite_tac[get_spec¨OpenIntervalÆ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "4" *** *)
a(∂_tac¨x1Æ THEN ∂_tac¨y2Æ THEN PC_T1 "sets_ext" rewrite_tac[get_spec¨OpenIntervalÆ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €°_open_interval_thm›=save_pop_thm "°_open_interval_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx1 y1 x2 y2∑∂x y∑ ClosedInterval x1 y1 ° ClosedInterval x2 y2 = ClosedInterval x yÆ);
a(REPEAT strip_tac THEN cases_tac¨(x1:Ø) < x2Æ THEN cases_tac¨(y1:Ø) < y2Æ);
(* *** Goal "1" *** *)
a(∂_tac¨x2Æ THEN ∂_tac¨y1Æ THEN PC_T1 "sets_ext" rewrite_tac[get_spec¨ClosedIntervalÆ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨x2Æ THEN ∂_tac¨y2Æ THEN PC_T1 "sets_ext" rewrite_tac[get_spec¨ClosedIntervalÆ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨x1Æ THEN ∂_tac¨y1Æ THEN PC_T1 "sets_ext" rewrite_tac[get_spec¨ClosedIntervalÆ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "4" *** *)
a(∂_tac¨x1Æ THEN ∂_tac¨y2Æ THEN PC_T1 "sets_ext" rewrite_tac[get_spec¨ClosedIntervalÆ]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €°_closed_interval_thm›=save_pop_thm "°_closed_interval_thm";
=TEX
Now we show that open sets are closed under arbitrary unions \ldots
%%%%
%%%%
=SML
set_goal([], ¨µV∑ V Ä OpenâR ¥ ﬁV ç OpenâRÆ);
a(PC_T1"sets_ext" rewrite_tac[get_spec¨OpenâRÆ] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(∂_tac¨x'Æ THEN ∂_tac¨yÆ THEN contr_tac THEN all_asm_fc_tac[]);
val €ﬁ_open_Ø_thm›=save_pop_thm "ﬁ_open_Ø_thm";
=TEX
\ldots and hence under binary unions \ldots
%%%%
%%%%
=SML
set_goal([], ¨µX Y∑ X ç OpenâR ± Y ç OpenâR ¥ X ¿ Y ç OpenâRÆ);
a(REPEAT µ_tac);
a(ante_tac(µ_elim¨{X; Y}Æ ﬁ_open_Ø_thm));
a(rewrite_tac[pc_rule1"sets_ext" prove_rule[]¨µx y c∑ {x; y} Ä c § x ç c ± y ç cÆ]);
(* Need lemma which is easier to prove generically: *)
	push_goal([], ¨µx y∑ ﬁ{x; y} = x ¿ yÆ);
	a(PC_T1 "sets_ext" REPEAT strip_tac THEN all_asm_fc_tac[]);
	(* *** Goal "1" *** *)
	a(∂_tac¨xÆ THEN PC_T1 "sets_ext" REPEAT strip_tac);
	(* *** Goal "2" *** *)
	a(∂_tac¨yÆ THEN PC_T1 "sets_ext" REPEAT strip_tac);
(a o rewrite_thm_tac o pop_thm)();
val €¿_open_Ø_thm ›=save_pop_thm "¿_open_Ø_thm";
=TEX
\ldots and under binary intersections \ldots
%%%%
%%%%
=SML
set_goal([], ¨µX Y∑ X ç OpenâR ± Y ç OpenâR ¥ X ° Y ç OpenâRÆ);
a(rewrite_tac[get_spec¨OpenâRÆ] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(strip_asm_tac (list_µ_elim[¨xÆ, ¨yÆ, ¨x'Æ , ¨y'Æ] °_open_interval_thm));
a(∂_tac¨x''Æ THEN ∂_tac¨y''Æ THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(REPEAT_N 4 (POP_ASM_T ante_tac) THEN PC_T1 "sets_ext" prove_tac[]);
val €°_open_Ø_thm ›=save_pop_thm "°_open_Ø_thm";
=TEX
To get the analogous fcts for closed sets, we need a lemma about complements of
intersections:
%%%%
%%%%
=SML
set_goal([], ¨µv∑~(•v) = ﬁ{a | ~a ç v}Æ);
a(PC_T1"sets_ext" rewrite_tac[complement_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨~sÆ THEN rewrite_tac[complement_def] THEN REPEAT strip_tac);
a(asm_rewrite_tac[pc_rule1"sets_ext" prove_rule[complement_def]¨µa:'a SET∑~ (~ a) = aÆ]);
(* *** Goal "2" *** *)
a(∂_tac¨~sÆ THEN rewrite_tac[complement_def] THEN REPEAT strip_tac);
val €complement_•_lemma› = pop_thm();
=TEX
\ldots whence closed sets are closed under arbitrary intersections \ldots
%%%%
%%%%
=SML
set_goal([], ¨µV∑ V Ä ClosedâR ¥ •V ç ClosedâRÆ);
a(rewrite_tac[get_spec¨ClosedâRÆ, complement_•_lemma]);
a(REPEAT strip_tac THEN bc_thm_tac ﬁ_open_Ø_thm);
a(PC_T1"sets_ext" asm_prove_tac []);
a(ALL_ASM_FC_T (MAP_EVERY ante_tac) []);
a(rewrite_tac[pc_rule1"sets_ext" prove_rule[complement_def]¨µa:'a SET∑~ (~ a) = aÆ]);
val €•_closed_Ø_thm›=save_pop_thm "•_closed_Ø_thm";
=TEX
\ldots and under binary intersections \ldots
%%%%
%%%%
=SML
set_goal([], ¨µX Y∑ X ç ClosedâR ± Y ç ClosedâR ¥ X ° Y ç ClosedâRÆ);
a(rewrite_tac[get_spec¨ClosedâRÆ,
	pc_rule1"sets_ext" prove_rule[complement_def]¨µa b∑~(a ° b) = ~a ¿ ~bÆ]);
a(REPEAT strip_tac THEN bc_thm_tac ¿_open_Ø_thm THEN REPEAT strip_tac);
val €°_closed_Ø_thm›=save_pop_thm "°_closed_Ø_thm";
=TEX
\ldots and under binary unions:
%%%%
%%%%
=SML
set_goal([], ¨µX Y∑ X ç ClosedâR ± Y ç ClosedâR ¥ X ¿ Y ç ClosedâRÆ);
a(rewrite_tac[get_spec¨ClosedâRÆ,
	pc_rule1"sets_ext" prove_rule[complement_def]¨µa b∑~(a ¿ b) = ~a ° ~bÆ]);
a(REPEAT strip_tac THEN bc_thm_tac °_open_Ø_thm THEN REPEAT strip_tac);
val €¿_closed_Ø_thm›=save_pop_thm "¿_closed_Ø_thm";
=TEX
We have already proved that closed intervals are closed sets.
We now prove that opern intervals are open sets and various facts about complements
of intervals and half-infinite intervals (which we just write out as set comprehensions):
%%%%
%%%%
=SML
set_goal([], ¨µx y∑ OpenInterval x y ç OpenâRÆ);
a(rewrite_tac[get_spec¨OpenâRÆ] THEN REPEAT strip_tac);
a(∂_tac¨xÆ THEN ∂_tac¨yÆ THEN PC_T1 "sets_ext" REPEAT strip_tac);
val €open_interval_open_thm›=save_pop_thm "open_interval_open_thm";
=TEX
The complement of an open interval is the union of two closed half-infinite intervals:
%%%%
%%%%
=SML
set_goal([], ¨µx y∑ ~(OpenInterval x y) = {t | t º x} ¿ {t | y º t}Æ);
a(rewrite_tac(map get_spec[ ¨OpenIntervalÆ]));
a(PC_T1"sets_ext" rewrite_tac[complement_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €complement_open_interval_thm›=save_pop_thm "complement_open_interval_thm";
=TEX
The complement of a closed interval is the union of two open half-infinite intervals:
%%%%
%%%%
=SML
set_goal([], ¨µx y∑ ~(ClosedInterval x y) = {t | t < x} ¿ {t | y < t}Æ);
a(rewrite_tac(map get_spec[ ¨ClosedIntervalÆ]));
a(PC_T1"sets_ext" rewrite_tac[complement_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €complement_closed_interval_thm›=save_pop_thm "complement_closed_interval_thm";
=TEX
Open half-infinite intervals are open sets:
%%%%
%%%%
=SML
set_goal([], ¨µx∑ {t | t < x} ç OpenâR ± {t | x < t} ç OpenâRÆ);
a(rewrite_tac [get_spec ¨OpenâRÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[Ø_less_dense_thm]);
a(strip_asm_tac (µ_elim¨tÆØ_unbounded_below_thm));
a(∂_tac¨yÆ THEN  ∂_tac¨zÆ THEN PC_T1 "sets_ext" rewrite_tac[open_interval_def]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(all_fc_tac[Ø_less_dense_thm]);
a(strip_asm_tac (µ_elim¨tÆØ_unbounded_above_thm));
a(∂_tac¨zÆ THEN  ∂_tac¨yÆ THEN PC_T1 "sets_ext" rewrite_tac[open_interval_def]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €half_infinite_intervals_open_thm›=save_pop_thm "half_infinite_intervals_open_thm";
=TEX
Closed half-infinite intervals are closed sets:
%%%%
%%%%
=SML
set_goal([], ¨µx∑ {t | t º x} ç ClosedâR ± {t | x º t} ç ClosedâRÆ);
a(rewrite_tac [get_spec ¨ClosedâRÆ]);
a(LEMMA_T¨µx:Ø∑ ~ {t|t º x} = {t | x < t} ± ~ {t|x º t} = {t | t < x}Æ
	(fn th => rewrite_tac[th, half_infinite_intervals_open_thm]));
a(PC_T1 "sets_ext" rewrite_tac[complement_def] THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €half_infinite_intervals_closed_thm›=save_pop_thm "half_infinite_intervals_closed_thm";
=TEX
The empty set and the set of all real numbers are both open and closed:
%%%%
%%%%
=SML
set_goal([], ¨{} ç OpenâR ± Universe ç OpenâR ± {} ç ClosedâR ± Universe ç ClosedâRÆ);
a(rewrite_tac [get_spec ¨ClosedâRÆ, taut_rule¨µp q∑ p ± q ± q ± p § p ± qÆ]);
a(rewrite_tac[get_spec¨OpenâRÆ] THEN REPEAT strip_tac);
a(rewrite_tac[get_spec¨OpenIntervalÆ]);
a(∂_tac ¨t + ~(ÓØ 1)Æ THEN ∂_tac¨t + (ÓØ 1)Æ THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €empty_universe_open_closed_thm›=save_pop_thm "empty_universe_open_closed_thm";
=TEX
Now we can prove that compact sets are closed:
%%%%
%%%%
=SML
set_goal([], ¨CompactâR Ä ClosedâRÆ);
a(PC_T1 "sets_ext" rewrite_tac[]);
a(rewrite_tac(map get_spec[¨CompactâRÆ]));
a(REPEAT strip_tac THEN rename_tac[(¨x:Ø SETÆ, "C")]);
a(cases_tac¨C = {}Æ THEN1 asm_rewrite_tac[empty_universe_open_closed_thm]);
a(rewrite_tac(map get_spec[¨ClosedâRÆ]) THEN REPEAT strip_tac);
a(rewrite_tac[pc_rule1"sets_ext"prove_rule[complement_def]¨µa:'a SET∑~a = {z | ≥z ç a}Æ]);
a(rewrite_tac[open_Ø_def] THEN REPEAT strip_tac);
a(lemma_tac¨∂V∑V = {X | ∂e∑ ÓØ 0 < e ± X = {z | z < t + ~e} ¿{z | t + e < z}}Æ
	THEN1 prove_∂_tac);
a(lemma_tac¨V Ä OpenâR ± C Ä ﬁ VÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T "sets_ext" strip_tac THEN all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN bc_thm_tac ¿_open_Ø_thm);
a(rewrite_tac[half_infinite_intervals_open_thm]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨xÆ, ¨tÆ]Ø_less_cases_thm) THEN_TRY (SOLVED_T all_var_elim_asm_tac)
	THEN all_fc_tac[Ø_less_dense_thm]);
(* *** Goal "2.1" *** *)
a(∂_tac¨{w|w < t + ~(t + ~z)} ¿ {w|t + (t + ~z) < w}Æ THEN REPEAT strip_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(∂_tac¨t + ~zÆ THEN REPEAT strip_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(∂_tac¨{w|w < t + ~(z + ~t)} ¿ {w|t + (z + ~t) < w}Æ THEN REPEAT strip_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(∂_tac¨z + ~tÆ THEN REPEAT strip_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
a(cases_tac¨W = {}Æ THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(lemma_tac¨µA B∑ A ç W ± B ç W ¥ A Ä B ≤ B Ä AÆ);
(* *** Goal "3.1" *** *)
a(REPEAT µ_tac THEN ¥_tac);
a(LEMMA_T¨A ç V ± B ç VÆ ante_tac THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(asm_rewrite_tac[] THEN ¥_tac THEN asm_rewrite_tac[]);
a(strip_asm_tac(list_µ_elim[¨eÆ, ¨e'Æ] Ø_º_cases_thm) THEN_LIST
	[≤_right_tac, ≤_left_tac] THEN PC_T1 "sets_ext" REPEAT strip_tac
	THEN PC_T1"Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2" *** *)
a(all_fc_tac[finite_chain_thm]);
a(LEMMA_T ¨A ç VÆ ante_tac THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(var_elim_nth_asm_tac 10 THEN REPEAT strip_tac);
a(∂_tac¨t + ~eÆ THEN ∂_tac¨t + eÆ THEN rewrite_tac[open_interval_def] THEN
	PC_T1 "sets_ext" REPEAT strip_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨C Ä AÆ ante_tac THEN1 (var_elim_nth_asm_tac 5 THEN strip_tac));
a(LEMMA_T¨≥x ç AÆ ante_tac THEN_LIST
	[asm_rewrite_tac[], PC_T1 "sets_ext" prove_tac[]]);
a(PC_T1 "sets_ext" REPEAT strip_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €compact_closed_thm ›= save_pop_thm "compact_closed_thm";
=TEX
Compact sets contain their minimum and maximum values:
%%%%
%%%%
=SML
set_goal([], ¨µX∑
	≥X = {}
±	X ç CompactâR
¥	∂L U∑ L ç X ± U ç X ± µx∑x ç X ¥ L º x ± x º UÆ);
a(REPEAT strip_tac);
a(strip_asm_tac id_cts_thm);
a(LEMMA_T¨µt∑ (Ãx∑~((Ãx∑ x)x)) CtsAt tÆ ante_tac THEN1
	(µ_tac THEN bc_thm_tac minus_comp_cts_thm THEN asm_rewrite_tac[]));
a(rewrite_tac[] THEN strip_tac);
a(ALL_FC_T (MAP_EVERY ante_tac) [cts_compact_bounded_thm]);
a(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µx y:Ø∑~x º ~y § y º xÆ]
	THEN REPEAT strip_tac);
a(∂_tac¨x'Æ THEN ∂_tac¨xÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val €compact_min_max_thm ›= save_pop_thm "compact_min_max_thm ";
=TEX
Closed subsets of compact sets are compact:
%%%%
%%%%
=SML
set_goal([], ¨µX Y∑
	Y ç ClosedâR ± Y Ä X ± X ç CompactâR
¥	Y ç CompactâRÆ);
a(rewrite_tac[closed_Ø_def, compact_Ø_def] THEN REPEAT strip_tac);
a(lemma_tac¨{~Y} ¿ V Ä OpenâR ± X Ä ﬁ({~Y} ¿ V)Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac (pc_rule1 "sets_ext" prove_rule[] ¨µx b c∑x ç c ± b Ä c ¥ {x} ¿ b Ä cÆ)
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(cases_tac¨x ç YÆ);
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 3 (PC_T1 "sets_ext" strip_asm_tac));
a(PC_T1 "sets_ext" all_asm_fc_tac[]);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(∂_tac¨~YÆ THEN rewrite_tac[complement_def] THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
a(∂_tac¨W \ {~Y}Æ THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(bc_thm_tac (pc_rule1 "sets_ext" prove_rule[] ¨µa b c∑a Ä b ¿ c ¥ a \ b Ä cÆ)
	THEN REPEAT strip_tac);
(* *** Goal "3.2" *** *)
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨WÆ THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "3.3" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(lemma_tac¨Y Ä ﬁWÆ THEN1
	all_fc_tac [pc_rule1 "sets_ext" prove_rule[] ¨µa b c∑a Ä b ± b Ä  c ¥ a Ä cÆ]);
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN DROP_ASMS_T discard_tac
	THEN PC_T1 "sets_ext" REPEAT strip_tac);
a(PC_T1 "sets_ext" all_asm_fc_tac[]);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
a(contr_tac THEN all_var_elim_asm_tac1);
a(PC_T1 "sets_ext" asm_prove_tac[complement_def]);
val €closed_Ä_compact_thm ›= save_pop_thm "closed_Ä_compact_thm";
=TEX
The empty set is compact but the set of all real numbers is not:
%%%%
%%%%
=SML
set_goal([], ¨{} ç CompactâR ± ≥Universe ç CompactâRÆ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[compact_Ø_def] THEN REPEAT strip_tac THEN ∂_tac¨{}Æ
	THEN rewrite_tac[empty_finite_thm]);
(* *** Goal "2" *** *)
a(contr_tac THEN LEMMA_T¨≥(Universe:Ø SET) = {}Æ asm_tac THEN1
	PC_T1 "sets_ext" rewrite_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [compact_min_max_thm ]);
a(rewrite_tac[] THEN contr_tac);
a(strip_asm_tac(µ_elim¨LÆ Ø_unbounded_below_thm));
a(lemma_tac¨L º yÆ THEN1 asm_rewrite_tac[]);
a(PC_T1"Ø_lin_arith" asm_prove_tac[]);
val €empty_universe_compact_thm ›= save_pop_thm "empty_universe_compact_thm";
=TEX
The Heine-Borel theorem: a set is compact iff. it is closed and bounded:
%%%%
%%%%
=SML
set_goal([], ¨µX∑
	X ç CompactâR
§	X ç ClosedâR ± ∂L U∑ µx∑x ç X ¥ L º x ± x º UÆ);
a(µ_tac);
a(cases_tac¨X = {}Æ THEN1 asm_rewrite_tac[
	empty_universe_open_closed_thm, empty_universe_compact_thm]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext" all_fc_tac[compact_closed_thm]);
(* *** Goal "2" *** *)
a(all_fc_tac[compact_min_max_thm]);
a(∂_tac¨LÆ THEN ∂_tac¨UÆ THEN POP_ASM_T accept_tac);
(* *** Goal "3" *** *)
a(lemma_tac¨X Ä ClosedInterval L UÆ THEN1
	PC_T1 "sets_ext" asm_rewrite_tac[closed_interval_def]);
a(bc_thm_tac closed_Ä_compact_thm);
a(∂_tac¨ClosedInterval L UÆ THEN asm_rewrite_tac[closed_interval_compact_thm]);
val €heine_borel_thm ›= save_pop_thm "heine_borel_thm";
=TEX
The following lemma contains most of the proof that the real numbers are connected.
It says that if $X$ and $Y$ are non-empty open sets whose union is the set of all real numbers
then $X$ and $Y$ are not disjoint, under the hypothesis that $X$ contains
an element that is smaller than some element of $Y$ (which is a technical convenience to
simplify the case analysis in the general result):
%%%%
%%%%
=SML
set_goal([], ¨µX Y x y∑
	x ç X ± X ç OpenâR ± y ç Y ± Y ç OpenâR ± (µx∑x ç X ¿ Y) ± x < y
¥	(∂x∑ x ç X ° Y)Æ);
a(PC_T "sets_ext" contr_tac);
a(LEMMA_T¨∂f∑ f = (Ãt∑ if t ç X then x else y)Æ (∂_THEN asm_tac) THEN1 prove_∂_tac);
a(lemma_tac¨µt∑x º t ± t º y ¥ f CtsAt tÆ THEN1 (strip_tac THEN STRIP_T discard_tac));
a(all_var_elim_asm_tac1 THEN intro_µ_tac(¨tÆ, ¨tÆ));
(* *** Goal "1" *** *)
a(rewrite_tac[cts_open_Ø_thm] THEN REPEAT strip_tac);
a(cases_tac¨x ç AÆ THEN cases_tac ¨y ç AÆ);
(* *** Goal "1.1" *** *)
a(lemma_tac¨{x'|(if x' ç X then x else y) ç A} = UniverseÆ THEN_LIST
	[id_tac, asm_rewrite_tac[empty_universe_open_closed_thm]]);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(cases_tac¨x' ç XÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(lemma_tac¨{x'|(if x' ç X then x else y) ç A} = XÆ THEN_LIST
	[id_tac, asm_rewrite_tac[]]);
a(PC_T1 "sets_ext" REPEAT strip_tac THEN POP_ASM_T ante_tac
	THEN cases_tac¨x' ç XÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.3" *** *)
a(lemma_tac¨{x'|(if x' ç X then x else y) ç A} = YÆ THEN_LIST
	[id_tac, asm_rewrite_tac[]]);
a(PC_T1 "sets_ext" REPEAT strip_tac THEN POP_ASM_T ante_tac
	THEN cases_tac¨x' ç XÆ THEN asm_rewrite_tac[]
	THEN PC_T1 "sets_ext" asm_prove_tac[]);
(* *** Goal "1.4" *** *)
a(lemma_tac¨{x'|(if x' ç X then x else y) ç A} = {}Æ THEN_LIST
	[id_tac, asm_rewrite_tac[empty_universe_open_closed_thm]]);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN cases_tac¨x' ç XÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨≥y ç XÆ THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(all_fc_tac[Ø_less_dense_thm]);
a(lemma_tac¨f x < z ± z < f yÆ THEN1 asm_rewrite_tac[]);
a(strip_asm_tac intermediate_value_thm THEN rename_tac[]);
a(LIST_DROP_NTH_ASM_T [1] all_fc_tac);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(cases_tac¨x' ç XÆ THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €connected_lemma› = pop_thm();
=TEX
Now we can prove the general result that the real numbers cannot be written as the union of
two disjoint non-empty open sets. I.e., the topological space of real numbers is connected.
%%%%
%%%%
=SML
set_goal([], ¨µX Y∑
	≥X = {} ± X ç OpenâR ± ≥Y = {} ± Y ç OpenâR ± (µx∑x ç X ¿ Y)
¥	(∂x∑ x ç X ° Y)Æ);
a(PC_T1 "sets_ext" REPEAT strip_tac THEN rename_tac[(¨x':ØÆ, "y")]);
a(strip_asm_tac(list_µ_elim[¨xÆ, ¨yÆ]Ø_less_cases_thm) THEN_LIST [
	bc_thm_tac connected_lemma,
	PC_T1 "sets_ext" asm_prove_tac[],
	bc_thm_tac (once_rewrite_rule[
		pc_rule1"sets_ext" prove_rule[]¨µa b∑a ¿ b = b ¿ a ± a ° b = b ° aÆ]
			connected_lemma)]
	THEN contr_tac THEN rename_tac[] THEN all_asm_fc_tac[]);
val €Ø_connected_thm ›= save_pop_thm "Ø_connected_thm";
=TEX
\subsection{Cauchy Sequences}
In this section we prove that a sequence of real numbers converges iff. it is a Cauchy
sequence. For future use, we will prove various standard lemmas first.

The easy direction is to show that any convergent sequence is a Cauchy sequence:
%%%%
%%%%
=SML
set_goal([], ¨µs x∑s -> x ¥ µe∑ ÓØ 0 < e ¥∂n∑µk m∑n º k ± n º m ¥ Abs(s k - s m) < eÆ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < (1/2)*eÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 2 discard_tac THEN all_asm_fc_tac[]);
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 discard_tac THEN all_asm_fc_tac[]);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨Abs(s k + ~x) + Abs(~(s m + ~x))Æ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ø_abs_plus_bc_thm);
a(conv_tac (ONCE_MAP_C Ø_anf_conv) THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a (rewrite_tac[Ø_abs_minus_thm] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €lim_seq_cauchy_seq_thm ›= save_pop_thm "lim_seq_cauchy_seq_thm";
=TEX
For the converse, we will need to know that finite sequences are bounded above \ldots
%%%%
%%%%
=SML
set_goal([], ¨µs : Ó ≠ Ø; n∑ ∂b∑ µm∑ m º n ¥ s m < bÆ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ);
(* *** Goal "1" *** *)
a(∂_tac¨s 0 + ÓØ 1Æ THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1 THEN PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac(list_µ_elim[¨s(n+1)Æ, ¨bÆ]Ø_º_cases_thm));
(* *** Goal "2.1" *** *)
a(∂_tac¨b + ÓØ 1Æ THEN REPEAT strip_tac);
a(cases_tac¨m' º nÆ THEN1 (all_asm_fc_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨m' = n + 1Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(∂_tac¨s(n+1) + ÓØ 1Æ THEN REPEAT strip_tac);
a(cases_tac¨m' º nÆ THEN1 (all_asm_fc_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨m' = n + 1Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €fin_seq_bounded_thm› = save_pop_thm "fin_seq_bounded_thm";
=TEX
\ldots and that Cauchy sequences are bounded above \ldots
%%%%
%%%%
=SML
set_goal([], ¨µs : Ó ≠ Ø∑
	(µe∑ ÓØ 0 < e ¥∂n∑µk m∑n º k ± n º m ¥ Abs(s k - s m) < e)
¥	∂b∑ µm∑s m < bÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨ÓØ 0ÆØ_unbounded_above_thm));
a(all_asm_fc_tac[] THEN LIST_DROP_NTH_ASM_T [3] discard_tac);
a(strip_asm_tac(list_µ_elim[¨sÆ, ¨nÆ]fin_seq_bounded_thm));
a(∂_tac¨b + yÆ THEN REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨mÆ, ¨nÆ]º_cases_thm));
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(SPEC_NTH_ASM_T 3 ¨nÆ (fn th => all_fc_tac[th]));
a(spec_nth_asm_tac 3 ¨nÆ);
a(cases_tac¨ÓØ 0 º s n + ~ (s m)Æ);
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[Ø_abs_def]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[Ø_abs_def]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €cauchy_seq_bounded_above_thm ›= save_pop_thm "cauchy_seq_bounded_above_thm";
=TEX
\ldots and below (so that we can argue about suprema and infima of subsets of
the range of the sequence):
%%%%
%%%%
=SML
set_goal([], ¨µs : Ó ≠ Ø∑
	(µe∑ ÓØ 0 < e ¥∂n∑µk m∑n º k ± n º m ¥ Abs(s k - s m) < e)
¥	∂b∑ µm∑b  < s mÆ);
a(LEMMA_T¨µx y:Ø∑Abs (x - y) = Abs(~x + y)Æ once_rewrite_thm_tac THEN1
	(once_rewrite_tac[pc_rule1"Ø_lin_arith"prove_rule[]¨µx y:Ø∑ ~x + y = ~(x + ~y)Æ]
	THEN rewrite_tac[Ø_abs_minus_thm]));
a(REPEAT strip_tac);
a(all_fc_tac[rewrite_rule[](µ_elim¨Ãm∑~(s m)Æ cauchy_seq_bounded_above_thm)]);
a(∂_tac¨~bÆ THEN REPEAT strip_tac);
a(asm_rewrite_tac[pc_rule1"Ø_lin_arith"prove_rule[]¨µx y:Ø∑ ~x <  y § ~y < xÆ]);
val €cauchy_seq_bounded_below_thm ›= save_pop_thm "cauchy_seq_bounded_below_thm";
=TEX
Any (non-strict) monotone increasing sequence with an upper bound converges (to the supremum of
the set of values taken by the sequence), moreover the terms of the sequence are all no smaller than
the limit.
We prove this first of all giiving the explicit value for the limit.
%%%%
%%%%
=SML
set_goal([], ¨µs: Ó ≠ Ø; ub∑
	(µm∑s m º ub ± s m º s (m+1))
¥	(s -> Sup{t | ∂m∑t = s m} ± (µm∑s m º Sup{t | ∂m∑t = s m} ))
Æ);
a(rewrite_tac[lim_seq_def] THEN REPEAT µ_tac THEN ¥_tac);
a(lemma_tac ¨µ m n∑ s m º s (m + n)Æ THEN1
	(bc_thm_tac Ø_mono_inc_seq_thm THEN asm_rewrite_tac[]));
a(LEMMA_T¨
	≥{t | ∂m∑t = s m} = {}
±	(∂a∑ µx∑x ç {t | ∂m∑t = s m} ¥ x º a)Æ (±_THEN asm_tac)  THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac THEN ∂_tac¨s mÆ THEN rewrite_tac[]);
a(∂_tac¨mÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(∂_tac ¨ubÆ THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨µm∑s m º (Sup {t|∂ m∑ t = s m})Æ THEN1
	(strip_tac THEN bc_thm_tac Ø_º_sup_bc_thm THEN
	asm_rewrite_tac[] THEN REPEAT strip_tac));
(* *** Goal "3.1" *** *)
a(POP_ASM_T bc_thm_tac THEN ∂_tac¨mÆ THEN REPEAT strip_tac);
(* *** Goal "3.2" *** *)
a(lemma_tac¨µm∑ÓØ 0 º Sup {t|∂ m∑ t = s m} + ~(s m)Æ THEN1
	(REPEAT strip_tac THEN spec_nth_asm_tac 1 ¨m:ÓÆ
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(once_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b:Ø ∑a + ~b = ~(b + ~a)Æ]);
a(rewrite_tac[Ø_abs_minus_thm] THEN asm_rewrite_tac[Ø_abs_def]);
a(ante_tac (µ_elim¨{t|∂ m∑ t = s m}Æ Ø_less_sup_thm)
	THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(contr_tac THEN LEMMA_T¨Sup {t|∂ m∑ t = s m} + ~e < Sup {t|∂ m∑ t = s m}Æ ante_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(pure_asm_rewrite_tac[] THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨mÆ THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac[º_def] THEN contr_tac
	THEN all_var_elim_asm_tac1);
a(lemma_tac¨s m º s (m + i)Æ THEN1 asm_rewrite_tac[]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "4" *** *)
a(bc_thm_tac Ø_º_sup_bc_thm THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(POP_ASM_T bc_thm_tac THEN ∂_tac ¨mÆ THEN REPEAT strip_tac);
val €lim_seq_mono_inc_sup_thm ›= save_pop_thm "lim_seq_mono_inc_sup_thm";
=TEX
Now we give the pure existence version:
%%%%
%%%%
=SML
set_goal([], ¨µs: Ó ≠ Ø; ub∑
	(µm∑s m º ub ± s m º s (m+1))
¥	∂x∑ s -> x ± (µm∑s m º x )
Æ);
a(REPEAT strip_tac THEN ∂_tac¨Sup {t|∂ m:Ó∑ t = s m}Æ
	THEN all_fc_tac[lim_seq_mono_inc_sup_thm]
	THEN asm_rewrite_tac[]);
val €lim_seq_mono_inc_thm ›= save_pop_thm "lim_seq_mono_inc_thm";
=TEX
And similarly for a  (non-strict) monotone decreasing sequence with a lower bound:
%%%%
%%%%
=SML
set_goal([], ¨µs: Ó ≠ Ø; lb∑
	(µm∑lb º s m ± s (m+1) º s m)
¥	∂x∑ s -> x ± (µm∑x º s m )
Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨∂u∑µm∑u m = ~(s m)Æ THEN1 prove_∂_tac);
a(lemma_tac¨µm∑u m º ~lb  ± u m º u (m+1)Æ THEN1
	asm_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b:Ø∑~a º ~b §b º aÆ]);
a(all_fc_tac[lim_seq_mono_inc_thm] THEN ∂_tac¨~ x:ØÆ);
a(ante_tac minus_cts_thm THEN rewrite_tac[cts_lim_seq_thm]);
a(REPEAT µ_tac THEN (STRIP_T (fn th => all_fc_tac[th])));
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[»_axiom,
	pc_rule1"Ø_lin_arith" prove_rule[]¨µa : Ø; f m∑~a º f m § ~(f m) º aÆ]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[] THEN taut_tac);
val €lim_seq_mono_dec_thm ›= save_pop_thm "lim_seq_mono_dec_thm";
=TEX
%%%%
%%%%
Any sequence bounded below and above has an {\em upper bound} or
$\mbox{\sf lim}\;\mbox{\sf sup}$.
%%%%
%%%%
=SML
set_goal([], ¨µs: Ó ≠ Ø; lb ub∑
	(µm∑lb º s m ± s m º ub)
¥	∂lim_sup∑ µe∑ ÓØ 0 < e ¥
		(∂n∑ µm∑n º m ¥ s m < lim_sup + e)
	±	(µn∑∂m∑ n º m ± lim_sup < s m + e)
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂U∑µm∑U m = Sup{t | ∂n∑m º n ± t =s n}Æ THEN1 prove_∂_tac);
a(lemma_tac¨µm∑
	≥{t | ∂n∑m º n ± t =s n} = {}
±	(∂a∑ µx∑x ç {t | ∂n∑m º n ± t =s n} ¥ x º a)Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac THEN ∂_tac¨s mÆ THEN rewrite_tac[]);
a(∂_tac¨mÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(∂_tac ¨ubÆ THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨µm∑lb º U m ± U (m+1) º U mÆ THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(asm_rewrite_tac[] THEN bc_thm_tac Ø_º_sup_bc_thm
	THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(bc_thm_tac Ø_º_trans_thm THEN ∂_tac¨s mÆ THEN REPEAT strip_tac
	THEN1 asm_rewrite_tac[]);
a(POP_ASM_T bc_thm_tac THEN ∂_tac¨mÆ THEN REPEAT strip_tac);
(* *** Goal "3.2" *** *)
a(asm_rewrite_tac[] THEN bc_thm_tac Ø_Ä_sup_thm THEN asm_rewrite_tac[]);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(∂_tac ¨nÆ THEN asm_rewrite_tac[] THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "3.3" *** *)
a(all_fc_tac[lim_seq_mono_dec_thm]);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[lim_seq_def]));
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "3.3.1" *** *)
a(lemma_tac¨ÓØ 0 < (1/2)*eÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 2 discard_tac THEN all_asm_fc_tac[]);
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨U mÆ 
	THEN REPEAT strip_tac THEN1 asm_rewrite_tac[]);
(* *** Goal "3.3.1.1" *** *)
a(bc_thm_tac Ø_º_sup_bc_thm THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(POP_ASM_T bc_thm_tac THEN ∂_tac ¨mÆ THEN REPEAT strip_tac);
(* *** Goal "3.3.1.2" *** *)
a(DROP_NTH_ASM_T 8 discard_tac);
a(DROP_NTH_ASM_T 3 (fn th => all_asm_fc_tac[] THEN asm_tac th));
a(lemma_tac¨ÓØ 0 º U m + ~ xÆ THEN1
	(spec_nth_asm_tac 6 ¨mÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[Ø_abs_def]
	THEN_TRY PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3.3.2" *** *)
a(contr_tac THEN POP_ASM_T (strip_asm_tac o
	rewrite_rule[taut_rule¨µp q∑≥(p ± q) § p ¥ ≥qÆ,
		pc_rule1"Ø_lin_arith" prove_rule[] ¨µa b:Ø∑≥a < b § b º aÆ]));
a(LEMMA_T¨≥x º U nÆ (fn th => ante_tac th THEN asm_rewrite_tac[]));
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[] ¨µa b:Ø∑≥a  º b § b < aÆ]);
a(asm_rewrite_tac[] THEN bc_thm_tac Ø_sup_less_bc_thm THEN asm_rewrite_tac[]);
a(∂_tac¨x + ~ (1/2)* eÆ THEN REPEAT strip_tac THEN_LIST
	[all_var_elim_asm_tac1, PC_T1 "Ø_lin_arith" asm_prove_tac[]]);
a(spec_nth_asm_tac 2 ¨n'Æ);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €lim_sup_thm ›= save_pop_thm "lim_sup_thm";
=TEX
%%%%
%%%%
And any sequence bounded below and above has a {\em lower bound} or
$\mbox{\sf lim}\;\mbox{\sf inf}$.
%%%%
%%%%
=SML
set_goal([], ¨µs: Ó ≠ Ø; lb ub∑
	(µm∑lb º s m ± s m º ub)
¥	∂lim_inf∑ µe∑ ÓØ 0 < e ¥
		(∂n∑ µm∑n º m ¥  lim_inf - e < s m)
	±	(µn∑∂m∑ n º m ± s m - e < lim_inf)
Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨∂u∑µm∑u m = ~(s m)Æ THEN1 prove_∂_tac);
a(lemma_tac¨µm∑~ub º u m ± u m º ~lb Æ THEN1
	asm_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b:Ø∑~a º ~b § b º aÆ]);
a(DROP_NTH_ASM_T 3 discard_tac  THEN all_fc_tac[lim_sup_thm] THEN ∂_tac¨~ lim_sup:ØÆ);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[
	pc_rule1"Ø_lin_arith" prove_rule[]¨
		µa b c: Ø∑(~a + ~b < c  § ~c < a + b) ± (a + ~b < ~c § c <  ~a + b)Æ ]);
val €lim_inf_thm ›= save_pop_thm "lim_inf_thm";
=TEX
The proof that Cauchy sequences converge is now straiightforward.
%%%%
%%%%
=SML
set_goal([], ¨µs∑
	(µe∑ ÓØ 0 < e ¥∂n∑µk m∑n º k ± n º m ¥ Abs(s k - s m) < e)
¥	∂x∑ s -> xÆ);
a(REPEAT strip_tac);
a(lemma_tac¨∂lb ub∑µm∑lb º s m ± s m º ubÆ THEN1
	(all_fc_tac[cauchy_seq_bounded_below_thm] THEN
	∂_tac¨b:ØÆ THEN asm_rewrite_tac[Ø_º_def] THEN
	POP_ASM_T discard_tac THEN
	all_fc_tac[cauchy_seq_bounded_above_thm] THEN
	∂_tac¨b:ØÆ THEN asm_rewrite_tac[]));
a(all_fc_tac[lim_sup_thm] THEN ∂_tac¨lim_sup:ØÆ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < (1/3)*eÆ THEN1 PC_T1"Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 2 discard_tac THEN all_asm_fc_tac[]);
a(DROP_NTH_ASM_T 7 discard_tac THEN ∂_tac¨n + n'Æ THEN REPEAT strip_tac);
a(lemma_tac¨n º m  ± n'  º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [6] all_fc_tac);
a(DROP_NTH_ASM_T 6 (strip_asm_tac o µ_elim¨mÆ));
a(lemma_tac¨n'  º m'Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LEMMA_T¨ Abs (s m' - s m) < (1 / 3) * eÆ ante_tac
	THEN1 LIST_DROP_NTH_ASM_T [8] all_fc_tac);
a(cases_tac¨ÓØ 0 º s m + ~ lim_supÆ THEN cases_tac ¨ÓØ 0 º s m' + ~ (s m)Æ
	THEN asm_rewrite_tac[Ø_abs_def]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €cauchy_seq_lim_seq_thm ›= save_pop_thm "cauchy_seq_lim_seq_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µs∑
	(∂x∑s -> x)
§	(µe∑ ÓØ 0 < e ¥∂n∑µk m∑n º k ± n º m ¥ Abs(s k - s m) < e)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[lim_seq_cauchy_seq_thm]);
a(∂_tac¨nÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(bc_thm_tac cauchy_seq_lim_seq_thm THEN POP_ASM_T accept_tac);
val €lim_seq_§_cauchy_seq_thm ›= save_pop_thm "lim_seq_§_cauchy_seq_thm";
=TEX
\subsection{Limits of Function Values}
We follow our earlier strategy of reducing problems about limits of function values
to limits of sequences:
%%%%
%%%%
=SML
set_goal([], ¨µf c x∑
	(f --> c) x
§	(µs∑s -> x ± (µm∑≥s m = x) ¥ (Ãm∑f(s m)) -> c)Æ);
a(rewrite_tac[lim_fun_def, lim_seq_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
a(LIST_DROP_NTH_ASM_T [3, 5] all_fc_tac);
a(∂_tac¨nÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(lemma_tac¨≥s m = xÆ THEN1 asm_rewrite_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(contr_tac THEN strip_asm_tac(µ_elim¨xÆ lim_seq_≥_eq_thm));
a(lemma_tac¨∂t∑µm∑ Abs(t m + ~x) < Abs(s m + ~x) ±≥t m = x ± ≥Abs(f(t m) + ~c) < eÆ
	THEN1 prove_∂_tac THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(lemma_tac¨≥s m' = xÆ THEN1 asm_rewrite_tac[]);
a(lemma_tac¨ÓØ 0 < Abs(s m' +  ~x)Æ THEN1
	(cases_tac¨ÓØ 0 º s m' + ~xÆ THEN asm_rewrite_tac[Ø_abs_def]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(spec_nth_asm_tac 5 ¨Abs(s m'  + ~x)Æ);
a(∂_tac ¨yÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 6 (ante_tac o µ_elim¨tÆ) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(DROP_NTH_ASM_T 4 (fn th => all_fc_tac[rewrite_rule[lim_seq_def]th]));
a(∂_tac ¨nÆ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨Abs(s m + ~x)Æ THEN asm_rewrite_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "2.2.2" *** *)
a(∂_tac¨eÆ THEN REPEAT strip_tac);
a(∂_tac¨nÆ THEN asm_rewrite_tac[]);
val €lim_fun_lim_seq_thm› = save_pop_thm "lim_fun_lim_seq_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µc t∑ ((Ãx∑c) --> c) tÆ);
a(rewrite_tac[lim_fun_lim_seq_thm, const_lim_seq_thm]);
val €const_lim_fun_thm› = save_pop_thm "const_lim_fun_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µt∑ ((Ãx∑x) --> t) tÆ);
a(rewrite_tac[lim_fun_lim_seq_thm, »_axiom] THEN taut_tac);
val €id_lim_fun_thm› = save_pop_thm "id_lim_fun_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf1 t1 x f2 t2∑ (f1 --> t1) x ±  (f2 --> t2) x ¥ ((Ãx∑f1 x + f2 x) --> t1 + t2) xÆ);
a(rewrite_tac[lim_fun_lim_seq_thm] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [plus_lim_seq_thm]);
a(rewrite_tac[] THEN taut_tac);
val €plus_lim_fun_thm› = save_pop_thm "plus_lim_fun_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf1 t1 x f2 t2∑ (f1 --> t1) x ±  (f2 --> t2) x ¥ ((Ãx∑f1 x * f2 x) --> t1 * t2) xÆ);
a(rewrite_tac[lim_fun_lim_seq_thm] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [times_lim_seq_thm]);
a(rewrite_tac[] THEN taut_tac);
val €times_lim_fun_thm› = save_pop_thm "times_lim_fun_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf t x∑ (f --> t) x ±  ≥t = ÓØ 0 ¥ ((Ãx∑(f x) õ-õ1) --> t õ-õ1) xÆ);
a(rewrite_tac[lim_fun_lim_seq_thm] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [recip_lim_seq_thm]);
a(rewrite_tac[]);
val €recip_lim_fun_thm› = save_pop_thm "recip_lim_fun_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf t x g∑ (f --> t) x ± (g CtsAt t)  ¥ ((Ãx∑g (f x)) --> g t ) xÆ);
a(rewrite_tac[lim_fun_lim_seq_thm] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [cts_lim_seq_thm]);
a(rewrite_tac[]);
val €comp_lim_fun_thm› = save_pop_thm "comp_lim_fun_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µf t x g∑ (g --> t) (f x) ± (f CtsAt x) ± (µy∑ f y = f x § y = x)
	¥ ((Ãx∑g (f x)) -->  t) xÆ);
a(rewrite_tac[lim_fun_lim_seq_thm] THEN REPEAT strip_tac);
a(all_fc_tac[cts_lim_seq_thm1]);
a(lemma_tac¨µm∑ ≥(Ãm∑f(s m)) m = f xÆ THEN1 asm_rewrite_tac[]);
a(ALL_ASM_FC_T  (MAP_EVERY ante_tac)[]);
a(rewrite_tac[]);
val €comp_lim_fun_thm1› = save_pop_thm "comp_lim_fun_thm1";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf x∑ f ç PolyFunc ¥ (f --> f x) xÆ);
a(REPEAT strip_tac);
a(poly_induction_tac ¨fÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[const_lim_fun_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[id_lim_fun_thm]);
(* *** Goal "3" *** *)
a(ALL_FC_T (MAP_EVERY ante_tac) [plus_lim_fun_thm]);
a(rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(ALL_FC_T (MAP_EVERY ante_tac) [times_lim_fun_thm]);
a(rewrite_tac[] THEN REPEAT strip_tac);
val €poly_lim_fun_thm› = save_pop_thm "poly_lim_fun_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µu d c t∑
	ÓØ 0 < d
±	(µy∑Abs(y - x) <  d ± ≥y = x¥ u y º  c) ± (u --> t) x
¥	t º cÆ);
a(rewrite_tac[lim_fun_lim_seq_thm] THEN REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨xÆ, ¨dÆ](rewrite_rule[]lim_seq_≥_eq_thm1)));
a(bc_thm_tac lim_seq_upper_bound_thm);
 a(∂_tac¨Ãm∑u (s m)Æ THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 bc_thm_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN asm_rewrite_tac[]);
val €lim_fun_upper_bound_thm› = save_pop_thm "lim_fun_upper_bound_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µu s t x∑ (u --> s) x ± (u --> t) x ¥ s = tÆ);
a(rewrite_tac[lim_fun_def] THEN contr_tac);
a(lemma_tac¨s < t ≤ t < sÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1" *** *)
a(lemma_tac¨ÓØ 0 < (1/2)*(t + ~s)Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [4, 5] all_fc_tac);
a(lemma_tac¨∂d1∑ÓØ 0 < d1 ± ÓØ 0 º d1 ± d1 < d ± d1 < d'Æ THEN1
	(cases_tac ¨d º d'Æ THEN_LIST [∂_tac¨(1/2)*dÆ, ∂_tac¨(1/2)*d'Æ]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(LIST_DROP_NTH_ASM_T [5, 7] (MAP_EVERY (ante_tac o µ_elim¨d1 + xÆ)));
a(asm_rewrite_tac[Ø_plus_assoc_thm, Ø_abs_def]);
a(cases_tac¨ÓØ 0 º u (d1 + x) + ~ tÆ THEN cases_tac ¨ÓØ 0 º u (d1 + x) + ~ sÆ THEN
	asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨ÓØ 0 < (1/2)*(s + ~t)Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [4, 5] all_fc_tac);
a(lemma_tac¨∂d1∑ÓØ 0 < d1 ± ÓØ 0 º d1 ± d1 < d ± d1 < d'Æ THEN1
	(cases_tac ¨d º d'Æ THEN_LIST [∂_tac¨(1/2)*dÆ, ∂_tac¨(1/2)*d'Æ]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(LIST_DROP_NTH_ASM_T [5, 7] (MAP_EVERY (ante_tac o µ_elim¨d1 + xÆ)));
a(asm_rewrite_tac[Ø_plus_assoc_thm, Ø_abs_def]);
a(cases_tac¨ÓØ 0 º u (d1 + x) + ~ tÆ THEN cases_tac ¨ÓØ 0 º u (d1 + x) + ~ sÆ THEN
	asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €lim_fun_unique_thm› = save_pop_thm "lim_fun_unique_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µu v s t x a b ∑
	(u --> s) x
±	a < x ± x < b
±	(µt∑a < t ± t < b ± ≥t = x ¥ u t = v t)
¥	(v --> s) xÆ);
a(rewrite_tac[lim_fun_def] THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [5] all_fc_tac);
a(lemma_tac¨∂d1∑ÓØ 0 < d1 ± d1 < x + ~a ± d1 < b + ~x ± d1 < dÆ THEN1 
	(bc_thm_tac Ø_bound_below_3_thm THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(∂_tac¨d1Æ THEN REPEAT strip_tac);
a(lemma_tac¨a < y ± y < bÆ THEN1
	(DROP_NTH_ASM_T 2 ante_tac THEN cases_tac¨ÓØ 0 º y + ~xÆ
		THEN asm_rewrite_tac[Ø_abs_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨Abs(y + ~x) < dÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [10] (ALL_FC_T (MAP_EVERY ante_tac)));
a(LIST_DROP_NTH_ASM_T [12] (ALL_FC_T rewrite_tac));
val €lim_fun_local_thm› = save_pop_thm "lim_fun_local_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µf a b t x g∑
	x ç OpenInterval a b
±	 (g --> t) (f x)
±	(f CtsAt x)
±	(µy∑ y ç OpenInterval a b ¥ (f y = f x § y = x))
¥	((Ãx∑g (f x)) -->  t) xÆ);
a(rewrite_tac[open_interval_def] THEN REPEAT strip_tac THEN bc_thm_tac lim_fun_local_thm);
a(lemma_tac¨∂h∑(µt∑a < t ± t < b ¥ h t = f t) ± (µt∑h t = h x § t = x)Æ);
(* *** Goal "1" *** *)
a(∂_tac¨Ãt∑if a < t ± t < b then f t else f x + ÓØ 1Æ THEN rewrite_tac[] THEN
	REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(POP_ASM_T ante_tac THEN cases_tac¨a < t' ± t' < bÆ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(MAP_EVERY ∂_tac [¨bÆ, ¨aÆ, ¨Ãx∑g(h x)Æ]);
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac comp_lim_fun_thm1 THEN asm_rewrite_tac[]);
a(ALL_ASM_FC_T asm_rewrite_tac[]);
a(bc_thm_tac cts_local_thm);
a(MAP_EVERY ∂_tac [¨fÆ, ¨bÆ, ¨aÆ]);
a(REPEAT strip_tac);
a(ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(ALL_ASM_FC_T rewrite_tac[]);
val €comp_lim_fun_thm2› = save_pop_thm "comp_lim_fun_thm2";
=TEX

The theorems on limits above have the following consequence concerning
the differentiability of an inverse function:
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µf g a b x c∑ 
	x ç OpenInterval a b
±	(µy∑y ç OpenInterval a b ¥ f(g y) = y)
±	(f HasDeriv c) (g x)
±	(g CtsAt x)
±	≥c = ÓØ 0
¥	(g HasDeriv c õ-õ1) x
Æ);
a(rewrite_tac[deriv_lim_fun_thm] THEN REPEAT strip_tac);
a(lemma_tac¨µ y∑ y ç OpenInterval a b ¥ (g y = g x § y = x)Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T ¨y = f(g y) ± x = f(g x)Æ once_rewrite_thm_tac THEN1
	(REPEAT strip_tac THEN ALL_ASM_FC_T rewrite_tac[]));
a(POP_ASM_T rewrite_thm_tac);
(* *** Goal "2" *** *)
a(POP_ASM_T rewrite_thm_tac);
(* *** Goal "3" *** *)
a(all_fc_tac[comp_lim_fun_thm2]);
a(DROP_NTH_ASM_T 5 discard_tac);
a(all_fc_tac [recip_lim_fun_thm]);
a(POP_ASM_T ante_tac THEN rewrite_tac[] THEN strip_tac);
a(bc_thm_tac lim_fun_local_thm);
a(MAP_EVERY ∂_tac [¨bÆ, ¨aÆ, ¨(Ã x'∑ ((f (g x') + ~ (f (g x))) / (g x' + ~ (g x))) õ-õ1)Æ]);
a(GET_NTH_ASM_T 7 (asm_rewrite_thm_tac o rewrite_rule[open_interval_def]));
a(REPEAT strip_tac);
a(lemma_tac¨t ç OpenInterval a bÆ THEN1 asm_rewrite_tac[open_interval_def]);
a(LIST_GET_NTH_ASM_T [10] (ALL_FC_T rewrite_tac));
a(lemma_tac¨≥g t = g xÆ);
(* *** Goal "3.1" *** *)
a(swap_nth_asm_concl_tac 2);
a(LEMMA_T¨f(g t) = f(g x)Æ ante_tac THEN1 asm_rewrite_tac[]);
a(LIST_GET_NTH_ASM_T [10] (ALL_FC_T rewrite_tac));
(* *** Goal "3.2" *** *)
a(lemma_tac¨≥t + ~x = ÓØ 0 ± ≥g t + ~(g x) = ÓØ 0Æ THEN1
	PC_T1 "Ø_lin_arith"asm_prove_tac[]);
a(all_fc_tac[Ø_≥_recip_0_thm]);
a(rename_tac[(¨xÆ, "X")] THEN
	ALL_FC_T rewrite_tac[Ø_over_times_recip_thm, Ø_recip_clauses]);
a(conv_tac(LEFT_C (once_rewrite_conv[Ø_times_comm_thm])) THEN REPEAT strip_tac);
val €inverse_deriv_thm› = save_pop_thm "inverse_deriv_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Uniform Convergence}
%%%%
%%%%
%%%%
%%%%
We now prove some basic facts about limits of locally uniformly convergent
sequences of functions.

Firstly, constant sequences are uniformly convergent at $x$ on any
iset $X$
%%%%
%%%%
=SML
set_goal([], ¨µh X∑ ((Ãm∑ h) ---> h) XÆ);
a(REPEAT strip_tac THEN asm_rewrite_tac[unif_lim_seq_def]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val €const_unif_lim_seq_thm› = save_pop_thm "const_unif_lim_seq_thm";
=TEX
If two uniformly convergent
sequences of functions each have a limit, then so does their
sum and its limit is the sum of the limits.
Thee proof is a cut-and-paste generalisation of the analogous proof
for the limit of sequences of numbers.
%%%%
%%%%
=SML
set_goal([], ¨µu1 h1 X u2 h2∑
	(u1 ---> h1) X
±	(u2 ---> h2) X
¥	((Ãm y∑u1 m y + u2 m y) ---> (Ãy∑h1 y + h2 y)) XÆ);
a(rewrite_tac[unif_lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac ¨ÓØ 0 < e / ÓØ 2 Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 4 ¨e / ÓØ 2Æ THEN spec_nth_asm_tac 4  ¨e / ÓØ 2Æ);
a(∂_tac¨n + n'Æ THEN REPEAT strip_tac);
a(lemma_tac¨n º m ± n' º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T [5, 6] all_fc_tac);
a(LEMMA_T ¨
	(u1 m y + u2 m y) + ~(h1 y) + ~(h2 y) =
	(u1 m y + ~(h1 y)) + (u2 m y + ~(h2 y))Æ
	rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(bc_thm_tac Ø_º_less_trans_thm);
a(∂_tac¨Abs (u1 m y + ~ (h1 y)) + Abs (u2 m y + ~(h2 y))Æ THEN rewrite_tac[Ø_abs_plus_thm]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €plus_unif_lim_seq_thm› = save_pop_thm "plus_unif_lim_seq_thm";
=TEX
We now want to give the analogous result on the product of two bounded sequences
of functions with uniform limits. Some preparation is required.
It is useful to know that the limit of a uniformly convergent and bounded sequence of functions
is itself bounded: 
%%%%
%%%%
=SML
set_goal([], ¨µu g X c∑
	(u ---> g)  X
±	(µy m∑y ç X ¥ Abs(u m y) < c)
¥	(∂d∑ µy∑y ç X ¥ Abs(g y) < d)Æ);
a(rewrite_tac[unif_lim_seq_def] THEN REPEAT strip_tac);
a(cases_tac¨X = {}Æ THEN1 asm_rewrite_tac[]);
a(POP_ASM_T (PC_T1 "sets_ext1" strip_asm_tac));
a(lemma_tac¨ÓØ 0 < cÆ THEN1
	(DROP_NTH_ASM_T 2 (ante_tac o list_µ_elim[¨xÆ, ¨m:ÓÆ]) THEN
	asm_rewrite_tac[Ø_º_def] THEN strip_asm_tac (µ_elim¨u m xÆØ_0_º_abs_thm)
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(DROP_NTH_ASM_T 2 discard_tac);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac);
a(∂_tac¨ÓØ 2*cÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[] o µ_elim¨nÆ));
a(LIST_DROP_NTH_ASM_T [1, 4] all_fc_tac);
a(DROP_NTH_ASM_T 1 (strip_asm_tac o µ_elim¨nÆ));
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨ Abs( ~(u n y + ~ (g y)) + u n y )Æ);
a(strip_tac THEN1 (conv_tac (ONCE_MAP_C Ø_anf_conv) THEN REPEAT strip_tac));
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨ Abs( ~(u n y + ~ (g y)) ) + Abs(u n y)Æ);
a(rewrite_tac[Ø_abs_plus_thm, Ø_abs_minus_thm]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €bounded_unif_limit_thm› = save_pop_thm "bounded_unif_limit_thm";
=TEX
We now want to give the analogous result on the product of two sequences
of functions with uniform limits.  We need two algebraic lemmas:
%%%%
%%%%
=SML
set_goal([], ¨µU G V H D B E C:Ø∑
	Abs(U + ~G) < D ± Abs(U + G) < B
±	Abs(V + ~H) < E ± Abs(V + H) < C
¥	Abs(U*V + ~(G*H)) < (1/2)*(B * E + C * D)
Æ);
a(REPEAT strip_tac);
a(LEMMA_T ¨U*V + ~(G*H) = (1/2)*((U + G)*(V + ~H) + (V + H)*(U + ~G))Æ rewrite_thm_tac
	THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(rewrite_tac[Ø_abs_times_thm, pc_rule1"Ø_lin_arith" prove_rule[]¨µa b∑ (1/2)*a < (1/2)*b § a < bÆ]);
a(bc_thm_tac Ø_º_less_trans_thm THEN
	∂_tac¨Abs ((U + G) * (V + ~ H)) + Abs((V + H) * (U + ~ G))Æ
	THEN rewrite_tac[Ø_abs_plus_thm, Ø_abs_times_thm]);
a(bc_thm_tac (pc_rule1"Ø_lin_arith" prove_rule[]¨µa b x y:Ø∑ a < b ± x < y ¥ a + x < b + yÆ));
a(ALL_FC_T rewrite_tac[Ø_abs_less_times_thm]);
val €times_unif_lemma1› = pop_thm();
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µB C  e∑
	ÓØ 0 < B ± ÓØ 0 <  C ± ÓØ 0 <  e
¥	∂D E∑ ÓØ 0 < D ± ÓØ 0 < E ± (1/2)*(B * E + C * D) < e
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < (B + C)õ-õ1Æ THEN1
	(bc_thm_tac Ø_0_less_0_less_recip_thm THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨ÓØ 0 < e * (B + C)õ-õ1Æ THEN1
	(bc_thm_tac Ø_0_less_0_less_times_thm THEN REPEAT strip_tac));
a(REPEAT_N 2 (∂_tac¨e*((B + C)õ-õ1)Æ) THEN REPEAT strip_tac);
a(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[] ¨µa b c d:Ø∑c*(a*b) + d*(a*b) = a*b*(c + d)Æ]);
a(lemma_tac¨≥B + C = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €times_unif_lemma2› = pop_thm();
=TEX
We now give result on the product of two sequences of functions with uniform limits. 
%%%%
%%%%
=SML
set_goal([], ¨µu g v h X c d∑
	(u ---> g)  X
±	(v ---> h)  X
±	(µy m∑ y ç X ¥ Abs(u m y) < c)
±	(µy m∑ y ç X ¥ Abs(v m y) < d)
¥	((Ãm y∑u m y*v m y) ---> (Ãy∑g y*h y)) XÆ);
a(REPEAT strip_tac);
a(lemma_tac¨∂B∑µy m∑ y ç X ¥ Abs(u m y + g y) < BÆ);
(* *** Goal "1" *** *)
a(all_fc_tac[bounded_unif_limit_thm]);
a(∂_tac¨c + d''Æ THEN REPEAT strip_tac THEN
	bc_thm_tac Ø_º_less_trans_thm THEN
	∂_tac¨Abs(u m y) + Abs(g y)Æ THEN rewrite_tac[Ø_abs_plus_thm]);
a(bc_thm_tac (pc_rule1"Ø_lin_arith" prove_rule[] ¨µa b x y:Ø∑ a < b ± x < y ¥ a + x < b + yÆ));
a(LIST_GET_NTH_ASM_T [2, 5] (ALL_FC_T rewrite_tac));
(* *** Goal "2" *** *)
a(lemma_tac¨∂C∑µy m∑y ç X ¥ Abs(v m y + h y) < CÆ);
(* *** Goal "2.1" *** *)
a(all_fc_tac[bounded_unif_limit_thm]);
a(∂_tac¨d + d'Æ THEN REPEAT strip_tac THEN
	bc_thm_tac Ø_º_less_trans_thm THEN
	∂_tac¨Abs(v m y) + Abs(h y)Æ THEN rewrite_tac[Ø_abs_plus_thm]);
a(bc_thm_tac (pc_rule1"Ø_lin_arith" prove_rule[] ¨µa b x y:Ø∑ a < b ± x < y ¥ a + x < b + yÆ));
a(LIST_GET_NTH_ASM_T [3, 5] (ALL_FC_T rewrite_tac));
(* *** Goal "2.2" *** *)
a(LIST_DROP_NTH_ASM_T [5, 6] (MAP_EVERY ante_tac));
a(rewrite_tac[unif_lim_seq_def] THEN REPEAT strip_tac);
a(cases_tac¨X = {}Æ THEN1 asm_rewrite_tac[]);
a(POP_ASM_T (PC_T1 "sets_ext1" strip_asm_tac));
a(lemma_tac¨ÓØ 0 < BÆ THEN1
	(DROP_NTH_ASM_T 6 (ante_tac o list_µ_elim[¨xÆ, ¨m:ÓÆ]) THEN
	asm_rewrite_tac[Ø_º_def] THEN
	strip_asm_tac (µ_elim¨u m x + g xÆØ_0_º_abs_thm) THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨ÓØ 0 < CÆ THEN1
	(DROP_NTH_ASM_T 6 (ante_tac o list_µ_elim[¨xÆ, ¨m:ÓÆ]) THEN
	asm_rewrite_tac[Ø_º_def] THEN
	strip_asm_tac (µ_elim¨v m x + h xÆØ_0_º_abs_thm) THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(DROP_NTH_ASM_T 3 discard_tac);
a(lemma_tac¨∂D E∑ ÓØ 0 < D ± ÓØ 0 < E ± (1/2)*(B * E + C * D) < eÆ THEN1
	(bc_thm_tac times_unif_lemma2 THEN REPEAT strip_tac));
a(DROP_NTH_ASM_T 8 (strip_asm_tac o µ_elim¨DÆ));
a(DROP_NTH_ASM_T 8 (strip_asm_tac o µ_elim¨EÆ));
a(∂_tac¨n+n'Æ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨1 / 2 * (B * E + C * D)Æ
	THEN REPEAT strip_tac);
a(lemma_tac¨n º m ± n' º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(bc_thm_tac times_unif_lemma1 THEN REPEAT strip_tac THEN  all_asm_fc_tac[]
	THEN asm_rewrite_tac[]);
val €times_unif_lim_seq_thm› = save_pop_thm "times_unif_lim_seq_thm";
=TEX
Now we show that a sequence of functions converging uniformly on a closed interval
with a continuous limit is uniformly bounded:
%%%%
%%%%
=SML
set_goal([], ¨µu h a b∑
	a < b
±	(u ---> h)  (ClosedInterval a b)
±	(µy∑a º y ± y º b ¥ h CtsAt y)
¥	(∂c n∑µm y∑n º m ± a º y ± y º b ¥ Abs(u m y) < c)Æ);
a(rewrite_tac[unif_lim_seq_def, closed_interval_def] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T  2 (strip_asm_tac o µ_elim¨ÓØ 1Æ));
a(lemma_tac¨a º bÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_fc_tac[cts_abs_bounded_thm]);
a(lemma_tac¨ÓØ 0 º cÆ THEN1
	(SPEC_NTH_ASM_T 1 ¨aÆ ante_tac THEN
	strip_asm_tac(µ_elim¨h aÆØ_0_º_abs_thm) THEN
	PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(∂_tac¨ÓØ 1 + cÆ THEN ∂_tac¨nÆ THEN REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨u m y + ~(h y)Æ, ¨h yÆ] Ø_abs_plus_thm));
a(rewrite_tac[Ø_plus_assoc_thm] THEN strip_tac);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨Abs (u m y + ~ (h y)) + Abs (h y)Æ
	THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €unif_lim_seq_bounded_thm› = save_pop_thm "unif_lim_seq_bounded_thm";
=TEX
Now we show that a sequence of functions converging uniformly on a closed interval
with a continuous limit is uniformly bounded:
%%%%
%%%%
=SML
set_goal([], ¨µu h X Y∑
	(u ---> h)  X
±	Y Ä X
¥	(u ---> h) YÆ);
a(rewrite_tac[unif_lim_seq_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac);
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
val €unif_lim_seq_Ä_thm› = save_pop_thm "unif_lim_seq_Ä_thm";
=TEX
The following ``shift theorem'' is analogous to the one for sequences of terms:
%%%%
%%%%
=SML
set_goal([], ¨µm u h X ∑ (u ---> h) X § ((Ãn∑u (n + m)) --->h) XÆ);
a(rewrite_tac[unif_lim_seq_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN ∂_tac¨nÆ THEN REPEAT strip_tac);
a(lemma_tac¨n º m'+mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[] THEN ∂_tac¨n + mÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[º_def]) THEN all_var_elim_asm_tac1);
a(SPEC_NTH_ASM_T 2 ¨n+iÆ ante_tac THEN
	conv_tac (ONCE_MAP_C anf_conv) THEN
	REPEAT strip_tac);
a(POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
val €unif_lim_seq_shift_thm› = save_pop_thm "unif_lim_seq_shift_thm";
=TEX
Now one of the main results of this section: if a sequence
of functions, all continuous at some point $x$, is uniformly convergent in an open interval containing $x$
at $x$, then the limit function is continuous at $x$.
We prove a little lemma first:
%%%%
%%%%
=SML
set_goal([], ¨µa b c d:Ø∑Abs(a - d) º Abs(a - b) + Abs(b - c) + Abs(c - d)Æ);
a(REPEAT strip_tac);
a(lemma_tac¨Abs(b - d) º Abs(b - c) + Abs(c - d)Æ THEN1
	(pure_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
		¨b - d = (b - c) + (c - d)Æ, Ø_abs_plus_thm]));
a(lemma_tac¨Abs(a - d) º Abs(a - b) + Abs(b - d)Æ THEN1
	(pure_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
		¨a - d = (a - b) + (b - d)Æ, Ø_abs_plus_thm]));
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €abs_abcd_thm› = pop_thm ();
=TEX
Now we prove the main result on the continuity of limits of sequences of
functions. We use
the $\epsilon$-$\delta$ definition of continuity directly --- to use
the alternative characterisation in terms of sequences involves too
many subscripts for comfort!
%%%%
%%%%
=SML
set_goal([], ¨µu h x a b∑
	(u ---> h) (OpenInterval a b) ± a < x ± x < b ± (µm∑u m CtsAt x) ¥ h CtsAt xÆ);
a(rewrite_tac[cts_at_def, unif_lim_seq_def, lim_seq_def, open_interval_def] THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < (1/3)*eÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 6 ¨(1/3)*eÆ);
a(SPEC_NTH_ASM_T 1 ¨nÆ ante_tac THEN rewrite_tac[] THEN REPEAT strip_tac);
a(list_spec_nth_asm_tac 5 [¨nÆ, ¨(1/3)*eÆ]);
a(strip_asm_tac(list_µ_elim[¨aÆ, ¨xÆ, ¨bÆ, ¨dÆ]axbd_thm));
a(∂_tac¨cÆ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac ¨
	Abs(h y - u n y) + Abs(u n y - u n x) + Abs(u n x - h x)Æ
	THEN rewrite_tac[rewrite_rule[]abs_abcd_thm] THEN REPEAT strip_tac);
a(lemma_tac ¨Abs(h y + ~(u n y)) < (1/3)*e
	± Abs(u n y + ~(u n x)) < (1/3)*e
	± Abs(u n x + ~(h x)) < (1/3)*eÆ
	THEN_LIST [id_tac, PC_T1 "Ø_lin_arith" asm_prove_tac[]]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(pure_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µz∑h y + ~z = ~(z + ~(h y))Æ,
	Ø_abs_minus_thm]);
a(GET_NTH_ASM_T 7 bc_thm_tac);
a(LIST_GET_NTH_ASM_T [2] (ALL_FC_T rewrite_tac));
(* *** Goal "2" *** *)
a(GET_NTH_ASM_T 5 bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(GET_NTH_ASM_T 7 bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €unif_lim_seq_cts_thm› = save_pop_thm "unif_lim_seq_cts_thm";
=TEX
Any uniformly convergent sequence of functions is a Cauchy sequence:
%%%%
%%%%
=SML
set_goal([], ¨µu f X∑
	(u ---> f) X
¥	µe∑ ÓØ 0 < e ¥∂n∑µk m∑n º k ± n º m ¥ µy∑y ç X ¥ Abs(u k y - u m y) < eÆ);
a(rewrite_tac[unif_lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < (1/2)*eÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 2 discard_tac THEN all_asm_fc_tac[]);
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 6 discard_tac THEN all_asm_fc_tac[]);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨Abs(u k y + ~(f y)) + Abs(~(u m y + ~(f y)))Æ
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ø_abs_plus_bc_thm);
a(conv_tac (ONCE_MAP_C Ø_anf_conv) THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a (rewrite_tac[Ø_abs_minus_thm] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €unif_lim_seq_cauchy_seq_thm ›= save_pop_thm "unif_lim_seq_cauchy_seq_thm";
=TEX
Uniform Cauchy sequences of functions converge uniformly. This is a bit easier than
the equivalent result for numeric sequences, because that result is now available to give
us the pointwise limit functon with little extra work. We just then have to show that
the uniform Cauchy condition implies that the convergence to the point-wise limit is uniform.
%%%%
%%%%
=SML
set_goal([], ¨µu X∑
	(µe∑ ÓØ 0 < e ¥∂n∑µk m∑n º k ± n º m ¥ µy∑ y ç X ¥ Abs(u k y - u m y) < e)
¥	∂f∑(u ---> f) XÆ);
a(rewrite_tac[unif_lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac¨∂f∑µy∑ y ç X ¥ (Ãm∑u m y) -> f yÆ THEN1 prove_∂_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(cases_tac¨y' ç XÆ THEN asm_rewrite_tac[]);
a(bc_thm_tac cauchy_seq_lim_seq_thm THEN REPEAT strip_tac THEN rewrite_tac[]);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac);
a(∂_tac¨nÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨fÆ THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < (1/2)*eÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [2, 4] all_fc_tac);
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [5] (ALL_FC_T (MAP_EVERY ante_tac)));
a(rewrite_tac[lim_seq_def] THEN STRIP_T (fn th => all_fc_tac[th]));
a(POP_ASM_T (strip_asm_tac o µ_elim¨n' + mÆ));
a(lemma_tac ¨Abs (u m y + ~ (u (n'+m) y)) < 1 / 2 * eÆ);
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 4 (ante_tac o list_µ_elim[¨mÆ, ¨n'+mÆ]));
a(LEMMA_T ¨n º n' + mÆ asm_rewrite_thm_tac THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(STRIP_T (strip_asm_tac o µ_elim¨yÆ));
(* *** Goal "2.2" *** *)
a(bc_thm_tac Ø_º_less_trans_thm THEN
	∂_tac¨Abs (u m y + ~ (u (n' + m) y)) + Abs (u (n' + m) y + ~ (f y))Æ);
a(REPEAT strip_tac THEN_LIST
	[bc_thm_tac Ø_º_trans_thm, PC_T1 "Ø_lin_arith" asm_prove_tac[]]);
a(∂_tac¨Abs ((u m y + ~ (u (n' + m) y)) + (u (n' + m) y + ~ (f y)))Æ
	THEN rewrite_tac[Ø_abs_plus_thm]);
a(conv_tac(ONCE_MAP_C Ø_anf_conv) THEN REPEAT strip_tac);
val €cauchy_seq_unif_lim_seq_thm ›= save_pop_thm "cauchy_seq_unif_lim_seq_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µu f X x∑
	(u ---> f) X
±	x ç X
¥	(Ãm∑u m x) -> f xÆ);
a(rewrite_tac[unif_lim_seq_def, lim_seq_def] THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac);
a(∂_tac¨nÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val €unif_lim_seq_pointwise_lim_seq_thm›= save_pop_thm "unif_lim_seq_pointwise_lim_seq_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µu f g X x c∑
	(u ---> f) X
±	x ç X
±	(Ãm∑ u m x) -> c
¥	f x = cÆ);
a(REPEAT strip_tac THEN all_fc_tac[unif_lim_seq_pointwise_lim_seq_thm]);
a(all_fc_tac[lim_seq_unique_thm]);
val €unif_lim_seq_pointwise_unique_thm›= save_pop_thm "unif_lim_seq_pointwise_unique_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µu f g X x∑
	(u ---> f) X
±	(u ---> g) X
±	x ç X
¥	f x = g xÆ);
a(REPEAT strip_tac THEN all_fc_tac[unif_lim_seq_pointwise_lim_seq_thm]);
a(all_fc_tac[lim_seq_unique_thm]);
val €unif_lim_seq_unique_thm ›= save_pop_thm "unif_lim_seq_unique_thm";
=TEX
The following is theorem 7.11 from Rudin (p. 149) which says if a sequence
of functions $u_m$ converges uniformly to a limit $f$ on some set $E$ and
if $x$ is a limit point of $E$ such that $u_m(y)$ tends to some limiit
$s_m$ for each $m$ as $y$ tends to $x$, then the sequence $s_m$ 
converges to a limit $c$ and $f(y)$ tends to $c$ as $y$ tends to $x$.
I.e., under the given hypotheses, the operations of taking limits as $y$
tends to $x$ and taking limits as $m$ tends to infinity can be interchanged.

We do the special case where $E$ is the set obtained by deleting $x$ from
an open interval containing $x$, which is expected to be the most important
one in applications --- it certainly suffices for the theorem about differentiability
of limits that is Rudin's theorem 7.17. 

%%%%
%%%%
=SML
set_goal([], ¨µu f a b x s∑
	(u ---> f) (OpenInterval a b \ {x})
±	a < x ± x < b
±	(µm∑ (u m --> s m) x)
¥	∂c∑ (f --> c) x ± s -> c
Æ);
a(REPEAT strip_tac THEN lemma_tac¨∂c∑s -> cÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[lim_seq_§_cauchy_seq_thm] THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < (1/2)*eÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 2 discard_tac THEN all_fc_tac[unif_lim_seq_cauchy_seq_thm]);
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o
	pc_rule1 "sets_ext1" rewrite_rule[open_interval_def] o list_µ_elim[¨kÆ, ¨mÆ]));
a(lemma_tac¨((Ãz∑~(u m z)) -->  ~(s m)) xÆ THEN1
	(bc_thm_tac comp_lim_fun_thm
	THEN asm_rewrite_tac[minus_cts_thm]));
a(lemma_tac¨((Ãz∑ (Ãz∑u k z) z + (Ãz∑~(u m z)) z) -->  s k + ~(s m)) xÆ THEN1
	(bc_thm_tac plus_lim_fun_thm
	THEN asm_rewrite_tac[»_axiom]));
a(LEMMA_T¨( (Ãz∑Abs((Ãz∑ (Ãz∑u k z) z + (Ãz∑~(u m z)) z)z)) -->  Abs(s k + ~(s m)) ) xÆ ante_tac THEN1
	(bc_thm_tac comp_lim_fun_thm
	THEN asm_rewrite_tac[abs_cts_thm]));
a(rewrite_tac[] THEN strip_tac THEN all_fc_tac[axbd_thm]);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨(1/2)*eÆ THEN REPEAT strip_tac
	THEN_LIST[id_tac, PC_T1 "Ø_lin_arith" asm_prove_tac[]]);
a(bc_thm_tac lim_fun_upper_bound_thm);
a(∂_tac¨Ã z∑ Abs (u k z + ~ (u m z))Æ THEN ∂_tac¨xÆ THEN ∂_tac¨cÆ);
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(rewrite_tac[Ø_º_def] THEN ≤_left_tac);
a(lemma_tac¨y < x ≤ x < yÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.1" *** *)
a(DROP_NTH_ASM_T 10 (bc_thm_tac o rewrite_rule[]));
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 10 (bc_thm_tac o rewrite_rule[]));
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(∂_tac¨cÆ THEN asm_rewrite_tac[lim_fun_def] THEN REPEAT strip_tac);
a(POP_ASM_T (fn th => lemma_tac¨ÓØ 0 < (1/3)*eÆ THEN1
	(ante_tac th THEN PC_T1 "Ø_lin_arith" asm_prove_tac[])));
a(DROP_NTH_ASM_T 6 (fn th => all_fc_tac
	[pc_rule1"sets_ext1" rewrite_rule[unif_lim_seq_def, open_interval_def]th]));
a(DROP_NTH_ASM_T 3 (fn th => all_fc_tac[rewrite_rule[lim_seq_def]th]));
a(DROP_NTH_ASM_T 4 (fn th => all_fc_tac[rewrite_rule[lim_fun_def](µ_elim¨n'Æth)]));
a(POP_ASM_T (strip_asm_tac o µ_elim¨n+n'Æ));
a(DROP_NTH_ASM_T 5 discard_tac THEN all_fc_tac[axbd_thm]);
a(∂_tac¨c'Æ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac ¨
	Abs(f y - u  (n+n') y) + Abs(u (n+n') y - s (n+n')) + Abs(s(n+n') - c)Æ
	THEN rewrite_tac[rewrite_rule[]abs_abcd_thm] THEN REPEAT strip_tac);
a(lemma_tac ¨Abs(f y + ~(u (n+n') y)) < (1/3)*e
	± Abs(u (n+n') y + ~(s(n+n'))) < (1/3)*e
	± Abs(s(n+n') + ~c) < (1/3)*eÆ
	THEN_LIST [id_tac, PC_T1 "Ø_lin_arith" asm_prove_tac[]]);
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(LEMMA_T ¨f y + ~ (u (n + n' ) y) =~ ((u (n + n') y) + ~(f y))Æ
	(fn th => pure_rewrite_tac[th, Ø_abs_minus_thm]) THEN1
	PC_T1 "Ø_lin_arith" prove_tac[]);
a(lemma_tac¨y < x ≤ x < yÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.1.1" *** *)
a(DROP_NTH_ASM_T 10 (bc_thm_tac o rewrite_rule[]));
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac THEN REPEAT strip_tac);
(* *** Goal "2.1.2" *** *)
a(DROP_NTH_ASM_T 10 (bc_thm_tac o rewrite_rule[]));
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 6 bc_thm_tac THEN REPEAT strip_tac);
a(PC_T1"Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.3" *** *)
a(DROP_NTH_ASM_T 8 bc_thm_tac THEN REPEAT strip_tac);
val €lim_fun_lim_seq_interchange_thm› = save_pop_thm "lim_fun_lim_seq_interchange_thm";
=TEX
We now embark on our variant of theorem 7.17 from Rudin (p. 152)
which says that if the derivatives of a sequence of differentiable functtions
converge uniformly in an interval and if the values of the sequence of functions
converges at some point in the interval then the sequence of functions converges
uniformly in the interval and the derivative of the limit is the limit of the derivatives.
Since our notions of continuity etc. are two-sided, we prove the theorem for
an open interval rather than a closed one. This is not expected to make much
difference in typical applications.
%%%%
%%%%
=SML
set_goal([], ¨µdu df x0 y0 A B u e ∑
	(du ---> df) (OpenInterval A B)
±	(µy m∑ A < y ± y < B ¥ (u m HasDeriv du m y) y)
±	A < x0 ± x0 < B
±	((Ãm∑ u m x0) ->  y0)
±	ÓØ 0 < e
¥	∂N∑ 	µn m x t∑ N º n ± N º m ± A < x ± x < B ± A < t ± t < B
	¥	Abs(u n t + ~ (u m t) + ~(u n x) + u m x) º Abs(t + ~x)*e
Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(lemma_tac ¨
	µe∑ ÓØ 0 < e ¥ ∂N∑ µn m x t∑ N º n ± N º m ± A < x ± x < t ± t < B ¥
		Abs(u n t + ~ (u m t) + ~(u n x) + u m x) º (t + ~x)*e
Æ);
(* *** Goal "1" *** *)
a(POP_ASM_T discard_tac);
a(REPEAT strip_tac THEN all_fc_tac[unif_lim_seq_cauchy_seq_thm]);
a(POP_ASM_T (strip_asm_tac o pc_rule1 "sets_ext1" rewrite_rule[open_interval_def]));
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(LEMMA_T¨∂ z d∑
	x < z ± z < t ± ((Ãw∑u n' w + ~(u m w)) HasDeriv d) z
	± (Ãw∑u n' w + ~(u m w)) t + ~ ((Ãw∑u n' w + ~(u m w)) x) = (t + ~ x) * d
Æ (strip_asm_tac o rewrite_rule[]) THEN1 bc_thm_tac (rewrite_rule[]mean_value_thm1));
(* *** Goal "1.1" *** *)
a(REPEAT strip_tac);
a(∂_tac ¨du n' x' + ~(du m x')Æ);
a(pure_once_rewrite_tac[prove_rule[]¨~(u m w) = (Ãw∑ ~(u m w)) wÆ] THEN1 bc_thm_tac plus_deriv_thm);
a(REPEAT strip_tac THEN_TRY bc_thm_tac minus_comp_deriv_thm THEN 
	(GET_NTH_ASM_T 13 bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
(* *** Goal "1.2" *** *)
a(POP_ASM_T (rewrite_thm_tac o rewrite_rule[Ø_plus_assoc_thm]));
a(LEMMA_T ¨d = du n' z + ~ (du m z)Æ rewrite_thm_tac THEN1 bc_thm_tac deriv_unique_thm);
(* *** Goal "1.2.1" *** *)
a(∂_tac¨zÆ THEN ∂_tac ¨Ã w∑ u n' w + ~ (u m w)Æ THEN REPEAT strip_tac);
a(pure_once_rewrite_tac[prove_rule[]¨~(u m w) = (Ãw∑ ~(u m w)) wÆ] THEN1 bc_thm_tac plus_deriv_thm);
a(REPEAT strip_tac THEN_TRY bc_thm_tac minus_comp_deriv_thm THEN 
	(GET_NTH_ASM_T 14 bc_thm_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
(* *** Goal "1.2.2" *** *)
a(LEMMA_T¨ÓØ 0 º t + ~ xÆ (fn th => rewrite_tac[Ø_abs_times_thm, th, µ_elim¨t + ~xÆ Ø_abs_def])
	THEN1  PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(once_rewrite_tac[Ø_º_0_º_thm]);
a(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b c:Ø∑a*b + ~(a*c) = a* (b + ~c)Æ]);
a(bc_thm_tac Ø_0_º_0_º_times_thm THEN strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨Abs (du n' z + ~ (du m z)) < e Æ
	(fn th => ante_tac th  THEN  PC_T1 "Ø_lin_arith"  prove_tac[]));
a(lemma_tac ¨A < z ± z < BÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_GET_NTH_ASM_T [11] (all_fc_tac o map (rewrite_rule[])));
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T [1] all_fc_tac);
a(∂_tac¨NÆ THEN REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim[¨xÆ, ¨tÆ]Ø_less_cases_thm));
(* *** Goal "2.1" *** *)
a(LEMMA_T ¨ÓØ 0 º t + ~xÆ (fn th => conv_tac(RIGHT_C (rewrite_conv[th, Ø_abs_def])))
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [8] all_fc_tac);
(* *** Goal "2.2" *** *)
a(all_var_elim_asm_tac THEN conv_tac (ONCE_MAP_C Ø_anf_conv) THEN rewrite_tac[]);
(* *** Goal "2.3" *** *)
a(pure_rewrite_tac[
	pc_rule1 "Ø_lin_arith" prove_rule[] ¨
		u n t + ~ (u m t) + ~ (u n x) + u m x = ~ (u n x + ~ (u m x) + ~ (u n t) + u m t)
	±	t + ~x = ~(x + ~t)Æ,
	Ø_abs_minus_thm]);
a(LEMMA_T ¨ÓØ 0 º x + ~tÆ (fn th => conv_tac(RIGHT_C (rewrite_conv[th, Ø_abs_def])))
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 8 bc_thm_tac THEN REPEAT strip_tac);
val €unif_lim_seq_deriv_estimate_thm› = save_pop_thm "unif_lim_seq_deriv_estimate_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨µdu df x0 y0 A B u ∑
	(du ---> df) (OpenInterval A B)
±	(µy m∑ A < y ± y < B ¥ (u m HasDeriv du m y) y)
±	A <  x0 ± x0 < B
±	((Ãm∑ u m x0) ->  y0)
¥	∂f∑ (u ---> f)  (OpenInterval A B)
Æ);
a(REPEAT strip_tac);
a(bc_thm_tac cauchy_seq_unif_lim_seq_thm THEN REPEAT strip_tac);
a(PC_T1"sets_ext1" rewrite_tac[open_interval_def]);
a(LEMMA_T¨ÓØ 0 < (1/2)*eÆ
	(fn th => POP_ASM_T discard_tac THEN strip_asm_tac th
	THEN all_fc_tac[lim_seq_cauchy_seq_thm] THEN POP_ASM_T (strip_asm_tac o rewrite_rule[]))
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T¨ÓØ 0 < (1/2)*e*(B + ~A)õ-õ1Æ
	(fn th => DROP_NTH_ASM_T 2 discard_tac THEN strip_asm_tac th
	THEN all_fc_tac[unif_lim_seq_deriv_estimate_thm]));
(* *** Goal "1" *** *)
a(REPEAT (bc_thm_tac Ø_0_less_0_less_times_thm THEN REPEAT strip_tac)
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(bc_thm_tac Ø_0_less_0_less_recip_thm THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨n + NÆ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨
	Abs(u k x0 + ~(u m x0)) + Abs(u k y + ~(u m y) + ~(u k x0) + u m x0)Æ
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[] THEN bc_thm_tac  Ø_º_trans_thm THEN
	∂_tac¨Abs((u k x0 + ~(u m x0)) + (u k y + ~(u m y) + ~(u k x0) + u m x0))Æ);
a(rewrite_tac[Ø_abs_plus_thm]);
a(conv_tac (ONCE_MAP_C Ø_anf_conv) THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(once_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[] ¨e = (1/2)*e + (1/2)*eÆ]
	THEN bc_thm_tac Ø_plus_mono_thm2 THEN REPEAT strip_tac
	THEN1 (GET_NTH_ASM_T 7 bc_thm_tac THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(lemma_tac¨N º k ± N º mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(bc_thm_tac Ø_º_less_trans_thm);
a(∂_tac¨Abs (y + ~ x0) * 1 / 2 * e * (B + ~ A) õ-õ1Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(DROP_NTH_ASM_T 7 bc_thm_tac);
a(REPEAT strip_tac THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal ".2.2.2" *** *)
a(pure_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µx y∑x * (1/2) * e * y = ((1/2)*e) * x * yÆ]);
a(pure_once_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µx y∑x<  y § x < y * ÓØ 1Æ]);
a(bc_thm_tac Ø_times_mono_thm THEN REPEAT strip_tac);
(* *** Goal ".2.2.2.1" *** *)
a(bc_thm_tac Ø_º_less_trans_thm);
a(∂_tac ¨Abs(u n x0 + ~(u n x0))Æ THEN pure_rewrite_tac [Ø_0_º_abs_thm]);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 9 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2" *** *)
a(lemma_tac ¨≥B + ~A  = ÓØ 0 ± ÓØ 0 < B + ~AÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T1 fc_§_canon once_rewrite_tac[µ_elim¨B + ~AÆ Ø_times_mono_§_thm]);
a(pure_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µx y∑(B + ~A)*x *y = x*y*(B + ~A)Æ]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(cases_tac¨ÓØ 0 º y + ~x0Æ THEN asm_rewrite_tac[Ø_abs_def]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €unif_lim_seq_deriv_lemma› = pop_thm();
=TEX

Now the main theorem.
(For historical reasons the proof works with a mixture of statements about
membership of open intervals and explicit inequalities; the fiddling around
in the first three tactic applications puts the goal in the form expected by
the rest of the proof.)
%%%%
%%%%
=SML
set_goal([], ¨µu du df A B x0 y0 ∑
	(du ---> df) (OpenInterval A B)
±	(µy m∑ y ç OpenInterval A B ¥ (u m HasDeriv du m y) y)
±	x0 ç OpenInterval A B
±	((Ãm∑ u m x0) ->  y0)
¥	∂f∑ (u ---> f)  (OpenInterval A B) ± µy∑ y ç OpenInterval A B ¥ (f HasDeriv df y) y
Æ);
a(REPEAT µ_tac);
a(conv_tac(LEFT_C (RIGHT_C (rewrite_conv[open_interval_def]))));
a(conv_tac(RIGHT_C (BINDER_C(RIGHT_C (rewrite_conv[open_interval_def])))));
a(REPEAT strip_tac);
a(all_fc_tac[unif_lim_seq_deriv_lemma]);
a(∂_tac¨fÆ THEN GET_NTH_ASM_T 5 ante_tac);
a(rewrite_tac[deriv_lim_fun_thm] THEN REPEAT strip_tac);
a(lemma_tac ¨∂g∑((Ãm∑Ã y'∑ (u m y' + ~ (u m y)) / (y' + ~ y)) ---> g) (OpenInterval A B \ {y})Æ);
(* *** Goal "1" *** *)
a(bc_thm_tac cauchy_seq_unif_lim_seq_thm THEN rewrite_tac[] THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < (1/2)*eÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 2 discard_tac);
a(all_fc_tac[unif_lim_seq_deriv_estimate_thm]);
a(∂_tac¨NÆ THEN PC_T1 "sets_ext1" rewrite_tac[open_interval_def] THEN REPEAT strip_tac);
a(lemma_tac¨y' < y ≤ y < y'Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.1" *** *)
a(list_spec_nth_asm_tac 7 [¨kÆ, ¨mÆ, ¨yÆ, ¨y'Æ]);
a(lemma_tac¨≥y' + ~y = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac [Ø_over_times_recip_thm]);
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b c d e: Ø∑
	(a + b) * c + ~((d + ~e) * c) = (a + ~d + b + e)*cÆ, 	Ø_abs_times_thm]);
a(ALL_FC_T rewrite_tac [Ø_abs_recip_thm]);
a(lemma_tac¨ÓØ 0 º Abs (y' + ~ y)Æ THEN1 rewrite_tac [Ø_0_º_abs_thm]);
a(lemma_tac¨≥Abs (y' + ~ y) = ÓØ 0Æ THEN1 asm_rewrite_tac [Ø_abs_eq_0_thm]);
a(lemma_tac¨ÓØ 0 < Abs (y' + ~ y)Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T1 fc_§_canon once_rewrite_tac [µ_elim¨Abs(y' + ~y)Æ Ø_times_mono_§_thm]);
a(once_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b c: Ø∑ a*b*c = b*a*cÆ]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(bc_thm_tac Ø_º_less_trans_thm);
a(∂_tac¨Abs (y' + ~ y) * 1 / 2 * eÆ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_times_mono_thm);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(list_spec_nth_asm_tac 7 [¨kÆ, ¨mÆ, ¨yÆ, ¨y'Æ]);
a(lemma_tac¨≥y' + ~y = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac [Ø_over_times_recip_thm]);
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b c d e: Ø∑
	(a + b) * c + ~((d + ~e) * c) = (a + ~d + b + e)*cÆ, 	Ø_abs_times_thm]);
a(ALL_FC_T rewrite_tac [Ø_abs_recip_thm]);
a(lemma_tac¨ÓØ 0 º Abs (y' + ~ y)Æ THEN1 rewrite_tac [Ø_0_º_abs_thm]);
a(lemma_tac¨≥Abs (y' + ~ y) = ÓØ 0Æ THEN1 asm_rewrite_tac [Ø_abs_eq_0_thm]);
a(lemma_tac¨ÓØ 0 < Abs (y' + ~ y)Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T1 fc_§_canon once_rewrite_tac [µ_elim¨Abs(y' + ~y)Æ Ø_times_mono_§_thm]);
a(once_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b c: Ø∑ a*b*c = b*a*cÆ]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(bc_thm_tac Ø_º_less_trans_thm);
a(∂_tac¨Abs (y' + ~ y) * 1 / 2 * eÆ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_times_mono_thm);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T¨∂s∑µm∑s m = du m yÆ (strip_asm_tac o  conv_rule (ONCE_MAP_C eq_sym_conv))
	THEN1 prove_∂_tac);
a(DROP_NTH_ASM_T 5 (ante_tac o µ_elim¨yÆ));
a(LIST_GET_NTH_ASM_T [1, 3, 4] rewrite_tac);
a(pure_once_rewrite_tac[prove_rule[]
	¨(Ã y'∑ (u m y' + ~ (u m y)) / (y' + ~ y)) = (Ãm y'∑ (u m y' + ~ (u m y)) / (y' + ~ y)) mÆ]);
a(REPEAT strip_tac THEN all_fc_tac[lim_fun_lim_seq_interchange_thm]);
a(lemma_tac¨µt∑A < t ± t < B ± ≥t = y ¥ g t = (Ã y'∑ (f y' + ~ (f y)) / (y' + ~ y)) tÆ);
(* *** Goal "2.1" *** *)
a(PC_T1 "predicates"  REPEAT strip_tac THEN bc_thm_tac unif_lim_seq_pointwise_unique_thm);
a(∂_tac¨OpenInterval A B \ {y}Æ THEN
	∂_tac¨(Ã m y'∑ (u m y' + ~ (u m y)) / (y' + ~ y))Æ THEN
	REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(PC_T1 "sets_ext1" rewrite_tac[open_interval_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.1.2" *** *)
a(lemma_tac¨≥t + ~y = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac times_lim_seq_thm);
a(rewrite_tac[const_lim_seq_thm]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac plus_lim_seq_thm);
a(conv_tac (RIGHT_C(once_rewrite_conv[minus_lim_seq_thm])) THEN rewrite_tac[]);
a(lemma_tac¨t ç OpenInterval A B ± y ç OpenInterval A BÆ
	THEN1 (PC_T1 "sets_ext1" rewrite_tac[open_interval_def]
		THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(all_fc_tac[unif_lim_seq_pointwise_lim_seq_thm] THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(lemma_tac¨s -> df yÆ);
(* *** Goal "2.2.1" *** *)
a(LEMMA_T¨s = Ãm∑du m yÆ rewrite_thm_tac THEN1 asm_rewrite_tac[]);
a(lemma_tac¨y ç OpenInterval A B Æ
	THEN1 (PC_T1 "sets_ext1" rewrite_tac[open_interval_def]
		THEN REPEAT strip_tac));
a(all_fc_tac[unif_lim_seq_pointwise_lim_seq_thm] THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(all_fc_tac[lim_seq_unique_thm] THEN all_var_elim_asm_tac1);
a(bc_thm_tac lim_fun_local_thm);
a(MAP_EVERY ∂_tac[¨BÆ, ¨AÆ, ¨gÆ] THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [4] (ALL_FC_T rewrite_tac));
val €unif_lim_seq_deriv_thm› = save_pop_thm "unif_lim_seq_deriv_thm";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Series and Power Series}
%%%%
%%%%
%%%%
%%%%
We now prove some basic facts about series and power series.
These depend on some facts about limits of particular sequences
that could have been given earlier, but may conveniently be given now.
To warm up, we prove equations showing that our
notions of series and power series are interdefinable:
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µs n x∑ PowerSeries s = Ãn∑ Ã x∑Series (Ãm∑ s m*x^m) nÆ);
a(REPEAT strip_tac);
a(rewrite_tac[power_series_def]);
a(induction_tac¨xÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[to_def, series_def, poly_eval_def]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[to_def, series_def, poly_eval_def, poly_eval_append_thm,
	length_to_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €power_series_series_thm› = save_pop_thm "power_series_series_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µs n∑ Series s = Ãn∑ PowerSeries s n (ÓØ 1)Æ);
a(REPEAT strip_tac THEN rewrite_tac[power_series_def]);
a(induction_tac¨xÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[to_def, series_def, poly_eval_def]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[to_def, series_def, poly_eval_def, poly_eval_append_thm,
	length_to_thm, Ø_Ó_exp_0_1_thm]);
val €series_power_series_thm› = save_pop_thm "series_power_series_thm";
=TEX
It is useful to know the value taken by the partial sums of a power series
when the argument is 0:
%%%%
%%%%
=SML
set_goal([], ¨
	PowerSeries s 0 (ÓØ 0) = ÓØ 0
±	µs m∑ PowerSeries s (m+1) (ÓØ 0) = s 0Æ);
a(rewrite_tac[power_series_series_thm] THEN REPEAT strip_tac
	THEN1 rewrite_tac[series_def, to_def]);
a(induction_tac¨mÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[to_def, series_def]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[to_def, series_def, Ø_Ó_exp_0_1_thm]);
val €power_series_0_arg_thm› = save_pop_thm "power_series_0_arg_thm";
=TEX
With the previous theorem we can readily prove our first result on convergence
of power series --- a trivial but useful one:
%%%%
%%%%
=SML
set_goal([], ¨µs∑ (Ã m∑ PowerSeries s m (ÓØ 0)) -> s 0Æ);
a(REPEAT strip_tac);
a(once_rewrite_tac[µ_elim¨1Æ lim_seq_shift_thm]);
a(rewrite_tac[power_series_0_arg_thm, const_lim_seq_thm]);
val €power_series_limit_0_thm› = save_pop_thm "series_power_limit_0_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µs1 s2∑ Series (Ãm∑s1 m + s2 m) = (Ãn∑ Series s1 n + Series s2 n)Æ);
a(REPEAT strip_tac THEN induction_tac¨x:ÓÆ THEN asm_rewrite_tac[series_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €plus_series_thm› = save_pop_thm "plus_series_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µs c∑ Series (Ãm∑ÓØ 0) = (Ãm∑ ÓØ 0)Æ);
a(REPEAT strip_tac THEN induction_tac¨x:ÓÆ THEN asm_rewrite_tac[series_def]);
val €series_0_thm› = save_pop_thm "series_0_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µs c∑ Series (Ãm∑c * s m) = (Ãn∑c * Series s n)Æ);
a(REPEAT strip_tac THEN induction_tac¨x:ÓÆ THEN asm_rewrite_tac[series_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €const_times_series_thm› = save_pop_thm "const_times_series_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨(Ãm∑ ÓØ (m+1) õ-õ1) -> ÓØ 0Æ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(all_fc_tac[Ø_archimedean_recip_thm]);
a(DROP_NTH_ASM_T 2 discard_tac THEN ∂_tac¨m+1Æ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨ÓØ (m + 1) õ-õ1Æ THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < ÓØ(m'+1)Æ THEN1 rewrite_tac[ÓØ_less_thm]);
a(lemma_tac¨≥ÓØ(m'+1) = ÓØ 0Æ THEN1 rewrite_tac[ÓØ_one_one_thm]);
a(ALL_FC_T rewrite_tac [Ø_abs_recip_thm]);
a(bc_thm_tac Ø_less_recip_less_thm);
a(rewrite_tac[ÓØ_less_thm]);
a(PC_T1 "lin_arith" asm_prove_tac[]);
val €lim_seq_ÓØ_recip_eq_0_lemma› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨(Ãm∑ ÓØ m õ-õ1) -> ÓØ 0Æ);
a(once_rewrite_tac[µ_elim¨1Æ lim_seq_shift_thm]);
a(rewrite_tac[lim_seq_ÓØ_recip_eq_0_lemma]);
val €lim_seq_ÓØ_recip_eq_0_thm› = save_pop_thm "lim_seq_ÓØ_recip_eq_0_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx∑ ÓØ 0 < x ± x < ÓØ 1 ¥ (Ãm∑ x^m) -> ÓØ 0Æ);
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(lemma_tac¨µm∑ÓØ 0 º x^mÆ THEN1
	(rewrite_tac[Ø_º_def] THEN FC_T rewrite_tac[Ø_Ó_exp_0_less_thm]));
a(asm_rewrite_tac[Ø_abs_def]);
a(all_fc_tac[Ø_Ó_exp_tends_to_0_thm]);
a(∂_tac¨m+1Æ THEN REPEAT strip_tac);
a(lemma_tac ¨m < m''Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac ¨x^mÆ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_Ó_exp_less_1_mono_thm1 THEN REPEAT strip_tac);
val €lim_seq_Ø_Ó_exp_eq_0_lemma› = pop_thm();
=TEX
%%%%
%%%%
=SML
set_goal([], ¨µx∑~(ÓØ 1) < x ± x < ÓØ 1 ¥ (Ãm∑ x^m) -> ÓØ 0Æ);
a(REPEAT strip_tac);
a(cases_tac¨x = ÓØ 0Æ THEN1
	(once_rewrite_tac[µ_elim¨1Æ lim_seq_shift_thm] THEN
		asm_rewrite_tac[Ø_Ó_exp_0_1_thm, const_lim_seq_thm]));
a(cases_tac¨ÓØ 0 < xÆ THEN1 all_fc_tac[lim_seq_Ø_Ó_exp_eq_0_lemma]);
a(once_rewrite_tac[µ_elim¨1Æ lim_seq_shift_thm] THEN rewrite_tac[]);
a(lemma_tac¨ÓØ 0 < ~x ± ~x < ÓØ 1Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_fc_tac[lim_seq_Ø_Ó_exp_eq_0_lemma]);
a(POP_ASM_T ante_tac);
a(pure_once_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µx∑~x  = ~(ÓØ 1) * xÆ]);
a(pure_rewrite_tac[Ø_Ó_exp_times_thm]);
a(DROP_ASMS_T discard_tac THEN rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [2] all_fc_tac);
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o µ_elim¨m+1Æ) THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(POP_ASM_T ante_tac);
a(rewrite_tac[Ø_abs_times_thm]);
a(LEMMA_T¨Abs (~ (ÓØ 1) ^ (m + 1)) = ÓØ 1Æ rewrite_thm_tac);
a(rewrite_tac[Ø_abs_Ø_Ó_exp_thm, Ø_Ó_exp_0_1_thm]);
val €lim_seq_Ø_Ó_exp_eq_0_thm› = save_pop_thm "lim_seq_Ø_Ó_exp_eq_0_thm";

=TEX
The following gives the identity for summing a geometric series.
%%%%
%%%%
=SML
set_goal([], ¨
	µn x∑ 
	≥x = ÓØ 1
¥	PolyEval ((Ãm∑ÓØ 1) To (n+1)) x = (ÓØ 1 - x^(n+1)) / (ÓØ 1 - x)
Æ);
a(REPEAT strip_tac);
a(ante_tac(rewrite_rule[rev_const_to_thm,Ø_Ó_exp_0_1_thm]
	(list_µ_elim[¨nÆ, ¨xÆ,  ¨ÓØ 1Æ] poly_diff_powers_thm)));
a(lemma_tac¨≥x + ~(ÓØ 1) = ÓØ 0 ± ≥ÓØ 1 + ~x = ÓØ 0Æ
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[µ_elim¨x + ~(ÓØ 1)Æ Ø_over_times_recip_thm]);
a(ALL_FC_T rewrite_tac[µ_elim¨(ÓØ 1 + ~x)Æ Ø_over_times_recip_thm]);
a(REPEAT strip_tac);
a(pure_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µt∑ÓØ 1 + ~t = ~(t + ~(ÓØ 1))Æ]);
a(ALL_FC_T pure_rewrite_tac[Ø_minus_recip_thm]);
a(pure_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b:Ø∑ ~a * ~b = a*bÆ]);
a(LEMMA_T¨µa b∑a = b ¥ (x + ~ (ÓØ 1)) õ-õ1 * a = b * (x + ~ (ÓØ 1)) õ-õ1Æ
	(fn th => all_fc_tac[th]) THEN1
	(REPEAT strip_tac THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(POP_ASM_T ante_tac);
a(asm_rewrite_tac[Ø_times_assoc_thm1]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
val €geometric_sum_thm› = save_pop_thm "geometric_sum_thm";
=TEX
We can now show that geometric series converge for arguments of absolute value
less than 1.
%%%%
%%%%
=SML
set_goal([], ¨
	µx∑ 
	~(ÓØ 1) < x ± x < ÓØ 1
¥	(Ãn∑ PowerSeries (Ãm∑ÓØ 1) n x) -> ÓØ 1 / (ÓØ 1 - x)
Æ);
a(REPEAT strip_tac THEN lemma_tac ¨≥x = ÓØ 1Æ THEN1 PC_T1 "Ø_lin_arith"
	asm_prove_tac[]);
a(rewrite_tac[power_series_def]);
a(once_rewrite_tac[µ_elim¨1Æ lim_seq_shift_thm]);
a(FC_T rewrite_tac[geometric_sum_thm]);
a(lemma_tac¨≥ÓØ 1 + ~x = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[µ_elim¨(ÓØ 1 + ~x)Æ Ø_over_times_recip_thm]);
a(rewrite_tac[Ø_times_plus_distrib_thm]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(conv_tac (RIGHT_C (once_rewrite_conv[prove_rule[]¨µx∑x = x + ÓØ 0Æ])));
a(bc_thm_tac plus_lim_seq_thm THEN rewrite_tac[const_lim_seq_thm]);
a(once_rewrite_tac[prove_rule[]¨ÓØ 0 = ÓØ 0 * (ÓØ 1 + ~ x) õ-õ1Æ]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac times_lim_seq_thm THEN rewrite_tac[const_lim_seq_thm]);
a(once_rewrite_tac[prove_rule[]¨ÓØ 0 = ~(ÓØ 0)Æ]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac minus_lim_seq_thm);
a(bc_thm_tac( rewrite_rule[]
	(once_rewrite_rule[µ_elim¨1Æ lim_seq_shift_thm] lim_seq_Ø_Ó_exp_eq_0_thm)));
a(REPEAT strip_tac);
val €geometric_series_thm› = save_pop_thm "geometric_series_thm";
=TEX
A simpler formula for a geometric series is often useful:
%%%%
%%%%
=SML
set_goal([], ¨
	µx∑ (Ãn∑ PowerSeries (Ãm∑ÓØ 1) n x) = Series (Ãm∑x^m)
Æ);
a(REPEAT strip_tac THEN rewrite_tac[power_series_def]);
a(induction_tac¨x':ÓÆ THEN rewrite_tac[series_def, poly_eval_def, to_def]);
a(asm_rewrite_tac [poly_eval_append_thm, length_to_thm, poly_eval_def]);
val €geometric_series_series_thm› = save_pop_thm "geometric_series_series_thm";
=TEX
The theorem about the convergence of a geometric series then simplifies:
%%%%
%%%%
=SML
set_goal([], ¨
	µx∑ 
	~(ÓØ 1) < x ± x < ÓØ 1
¥	Series (Ãm∑x^m) -> ÓØ 1 / (ÓØ 1 - x)
Æ);
a(ante_tac geometric_series_thm THEN rewrite_tac[geometric_series_series_thm]);
val €geometric_series_thm1› = save_pop_thm "geometric_series_thm1";
=TEX
The Weierstrass uniform convergence test: a series of functions with absolute
values dominated by a convergent series on some set of values converges uniformly
to a limit function on that set.
%%%%
%%%%
=SML
set_goal([], ¨
	µu X s c∑ 
	(µm x∑x ç X ¥ Abs(u m x) º s m)
±	(Series s -> c)
¥	∂f∑ ((Ãm∑Ãx∑Series (Ãm∑u m x) m) ---> f) X
Æ);
a(REPEAT strip_tac);
a(fc_tac[lim_seq_cauchy_seq_thm]);
a(bc_thm_tac cauchy_seq_unif_lim_seq_thm);
a(REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [2] all_fc_tac);
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 ante_tac THEN rewrite_tac[]);
a(REPEAT strip_tac);
a(lemma_tac¨Abs (Series s k + ~ (Series s m)) < eÆ
	THEN1 LIST_DROP_NTH_ASM_T [1] all_fc_tac);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨Abs (Series s k + ~ (Series s m))Æ
	THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T ((interval 1 7) less 3) discard_tac);
a(lemma_tac  ¨µk m∑ m º k ¥
	Abs (Series (Ã m∑ u m y) k + ~ (Series (Ã m∑ u m y) m))
		º Series s k + ~ (Series s m)Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[º_def]));
a(all_var_elim_asm_tac1);
a(induction_tac ¨iÆ THEN rewrite_tac[series_def, plus_assoc_thm1, Ø_plus_assoc_thm1]);
a(once_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b c:Ø∑ (a+b) + ~c = b + a + ~cÆ]);
a(bc_thm_tac Ø_º_trans_thm THEN ∂_tac¨
	Abs(u (m+i) y) + Abs(Series (Ã m∑ u m y) (m + i) + ~ (Series (Ã m∑ u m y) m)) Æ);
a(rewrite_tac[Ø_abs_plus_thm]);
a(bc_thm_tac (pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b c d:Ø∑a º b ± c º d ¥ a + c º b + dÆ));
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(lemma_tac  ¨µm∑ ÓØ 0 º s mÆ);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac THEN bc_thm_tac Ø_º_trans_thm
	THEN ∂_tac ¨Abs(u m y)Æ);
a(rewrite_tac[Ø_0_º_abs_thm] THEN GET_NTH_ASM_T 3 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(lemma_tac  ¨µk m∑ m º k ¥ ÓØ 0 º Series s k + ~ (Series s m)Æ);
(* *** Goal "2.2.1" *** *)
a(REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[º_def]));
a(all_var_elim_asm_tac1);
a(induction_tac ¨iÆ THEN rewrite_tac[series_def, plus_assoc_thm1]);
a(spec_nth_asm_tac 2 ¨m+iÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2.2" *** *)
a(lemma_tac ¨k º m ≤ m º kÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2.2.2.1" *** *)
a(once_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b:Ø∑a + ~b = ~(b + ~a)Æ]);
a(pure_rewrite_tac[Ø_abs_minus_thm]) (* Makes it same as 2.2.2.2! *);
a(conv_tac (RIGHT_C (rewrite_conv[Ø_abs_def])));
a(LIST_DROP_NTH_ASM_T [2] (ALL_FC_T rewrite_tac));
a(GET_NTH_ASM_T 3 bc_thm_tac THEN REPEAT strip_tac);
val €weierstrass_test_thm› = save_pop_thm "weierstrass_test_thm";
=TEX
The comparison test: a series whose absolute values are dominated by a convergent
series is convergent (this is often stated in the special case when the dominated series
is a series of non-negative values, but the general case is just as easy in the present context):
%%%%
%%%%
=SML
set_goal([], ¨
	µs1 s2 c2∑ 
	(µm∑Abs(s1 m) º s2 m)
±	(Series s2 ->  c2)
¥	∂c1∑ Series s1 -> c1
Æ);
a(REPEAT strip_tac);
a(ante_tac (list_µ_elim [¨Ãm; x:Ø∑s1 mÆ, ¨Universe:Ø SETÆ, ¨s2Æ, ¨c2Æ] weierstrass_test_thm));
a(asm_rewrite_tac[lim_seq_def, unif_lim_seq_def, µ_elim¨s1Æ »_axiom] THEN REPEAT strip_tac);
a(∂_tac¨f xÆ THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [2] all_fc_tac);
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 bc_thm_tac THEN REPEAT strip_tac);
val €comparison_test_thm› = save_pop_thm "comparison_test_thm";
=TEX
The next theorem gives the identity relating a series to a trailing subseries:
%%%%
%%%%
=SML
set_goal([], ¨
	µn s∑ (Series (Ãm∑ s (m + n))  = Ãm∑Series s (m+n) - Series s n)
Æ);
a(REPEAT strip_tac);
a(induction_tac¨x:ÓÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[series_def]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[series_def]);
a(rewrite_tac[pc_rule1"lin_arith" prove_rule[]¨(x+1)+n=(x+n)+1Æ, series_def]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €series_shift_thm› = save_pop_thm "series_shift_thm";
=TEX
A series is convergent iff. some trailing subseries is convergent.
We first state and prove this with an explicit formula for the limit:
%%%%
%%%%
=SML
set_goal([], ¨
	µn s x∑ 
	(Series s ->  x)
§	(Series (Ãm∑ s (m + n)) -> x - Series s n)
Æ);
a(REPEAT µ_tac);
a(rewrite_tac[series_shift_thm]);
a(conv_tac(LEFT_C(once_rewrite_conv[µ_elim¨nÆ lim_seq_shift_thm])));
a(rewrite_tac[lim_seq_def]);
a(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b c:Ø∑ (a + ~b) + c + b = a + cÆ]);
val €lim_series_shift_thm› = save_pop_thm "lim_series_shift_thm";
=TEX
As a technical convenience it is also useful to have a pure existence version of
the above theorem:
%%%%
%%%%
=SML
set_goal([], ¨
	µn s∑ 
	(∂x∑Series s ->  x)
§	(∂x∑ Series (Ãm∑ s (m + n)) -> x)
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨x - Series s nÆ);
a(bc_thm_tac lim_series_shift_thm THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(∂_tac¨x + Series s nÆ);
a(once_rewrite_tac[µ_elim¨nÆ lim_series_shift_thm]);
a(conv_tac (ONCE_MAP_C Ø_anf_conv) THEN REPEAT strip_tac);
val €lim_series_shift_∂_thm› = save_pop_thm "lim_series_shift_∂_thm";
=TEX
The root test without tears (or roots!). The usual statement of this is that a series $\Sigma s_m$ converges
if $ \LimSup\,\sqrt[m]{\Abs{s_m}} < 1$. The proof of this fact immediately translates
the condition into the assertion that $\Abs{s_m}$ is bounded by $b^m$ for some $b$, $0 < b < 1$,
for all large enough $m$. Since the latter assertion is exactly what you have to prove to show that
$ \LimSup\,\sqrt[m]{\Abs{s_m}} < 1$, we just use it directly in our statement of the theorem.
This form given is just as easy to use in most applications (and better captures the essence of what is actually going
on, in my opinion).
%%%%
%%%%
=SML
set_goal([], ¨
	µs b m∑ 
	ÓØ 0 < b ± b  < ÓØ 1 
±	(µn∑m º n ¥ Abs(s n) º b^n)
¥	∂c∑ Series s -> c
Æ);
a(REPEAT strip_tac);
a(once_rewrite_tac[µ_elim¨mÆlim_series_shift_∂_thm]);
a(bc_thm_tac comparison_test_thm);
a(∂_tac¨(ÓØ 1 / (ÓØ 1 + ~ b)) *  b^mÆ THEN ∂_tac ¨Ãk∑b ^(k + m)Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[] THEN POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[Ø_Ó_exp_plus_thm]);
a(once_rewrite_tac[Ø_times_comm_thm]);
a(rewrite_tac[
	conv_rule(ONCE_MAP_C ¬_conv)(µ_elim¨Ãk∑b^kÆ const_times_series_thm)]);
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac times_lim_seq_thm);
a(rewrite_tac[const_lim_seq_thm]);
a(lemma_tac¨~(ÓØ 1) < bÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(rewrite_tac[µ_elim¨Series (Ã k∑ b ^ k)Æ»_axiom]);
a(ALL_FC_T rewrite_tac[rewrite_rule[]geometric_series_thm1]);
val €simple_root_test_thm› = save_pop_thm "simple_root_test_thm";
=TEX

%%%%
%%%%
=SML
set_goal([], ¨
	µe s c∑ 
	ÓØ 0 < e
±	Series s -> c
¥	∂m∑ µn∑m º n ¥ Abs(s n) < e
Æ);
a(REPEAT strip_tac);
a(all_fc_tac[lim_seq_diffs_tend_to_0_thm]);
a(POP_ASM_T ante_tac THEN POP_ASM_T discard_tac);
a(rewrite_tac[series_def] THEN conv_tac(ONCE_MAP_C Ø_anf_conv));
a(rewrite_tac[lim_seq_def] THEN REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o µ_elim¨eÆ));
a(∂_tac¨nÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 bc_thm_tac THEN REPEAT strip_tac);
val €lim_series_bounded_thm› = save_pop_thm "lim_series_bounded_thm";
=TEX
The root test as formulated above will also tolerate a multiplicative constant in the estimate.
Moreover there is no need to assume that either of the constants is positive. This gives
the following generalisation which is what we will typically use in practice.
%%%%
%%%%
=SML
set_goal([], ¨
	µs b d m∑ 
	b  < ÓØ 1 
±	(µn∑m º n ¥ Abs(s n) º d*b^n)
¥	∂c∑ Series s -> c
Æ);
a(REPEAT strip_tac THEN  CASES_T ¨b = ÓØ 0 ≤ d = ÓØ 0Æ asm_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨µn∑d*b^(n+1) = ÓØ 0Æ THEN1 (POP_ASM_T strip_asm_tac THEN
	asm_rewrite_tac[Ø_Ó_exp_0_1_thm]));
a(LEMMA_T¨µn∑m º n ¥ Abs(s(n+1)) º d*b^(n+1)Æ ante_tac THEN1 (
	REPEAT strip_tac THEN
		DROP_NTH_ASM_T 4 bc_thm_tac THEN PC_T1 "lin_arith" asm_prove_tac[]));
a(asm_rewrite_tac[Ø_abs_º_0_thm] THEN strip_tac);
a(once_rewrite_tac[µ_elim¨m+1Æ lim_series_shift_∂_thm]);
a(∂_tac¨ÓØ 0Æ);
a(LEMMA_T ¨(Ãk∑s(k + m + 1)) = (Ãm∑ÓØ 0)Æ 
	(fn th => rewrite_tac[th, series_0_thm, const_lim_seq_thm]));
a(REPEAT strip_tac THEN rewrite_tac[plus_assoc_thm1]);
a(POP_ASM_T bc_thm_tac THEN PC_T1 "lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T strip_asm_tac);
a(spec_nth_asm_tac 3 ¨mÆ);
a(GET_NTH_ASM_T 4 (strip_asm_tac o rewrite_rule[Ø_Ó_exp_def] o µ_elim¨m + 1Æ));
a(lemma_tac¨≥b^m = ÓØ 0 Æ THEN1
	(bc_thm_tac Ø_Ó_exp_≥_eq_0_thm THEN REPEAT strip_tac));
a(lemma_tac¨≥d * b ^ m = ÓØ 0 ± ≥d * b *b^m = ÓØ 0Æ THEN1
	(asm_rewrite_tac[Ø_times_eq_0_thm]));
a(lemma_tac¨≥b^m = ÓØ 0 Æ THEN1
	(bc_thm_tac Ø_Ó_exp_≥_eq_0_thm THEN REPEAT strip_tac));
a(lemma_tac¨ÓØ 0 º d*b^mÆ THEN1
	(bc_thm_tac Ø_º_trans_thm THEN ∂_tac ¨Abs (s m)Æ THEN asm_rewrite_tac[Ø_0_º_abs_thm]));
a(lemma_tac¨ÓØ 0 º d* b * b^mÆ THEN1
	(bc_thm_tac Ø_º_trans_thm THEN ∂_tac ¨Abs (s (m+1))Æ THEN asm_rewrite_tac[Ø_0_º_abs_thm]));
a(lemma_tac¨ÓØ 0 < d* b^m ± ÓØ 0 < d* b * b^mÆ THEN1
	(PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨ÓØ 0 < (d*b^m)õ-õ1Æ THEN1 all_fc_tac[Ø_0_less_0_less_recip_thm]);
a(LEMMA_T¨ÓØ 0 < (d*b*b^m)*(d*b^m)õ-õ1Æ ante_tac THEN1 all_fc_tac[Ø_0_less_0_less_times_thm]);
a(ALL_FC_T rewrite_tac [Ø_recip_clauses]);
a(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b c d e:Ø∑(a*b*c)*d *e = b*a*d*c*eÆ]);
a(ALL_FC_T rewrite_tac [Ø_recip_clauses]);
a(REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 <  b^m Æ THEN1
	(bc_thm_tac Ø_Ó_exp_0_less_thm THEN REPEAT strip_tac));
a(lemma_tac¨ÓØ 0 < (b^m)õ-õ1Æ THEN1 all_fc_tac[Ø_0_less_0_less_recip_thm]);
a(LEMMA_T¨ÓØ 0 < (d*b^m) * (b^m) õ-õ1 Æ ante_tac THEN1 all_fc_tac[Ø_0_less_0_less_times_thm]);
a(rewrite_tac[Ø_times_assoc_thm] THEN  ALL_FC_T rewrite_tac [Ø_recip_clauses]);
a(REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [1, 4, 15, 17, 18] (MAP_EVERY ante_tac)
	THEN DROP_ASMS_T discard_tac THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < d õ-õ1Æ THEN1
	(bc_thm_tac Ø_0_less_0_less_recip_thm THEN REPEAT strip_tac));
a(lemma_tac¨∂k∑b^k < d õ-õ1Æ THEN1
	(bc_thm_tac Ø_Ó_exp_tends_to_0_thm THEN REPEAT strip_tac));
a(once_rewrite_tac [µ_elim¨kÆ lim_series_shift_∂_thm]);
a(bc_thm_tac simple_root_test_thm);
a(∂_tac¨mÆ THEN ∂_tac¨bÆ THEN rewrite_tac[] THEN REPEAT strip_tac);
a(lemma_tac ¨m º n + kÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(spec_nth_asm_tac 8 ¨n+kÆ);
a(REPEAT strip_tac THEN bc_thm_tac Ø_º_trans_thm THEN
	∂_tac¨d * b^(n+k)Æ THEN REPEAT strip_tac);
a(once_rewrite_tac[Ø_times_comm_thm]);
a(rewrite_tac[Ø_Ó_exp_plus_thm, Ø_times_assoc_thm]);
a(bc_thm_tac Ø_º_trans_thm THEN ∂_tac¨b^n * ÓØ 1Æ);
a(conv_tac(RIGHT_C (rewrite_conv[])) THEN REPEAT strip_tac);
a(bc_thm_tac Ø_º_times_mono_thm THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[Ø_º_def] THEN ≤_left_tac);
a(bc_thm_tac Ø_Ó_exp_0_less_thm THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(REPEAT strip_tac THEN bc_thm_tac Ø_º_trans_thm THEN ∂_tac¨d õ-õ1 * dÆ);
a(REPEAT strip_tac THEN_LIST [id_tac, ALL_FC_T rewrite_tac[Ø_recip_clauses]]);
a(once_rewrite_tac[Ø_times_comm_thm]);
a(bc_thm_tac Ø_º_times_mono_thm);
a(asm_rewrite_tac[Ø_º_def]);
val €root_test_thm› = save_pop_thm "root_test_thm";
=TEX
The heart ratio test: this is generally formulated
using lim sups or limits (which can be useful), but neither is necessary: we just need to know that
the ratios are eventually all bounded below 1. We formulate this as follows.
%%%%
%%%%
=SML
set_goal([], ¨
	µs b n∑
	(µm∑≥s m = ÓØ 0)
±	ÓØ 0 < b ± b < ÓØ 1
±	(µn∑m º n ¥ Abs(s (n+1) / s n) < b)
¥	∂c ∑ Series s -> c
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µi∑ÓØ 0 < Abs(s i)Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim¨s iÆ Ø_0_º_abs_thm));
a(DROP_NTH_ASM_T 5 (strip_asm_tac o µ_elim¨iÆ));
a(lemma_tac¨≥Abs(s i ) = ÓØ 0Æ THEN1 asm_rewrite_tac[Ø_abs_eq_0_thm]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a( lemma_tac¨µi∑Abs(s(m + i)) º Abs(s m) * b^ iÆ);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac THEN induction_tac¨i:ÓÆ THEN rewrite_tac[Ø_Ó_exp_def]);
a(rewrite_tac[Ø_º_def] THEN ≤_left_tac);
a(DROP_NTH_ASM_T 3 (ante_tac o µ_elim¨m + iÆ));
a(DROP_NTH_ASM_T 5 (strip_asm_tac o µ_elim¨m + iÆ));
a(rewrite_tac[plus_assoc_thm]);
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(rewrite_tac[Ø_abs_times_thm, Ø_times_assoc_thm]);
a(ALL_FC_T rewrite_tac[Ø_abs_recip_thm] THEN REPEAT strip_tac);
a(bc_thm_tac Ø_less_º_trans_thm THEN ∂_tac¨Abs(s(m+i))*bÆ THEN REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(lemma_tac¨≥Abs(s(m+i) ) = ÓØ 0Æ THEN1 asm_rewrite_tac[Ø_abs_eq_0_thm]);
a(DROP_NTH_ASM_T 5 (strip_asm_tac o µ_elim¨m + iÆ));
a(lemma_tac¨ÓØ 0 < Abs(s(m+i))õ-õ1Æ THEN1 all_fc_tac[Ø_0_less_0_less_recip_thm]);
a(ALL_FC_T1 fc_§_canon once_rewrite_tac
	[µ_elim¨Abs(s(m+i))õ-õ1Æ Ø_times_mono_§_thm]);
a(once_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
	¨µa b c d e:Ø∑a * b < c * d * e § b * a < (c * d) * eÆ]);
a(ALL_FC_T asm_rewrite_tac[Ø_recip_clauses]);
(* *** Goal "2.1.2" *** *)
a(once_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
	¨µa b c d e:Ø∑a * b º c * d * e § b * a º d * c * eÆ]);
a(bc_thm_tac Ø_º_times_mono_thm THEN REPEAT strip_tac);
a(asm_rewrite_tac[Ø_º_def]);
(* *** Goal "2.2" *** *)
a(once_rewrite_tac[µ_elim¨mÆ lim_series_shift_∂_thm]);
a(bc_thm_tac root_test_thm);
a(∂_tac¨Abs(s m)Æ THEN ∂_tac¨0Æ  THEN ∂_tac¨bÆ THEN rewrite_tac[] THEN REPEAT strip_tac);
a(once_rewrite_tac [plus_comm_thm] THEN asm_rewrite_tac[]);
val €ratio_test_thm1› = save_pop_thm "ratio_test_thm1";
=TEX
The ratio test  in terms of limits is often useful (and this is what we call the ratio test).
%%%%
%%%%
=SML
set_goal([], ¨
	µs b n∑
	(µm∑≥s m = ÓØ 0)
±	ÓØ 0 º b ± b < ÓØ 1
±	(Ãn∑ Abs(s (n+1) / s n)) -> b
¥	∂c ∑ Series s -> c
Æ);
a(REPEAT strip_tac THEN bc_thm_tac ratio_test_thm1 THEN
	POP_ASM_T (strip_asm_tac o rewrite_rule[lim_seq_def]) THEN 
	rename_tac[] THEN asm_rewrite_tac[] );
a(lemma_tac¨∂c∑ÓØ 0 < c ± ÓØ 0 < c + ~b ± c < ÓØ 1Æ THEN1
	(∂_tac¨(b + ÓØ 1) / ÓØ 2Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(LIST_DROP_NTH_ASM_T [3, 6] (MAP_EVERY ante_tac)
	THEN LIST_DROP_NTH_ASM_T [3] all_fc_tac);
a(REPEAT strip_tac THEN ∂_tac¨nÆ THEN ∂_tac ¨cÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (ante_tac o µ_elim¨n'Æ) THEN asm_rewrite_tac[]);
a(ALL_FC_T1 fc_§_canon rewrite_tac[Ø_abs_diff_bounded_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €ratio_test_thm› = save_pop_thm "ratio_test_thm";
=TEX
Uniform convergence of power series:
%%%%
%%%%
=SML
set_goal([], ¨
	µs B C b∑
	ÓØ 0 < B ± ÓØ 0 < b ± b < B
±	(Ãm∑ PowerSeries (Ãm∑Abs(s m)) m B) ->  C
¥	∂f∑ (PowerSeries s ---> f) (OpenInterval (~b) b)
Æ);
a(rewrite_tac[power_series_series_thm] THEN REPEAT strip_tac);
a(pure_once_rewrite_tac[prove_rule[]¨µm : Ó; x:Ø∑ 
		(Ã m∑ s m * x ^ m) =
		(Ã m∑ (Ãm x∑ s m  * x ^ m) m x)Æ]);
a(bc_thm_tac weierstrass_test_thm);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[»_axiom]));
a(∂_tac¨CÆ THEN ∂_tac ¨Ã m∑ Abs (s m) * B ^ mÆ THEN rewrite_tac[open_interval_def]
	THEN REPEAT strip_tac);
a(rewrite_tac [Ø_abs_times_thm]);
a(bc_thm_tac Ø_º_times_mono_thm THEN rewrite_tac[Ø_0_º_abs_thm]);
a(rewrite_tac[Ø_abs_Ø_Ó_exp_thm]);
a(induction_tac¨mÆ THEN rewrite_tac[Ø_Ó_exp_def]);
a(lemma_tac ¨Abs x º  bÆ THEN1
	(cases_tac ¨ÓØ 0 º xÆ THEN asm_rewrite_tac[Ø_abs_def]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(bc_thm_tac Ø_º_trans_thm THEN ∂_tac¨Abs x * B ^ mÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ø_º_times_mono_thm THEN asm_rewrite_tac[Ø_0_º_abs_thm]);
(* *** Goal "2" *** *)
a(once_rewrite_tac[Ø_times_comm_thm]);
a(bc_thm_tac Ø_º_times_mono_thm THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[Ø_º_def] THEN ≤_left_tac);
a(bc_thm_tac Ø_Ó_exp_0_less_thm THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €power_series_convergence_thm› = save_pop_thm "power_series_convergence_thm";
=TEX
Formula for the derivatives of partial sums of a power series:
%%%%
%%%%
=SML
set_goal([], ¨
	µs n x∑
	(PowerSeries s (n+1) HasDeriv PowerSeries (Ãm∑ÓØ (m+1)*s(m+1)) n x) x
Æ);
a(rewrite_tac[power_series_series_thm, series_def] THEN REPEAT strip_tac);
a(induction_tac ¨nÆ THEN rewrite_tac [series_def]);
(* *** Goal "1" *** *)
a(rewrite_tac[const_deriv_thm]);
(* *** Goal "2" *** *)
a(conv_tac (RATOR_C (RATOR_C(RANDS_C Ã_un_¬_rands_conv))));
a(bc_thm_tac plus_deriv_thm);
a(REPEAT strip_tac);
a(conv_tac (RATOR_C (RATOR_C(RAND_C Ã_un_¬_rands_conv))));
a(once_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[] ¨µa b c:Ø∑ (a * b) * c = b * a * cÆ]);
a(rewrite_tac[ÓØ_plus_homomorphism_thm]);
a(accept_tac (rewrite_rule[const_deriv_thm, power_deriv_thm] (
	list_µ_elim[¨Ã x:Ø∑ s (n + 1)Æ, ¨ÓØ 0Æ, ¨xÆ, ¨Ãx:Ø∑x ^ (n + 1)Æ, ¨(ÓØ n + ÓØ 1)* x ^ nÆ] 	
			times_deriv_thm
)));
val €power_series_deriv_coeffs_thm› = save_pop_thm "power_series_deriv_coeffs_thm";
=TEX
Now lemmas needed in showing the convergence of the sequence of derivatives
of a convergent power series. The first one is the special case where the sequence
is a convergent geometric series:
%%%%
%%%%
=SML
set_goal([], ¨
	µ b ∑
	ÓØ 0 < b ± b < ÓØ 1
¥	∂c ∑ Series (Ãm∑ ÓØ (m + 1) * b ^ m) -> c
Æ);
a(REPEAT strip_tac THEN bc_thm_tac ratio_test_thm);
a(∂_tac¨bÆ THEN asm_rewrite_tac[Ø_º_def]);
a(lemma_tac¨≥ b = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac¨µm∑≥ b^m = ÓØ 0Æ THEN1
	(strip_tac THEN ALL_FC_T rewrite_tac [Ø_Ó_exp_≥_eq_0_thm]));
a(lemma_tac¨µm∑ ≥ ÓØ (m + 1) = ÓØ 0Æ THEN1 rewrite_tac[ÓØ_one_one_thm]);
a(once_rewrite_tac[taut_rule ¨µp q∑p ± q § p ± (p ¥q)Æ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨≥ b^m = ÓØ 0Æ THEN1 asm_rewrite_tac[]);
a(asm_rewrite_tac[Ø_times_eq_0_thm] THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_T ¨µm x∑ x / (ÓØ (m + 1) * b ^ m) = x * (ÓØ (m + 1) * b ^ m) õ-õ1 Æ
	asm_rewrite_thm_tac THEN1
		(µ_tac THEN bc_thm_tac Ø_over_times_recip_thm THEN asm_rewrite_tac[]));
a(LEMMA_T¨µn∑ (ÓØ (n + 1) * b ^ n) õ-õ1  =  ÓØ (n + 1)õ-õ1  *( b ^ n) õ-õ1Æ
	rewrite_thm_tac THEN1
		(REPEAT strip_tac THEN
			(lemma_tac¨≥ ÓØ(n+1) = ÓØ 0 ± ≥b ^ n = ÓØ 0Æ
				THEN1 asm_rewrite_tac[]) THEN
					 all_fc_tac[ Ø_recip_clauses]));
a(rewrite_tac[Ø_Ó_exp_plus_thm, Ø_times_assoc_thm]);
a(once_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µa b c d e:Ø∑a * b * c * d * e = c * a * d * b * eÆ]);
a(LEMMA_T ¨µm∑ b^m * (b ^ m) õ-õ1 = ÓØ 1Æ  rewrite_thm_tac THEN1
	(REPEAT strip_tac 	THEN
		(lemma_tac¨≥b ^ m = ÓØ 0Æ
			THEN1 asm_rewrite_tac[]) THEN
					 all_fc_tac[ Ø_recip_clauses]));
a(rewrite_tac[Ø_abs_times_thm]);
a(LEMMA_T¨Abs b = bÆ rewrite_thm_tac THEN1
	asm_rewrite_tac[Ø_abs_def, Ø_º_def]);
a(lemma_tac¨µm∑ ÓØ 0 < ÓØ(m+1)õ-õ1 Æ  THEN1
	(REPEAT strip_tac THEN
		(lemma_tac¨ÓØ 0 < ÓØ (m+1)Æ
			THEN1 rewrite_tac[ÓØ_less_thm]) THEN
					 all_fc_tac[ Ø_0_less_0_less_recip_thm]));
a(asm_rewrite_tac[Ø_abs_def, Ø_º_def]);
a(conv_tac (RIGHT_C(pure_once_rewrite_conv[prove_rule[]¨b = b * ÓØ 1Æ])));
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac times_lim_seq_thm THEN rewrite_tac[const_lim_seq_thm]);
a(conv_tac (LEFT_C(Ã_C(LEFT_C (once_rewrite_conv[ÓØ_plus_homomorphism_thm])))));
a(rewrite_tac[Ø_times_plus_distrib_thm]);
a(LEMMA_T¨µm∑ ÓØ (m + 1) * ÓØ(m+1) õ-õ1 = ÓØ 1Æ  rewrite_thm_tac THEN1
	(REPEAT strip_tac THEN
		(lemma_tac¨≥ÓØ (m+1) = ÓØ 0Æ
			THEN1 rewrite_tac[ÓØ_one_one_thm]) THEN
					 all_fc_tac[ Ø_recip_clauses]));
a(conv_tac (RIGHT_C(pure_once_rewrite_conv[prove_rule[]¨ÓØ 1 = ÓØ 1 + ÓØ 0Æ])));
a(conv_tac (LEFT_C Ã_un_¬_rands_conv));
a(bc_thm_tac plus_lim_seq_thm THEN rewrite_tac[
	const_lim_seq_thm,
	rewrite_rule[](µ_elim¨ÓØ 0Æ lim_seq_recip_Ó_thm)]);
val €power_series_deriv_lemma1› = save_pop_thm "power_series_deriv_lemma1";
=TEX
Another lemma for the convergence of the derivatives of partial sums of a power series:
this is the special case where the estimate on the radius of convergence is 1, for
which the calculations are rather simpler.

%%%%
%%%%
=SML
set_goal([], ¨
	µs C b∑
	ÓØ 0 < b ± b < ÓØ 1
±	(Ãm∑ PowerSeries (Ãm∑Abs(s m)) m (ÓØ 1)) ->  C
¥	∂D∑ (Ãm∑ PowerSeries (Ãm∑Abs((ÓØ (m+1))*s (m+1))) m b) -> D
Æ);
a(rewrite_tac[power_series_series_thm] THEN REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[»_axiom, Ø_Ó_exp_0_1_thm]));
a(all_fc_tac[rewrite_rule[](µ_elim¨ÓØ 1Æ lim_series_bounded_thm)]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_abs_abs_thm, Ø_abs_times_thm]));
a(conv_tac (RAND_C(Ã_C (once_rewrite_conv[»_axiom]))));
a(once_rewrite_tac[µ_elim¨mÆ lim_series_shift_∂_thm]);
a(all_fc_tac[once_rewrite_rule[µ_elim¨mÆ lim_series_shift_∂_thm]power_series_deriv_lemma1]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[] o µ_elim¨mÆ));
a(bc_thm_tac comparison_test_thm);
a(∂_tac ¨xÆ THEN ∂_tac¨Ã m'∑ ÓØ ((m' + m) + 1) * b ^ (m' + m)Æ );
a(rewrite_tac[]);
a(once_rewrite_tac[Ø_abs_times_thm] THEN rewrite_tac[Ø_abs_abs_thm]);
a(rewrite_tac[Ø_abs_times_thm, Ø_times_assoc_thm] THEN REPEAT strip_tac);
a(bc_thm_tac Ø_º_times_mono_thm THEN rewrite_tac[ÓØ_º_thm]);
a(lemma_tac ¨ÓØ 0 º b^(m'+m)Æ
		THEN1 (rewrite_tac[Ø_º_def] THEN
			ALL_FC_T rewrite_tac[Ø_Ó_exp_less_mono_thm]));
a(LEMMA_T ¨Abs (b^(m'+m)) = b^(m'+m)Æ rewrite_thm_tac THEN1 asm_rewrite_tac[Ø_abs_def]);
a(bc_thm_tac Ø_º_trans_thm THEN ∂_tac¨ÓØ 1 * b ^ (m' + m)Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(pure_once_rewrite_tac[Ø_times_comm_thm]);
a(bc_thm_tac Ø_º_times_mono_thm THEN REPEAT strip_tac);
a(rewrite_tac[Ø_º_def] THEN ≤_left_tac);
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
val €power_series_deriv_lemma2› = save_pop_thm "power_series_deriv_lemma2";
=TEX
The identity for scaling the argument of a power series by a constant factor:
%%%%
%%%%
=SML
set_goal([], ¨µc s y∑
	PowerSeries s m (c * y) =PowerSeries (Ã m∑ s m * c ^ m)  m y
Æ);
a(rewrite_tac[power_series_series_thm, Ø_Ó_exp_times_thm, Ø_times_assoc_thm]);
val €power_series_scale_arg_thm› = save_pop_thm "power_series_scale_arg_thm";
=TEX
The identity for scaling the coefficients of a power series by a constant factor:
%%%%
%%%%
=SML
set_goal([], ¨µc s y∑
	PowerSeries (Ãm∑c * s m) m y =c * PowerSeries s  m y
Æ);
a(rewrite_tac[power_series_series_thm, Ø_Ó_exp_times_thm, Ø_times_assoc_thm]
	THEN REPEAT strip_tac);
a(pure_rewrite_tac[prove_rule[]¨ (Ã m∑ c * s m * y ^ m) =  (Ã m∑ c * (Ãm∑ s m * y ^ m) m)Æ]);
a(pure_rewrite_tac[const_times_series_thm] THEN rewrite_tac[]);
val €power_series_scale_coeffs_thm› = save_pop_thm "power_series_scale_coeffs_thm";
=TEX
The theorem on the convergence of the derivatives of a power series:

%%%%
%%%%
=SML
set_goal([], ¨
	µs B C b∑
	ÓØ 0 < b ± b < B
±	(Ãm∑ PowerSeries (Ãm∑Abs(s m)) m B) ->  C
¥	∂D∑ (Ãm∑ PowerSeries (Ãm∑Abs((ÓØ (m+1))*s(m+1))) m b) -> D
Æ);
a(REPEAT strip_tac);
a(swap_nth_asm_concl_tac 1);
a(pure_once_rewrite_tac[prove_rule[]¨B = B * ÓØ 1Æ]);
a(pure_rewrite_tac[power_series_scale_arg_thm] THEN rewrite_tac[]);
a(swap_nth_asm_concl_tac 1 THEN REPEAT strip_tac THEN rewrite_tac[]);
a(lemma_tac ¨ÓØ 0 < BÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac ¨∂c∑ B õ-õ1 * B = ÓØ 1 ± ÓØ 0 < c ± c < ÓØ 1 ± b = B * cÆ);
(* *** Goal "1" *** *)
a(∂_tac¨B õ-õ1 * bÆ);
a(all_fc_tac[Ø_0_less_0_less_recip_thm]);
a(ALL_FC_T rewrite_tac [Ø_0_less_0_less_times_thm]);
a(lemma_tac ¨≥b = ÓØ 0 ± ≥ B õ-õ1 = ÓØ 0 ± ≥B = ÓØ 0Æ THEN1
	PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(rewrite_tac[Ø_times_assoc_thm1] THEN ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(ALL_FC_T1 fc_§_canon once_rewrite_tac[µ_elim¨BÆ Ø_times_mono_§_thm]);
a(rewrite_tac[Ø_times_assoc_thm1] THEN ALL_FC_T asm_rewrite_tac[Ø_recip_clauses]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(swap_nth_asm_concl_tac 5);
a(lemma_tac ¨Abs B = BÆ THEN1 asm_rewrite_tac[Ø_abs_def, Ø_º_def]);
a(lemma_tac ¨µm∑Abs(B ^ m) = B ^ mÆ THEN1
	(strip_tac THEN induction_tac¨m:ÓÆ THEN
		asm_rewrite_tac[Ø_Ó_exp_def, Ø_abs_times_thm]));
a(LEMMA_T ¨µm∑Abs(s m) * B ^ m = Abs(s m * B ^ m)Æ rewrite_thm_tac
	THEN1 asm_rewrite_tac[Ø_abs_times_thm]);
a(pure_once_rewrite_tac[prove_rule[]¨µm∑ s m * B ^ m = (Ãm∑ s m * B ^ m) mÆ]);
a(swap_nth_asm_concl_tac 3 THEN REPEAT strip_tac);
a(all_fc_tac[power_series_deriv_lemma2]);
a(∂_tac¨B õ-õ1 * DÆ THEN rewrite_tac[power_series_scale_arg_thm]);
a(swap_nth_asm_concl_tac 1 THEN
	asm_rewrite_tac[Ø_Ó_exp_def, Ø_times_assoc_thm, Ø_abs_times_thm]);
a(once_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b c d:Ø∑ a * b * c * d = c* a * b * dÆ ]);
a(pure_once_rewrite_tac[ prove_rule[]¨µm∑
	ÓØ (m + 1) * Abs(s (m + 1)) * B ^ m = (Ãm∑ ÓØ (m + 1) * Abs(s (m + 1)) * B ^ m) m
Æ]);
a(pure_once_rewrite_tac[power_series_scale_coeffs_thm]);
a(swap_nth_asm_concl_tac 1);
a(LEMMA_T ¨µm s∑PowerSeries s m c = (B õ-õ1 * B) * PowerSeries s m cÆ once_rewrite_thm_tac
	THEN1 asm_rewrite_tac[]);
a(rewrite_tac[Ø_times_assoc_thm, Ø_abs_times_thm]);
a(conv_tac (LEFT_C (Ã_un_¬_rands_conv)));
a(bc_thm_tac times_lim_seq_thm THEN asm_rewrite_tac[const_lim_seq_thm]);
val €power_series_deriv_lemma3› = save_pop_thm "power_series_deriv_lemma3";
=TEX
Uniform convergence of power series:
%%%%
%%%%
=SML
set_goal([], ¨
	µs B C b∑
	ÓØ 0 < B ± ÓØ 0 < b ± b < B
±	(Ãm∑ PowerSeries (Ãm∑Abs(s m)) m B) ->  C
¥	∂df∑ (PowerSeries (Ãm∑(ÓØ (m+1))*s(m+1)) ---> df) (OpenInterval (~b) b)
Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨∂B1∑ ÓØ 0 < B1 ± b < B1 ± B1 <  BÆ THEN1
	(∂_tac¨(1/2)*(B + b) Æ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(DROP_NTH_ASM_T 5 discard_tac THEN all_fc_tac[power_series_deriv_lemma3]);
a(POP_ASM_T ante_tac);
a(pure_once_rewrite_tac[ prove_rule[]¨
	(Ã m∑ Abs(ÓØ (m + 1) * s (m + 1))) =(Ã m∑ Abs((Ãm∑ ÓØ (m + 1) * s (m + 1))m))
Æ] THEN strip_tac);
a(DROP_NTH_ASM_T 5 discard_tac THEN all_fc_tac[power_series_convergence_thm]);
a(∂_tac¨fÆ THEN REPEAT strip_tac);
val €power_series_deriv_convergence_thm› = save_pop_thm "power_series_deriv_convergence_thm";
=TEX
The main theorem on power series: if a power series is absolutely convergent for
some positive value $B$ of its argument, then for any positive
$b < B$, it is uniformly convergent to a limit $f$ on any open interval $(-b, b)$
and $f$ is differential on that open interval with derivative given by the (uniformly
convergent) limit of the derivatives of the partial sums of the series:
%%%%
%%%%
=SML
set_goal([], ¨
	µs B C b∑
	ÓØ 0 < b ± b < B
±	(Ãm∑ PowerSeries (Ãm∑Abs(s m)) m B) ->  C
¥	∂f df∑
	(PowerSeries s ---> f) (OpenInterval (~b) b)
±	(PowerSeries (Ãm∑(ÓØ (m+1))*s(m+1)) ---> df) (OpenInterval (~b) b)
±	(µy∑ y ç OpenInterval (~b) b ¥ (f HasDeriv df y) y)
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < BÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(all_fc_tac[power_series_convergence_thm, power_series_deriv_convergence_thm]);
a(∂_tac¨fÆ THEN ∂_tac¨dfÆ THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 ç OpenInterval (~b) bÆ THEN1
	(rewrite_tac[open_interval_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨∂g∑ (PowerSeries s ---> g) (OpenInterval (~b) b) ±
	(µy∑ y ç OpenInterval (~b) b ¥ (g HasDeriv df y) y)Æ);
(* *** Goal "1" *** *)
a(once_rewrite_tac[µ_elim¨1Æ unif_lim_seq_shift_thm]);
a(bc_thm_tac unif_lim_seq_deriv_thm);
a(∂_tac¨f(ÓØ 0)Æ THEN ∂_tac¨ÓØ 0Æ THEN ∂_tac¨PowerSeries (Ã m∑ ÓØ (m + 1) * s (m + 1))Æ);
a(REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(rewrite_tac[power_series_deriv_coeffs_thm]);
(* *** Goal "1.2" *** *)
a(bc_thm_tac unif_lim_seq_pointwise_lim_seq_thm);
a(∂_tac¨OpenInterval (~b) bÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (ante_tac o once_rewrite_rule[µ_elim¨1Æ unif_lim_seq_shift_thm]));
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(bc_thm_tac deriv_local_thm);
a(∂_tac¨gÆ THEN ∂_tac¨bÆ THEN ∂_tac¨~bÆ THEN rewrite_tac[
	prove_rule[open_interval_def] ¨µA B Y∑A < Y ± Y <  B § Y ç OpenInterval A  BÆ]);
a(GET_NTH_ASM_T 4 (rewrite_thm_tac o rewrite_rule[open_interval_def]));
a(LIST_GET_NTH_ASM_T [1] (ALL_FC_T rewrite_tac));
a(REPEAT strip_tac THEN bc_thm_tac unif_lim_seq_unique_thm);
a(∂_tac¨OpenInterval (~b) bÆ THEN ∂_tac¨PowerSeries sÆ THEN asm_rewrite_tac[]);
val €power_series_main_thm› = save_pop_thm "power_series_main_thm";
=TEX
The main theorem has the following useful consequences for power series that
are convergent for all positive values of their argument. Thefirst consequence
gives information about uniform convergence:
%%%%
%%%%
=SML
set_goal([], ¨
	µs b∑
	ÓØ 0 <  b
±	(µx∑ ÓØ 0 < x ¥ ∂c∑ (Ãm∑ PowerSeries (Ãm∑Abs(s m)) m x) ->  c)
¥	∂f df∑
	(PowerSeries s ---> f) (OpenInterval (~b) b)
±	(PowerSeries (Ãm∑(ÓØ (m+1))*s(m+1)) ---> df) (OpenInterval (~b) b)
±	(µy∑ y ç OpenInterval (~b) b ¥ (f HasDeriv df y) y)
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂B∑b < B ±ÓØ 0 < BÆ THEN1
	(∂_tac¨b + bÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(DROP_NTH_ASM_T 3 (strip_asm_tac o µ_elim¨BÆ));
a(all_fc_tac[power_series_main_thm]);
a(∂_tac¨fÆ THEN ∂_tac¨dfÆ THEN asm_rewrite_tac[]);
val €power_series_main_thm1› = save_pop_thm "power_series_main_thm1";
=TEX
The second consequence of the main theorem just gives information about pointwise convergence.
It is just what is wanted to justify definitions of functions by differential equation like
that of the exponential function.
%%%%
%%%%
=SML
set_goal([], ¨
	µs∑
	(µx∑ ÓØ 0 < x ¥ ∂c∑ (Ãm∑ PowerSeries (Ãm∑Abs(s m)) m x) ->  c)
¥	∂f df∑
	(µx∑ (Ãm∑PowerSeries s m x) ->  f x)
±	(µx∑ (Ãm∑PowerSeries (Ãm∑(ÓØ (m+1))*s(m+1)) m x) ->  df x) 
±	(µx∑ (f HasDeriv df x) x)
±	f (ÓØ 0) = s 0
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µz∑∂b∑ÓØ 0 < b ± z ç OpenInterval (~b) bÆ THEN1
	(strip_tac THEN ∂_tac¨Abs z + ÓØ 1Æ THEN cases_tac¨ÓØ 0 º zÆ THEN
		asm_rewrite_tac[Ø_abs_def, open_interval_def] THEN
			PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨(∂f∑µy∑ (Ãm∑ PowerSeries s m y) -> f y)
±	(∂df∑ µy∑ (Ãm∑PowerSeries (Ãm∑(ÓØ (m+1))*s(m+1)) m y) ->  df y) 
Æ THEN1 (REPEAT strip_tac THEN prove_∂_tac THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 1 ¨y'Æ  THEN all_asm_fc_tac[power_series_main_thm1]);
a(∂_tac¨f y'Æ );
a(all_fc_tac[ unif_lim_seq_pointwise_lim_seq_thm]);
(* *** Goal "2" *** *)
a(spec_nth_asm_tac 1 ¨y'Æ  THEN all_asm_fc_tac[power_series_main_thm1]);
a(∂_tac¨df y'Æ );
a(all_fc_tac[ unif_lim_seq_pointwise_lim_seq_thm]);
(* *** Goal "3" *** *)
a(∂_tac¨fÆ THEN ∂_tac¨dfÆ THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3.3" *** *)
a(spec_nth_asm_tac 3  ¨xÆ  THEN all_asm_fc_tac[power_series_main_thm1]);
a(bc_thm_tac deriv_local_thm);
a(∂_tac¨f'Æ THEN ∂_tac¨bÆ THEN ∂_tac¨~bÆ THEN rewrite_tac[
	prove_rule[open_interval_def] ¨µA B Y∑A < Y ± Y <  B § Y ç OpenInterval A  BÆ]);
a(GET_NTH_ASM_T 5 (rewrite_thm_tac o rewrite_rule[open_interval_def]));
a(REPEAT strip_tac);
(* *** Goal "3.3.1" *** *)
a(conv_tac eq_sym_conv THEN bc_thm_tac unif_lim_seq_pointwise_unique_thm);
a(∂_tac¨OpenInterval(~b) bÆ THEN ∂_tac¨PowerSeries sÆ THEN asm_rewrite_tac[]);
(* *** Goal "3.3.2" *** *)
a(LIST_DROP_NTH_ASM_T [2] all_fc_tac);
a(LEMMA_T ¨df x = df' xÆ asm_rewrite_thm_tac);
a(conv_tac eq_sym_conv THEN bc_thm_tac unif_lim_seq_pointwise_unique_thm);
a(∂_tac¨OpenInterval(~b) bÆ THEN
	∂_tac¨PowerSeries  (Ã m∑ ÓØ (m + 1) * s (m + 1))Æ THEN asm_rewrite_tac[]);
(* *** Goal "3.4" *** *)
a(POP_ASM_T discard_tac THEN POP_ASM_T (strip_asm_tac o µ_elim¨ÓØ 0Æ));
a(strip_asm_tac (µ_elim¨sÆ power_series_limit_0_thm));
a(all_fc_tac[lim_seq_unique_thm]);
val €power_series_main_thm2› = save_pop_thm "power_series_main_thm2";
=TEX
%%%%
%%%%
%%%%
%%%%
\subsection{Some Special Functions}
=TEX
We begin our investigation of the exponential function by proving a (very) few elementary
properties of the factorial function. 
All we need to know really is that it is always positive and that the ratio $m!/(m+1)!$
is $1/(m+1$.The following lemma gives a weak lower bound on the growth of the
factorial function and shows that is always positive.
%%%%
%%%%
=SML
set_goal([], ¨µm∑ ÓØ 1 º m! ± ÓØ m º m!Æ);
a(REPEAT µ_tac THEN induction_tac¨m:ÓÆ THEN asm_rewrite_tac[factorial_def]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ø_º_trans_thm THEN ∂_tac ¨m!Æ THEN REPEAT strip_tac);
a(conv_tac(LEFT_C(pure_once_rewrite_conv [prove_rule[]¨m! = ÓØ 1 * m!Æ])));
a(pure_once_rewrite_tac[Ø_times_comm_thm]);
a(bc_thm_tac Ø_º_times_mono_thm);
a(REPEAT strip_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(rewrite_tac[Ø_º_def, ÓØ_less_thm, ÓØ_one_one_thm]);
a(PC_T1 "lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(conv_tac(LEFT_C(pure_once_rewrite_conv [prove_rule[]¨µx∑ x = x * ÓØ 1Æ])));
a(bc_thm_tac Ø_º_times_mono_thm THEN REPEAT strip_tac);
a(rewrite_tac[Ø_º_def, ÓØ_less_thm, ÓØ_one_one_thm]);
val €factorial_linear_estimate_thm› = save_pop_thm "factorial_linear_estimate_thm";
=TEX

The next lemma says explicitly that factorials are always positive:
%%%%
%%%%
=SML
set_goal([], ¨µm∑ ÓØ 0 < m! Æ);
a(REPEAT strip_tac THEN bc_thm_tac Ø_less_º_trans_thm
	THEN ∂_tac¨ÓØ 1Æ THEN rewrite_tac [factorial_linear_estimate_thm]
	THEN REPEAT strip_tac);
val €factorial_0_less_thm› = save_pop_thm "factorial_0_less_thm";
=TEX
Finally the following lemma is the one that will show that the exponential function
is its own derivative:
%%%%
%%%%
=SML
set_goal([], ¨µm∑ ÓØ (m + 1) * (m + 1) ! õ-õ1 = m! õ-õ1Æ);
a(REPEAT strip_tac THEN rewrite_tac[factorial_def]);
a(strip_asm_tac (µ_elim¨mÆ factorial_0_less_thm));
a(lemma_tac¨≥ ÓØ (m+1) = ÓØ 0Æ THEN1 rewrite_tac[ÓØ_one_one_thm]);
a(ALL_FC_T (MAP_EVERY (strip_asm_tac o conv_rule(ONCE_MAP_C eq_sym_conv)))
	[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b:Ø∑a < b ¥ ≥a = bÆ]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(rewrite_tac[Ø_times_assoc_thm1]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
val €exp_deriv_coeffs_thm› = save_pop_thm "exp_deriv_coeffs_thm";
=TEX
We can now show using the ratio test and some calculations that the usual series
for the exponential converges for all positive arguments:
%%%%
%%%%
=SML
set_goal([], ¨µx∑
	ÓØ 0 < x
¥	∂c∑ (Ãm∑ PowerSeries (Ãm∑ Abs(m ! õ-õ1)) m x) -> c
Æ);
a(rewrite_tac [power_series_series_thm] THEN REPEAT strip_tac);
a(conv_tac(BINDER_C (rewrite_conv[»_axiom])));
a(bc_thm_tac ratio_test_thm);
a(strip_asm_tac factorial_0_less_thm);
a(lemma_tac¨µm∑ÓØ 0 < m ! õ-õ1 Æ THEN1
	(strip_tac THEN bc_thm_tac Ø_0_less_0_less_recip_thm THEN rewrite_tac[factorial_0_less_thm]));
a(lemma_tac¨µm∑Abs(m ! õ-õ1) = m ! õ-õ1 Æ THEN1
	(asm_rewrite_tac[Ø_abs_def, Ø_º_def]));
a(lemma_tac¨µm∑ÓØ 0 < x ^ m Æ THEN1
	(strip_tac THEN bc_thm_tac Ø_Ó_exp_0_less_thm THEN REPEAT strip_tac));
a(lemma_tac¨µm∑ÓØ 0 < Abs(m ! õ-õ1) * x ^ m Æ THEN1
	(strip_tac THEN bc_thm_tac Ø_0_less_0_less_times_thm THEN asm_rewrite_tac[]));
a(∂_tac¨ÓØ 0Æ THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(POP_ASM_T (ante_tac o µ_elim¨mÆ) THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith"  prove_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a(LEMMA_T¨µm y∑y/ (m ! õ-õ1 * x ^ m) = y *  (m ! õ-õ1 * x ^ m)õ-õ1Æ  rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨mÆ);
a(lemma_tac ¨≥ m ! õ-õ1 * x ^ m = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(rename_tac[(¨xÆ, "xx")] THEN ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[Ø_abs_times_thm]);
a(LEMMA_T¨µm∑(m ! õ-õ1 * x ^ m) õ-õ1 = m ! * (x ^ m) õ-õ1Æ  rewrite_thm_tac);
(* *** Goal "2.2.1" *** *)
a(REPEAT strip_tac);
a(spec_nth_asm_tac 5 ¨mÆ);
a(spec_nth_asm_tac 5 ¨mÆ);
a(spec_nth_asm_tac 4 ¨mÆ);
a(ALL_FC_T (MAP_EVERY (strip_asm_tac o conv_rule(ONCE_MAP_C eq_sym_conv)))
	[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b:Ø∑a < b ¥ ≥a = bÆ]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
(* *** Goal "2.2.2" *** *)
a(asm_rewrite_tac[Ø_abs_times_thm, Ø_abs_Ø_Ó_exp_thm]);
a(lemma_tac¨µm∑ÓØ 0 < (x ^ m) õ-õ1Æ  THEN1
	(strip_tac THEN bc_thm_tac Ø_0_less_0_less_recip_thm THEN asm_rewrite_tac[]));
a(asm_rewrite_tac[Ø_abs_def, Ø_º_def, factorial_0_less_thm]);
a(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b c d:Ø∑(a * b) * c * d = a * c * b * dÆ]);
a(rewrite_tac[Ø_Ó_exp_def, factorial_def]);
a(LEMMA_T¨µm∑(ÓØ(m+1) * m !) õ-õ1 =ÓØ (m+1)  õ-õ1 * m! õ-õ1Æ  rewrite_thm_tac);
(* *** Goal "2.2.2.1" *** *)
a(REPEAT strip_tac);
a(lemma_tac¨≥ÓØ(m+1) = ÓØ 0Æ THEN1 rewrite_tac[ÓØ_one_one_thm]);
a(spec_nth_asm_tac 7 ¨mÆ);
a(ALL_FC_T (MAP_EVERY (strip_asm_tac o conv_rule(ONCE_MAP_C eq_sym_conv)))
	[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b:Ø∑a < b ¥ ≥a = bÆ]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
(* *** Goal "2.2.2.2" *** *)
a(rewrite_tac[Ø_times_assoc_thm]);
a(LEMMA_T¨µm∑x ^ m * (x ^ m) õ-õ1 = ÓØ 1Æ  rewrite_thm_tac);
(* *** Goal "2.2.2.2.1" *** *)
a(REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨mÆ);
a(ALL_FC_T (MAP_EVERY (strip_asm_tac o conv_rule(ONCE_MAP_C eq_sym_conv)))
	[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b:Ø∑a < b ¥ ≥a = bÆ]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
(* *** Goal "2.2.2.2.2" *** *)
a(once_rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b c d:Ø∑a * b * c * d = a * d * b * cÆ]);
a(LEMMA_T¨µm∑m ! õ-õ1 * m ! = ÓØ 1Æ  rewrite_thm_tac);
(* *** Goal "2.2.2.2.2.1" *** *)
a(REPEAT strip_tac);
a(spec_nth_asm_tac 6 ¨mÆ);
a(ALL_FC_T (MAP_EVERY (strip_asm_tac o conv_rule(ONCE_MAP_C eq_sym_conv)))
	[pc_rule1"Ø_lin_arith" prove_rule[]¨µa b:Ø∑a < b ¥ ≥a = bÆ]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
(* *** Goal "2.2.2.2.2.2" *** *)
a(conv_tac(LEFT_C Ã_un_¬_rands_conv));
a(pure_once_rewrite_tac[prove_rule[]¨ÓØ 0 = ÓØ 0 * xÆ]);
a(bc_thm_tac times_lim_seq_thm THEN rewrite_tac[const_lim_seq_thm]);
a(rewrite_tac[rewrite_rule[](µ_elim¨ÓØ 0Æ lim_seq_recip_Ó_thm)]);
val €exp_series_convergence_thm› = save_pop_thm "exp_series_convergence_thm";
=TEX
The main theorem justifying the consistency of the definition by the differential equation
of the exponential function:
%%%%
%%%%

=SML
set_goal([], ¨
	∂f∑
	(µy∑ (f HasDeriv f y) y)
±	f (ÓØ 0) = ÓØ 1
Æ);
a(ante_tac exp_series_convergence_thm);
a(pure_once_rewrite_tac[prove_rule[]¨µm∑ m ! õ-õ1 = (Ãm∑ m ! õ-õ1) mÆ]);
a(strip_tac THEN all_fc_tac[power_series_main_thm2]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[factorial_def]));
a(DROP_NTH_ASM_T 3 ante_tac);
a(rewrite_tac[exp_deriv_coeffs_thm] THEN REPEAT strip_tac);
a(∂_tac¨fÆ  THEN REPEAT strip_tac);
a(LEMMA_T¨f y = df yÆ asm_rewrite_thm_tac);
a(bc_thm_tac lim_seq_unique_thm);
a(∂_tac¨ (Ã m∑ PowerSeries (Ã m∑ m ! õ-õ1) m y)Æ THEN asm_rewrite_tac[]);
val €exp_consistency_thm› = save_pop_thm "exp_consistency_thm";
=TEX

Et, voil\'a!
%%%%
%%%%
=TEX
=SML
push_consistency_goal¨ExpÆ;
a(strip_asm_tac exp_consistency_thm);
a(∂_tac ¨fÆ THEN asm_rewrite_tac[]);
val _ = save_consistency_thm ¨ExpÆ (pop_thm());
val €exp_def› = get_spec¨ExpÆ;
=TEX

We now develop some basic properties of the exponential function.
A consequence of the differential equation is the following fact, which
says that if a function $f$ is its own derivative on some open interval then
it is equal to a constant multiple of the exponential function on that interval.
%%%%
%%%%

=SML
set_goal([], ¨
	µf a b t∑
	(µx∑ x ç OpenInterval a b ¥ ≥f x = ÓØ 0)
±	(µx∑ x ç OpenInterval a b ¥ (f HasDeriv f x) x)
±	t ç OpenInterval a b
¥	(µx∑ x ç OpenInterval a b ¥ Exp x = Exp t * f t õ-õ1 * f x)
Æ);
a(rewrite_tac[open_interval_def] THEN REPEAT strip_tac);
a(lemma_tac¨µy∑ a < y ± y < b ¥ ((Ãy∑Exp y * f y õ-õ1) HasDeriv ÓØ 0) yÆ);
(* *** Goal "1" *** *)
a(LIST_DROP_NTH_ASM_T [1, 2, 3, 4] discard_tac);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o µ_elim¨yÆ));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o µ_elim¨yÆ));
a(all_fc_tac[ recip_comp_deriv_thm]);
a(LIST_DROP_NTH_ASM_T [3] discard_tac);
a(strip_asm_tac (µ_elim¨yÆ (±_right_elim exp_def)));
a(LEMMA_T¨
	((Ã y∑ Exp y * f y õ-õ1) HasDeriv
		Exp y * f y õ-õ1 + Exp y * ~ (f y õ-õ1 * f y õ-õ1) * f y)  yÆ  ante_tac THEN1
	(ALL_FC_T (MAP_EVERY ante_tac)[times_deriv_thm] THEN rewrite_tac[] THEN taut_tac));
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b c d:Ø∑a * ~(b * c) * d = ~(a * b * c * d)Æ]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T [2, 3] (MAP_EVERY ante_tac));
a(ALL_FC_T (MAP_EVERY (strip_asm_tac o rewrite_rule[])) [deriv_0_thm]);
a(REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac);
a(all_var_elim_asm_tac1);
a(asm_rewrite_tac[Ø_times_assoc_thm1]);
a(rewrite_tac[Ø_times_assoc_thm]);
a(all_asm_fc_tac[] THEN ALL_FC_T rewrite_tac[Ø_recip_clauses]);
val €exp_unique_thm› = save_pop_thm "exp_unique_thm";
=TEX

The exponential function is continuous everywhere
%%%%
%%%%

=SML
set_goal([], ¨ µx∑ Exp CtsAt xÆ);
a(REPEAT strip_tac THEN bc_thm_tac has_deriv_cts_thm);
a(∂_tac ¨Exp xÆ THEN rewrite_tac[exp_def]);
val €exp_cts_thm› = save_pop_thm "exp_cts_thm";
=TEX

The exponential function is positive in some neighbourhood of zero:
%%%%
%%%%

=SML
set_goal([], ¨ ∂b∑ ÓØ 0 < b ± µx∑x ç OpenInterval (~b) b ¥ ÓØ 0 < Exp xÆ);
a(rewrite_tac[open_interval_def]);
a(ante_tac(µ_elim ¨ÓØ 0Æ exp_cts_thm) THEN
	rewrite_tac[cts_at_def, exp_def]);
a(STRIP_T (strip_asm_tac o µ_elim¨ÓØ 1Æ));
a(∂_tac¨dÆ THEN REPEAT strip_tac);
a(lemma_tac¨Abs x < dÆ THEN1
	(cases_tac¨ÓØ 0 º xÆ THEN asm_rewrite_tac[Ø_abs_def]
		THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN
	cases_tac¨ÓØ 0 º Exp x + ~(ÓØ 1)Æ THEN asm_rewrite_tac[Ø_abs_def]
		THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €exp_0_less_lemma› = pop_thm();
=TEX

The exponential function maps addition to multiplication if one operand
lies in some neighbourhood of zero. 
%%%%
%%%%

=SML
set_goal([], ¨ ∂b∑ ÓØ 0 < b ± µx y∑x ç OpenInterval (~b) b ¥ Exp (x + y) = Exp x * Exp yÆ);
a(strip_asm_tac exp_0_less_lemma);
a(∂_tac¨bÆ THEN asm_rewrite_tac[]);
a(REPEAT µ_tac THEN intro_µ_tac(¨x:ØÆ, ¨x:ØÆ));
a(lemma_tac¨µx∑ ((Ãx∑ Exp(x + y)) HasDeriv (Ãx∑ Exp(x + y)) x) xÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[] THEN REPEAT strip_tac);
a(conv_tac(RATOR_C(LEFT_C(Ã_un_¬_rands_conv))));
a(pure_once_rewrite_tac[prove_rule[]¨Exp(x + y) = Exp(x + y) * ÓØ 1Æ]);
a(bc_thm_tac comp_deriv_thm);
a(rewrite_tac[exp_def]);
a(conv_tac(RATOR_C(LEFT_C(Ã_un_¬_rands_conv))));
a(pure_once_rewrite_tac[prove_rule[]¨ÓØ 1 =ÓØ 1 + ÓØ 0Æ]);
a(bc_thm_tac plus_deriv_thm);
a(rewrite_tac[id_deriv_thm, const_deriv_thm]);
(* *** Goal "2" *** *)
a(lemma_tac¨µx∑ x ç OpenInterval (~b)  b ¥ ≥ Exp x = ÓØ 0Æ
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]
		THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(lemma_tac¨µx∑ x ç OpenInterval (~b)  b ¥ ((Ãx∑Exp (x + y) * Exp x õ-õ1) HasDeriv ÓØ 0) xÆ);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o µ_elim¨xÆ));
a(strip_asm_tac(µ_elim¨xÆ(±_right_elim exp_def)));
a(all_fc_tac[ recip_comp_deriv_thm]);
a(LIST_DROP_NTH_ASM_T [2] discard_tac);
a(DROP_NTH_ASM_T 4 (strip_asm_tac o list_µ_elim[¨xÆ]));
a(LEMMA_T¨
	((Ã y'∑ (Ã x∑ Exp (x + y)) y' * (Ã x∑ Exp x õ-õ1) y')
	HasDeriv (Ã x∑ Exp (x + y)) x * (Ã x∑ Exp x õ-õ1) x
		+ (Ã x∑ Exp (x + y)) x * ~ (Exp x õ-õ1 * Exp x õ-õ1) * Exp x)xÆ 
		ante_tac THEN1
	(ALL_FC_T (MAP_EVERY ante_tac)[times_deriv_thm] THEN rewrite_tac[] THEN taut_tac));
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b c d:Ø∑a * ~(b * c) * d = ~(a * b * c * d)Æ]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
(* *** Goal "2" *** *)
a(all_fc_tac[
	rewrite_rule[prove_rule[open_interval_def]
		¨µA B Y∑A < Y ± Y <  B § Y ç OpenInterval A  BÆ]
			deriv_0_thm]);
a(lemma_tac¨ÓØ 0 ç OpenInterval (~b)b Æ THEN1 
	(rewrite_tac[open_interval_def] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [3, 5] (ALL_FC_T (MAP_EVERY ante_tac)));
a(rewrite_tac[exp_def] THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(once_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µa b c:Ø∑ a * b * c = b * a * cÆ]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
val €exp_plus_lemma› = pop_thm();
=TEX

The exponential function is positive and maps addition
to multiplication for non-negative arguments:
%%%%
%%%%

=SML
set_goal([], ¨µx∑ ÓØ 0 º x ¥ ÓØ 0 <  Exp x ± µy∑Exp (x + y) = Exp x * Exp yÆ);
a(lemma_tac¨∂d∑ÓØ 0 < d
±	µt∑ ÓØ 0 º t ± t º d ¥ ÓØ 0 < Exp t ± µz∑ Exp (t + z) =  Exp t * Exp zÆ);
(* *** Goal "1" *** *)
a(strip_asm_tac exp_0_less_lemma);
a(strip_asm_tac exp_plus_lemma);
a(strip_asm_tac (list_µ_elim[¨bÆ, ¨b'Æ]Ø_bound_below_2_thm));
a(∂_tac¨dÆ THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(DROP_NTH_ASM_T 8 bc_thm_tac THEN rewrite_tac[open_interval_def]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 6 bc_thm_tac THEN rewrite_tac[open_interval_def]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨µq x∑ Exp(ÓØ q * d + x) = Exp(ÓØ q * d) * Exp xÆ );
(* *** Goal "2.1" *** *)
a(µ_tac THEN induction_tac¨q:ÓÆ THEN REPEAT strip_tac THEN1 rewrite_tac[exp_def]);
a(rewrite_tac[ÓØ_plus_homomorphism_thm, Ø_times_plus_distrib_thm]);
a(rewrite_tac[µ_elim¨ÓØ q * dÆ Ø_plus_comm_thm]);
a(lemma_tac¨ÓØ 0 º dÆ THEN1 asm_rewrite_tac[Ø_º_def]);
a(spec_nth_asm_tac 3 ¨dÆ);
a(asm_rewrite_tac[Ø_plus_assoc_thm, Ø_times_assoc_thm]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨µq∑ ÓØ 0 < Exp(ÓØ q * d)Æ );
a(µ_tac THEN induction_tac¨q:ÓÆ THEN REPEAT strip_tac THEN1 rewrite_tac[exp_def]);
a(asm_rewrite_tac[ÓØ_plus_homomorphism_thm, Ø_times_plus_distrib_thm]);
a(bc_thm_tac Ø_0_less_0_less_times_thm THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 º dÆ THEN1 asm_rewrite_tac[Ø_º_def]);
a(spec_nth_asm_tac 4 ¨dÆ);
(* *** Goal "2.2.2" *** *)
a(µ_tac THEN ¥_tac THEN all_fc_tac[Ø_archimedean_division_thm]);
a(all_var_elim_asm_tac1);
a(lemma_tac¨r º dÆ THEN1 asm_rewrite_tac[Ø_º_def]);
a(LIST_GET_NTH_ASM_T [7] all_fc_tac);
a(rewrite_tac[µ_elim¨ÓØ q * dÆ Ø_plus_comm_thm]);
a(asm_rewrite_tac[Ø_plus_assoc_thm, Ø_times_assoc_thm]);
a(bc_thm_tac Ø_0_less_0_less_times_thm THEN asm_rewrite_tac[]);
val €exp_0_less_plus_lemma› = pop_thm();
=TEX

The exponential function maps negation to reciprocal:
%%%%
%%%%

=SML
set_goal([], ¨µx∑ Exp (~x) = Exp x õ-õ1Æ);
a(lemma_tac ¨µx∑ ÓØ 0 º x ¥ Exp (~x) = Exp x õ-õ1Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN fc_tac [exp_0_less_plus_lemma]);
a(lemma_tac¨≥Exp x = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 3 (ante_tac o µ_elim¨~xÆ));
a(rewrite_tac[exp_def] THEN REPEAT strip_tac);
a(LEMMA_T ¨Exp x õ-õ1 * ÓØ 1 = Exp x õ-õ1 * Exp x * Exp (~ x)Æ ante_tac
	THEN1 (pure_asm_rewrite_tac[] THEN strip_tac));
a(rewrite_tac[Ø_times_assoc_thm1]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 º x ≤ ÓØ 0 º ~xÆ THEN1 PC_T1 "Ø_lin_arith" prove_tac[]
	THEN all_asm_fc_tac[exp_0_less_plus_lemma]);
a(lemma_tac¨≥Exp (~x) = ÓØ 0Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 4 (rewrite_thm_tac o rewrite_rule[]));
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
val €exp_minus_thm› = save_pop_thm "exp_minus_thm";
=TEX

The exponential function is positive everywhere:
%%%%
%%%%

=SML
set_goal([], ¨µx∑  ÓØ 0 < Exp xÆ);
a(REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 º x ≤ ÓØ 0 º ~xÆ THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "1" *** *)
a(all_fc_tac [exp_0_less_plus_lemma]);
(* *** Goal "2" *** *)
a(all_fc_tac [exp_0_less_plus_lemma]);
a(ante_tac (µ_elim¨~xÆ exp_minus_thm));
a(rewrite_tac[] THEN strip_tac THEN asm_rewrite_tac[]);
a(bc_thm_tac Ø_0_less_0_less_recip_thm THEN REPEAT strip_tac);
val €exp_0_less_thm› = save_pop_thm "exp_0_less_thm";
=TEX

The exponential function maps addition to multiplication everywhere:
%%%%
%%%%

=SML
set_goal([], ¨µx y∑  Exp (x + y) = Exp x * Exp yÆ);
a(REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 º x ≤ ÓØ 0 º ~xÆ THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac [exp_0_less_plus_lemma]);
(* *** Goal "2" *** *)
a(fc_tac [exp_0_less_plus_lemma]);
a(DROP_NTH_ASM_T 2 (ante_tac o µ_elim¨~yÆ));
a(LEMMA_T ¨~x + ~y = ~(x + y)Æ pure_rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" prove_tac[]);
a(pure_rewrite_tac[exp_minus_thm]);
a(lemma_tac¨ÓØ 0 < Exp x ± ÓØ 0 < Exp y ± ÓØ 0 < Exp (x + y)Æ
	THEN1 rewrite_tac[exp_0_less_thm]);
 a(lemma_tac¨≥Exp x = ÓØ 0 ± ≥Exp y = ÓØ 0 ± ≥Exp (x + y) = ÓØ  0Æ
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(REPEAT strip_tac);
a(LEMMA_T ¨Exp (x + y) õ-õ1 * Exp y= (Exp x õ-õ1 * Exp y õ-õ1) * Exp yÆ ante_tac
	THEN1 asm_rewrite_tac[]);
a(rewrite_tac[Ø_times_assoc_thm] THEN ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(REPEAT strip_tac);
a(LEMMA_T ¨(Exp (x + y) õ-õ1 * Exp y) * Exp x = Exp x õ-õ1 * Exp xÆ ante_tac
	THEN1 asm_rewrite_tac[]);
a(rewrite_tac[Ø_times_assoc_thm] THEN ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(REPEAT strip_tac);
a(LEMMA_T ¨Exp(x + y) * (Exp (x + y) õ-õ1 * Exp y * Exp x) = Exp (x + y)Æ ante_tac
	THEN1 asm_rewrite_tac[]);
a(rewrite_tac[Ø_times_assoc_thm1] THEN ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(STRIP_T (rewrite_thm_tac o once_rewrite_rule[Ø_times_comm_thm]));
val €exp_plus_thm› = save_pop_thm "exp_plus_thm";
=TEX

The exponential function is monotonic increasing:
%%%%
%%%%

=SML
set_goal([], ¨µx y∑  x < y § Exp x < Exp yÆ);
a(lemma_tac¨µx y∑  x < y ¥ Exp x < Exp yÆ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(bc_thm_tac deriv_0_less_thm);
a(asm_rewrite_tac[exp_cts_thm]);
a(REPEAT strip_tac THEN ∂_tac¨Exp x'Æ THEN rewrite_tac[exp_def, exp_0_less_thm]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN1 all_asm_fc_tac[]);
a(cases_tac¨x = yÆ THEN1 all_var_elim_asm_tac1);
a(contr_tac THEN lemma_tac¨y < xÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]
	THEN all_asm_fc_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €exp_less_mono_thm› = save_pop_thm "exp_less_mono_thm";
=TEX

We show that the definition of the natural logarithm function is consistent:
%%%%
%%%%

=SML
push_consistency_goal ¨LogÆ;
a(lemma_tac¨∂f∑ µx y∑ Exp y = x ¥ f x = yÆ THEN1 prove_∂_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(cases_tac¨µy∑ ≥Exp y = x'Æ THEN1 asm_rewrite_tac[]);
a(∂_tac¨yÆ THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN contr_tac);
a(contr_tac THEN1 lemma_tac¨y < y' ≤ y' < yÆ THEN all_fc_tac[exp_less_mono_thm]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨fÆ THEN REPEAT strip_tac);
a(POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
val _ = save_consistency_thm ¨LogÆ (pop_thm());
val €log_def› = get_spec¨LogÆ;
=TEX

The exponential function is one-to-one:
%%%%
%%%%

=SML
set_goal([], ¨OneOne ExpÆ);
a(rewrite_tac[one_one_def] THEN contr_tac);
a(lemma_tac¨x1 < x2 ≤ x2 < x1Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]
	THEN all_fc_tac[exp_less_mono_thm] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €exp_one_one_thm› = save_pop_thm "exp_one_one_thm";
=TEX

The exponential function maps natural number multiples to powers:
%%%%
%%%%

=SML
set_goal([], ¨µm x∑ Exp (ÓØ m *x) = Exp x ^ mÆ);
a(REPEAT strip_tac THEN induction_tac¨m:ÓÆ THEN
	asm_rewrite_tac[Ø_Ó_exp_def, exp_def, ÓØ_plus_homomorphism_thm,
		Ø_times_plus_distrib_thm, exp_plus_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €exp_Ø_Ó_exp_thm› = save_pop_thm "exp_Ø_Ó_exp_thm";
=TEX

The exponential function maps the real line onto the positive reals:
%%%%
%%%%

=SML
set_goal([], ¨µx∑  ÓØ 0 < x ¥ ∂y∑x = Exp yÆ);
a(REPEAT strip_tac);
a(lemma_tac¨(∂b∑ x < Exp b) ± (∂a∑Exp a < x)Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨∂d∑ ÓØ 1 < Exp dÆ THEN1
	(∂_tac¨ÓØ 2Æ THEN rewrite_tac[eq_sym_rule(±_left_elim exp_def)] THEN
		bc_thm_tac exp_less_mono_thm THEN REPEAT strip_tac));
a(all_fc_tac[Ø_Ó_exp_tends_to_infinity_thm]);
a(POP_ASM_T (strip_asm_tac o µ_elim¨xÆ));
a(∂_tac¨ÓØ m * dÆ THEN asm_rewrite_tac[exp_Ø_Ó_exp_thm]);
(* *** Goal "2" *** *)
a(lemma_tac¨∂d∑ ÓØ 0 < Exp d ± Exp d < ÓØ 1Æ THEN1
	(∂_tac¨~(ÓØ 2)Æ THEN
		rewrite_tac[eq_sym_rule(±_left_elim exp_def), exp_0_less_thm] THEN
			bc_thm_tac exp_less_mono_thm THEN REPEAT strip_tac));
a(all_fc_tac[Ø_Ó_exp_tends_to_0_thm]);
a(∂_tac¨ÓØ m'* dÆ THEN asm_rewrite_tac[exp_Ø_Ó_exp_thm]);
(* *** Goal "3" *** *)
a(lemma_tac¨a < bÆ THEN1 contr_tac);
(* *** Goal "3.1" *** *)
a(lemma_tac ¨Exp a < Exp bÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(cases_tac¨a = bÆ THEN1 all_var_elim_asm_tac1);
a(lemma_tac ¨b < aÆ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(lemma_tac ¨Exp b <  Exp aÆ THEN1 all_fc_tac[exp_less_mono_thm]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2" *** *)
a(ante_tac (list_µ_elim[¨ExpÆ, ¨aÆ, ¨bÆ] intermediate_value_thm));
a(asm_rewrite_tac[exp_cts_thm]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(∂_tac¨x'Æ THEN asm_rewrite_tac[]);
val €exp_0_less_onto_thm› = save_pop_thm "exp_0_less_onto_thm";
=TEX

The exponential function is a left inverse for the natural logarithm function on the
positive reals:
%%%%
%%%%

=SML
set_goal([], ¨µx∑  ÓØ 0 < x ¥ Exp(Log x) = xÆ);
a(REPEAT strip_tac);
a(all_fc_tac[exp_0_less_onto_thm] THEN all_var_elim_asm_tac1);
a(rewrite_tac[log_def]);
val €exp_log_thm› = save_pop_thm "exp_log_thm";
=TEX

The natural logarithm function is strictly monotonic on the positive reals:
%%%%
%%%%

=SML
set_goal([], ¨µx y∑  ÓØ 0 < x ± x < y ¥ Log x < Log yÆ);
a(REPEAT strip_tac);
a(all_fc_tac[Ø_less_trans_thm]);
a(once_rewrite_tac[exp_less_mono_thm]);
a(ALL_FC_T asm_rewrite_tac[exp_log_thm]);
val €log_less_mono_thm› = save_pop_thm "log_less_mono_thm";
=TEX

The natural logarithm function is continuous on the positive reals:
%%%%
%%%%

=SML
set_goal([], ¨µx∑  ÓØ 0 < x ¥  Log CtsAt xÆ);
a(REPEAT strip_tac);
a(bc_thm_tac darboux_cts_mono_thm);
a(lemma_tac ¨∂U L∑ÓØ 0 < L ± L < x ± x < U ± ÓØ 0 < UÆ THEN1
	(∂_tac¨ÓØ 2*xÆ THEN ∂_tac¨(1/2)* xÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(∂_tac¨UÆ THEN ∂_tac¨LÆ THEN rewrite_tac[open_interval_def, closed_interval_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac log_less_mono_thm THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨Exp yÆ THEN rewrite_tac[log_def]);
a(LEMMA_T ¨L = Exp (Log L) ± U = Exp(Log U)Æ once_rewrite_thm_tac THEN1
	ALL_FC_T rewrite_tac [exp_log_thm]);
a(REPEAT strip_tac THEN bc_thm_tac exp_less_mono_thm THEN REPEAT strip_tac);
val €log_cts_thm› = save_pop_thm "log_cts_thm";
=TEX

The natural logarithm function is differential for positive arguments with derivative given by the
reciprocal function.
%%%%
%%%%

=SML
set_goal([], ¨µx∑  ÓØ 0 < x ¥  (Log HasDeriv x õ-õ1) xÆ);
a(REPEAT strip_tac THEN bc_thm_tac inverse_deriv_thm);
a(lemma_tac ¨∂U L∑ÓØ 0 < L ± L < x ± x < U ± ÓØ 0 < U ±≥x = ÓØ 0Æ THEN1
	(∂_tac¨ÓØ 2*xÆ THEN ∂_tac¨(1/2)* xÆ THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(∂_tac¨ExpÆ THEN ∂_tac¨UÆ THEN ∂_tac¨LÆ THEN
	rewrite_tac[open_interval_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[Ø_less_trans_thm] THEN ALL_FC_T rewrite_tac[exp_log_thm]);
(* *** Goal "2" *** *)
a(all_fc_tac[exp_0_less_onto_thm] THEN all_var_elim_asm_tac1 THEN rewrite_tac[exp_def, log_def]);
(* *** Goal "3" *** *)
a(all_fc_tac[log_cts_thm]);
val €log_deriv_thm› = save_pop_thm "log_deriv_thm";
=TEX

The natural logarithm function is a homomorphism from the multiplicative group
of positive real numbers under multiplication to the group of  all reals under addition:
%%%%
%%%%

=SML
set_goal([], ¨
	Log (ÓØ 1) = ÓØ 0
±	(µx∑  ÓØ 0 < x ¥  Log(x õ-õ1) = ~(Log x))
±	(µx y∑  ÓØ 0 < x ± ÓØ 0 < y ¥  Log(x*y) = Log x + Log y)
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[eq_sym_rule (±_left_elim exp_def), log_def]);
(* *** Goal "1" *** *)
a(all_fc_tac[exp_0_less_onto_thm] THEN all_var_elim_asm_tac1);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) exp_minus_thm, log_def]);
(* *** Goal "3" *** *)
a(all_fc_tac[exp_0_less_onto_thm] THEN all_var_elim_asm_tac1);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) exp_plus_thm, log_def]);
val €log_clauses› = save_pop_thm "log_clauses";
=TEX
=TEX
%%%%
%%%%
%%%%
%%%%
=TEX
\subsection{Epilogue}
=TEX
%%%%
%%%%
=SML
output_theory{out_file="analysis.th.doc", theory="-"};
=TEX
\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}
\end{document}
=IGN
