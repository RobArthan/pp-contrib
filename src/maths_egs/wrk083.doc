=IGN
********************************************************************************
wrk083.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
wrk083.doc,v 1.115 2011/02/06 17:42:00 rda Exp
********************************************************************************
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
%\usepackage{amsmath} % breaks the index!
\ftlinepenalty=9999
\usepackage{A4}
\makeindex
\title{Mathematical Case Studies: Tools}
\author{Rob Arthan}
%\makeindex
\author{R.D. Arthan \\ Lemma 1 Ltd. \\ rda@lemma-one.com}
\date{\FormatDate{$Date: 2012/06/05 12:35:44 $%
}}

\def\Func#1{\mathsf{#1}}
\def\I{\Func{I}}
\def\K{\Func{K}}
\def\Uncurry{\Func{Uncurry}}
\def\Frees{\Func{frees}}
\def\Constant{\Func{Constant}}
\def\Unary{\Func{Unary}}
\def\Binary{\Func{Binary}}
\def\Parametrized{\Func{Parametrized}}
\def\To{\rightarrow}

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}

This document describes some tools that are used in the proofs in the {\Product} Mathematical Case Studies.
\end{abstract}
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd \number\year \\
Reference: LEMMA1/HOL/WRK083; issue 1.115%


\end{centering}
\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
\tableofcontents
%\newpage
%\subsection{Document cross references}
\newpage
\subsection*{To Do}
\begin{itemize}

\item
Think through the packaging of the tools
\item
Add more powerful tools.
\end{itemize}


\bibliographystyle{plain}
\bibliography{fmu}

%%%%
%%%%
%%%%
%%%%
\newpage
\section{INTRODUCTION}
Currently the tools describes some utilities primarily for use in the code of the tools themselves and simple support for proving that an expression denotes a morphism in a concrete category finitely generated by certain given morphism constructors and object constructors.
%%%%
%%%%
\section{UTILITIES}
=SML
fun €thm_frees› (thm : THM) : TERM list = (
	frees (list_mk_± (concl thm :: asms thm))
);
=TEX
=SML
new_error_message{id = 999001,
	text = "?0 is not of form ?1"};
new_error_message{id = 999002,
	text = "?0 expects a ?1-element argument list"};
new_error_message{id = 999003,
	text = "hd2 expects a list with at least 2 elements"};
fun €dest_any› (pattern : TERM, fun_name : string) : TERM -> TERM list = (
	let	val (f, args) = strip_app pattern;
		val arity = length args;
		fun strip_and_check tm = (
			let	val (g, args) = strip_app tm;
				val _ = term_match g f;
			in	if	length args = arity
				then	args
				else	fail "" 0 []
			end	handle Fail _ => (
				term_fail fun_name 999001 [tm, pattern]
			)
		);
	in	strip_and_check
	end
);
=TEX
=SML
fun €is_any› (pattern : TERM) : TERM -> bool = (
	let	val dest = dest_any (pattern, "is_any");
	in	fn tm => (dest tm; true) handle Fail _ => false
	end
);
=TEX
=SML
fun €mk_any› (pattern : TERM, fun_name : string) : TERM list -> TERM = (
	let	val (f, args) = strip_app pattern;
		val arity_s = string_of_int (length args);
		val ftys = map type_of args;
		fun match_arg_tys i (aty :: more_atys) (fty :: more_ftys) = (
			let	val i = type_match1 i aty fty;
			in	match_arg_tys i more_atys more_ftys
			end
		) | match_arg_tys i [] [] = (i
		) | match_arg_tys _ _ _ = (
			fail fun_name 999002 [fn () => arity_s]
		);
		fun match_and_apply tms = (
			let	val atys = map type_of tms;
				val i = match_arg_tys [] atys ftys;
				val f' = inst [] i f;
			in	list_mk_app (f', tms)
			end
		);
	in	match_and_apply
	end
);
=SML
fun €hd2› (x :: y :: _ : 'a list) : 'a * 'a = (x, y)
|   hd2 _ = fail "hd2" 999003 [];
=TEX
=SML
=SML
local 
	val old_thy = get_current_theory_name();
	val _ = open_theory"combin";
	val _ = push_pc"basic_hol1";
in
val €mk_o› : TERM * TERM -> TERM = (
	let	val mk = mk_any (¨(t1 : 'b ≠ 'c) o (t2 : 'a ≠ 'b)Æ, "mk_o");
	in	fn (t1, t2) => mk [t1, t2]
	end
);
val €dest_o› : TERM -> TERM * TERM = (
	let	val dest = dest_any (¨(t1 : 'b ≠ 'c) o (t2 : 'a ≠ 'b)Æ, "mk_o");
	in	hd2 o dest
	end
);
val €is_o› : TERM -> bool = is_any ¨(t1 : 'b ≠ 'c) o (t2 : 'a ≠ 'b)Æ;
val _ = open_theory old_thy;
end;
=TEX
\section{PROVING MORPHISMHOOD}
%%%%
%%%%
=TEX
\subsection{Representing $\lambda$-abstractions using first-order combinators}

\subsubsection{The approach: a rewrite system}

We assume given a set of unary operators, binary operators and
parametrized operators (such $x^n$ viewed as an operator on $x$ parametrized by $n$) that are primitive morphisms in some concrete category of interest.
We expect the projections $\pi_i : X_1 \times X_2 \To X_i$ to be included amongst the unary operators.
We also assume give some set of constant elements of selected objects
in the category.

We want to convert a $\lambda$-abstraction whose body is a first-order formula built using the given operators, constants and the pairing operator $\_, \_)$ into an equivalent function expressed using the combinators of a category with binary products.
We do this using the following rewrite system, where $V$ denotes a {\em variable structure}, i.e., $V$ is a pattern formed from variables using pairing (such that each free variable of $V$ appears exactly once in $V$).

\[
\begin{array}{rcl@{\quad\quad}l}
(\lambda V \bullet x) &\leadsto& \pi^V_x
	& \mbox{if $x \in \Frees(V)$} \\
(\lambda V \bullet y) &\leadsto& \K\,y
	& \mbox{if $y \not\in \Frees(V)$} \\
(\lambda V \bullet c) &\leadsto& \K\,c
	& \mbox{if $c \in \Constant$} \\
(\lambda V \bullet (t_1, t_2)) &\leadsto& \langle(\lambda V\bullet t_1), (\lambda V\bullet t_2)\rangle
	&  \\
(\lambda V \bullet f\,t) &\leadsto& f \circ (\lambda V\bullet t)
	& \mbox{if $f \in \Unary$} \\
(\lambda V \bullet g\,t_1\,t_2) &\leadsto& \Uncurry\,g \circ \langle(\lambda V\bullet t_1), (\lambda V\bullet t_2)\rangle
	& \mbox{if $g \in \Binary$} \\
(\lambda V \bullet h\,t\,p) &\leadsto& (\lambda x\bullet h\,x\,p) \circ (\lambda V\bullet t)
	& \mbox{if $h \in \Parametrized$} \\
\end{array}
\]

Here, if $V$ is a varstruct with a free occurrence of the variable $x$,
$\pi^V_x$ denotes the combination of projections which extracts $x$.
For example $\pi^{((z, x), y)}_x$ is $\pi_2 \circ \pi_1$.
As a special case, $\pi^x_x = \I$ and we may simplify $f \circ I$ to $f$.

%Note that if pairing is implemented by taking `,' to be a binary operator
%of type $\alpha \rightarrow \beta \rightarrow \alpha \times \beta$,
%the rule for pairing is subsumed by the rule for binary operators
%together with a simplification rule $\Upsilon (,) = \iota$.
=TEX
\subsubsection{Implementation}

We prove template theorems that support the various clauses of the rewrite system.
=SML
local 
	val old_thy = get_current_theory_name();
	val _ = open_theory"combin";
	val _ = push_pc"basic_hol1";
in

=SML
val €i_rule_thm› = snd ("i_rule_thm", (
set_goal([], ¨(Ãx∑ x) = CombIÆ);
a(rewrite_tac [get_spec¨CombIÆ]);
pop_thm()
));
=TEX
%%%%

=SML
val €o_i_rule_thm› = snd ("o_i_rule_thm", (
set_goal([], ¨µf∑f o CombI = fÆ);
a(rewrite_tac [get_spec¨CombIÆ, get_spec¨$oÆ]);
pop_thm()
));
=TEX
%%%%

=SML
val €k_rule_thm› = snd ("k_rule_thm", (
set_goal([], ¨µc∑ (Ãx∑ c) = CombK cÆ);
a(rewrite_tac [get_spec¨CombKÆ]);
pop_thm()
));
=TEX
%%%%

=SML
val €unary_rule_thm› = snd ("unary_rule_thm", (
set_goal([], ¨ µf t∑ (Ãx∑f (t x)) = f o t Æ);
a(rewrite_tac[o_def]);
pop_thm()
));
=TEX
%%%%

=SML
val €pair_rule_thm› = snd ("pair_rule_thm", (
set_goal([], ¨ µs t∑ (Ãx∑(s x, t x)) = Pair(s, t)Æ);
a(rewrite_tac[pair_def, o_def, uncurry_def]);
pop_thm()
));
=TEX
%%%%

=SML
val €binary_rule_thm› = snd ("binary_rule_thm", (
set_goal([], ¨ µf s t∑ (Ãx∑f (s x) (t x)) = Uncurry f o Pair(s, t)Æ);
a(rewrite_tac[pair_def, o_def, uncurry_def]);
pop_thm()
));
=TEX
%%%%

=SML
val €binary_rule_thm1› = snd ("binary_rule_thm1", (
set_goal([], ¨ µf c t∑ (Ãx∑f c (t x)) = Uncurry f o Pair ((Ãx∑c), t)Æ);
a(rewrite_tac[pair_def, o_def, uncurry_def]);
pop_thm()
));
=TEX
%%%%
=SML
val €parametrized_rule_thm› = snd ("parametrized_rule_thm", (
set_goal([], ¨ µf s p∑ (Ãx∑f (s x) p) = (Ãx∑f x p) o sÆ);
a(rewrite_tac[o_def]);
pop_thm()
));
=TEX
=SML

val »_expand_thm : THM = prove_rule[]¨µf∑ f = Ãz∑ f zÆ;

val _ = pop_pc();
val _ = open_theory old_thy;
end (* of local ... in ... end *);
=TEX
%%%%
When we instantiate the template theorems, we want to rename type variables to avoid capture, we use the following utility to help with this.
=SML
fun €list_string_variant› (avoid : string list) (ss : string list) : string list = (
	let	fun aux (s, (av, res)) = (
			let	val s' = string_variant av s;
			in	(s'::av, s'::res)
			end
		);
	in	rev(snd (revfold aux ss (avoid, [])))
	end
);
=TEX
%%%%
The derived rule 
=INLINEFT
gen_µ_elim
=TEX
\ is µ-elimination combined with renaming of type variables to avoid capture.
=SML
fun €gen_µ_elim› (tm : TERM) (thm : THM) : THM = (
	let	val tm_tyvs = term_tyvars tm;
		val (asms, conc) = dest_thm thm;
		val thm_tyvs = term_tyvars (mk_list(conc::asms));
		val thm_tyvs' = list_string_variant tm_tyvs thm_tyvs;
		val thm' = inst_type_rule (combine (map mk_vartype thm_tyvs') (map mk_vartype thm_tyvs)) thm;
	in	µ_elim tm thm'
	end
);
=TEX
The derived rule 
=INLINEFT
all_µ_intro1
=TEX
\ gives the universal closure of a theorem but leaving the free variables
of a specified term that are not included in a supplied list of ``pattern variables'' free.

=SML
fun €all_µ_intro1› (pat_vars : TERM list) (tm : TERM) (thm : THM) : THM = (
	let	val fvs = frees tm diff pat_vars;
		val bvs = thm_frees thm diff fvs;
	in	list_µ_intro bvs thm
	end
);
=TEX
%%%%
Now
=INLINEFT
morphism\_conv
=TEX
\ implements our rewrite system.
=SML
fun €morphism_conv›
	{unary : TERM list, binary : TERM list, parametrized : TERM list, pattern_vars : TERM list}
	: CONV = (
	let	val unary_thms = map (fn t => all_µ_intro1 pattern_vars t (gen_µ_elim t unary_rule_thm))
			unary;
		val binary_thms = map (fn t => all_µ_intro1 pattern_vars t (gen_µ_elim t binary_rule_thm))
			binary;
		val binary_thms1 = map (fn t => all_µ_intro1 pattern_vars t (gen_µ_elim t binary_rule_thm1))
			binary;
		val parametrized_thms = map (switch gen_µ_elim parametrized_rule_thm)
			parametrized;
		val i_conv = simple_eq_match_conv i_rule_thm;
		val k_conv = simple_eq_match_conv k_rule_thm;
		val pair_conv = simple_ho_eq_match_conv pair_rule_thm;
		val unary_conv = FIRST_C (map simple_ho_eq_match_conv1 unary_thms)
			handle Fail _ => fail_conv;
		val binary_conv = FIRST_C (map simple_ho_eq_match_conv1 (binary_thms @ binary_thms1))
			handle Fail _ => fail_conv;
		val parametrized_conv = FIRST_C (map simple_ho_eq_match_conv1 parametrized_thms)
			handle Fail _ => fail_conv;
		val simp_conv = simple_eq_match_conv o_i_rule_thm;
		val rec rec_conv = (fn t =>
			((i_conv ORELSE_C
			k_conv ORELSE_C
			(pair_conv THEN_C RAND_C(RANDS_C(TRY_C rec_conv))) ORELSE_C
			(unary_conv THEN_TRY_C RIGHT_C rec_conv) ORELSE_C
			(binary_conv THEN_C RIGHT_C (RAND_C(RANDS_C (TRY_C rec_conv)))) ORELSE_C
			(parametrized_conv THEN_C RIGHT_C (TRY_C rec_conv)))
				AND_OR_C simp_conv) t
		);
	in	Ã_unpair_conv AND_OR_C rec_conv
	end
);
=TEX
=TEX
\subsection{Moprhismhood Tactic}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Now we build the basic morphismhood tactic.
It expects a goal of the form
=INLINEFT
f ç (X, Y) Morphism
=TEX
.
The tactic begins by »-expanding $f$ if it not already an abstraction.
=SML

val  €»_expand_conv› : CONV = (fn tm => (
	if	is_Ã tm
	then	fail_conv
	else	simple_eq_match_conv »_expand_thm) tm);

=TEX
The theorem is parametrized by a list of theorems that are used
as an initial set of rewrite rules. For convenience, we convert
any paired abstractions in these theorems into simple abstractions,
which makes them more general as rewrite rules.
=SML

val €unpair_rewrite_tac› : THM list -> TACTIC = 
	rewrite_tac o map (conv_rule (TRY_C (MAP_C Ã_unpair_conv)));
=TEX
Now the tactic. After the »-expansion and rewriting discussed above,
it converts the function into combinator form.
It then goes through a cycle of backchaining with implicative facts
applying the supplied tactic to guess
existential witnesses, then stripping and rewriting with the basic facts.
=SML
fun €basic_morphism_tac›
	{
		unary : TERM list,
		binary : TERM list,
		parametrized : TERM list,
		pattern_vars : TERM list,
		facts : THM list,
		witness_tac : TACTIC} : THM list -> TACTIC = (
	let	val m_conv = morphism_conv {
			unary = unary,
			binary = binary,
			parametrized = parametrized,
			pattern_vars = pattern_vars};
		val is_rule = is_¥ o snd o strip_µ o concl;
		val rule_thms = facts drop (not o is_rule);
		val axiom_thms = facts drop is_rule;
	in	fn rw_thms =>
			TRY (conv_tac (LEFT_C »_expand_conv))
		THEN	TRY (unpair_rewrite_tac rw_thms)
		THEN	conv_tac (LEFT_C m_conv)	
		THEN 	(REPEAT o CHANGED_T) (
				(TRY o bc_tac) rule_thms
			THEN	TRY witness_tac
			THEN	REPEAT strip_tac
			THEN	(TRY o rewrite_tac) axiom_thms)
	end
);
=TEX
The following constructs witnesses to objecthood using a supplied list of object constructors based on the type of the desired witness.
Each object constructor is given with a list of type variables that are not to be instantiated in the search for a witness.
=SML
fun €object_by_type› (ocs : (string list * TERM) list) : TYPE -> TERM = (
	let	fun preprocess acc [] = acc
		|   preprocess acc ((tvs, oc) :: more) = (
			let	val rev_tys = rev(strip_≠_type (type_of oc));
				val res_ty = hd (rev_tys);
				val tysubs0 = map (fn tv => (mk_vartype tv, mk_vartype tv)) tvs;
				val arg_tys = rev (tl rev_tys);
			in	preprocess ((res_ty,  (oc, tysubs0, arg_tys)) :: acc) more
			end
		);
		val table = preprocess [] ocs;
		fun solve [] ty = fail "object_by_type" 1005 []
		|   solve ((res_ty, (oc, tysubs0, arg_tys)) :: more) ty = (
			let	val recur = solve table;
				val tysubs = type_match1 tysubs0 ty res_ty;
				val args = map (recur o inst_type tysubs) arg_tys;
				val ioc = inst [] tysubs oc;
			in	list_mk_app(ioc, args)
			end	handle Fail _ => solve more ty
		);
	in	solve table
	end
);
=TEX
%%%%

In the following, the list of strings with each object constructor is a list of type variables that are not to be instantiated when matching with this constructor. Typically these would be type variables appearing in the type of something which is an object by dint of an assumption of the goal.

=SML
fun €∂_object_by_type_tac› (ocs : (string list * TERM) list) : TACTIC = (
	let	val witness_by_type = object_by_type ocs;
	in	fn gl as (_, conc) => 
		let	val (x, _) = dest_simple_∂ conc;
		in	(simple_∂_tac o witness_by_type o type_of) x gl
		end
	end
);
(*
=TEX
The following function that extracts lists of known unary, binary and parametrized morphisms and a list
of known objects from a list of theorems.
The patterns have the form $(v, t)$ where $v$ is a variable and $t$ is a term containing a free
occurrence of $v$ to be matched with the conclusion of a theorem.
If there is a match in the binary pattern, for example, the appropriate instanve of $v$ is added to the list
of binary morphisms.
=TEX
=SML
*)
fun €analyse_morphism_thms›
	{object_pat : TERM, unary_pat : TERM, binary_pat : TERM, parametrized_pat : TERM}
	: THM list ->
		{unary : TERM list, binary : TERM list, parametrized : TERM list} *
			(string list * TERM) list = (
	let	fun dp p = dest_pair p handle Fail _ => (mk_t, mk_t);
		val (object_v, object_p) = dp object_pat;
		val (unary_v, unary_p) = dp unary_pat;
		val (binary_v, binary_p) = dp binary_pat;
		val (parametrized_v, parametrized_p) = dp parametrized_pat;
		fun aux (accs as (acc_u, acc_b, acc_p, acc_o))
			((thm :: more)) = (
			let	val tm = (snd o strip_µ o concl) thm;
			in	let	val (tym, tmm) = term_match tm binary_p;
					val bin = subst tmm (inst [] tym binary_v);
				in	aux (acc_u, bin::acc_b, acc_p, acc_o) more
				end	handle Fail _ =>
				let	val (tym, tmm) = term_match tm parametrized_p;
					val par = subst tmm (inst [] tym parametrized_v);
				in	aux (acc_u, acc_b, par::acc_p, acc_o) more
				end	handle Fail _ =>
				let	val (tym, tmm) = term_match tm unary_p;
					val un = subst tmm (inst [] tym unary_v);
				in	aux (un::acc_u, acc_b, acc_p, acc_o) more
				end	handle Fail _ =>
				let	val (tym, tmm) = term_match tm object_p;
					val ob = subst tmm (inst [] tym object_v);
					val tvs = (list_cup o map term_tyvars o asms) thm;
				in	aux (acc_u, acc_b, acc_p, (tvs, ob)::acc_o) more
				end	handle Fail _ => aux accs more
			end
		) | aux accs [] = accs;
	in	fn thms => (
			let	val (ul, bl, pl, ol) = aux ([], [], [], []) thms;
			in	({unary = ul, binary = bl, parametrized = pl}, ol)
			end
		)
	end
);
(*
=TEX
The following gives a standard way of constructing the parameters for the morphismhood tactic.
=SML
*)
fun morphism_params›
	(pats as {object_pat : TERM, unary_pat : TERM, binary_pat : TERM, parametrized_pat : TERM})
	(fst_snd : TERM list)
	(basic_obs : (string list * TERM) list)
	(tac :  (string list * TERM) list -> TACTIC)
	(basic_thms : THM list)
	(thms : THM list) :
	{unary : TERM list,
	 binary : TERM list,
	 parametrized : TERM list,
	 pattern_vars : TERM list,
	 facts : THM list,
	 witness_tac : TACTIC} = (
	let	val ({unary, binary, parametrized}, obs) = analyse_morphism_thms pats thms;
	in
		{unary = fst_snd @ unary,
		 binary = binary,
		 parametrized = parametrized,
		 pattern_vars = [],
		 facts = thms @ basic_thms,
		 witness_tac = tac (basic_obs @ obs)}
	end
);

=TEX
\section{HIGHER-ORDER BACKCHAINING}

=TEX
%%%%
%%%%
In the following, we have some choice about how much normalisation to do.
We need to do full $\beta$-$\eta$ normalisation to make sure the conclusion
of the goal matches the succedent of the instantiated theorem. However, we
just do $\beta$-normalisation of the antecedent to preserve the form of
subterms such as
=INLINEFT
Ãi∑n + i
=TEX
.
=SML
local
fun €bc_rule› (th : THM) : THM = (
	let	val (ant, suc) = dest_¥ (concl th);
		fun aux (v :: vs) a th = (
			let	val (a', th') = aux vs a th;
				val a'' = mk_simple_∂ (v, a');
				val th1 = asm_rule a'';
				val th2 = simple_∂_elim v th1 th';
			in	(a'', th2)
			end
		) | aux [] a th = (a, th);
	in	case frees ant term_diff
		(flat(map frees(suc :: asms th))) of
		[] => th
		|	vs => (
			let	val (a,th1) = aux vs ant (undisch_rule th);
				val th2 = ¥_intro a th1;
			in	th2
			end
		)
	end
);
in
fun €ho_bc_thm_tac› (thm : THM) : TACTIC = ( 
	let	val thm0 = all_µ_elim thm;
		val thm1 = all_µ_intro(
			if	is_¥(concl thm0)
			then	thm0
			else	fst (§_elim thm0))
			handle Fail _ => thm_fail "bc_thm_tac" 29012 [thm];
		val (bvs, _) =  strip_µ(concl thm1);
	in
	fn gl as (_, conc) =>
	let	val nbvs = list_variant (frees conc) bvs;
		val thm2 = list_µ_elim nbvs thm1;
		val (_, suc) = dest_¥(concl thm2);
		val (tym, tmm) = simple_ho_match [] conc suc
			handle Fail _ => term_fail "bc_thm_tac" 29011 [suc];
		val thm3 = asm_inst_term_rule tmm (asm_inst_type_rule tym thm2);
		val thm4 = conv_rule (TRY_C
				(LEFT_C all_simple_¬_conv AND_OR_C
					RIGHT_C simple_¬_»_norm_conv)) thm3;
		val thm5 = bc_rule thm4;
	in	TRY (conv_tac simple_¬_»_norm_conv) THEN ¥_thm_tac thm5
	end	gl
	end
);
end;
=TEX
\end{document}
=IGN
