=IGN
********************************************************************************
wrk083.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
wrk083.doc,v 1.115 2011/02/06 17:42:00 rda Exp
********************************************************************************
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
%\usepackage{amsmath} % breaks the index!
\ftlinepenalty=9999
\usepackage{A4}
\makeindex
\title{Mathematical Case Studies: Recognising Morphisms}
\author{Rob Arthan}
%\makeindex
\author{R.D. Arthan \\ Lemma 1 Ltd. \\ rda@lemma-one.com}
\date{\FormatDate{$Date: 2012/03/25 14:49:46 $%
}}

\def\Func#1{\mathsf{#1}}
\def\I{\Func{I}}
\def\K{\Func{K}}
\def\Uncurry{\Func{Uncurry}}
\def\Frees{\Func{frees}}
\def\Constant{\Func{Constant}}
\def\Unary{\Func{Unary}}
\def\Binary{\Func{Binary}}
\def\Parametrized{\Func{Parametrized}}

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}

TBS
\end{abstract}
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd \number\year \\
Reference: LEMMA1/HOL/WRK083; issue 1.115%


\end{centering}
\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
\tableofcontents
%\newpage
%\subsection{Document cross references}
\newpage
\subsection*{To Do}
\begin{itemize}

\item
TBS
\end{itemize}


\bibliographystyle{plain}
\bibliography{fmu}

%%%%
%%%%
%%%%
%%%%
\newpage
\section{INTRODUCTION}
%%%%
%%%%


\section{SUPPORTING THEORY}
%%%%
%%%%

=SML
open_theory "combin";
new_theory "morphisms";
set_pc"basic_hol1";
=TEX
We define aliases for the I and K combinators useful for working in a typical concrete category
whose morphisms are represented as HOL functions.

%%%%
%%%%
=SML
declare_alias("Ic", ¨CombI : 'a ≠ 'aÆ);
declare_alias("Kc", ¨CombK : 'a ≠ 'b ≠ 'aÆ);
=TEX
{\bf Note:} the type ascriptions here and in other alias declarations
in this document give the most general type of 
the constant and are just for documentary purposes. (We are not introducing
 aliases for special instances of the constants.)

%%%%
%%%%

We introduce the combinator {\em Pair} corresponding to the universal property
of a binary product:
πHOLCONST
‹ €Pair› : ('a ≠ 'b) ∏ ('a ≠ 'c) ≠ 'a ≠ 'b ∏ 'c
˜¸¸¸¸¸¸
‹ µf g∑ Pair(f, g) = (Ãx∑ (f x, g x))
∞
=TEX
=SML
val €pair_def› : THM = get_spec¨PairÆ;
=TEX
%%%%
\section{REPRESENTING $\lambda$-ABSTRACTIONS WITH COMBINATORS}

\[
\begin{array}{rcl@{\quad\quad}l}
(\lambda V \bullet x)^M &=& \pi^V_x
	& \mbox{if $x \in \Frees(V)$} \\
(\lambda V \bullet y)^M &=& \K\,y
	& \mbox{if $y \not\in \Frees(V)$} \\
(\lambda V \bullet c)^M &=& \K\,c
	& \mbox{if $c \in \Constant$} \\
(\lambda V \bullet (t_1, t_2))^M &=& \langle(\lambda V\bullet t_1)^M, (\lambda V\bullet t_2)^M\rangle
	&  \\
(\lambda V \bullet f\,t)^M &=& f \circ (\lambda V\bullet t)^M
	& \mbox{if $f \in \Unary$} \\
(\lambda V \bullet g\,t_1\,t_2)^M &=& \Uncurry\,g \circ \langle(\lambda V\bullet t_1)^M, (\lambda V\bullet t_2)^M\rangle
	& \mbox{if $g \in \Binary$} \\
(\lambda V \bullet h\,t\,p)^M &=& (\lambda x\bullet h\,x\,p) \circ (\lambda V\bullet t)^M
	& \mbox{if $h \in \Parametrized$} \\
\end{array}
\]

Here, if $V$ is a varstruct with a free occurrence of the variable $x$,
$\pi^V_x$ denotes the combination of projections which extracts $x$.
For example $\pi^{((z, x), y)}_x$ is $\pi_2 \circ \pi_1$.
As a special case, $\pi^x_x = \I$.

%Note that if pairing is implemented by taking `,' to be a binary operator
%of type $\alpha \rightarrow \beta \rightarrow \alpha \times \beta$,
%the rule for pairing is subsumed by the rule for binary operators
%together with a simplification rule $\Upsilon (,) = \iota$.
=TEX
=SML
val €i_rule_thm› = save_thm ("i_rule_thm", (
set_goal([], ¨(Ãx∑ x) = IcÆ);
a(rewrite_tac [get_spec¨CombIÆ]);
pop_thm()
));
=TEX
%%%%

=SML
val €o_i_rule_thm› = save_thm ("o_i_rule_thm", (
set_goal([], ¨µf∑f o Ic = fÆ);
a(rewrite_tac [get_spec¨CombIÆ, get_spec¨$oÆ]);
pop_thm()
));
=TEX
%%%%

=SML
val €k_rule_thm› = save_thm ("k_rule_thm", (
set_goal([], ¨µc∑ (Ãx∑ c) = Kc cÆ);
a(rewrite_tac [get_spec¨CombKÆ]);
pop_thm()
));
=TEX
%%%%

=SML
val €unary_rule_thm› = save_thm ("unary_rule_thm", (
set_goal([], ¨ µf t∑ (Ãx∑f (t x)) = f o t Æ);
a(rewrite_tac[o_def]);
pop_thm()
));
=TEX
%%%%

=SML
val €pair_rule_thm› = save_thm ("pair_rule_thm", (
set_goal([], ¨ µs t∑ (Ãx∑(s x, t x)) = Pair(s, t)Æ);
a(rewrite_tac[pair_def, o_def, uncurry_def]);
pop_thm()
));
=TEX
%%%%

=SML
val €binary_rule_thm› = save_thm ("binary_rule_thm", (
set_goal([], ¨ µf s t∑ (Ãx∑f (s x) (t x)) = Uncurry f o Pair(s, t)Æ);
a(rewrite_tac[pair_def, o_def, uncurry_def]);
pop_thm()
));
=TEX
%%%%

=SML
val €binary_rule_thm1› = save_thm ("binary_rule_thm1", (
set_goal([], ¨ µf c t∑ (Ãx∑f c (t x)) = Uncurry f o Pair ((Ãx∑c), t)Æ);
a(rewrite_tac[pair_def, o_def, uncurry_def]);
pop_thm()
));
=TEX
%%%%
=SML
val €parametrized_rule_thm› = save_thm ("parametrized_rule_thm", (
set_goal([], ¨ µf s p∑ (Ãx∑f (s x) p) = (Ãx∑f x p) o sÆ);
a(rewrite_tac[o_def]);
pop_thm()
));
=TEX
%%%%

=SML
fun €list_string_variant› (avoid : string list) (ss : string list) : string list = (
	let	fun aux (s, (av, res)) = (
			let	val s' = string_variant av s;
			in	(s'::av, s'::res)
			end
		);
	in	rev(snd (revfold aux ss (avoid, [])))
	end
);
=TEX
%%%%

=SML
fun €gen_µ_elim› (tm : TERM) (thm : THM) = (
	let	val tm_tyvs = term_tyvars tm;
		val (asms, conc) = dest_thm thm;
		val thm_tyvs = term_tyvars (mk_list(conc::asms));
		val tm_tyvs' = list_string_variant thm_tyvs tm_tyvs;
		val tm' = inst [] (combine (map mk_vartype tm_tyvs') (map mk_vartype tm_tyvs)) tm;
	in	µ_elim tm' thm
	end
);
=TEX
%%%%

=SML
fun €morphism_conv›
	{unary : TERM list, binary : TERM list, parametrized : TERM list}
	: CONV = (
	let	val unary_thms = map (all_µ_intro o switch gen_µ_elim unary_rule_thm)
			unary;
		val binary_thms = map (all_µ_intro o switch gen_µ_elim binary_rule_thm)
			binary;
		val binary_thms1 = map (all_µ_intro o switch gen_µ_elim binary_rule_thm1)
			binary;
		val parametrized_thms = map (switch gen_µ_elim parametrized_rule_thm)
			parametrized;
		val i_conv = simple_eq_match_conv i_rule_thm;
		val k_conv = simple_eq_match_conv k_rule_thm;
		val pair_conv = simple_ho_eq_match_conv pair_rule_thm;
		val unary_conv = FIRST_C (map simple_ho_eq_match_conv unary_thms)
			handle Fail _ => fail_conv;
		val binary_conv = FIRST_C (map simple_ho_eq_match_conv (binary_thms @ binary_thms1))
			handle Fail _ => fail_conv;
		val parametrized_conv = FIRST_C (map simple_ho_eq_match_conv parametrized_thms)
			handle Fail _ => fail_conv;
		val simp_conv = simple_eq_match_conv o_i_rule_thm;
		val rec rec_conv = (fn t =>
			((i_conv ORELSE_C
			k_conv ORELSE_C
			(pair_conv THEN_C RAND_C(RANDS_C(TRY_C rec_conv))) ORELSE_C
			(unary_conv THEN_TRY_C RIGHT_C rec_conv) ORELSE_C
			(binary_conv THEN_C RIGHT_C (RAND_C(RANDS_C (TRY_C rec_conv)))) ORELSE_C
			(parametrized_conv THEN_C RIGHT_C (TRY_C rec_conv)))
				AND_OR_C simp_conv) t
		);
	in	Ã_unpair_conv AND_OR_C rec_conv
	end
);
=TEX
%%%%
\section{APPLICATION IN TOPOLOGY}
=SML
new_theory"topology-examples";
new_parent "topology_Ø";
new_parent "÷";
set_merge_pcs ["basic_hol1", "'Ø", "'sets_alg"];
=TEX
=SML
declare_alias("OâR", ¨OpenâRÆ);
declare_alias("OâC", ¨OpenâCÆ);
=TEX
=SML
val €fst_continuous_rule_thm› = fst_continuous_thm;
val €snd_continuous_rule_thm› = snd_continuous_thm;

=TEX
=SML
val €i_continuous_rule_thm› = save_thm( "i_continuous_rule_thm", (
set_goal([], ¨µ‘∑ ‘ ç Topology ¥ Ic ç (‘, ‘) ContinuousÆ);
a(REPEAT strip_tac THEN rewrite_tac[
		prove_rule[get_spec¨IcÆ] ¨Ic = Ãx∑ xÆ]
	THEN ALL_FC_T rewrite_tac[id_continuous_thm]);
pop_thm()
));

=TEX
=SML
val €k_continuous_rule_thm› = save_thm( "k_continuous_rule_thm", (
set_goal([], ¨µ ” ‘ c∑
	” ç Topology ± ‘ ç Topology ± c ç SpaceâT ‘ ¥
	Kc c ç (”, ‘) ContinuousÆ);
a(REPEAT strip_tac THEN rewrite_tac[
		prove_rule[get_spec¨KcÆ] ¨µc∑Kc c = Ãx∑ cÆ]
	THEN ALL_FC_T rewrite_tac[const_continuous_thm]);
pop_thm()
));

=TEX
=SML
val €minus_continuous_rule_thm› = save_thm( "minus_continuous_rule_thm", (
set_goal([], ¨~ ç (OpenâR, OpenâR) ContinuousÆ);
a(rewrite_tac[continuous_cts_at_Ø_thm, minus_cts_thm]);
pop_thm()
));


=TEX
=SML
val €exp_sin_cos_continuous_rule_thm› = save_thm( "exp_sin_cos_continuous_rule_thm", (
set_goal([], ¨
	Exp ç (OpenâR, OpenâR) Continuous
±	Sin ç (OpenâR, OpenâR) Continuous
±	Cos ç (OpenâR, OpenâR) Continuous
Æ);
a(rewrite_tac[continuous_cts_at_Ø_thm, exp_cts_thm, sin_cos_cts_thm]);
pop_thm()
));


=TEX
=SML
val €plus_continuous_rule_thm› = plus_continuous_Ø_∏_Ø_thm;
val €times_continuous_rule_thm› = times_continuous_Ø_∏_Ø_thm;

=TEX
=SML
=TEX
=SML
val €Ø_Ó_exp_continuous_rule_thm› = save_thm( "Ø_Ó_exp_continuous_rule_thm", (
set_goal([], ¨µn : Ó∑ (Ãx∑ x ^ n) ç (OpenâR, OpenâR) ContinuousÆ);
a(rewrite_tac[continuous_cts_at_Ø_thm, Ø_Ó_exp_cts_thm]);
pop_thm()
));

=TEX
=SML
val €pair_continuous_rule_thm› = save_thm( "pair_continuous_rule_thm", (
set_goal([], ¨µ “ ” ‘ f g∑
	“ ç Topology ± ” ç Topology ± ‘ ç Topology ±
	f ç (“, ”) Continuous ± g ç (“, ‘) Continuous ¥
	Pair (f, g) ç (“, ” ∏âT ‘) Continuous
Æ);
a(REPEAT strip_tac THEN rewrite_tac[pair_def]
	THEN ALL_FC_T rewrite_tac[product_continuous_thm]);
pop_thm()
));

=TEX
=SML
val €o_continuous_rule_thm› = save_thm( "o_continuous_rule_thm", (
set_goal([], ¨µ “ ” ‘ f g∑
	“ ç Topology ± ” ç Topology ± ‘ ç Topology ±
	f ç (“, ”) Continuous ± g ç (”, ‘) Continuous ¥
	g o f ç (“, ‘) Continuous
Æ);
a(REPEAT strip_tac THEN rewrite_tac[
		prove_rule[o_def] ¨µf g∑ g o f = Ãx∑ g(f x)Æ]
	THEN ALL_FC_T rewrite_tac[comp_continuous_thm]);
pop_thm()
));

=TEX
=SML

val €continuity_axiom_thms› : THM list = [
	open_Ø_topology_thm,
	space_t_Ø_thm,
	minus_continuous_rule_thm,
	exp_sin_cos_continuous_rule_thm,
	plus_continuous_rule_thm,
	times_continuous_rule_thm,
	Ø_Ó_exp_continuous_rule_thm];

val €continuity_rule_thms› : THM list = [
	product_topology_thm,
	fst_continuous_rule_thm,
	snd_continuous_rule_thm,
	i_continuous_rule_thm,
	k_continuous_rule_thm,
	pair_continuous_rule_thm,
	o_continuous_rule_thm];
=TEX
=SML
val Ø_morphism_conv = morphism_conv {
	unary = [¨~ : Ø ≠ ØÆ, ¨Exp : Ø ≠ ØÆ, ¨Sin : Ø ≠ ØÆ,
		¨Cos : Ø ≠ ØÆ, ¨FstÆ, ¨SndÆ] : TERM list,
	binary = [¨$+ : Ø ≠ Ø ≠ ØÆ, ¨$* : Ø ≠ Ø ≠ ØÆ],
	parametrized = [¨$^ : Ø ≠ Ó ≠ ØÆ]};
=TEX
=IGN

Ø_morphism_conv ¨Ã xy∑ Snd xy * Snd xy + 1.0Æ;
Ø_morphism_conv ¨Ã(x, y)∑x + y * y + 1.0Æ;
Ø_morphism_conv ¨Ã(x:Ø, y)∑(x + y, x * y)Æ;
Ø_morphism_conv ¨Ã((z, x), y)∑xÆ;
simple_ho_match ¨Ãx:'a ∏ 'b∑Snd xÆ ¨Ãy:'b∑ Snd (t y)Æ;
Ø_morphism_conv ¨Ã(x:Ø, y)∑ x^3 * yÆ;
Ø_morphism_conv ¨Ã(x:Ø, y)∑ (x, x+y, x^3 * y)Æ;
Ø_morphism_conv ¨Ãx∑ (Cos x, Sin x)Æ;
Ø_morphism_conv ¨Ã(x, y) : Ø ∏ Ø∑ Exp(x + y)Æ;
Ø_morphism_conv ¨Ã(x, y) : Ø ∏ Ø∑ (a*x + c*y, c*x + d*y)Æ;
Ø_morphism_conv ¨Ãx : Ø∑ 2.0 * x ^ 4Æ;
=TEX
=IGN
val Ø_linear_morphism_conv = morphism_conv {
	unary = [¨~ : Ø ≠ ØÆ, ¨$* : Ø ≠ Ø ≠ ØÆ] : TERM list,
	binary = [¨$+ : Ø ≠ Ø ≠ ØÆ],
	parametrized = []};
=IGN
Ø_linear_morphism_conv ¨Ã(x, y):Ø ∏ Ø∑(a*x+c*y, b*x+d*y)Æ;
=SML
set_goal([], ¨(Ãx∑x ^ 2 + 2. * x + 1.) ç (OpenâR, OpenâR) ContinuousÆ);
a(conv_tac (LEFT_C Ø_morphism_conv));
a (bc_tac continuity_rule_thms);

a(∂_tac¨OpenâR ∏âT OpenâRÆ);
a(rewrite_tac continuity_axiom_thms);
a(REPEAT strip_tac THEN bc_tac continuity_rule_thms
	THEN_TRY rewrite_tac continuity_axiom_thms);

a(∂_tac¨OpenâR ∏âT OpenâRÆ);
a(rewrite_tac continuity_axiom_thms);
a(REPEAT strip_tac THEN bc_tac continuity_rule_thms
	THEN_TRY rewrite_tac continuity_axiom_thms);

a(∂_tac¨OpenâR ∏âT OpenâRÆ);
a(rewrite_tac continuity_axiom_thms);
a(REPEAT strip_tac THEN bc_tac continuity_rule_thms
	THEN_TRY rewrite_tac continuity_axiom_thms);

val thm1 = pop_thm();

=IGN
val ÷_morphism_conv = morphism_conv {
	unary = [¨~ : ÷ ≠ ÷Æ, ¨Exp : ÷ ≠ ÷Æ,
		¨FstÆ, ¨SndÆ ] : TERM list,
	binary = [¨$+ : ÷ ≠ ÷ ≠ ÷Æ, ¨$* : ÷ ≠ ÷ ≠ ÷Æ],
	parametrized = [¨$^ : ÷ ≠ Ó ≠ ÷Æ]};

=TEX
Notes:

Axioms and rules for: morphism-ness (continuity) and object-ness (topology).

Could/should automate the »-expansion at the beginning of the following.

Put ML bindings for spec of Exp etc. in wrk072.

Sort out parent relationships

=IGN
set_goal([], ¨Exp ç (OpenâC, OpenâC) ContinuousÆ);
a(conv_tac(LEFT_C(once_rewrite_conv[prove_rule[]¨µf∑ f = Ãz∑ f zÆ])));
a(rewrite_tac[get_spec¨ExpâCÆ, get_spec¨Ø÷Æ, ÷_times_def, open_÷_def]);

a(conv_tac (LEFT_C Ø_morphism_conv));

a(REPEAT strip_tac THEN bc_tac continuity_rule_thms
	THEN_TRY rewrite_tac continuity_axiom_thms);

(* *** Goal "1" *** *)

a(∂_tac¨OpenâR ∏âT OpenâRÆ);
a(REPEAT strip_tac THEN_TRY bc_tac continuity_rule_thms
	THEN_TRY rewrite_tac continuity_axiom_thms);

(* *** Goal "1.1" *** *)

a(∂_tac¨OpenâRÆ);
a(REPEAT strip_tac THEN_TRY bc_tac continuity_rule_thms
	THEN_TRY rewrite_tac continuity_axiom_thms);

(* *** Goal "1.2" *** *)

a(∂_tac¨OpenâRÆ);
a(REPEAT strip_tac THEN_TRY bc_tac continuity_rule_thms
	THEN_TRY rewrite_tac continuity_axiom_thms);

(* *** Goal "2" *** *)


a(∂_tac¨OpenâR ∏âT OpenâRÆ);
a(REPEAT strip_tac THEN_TRY bc_tac continuity_rule_thms
	THEN_TRY rewrite_tac continuity_axiom_thms);

(* *** Goal "2.1" *** *)

a(∂_tac¨OpenâRÆ);
a(REPEAT strip_tac THEN_TRY bc_tac continuity_rule_thms
	THEN_TRY rewrite_tac continuity_axiom_thms);

(* *** Goal "2.2" *** *)

a(∂_tac¨OpenâRÆ);
a(REPEAT strip_tac THEN_TRY bc_tac continuity_rule_thms
	THEN_TRY rewrite_tac continuity_axiom_thms);


val thm1 = pop_thm();
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

=SML

val »_expand_thm : THM = prove_rule[]¨µf∑ f = Ãz∑ f zÆ;

val  €»_expand_conv› : CONV = (fn tm => (
	if	is_Ã tm
	then	fail_conv
	else	simple_eq_match_conv »_expand_thm) tm);

val €unpair_rewrite_tac› : THM list -> TACTIC = 
	rewrite_tac o map (conv_rule (TRY_C (MAP_C Ã_unpair_conv)));

fun €basic_continuity_tac› (thms : THM list) : TACTIC = (
		TRY (conv_tac (LEFT_C »_expand_conv))
	THEN	TRY (unpair_rewrite_tac thms)
	THEN	conv_tac (LEFT_C Ø_morphism_conv)	
	THEN REPEAT (
		(TRY o FIRST o map ∂_tac) [¨OpenâRÆ, ¨OpenâR ∏âT OpenâRÆ]
	THEN	REPEAT strip_tac
	THEN	(TRY o bc_tac) continuity_rule_thms
	THEN	(TRY o rewrite_tac) continuity_axiom_thms)
);

=TEX
=SML

set_goal([], ¨(Ãx∑ Sin(Cos (Exp x))) ç (OpenâR, OpenâR) ContinuousÆ);

a(basic_continuity_tac[]);

val thm2 = pop_thm();

=TEX
=SML

set_goal([], ¨(Ãx∑(Sin(Exp x), Cos (Exp x))) ç (OâR, OâR ∏âT OâR) ContinuousÆ);

a(basic_continuity_tac[]);

val thm3 = pop_thm();

=TEX
=SML

set_goal([], ¨(Ãx∑ 2.0 * (x ^ 4)) ç (OâR, OâR) ContinuousÆ);

a(basic_continuity_tac[]);

val thm4 = pop_thm();


=TEX
=SML


set_goal([], ¨(Ãx∑ Exp(Ø÷ 2. * Ø÷ – * IâC * Ø÷ x)) ç (OâR, OâC) ContinuousÆ);
(*

a(rewrite_tac[÷_exp_def, Ø÷_def, ÷_i_def, ÷_times_def, open_÷_def]);
a(conv_tac(LEFT_C Ø_morphism_conv));

*)
a(basic_continuity_tac[÷_exp_def, Ø÷_def, ÷_i_def, ÷_times_def, open_÷_def]);

val thm5 = pop_thm();
=TEX
=SML


set_goal([], ¨Exp ç (OpenâC, OpenâC) ContinuousÆ);
a(basic_continuity_tac[÷_exp_def, Ø÷_def, Ø…_def, ÷_times_def, open_÷_def]);

val thm4 = pop_thm();

=IGN
=IGN
set_flag("pp_show_HOL_types", true);
set_flag("pp_show_HOL_types", false);
=TEX
%%%%

%%%%
=SML
=IGN
(get_const_theory o fst o dest_const) ¨ Curry Æ;

get_spec ¨ Uncurry Æ;

open_theory "morphisms";
open_theory "topology_Ø";
find_thm [ ¨ Uncurry Æ ];

Ã_pair_conv¨(Ãxy∑Fst xy + Snd xy)Æ;
uncurry_def;
=TEX

{\let\Section\section
\def\section#1{\Section{#1}\label{TheoryListing}}
\include{wrk083.th}
}  %\let

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document}

{\HOLindexOff
%%%%
%%%%
%%%%
%%%%

} % matches turning off of HOL index entries.
=TEX
%%%%
%%%%
=SML
output_theory{out_file="wrk083.th.doc", theory="-"};
=TEX
The intention is that theorems should always have an outer universal quantifier if necessary rather than free variables
and that all variables bound by logical quantifiers should
actually be used.
The following code reports on theorems that fail to comply.
=SML
fun €unused_qvs› (tm : TERM) : TERM list = (
	let	fun drop_fst (t :: ts) v = (
			if	t =$ v
			then	ts
			else	t :: drop_fst ts v
		) | drop_fst [] _ = [];
		fun dest_quant t = (
			let	val (vs, b) = dest_µ t
				handle Fail _ => dest_∂ t
				handle Fail _ => dest_∂â1 t;
			in	(frees vs, b)
			end
		);
		fun aux (acc, tm) = (
			(dest_var tm; drop_fst acc tm)
		handle Fail _ => 
			(dest_const tm; acc)
		handle Fail _ =>
			(aux (dest_quant tm))
		handle Fail _ =>
			let	val (v, b) = dest_simple_Ã tm;
			in	if	v mem acc
				then	v :: aux (acc less v, b)
				else	aux (acc, b)
			end
		handle Fail _ =>
			let 	val (f, x) = dest_app tm;
			in	aux (aux(acc, f), x)
			end
		);
	in	aux ([], tm)
	end
);
fun €thm_unused_qvs› (thm : THM) : TERM list = (
	let	val tuple = fold mk_pair (asms thm) (concl thm);
	in	unused_qvs tuple
	end
);
fun €check_thms› (thyn : string) : unit = (
	let	val thy = if thyn = "-" then get_current_theory_name () else thyn;
		val thms = get_thms thy;
		val fv_bad_thms = thms drop (is_nil o thm_frees o snd);
		val bv_bad_thms = thms drop (is_nil o thm_unused_qvs o snd);
		fun aux (ns, _) = (
			output(ExtendedIO.std_err,
				translate_for_output (hd ns));
			output(ExtendedIO.std_err, "\n")
		);
	in	(case fv_bad_thms of
			[] => ()
		|	_ => (
			output(ExtendedIO.std_err,
		"**** The following theorems in theory \"" ^ thy
			^"\" have one or more free variables:\n");
			app aux fv_bad_thms
		));
		(case bv_bad_thms of
			[] => ()
		|	_ => (
			output(ExtendedIO.std_err,
		"**** The following theorems in theory \"" ^ thy
			^"\" have one or more unused quantified variables:\n");
			app aux bv_bad_thms
		));
		(case (fv_bad_thms, bv_bad_thms) of
			([], []) => (
			output(ExtendedIO.std_err,
		"**** Theorem quality control checks for theory \"" ^ thy
			^"\" all passed\n")
		) |	_ => ())
	end
);
check_thms "-";
(*
val _ = app check_thms (get_descendants "min");
*)
=TEX
\end{document}
=IGN

