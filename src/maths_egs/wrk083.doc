=IGN
********************************************************************************
wrk083.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
wrk083.doc,v 1.115 2011/02/06 17:42:00 rda Exp
********************************************************************************
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
%\usepackage{amsmath} % breaks the index!
\ftlinepenalty=9999
\usepackage{A4}
\makeindex
\title{Mathematical Case Studies: Recognising Morphisms}
\author{Rob Arthan}
%\makeindex
\author{R.D. Arthan \\ Lemma 1 Ltd. \\ rda@lemma-one.com}
\date{\FormatDate{$Date: 2012/03/30 19:31:40 $%
}}

\def\Func#1{\mathsf{#1}}
\def\I{\Func{I}}
\def\K{\Func{K}}
\def\Uncurry{\Func{Uncurry}}
\def\Frees{\Func{frees}}
\def\Constant{\Func{Constant}}
\def\Unary{\Func{Unary}}
\def\Binary{\Func{Binary}}
\def\Parametrized{\Func{Parametrized}}
\def\To{\rightarrow}

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}

TBS
\end{abstract}
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd \number\year \\
Reference: LEMMA1/HOL/WRK083; issue 1.115%


\end{centering}
\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
\tableofcontents
%\newpage
%\subsection{Document cross references}
\newpage
\subsection*{To Do}
\begin{itemize}

\item
TBS
\end{itemize}


\bibliographystyle{plain}
\bibliography{fmu}

%%%%
%%%%
%%%%
%%%%
\newpage
\section{INTRODUCTION}
%%%%
%%%%
\section{UTILITIES}
=SML
new_error_message{id = 999001,
	text = "?0 is not of form ?1"};
new_error_message{id = 999002,
	text = "?0 expects a ?1-element argument list"};
new_error_message{id = 999003,
	text = "hd2 expects a list with at least 2 elements"};
fun Ûdest_anyÝ (pattern : TERM, fun_name : string) : TERM -> TERM list = (
	let	val (f, args) = strip_app pattern;
		val arity = length args;
		fun strip_and_check tm = (
			let	val (g, args) = strip_app tm;
				val _ = term_match g f;
			in	if	length args = arity
				then	args
				else	fail "" 0 []
			end	handle Fail _ => (
				term_fail fun_name 999001 [tm, pattern]
			)
		);
	in	strip_and_check
	end
);
=TEX
=SML
fun Ûis_anyÝ (pattern : TERM) : TERM -> bool = (
	let	val dest = dest_any (pattern, "is_any");
	in	fn tm => (dest tm; true) handle Fail _ => false
	end
);
=TEX
=SML
fun Ûmk_anyÝ (pattern : TERM, fun_name : string) : TERM list -> TERM = (
	let	val (f, args) = strip_app pattern;
		val arity_s = string_of_int (length args);
		val ftys = map type_of args;
		fun match_arg_tys i (aty :: more_atys) (fty :: more_ftys) = (
			let	val i = type_match1 i aty fty;
			in	match_arg_tys i more_atys more_ftys
			end
		) | match_arg_tys i [] [] = (i
		) | match_arg_tys _ _ _ = (
			fail fun_name 999002 [fn () => arity_s]
		);
		fun match_and_apply tms = (
			let	val atys = map type_of tms;
				val i = match_arg_tys [] atys ftys;
				val f' = inst [] i f;
			in	list_mk_app (f', tms)
			end
		);
	in	match_and_apply
	end
);
=SML
fun Ûhd2Ý (x :: y :: _ : 'a list) : 'a * 'a = (x, y)
|   hd2 _ = fail "hd2" 999003 [];
=TEX
=SML
val Ûmk_oÝ : TERM * TERM -> TERM = (
	let	val mk = mk_any (¬(t1 : 'b ­ 'c) o (t2 : 'a ­ 'b)®, "mk_o");
	in	fn (t1, t2) => mk [t1, t2]
	end
);
val Ûdest_oÝ : TERM -> TERM * TERM = (
	let	val dest = dest_any (¬(t1 : 'b ­ 'c) o (t2 : 'a ­ 'b)®, "mk_o");
	in	hd2 o dest
	end
);
val Ûis_oÝ : TERM -> bool = is_any ¬(t1 : 'b ­ 'c) o (t2 : 'a ­ 'b)®;
=TEX
\section{SUPPORTING DEFINITIONS}
%%%%
%%%%
=GFT
Ö‰+\
Ö‰*
=SML
open_theory "combin";
new_theory "morphisms";
set_pc"basic_hol1";
=TEX
We define aliases for the I and K combinators useful for working in a typical concrete category
whose morphisms are represented as HOL functions.

%%%%
%%%%
=SML
declare_alias("Ic", ¬CombI : 'a ­ 'a®);
declare_alias("Kc", ¬CombK : 'a ­ 'b ­ 'a®);
=TEX
{\bf Note:} the type ascriptions here and in other alias declarations
in this document give the most general type of 
the constant and are just for documentary purposes. (We are not introducing
 aliases for special instances of the constants.)

\section{REPRESENTING $\lambda$-ABSTRACTIONS WITH COMBINATORS}

\subsection{A Rewrite System}

We assume given a set of unary operators, binary operators and
parametrized operators (such $x^n$ viewed as an operator on $x$ parametrized by $n$) that are primitive morphisms in some concrete category of interest.
We expect the projections $\pi_i : X_1 \times X_2 \To X_i$ to be included amongst the unary operators.
We also assume give some set of constant elements of selected objects
in the category.

We want to convert $\lambda$-abstraction whose body is a first-order formula built using the given operators, constants and the pairing operator $\_, \_)$ into an equivalent function expressed using the combinators of a category with binary products.
We do this using the following rewrite system, where $V$ denotes a {\em variable structure}, i.e., $V$ is a pattern formed from variables using pairing (such that each free variable of $V$ appears exactly once in $V$).

\[
\begin{array}{rcl@{\quad\quad}l}
(\lambda V \bullet x) &\leadsto& \pi^V_x
	& \mbox{if $x \in \Frees(V)$} \\
(\lambda V \bullet y) &\leadsto& \K\,y
	& \mbox{if $y \not\in \Frees(V)$} \\
(\lambda V \bullet c) &\leadsto& \K\,c
	& \mbox{if $c \in \Constant$} \\
(\lambda V \bullet (t_1, t_2)) &\leadsto& \langle(\lambda V\bullet t_1), (\lambda V\bullet t_2)\rangle
	&  \\
(\lambda V \bullet f\,t) &\leadsto& f \circ (\lambda V\bullet t)
	& \mbox{if $f \in \Unary$} \\
(\lambda V \bullet g\,t_1\,t_2) &\leadsto& \Uncurry\,g \circ \langle(\lambda V\bullet t_1), (\lambda V\bullet t_2)\rangle
	& \mbox{if $g \in \Binary$} \\
(\lambda V \bullet h\,t\,p) &\leadsto& (\lambda x\bullet h\,x\,p) \circ (\lambda V\bullet t)
	& \mbox{if $h \in \Parametrized$} \\
\end{array}
\]

Here, if $V$ is a varstruct with a free occurrence of the variable $x$,
$\pi^V_x$ denotes the combination of projections which extracts $x$.
For example $\pi^{((z, x), y)}_x$ is $\pi_2 \circ \pi_1$.
As a special case, $\pi^x_x = \I$ and we may simplify $f \circ I$ to $f$.

%Note that if pairing is implemented by taking `,' to be a binary operator
%of type $\alpha \rightarrow \beta \rightarrow \alpha \times \beta$,
%the rule for pairing is subsumed by the rule for binary operators
%together with a simplification rule $\Upsilon (,) = \iota$.
=TEX
\subsection{Implementation}

We prove template theorems that support the various clauses of the rewrite system.

=SML
val Ûi_rule_thmÝ = save_thm ("i_rule_thm", (
set_goal([], ¬(Ìx· x) = Ic®);
a(rewrite_tac [get_spec¬CombI®]);
pop_thm()
));
=TEX
%%%%

=SML
val Ûo_i_rule_thmÝ = save_thm ("o_i_rule_thm", (
set_goal([], ¬µf·f o Ic = f®);
a(rewrite_tac [get_spec¬CombI®, get_spec¬$o®]);
pop_thm()
));
=TEX
%%%%

=SML
val Ûk_rule_thmÝ = save_thm ("k_rule_thm", (
set_goal([], ¬µc· (Ìx· c) = Kc c®);
a(rewrite_tac [get_spec¬CombK®]);
pop_thm()
));
=TEX
%%%%

=SML
val Ûunary_rule_thmÝ = save_thm ("unary_rule_thm", (
set_goal([], ¬ µf t· (Ìx·f (t x)) = f o t ®);
a(rewrite_tac[o_def]);
pop_thm()
));
=TEX
%%%%

=SML
val Ûpair_rule_thmÝ = save_thm ("pair_rule_thm", (
set_goal([], ¬ µs t· (Ìx·(s x, t x)) = Pair(s, t)®);
a(rewrite_tac[pair_def, o_def, uncurry_def]);
pop_thm()
));
=TEX
%%%%

=SML
val Ûbinary_rule_thmÝ = save_thm ("binary_rule_thm", (
set_goal([], ¬ µf s t· (Ìx·f (s x) (t x)) = Uncurry f o Pair(s, t)®);
a(rewrite_tac[pair_def, o_def, uncurry_def]);
pop_thm()
));
=TEX
%%%%

=SML
val Ûbinary_rule_thm1Ý = save_thm ("binary_rule_thm1", (
set_goal([], ¬ µf c t· (Ìx·f c (t x)) = Uncurry f o Pair ((Ìx·c), t)®);
a(rewrite_tac[pair_def, o_def, uncurry_def]);
pop_thm()
));
=TEX
%%%%
=SML
val Ûparametrized_rule_thmÝ = save_thm ("parametrized_rule_thm", (
set_goal([], ¬ µf s p· (Ìx·f (s x) p) = (Ìx·f x p) o s®);
a(rewrite_tac[o_def]);
pop_thm()
));
=TEX
%%%%
When we instantiate the template theorems, we want to rename type variables to avoid capture, we use the following utility to help with this.
=SML
fun Ûlist_string_variantÝ (avoid : string list) (ss : string list) : string list = (
	let	fun aux (s, (av, res)) = (
			let	val s' = string_variant av s;
			in	(s'::av, s'::res)
			end
		);
	in	rev(snd (revfold aux ss (avoid, [])))
	end
);
=TEX
%%%%
The derived rule 
=INLINEFT
gen_µ_elim
=TEX
\ is µ-elimination combined with renaming of type variables to avoid capture.
=SML
fun Ûgen_µ_elimÝ (tm : TERM) (thm : THM) = (
	let	val tm_tyvs = term_tyvars tm;
		val (asms, conc) = dest_thm thm;
		val thm_tyvs = term_tyvars (mk_list(conc::asms));
		val thm_tyvs' = list_string_variant tm_tyvs thm_tyvs;
		val thm' = inst_type_rule (combine (map mk_vartype thm_tyvs') (map mk_vartype thm_tyvs)) thm;
	in	µ_elim tm thm'
	end
);
=TEX
%%%%
Now
=INLINEFT
morphism\_conv
=TEX
\ implements our rewrite system.
=SML
fun Ûmorphism_convÝ
	{unary : TERM list, binary : TERM list, parametrized : TERM list}
	: CONV = (
	let	val unary_thms = map (all_µ_intro o switch gen_µ_elim unary_rule_thm)
			unary;
		val binary_thms = map (all_µ_intro o switch gen_µ_elim binary_rule_thm)
			binary;
		val binary_thms1 = map (all_µ_intro o switch gen_µ_elim binary_rule_thm1)
			binary;
		val parametrized_thms = map (switch gen_µ_elim parametrized_rule_thm)
			parametrized;
		val i_conv = simple_eq_match_conv i_rule_thm;
		val k_conv = simple_eq_match_conv k_rule_thm;
		val pair_conv = simple_ho_eq_match_conv pair_rule_thm;
		val unary_conv = FIRST_C (map simple_ho_eq_match_conv unary_thms)
			handle Fail _ => fail_conv;
		val binary_conv = FIRST_C (map simple_ho_eq_match_conv (binary_thms @ binary_thms1))
			handle Fail _ => fail_conv;
		val parametrized_conv = FIRST_C (map simple_ho_eq_match_conv parametrized_thms)
			handle Fail _ => fail_conv;
		val simp_conv = simple_eq_match_conv o_i_rule_thm;
		val rec rec_conv = (fn t =>
			((i_conv ORELSE_C
			k_conv ORELSE_C
			(pair_conv THEN_C RAND_C(RANDS_C(TRY_C rec_conv))) ORELSE_C
			(unary_conv THEN_TRY_C RIGHT_C rec_conv) ORELSE_C
			(binary_conv THEN_C RIGHT_C (RAND_C(RANDS_C (TRY_C rec_conv)))) ORELSE_C
			(parametrized_conv THEN_C RIGHT_C (TRY_C rec_conv)))
				AND_OR_C simp_conv) t
		);
	in	Ì_unpair_conv AND_OR_C rec_conv
	end
);
=TEX
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Now we build the basic morphismhood tactic.
It expects a goal of the form
=INLINEFT
f  (X, Y) Morphism
=TEX
.
The tactic begins by È-expanding $f$ if it not already an abstraction.
=SML

val È_expand_thm : THM = prove_rule[]¬µf· f = Ìz· f z®;

val  ÛÈ_expand_convÝ : CONV = (fn tm => (
	if	is_Ì tm
	then	fail_conv
	else	simple_eq_match_conv È_expand_thm) tm);

=TEX
The theorem is parametrized by a list of theorems that are used
as an initial set of rewrite rules. For convenience, we convert
any paired abstractions in these theorems into simple abstractions,
which makes them more general as rewrite rules.
=SML

val Ûunpair_rewrite_tacÝ : THM list -> TACTIC = 
	rewrite_tac o map (conv_rule (TRY_C (MAP_C Ì_unpair_conv)));
=TEX
Now the tactic. After the È-expansion and rewriting discussed above,
it converts the function into combinator form.
It then goes through a cycle of backchaining with implicative facts
applying the supplied tactic to guess
existential witnesses, then stripping and rewriting with the basic facts.
=SML
fun Ûbasic_morphism_tacÝ
	{
		unary : TERM list,
		binary : TERM list,
		parametrized : TERM list,
		facts : THM list,
		witness_tac : TACTIC} : THM list -> TACTIC = (
	let	val m_conv = morphism_conv {unary = unary, binary = binary, parametrized = parametrized};
		val is_rule = is_´ o snd o strip_µ o concl;
		val rule_thms = facts drop (not o is_rule);
		val axiom_thms = facts drop is_rule;
	in	fn rw_thms =>
			TRY (conv_tac (LEFT_C È_expand_conv))
		THEN	TRY (unpair_rewrite_tac rw_thms)
		THEN	conv_tac (LEFT_C m_conv)	
		THEN 	(REPEAT o CHANGED_T) (
				(TRY o bc_tac) rule_thms
			THEN	TRY witness_tac
			THEN	REPEAT strip_tac
			THEN	(TRY o rewrite_tac) axiom_thms)
	end
);
=TEX
The following constructs witnesses to objecthood using a supplied list of object constructors based on the type of the desired witness.
=SML
fun Ûobject_by_typeÝ (ocs : TERM list) : TYPE -> TERM = (
	let	fun preprocess acc [] = acc
		|   preprocess acc (oc :: more) = (
			let	val rev_tys = rev(strip_­_type (type_of oc));
				val res_ty = hd (rev_tys);
				val arg_tys = rev (tl rev_tys);
			in	preprocess ((res_ty,  (oc, arg_tys)) :: acc) more
			end
		);
		val table = preprocess [] ocs;
		fun solve [] ty = fail "object_by_type" 1005 []
		|   solve ((res_ty, (oc, arg_tys)) :: more) ty = (
			let	val recur = solve table;
				val tysubs = type_match ty res_ty;
				val args = map (recur o inst_type tysubs) arg_tys;
				val ioc = inst [] tysubs oc;
			in	list_mk_app(ioc, args)
			end	handle Fail _ => solve more ty
		);
	in	solve table
	end
);
=TEX
%%%%

=SML
fun Û¶_object_by_type_tacÝ (ocs : TERM list) : TACTIC = (
	let	val witness_by_type = object_by_type ocs;
	in	fn gl as (_, conc) => 
		let	val (x, _) = dest_simple_¶ conc;
		in	(simple_¶_tac o witness_by_type o type_of) x gl
		end
	end
);

=TEX
%%%%
\section{PROVING CONTINUITY}
We set up a theory to work in.
Our examples will use the topology on the real line and the complex plane.
=SML
open_theory "morphisms";
new_theory"topology-examples";
new_parent "topology_¯";
new_parent "Ö";
set_merge_pcs ["basic_hol1", "'¯", "'sets_alg"];
=TEX
It is nice to have short names for the topologies.
=SML
declare_alias("O‰R", ¬Open‰R®);
declare_alias("O‰C", ¬Open‰C®);
=TEX
Now we give the theorems asserting that various basic functions are indeed continuous with respect to specific topologies.

=SML
val Ûminus_continuous_axiom_thmÝ = save_thm( "minus_continuous_axiom_thm", (
set_goal([], ¬~  (O‰R, O‰R) Continuous®);
a(rewrite_tac[continuous_cts_at_¯_thm, minus_cts_thm]);
pop_thm()
));


=TEX
=SML
val Ûexp_sin_cos_continuous_axiom_thmÝ = save_thm( "exp_sin_cos_continuous_axiom_thm", (
set_goal([], ¬
	Exp  (O‰R, O‰R) Continuous
±	Sin  (O‰R, O‰R) Continuous
±	Cos  (O‰R, O‰R) Continuous
®);
a(rewrite_tac[continuous_cts_at_¯_thm, exp_cts_thm, sin_cos_cts_thm]);
pop_thm()
));


=TEX
=SML
val Ûplus_continuous_axiom_thmÝ = plus_continuous_¯_¸_¯_thm;
val Ûtimes_continuous_axiom_thmÝ = times_continuous_¯_¸_¯_thm;

=TEX
=SML
=TEX
=SML
val Û¯_î_exp_continuous_axiom_thmÝ = save_thm( "¯_î_exp_continuous_axiom_thm", (
set_goal([], ¬µn : î· (Ìx· x ^ n)  (O‰R, O‰R) Continuous®);
a(rewrite_tac[continuous_cts_at_¯_thm, ¯_î_exp_cts_thm]);
pop_thm()
));

=TEX
Next we give the backchaining theorems.
=SML
val Ûpair_continuous_rule_thmÝ = save_thm( "pair_continuous_rule_thm", (
set_goal([], ¬µ Ò Ó Ô f g·
	Ò  Topology ± Ó  Topology ± Ô  Topology ±
	f  (Ò, Ó) Continuous ± g  (Ò, Ô) Continuous ´
	Pair (f, g)  (Ò, Ó ¸‰T Ô) Continuous
®);
a(REPEAT strip_tac THEN rewrite_tac[pair_def]
	THEN ALL_FC_T rewrite_tac[product_continuous_thm]);
pop_thm()
));

=TEX
=SML
val Ûo_continuous_rule_thmÝ = save_thm( "o_continuous_rule_thm", (
set_goal([], ¬µ Ò Ó Ô f g·
	Ò  Topology ± Ó  Topology ± Ô  Topology ±
	f  (Ò, Ó) Continuous ± g  (Ó, Ô) Continuous ´
	g o f  (Ò, Ô) Continuous
®);
a(REPEAT strip_tac THEN rewrite_tac[
		prove_rule[o_def] ¬µf g· g o f = Ìx· g(f x)®]
	THEN ALL_FC_T rewrite_tac[comp_continuous_thm]);
pop_thm()
));
=TEX

=SML
val Ûfst_continuous_rule_thmÝ = fst_continuous_thm;
val Ûsnd_continuous_rule_thmÝ = snd_continuous_thm;

=TEX
=SML
val Ûi_continuous_rule_thmÝ = save_thm( "i_continuous_rule_thm", (
set_goal([], ¬µÔ· Ô  Topology ´ Ic  (Ô, Ô) Continuous®);
a(REPEAT strip_tac THEN rewrite_tac[
		prove_rule[get_spec¬Ic®] ¬Ic = Ìx· x®]
	THEN ALL_FC_T rewrite_tac[id_continuous_thm]);
pop_thm()
));

=TEX
=SML
val Ûk_continuous_rule_thmÝ = save_thm( "k_continuous_rule_thm", (
set_goal([], ¬µ Ó Ô c·
	Ó  Topology ± Ô  Topology ± c  Space‰T Ô ´
	Kc c  (Ó, Ô) Continuous®);
a(REPEAT strip_tac THEN rewrite_tac[
		prove_rule[get_spec¬Kc®] ¬µc·Kc c = Ìx· c®]
	THEN ALL_FC_T rewrite_tac[const_continuous_thm]);
pop_thm()
));


=TEX
We collect the theorems together.

=SML

val Ûcontinuity_fact_thmsÝ : THM list = [
	open_¯_topology_thm,
	space_t_¯_thm,
	minus_continuous_axiom_thm,
	exp_sin_cos_continuous_axiom_thm,
	plus_continuous_axiom_thm,
	times_continuous_axiom_thm,
	¯_î_exp_continuous_axiom_thm,
	product_topology_thm,
	fst_continuous_rule_thm,
	snd_continuous_rule_thm,
	i_continuous_rule_thm,
	k_continuous_rule_thm,
	pair_continuous_rule_thm,
	o_continuous_rule_thm];

=TEX
Notes:

Put ML bindings for spec of Exp etc. in wrk072.

Sort out parent relationships

=IGN
=SML
val continuity_params = {
	unary = [¬~ : ¯ ­ ¯®, ¬Exp : ¯ ­ ¯®, ¬Sin : ¯ ­ ¯®,
		¬Cos : ¯ ­ ¯®, ¬Fst®, ¬Snd®] : TERM list,
	binary = [¬$+ : ¯ ­ ¯ ­ ¯®, ¬$* : ¯ ­ ¯ ­ ¯®],
	parametrized = [¬$^ : ¯ ­ î ­ ¯®],
	facts = continuity_fact_thms,
	witness_tac = ¶_object_by_type_tac [¬O‰R®, ¬O‰R ¸‰T O‰R®]};

val Ûbasic_continuity_tacÝ = basic_morphism_tac continuity_params;
=TEX
=SML

set_goal([], ¬(Ìx· Sin(Cos (Exp x)))  (O‰R, O‰R) Continuous®);

a(basic_continuity_tac[]);

val thm2 = pop_thm();

=TEX
=SML

set_goal([], ¬(Ìx·(Sin(Exp x), Cos (Exp x)))  (O‰R, O‰R ¸‰T O‰R) Continuous®);

a(basic_continuity_tac[]);

val thm3 = pop_thm();

=TEX
=SML

set_goal([], ¬(Ìx· 2.0 * (x ^ 4))  (O‰R, O‰R) Continuous®);

a(basic_continuity_tac[]);

val thm4 = pop_thm();


=TEX
=SML


set_goal([], ¬(Ìx· Exp(¯Ö 2. * ¯Ö Ð * I‰C * ¯Ö x))  (O‰R, O‰C) Continuous®);
(*

a(rewrite_tac[Ö_exp_def, ¯Ö_def, Ö_i_def, Ö_times_def, open_Ö_def]);
a(conv_tac(LEFT_C ¯_morphism_conv));

*)
a(basic_continuity_tac[Ö_exp_def, ¯Ö_def, Ö_i_def, Ö_times_def, open_Ö_def]);

val thm5 = pop_thm();
=TEX
=SML


set_goal([], ¬Exp  (Open‰C, Open‰C) Continuous®);
a(basic_continuity_tac[Ö_exp_def, ¯Ö_def, ¯É_def, Ö_times_def, open_Ö_def]);

val thm6 = pop_thm();
=TEX
\section{PROVING GROUP HOMOMORPHISMHOOD}
=SML
open_theory "morphisms";
new_theory "group-examples";
new_parent "group_egs";
set_merge_pcs["basic_hol1", "'sets_alg", "'¯", "'Ö"];
=TEX
Now we give the theorems asserting that various basic functions are linear.

=SML
val Ûminus_homomorphism_thmÝ = save_thm( "minus_homomorphism_thm", (
set_goal([], ¬~  Homomorphism(¯‰+, ¯‰+)®);
a(rewrite_tac[¯_additive_def, group_ops_def, homomorphism_def, ¸_group_def, ¸_def]
	THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

val Ûplus_homomorphism_thmÝ = plus_¯_additive_homomorphism_thm;
val Ûconst_times_homomorphism_thmÝ = save_thm( "const_times_homomorphism_thm", (
set_goal([], ¬µc· $* c  Homomorphism(¯‰+, ¯‰+)®);
a(strip_tac THEN conv_tac(LEFT_C È_expand_conv));
a(rewrite_tac[linear_homomorphism_thm]);
pop_thm()
));

val Ûtimes_const_homomorphism_thmÝ = once_rewrite_rule[¯_times_comm_thm] linear_homomorphism_thm;

val ÛÖ_const_times_homomorphism_thmÝ = save_thm( "Ö_const_times_homomorphism_thm", (
set_goal([], ¬µc· $* c  Homomorphism(¯‰+ ¸‰G ¯‰+, ¯‰+ ¸‰G ¯‰+)®);
a(strip_tac THEN conv_tac(LEFT_C È_expand_conv));
a(rewrite_tac[rewrite_rule[Ö_eq_¯_¸_¯_thm]Ö_linear_homomorphism_thm]);
pop_thm()
));

val ÛÖ_times_const_homomorphism_thmÝ = once_rewrite_rule[Ö_times_comm_thm] Ö_linear_homomorphism_thm;

val Û¯Ö_homomorphism_thmÝ = save_thm( "¯Ö_homomorphism_thm", (
set_goal([], ¬¯Ö  Homomorphism (¯‰+, ¯‰+ ¸‰G ¯‰+)®);
a(rewrite_tac[¯Ö_def, homomorphism_def, ¸_group_def, ¯_additive_ops_thm, group_ops_def, ¸_def]);
pop_thm()
));
=TEX
Some of the following material should be in WRK068.
=SML
val ÛÖ_conj_eq_0_thmÝ = save_thm( "Ö_conj_eq_0_thm", (
set_goal([], ¬µz· z ›_  = îÖ 0 ¤ z = îÖ 0®);
a(rewrite_tac[Ö_conj_def, îÖ_def, ¯Ö_def]THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));
=TEX
=SML

val ÛÖ_conj_additive_homomorphism_thmÝ = save_thm( "Ö_conj_additive_homomorphism_thm", (
set_goal([], ¬$›_   Homomorphism (¯‰+ ¸‰G ¯‰+, ¯‰+ ¸‰G ¯‰+)®);
a(rewrite_tac[eq_sym_rule Ö_eq_¯_¸_¯_thm]);
a(rewrite_tac[homomorphism_def, Ö_additive_def, group_ops_def,
	Ö_conj_plus_homomorphism_thm]);
pop_thm()
));

val ÛÖ_conj_multiplicative_homomorphism_thmÝ = save_thm( "Ö_conj_multiplicative_homomorphism_thm", (
set_goal([], ¬$›_   Homomorphism (Ö‰*, Ö‰*)®);
a(rewrite_tac[homomorphism_def, Ö_additive_def, group_ops_def,
	Ö_conj_times_homomorphism_thm, Ö_conj_eq_0_thm]);
pop_thm()
));

=TEX
Next we give the backchaining theorems.
=SML
val Ûpair_homomorphism_rule_thmÝ = save_thm( "pair_homomorphism_rule_thm", (
set_goal([], ¬µ G H K f g·
		G  Group ± H  Group ± K  Group ±
		f  Homomorphism (G, H) ± g  Homomorphism (G, K)
	´ Pair(f, g)  Homomorphism (G, H ¸‰G K)
®);
a(REPEAT strip_tac THEN rewrite_tac[pair_def]
	THEN ALL_FC_T rewrite_tac[product_homomorphism_thm]);
pop_thm()
));

=TEX
=SML
val Ûo_homomorphism_rule_thmÝ = save_thm( "o_homomorphism_rule_thm", (
set_goal([], ¬µ G H K f g·
		G  Group ± H  Group ± K  Group ±
		f  Homomorphism (G, H) ± g  Homomorphism (H, K)
	´ g o f  Homomorphism (G, K)
®);
a(REPEAT strip_tac THEN rewrite_tac[
		prove_rule[o_def] ¬µf g· g o f = Ìx· g(f x)®]
	THEN ALL_FC_T rewrite_tac[comp_homomorphism_thm]);
pop_thm()
));


val Ûunit_¯_additive_thmÝ = save_thm( "unit_¯_additive_thm", (
set_goal([], ¬Unit ¯‰+ = 0.0®);
a(rewrite_tac[¯_additive_def, group_ops_def]);
pop_thm()
));

val Ûk_zero_homomorphism_rule_thmÝ = 
	rewrite_rule[¯_additive_group_thm, unit_¯_additive_thm,
		prove_rule[get_spec¬Kc®] ¬µc· (Ìx· c) = Kc c®] (
		list_µ_elim[¬G:'a GROUP®, ¬¯‰+®] unit_homomorphism_thm);

=TEX

=SML
val Ûfst_homomorphism_rule_thmÝ = fst_homomorphism_thm;
val Ûsnd_homomorphism_rule_thmÝ = snd_homomorphism_thm;

=TEX
=SML
val Ûi_homomorphism_rule_thmÝ = save_thm( "i_homomorphism_rule_thm", (
set_goal([], ¬µG· G  Group ´ Ic  Homomorphism(G, G)®);
a(REPEAT strip_tac THEN rewrite_tac[
		prove_rule[get_spec¬Ic®] ¬Ic = Ìx· x®]
	THEN ALL_FC_T rewrite_tac[id_homomorphism_thm]);
pop_thm()
));

=TEX
=SML

val Ûk_homomorphism_rule_thmÝ = save_thm( "k_homomorphism_rule_thm", (
set_goal([], ¬µG H·
		G  Group ± H  Group
	´	Kc (Unit H)  Homomorphism(G, H)
®);
a(REPEAT strip_tac THEN rewrite_tac[
		prove_rule[get_spec¬Kc®] ¬µc·Kc c = Ìx· c®]
	THEN ALL_FC_T rewrite_tac[unit_homomorphism_thm]);
pop_thm()
));


=TEX
We collect the theorems together.

=SML

val Ûhomomorphism_fact_thmsÝ : THM list = [
	Ö_eq_¯_¸_¯_thm,
	Ö_const_times_homomorphism_thm,
	Ö_conj_additive_homomorphism_thm,
	Ö_conj_multiplicative_homomorphism_thm,
	¯Ö_homomorphism_thm,
	rewrite_rule[Ö_eq_¯_¸_¯_thm] Ö_exp_homomorphism_thm,
	¯_additive_group_thm,
	Ö_multiplicative_group_thm,
	minus_homomorphism_thm,
	plus_homomorphism_thm,
	const_times_homomorphism_thm,
	times_const_homomorphism_thm,
	Ö_times_const_homomorphism_thm,
	plus_homomorphism_thm,
	k_zero_homomorphism_rule_thm,
	product_group_thm,
	pair_homomorphism_rule_thm,
	o_homomorphism_rule_thm,
	fst_homomorphism_rule_thm,
	snd_homomorphism_rule_thm,
	i_homomorphism_rule_thm,
	k_homomorphism_rule_thm
];

val homomorphism_params = {
	unary = [¬~ : ¯ ­ ¯®, ¬$* c: ¯ ­ ¯®,
		¬$* c: Ö ­ Ö®, ¬Exp: Ö ­ Ö®,
		¬$›_ : Ö ­ Ö®],
	binary = [¬$+ : ¯ ­ ¯ ­ ¯®],
	parametrized = [¬$* : ¯ ­ ¯ ­ ¯®, ¬$* : Ö ­ Ö  ­ Ö®],
	facts = homomorphism_fact_thms,
	witness_tac = ¶_object_by_type_tac [¬¯‰+®, ¬¯‰+ ¸‰G ¯‰+®]};

val Ûbasic_homomorphism_tacÝ = basic_morphism_tac homomorphism_params;

=TEX
=SML
set_goal([], ¬(Ìx·2.0 * x)  Homomorphism(¯‰+, ¯‰+)®);
a(basic_homomorphism_tac[]);
val thm1 = pop_thm();
=TEX
=SML
set_goal([], ¬(Ì(x, y)·(a*x+c*y, b*x+d*y))  Homomorphism(¯‰+ ¸‰G ¯‰+, ¯‰+ ¸‰G ¯‰+)®);
a(basic_homomorphism_tac[]);
val thm2 = pop_thm();
=TEX
=SML
set_goal([], ¬(Ì(x, y)·(a*x*u, 0.0))  Homomorphism(¯‰+ ¸‰G ¯‰+, ¯‰+ ¸‰G ¯‰+)®);
a(basic_homomorphism_tac[]);
val thm3 = pop_thm();


=TEX
=SML

set_goal([], ¬(Ìx· Exp(¯Ö 2. * ¯Ö Ð * I‰C * ¯Ö x))  Homomorphism(¯‰+, Ö‰*)®);

a(basic_homomorphism_tac[]);

val thm5 = pop_thm();

=TEX
=SML



set_goal([], ¬(Ìx· Fst(Exp(x)›_))  Homomorphism(¯‰+ ¸‰G ¯‰+, Ö‰*)®);

a(basic_homomorphism_tac[]);

(* fails *)
drop_main_goal();

=IGN


{\let\Section\section
\def\section#1{\Section{#1}\label{TheoryListing}}
\include{wrk083.th}
}  %\let

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document}

{\HOLindexOff
%%%%
%%%%
%%%%
%%%%

} % matches turning off of HOL index entries.
=TEX
%%%%
%%%%
=SML
output_theory{out_file="wrk083.th.doc", theory="-"};
=TEX
The intention is that theorems should always have an outer universal quantifier if necessary rather than free variables
and that all variables bound by logical quantifiers should
actually be used.
The following code reports on theorems that fail to comply.
=SML
fun Ûunused_qvsÝ (tm : TERM) : TERM list = (
	let	fun drop_fst (t :: ts) v = (
			if	t =$ v
			then	ts
			else	t :: drop_fst ts v
		) | drop_fst [] _ = [];
		fun dest_quant t = (
			let	val (vs, b) = dest_µ t
				handle Fail _ => dest_¶ t
				handle Fail _ => dest_¶‰1 t;
			in	(frees vs, b)
			end
		);
		fun aux (acc, tm) = (
			(dest_var tm; drop_fst acc tm)
		handle Fail _ => 
			(dest_const tm; acc)
		handle Fail _ =>
			(aux (dest_quant tm))
		handle Fail _ =>
			let	val (v, b) = dest_simple_Ì tm;
			in	if	v mem acc
				then	v :: aux (acc less v, b)
				else	aux (acc, b)
			end
		handle Fail _ =>
			let 	val (f, x) = dest_app tm;
			in	aux (aux(acc, f), x)
			end
		);
	in	aux ([], tm)
	end
);
fun Ûthm_unused_qvsÝ (thm : THM) : TERM list = (
	let	val tuple = fold mk_pair (asms thm) (concl thm);
	in	unused_qvs tuple
	end
);
fun Ûcheck_thmsÝ (thyn : string) : unit = (
	let	val thy = if thyn = "-" then get_current_theory_name () else thyn;
		val thms = get_thms thy;
		val fv_bad_thms = thms drop (is_nil o thm_frees o snd);
		val bv_bad_thms = thms drop (is_nil o thm_unused_qvs o snd);
		fun aux (ns, _) = (
			output(ExtendedIO.std_err,
				translate_for_output (hd ns));
			output(ExtendedIO.std_err, "\n")
		);
	in	(case fv_bad_thms of
			[] => ()
		|	_ => (
			output(ExtendedIO.std_err,
		"**** The following theorems in theory \"" ^ thy
			^"\" have one or more free variables:\n");
			app aux fv_bad_thms
		));
		(case bv_bad_thms of
			[] => ()
		|	_ => (
			output(ExtendedIO.std_err,
		"**** The following theorems in theory \"" ^ thy
			^"\" have one or more unused quantified variables:\n");
			app aux bv_bad_thms
		));
		(case (fv_bad_thms, bv_bad_thms) of
			([], []) => (
			output(ExtendedIO.std_err,
		"**** Theorem quality control checks for theory \"" ^ thy
			^"\" all passed\n")
		) |	_ => ())
	end
);
check_thms "-";
(*
val _ = app check_thms (get_descendants "min");
*)
=TEX
\end{document}
=IGN

=TEX
=IGN
val ¯_morphism_conv = morphism_conv {
	unary = [¬~ : ¯ ­ ¯®, ¬Exp : ¯ ­ ¯®, ¬Sin : ¯ ­ ¯®,
		¬Cos : ¯ ­ ¯®, ¬Fst®, ¬Snd®] : TERM list,
	binary = [¬$+ : ¯ ­ ¯ ­ ¯®, ¬$* : ¯ ­ ¯ ­ ¯®],
	parametrized = [¬$^ : ¯ ­ î ­ ¯®]};
¯_morphism_conv ¬Ì xy· Snd xy * Snd xy + 1.0®;
¯_morphism_conv ¬Ì(x, y)·x + y * y + 1.0®;
¯_morphism_conv ¬Ì(x:¯, y)·(x + y, x * y)®;
¯_morphism_conv ¬Ì((z, x), y)·x®;
simple_ho_match ¬Ìx:'a ¸ 'b·Snd x® ¬Ìy:'b· Snd (t y)®;
¯_morphism_conv ¬Ì(x:¯, y)· x^3 * y®;
¯_morphism_conv ¬Ì(x:¯, y)· (x, x+y, x^3 * y)®;
¯_morphism_conv ¬Ìx· (Cos x, Sin x)®;
¯_morphism_conv ¬Ì(x, y) : ¯ ¸ ¯· Exp(x + y)®;
¯_morphism_conv ¬Ì(x, y) : ¯ ¸ ¯· (a*x + c*y, c*x + d*y)®;
¯_morphism_conv ¬Ìx : ¯· 2.0 * x ^ 4®;
=TEX
=IGN
=IGN

val ¯_homomorphism_morphism_conv =  morphism_conv {
	unary = [¬~ : ¯ ­ ¯®, ¬$* c: ¯ ­ ¯®, ¬$* c: Ö ­ Ö®, ¬Exp: Ö ­ Ö®] : TERM list,
	binary = [¬$+ : ¯ ­ ¯ ­ ¯®],
	parametrized = [¬$* : ¯ ­ ¯ ­ ¯®, ¬$* : Ö ­ Ö  ­ Ö®]};

¯_homomorphism_morphism_conv ¬Ìx· Exp(¯Ö 2. * ¯Ö Ð * I‰C * ¯Ö x)®;
