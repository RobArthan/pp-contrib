=IGN
********************************************************************************
wrk080.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http:/www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
wrk080.doc,v 1.29 2010/03/03 11:35:32 rda Exp
********************************************************************************
=IGN
pp_make_database -f -p hol maths_egs
docsml wrk080
xpp wrk080.doc -d maths_egs -i wrk080 &
doctex wrk080 wrk080.th; texdvi -b wrk080; texdvi wrk080; texdvi wrk080
=TEX
\documentclass[11pt,a4paper,leqno]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\def\Lim{\mbox{{\sf lim}}}
\def\LimInf{\mbox{{\sf lim inf}}}
\def\LimSup{\mbox{{\sf lim sup}}}

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}

\def\LogName{\mbox{{\sf log}}}
\def\Log#1{\LogName(#1)}

\def\SinName{\mbox{{\sf sin}}}
\def\Sin#1{\SinName(#1)}

\def\CosName{\mbox{{\sf cos}}}
\def\Cos#1{\CosName(#1)}

\def\Abs#1{|#1|}

\def\SizeName{\#}
\def\Size#1{\#\left(#1\right)}

\tabstop=0.4in
\def\ThmsI#1{%
{\vertbarfalse#1}}

\def\ThmsII#1#2{%
{\vertbarfalse
\begin{minipage}[t]{0.48\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.48\hsize}
#2
\end{minipage}}}

\def\ThmsIII#1#2#3{%
{\vertbarfalse
\begin{minipage}[t]{0.32\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#2
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#3
\end{minipage}}}

\def\Hide#1{\relax}

\makeindex
\title{Mathematical Case Studies: \\ --- \\ 
Universal Algebra in Action: \\
Semigroups and Groups}
\author{Rob Arthan}
\makeindex
\author{R.D. Arthan \\ Lemma 1 Ltd. \\ rda@lemma-one.com}
\date{\FormatDate{2010/03/03 11:35:32%
}}

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
This {\ProductHOL} script contains definitions and proofs concerning
semigroups and groups demonstrating the universal algebra framework.

\end{abstract}
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd \number\year \\
Reference: LEMMA1/HOL/WRK080; issue $Revision: 1.2 $%
% Don't forget to restore the above to dollar Revision: dollar when editing, if necessary.
% (The makefile uses -kv when it checks documents out). 


\end{centering}
\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
\tableofcontents
%\newpage
%\subsection{Document cross references}

\newpage
\subsection*{To Do}
A great deal of work remains.



{\raggedright
\bibliographystyle{fmu}
\bibliography{fmu}
} %\raggedright
%%%%
%%%%
%%%%
%%%%
\newpage
\section{INTRODUCTION}
%%%%
%%%%
%%%%
%%%%
The companion document \cite{LEMMA1/HOL/WRK080} defines
a type capable of representing any algebraic variety
(i.e., a finitary algebraic structure defined by a set
of equational axioms).
In this document we give examples of how one can form
subtypes of this type to represent particular varieties.
This is part of a series of case studies in formalising some basic pure  mathematics in {\ProductHOL}.
Other parts of the case study deal, for example, with real analysis \cite{LEMMA1/HOL/WRK066} and with topology \cite{LEMMA1/HOL/WRK067}.


This document is a {\Product} literate script. It contains all the metalanguage (ML) commands required to create several theories, populate them with the formal definitions and prove and record all the theorems.
The descriptions include all the formal definitions in the Z-like concrete syntax for specification in {\ProductHOL}.
and a discussion of the theorems that have been proved about the objects specified.
There is an index to the formal definitions and the theory listings in section~\ref{index}.

%%%%
%%%%
%%%%
%%%%
\section{GENERAL PRINCIPLES}
We plan eventually to construct polymorphic types that represent a wide range of algebraic varieties. These will
all be defined as subtypes of the polymorphic type of
general algebras
=INLINEFT
'a ALGEBRA
=TEX
\ defined in \cite{LEMMA1/HOL/WRK080}.
For each variety, we also define a universal variety
that can be viewed the product of all the varieties in
the class.
Since it is pleasant to reuse operator symbols in different
contexts (e.g., $+$ in rings, fields and polynomial rings), we adopt the conventions of table \ref{tags} for single letter tags for some well-known varieties.
So addition in the universal ring will be $+‰A$ while addition in the universal field will $+‰F$.
The tags are also used to distinguish the representation and abstraction functions for the subtypes.
This will probably be extended later to allocate two letter tags for other varieties.

\begin{table}
\begin{center}
\begin{tabular}{|l|l|p{0.4\hsize}|}\hline
Tag & Variety & Notes \\\hline\hline
A	& rings			& French: {\it anneaux}; R taken by reals \\\hline
B	& boolean algebras	& \\\hline
C	& complex numbers	& \\\hline
D	& integral domains	& \\\hline
E	&			& \\\hline
F	& fields		& Or use K for German: k\"{o}rper \\\hline
G	& group			& \\\hline
H	&			& \\\hline
I	&			& \\\hline
J	&			& \\\hline
K	&			& \\\hline
L	& lattices		& \\\hline
M	& monoids		& \\\hline
N	&			& {\ProductHOL} uses no subscript for operations on î\\\hline
O	&			& \\\hline
P	& polynomial rings	& \\\hline
Q	& rationals		& \\\hline
R	& reals	& (Already extant in {\ProductHOL}) \\\hline
S	& semigroup		& \\\hline
T	&			& \\\hline
U	&			& \\\hline
V	& real vector spaces	& use VS for abstract vector spaces \\\hline
W	&			& \\\hline
X	&			& \\\hline
Y	&			& \\\hline
Z	& integers		& German: {\it zahlen} (Already extant in {\ProductHOL}) \\\hline
\end{tabular}
\end{center}
\caption{A tagging convention for selected varieties}
\label{tags}
\end{table}

\section{SEMIGROUPS}

First of all, we must give the the ML commands to  introduce the new theory ``semigroups'' as a child of the theory ``algebras'' of universal algebras.

=TEX
%%%%
%%%%
%%%%
%%%%
=SML
force_delete_theory"semigroups" handle Fail _ => ();
open_theory"algebras";
new_theory"semigroups";
set_merge_pcs["basic_hol1", "'sets_alg"];
=TEX

%%%%
%%%%

\subsection{Semigroups}
The following function gives the representation of the equation that
the $p$-th binary operator $\mu_{p2}$ in an algebra is associative (see universal algebra document and note that at the leaves of an expression
tree the odd-numbered nodes are the variables and the even-numbered nodes are the constant symbols).

=SML
declare_infix(310, "oo");
=TEX

¹HOLCONST
Ü ÛAssocEqÝ : î ­ EQUATION
÷üüüüüü
Ü µp·	AssocEq p =
Ü	let	v i = MkTree(2*i + 1, [])
Ü	and	x oo y = MkTree(p, [x; y])
Ü	in	((v 0 oo v 1) oo v 2, v 0 oo (v 1 oo v 2))
°

A semigroup is an algebra in which the 0-th binary operator is required to be associative.


¹HOLCONST
Ü ÛSemigroupAxiomsÝ : EQUATION SET
÷üüüüüü
Ü SemigroupAxioms = {AssocEq 0}
°


We define the type of semigroups and the abstraction and representation functions for it as a subtype of the type of algebras.

=SML
new_type_defn(["SEMIGROUP", "semigroup_def"], "SEMIGROUP", ["'a"], (
set_goal([], ¬¶sg· (ÌA· A  Variety SemigroupAxioms) sg
®);
a(rewrite_tac[variety_type_lemmas]);
pop_thm()));
=TEX


¹HOLCONST
Ü ÛRep‰SÝ	: 'a SEMIGROUP ­ 'a ALGEBRA;
Ü ÛAbs‰SÝ 	: 'a ALGEBRA ­ 'a SEMIGROUP
÷üüüüüü
Ü(µS·	Abs‰S(Rep‰S S) = S) ±
Ü(µK·	K  Variety SemigroupAxioms ¤ Rep‰S(Abs‰S K) = K)
°


The elements of the universal semigroup will have the following type:

=SML
new_type_defn(["UNIV_SEMIGROUP_ELEMENT"], "UNIV_SEMIGROUP_ELEMENT", ["'a"], (
set_goal([], ¬¶f· (Ìg· g  Safe SemigroupAxioms) f
®);
a(rewrite_tac[variety_type_lemmas]);
pop_thm()));
=TEX

The following are the abstraction and representation functions for the elements of the universal semigroup as a subtype of the carrier type of the universal algebra for the semigroup axioms.

¹HOLCONST
Ü ÛRep‰USEÝ	: 'a UNIV_SEMIGROUP_ELEMENT ­ ('a ALGEBRA ­ 'a);
Ü ÛAbs‰USEÝ 	: ('a ALGEBRA ­ 'a) ­ 'a UNIV_SEMIGROUP_ELEMENT
÷üüüüüü
Ü(µx·	Abs‰USE(Rep‰USE x) = x) ±
Ü(µf·	f  Safe SemigroupAxioms ¤ Rep‰USE(Abs‰USE f) = f)
°

Now we can define the universal semigroup:

¹HOLCONST
Ü ÛUnivSemigroupÝ : 'a UNIV_SEMIGROUP_ELEMENT SEMIGROUP
÷üüüüüü
Ü UnivSemigroup =
Ü Abs‰S (MkAlgebra
Ü	Universe
Ü	(Ìp a· Abs‰USE(Op(UnivAlgebra SemigroupAxioms) p (Map Rep‰USE a)))
Ü	Arbitrary)
°
=IGN
type_of ¬Abs‰S®;
type_of ¬Abs‰USE®;

=TEX

Now we can define the universal semigroup operation:
=SML
declare_infix(310, ".‰S");
=TEX

¹HOLCONST
Ü Û$.‰SÝ :
Ü	'a UNIV_SEMIGROUP_ELEMENT
Ü ­	'a UNIV_SEMIGROUP_ELEMENT
Ü ­	'a UNIV_SEMIGROUP_ELEMENT
÷üüüüüü
Ü µ x y· x .‰S y = Op (Rep‰S UnivSemigroup) 0 [x; y]
°


%%%%
%%%%
%%%%
%%%%
\section{MONOIDS}

We must give the the ML commands to  introduce the new theory ``monoids'' as a child of the theory ``semigroups''.

=TEX
%%%%
%%%%
%%%%
%%%%
=SML
force_delete_theory"monoids" handle Fail _ => ();
open_theory"semigroups";
new_theory"monoids";
set_merge_pcs["basic_hol1", "'sets_alg"];
=TEX

%%%%
%%%%

The following function gives the representation of the equations asserting that
the $p$-th nullary operator $\mu_{p0}$ in an algebra is
a two-sided unit for the $q$-th binary operator.

=SML
declare_infix(310, "oo");
=TEX

¹HOLCONST
Ü ÛUnitEqÝ : î ­ î ­ EQUATION SET
÷üüüüüü
Ü µp q·	UnitEq p q =
Ü	let	v i = MkTree(2*i + 1, [])
Ü	and	e = MkTree(p, [])
Ü	and	x oo y = MkTree(q, [x; y])
Ü	in	{(e oo v 0, v 0); (v 0 oo e, v 0)}
°

A monoid satisfies the semigroup axioms and and has the nullary operator $\mu_{p0}$ as two-sided unit:


¹HOLCONST
Ü ÛMonoidAxiomsÝ : EQUATION SET
÷üüüüüü
Ü MonoidAxioms = SemigroupAxioms À UnitEq 0 0
°


We define the type of monoids and the abstraction and representation functions for it as a subtype of the type of algebras.

=SML
new_type_defn(["MONOID", "monoid_def"], "MONOID", ["'a"], (
set_goal([], ¬¶mnd· (ÌA· A  Variety MonoidAxioms) mnd
®);
a(rewrite_tac[variety_type_lemmas]);
pop_thm()));
=TEX


¹HOLCONST
Ü ÛRep‰MÝ	: 'a MONOID ­ 'a ALGEBRA;
Ü ÛAbs‰MÝ 	: 'a ALGEBRA ­ 'a MONOID
÷üüüüüü
Ü(µS·	Abs‰M(Rep‰M S) = S) ±
Ü(µK·	K  Variety MonoidAxioms ¤ Rep‰M(Abs‰M K) = K)
°


The elements of the universal monoio will have the following type:

=SML
new_type_defn(["UNIV_MONOID_ELEMENT"], "UNIV_MONOID_ELEMENT", ["'a"], (
set_goal([], ¬¶f· (Ìg· g  Safe MonoidAxioms) f
®);
a(rewrite_tac[variety_type_lemmas]);
pop_thm()));
=TEX

The following are the abstraction and representation functions for the elements of the universal monoid as a subtype of the carrier type of the universal algebra for the monoid axioms.

¹HOLCONST
Ü ÛRep‰UMEÝ	: 'a UNIV_MONOID_ELEMENT ­ ('a ALGEBRA ­ 'a);
Ü ÛAbs‰UMEÝ 	: ('a ALGEBRA ­ 'a) ­ 'a UNIV_MONOID_ELEMENT
÷üüüüüü
Ü(µx·	Abs‰UME(Rep‰UME x) = x) ±
Ü(µf·	f  Safe MonoidAxioms ¤ Rep‰UME(Abs‰UME f) = f)
°

Now we can define the universal monoid:

¹HOLCONST
Ü ÛUnivMonoidÝ : 'a UNIV_MONOID_ELEMENT MONOID
÷üüüüüü
Ü UnivMonoid =
Ü Abs‰M (MkAlgebra
Ü	Universe
Ü	(Ìp a· Abs‰UME(Op(UnivAlgebra MonoidAxioms) p (Map Rep‰UME a)))
Ü	Arbitrary)
°

=TEX

Now we can define the universal monoid operation:
=SML
declare_infix(310, ".‰M");
=TEX

¹HOLCONST
Ü Û$.‰MÝ :
Ü	'a UNIV_MONOID_ELEMENT
Ü ­	'a UNIV_MONOID_ELEMENT
Ü ­	'a UNIV_MONOID_ELEMENT
÷üüüüüü
Ü µ x y· x .‰M y = Op (Rep‰M UnivMonoid) 0 [x; y]
°

and the unit element for the universal monoid:

¹HOLCONST
Ü Û$1‰MÝ :
Ü	'a UNIV_MONOID_ELEMENT
÷üüüüüü
Ü 1‰M = Op (Rep‰M UnivMonoid) 0 []
°

%%%%
%%%%
%%%%
%%%%
\section{SPECIFIC EXAMPLES}

We must give the the ML commands to  introduce the new theory ``alg-egs'' as a child of the theory ``monoids''.

=TEX
%%%%
%%%%
%%%%
%%%%
=SML
force_delete_theory"alg-egs" handle Fail _ => ();
open_theory"monoids";
new_theory"alg-egs";
set_merge_pcs["basic_hol1", "'sets_alg"];
=TEX


%%%%
%%%%
%%%%
%%%%
{\let\Section\section
\newcounter{ThyNum}
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
{\makeatletter
\def\UP@char#1{{{}\sp{#1}}}
\makeatother
\HOLindexOff\include{wrk0811.th}
\include{wrk0812.th}}
}  %\let

\twocolumn[\section{INDEX}\label{index}]
{\small\printindex}

\end{document}

{\HOLindexOff
%%%%
%%%%
%%%%
%%%%
\onecolumn
\section{THEOREMS}\label{THEOREMS}
=SML
fun arb_gen (thm : THM) : THM = (
	let	val ty_map = map
			(fn tv => (mk_vartype("@_" ^ tv), mk_vartype tv))
			(term_tyvars(concl thm));
		val thm1 = asm_inst_type_rule ty_map thm;
	in	all_µ_intro (all_µ_arb_elim thm1)
	end
);
=TEX

%%%%
%%%%
\subsection{Semigroups}
=TEX
We begin by working through the definitions proving
consistency as necessary.
%%%%
%%%%
%%%%
%%%%
=SML
=TEX
=SML
val _ = open_theory "semigroups";
val _ = set_merge_pcs["basic_hol1", "'sets_alg"];
val Ûassoc_eq_defÝ = get_spec¬AssocEq®;
val Ûsemigroup_axioms_defÝ = get_spec¬SemigroupAxioms®;
val Ûsemigroup_defÝ = get_defn "-" "SEMIGROUP";
=TEX
=SML
save_consistency_thm ¬Abs‰S® (
push_consistency_goal ¬Abs‰S®;
a (strip_asm_tac (rewrite_rule[](simple_´_match_mp_rule type_lemmas_thm semigroup_def)));
a (¶_tac ¬(rep, abs)®
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
pop_thm());
val Ûabs_s_defÝ = get_spec¬Abs‰S®;
val Ûrep_s_defÝ = get_spec¬Rep‰S®;
val Ûuniv_semigroup_element_defÝ = get_defn "-" "UNIV_SEMIGROUP_ELEMENT";
=TEX
=SML
save_consistency_thm ¬Abs‰USE® (
push_consistency_goal ¬Abs‰USE®;
a (strip_asm_tac (rewrite_rule[let_def](simple_´_match_mp_rule type_lemmas_thm univ_semigroup_element_def)));
a (¶_tac ¬(rep, abs)®
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
pop_thm());
val Ûabs_use_defÝ = get_spec¬Abs‰USE®;
val Ûrep_use_defÝ = get_spec¬Rep‰USE®;
val Ûuniv_semigroup_defÝ = get_spec¬UnivSemigroup®;
val Ûuniv_semigroup_op_defÝ = get_spec¬$.‰S®;
=TEX
%%%%
%%%%
=SML

val Ûrep_s_one_one_thmÝ = save_thm( "rep_s_one_one_thm", (
set_goal([], ¬µx y·
	Rep‰S x = Rep‰S y ¤ x = y
®);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(LEMMA_T ¬Abs‰S(Rep‰S x) = Abs‰S(Rep‰S y)® ante_tac
	THEN1 asm_rewrite_tac[]);
a(rewrite_tac[abs_s_def]);
pop_thm()));

=TEX
%%%%
%%%%
=SML

val sg_thm1 = rewrite_rule[]
	(conv_rule
	(LEFT_C (rewrite_conv[abs_s_def, rep_s_def, abs_use_def, rep_use_def]))
	(list_µ_elim[
		¬Abs‰S : 'a UNIV_SEMIGROUP_ELEMENT ALGEBRA ­ 'a UNIV_SEMIGROUP_ELEMENT SEMIGROUP®,
		¬Rep‰S : 'a UNIV_SEMIGROUP_ELEMENT SEMIGROUP ­ 'a UNIV_SEMIGROUP_ELEMENT ALGEBRA®] 	(list_µ_elim[
			¬SemigroupAxioms®,
			¬Abs‰USE®,
			¬Rep‰USE®]variety_laws_lemma)));

val sg_thm2 = rewrite_rule[eq_sym_rule univ_semigroup_def]
	(once_rewrite_rule[eq_sym_rule (rewrite_rule[abs_s_def] sg_thm1)] sg_thm1);

val sg_thm3 = rewrite_rule[sg_thm1]
	let	val t = hd(snd(strip_app(concl sg_thm1)));
	in	µ_elim t(±_right_elim rep_s_def)
	end;

val sg_thm4 =
	rewrite_conv[
		car_universe_thm,
		sg_thm3,
		univ_semigroup_def
	] ¬Car (Rep‰S UnivSemigroup)®;

=TEX
%%%%
%%%%
Note the following needs the proof contexts $basic\_hol1" and $'sets\_alg$.

=SML
val sg_thm5 =
	(rewrite_rule [
		semigroup_axioms_def,
		assoc_eq_def,
		prove_rule[] ¬µf s t·
			(µx y· x = s ± y = t ´ (µ I
         · f I x = f I y)) ¤ (µ I
         · f I s = f I t)®,
		sg_thm4,
		let_def,
		variety_def,
		derived_op_def,
		map_def] sg_thm2);

val sg_thm6 = all_µ_intro(rewrite_rule[]
	(µ_elim¬Ìv·
		if	v = 0
		then	x : 'a UNIV_SEMIGROUP_ELEMENT
		else if	v = 1
		then	y
		else	z® sg_thm5));


val Ûuniv_semigroup_assoc_thmÝ = save_thm( "univ_semigroup_assoc_thm", (
set_goal([], ¬µx y z·
	(x .‰S y) .‰S z = x .‰S (y .‰S z)
®);
a(REPEAT strip_tac);
a(rewrite_tac[univ_semigroup_op_def, sg_thm6]);
pop_thm()));


=TEX

%%%%
%%%%
\subsection{Monoids}
=TEX
We begin by working through the definitions proving
consistency as necessary.
%%%%
%%%%
%%%%
%%%%
=SML
=TEX
=SML
val _ = open_theory "monoids";
val _ = set_merge_pcs["basic_hol1", "'sets_alg"];
val Ûunit_eq_defÝ = get_spec¬UnitEq®;
val Ûmonoid_axioms_defÝ = get_spec¬MonoidAxioms®;
val Ûmonoid_defÝ = get_defn "-" "MONOID";
=TEX
=SML
save_consistency_thm ¬Abs‰M® (
push_consistency_goal ¬Abs‰M®;
a (strip_asm_tac (rewrite_rule[](simple_´_match_mp_rule type_lemmas_thm monoid_def)));
a (¶_tac ¬(rep, abs)®
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
pop_thm());
val Ûabs_m_defÝ = get_spec¬Abs‰M®;
val Ûrep_m_defÝ = get_spec¬Rep‰M®;
val Ûuniv_monoid_element_defÝ = get_defn "-" "UNIV_MONOID_ELEMENT";
=TEX
=SML
save_consistency_thm ¬Abs‰UME® (
push_consistency_goal ¬Abs‰UME®;
a (strip_asm_tac (rewrite_rule[let_def](simple_´_match_mp_rule type_lemmas_thm univ_monoid_element_def)));
a (¶_tac ¬(rep, abs)®
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
pop_thm());
val Ûabs_ume_defÝ = get_spec¬Abs‰UME®;
val Ûrep_ume_defÝ = get_spec¬Rep‰UME®;
val Ûuniv_monoid_defÝ = get_spec¬UnivMonoid®;
val Ûuniv_monoid_op_defÝ = get_spec¬$.‰M®;
val Ûuniv_monoid_unit_defÝ = get_spec¬1‰M®;
=TEX
%%%%
%%%%
=SML

val Ûrep_m_one_one_thmÝ = save_thm( "rep_m_one_one_thm", (
set_goal([], ¬µx y·
	Rep‰M x = Rep‰M y ¤ x = y
®);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(LEMMA_T ¬Abs‰M(Rep‰M x) = Abs‰M(Rep‰M y)® ante_tac
	THEN1 asm_rewrite_tac[]);
a(rewrite_tac[abs_m_def]);
pop_thm()));

=TEX
%%%%
%%%%
=SML

val mnd_thm1 = rewrite_rule[]
	(conv_rule
	(LEFT_C (rewrite_conv[abs_m_def, rep_m_def, abs_ume_def, rep_ume_def]))
	(list_µ_elim[
		¬Abs‰M : 'a UNIV_MONOID_ELEMENT ALGEBRA ­ 'a UNIV_MONOID_ELEMENT MONOID®,
		¬Rep‰M : 'a UNIV_MONOID_ELEMENT MONOID ­ 'a UNIV_MONOID_ELEMENT ALGEBRA®] 	(list_µ_elim[
			¬MonoidAxioms®,
			¬Abs‰UME®,
			¬Rep‰UME®]variety_laws_lemma)));

val mnd_thm2 = rewrite_rule(map eq_sym_rule [
	rewrite_rule[abs_m_def] mnd_thm1,
	univ_monoid_def]) mnd_thm1;

val mnd_thm2 = rewrite_rule[eq_sym_rule univ_monoid_def]
	(once_rewrite_rule[eq_sym_rule (rewrite_rule[abs_m_def] mnd_thm1)] mnd_thm1);

val mnd_thm3 = rewrite_rule[mnd_thm1]
	let	val t = hd(snd(strip_app(concl mnd_thm1)));
	in	µ_elim t(±_right_elim rep_m_def)
	end;

val mnd_thm4 =
	rewrite_conv[
		car_universe_thm,
		mnd_thm3,
		univ_monoid_def
	] ¬Car (Rep‰M UnivMonoid)®;

val mnd_thm5 =
	(pc_rule1 "sets_ext1" rewrite_rule [
		semigroup_axioms_def,
		monoid_axioms_def,
		assoc_eq_def,
		unit_eq_def,
		mnd_thm4,
		let_def,
		variety_def] mnd_thm2);


fun Ûget_lawsÝ (thm : THM) : (TERM * TERM) list = (
	let	val b = snd(strip_µ(concl thm));
		val ant = fst(dest_´ b);
		val eqs = strip_² ant;
		val rhses = map (snd o dest_eq) eqs;
		val res = map dest_pair rhses;
	in	res
	end
);

val mnd_thms6 =
	let	val pairs = get_laws mnd_thm5;
	in	map (fn (t1, t2) => rewrite_rule[] (list_µ_elim [t1, t2] mnd_thm5)) pairs
	end;


val mnd_thms7 = map 
	(fn thm => all_µ_intro(rewrite_rule[
		let_def,
		derived_op_def,
		map_def]
		(µ_elim¬Ìv·
			if	v = 0
			then	x : 'a UNIV_MONOID_ELEMENT
			else if	v = 1
			then	y
			else	z® thm))) mnd_thms6;


val Ûuniv_monoid_assoc_thmÝ = save_thm( "univ_monoid_assoc_thm", (
set_goal([], ¬µx y z·
	(x .‰M y) .‰M z = x .‰M (y .‰M z)
®);
a(REPEAT strip_tac);
a(rewrite_tac(univ_monoid_op_def :: mnd_thms7));
pop_thm()));


val Ûuniv_monoid_unit_thmÝ = save_thm( "univ_monoid_unit_thm", (
set_goal([], ¬µx·
	1‰M .‰M x = x
±	x .‰M 1‰M = x
®);
a(REPEAT strip_tac THEN
	rewrite_tac(univ_monoid_op_def :: univ_monoid_unit_def :: mnd_thms7));
pop_thm()));

=TEX
%%%%
%%%%
%%%%
=SML
=TEX
%%%%
=TEX
%%%%
%%%%
%%%%
%%%%
=TEX
\subsection{Epilogue}\label{END}
} % matches turning off of HOL index entries.
=TEX
%%%%
%%%%
=SML
open_theory"semigroups";
output_theory{out_file="wrk0811.th.doc", theory="semigroups"};
open_theory"monoids";
output_theory{out_file="wrk0812.th.doc", theory="monoids"};
=TEX
\end{document}
=SML
