=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}
\def\Hide#1{\relax}
\title{Mathematical Case Studies: the Geometric Algebra}
\author{Rob Arthan}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
This document develops the basic theory of the Geometric Algebra.
$GA(\infty)$.
\end{abstract}
\section{INTRODUCTION}
This document is one of a set of documents containing mathematical case studies in  {\ProductHOL}.
It deals with the Geometric Algebra.
\section{REAL VECTOR SPACES}
=SML
force_delete_theory"geomalg" handle Fail _ => ();
open_theory"fincomb";
new_theory"geomalg";
new_parent "groups";
new_parent "numbers";
set_merge_pcs["basic_hol1", "'sets_alg", "'ú", "'¯"];
=TEX

\section{THE GEOMETRIC ALGEBRA}


It is very convenient to have available the symmetric difference operator for sets. Indeed, it would be nice for this to be moved into the basic HOL theory of sets.
We follow Z in writing the symmetric difference of $a$ and $b$ as
=INLINEFT
a £ b
=TEX

=SML
declare_infix(250, "£");

¹HOLCONST
Ü $£ : 'a SET ­ 'a SET ­ 'a SET
÷üüüüüü
Ü µa b· a £ b = (a \ b) À (b \ a)
°

\subsection{The Algebra Operations}
¹HOLCONST
Ü ÛSign‰Gİ : î SET ­ î SET ­ ¯
÷üüüüüü
Ü µ I J· Sign‰G I J = ~(î¯ 1) ^ #{(i, j) | i  I ± j  J ± j < i}
°
=SML
declare_infix(300, "+‰G");
declare_type_abbrev("GA", [], ”î SET ­ ¯®);

¹HOLCONST
Ü $+‰G : GA ­ GA ­ GA
÷üüüüüü
Ü µ v w·
Ü	v +‰G w = ÌK· v K + w K
°
=SML
declare_infix(310, "*‰G");

¹HOLCONST
Ü $*‰G : GA ­ GA ­ GA
÷üüüüüü
Ü µ v w·
Ü	v *‰G w = ÌK·
Ü	“ {(I, J) | I  Supp v ± J  Supp w ± K = I £ J}
Ü	(Ì(I, J)· Sign‰G I J * v I * w J)
°
=SML
declare_infix(310, "*‰S");

¹HOLCONST
Ü $*‰S : ¯ ­ GA ­ GA
÷üüüüüü
Ü µ c v· c *‰S v = ÌK·c * v K
°

¹HOLCONST
Ü 0‰G : GA
÷üüüüüü
Ü 0‰G = ÌK· î¯ 0
°
¹HOLCONST
Ü 1‰G : GA
÷üüüüüü
Ü 1‰G = Ñ{{}}
°

=TEX

%\bibliographystyle{fmu}
%\bibliography{fmu}

%\appendix
{%\HOLindexOff
\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{geomalg.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
=TEX
%%%%
%%%%
=SML
=SML
=TEX
%%%%
%%%%

=TEX

=SML
val Û£_defİ = get_spec¬$£®;
val Ûsign_g_defİ = get_spec¬Sign‰G®;
val Ûplus_g_defİ = get_spec¬$+‰G®;
val Ûtimes_g_defİ = get_spec¬$*‰G®;
val Ûtimes_s_defİ = get_spec¬$*‰S®;
val Ûzero_g_defİ = get_spec¬0‰G®;
val Ûone_g_defİ = get_spec¬1‰G®;
=TEX
=SML
val Ûmod_2_clausesİ = rewrite_rule[] (µ_elim¬2®mod_clauses);
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b c·
	a £ {} = a
±	{} £ a = a
±	a £ b = b £ a
±	a £ b £ c = (a £ b) £ c®);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_group_thmİ = save_pop_thm "£_group_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b c·
	a £ b £ c = (a £ b) £ c®);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_assoc_thmİ = save_pop_thm "£_assoc_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa·
	a £ {} = a
±	{} £ a = a
±	a £ a = {}®);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_clausesİ = save_pop_thm "£_clauses";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b c· a = b £ c ¤ c = b £ a®);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_inverse_thmİ = save_pop_thm "£_inverse_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b·
	a ¡ b = {} ¤ a £ b = a À b®);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_eq_À_thmİ = save_pop_thm "£_eq_À_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b· a  Finite ± b  Finite ´ a £ b  Finite®);
a(REPEAT strip_tac THEN bc_thm_tac €_finite_thm
	THEN ¶_tac¬a À b®
	THEN asm_rewrite_tac[£_def, À_finite_thm]
	THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_finite_thmİ = save_pop_thm "£_finite_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µf a b·
	f {} = 0
±	(µa b· a  Finite ± b  Finite
	´	f(a À b) + f(a ¡ b) = f a + f b)
±	a  Finite
±	b  Finite
´	f(a £ b) + 2*f(a ¡ b) = f a + f b
®);
a(REPEAT strip_tac);
a(lemma_tac¬a À b  Finite® THEN1 asm_rewrite_tac[À_finite_thm]);
a(lemma_tac¬a ¡ b  Finite® THEN1 ALL_FC_T rewrite_tac[¡_finite_thm]);
a(lemma_tac¬a £ b  Finite® THEN1 all_fc_tac[£_finite_thm]);
a(LIST_SPEC_NTH_ASM_T 6 [¬a £ b®, ¬a ¡ b®] ante_tac);
a(LIST_SPEC_NTH_ASM_T 6 [¬a®, ¬b®] ante_tac);
a(DROP_NTH_ASM_T 6 discard_tac);
a(LEMMA_T ¬(a £ b) À a ¡ b = a À b ± (a £ b) ¡ a ¡ b = {}®
	asm_rewrite_thm_tac
	THEN1 (rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(PC_T1 "lin_arith" prove_tac[]);
val Ûsize_£_lemmaİ = save_pop_thm "size_£_lemma";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b·
	a  Finite
±	b  Finite
´	#(a £ b) + 2 * #(a ¡ b) = #a + #b
®);
a(REPEAT strip_tac THEN bc_thm_tac size_£_lemma);
a(asm_rewrite_tac[size_empty_thm, size_À_thm]);
val Ûsize_£_thmİ = save_pop_thm "size_£_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µt a b c·
	(µa·t a {} = 0)
±	(µa b c·a  Finite ± b  Finite ± c  Finite
	´	t a (b À c) + t a (b ¡ c) = t a b + t a c)
±	a  Finite ± b  Finite ± c  Finite
´	t a (b £ c) + 2 * t a (b ¡ c) = t a b + t a c
®);
a(REPEAT strip_tac);
a(bc_thm_tac size_£_lemma THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
val Ûsign_g_lemma1İ = save_pop_thm "sign_g_lemma1";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µt a b c·
	(µa·t {} a = 0)
±	(µa b c·a  Finite ± b  Finite ± c  Finite
	´	t (a À b) c + t (a ¡ b) c = t a c + t b c)
±	a  Finite ± b  Finite ± c  Finite
´	t (a £ b) c + 2 * t (a ¡ b) c = t a c + t b c
®);
a(REPEAT strip_tac);
a(bc_thm_tac(rewrite_rule[](µ_elim¬Ìx y· t y x® sign_g_lemma1)));
a(asm_rewrite_tac[] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val Ûsign_g_lemma2İ = save_pop_thm "sign_g_lemma2";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µt a b c·
	(µa·t a {} = 0)
±	(µa b c·a  Finite ± b  Finite ± c  Finite
	´	t a (b À c) + t a (b ¡ c) = t a b + t a c)
±	(µa·t {} a = 0)
±	(µa b c·a  Finite ± b  Finite ± c  Finite
	´	t (a À b) c + t (a ¡ b) c = t a c + t b c)
±	a  Finite ± b  Finite ± c  Finite
´	(t a (b £ c) + t b c) Mod 2 = (t (a £ b) c + t a b) Mod 2
®);
a(REPEAT strip_tac);
a(LEMMA_T ¬((t a (b £ c) + t b c) + 2 * t a (b ¡ c)) Mod 2 =
	((t (a £ b) c + t a b) + 2 * t (a ¡ b) c) Mod 2®
	(accept_tac o rewrite_rule[mod_2_clauses]));
a(LEMMA_T ¬((t a (b £ c) + t b c) + 2 * t a (b ¡ c)) =
	((t (a £ b) c + t a b) + 2 * t (a ¡ b) c)®
	rewrite_thm_tac);
a(rewrite_tac[pc_rule1"lin_arith" prove_rule[]
	¬µi j k:î·(i + j) + k = j + i + k®]);
a(ALL_FC_T rewrite_tac[sign_g_lemma1, sign_g_lemma2]);
a(PC_T1 "lin_arith" prove_tac[]);
val Ûsign_g_lemma4İ = save_pop_thm "sign_g_lemma4";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µm·
	 ~(î¯ 1) ^ m = ~(î¯ 1) ^ (m Mod 2)
®);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim¬m® mod_2_cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[mod_2_0_¯_î_exp_thm, mod_2_1_¯_î_exp_thm]
	THEN rewrite_tac[¯_î_exp_0_1_thm]);
val Û¯_î_exp_mod_2_thmİ = save_pop_thm "¯_î_exp_mod_2_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µI J K:î SET·
	{(i, j)|i  I À J ± j  K ± j < i} =
	{(i, j)|i  I ± j  K ± j < i} À
	{(i, j)|i  J ± j  K ± j < i}
±	{(i, j)|i  I ± j  J À K ± j < i} =
	{(i, j)|i  I ± j  J ± j < i} À
	{(i, j)|i  I ± j  K ± j < i}
±	{(i, j)|i  I ¡ J ± j  K ± j < i} =
	{(i, j)|i  I ± j  K ± j < i} ¡
	{(i, j)|i  J ± j  K ± j < i}
±	{(i, j)|i  I ± j  J ¡ K ± j < i} =
	{(i, j)|i  I ± j  J ± j < i} ¡
	{(i, j)|i  I ± j  K ± j < i}
®);
a(PC_T1 "sets_ext1" prove_tac[]);
val Ûsign_g_lemma5İ = save_pop_thm "sign_g_lemma5";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µI J:î SET·
	I  Finite ± J  Finite
´	{(i, j)|i  I ± j  J ± j < i}  Finite
®);
a(REPEAT strip_tac THEN bc_thm_tac €_finite_thm);
a(¶_tac¬I ¸ J® THEN ALL_FC_T rewrite_tac[¸_finite_size_thm]);
a(rewrite_tac[¸_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Ûsign_g_lemma6İ = save_pop_thm "sign_g_lemma6";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µI J K·
	I  Finite
±	J  Finite
±	K  Finite
´	Sign‰G (I £ J) K * Sign‰G I J
=	Sign‰G I (J £ K) * Sign‰G J K
®);
a(REPEAT strip_tac THEN rewrite_tac[sign_g_def,
	conv_rule(ONCE_MAP_C eq_sym_conv) ¯_î_exp_plus_thm]);
a(once_rewrite_tac[¯_î_exp_mod_2_thm]);
a(bc_thm_tac(prove_rule[]¬µx:¯; i j :î· j = i ´ x^i = x^j®));
a(bc_thm_tac(rewrite_rule[](µ_elim¬Ìa b:î SET·# {(i, j)|i  a ± j  b ± j < i}® sign_g_lemma4)));
a(asm_rewrite_tac[pc_rule1"sets_ext1" prove_rule[]
	¬{(i, j)|F} = {}®,
	size_empty_thm]);
a(DROP_ASMS_T discard_tac THEN rewrite_tac[sign_g_lemma5]);
a(REPEAT strip_tac THEN bc_thm_tac size_À_thm
	THEN ALL_FC_T rewrite_tac[sign_g_lemma6]);
val Ûsign_g_thmİ = save_pop_thm "sign_g_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µv w K·
	Supp v  Finite ² Supp w  Finite
´	 {(I, J)|I  Supp v ± J  Supp w ± K = I £ J}  Finite
®);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN bc_thm_tac €_finite_thm);
a(¶_tac¬{(I, J) | I  Supp v ± K = I £ J}®
	THEN REPEAT strip_tac
	THEN_LIST [id_tac,  PC_T1 "sets_ext1" prove_tac[]]);
a(lemma_tac¬{(I, J)|I  Supp v ± K = I £ J}  Finite ±
	#{(I, J)|I  Supp v ± K = I £ J} = #(Supp v)®
	THEN1 bc_thm_tac bijection_finite_size_thm);
a(once_rewrite_tac[£_inverse_thm]);
a(¶_tac¬ÌI·(I, I £ K)® THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" once_rewrite_tac[] THEN rewrite_tac[]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1
	THEN REPEAT strip_tac);
a(¶_tac¬x1® THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN bc_thm_tac €_finite_thm);
a(¶_tac¬{(I, J) | J  Supp w ± K = I £ J}®
	THEN REPEAT strip_tac
	THEN_LIST [id_tac,  PC_T1 "sets_ext1" prove_tac[]]);
a(lemma_tac¬{(I, J)| J  Supp w ± K = I £ J}  Finite ±
	#{(I, J)| J  Supp w ± K = I £ J} = #(Supp w)®
	THEN1 bc_thm_tac bijection_finite_size_thm);
a(once_rewrite_tac[£_group_thm]);
a(once_rewrite_tac[£_inverse_thm]);
a(¶_tac¬ÌJ·(J £ K, J)® THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" once_rewrite_tac[] THEN rewrite_tac[]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1
	THEN REPEAT strip_tac);
a(¶_tac¬x2® THEN REPEAT strip_tac);
val Ûtimes_g_finite_thmİ = save_pop_thm "times_g_finite_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µc v·
	³c = î¯ 0 ´ Supp (c *‰S v) = Supp v
®);
a(REPEAT strip_tac THEN PC_T1 "sets_ext1" rewrite_tac[supp_def, times_s_def]
	THEN µ_tac);
a(cases_tac¬v x = î¯ 0® THEN asm_rewrite_tac[¯_times_eq_0_thm]);
val Ûsupp_times_s_thmİ = save_pop_thm "supp_times_s_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µA·
	Supp (Ñ A) = A
®);
a(REPEAT strip_tac THEN PC_T1 "sets_ext1" rewrite_tac[supp_def, Ñ_def]
	THEN µ_tac);
a(cases_tac¬x  A® THEN asm_rewrite_tac[]);
val Ûsupp_Ñ_thmİ = save_pop_thm "supp_Ñ_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µA f·
	A  Finite
´	“ A f = “ (A ¡ Supp f) f
®);
a(REPEAT strip_tac);
a(finite_induction_tac¬A® THEN1 rewrite_tac[ind_sum_def]);
a(cases_tac¬x  Supp f®);
(* *** Goal "1" *** *)
a(LEMMA_T ¬({x} À A) ¡ Supp f = {x} À (A ¡ Supp f)®
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(LEMMA_T ¬³x  (A ¡ Supp f)® asm_tac
	THEN1 REPEAT strip_tac);
a(LEMMA_T ¬A ¡ Supp f  Finite® asm_tac
	THEN1 (bc_thm_tac €_finite_thm
		THEN ¶_tac¬A®  THEN REPEAT strip_tac
		THEN PC_T1 "sets_ext1" prove_tac[]));
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
(* *** Goal "2" *** *)
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[supp_def]));
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
a(LEMMA_T ¬({x} À A) ¡ Supp f = (A ¡ Supp f)®
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
val Ûind_sum_supp_thmİ = save_pop_thm "ind_sum_supp_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µA B f g h·
	A  Finite
±	B  Finite
±	(µx· x  A ± ³f x = î¯ 0 ´ h x  B ± f x = g(h x))
±	(µy· y  B ± ³ g y = î¯ 0 ´ ¶‰1x· x  A ± h x = y ± f x = g y)
´	“ A f = “ B g
®);
a(REPEAT strip_tac);
a(lemma_tac¬µC· C  Finite ´
	“ {x | x  A ± ³f x = î¯ 0 ± h x  C} f =
	“ (B ¡ C) g®);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(finite_induction_tac¬C®);
(* *** Goal "1" *** *)
(* *** Goal "1.1" *** *)
a(rewrite_tac[ind_sum_def, pc_rule1 "sets_ext1" prove_rule[]¬{x|F} = {}®]);
(* *** Goal "1.2" *** *)
a(cases_tac¬x  B®);
a(LEMMA_T¬B ¡ ({x} À C) = {x} À (B ¡ C)® rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(LEMMA_T¬³x  (B ¡ C)® asm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(lemma_tac¬B ¡ C  Finite®
	THEN1 (bc_thm_tac ¡_finite_thm THEN REPEAT strip_tac));
a(cases_tac¬g x = î¯ 0®);
(* *** Goal "1.2.1.1" *** *)
a(LEMMA_T¬{x'|x'  A ± ³ f x' = î¯ 0 ± h x'  {x} À C}
	= {x|x  A ± ³ f x = î¯ 0 ± h x  C}®
	asm_rewrite_thm_tac);
(* *** Goal "1.2.1.1.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [10] all_fc_tac);
a(swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[]);
(* *** Goal "1.2.1.1.2" *** *)
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
(* *** Goal "1.2.1.2" *** *)
a(spec_nth_asm_tac 8 ¬x® THEN 
	PC_T "predicates" all_var_elim_asm_tac1);
a(LEMMA_T¬{x''|x''  A ± ³ f x'' = î¯ 0 ± h x''  {h x'} À C}
	= {x'} À {x|x  A ± ³ f x = î¯ 0 ± h x  C}®
	asm_rewrite_thm_tac);
(* *** Goal "1.2.1.2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN_TRY all_var_elim_asm_tac1);
(* *** Goal "1.2.1.2.1.1" *** *)
a(swap_nth_asm_concl_tac 1);
a(spec_nth_asm_tac 16 ¬x®);
a(DROP_NTH_ASM_T 7 bc_thm_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.2.1.2.1.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "1.2.1.2.2" *** *)
a(LEMMA_T¬³x'  {x|x  A ± ³ f x = î¯ 0 ± h x  C}®
	asm_tac
	THEN1 asm_rewrite_tac[]);
a(lemma_tac¬{x|x  A ± ³ f x = î¯ 0 ± h x  C}  Finite®
	THEN1 (bc_thm_tac €_finite_thm
		THEN ¶_tac¬A® THEN REPEAT strip_tac
		THEN PC_T1 "sets_ext1" prove_tac[]));
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
(* *** Goal "1.2.2" *** *)
a(LEMMA_T¬B ¡ ({x} À C) = B ¡ C® rewrite_thm_tac
	THEN1 (POP_ASM_T ante_tac THEN PC_T1 "sets_ext1" prove_tac[]));
a(LEMMA_T¬{x'|x'  A ± ³ f x' = î¯ 0 ± h x'  {x} À C}
	= {x|x  A ± ³ f x = î¯ 0 ± h x  C}®
	asm_rewrite_thm_tac);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(spec_nth_asm_tac 8 ¬x'®);
(* *** Goal "2" *** *)
a(POP_ASM_T (ante_tac o µ_elim¬B®) THEN asm_rewrite_tac[]);
a(STRIP_T (rewrite_thm_tac o eq_sym_rule));
a(LEMMA_T ¬{x|x  A ± ³ f x = î¯ 0 ± h x  B} =
	A ¡ Supp f® rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[supp_def]
	THEN PC_T1 "sets_ext1" REPEAT strip_tac
	THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(ALL_FC_T rewrite_tac[ind_sum_supp_thm]);
val Ûind_sum_transfer_thmİ = save_pop_thm "ind_sum_transfer_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µx B; f:'a ¸ 'b ­ ¯·
	B  Finite
´	“ ({x} ¸ B) f = “ B (Ìy·f(x, y))
®);
a(REPEAT strip_tac);
a(finite_induction_tac¬B® THEN1 rewrite_tac[ind_sum_def, ¸_def,
	pc_rule1 "sets_ext1" prove_rule[]¬{(x, y)|F} = {}®]);
a(LEMMA_T¬({x} ¸ ({x'} À B)) = {(x,  x')} À ({x} ¸ B)®rewrite_thm_tac
	THEN1 MERGE_PCS_T1 ["'bin_rel", "'pair", "sets_ext1"] prove_tac[]);
a(LEMMA_T¬³(x,  x')  ({x} ¸ B)® asm_tac
	THEN1 MERGE_PCS_T1 ["'bin_rel", "sets_ext1"] prove_tac[]);
a(strip_asm_tac (µ_elim¬x® singleton_finite_thm));
a(lemma_tac¬({x} ¸ B)  Finite®
	THEN1 all_fc_tac[¸_finite_size_thm]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
val Ûind_sum_singleton_¸_thmİ = save_pop_thm "ind_sum_singleton_¸_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µf:'a ¸ 'b ­ ¯; A B·
	A  Finite ± B  Finite
´	“ A (Ìx·“ B (Ìy·f(x, y))) = “ (A ¸ B) f
®);
a(REPEAT strip_tac);
a(finite_induction_tac¬A® THEN1 rewrite_tac[ind_sum_def, ¸_def,
	pc_rule1 "sets_ext1" prove_rule[]¬{(x, y)|F} = {}®]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
a(LEMMA_T¬(({x} À A) ¸ B) = ({x} ¸ B) À (A ¸ B)®rewrite_thm_tac
	THEN1 MERGE_PCS_T1 ["'bin_rel", "'pair", "sets_ext1"] prove_tac[]);
a(strip_asm_tac (µ_elim¬x® singleton_finite_thm));
a(lemma_tac¬({x} ¸ B)  Finite ± (A ¸ B)  Finite ®
	THEN1 ALL_FC_T rewrite_tac[¸_finite_size_thm]);
a(ALL_FC_T rewrite_tac[ind_sum_À_thm, ind_sum_singleton_¸_thm]);
a(LEMMA_T¬({x} ¸ B) ¡ (A ¸ B) = {}®rewrite_thm_tac
	THEN1 (MERGE_PCS_T1 ["'bin_rel", "'pair", "sets_ext1"] rewrite_tac[]
		THEN contr_tac THEN all_var_elim_asm_tac1));
a(rewrite_tac[ind_sum_def]);
val Ûind_sum_¸_thmİ = save_pop_thm "ind_sum_¸_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µA·
	Supp 0‰G = {}
±	Supp 1‰G = {{}}
®);
a(rewrite_tac[zero_g_def, one_g_def, supp_Ñ_thm, supp_clauses]);
val Ûsupp_zero_one_g_thmİ = save_pop_thm "supp_zero_one_g_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µv w·
	Supp v  Finite
´	v *‰G w =
	ÌK· “ (Supp v) (Ì I· Sign‰G I (K £ I) * v I * w (K £ I))
®);
a(REPEAT strip_tac THEN rewrite_tac[times_g_def]);
a(lemma_tac¬{(I, J)|I  Supp v ± J  Supp w ± x = I £ J}  Finite®
	THEN1 ALL_FC_T asm_rewrite_tac[times_g_finite_thm]);
a(conv_tac eq_sym_conv);
a(bc_thm_tac ind_sum_transfer_thm);
a(rename_tac[(¬x®, "K")] THEN ¶_tac¬ÌI· (I, K £ I)®
	THEN PC_T1 "predicates" asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac);
a(rewrite_tac[¯_times_eq_0_thm, supp_def]
	THEN taut_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "3" *** *)
a(rewrite_tac[]);
(* *** Goal "4" *** *)
a(lemma_tac¬µa b c:î SET·((a £ b) £ a) = b®
	THEN1 (rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(¶‰1_tac¬Fst y® THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
val Ûtimes_g_def1İ = save_pop_thm "times_g_def1";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µv w·
	Supp w  Finite
´	v *‰G w =
	ÌK· “ (Supp w) (Ì J· Sign‰G (K £ J) J * v (K £ J) * w J)
®);
a(REPEAT strip_tac THEN rewrite_tac[times_g_def]);
a(lemma_tac¬{(I, J)|I  Supp v ± J  Supp w ± x = I £ J}  Finite®
	THEN1 ALL_FC_T asm_rewrite_tac[times_g_finite_thm]);
a(conv_tac eq_sym_conv);
a(bc_thm_tac ind_sum_transfer_thm);
a(rename_tac[(¬x®, "K")] THEN ¶_tac¬ÌJ· (K £ J, J)®
	THEN PC_T1 "predicates" asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac);
a(rewrite_tac[¯_times_eq_0_thm, supp_def]
	THEN taut_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "3" *** *)
a(rewrite_tac[]);
(* *** Goal "4" *** *)
a(lemma_tac¬µa b c:î SET·((b £ a) £ a) = b®
	THEN1 (rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(¶‰1_tac¬Snd y® THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
val Ûtimes_g_def2İ = save_pop_thm "times_g_def2";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µv·
	î¯ 0 *‰S v = 0‰G
®);
a(REPEAT strip_tac THEN rewrite_tac[zero_g_def, times_s_def]);
val Ûzero_times_s_thmİ = save_pop_thm "zero_times_s_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µv·
	0‰G *‰G v = 0‰G
±	v *‰G 0‰G = 0‰G
®);
a(REPEAT µ_tac THEN rewrite_tac[times_g_def]);
a(rewrite_tac[supp_zero_one_g_thm, pc_rule1 "sets_ext1" prove_rule[]
	¬{(a, b)|F} = {}®,
	ind_sum_def]);
a(rewrite_tac[zero_g_def]);
val Ûzero_times_g_thmİ = save_pop_thm "zero_times_g_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µv w c·
	Supp v  Finite
±	Supp w  Finite
´	(c *‰S v) *‰G w = c *‰S (v *‰G w)
®);

a(REPEAT µ_tac THEN ´_tac);
a(cases_tac¬c = î¯ 0® THEN1 PC_T1 "predicates" asm_rewrite_tac[zero_times_s_thm, zero_times_g_thm]);
a(lemma_tac¬Supp (c *‰S v)  Finite®
	THEN1 ALL_FC_T asm_rewrite_tac[supp_times_s_thm]);
a(PC_T1 "predicates" (ALL_FC_T rewrite_tac)[times_g_def1]);
a(ALL_FC_T rewrite_tac[supp_times_s_thm]);
a(µ_tac THEN rewrite_tac[times_s_def]);
a(rewrite_tac[µ_elim¬c®¯_times_order_thm]);
a(pure_rewrite_tac[prove_rule[]
	¬ (Ì I· c * Sign‰G I (x £ I) * v I * w (x £ I)) =
	ÌI·c * (Ì I· Sign‰G I (x £ I) * v I * w (x £ I)) I ®]);
a(ALL_FC_T rewrite_tac[ind_sum_const_times_thm]);
val Ûtimes_g_linear_thm1İ = save_pop_thm "times_g_linear_thm1";
=TEX
%%%%
%%%%

=SML
(*
set_goal([], ¬µv w r·
	Supp v  Finite
±	Supp w  Finite
±	Supp r  Finite
´	(v *‰G w) *‰G r = v *‰G (w *‰G r)
®);
a(REPEAT strip_tac);
a(PC_T1 "predicates" (ALL_FC_T rewrite_tac)
	[times_g_def1, times_g_def2]);
a(LEMMA_T ¬µf; c:¯·“ (Supp w) f * c = “ (Supp w) (ÌI·f I * c)®
	rewrite_thm_tac
	THEN1 (once_rewrite_tac[¯_times_comm_thm]
		THEN ALL_FC_T rewrite_tac[ind_sum_const_times_thm]));
a(LEMMA_T ¬µf; c:¯·c * “ (Supp w) f = “ (Supp w) (ÌJ·c * f J)®
	rewrite_thm_tac
	THEN1 ALL_FC_T rewrite_tac[ind_sum_const_times_thm]);
a(LEMMA_T ¬µf; c:¯·c * “ (Supp r) f = “ (Supp r) (ÌJ·c * f J)®
	rewrite_thm_tac
	THEN1 ALL_FC_T rewrite_tac[ind_sum_const_times_thm]
	THEN rename_tac[(¬J':î SET®, "K")]);
a(ALL_FC_T rewrite_tac[rewrite_rule[](µ_elim¬(Ì (J, K)· Sign‰G (x £ J) J * (Sign‰G ((x £ J) £ K) K * v ((x £ J) £ K) * w K) * r J)®
ind_sum_¸_thm)]);
a(ALL_FC_T rewrite_tac[rewrite_rule[](µ_elim¬Ì(I, J)·Sign‰G I (x £ I) * v I * Sign‰G ((x £ I) £ J) J * w ((x £ I) £ J) * r J®
ind_sum_¸_thm)]);

val Ûtimes_g_assoc_thmİ = save_pop_thm "times_g_assoc_thm";
*)
=TEX
%%%%
%%%%

=SML
(*
set_goal([], ¬µv w·
	Supp v  Finite ± Supp v € Finite
±	Supp w  Finite ± Supp v € Finite
´	Supp (v *‰G w)  Finite
®);
times_g_finite_thm;

a(REPEAT strip_tac THEN rewrite_tac[times_g_def]);
val Ûtimes_g_assoc_thmİ = save_pop_thm "times_g_assoc_thm";
*)
=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val Ûsectionsİ = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="geomalg.th.doc", theory="geomalg"};
end;
=TEX
} %\Hide
\end{document}


