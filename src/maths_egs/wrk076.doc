=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}
%
% Macro for cloak-and-dagger work:
%
\def\Hide#1{\relax}
%
% Macros for various mathematical odds and ends:
%
\def\Func#1{{\mathsf{#1}}}
\def\GA{\Func{GA}}
\def\Zero{\mathbf{0}}
\def\One{\mathbf{1}}
\def\x{\mathbf{x}}
\def\y{\mathbf{y}}
\def\z{\mathbf{z}}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\def\E#1{\mathbf{e}_{#1}}
\def\F#1{\mathbf{f}_{#1}}
%
%  article red tape:
%
\title{Mathematical Case Studies: the Geometric Algebra}
\author{Rob Arthan}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
This document is one of a series of mathematical case studies in  {\ProductHOL}.
It gives a construction of the Geometric Algebra $GA$.
\end{abstract}
\section{INTRODUCTION}
In \cite{Harrison05a}, Harrison advocates an approach to Euclidean geometry in HOL using a type constructor to model the individual Euclidean spaces $\R^{N}$.
In this document, we set up the framework for an alternative approach where one works in a fixed type that contains all of the $\bbR^{N}$.
In fact we do more than that: to quote Macdonald~\cite{Macdonald06}:

\begin{quotation}
\it
Geometric algebra is nothing less than a new approach to geometry.
Geometric objects (points, lines, planes, [\ldots]) are represented by members of an algebra, a {\em geometric algebra}, rather than by equations. Geometric operations (rotate, translate, intersect, [\ldots]) on the objects are represented by algebraic operations in the algebra, rather than by matrix operations.
Geometric algebra is {\em coordinate-free:} coordinates are needed only when specific objects or operations are under consideration.
\end{quotation}

Let me now give a potted account of geometric algebra.


The general finite-dimensional geometric algebra $\GA(p, q)$ is paremeterised by two natural numbers $p$ and $q$.
$\GA(p, q)$ is an associative algebra over the real numbers with a two-sided unit $\One$.
It is commutative iff. $p + q \le 1$.


Real multiples $\lambda\One$ of the unit element in $\GA(p, q)$ are called {\em scalars} and are ordered by taking $\lambda\One < \mu\One$ iff.  $\lambda < \mu$.
Under this ordering, the subalgebra of scalars is isomorphic as an ordered field with the real numbers.
We write $\R_0$ for the set of scalars.

$\GA(p, q)$ is generated as an algebra by a $p+q$-dimensional subspace called $\R^{p, q}$ whose members are called {\em vectors}.
If $\x \in \R^{p, q}$, then $\x^2$ is a scalar.
$\R^{p, q}$ contains subspaces $\R^{p, 0}$ and $\R^{0, q}$ of dimensions $p$ and $q$, respectively, such that for non-zero $\x \in \R^{p, 0}$, $\x^2 > 0$, while for non-zero $\x \in \R^{0, q}$
$\x^2 < 0$.

The {\em inner product} of vectors $\x$ and $\y$ is defined by $\x.\y = \frac{1}{2}(\x\y + \y\x)$ and is a scalar.
The inner product is a bilinear form, i.e., it satisfies the conditions $(\lambda\x).(\mu\y) = \lambda\mu(\x.\y)$, $(\x + \y).\z = \x.\z + \y.\z$,
$\x.(\y + \z) = \x.\y + \x.\z$.
Vectors $\x$ and $\y$ are said to be {\em orthogonal} iff. $\x.\y = 0$.
$\x$ and $\y$ are orthogonal iff. they anti-commute, i.e., iff. $\x\y = -\y\x$.

The {\em outer product} of vectors $\x$ and $\y$ is defined by $\x\land\y=\frac{1}{2}(\x\y -\y\x)$, so that $\x\y = \x.\y + \x\land\y$, which is a scalar iff. it is 0.
Vectors $\x$ and $\y$ are said to be {\em collinear} iff. $\x \land \y = 0$.
Thus, when $\x$ and $\y$ are orthogonal, $\x\y = \x \land y$, while when they are collinear, $\x\y = \x . \y$.

Simple explicit constructions of the geometric algebras have been given by Macdonald~\cite{Macdonald02}, and by the author~\cite{Arthan06b}.
As noted in~\cite{Arthan06b} the union of all of the $\GA(p, q)$ can be constructed in one step giving what I will now refer to as {\em the} geometric algebra, $\GA = \GA(\infty, \infty)$.



=SML
force_delete_theory"geomalg" handle Fail _ => ();
open_theory"fincomb";
new_theory"geomalg";
new_parent "groups";
new_parent "numbers";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙", "'Ø"];
=TEX

\section{THE GEOMETRIC ALGEBRA}

\subsection{Preliminaries}

It is very convenient to have available the symmetric difference operator for sets. Indeed, it would be nice for this to be moved into the basic HOL theory of sets.
We follow Z in writing the symmetric difference of $a$ and $b$ as
=INLINEFT
a £ b
=TEX

=SML
declare_infix(250, "£");
=TEX

πHOLCONST
‹ $£ : 'a SET ≠ 'a SET ≠ 'a SET
˜¸¸¸¸¸¸
‹ µa b∑ a £ b = (a \ b) ¿ (b \ a)
∞


The following is the function $\sigma$ of~\cite{Arthan06b}.
In addition to its use in defining the algebra, this may also find a use in decision procedures later on.

πHOLCONST
‹ €SignâG› : ˙ SET ≠ ˙ SET ≠ Ø
˜¸¸¸¸¸¸
‹ µ I J∑	SignâG I J =
‹	~(ÓØ 1) ^ (#{(i, j) | i ç I ± j ç J ± j < i} + #{i | i ç I ± i ç J ± i < Ó˙ 0})
∞

\subsection{The Representatives for the Algebra Operations}
$\GA$ in HOL will be subtype of the type of all real-valued functions on sets of integers (specifically, it will comprise the functions whose support is a finite set of finite sets).
The following (purely temporary) type abbreviation captures this.
=SML
declare_type_abbrev("GA", [], î˙ SET ≠ ØÆ);
=TEX
We adopt the convention of using an initial `\_' to distinguish operations on the representation type from corresponding operations on the new type.
=SML
declare_infix(300, "_+âG");
=TEX

πHOLCONST
‹ $€_+âG› : GA ≠ GA ≠ GA
˜¸¸¸¸¸¸
‹ µ v w∑ v _+âG w = ÃK∑ v K + w K
∞
πHOLCONST
‹ €_~âG› : GA ≠ GA
˜¸¸¸¸¸¸
‹ µ v∑ _~âG v = ÃK∑ ~(v K)
∞
=SML
declare_infix(310, "_*âG");
=TEX

πHOLCONST
‹ $€_*âG› : GA ≠ GA ≠ GA
˜¸¸¸¸¸¸
‹ µ v w∑
‹	v _*âG w = ÃK∑
‹	ì {(I, J) | I ç Supp v ± J ç Supp w ± K = I £ J}
‹	(Ã(I, J)∑ SignâG I J * v I * w J)
∞
=SML
declare_infix(310, "_*âS");
=TEX

πHOLCONST
‹ $€_*âS› : Ø ≠ GA ≠ GA
˜¸¸¸¸¸¸
‹ µ c v∑ c _*âS v = ÃK∑c * v K
∞

πHOLCONST
‹ €_0âG› : GA
˜¸¸¸¸¸¸
‹ _0âG = ÃK∑ ÓØ 0
∞
πHOLCONST
‹ €_1âG› : GA
˜¸¸¸¸¸¸
‹ _1âG = —{{}}
∞

=TEX
\subsection{The Type Definition}
πHOLCONST
‹	IsGARep : GA ≠ BOOL
˜
‹	µu∑ IsGARep u § Supp u ç Finite ± Supp u Ä Finite
∞
We can now do away with the type abbreviation \ldots
=SML
undeclare_type_abbrev"GA";
=TEX
\ldots and introduce the new type instead:
=SML
val €ga_def› = new_type_defn(["GA", "ga_def"], "GA", [],
	tac_proof(([], ¨∂u∑ IsGARep uÆ),
		∂_tac¨(ÃI∑ÓØ 0)Æ
	THEN	rewrite_tac[get_spec¨IsGARepÆ, get_spec¨SuppÆ,
		pc_rule1"sets_ext" prove_rule[]¨{x|F} = {}Æ,
		empty_finite_thm]));
=SML
declare_infix(300, "+âG");
declare_infix(310, "*âG");
declare_infix(310, "*âS");
=TEX

πHOLCONST
‹ $€+âG›	: GA ≠ GA ≠ GA;
‹ €~âG›	: GA ≠ GA;
‹ $€*âG›	: GA ≠ GA ≠ GA;
‹ $€*âS›	: Ø ≠ GA ≠ GA;
‹ €0âG›	: GA;
‹ €1âG›	: GA
˜¸¸¸¸¸¸
‹	(µu v∑ 	u +âG v = v +âG u)
‹ ±	(µ u v w∑ 	(u +âG v) +âG w = u +âG v +âG w)
‹ ±	(µ u∑ 		u +âG 0âG = u)
‹ ±	(µ u∑ 		u +âG ~âG u = 0âG)
‹ ±	(µ u∑ 		ÓØ 1 *âS u = u)
‹ ±	(µ a b u∑ 	a *âS (b *âS u) = (a * b) *âS u)
‹ ±	(µ a u v∑ 	a *âS (u +âG v) = a *âS u +âG a *âS v)
‹ ±	(µ a b u∑ 	(a + b) *âS u = a *âS u +âG b *âS u)
‹ ±	(µ u v w∑ 	(u *âG v) *âG w = u *âG (v *âG w))
‹ ±	(µ u v w∑	u *âG (v +âG w) = u *âG v +âG u *âG w)
‹ ±	(µ u v w∑	(v +âG w) *âG u = v *âG u +âG w *âG u)
‹ ±	(µ a u v∑	(a *âS u) *âG v = a *âS u *âG v)
‹ ±	(µ u∑		1âG *âG u = u ± u *âG 1âG = u)
∞



{\raggedright
\bibliographystyle{plain}
\bibliography{bookspapers}}

%\appendix
{%\HOLindexOff
\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{geomalg.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
=TEX
%%%%
%%%%
=SML
=SML
=TEX
%%%%
%%%%

=TEX

=SML
val €£_def› = get_spec¨$£Æ;
val €sign_g_def› = get_spec¨SignâGÆ;
val €plus_g_def› = get_spec¨$_+âGÆ;
val €minus_g_def› = get_spec¨_~âGÆ;
val €times_g_def› = get_spec¨$_*âGÆ;
val €times_s_def› = get_spec¨$_*âSÆ;
val €zero_g_def› = get_spec¨_0âGÆ;
val €one_g_def› = get_spec¨_1âGÆ;
=TEX
=SML
val €mod_2_clauses› = rewrite_rule[] (µ_elim¨2Æmod_clauses);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b c∑
	a £ {} = a
±	{} £ a = a
±	a £ b = b £ a
±	a £ b £ c = (a £ b) £ cÆ);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_group_thm› = save_pop_thm "£_group_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b∑ a £ b = b £ aÆ);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_comm_thm› = save_pop_thm "£_comm_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b c∑
	(a £ b) £ c = a £ b £ cÆ);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_assoc_thm› = save_pop_thm "£_assoc_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b∑
	a £ {} = a
±	{} £ a = a
±	a £ a = {}
±	a £ a = {}Æ);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_clauses› = save_pop_thm "£_clauses";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b c∑ a = b £ c § c = b £ aÆ);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_inverse_thm› = save_pop_thm "£_inverse_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨
	a £ a  = {}
±	a £ a £ b = b
±	{} £ a = a
±	a £ {} = a
±	a £ {} £ b = a £ bÆ);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_simp_thm› = pop_thm();
val €£_simp_conv› =
	let	val conv1 = FIRST_C(
			map (simple_eq_match_conv o all_µ_intro)
			(strip_±_rule £_simp_thm));
	in	conv1 THEN_C REPEAT_C conv1
	end;
fun €£_nf_conv› (ty : TYPE) = sort_conv term_order
	(inst_type_rule[(ty, î'aÆ)] £_comm_thm)
	(inst_type_rule[(ty, î'aÆ)] £_assoc_thm)
	£_simp_conv fail_conv;
=IGN
£_nf_conv î'aÆ ¨b £ aÆ;
£_nf_conv  î'aÆ ¨a £ bÆ;
£_nf_conv î'aÆ  ¨a £ b £ aÆ;
£_nf_conv î'aÆ  ¨a £ b £ (c £ {}) £ {} £ {} £ c £ aÆ;
£_nf_conv Ó ¨(x £ (x £ z) £ {1})Æ;
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b∑
	a ° b = {} § a £ b = a ¿ bÆ);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_eq_¿_thm› = save_pop_thm "£_eq_¿_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b∑ a ç Finite ± b ç Finite ¥ a £ b ç FiniteÆ);
a(REPEAT strip_tac THEN bc_thm_tac Ä_finite_thm
	THEN ∂_tac¨a ¿ bÆ
	THEN asm_rewrite_tac[£_def, ¿_finite_thm]
	THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_finite_thm› = save_pop_thm "£_finite_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µf a b∑
	f {} = 0
±	(µa b∑ a ç Finite ± b ç Finite
	¥	f(a ¿ b) + f(a ° b) = f a + f b)
±	a ç Finite
±	b ç Finite
¥	f(a £ b) + 2*f(a ° b) = f a + f b
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨a ¿ b ç FiniteÆ THEN1 asm_rewrite_tac[¿_finite_thm]);
a(lemma_tac¨a ° b ç FiniteÆ THEN1 ALL_FC_T rewrite_tac[°_finite_thm]);
a(lemma_tac¨a £ b ç FiniteÆ THEN1 all_fc_tac[£_finite_thm]);
a(LIST_SPEC_NTH_ASM_T 6 [¨a £ bÆ, ¨a ° bÆ] ante_tac);
a(LIST_SPEC_NTH_ASM_T 6 [¨aÆ, ¨bÆ] ante_tac);
a(DROP_NTH_ASM_T 6 discard_tac);
a(LEMMA_T ¨(a £ b) ¿ a ° b = a ¿ b ± (a £ b) ° a ° b = {}Æ
	asm_rewrite_thm_tac
	THEN1 (rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(PC_T1 "lin_arith" prove_tac[]);
val €size_£_lemma› = save_pop_thm "size_£_lemma";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b∑
	a ç Finite
±	b ç Finite
¥	a £ b ç Finite
±	#(a £ b) + 2 * #(a ° b) = #a + #b
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨a ¿ bÆ);
a(asm_rewrite_tac[¿_finite_thm, £_def]
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2" *** *)
a(bc_thm_tac size_£_lemma);
a(asm_rewrite_tac[size_empty_thm, size_¿_thm]);
val €£_finite_size_thm› = save_pop_thm "£_finite_size_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b∑
	≥a ç Finite
±	b ç Finite
¥	≥a £ b ç Finite
Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨bÆ THEN1 asm_rewrite_tac[£_clauses]);
a(swap_nth_asm_concl_tac 2);
a(bc_thm_tac Ä_finite_thm THEN1 ∂_tac ¨{x} ¿ (a £ ({x} ¿ b'))Æ
	THEN asm_rewrite_tac[¿_finite_thm, singleton_finite_thm]);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_infinite_thm› = save_pop_thm "£_infinite_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µt a b c∑
	(µa∑t a {} = 0)
±	(µa b c∑a ç Finite ± b ç Finite ± c ç Finite
	¥	t a (b ¿ c) + t a (b ° c) = t a b + t a c)
±	a ç Finite ± b ç Finite ± c ç Finite
¥	t a (b £ c) + 2 * t a (b ° c) = t a b + t a c
Æ);
a(REPEAT strip_tac);
a(bc_thm_tac size_£_lemma THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
val €sign_g_lemma1› = save_pop_thm "sign_g_lemma1";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µt a b c∑
	(µa∑t {} a = 0)
±	(µa b c∑a ç Finite ± b ç Finite ± c ç Finite
	¥	t (a ¿ b) c + t (a ° b) c = t a c + t b c)
±	a ç Finite ± b ç Finite ± c ç Finite
¥	t (a £ b) c + 2 * t (a ° b) c = t a c + t b c
Æ);
a(REPEAT strip_tac);
a(bc_thm_tac(rewrite_rule[](µ_elim¨Ãx y∑ t y xÆ sign_g_lemma1)));
a(asm_rewrite_tac[] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val €sign_g_lemma2› = save_pop_thm "sign_g_lemma2";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µt a b c∑
	(µa∑t a {} = 0)
±	(µa b c∑a ç Finite ± b ç Finite ± c ç Finite
	¥	t a (b ¿ c) + t a (b ° c) = t a b + t a c)
±	(µa∑t {} a = 0)
±	(µa b c∑a ç Finite ± b ç Finite ± c ç Finite
	¥	t (a ¿ b) c + t (a ° b) c = t a c + t b c)
±	a ç Finite ± b ç Finite ± c ç Finite
¥	(t a b + t (a £ b) c) Mod 2 = (t a (b £ c) + t b c) Mod 2
Æ);
a(REPEAT strip_tac);
a(LEMMA_T ¨
	((t a b + t (a £ b) c) + 2 * t (a ° b) c) Mod 2 =
	((t a (b £ c) + t b c) + 2 * t a (b ° c)) Mod 2Æ
	(accept_tac o rewrite_rule[mod_2_clauses]));
a(LEMMA_T ¨((t a (b £ c) + t b c) + 2 * t a (b ° c)) =
	((t a b + t (a £ b) c) + 2 * t (a ° b) c)Æ
	rewrite_thm_tac);
a(conv_tac(RIGHT_C (rewrite_conv[plus_assoc_thm])));
a(rewrite_tac[pc_rule1"lin_arith" prove_rule[]
	¨µi j k:Ó∑(i + j) + k = j + i + kÆ]);
a(ALL_FC_T rewrite_tac[sign_g_lemma1, sign_g_lemma2]);
a(PC_T1 "lin_arith" prove_tac[]);
val €sign_g_lemma4› = save_pop_thm "sign_g_lemma4";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm∑
	 ~(ÓØ 1) ^ m = ~(ÓØ 1) ^ (m Mod 2)
Æ);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim¨mÆ mod_2_cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[mod_2_0_Ø_Ó_exp_thm, mod_2_1_Ø_Ó_exp_thm]
	THEN rewrite_tac[Ø_Ó_exp_0_1_thm]);
val €Ø_Ó_exp_mod_2_thm› = save_pop_thm "Ø_Ó_exp_mod_2_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µI J K:˙ SET∑
	{(i, j)|i ç I ¿ J ± j ç K ± j < i} =
	{(i, j)|i ç I ± j ç K ± j < i} ¿
	{(i, j)|i ç J ± j ç K ± j < i}
±	{(i, j)|i ç I ± j ç J ¿ K ± j < i} =
	{(i, j)|i ç I ± j ç J ± j < i} ¿
	{(i, j)|i ç I ± j ç K ± j < i}
±	{(i, j)|i ç I ° J ± j ç K ± j < i} =
	{(i, j)|i ç I ± j ç K ± j < i} °
	{(i, j)|i ç J ± j ç K ± j < i}
±	{(i, j)|i ç I ± j ç J ° K ± j < i} =
	{(i, j)|i ç I ± j ç J ± j < i} °
	{(i, j)|i ç I ± j ç K ± j < i}
Æ);
a(PC_T1 "sets_ext1" prove_tac[]);
val €sign_g_lemma5› = save_pop_thm "sign_g_lemma5";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µI J:˙ SET∑
	I ç Finite ± J ç Finite
¥	{(i, j)|i ç I ± j ç J ± j < i} ç Finite
Æ);
a(REPEAT strip_tac THEN bc_thm_tac Ä_finite_thm);
a(∂_tac¨I ∏ JÆ THEN ALL_FC_T rewrite_tac[∏_finite_size_thm]);
a(rewrite_tac[∏_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €sign_g_lemma6› = save_pop_thm "sign_g_lemma6";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µS1; I J K:˙ SET∑
	(µx y∑S1 x y = ~ (ÓØ 1) ^ # {(i, j)|i ç x ± j ç y ± j < i})
±	I ç Finite
±	J ç Finite
±	K ç Finite
¥	S1 I J * S1 (I £ J) K
=	S1 I (J £ K) * S1 J K
Æ);
a(REPEAT strip_tac THEN asm_rewrite_tac[
	conv_rule(ONCE_MAP_C eq_sym_conv) Ø_Ó_exp_plus_thm]);
a(once_rewrite_tac[Ø_Ó_exp_mod_2_thm]);
a(bc_thm_tac(prove_rule[]¨µx:Ø; i j :Ó∑ i = j ¥ x^i = x^jÆ));
a(bc_thm_tac(rewrite_rule[](µ_elim¨Ãa b:˙ SET∑# {(i, j)|i ç a ± j ç b ± j < i}Æ sign_g_lemma4)));
a(asm_rewrite_tac[pc_rule1"sets_ext1" prove_rule[]
	¨{(i, j)|F} = {}Æ,
	size_empty_thm]);
a(DROP_ASMS_T discard_tac THEN rewrite_tac[sign_g_lemma5]);
a(REPEAT strip_tac THEN bc_thm_tac size_¿_thm
	THEN ALL_FC_T rewrite_tac[sign_g_lemma6]);
val €sign_g_lemma7› = save_pop_thm "sign_g_lemma7";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b c∑
	a ç Finite
±	b ç Finite
±	c ç Finite
¥	(#a + #(b £ c)) Mod 2 = (#(a £ b) + #c) Mod 2
Æ);
a(REPEAT strip_tac);
a(LEMMA_T ¨((#a + #(b £ c)) + 2 * #(b ° c)) Mod 2 =
	((#(a £ b) + #c) + 2 * #(a ° b)) Mod 2Æ
	(accept_tac o rewrite_rule[mod_2_clauses]));
a(LEMMA_T ¨((#a + #(b £ c)) + 2 * #(b ° c)) =
	((#(a £ b) + #c) + 2 * #(a ° b)) Æ
	rewrite_thm_tac);
a(rewrite_tac[plus_assoc_thm] THEN rewrite_tac[µ_elim¨#cÆ plus_order_thm]);
a(ALL_FC_T rewrite_tac[arb_gen £_finite_size_thm]);
a(PC_T1 "lin_arith" prove_tac[]);
val €sign_g_lemma8› = save_pop_thm "sign_g_lemma8";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µI J K : ˙ SET∑
	{i|i ç I ± i ç J ± i < Ó˙ 0} =
	{i|i ç I ± i < Ó˙ 0} ° {j|j ç J ± j < Ó˙ 0}
±	{i|i ç I ± i ç J £ K ± i < Ó˙ 0} =
	({i|i ç I ± i < Ó˙ 0} ° {j|j ç J ± j < Ó˙ 0}) £
	({i|i ç I ± i < Ó˙ 0} ° {k|k ç K ± k < Ó˙ 0})
±	{i|i ç I £ J ± i ç K ± i < Ó˙ 0} =
	({i|i ç I ± i < Ó˙ 0} ° {k|k ç K ± k < Ó˙ 0}) £
	({j|j ç J ± j < Ó˙ 0} ° {k|k ç K ± k < Ó˙ 0})
Æ);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext" prove_tac[]);
val €sign_g_lemma9› = save_pop_thm "sign_g_lemma9";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µS2; I J K:˙ SET∑
	(µx y∑S2 x y = ~ (ÓØ 1) ^ # {i|i ç x ± i ç y ± i < Ó˙ 0})
±	I ç Finite
±	J ç Finite
±	K ç Finite
¥	S2 I J * S2 (I £ J) K
=	S2 I (J £ K) * S2 J K
Æ);
a(REPEAT strip_tac THEN asm_rewrite_tac[
	conv_rule(ONCE_MAP_C eq_sym_conv) Ø_Ó_exp_plus_thm]);
a(once_rewrite_tac[Ø_Ó_exp_mod_2_thm]);
a(bc_thm_tac(prove_rule[]¨µx:Ø; i j :Ó∑ i = j ¥ x^i = x^jÆ));
a(rewrite_tac[sign_g_lemma9]);
a(bc_thm_tac sign_g_lemma8);
a(lemma_tac¨I ¿ J ¿ K ç FiniteÆ THEN1 asm_rewrite_tac[¿_finite_thm]);
a(LIST_DROP_NTH_ASM_T [2, 3, 4, 5] discard_tac);
a(REPEAT strip_tac THEN bc_thm_tac Ä_finite_thm
	THEN ∂_tac¨I ¿ J ¿ KÆ
	THEN REPEAT strip_tac
	THEN PC_T1 "sets_ext" asm_prove_tac[]);
val €sign_g_lemma10› = save_pop_thm "sign_g_lemma10";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µI J K:˙ SET∑
	I ç Finite
±	J ç Finite
±	K ç Finite
¥	SignâG I J * SignâG (I £ J) K
=	SignâG I (J £ K) * SignâG J K
Æ);
a(lemma_tac¨∂S1 S2∑
	(µx y:˙ SET∑S1 x y = ~ (ÓØ 1) ^ # {(i, j)|i ç x ± j ç y ± j < i})
±	(µx y:˙ SET∑S2 x y = ~ (ÓØ 1) ^ # {i|i ç x ± i ç y ± i < Ó˙ 0})Æ THEN1 prove_∂_tac);
a(REPEAT strip_tac);
a(LEMMA_T¨µx y∑SignâG x y = S1 x y * S2 x yÆ
	rewrite_thm_tac
	THEN1 (asm_rewrite_tac[sign_g_def, Ø_Ó_exp_plus_thm]));
a(rewrite_tac[Ø_times_assoc_thm]);
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µx1 y2 y1 x2:Ø∑ x1 * x2 * y1 * y2 = (x1 * y1) * (x2 * y2)Æ]);
a(ALL_FC_T rewrite_tac[sign_g_lemma7, sign_g_lemma10]);
val €sign_g_thm› = save_pop_thm "sign_g_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µv w K∑
	Supp v ç Finite ≤ Supp w ç Finite
¥	 {(I, J)|I ç Supp v ± J ç Supp w ± K = I £ J} ç Finite
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN bc_thm_tac Ä_finite_thm);
a(∂_tac¨{(I, J) | I ç Supp v ± K = I £ J}Æ
	THEN REPEAT strip_tac
	THEN_LIST [id_tac,  PC_T1 "sets_ext1" prove_tac[]]);
a(lemma_tac¨{(I, J)|I ç Supp v ± K = I £ J} ç Finite ±
	#{(I, J)|I ç Supp v ± K = I £ J} = #(Supp v)Æ
	THEN1 bc_thm_tac bijection_finite_size_thm);
a(once_rewrite_tac[£_inverse_thm]);
a(∂_tac¨ÃI∑(I, I £ K)Æ THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" once_rewrite_tac[] THEN rewrite_tac[]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1
	THEN REPEAT strip_tac);
a(∂_tac¨x1Æ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN bc_thm_tac Ä_finite_thm);
a(∂_tac¨{(I, J) | J ç Supp w ± K = I £ J}Æ
	THEN REPEAT strip_tac
	THEN_LIST [id_tac,  PC_T1 "sets_ext1" prove_tac[]]);
a(lemma_tac¨{(I, J)| J ç Supp w ± K = I £ J} ç Finite ±
	#{(I, J)| J ç Supp w ± K = I £ J} = #(Supp w)Æ
	THEN1 bc_thm_tac bijection_finite_size_thm);
a(once_rewrite_tac[£_group_thm]);
a(once_rewrite_tac[£_inverse_thm]);
a(∂_tac¨ÃJ∑(J £ K, J)Æ THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" once_rewrite_tac[] THEN rewrite_tac[]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1
	THEN REPEAT strip_tac);
a(∂_tac¨x2Æ THEN REPEAT strip_tac);
val €times_g_finite_thm› = save_pop_thm "times_g_finite_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µc v∑
	≥c = ÓØ 0 ¥ Supp (c _*âS v) = Supp v
Æ);
a(REPEAT strip_tac THEN PC_T1 "sets_ext1" rewrite_tac[supp_def, times_s_def]
	THEN µ_tac);
a(cases_tac¨v x = ÓØ 0Æ THEN asm_rewrite_tac[Ø_times_eq_0_thm]);
val €supp_times_s_thm› = save_pop_thm "supp_times_s_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µA∑
	Supp (— A) = A
Æ);
a(REPEAT strip_tac THEN PC_T1 "sets_ext1" rewrite_tac[supp_def, —_def]
	THEN µ_tac);
a(cases_tac¨x ç AÆ THEN asm_rewrite_tac[]);
val €supp_—_thm› = save_pop_thm "supp_—_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µA f∑
	A ç Finite
¥	ì A f = ì (A ° Supp f) f
Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨AÆ THEN1 rewrite_tac[ind_sum_def]);
a(cases_tac¨x ç Supp fÆ);
(* *** Goal "1" *** *)
a(LEMMA_T ¨({x} ¿ A) ° Supp f = {x} ¿ (A ° Supp f)Æ
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(LEMMA_T ¨≥x ç (A ° Supp f)Æ asm_tac
	THEN1 REPEAT strip_tac);
a(LEMMA_T ¨A ° Supp f ç FiniteÆ asm_tac
	THEN1 (bc_thm_tac Ä_finite_thm
		THEN ∂_tac¨AÆ  THEN REPEAT strip_tac
		THEN PC_T1 "sets_ext1" prove_tac[]));
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
(* *** Goal "2" *** *)
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[supp_def]));
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
a(LEMMA_T ¨({x} ¿ A) ° Supp f = (A ° Supp f)Æ
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
val €ind_sum_supp_thm› = save_pop_thm "ind_sum_supp_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µA B f g h∑
	A ç Finite
±	B ç Finite
±	(µx∑ x ç A ± ≥f x = ÓØ 0 ¥ h x ç B ± f x = g(h x))
±	(µy∑ y ç B ± ≥ g y = ÓØ 0 ¥ ∂â1x∑ x ç A ± h x = y ± f x = g y)
¥	ì A f = ì B g
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µC∑ C ç Finite ¥
	ì {x | x ç A ± ≥f x = ÓØ 0 ± h x ç C} f =
	ì (B ° C) gÆ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(finite_induction_tac¨CÆ);
(* *** Goal "1" *** *)
(* *** Goal "1.1" *** *)
a(rewrite_tac[ind_sum_def, pc_rule1 "sets_ext1" prove_rule[]¨{x|F} = {}Æ]);
(* *** Goal "1.2" *** *)
a(cases_tac¨x ç BÆ);
a(LEMMA_T¨B ° ({x} ¿ C) = {x} ¿ (B ° C)Æ rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(LEMMA_T¨≥x ç (B ° C)Æ asm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(lemma_tac¨B ° C ç FiniteÆ
	THEN1 (bc_thm_tac °_finite_thm THEN REPEAT strip_tac));
a(cases_tac¨g x = ÓØ 0Æ);
(* *** Goal "1.2.1.1" *** *)
a(LEMMA_T¨{x'|x' ç A ± ≥ f x' = ÓØ 0 ± h x' ç {x} ¿ C}
	= {x|x ç A ± ≥ f x = ÓØ 0 ± h x ç C}Æ
	asm_rewrite_thm_tac);
(* *** Goal "1.2.1.1.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [10] all_fc_tac);
a(swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[]);
(* *** Goal "1.2.1.1.2" *** *)
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
(* *** Goal "1.2.1.2" *** *)
a(spec_nth_asm_tac 8 ¨xÆ THEN 
	PC_T "predicates" all_var_elim_asm_tac1);
a(LEMMA_T¨{x''|x'' ç A ± ≥ f x'' = ÓØ 0 ± h x'' ç {h x'} ¿ C}
	= {x'} ¿ {x|x ç A ± ≥ f x = ÓØ 0 ± h x ç C}Æ
	asm_rewrite_thm_tac);
(* *** Goal "1.2.1.2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN_TRY all_var_elim_asm_tac1);
(* *** Goal "1.2.1.2.1.1" *** *)
a(swap_nth_asm_concl_tac 1);
a(spec_nth_asm_tac 16 ¨xÆ);
a(DROP_NTH_ASM_T 7 bc_thm_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.2.1.2.1.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "1.2.1.2.2" *** *)
a(LEMMA_T¨≥x' ç {x|x ç A ± ≥ f x = ÓØ 0 ± h x ç C}Æ
	asm_tac
	THEN1 asm_rewrite_tac[]);
a(lemma_tac¨{x|x ç A ± ≥ f x = ÓØ 0 ± h x ç C} ç FiniteÆ
	THEN1 (bc_thm_tac Ä_finite_thm
		THEN ∂_tac¨AÆ THEN REPEAT strip_tac
		THEN PC_T1 "sets_ext1" prove_tac[]));
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
(* *** Goal "1.2.2" *** *)
a(LEMMA_T¨B ° ({x} ¿ C) = B ° CÆ rewrite_thm_tac
	THEN1 (POP_ASM_T ante_tac THEN PC_T1 "sets_ext1" prove_tac[]));
a(LEMMA_T¨{x'|x' ç A ± ≥ f x' = ÓØ 0 ± h x' ç {x} ¿ C}
	= {x|x ç A ± ≥ f x = ÓØ 0 ± h x ç C}Æ
	asm_rewrite_thm_tac);
a(PC_T1 "sets_ext1" REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(spec_nth_asm_tac 8 ¨x'Æ);
(* *** Goal "2" *** *)
a(POP_ASM_T (ante_tac o µ_elim¨BÆ) THEN asm_rewrite_tac[]);
a(STRIP_T (rewrite_thm_tac o eq_sym_rule));
a(LEMMA_T ¨{x|x ç A ± ≥ f x = ÓØ 0 ± h x ç B} =
	A ° Supp fÆ rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[supp_def]
	THEN PC_T1 "sets_ext1" REPEAT strip_tac
	THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(ALL_FC_T rewrite_tac[ind_sum_supp_thm]);
val €ind_sum_transfer_thm› = save_pop_thm "ind_sum_transfer_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µx B; f:'a ∏ 'b ≠ Ø∑
	B ç Finite
¥	ì ({x} ∏ B) f = ì B (Ãy∑f(x, y))
Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨BÆ THEN1 rewrite_tac[ind_sum_def, ∏_def,
	pc_rule1 "sets_ext1" prove_rule[]¨{(x, y)|F} = {}Æ]);
a(LEMMA_T¨({x} ∏ ({x'} ¿ B)) = {(x,  x')} ¿ ({x} ∏ B)Ærewrite_thm_tac
	THEN1 MERGE_PCS_T1 ["'bin_rel", "'pair", "sets_ext1"] prove_tac[]);
a(LEMMA_T¨≥(x,  x') ç ({x} ∏ B)Æ asm_tac
	THEN1 MERGE_PCS_T1 ["'bin_rel", "sets_ext1"] prove_tac[]);
a(strip_asm_tac (µ_elim¨xÆ singleton_finite_thm));
a(lemma_tac¨({x} ∏ B) ç FiniteÆ
	THEN1 all_fc_tac[∏_finite_size_thm]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
val €ind_sum_singleton_∏_thm› = save_pop_thm "ind_sum_singleton_∏_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µf:'a ∏ 'b ≠ Ø; A B∑
	A ç Finite ± B ç Finite
¥	ì A (Ãx∑ì B (Ãy∑f(x, y))) = ì (A ∏ B) f
Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨AÆ THEN1 rewrite_tac[ind_sum_def, ∏_def,
	pc_rule1 "sets_ext1" prove_rule[]¨{(x, y)|F} = {}Æ]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_def]);
a(LEMMA_T¨(({x} ¿ A) ∏ B) = ({x} ∏ B) ¿ (A ∏ B)Ærewrite_thm_tac
	THEN1 MERGE_PCS_T1 ["'bin_rel", "'pair", "sets_ext1"] prove_tac[]);
a(strip_asm_tac (µ_elim¨xÆ singleton_finite_thm));
a(lemma_tac¨({x} ∏ B) ç Finite ± (A ∏ B) ç Finite Æ
	THEN1 ALL_FC_T rewrite_tac[∏_finite_size_thm]);
a(ALL_FC_T rewrite_tac[ind_sum_¿_thm, ind_sum_singleton_∏_thm]);
a(LEMMA_T¨({x} ∏ B) ° (A ∏ B) = {}Ærewrite_thm_tac
	THEN1 (MERGE_PCS_T1 ["'bin_rel", "'pair", "sets_ext1"] rewrite_tac[]
		THEN contr_tac THEN all_var_elim_asm_tac1));
a(rewrite_tac[ind_sum_def]);
val €ind_sum_∏_thm› = save_pop_thm "ind_sum_∏_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µA∑
	Supp _0âG = {}
±	Supp _1âG = {{}}
Æ);
a(rewrite_tac[zero_g_def, one_g_def, supp_—_thm, supp_clauses]);
val €supp_zero_one_g_thm› = save_pop_thm "supp_zero_one_g_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µv w∑
	Supp v ç Finite
¥	v _*âG w =
	ÃK∑ ì (Supp v) (Ã I∑ SignâG I (K £ I) * v I * w (K £ I))
Æ);
a(REPEAT strip_tac THEN rewrite_tac[times_g_def]);
a(lemma_tac¨{(I, J)|I ç Supp v ± J ç Supp w ± x = I £ J} ç FiniteÆ
	THEN1 ALL_FC_T asm_rewrite_tac[times_g_finite_thm]);
a(conv_tac eq_sym_conv);
a(bc_thm_tac ind_sum_transfer_thm);
a(rename_tac[(¨xÆ, "K")] THEN ∂_tac¨ÃI∑ (I, K £ I)Æ
	THEN PC_T1 "predicates" asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac);
a(rewrite_tac[Ø_times_eq_0_thm, supp_def]
	THEN taut_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "3" *** *)
a(rewrite_tac[]);
(* *** Goal "4" *** *)
a(lemma_tac¨µa b c:˙ SET∑((a £ b) £ a) = bÆ
	THEN1 (rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(∂â1_tac¨Fst yÆ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
val €times_g_def1› = save_pop_thm "times_g_def1";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µv w∑
	Supp w ç Finite
¥	v _*âG w =
	ÃK∑ ì (Supp w) (Ã J∑ SignâG (K £ J) J * v (K £ J) * w J)
Æ);
a(REPEAT strip_tac THEN rewrite_tac[times_g_def]);
a(lemma_tac¨{(I, J)|I ç Supp v ± J ç Supp w ± x = I £ J} ç FiniteÆ
	THEN1 ALL_FC_T asm_rewrite_tac[times_g_finite_thm]);
a(conv_tac eq_sym_conv);
a(bc_thm_tac ind_sum_transfer_thm);
a(rename_tac[(¨xÆ, "K")] THEN ∂_tac¨ÃJ∑ (K £ J, J)Æ
	THEN PC_T1 "predicates" asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac);
a(rewrite_tac[Ø_times_eq_0_thm, supp_def]
	THEN taut_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "3" *** *)
a(rewrite_tac[]);
(* *** Goal "4" *** *)
a(lemma_tac¨µa b c:˙ SET∑((b £ a) £ a) = bÆ
	THEN1 (rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(∂â1_tac¨Snd yÆ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
val €times_g_def2› = save_pop_thm "times_g_def2";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µv∑
	ÓØ 0 _*âS v = _0âG
Æ);
a(REPEAT strip_tac THEN rewrite_tac[zero_g_def, times_s_def]);
val €zero_times_s_thm› = save_pop_thm "zero_times_s_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µv∑
	_0âG _*âG v = _0âG
±	v _*âG _0âG = _0âG
Æ);
a(REPEAT µ_tac THEN rewrite_tac[times_g_def]);
a(rewrite_tac[supp_zero_one_g_thm, pc_rule1 "sets_ext1" prove_rule[]
	¨{(a, b)|F} = {}Æ,
	ind_sum_def]);
a(rewrite_tac[zero_g_def]);
val €zero_times_g_thm› = save_pop_thm "zero_times_g_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu v∑
	u _+âG v = v _+âG u
Æ);
a(REPEAT µ_tac THEN rewrite_tac[plus_g_def]);
val €plus_g_comm_thm› = save_pop_thm "plus_g_comm_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu v w∑
	(u _+âG v) _+âG w = u _+âG (v _+âG w)
Æ);
a(REPEAT µ_tac THEN rewrite_tac[plus_g_def, Ø_plus_assoc_thm]);
val €plus_g_assoc_thm› = save_pop_thm "plus_g_assoc_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu∑
	u _+âG _0âG = u
Æ);
a(REPEAT µ_tac THEN rewrite_tac[plus_g_def, zero_g_def]);
val €plus_g_0_thm› = save_pop_thm "plus_g_0_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu∑
	u _+âG (_~âG u) = _0âG
Æ);
a(REPEAT µ_tac THEN rewrite_tac[plus_g_def, minus_g_def, zero_g_def]);
val €plus_g_minus_g_thm› = save_pop_thm "plus_g_minus_g_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu∑
	ÓØ 1 _*âS u = u
Æ);
a(REPEAT µ_tac THEN rewrite_tac[times_s_def]);
val €one_times_s_thm› = save_pop_thm "one_times_s_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b u∑
	a _*âS (b _*âS u) = (a * b) _*âS u
Æ);
a(REPEAT µ_tac THEN rewrite_tac[times_s_def, Ø_times_assoc_thm]);
val €times_s_times_s_thm› = save_pop_thm "times_s_times_s_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa u v∑
	a _*âS (u _+âG v) = (a _*âS u) _+âG (a _*âS v)
Æ);
a(REPEAT µ_tac THEN rewrite_tac[times_s_def, plus_g_def, Ø_times_plus_distrib_thm]);
val €times_s_plus_g_distrib_thm› = save_pop_thm "times_s_plus_g_distrib_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b u∑
	(a + b) _*âS u = (a _*âS u) _+âG (b _*âS u)
Æ);
a(REPEAT µ_tac THEN rewrite_tac[times_s_def, plus_g_def, Ø_times_plus_distrib_thm]);
val €plus_times_s_distrib_thm› = save_pop_thm "plus_times_s_distrib_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu v w∑
	Supp u ç Finite ± Supp u Ä Finite
±	Supp v ç Finite ± Supp v Ä Finite
±	Supp w ç Finite ± Supp w Ä Finite
¥	(u _*âG v) _*âG w = u _*âG (v _*âG w)
Æ);
a(REPEAT strip_tac);
a(PC_T1 "predicates" (ALL_FC_T rewrite_tac) [arb_gen times_g_def2]);
a(PC_T1 "predicates" (ALL_FC_T rewrite_tac) [times_g_def1]);
a(LEMMA_T ¨µf; c:Ø∑ì (Supp v) f * c = ì (Supp v) (ÃI∑f I * c)Æ
	rewrite_thm_tac
	THEN1 (once_rewrite_tac[Ø_times_comm_thm]
		THEN ALL_FC_T rewrite_tac[ind_sum_const_times_thm]));
a(LEMMA_T ¨µf; c:Ø∑c * ì (Supp v) f = ì (Supp v) (ÃJ∑c * f J)Æ
	rewrite_thm_tac
	THEN1 ALL_FC_T rewrite_tac[ind_sum_const_times_thm]);
a(LEMMA_T ¨µf; c:Ø∑c * ì (Supp w) f = ì (Supp w) (ÃJ∑c * f J)Æ
	rewrite_thm_tac
	THEN1 ALL_FC_T rewrite_tac[ind_sum_const_times_thm]);
a(ALL_FC_T rewrite_tac[rewrite_rule[](µ_elim¨(Ã (K, L)∑ SignâG (x £ K) K * (SignâG ((x £ K) £ L) L * u ((x £ K) £ L) * v L) * r K)Æ
ind_sum_∏_thm)]);
a(ALL_FC_T rewrite_tac[rewrite_rule[](µ_elim¨Ã(I, J)∑SignâG I (x £ I) * u I * SignâG ((x £ I) £ J) J * v ((x £ I) £ J) * w JÆ
ind_sum_∏_thm)]);
a(lemma_tac¨(Supp w ∏ Supp v) ç Finite ± (Supp u ∏ Supp w) ç FiniteÆ
	THEN1 ALL_FC_T rewrite_tac[∏_finite_size_thm]);
a(bc_thm_tac ind_sum_transfer_thm);
a(∂_tac¨Ã(K, L)∑ ((x £ K) £ L, K)Æ
	THEN asm_rewrite_tac[]
	THEN rewrite_tac[∏_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[Ø_times_eq_0_thm, supp_def]
	THEN taut_tac);
(* *** Goal "2" *** *)
a(conv_tac(ONCE_MAP_C(£_nf_conv(hd(snd(dest_ctype(type_of¨xÆ)))))));
a(lemma_tac¨Fst x' ç Finite ± Snd x' ç FiniteÆ
	THEN1 LIST_DROP_NTH_ASM_T[6, 8]
		(PC_T1 "sets_ext1" (ALL_FC_T rewrite_tac)));
a(lemma_tac¨Fst x' £ Snd x' ç FiniteÆ
	THEN1 all_fc_tac[£_finite_size_thm]);
a(cases_tac¨≥x ç FiniteÆ);
(* *** Goal "2.1" *** *)
a(lemma_tac¨≥x £ Fst x' £ Snd x' ç FiniteÆ
	THEN1 all_fc_tac[£_infinite_thm]);
a(cases_tac¨x £ Fst x' £ Snd x' ç Supp uÆ
	THEN1 LIST_DROP_NTH_ASM_T[16]
		(PC_T1 "sets_ext1" all_fc_tac));
a(POP_ASM_T ante_tac THEN rewrite_tac[supp_def]);
a(STRIP_T rewrite_thm_tac);
(* *** Goal "2.2" *** *)
a(rewrite_tac[µ_elim¨SignâG (x £ Fst x' £ Snd x') (Snd x')Æ
	Ø_times_order_thm]
	THEN rewrite_tac[Ø_times_assoc_thm1]);
a(lemma_tac¨x £ Fst x' £ Snd x' ç FiniteÆ
	THEN1 all_fc_tac[£_finite_size_thm]);
a(LEMMA_T ¨x £ Fst x' = (x £ Fst x' £ Snd x') £ Snd x'Æ
	rewrite_thm_tac
	THEN1 (conv_tac  (ONCE_MAP_C(£_nf_conv(hd(snd(dest_ctype(type_of¨xÆ))))))
		THEN strip_tac));
a(ALL_FC_T rewrite_tac[sign_g_thm]);
a(LEMMA_T ¨(Snd x' £ Fst x') = (Fst x' £ Snd x')Æ
	rewrite_thm_tac
	THEN1 (conv_tac  (ONCE_MAP_C(£_nf_conv(hd(snd(dest_ctype(type_of¨xÆ))))))
		THEN strip_tac));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[Ø_times_eq_0_thm]
	THEN REPEAT strip_tac);
a(∂â1_tac¨(Snd y, (x £ Fst y) £ Snd y)Æ
	THEN1 asm_rewrite_tac[supp_def]
	THEN conv_tac  (ONCE_MAP_C(£_nf_conv(hd(snd(dest_ctype(type_of¨xÆ)))))));
a(REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(lemma_tac¨Fst y ç Finite ± Snd y ç FiniteÆ
	THEN1 LIST_DROP_NTH_ASM_T[14, 10]
		(PC_T1 "sets_ext1" (ALL_FC_T rewrite_tac)));
a(lemma_tac¨Fst y £ Snd y ç FiniteÆ
	THEN1 all_fc_tac[£_finite_size_thm]);
a(cases_tac¨≥x ç FiniteÆ);
(* *** Goal "3.1.1" *** *)
a(lemma_tac¨≥x £ Fst y £ Snd y ç FiniteÆ
	THEN1 all_fc_tac[£_infinite_thm]);
a(cases_tac¨x £ Fst y £ Snd y ç Supp vÆ
	THEN1 LIST_DROP_NTH_ASM_T[18]
		(PC_T1 "sets_ext1" all_fc_tac));
a(POP_ASM_T ante_tac THEN rewrite_tac[supp_def]);
a(STRIP_T rewrite_thm_tac);
(* *** Goal "3.1.2" *** *)
a(rewrite_tac[µ_elim¨SignâG (Fst y) (x £ Fst y £ Snd y)Æ
	Ø_times_order_thm]
	THEN rewrite_tac[Ø_times_assoc_thm1]);
a(lemma_tac¨x £ Fst y £ Snd y ç FiniteÆ
	THEN1 all_fc_tac[£_finite_size_thm]);
a(LEMMA_T ¨x £ Snd y = Fst y £ (x £ Fst y £ Snd y)Æ
	rewrite_thm_tac
	THEN1 (conv_tac  (ONCE_MAP_C(£_nf_conv(hd(snd(dest_ctype(type_of¨xÆ))))))
		THEN strip_tac));
a(ALL_FC_T rewrite_tac[sign_g_thm]);
a(conv_tac(ONCE_MAP_C(£_nf_conv(hd(snd(dest_ctype(type_of¨xÆ)))))));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "3.2" *** *)
a(DROP_NTH_ASM_T 3 (rewrite_thm_tac o eq_sym_rule));
a(asm_rewrite_tac[]);
a(conv_tac(ONCE_MAP_C(£_nf_conv(hd(snd(dest_ctype(type_of¨xÆ))))))
	THEN REPEAT strip_tac);
val €times_g_assoc_thm› = save_pop_thm "times_g_assoc_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu v w∑
	Supp u ç Finite
¥	u _*âG (v _+âG w) = (u _*âG v) _+âG (u _*âG w)
±	(v _+âG w) _*âG u = (v _*âG u) _+âG (w _*âG u)
Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(PC_T1 "predicates" (ALL_FC_T rewrite_tac)[arb_gen times_g_def1, arb_gen times_g_def2]);
a(rewrite_tac[plus_g_def, Ø_times_plus_distrib_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(conv_tac(LEFT_C(RAND_C(SIMPLE_Ã_C(RANDS_C(un_¬_conv¨I:˙ SETÆ))))));
a(ALL_FC_T rewrite_tac[ind_sum_plus_thm]);
(* *** Goal "2" *** *)
a(conv_tac(LEFT_C(RAND_C(SIMPLE_Ã_C(RANDS_C(un_¬_conv¨J:˙ SETÆ))))));
a(ALL_FC_T rewrite_tac[ind_sum_plus_thm]);
val €times_g_plus_g_distrib_thm› = save_pop_thm "times_g_plus_g_distrib";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu v a∑
	Supp u ç Finite
±	Supp v ç Finite
¥	(a _*âS u) _*âG v = a _*âS (u _*âG v)
Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(cases_tac¨a = ÓØ 0Æ THEN1 PC_T1 "predicates" asm_rewrite_tac[zero_times_s_thm, zero_times_g_thm]);
a(lemma_tac¨Supp (a _*âS u) ç FiniteÆ
	THEN1 ALL_FC_T asm_rewrite_tac[supp_times_s_thm]);
a(PC_T1 "predicates" (ALL_FC_T rewrite_tac)[times_g_def1]);
a(ALL_FC_T rewrite_tac[supp_times_s_thm]);
a(µ_tac THEN rewrite_tac[times_s_def]);
a(rewrite_tac[µ_elim¨aÆØ_times_order_thm]);
a(pure_rewrite_tac[prove_rule[]
	¨ (Ã I∑ a * SignâG I (x £ I) * u I * v (x £ I)) =
	ÃI∑a * (Ã I∑ SignâG I (x £ I) * u I * v (x £ I)) I Æ]);
a(ALL_FC_T rewrite_tac[ind_sum_const_times_thm]);
val €times_s_times_g_assoc_thm› = save_pop_thm "times_s_times_g_assoc_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu∑
	_1âG _*âG u = u
±	u _*âG _1âG = u
Æ);
a(REPEAT µ_tac);
a(lemma_tac¨Supp _1âG ç FiniteÆ
	THEN1 rewrite_tac[supp_zero_one_g_thm, singleton_finite_thm]);
a(ALL_FC_T rewrite_tac[times_g_def1, times_g_def2]);
a(rewrite_tac[supp_zero_one_g_thm, ind_sum_singleton_thm,
	sign_g_def, £_clauses,
	pc_rule1 "sets_ext1" prove_rule[] ¨{i|F} = {} ± {(i, j) | F} = {}Æ,
	size_empty_thm, one_g_def, —_def]);
val €one_g_times_g_thm› = save_pop_thm "one_g_times_g_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µI i j∑
	I £ {i} = {j} § i = j ± I = {} ≤ ≥i = j ± I = {i; j}
Æ);
a(REPEAT µ_tac);
a(rewrite_tac[pc_rule1 "sets_ext1" prove_rule[£_def] 
¨µa b c∑a £ b = c § a = b £ cÆ]);
a(REPEAT_UNTIL is_≤ strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1);
a(cases_tac¨i = jÆ THEN asm_rewrite_tac[£_clauses]);
a(rewrite_tac[pc_rule1 "sets_ext1" prove_rule[] 
¨{i; j} = {i} ¿ {j}Æ]);
a(lemma_tac¨≥j = iÆ THEN1 (contr_tac THEN all_var_elim_asm_tac1));
a(LEMMA_T ¨{i} ° {j} = {}Æ ante_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(rewrite_tac[£_eq_¿_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[£_clauses]);
(* *** Goal "3" *** *)
a(all_var_elim_asm_tac1);
a(rewrite_tac[pc_rule1 "sets_ext1" prove_rule[] 
¨{i; j} = {i} ¿ {j}Æ]);
a(lemma_tac¨≥j = iÆ THEN1 (contr_tac THEN all_var_elim_asm_tac1));
a(LEMMA_T ¨{i} ° {j} = {}Æ ante_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(rewrite_tac[£_eq_¿_thm] THEN STRIP_T rewrite_thm_tac);
val €times_g_singleton_lemma› = save_pop_thm "times_g_singleton_lemma";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µp f g x∑
	(if p then f else g) x = if p then f x else g x
Æ);
a(REPEAT strip_tac);
a(cases_tac¨pÆ THEN asm_rewrite_tac[]);
val €app_if_thm› = save_pop_thm "app_if_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨ µi∑ SignâG {i} {i} =
	if i < Ó˙ 0 then ~(ÓØ 1) else ÓØ 1 Æ);
a(REPEAT strip_tac THEN rewrite_tac[sign_g_def]);
a(LEMMA_T ¨{(i', j)|i' = i ± j = i ± j < i'} = {}Æ rewrite_thm_tac
	THEN1 (PC_T1 "sets_ext1" REPEAT strip_tac
		THEN all_var_elim_asm_tac1));
a(PC_T1 "predicates" cases_tac ¨i < Ó˙ 0Æ THEN asm_rewrite_tac[size_empty_thm]);
(* *** Goal "1" *** *)
a(LEMMA_T ¨{i'|i' = i ± i' = i ± i' < Ó˙ 0} = {i}Æ rewrite_thm_tac
	THEN1 (PC_T1 "sets_ext1" REPEAT strip_tac
		THEN all_var_elim_asm_tac1));
a(rewrite_tac[size_singleton_thm, Ø_Ó_exp_0_1_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨{i'|i' = i ± i' = i ± i' < Ó˙ 0} = {}Æ rewrite_thm_tac
	THEN1 (PC_T1 "sets_ext1" REPEAT strip_tac
		THEN all_var_elim_asm_tac1));
a(rewrite_tac[size_empty_thm, Ø_Ó_exp_0_1_thm]);
val €sign_singleton_thm› = save_pop_thm "sign_singleton_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨ µi j∑ ≥i = j ¥ SignâG {i} {j} =
	if i < j then ÓØ 1 else ~(ÓØ 1) Æ);
a(REPEAT strip_tac THEN rewrite_tac[sign_g_def]);
a(LEMMA_T ¨{i'|i' = i ± i' = j ± i' < Ó˙ 0} = {}Æ rewrite_thm_tac
	THEN1 (PC_T1 "sets_ext1" REPEAT strip_tac
		THEN all_var_elim_asm_tac1));
a(PC_T1 "predicates" cases_tac¨i < jÆ
	THEN asm_rewrite_tac[size_empty_thm]);
(* *** Goal "1" *** *)
a(LEMMA_T ¨{(i', j')| i' = i ± j' = j ± j' < i'} = {}Æ rewrite_thm_tac
	THEN1 (PC_T1 "sets_ext1" REPEAT strip_tac
		THEN all_var_elim_asm_tac1
		THEN PC_T1 "˙_lin_arith" asm_prove_tac[]));
a(rewrite_tac[size_empty_thm, Ø_Ó_exp_0_1_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨{(i', j')| i' = i ± j' = j ± j' < i'} = {(i, j)}Æ rewrite_thm_tac
	THEN1 (PC_T "sets_ext1" strip_tac
		THEN REPEAT strip_tac
		THEN all_var_elim_asm_tac1
		THEN PC_T1 "˙_lin_arith" asm_prove_tac[]));
a(rewrite_tac[size_singleton_thm, Ø_Ó_exp_0_1_thm]);
val €sign_singletons_thm› = save_pop_thm "sign_singletons_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µi j∑
	—{{i}} _*âG —{{j}} =
	if	i < j
	then	—{{i; j}}
	else if	j < i
	then	~(ÓØ 1) _*âS —{{i; j}}
	else if	i < Ó˙ 0
	then	~(ÓØ 1) _*âS _1âG
	else	 _1âG
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨Supp (—{{i}}) = {{i}}Æ
	THEN1 rewrite_tac[supp_—_thm]);
a(lemma_tac¨Supp (—{{i}}) ç FiniteÆ
	THEN1 asm_rewrite_tac[singleton_finite_thm]);
a(ALL_FC_T rewrite_tac[times_g_def1]);
a(asm_rewrite_tac[ind_sum_singleton_thm, app_if_thm]);
a(rewrite_tac[—_def, times_g_singleton_lemma, times_s_def]);
a(cases_tac¨i = jÆ THEN1 all_var_elim_asm_tac1
	THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(cases_tac¨x = {}Æ THEN
	asm_rewrite_tac[one_g_def, —_def,
			sign_singleton_thm, £_clauses]);
a(PC_T1 "predicates" cases_tac¨j < Ó˙ 0Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(cases_tac¨x = {i; j}Æ THEN1 all_var_elim_asm_tac1
	THEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a(LEMMA_T¨{i; j} £ {i} = {j}Æ rewrite_thm_tac
	THEN1 (PC_T1 "sets_ext1" rewrite_tac[£_def]
		THEN REPEAT strip_tac
		THEN all_var_elim_asm_tac1));
a(ALL_FC_T rewrite_tac[sign_singletons_thm]);
a(PC_T1 "predicates" lemma_tac ¨i < j ≤ ≥i < j ± j < iÆ
	THEN1 PC_T1 "˙_lin_arith" asm_prove_tac[]
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(PC_T1 "predicates" lemma_tac ¨i < j ≤ ≥i < j ± j < iÆ
	THEN1 PC_T1 "˙_lin_arith" asm_prove_tac[]
	THEN asm_rewrite_tac[]);
val €times_g_singleton_thm› = save_pop_thm "times_g_singleton_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu v∑
	Supp u ç Finite ± Supp u Ä Finite
±	Supp v ç Finite ± Supp v Ä Finite
¥	Supp (u _+âG v) ç Finite ± Supp (u _+âG v) Ä Finite
Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(lemma_tac¨Supp (u _+âG v) Ä Supp u ¿ Supp vÆ
	THEN1 rewrite_tac[plus_g_def, supp_clauses]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨Supp u ¿ Supp vÆ
	THEN asm_rewrite_tac[¿_finite_thm]);
(* *** Goal "2" *** *)
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]
	¨µb c d∑b Ä d ± c Ä d ¥ b ¿ c Ä dÆ]
	THEN all_fc_tac[
		pc_rule1 "sets_ext1" prove_rule[]
		¨µa b c∑a Ä b ± b Ä c ¥ a Ä cÆ]);
val €plus_g_finitary_thm› = save_pop_thm "plus_g_finitary_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa u∑
	Supp u ç Finite ± Supp u Ä Finite
¥	Supp (a _*âS u) ç Finite ± Supp (a _*âS u) Ä Finite
Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(cases_tac¨a = ÓØ 0Æ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[zero_times_s_thm, zero_times_g_thm,
	supp_zero_one_g_thm, empty_finite_thm]);
(* *** Goal "2" *** *)
a(ALL_FC_T asm_rewrite_tac[supp_times_s_thm]);
val €times_s_finitary_thm› = save_pop_thm "times_s_finitary_thm";

=TEX
%%%%
%%%%

=SML
(*
set_goal([], ¨µv w∑
	Supp v ç Finite ± Supp v Ä Finite
±	Supp w ç Finite ± Supp v Ä Finite
¥	Supp (v _*âG w) ç Finite
Æ);
times_g_finite_thm;

a(REPEAT strip_tac THEN rewrite_tac[times_g_def]);
val €times_g_assoc_thm› = save_pop_thm "times_g_assoc_thm";
*)
=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val €sections› = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="geomalg.th.doc", theory="geomalg"};
end;
=TEX
} %\Hide
\end{document}


