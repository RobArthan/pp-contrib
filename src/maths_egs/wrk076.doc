=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}
\def\Hide#1{\relax}
\title{Mathematical Case Studies: the Geometric Algebra}
\author{Rob Arthan}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
This document develops the basic theory of the Geometric Algebra.
$GA(\infty)$.
\end{abstract}
\section{INTRODUCTION}
This document is one of a set of documents containing mathematical case studies in  {\ProductHOL}.
It deals with real vector spaces and the Geometric Algebra.
\section{REAL VECTOR SPACES}
=SML
force_delete_theory"geomalg" handle Fail _ => ();
open_theory"fincomb";
new_theory"geomalg";
new_parent "groups";
new_parent "numbers";
set_merge_pcs["basic_hol1", "'sets_alg", "'ú", "'¯"];
=TEX

\section{THE GEOMETRIC ALGEBRA}


It is very convenient to have available the symmetric difference operator for sets. Indeed, it would be nice for this to be moved into the basic HOL theory of sets.
We follow Z in writing the symmetric difference of $a$ and $b$ as
=INLINEFT
a £ b
=TEX

=SML
declare_infix(250, "£");

¹HOLCONST
Ü $£ : 'a SET ­ 'a SET ­ 'a SET
÷üüüüüü
Ü µa b· a £ b = (a \ b) À (b \ a)
°

\subsection{The Algebra Operations}
¹HOLCONST
Ü ÛSign‰Gİ : î SET ­ î SET ­ ¯
÷üüüüüü
Ü µ I J· Sign‰G I J = ~(î¯ 1) ^ #{(i, j) | i  I ± j  J ± j < i}
°
=SML
declare_infix(300, "+‰G");
declare_type_abbrev("GA", [], ”î SET ­ ¯®);

¹HOLCONST
Ü $+‰G : GA ­ GA ­ GA
÷üüüüüü
Ü µ v w·
Ü	v +‰G w = ÌK· v K + w K
°
=SML
declare_infix(310, "*‰G");

¹HOLCONST
Ü $*‰G : GA ­ GA ­ GA
÷üüüüüü
Ü µ v w·
Ü	v *‰G w = ÌK·
Ü	“ {(I, J) | I  Supp v ± J  Supp w ± K = I £ J}
Ü	(Ì(I, J)· Sign‰G I J * v I * w J)
°
=SML
declare_infix(310, "*‰S");

¹HOLCONST
Ü $*‰S : ¯ ­ GA ­ GA
÷üüüüüü
Ü µ c v· c *‰S v = ÌK·c * v K
°

¹HOLCONST
Ü 0‰G : GA
÷üüüüüü
Ü 0‰G = ÌK· î¯ 0
°
¹HOLCONST
Ü 1‰G : GA
÷üüüüüü
Ü 1‰G = Ñ{{}}
°

=TEX

%\bibliographystyle{fmu}
%\bibliography{fmu}

%\appendix
{%\HOLindexOff
\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{geomalg.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
=TEX
%%%%
%%%%
=SML
=SML
=TEX
%%%%
%%%%

=TEX

=SML
val Û£_defİ = get_spec¬$£®;
val Ûsign_g_defİ = get_spec¬Sign‰G®;
val Ûplus_g_defİ = get_spec¬$+‰G®;
val Ûtimes_g_defİ = get_spec¬$*‰G®;
val Ûtimes_s_defİ = get_spec¬$*‰S®;
val Ûzero_g_defİ = get_spec¬0‰G®;
val Ûone_g_defİ = get_spec¬1‰G®;
=TEX
=SML
val Ûmod_2_clausesİ = rewrite_rule[] (µ_elim¬2®mod_clauses);
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b c·
	a £ {} = a
±	{} £ a = a
±	a £ b = b £ a
±	a £ b £ c = (a £ b) £ c®);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_group_thmİ = save_pop_thm "£_group_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b c·
	a £ b £ c = (a £ b) £ c®);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_assoc_thmİ = save_pop_thm "£_assoc_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa·
	a £ {} = a
±	{} £ a = a
±	a £ a = {}®);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_clausesİ = save_pop_thm "£_clauses";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b·
	a ¡ b = {} ¤ a £ b = a À b®);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_eq_À_thmİ = save_pop_thm "£_eq_À_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b· a  Finite ± b  Finite ´ a £ b  Finite®);
a(REPEAT strip_tac THEN bc_thm_tac €_finite_thm
	THEN ¶_tac¬a À b®
	THEN asm_rewrite_tac[£_def, À_finite_thm]
	THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_finite_thmİ = save_pop_thm "£_finite_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µf a b·
	f {} = 0
±	(µa b· a  Finite ± b  Finite
	´	f(a À b) + f(a ¡ b) = f a + f b)
±	a  Finite
±	b  Finite
´	f(a £ b) + 2*f(a ¡ b) = f a + f b
®);
a(REPEAT strip_tac);
a(lemma_tac¬a À b  Finite® THEN1 asm_rewrite_tac[À_finite_thm]);
a(lemma_tac¬a ¡ b  Finite® THEN1 ALL_FC_T rewrite_tac[¡_finite_thm]);
a(lemma_tac¬a £ b  Finite® THEN1 all_fc_tac[£_finite_thm]);
a(LIST_SPEC_NTH_ASM_T 6 [¬a £ b®, ¬a ¡ b®] ante_tac);
a(LIST_SPEC_NTH_ASM_T 6 [¬a®, ¬b®] ante_tac);
a(DROP_NTH_ASM_T 6 discard_tac);
a(LEMMA_T ¬(a £ b) À a ¡ b = a À b ± (a £ b) ¡ a ¡ b = {}®
	asm_rewrite_thm_tac
	THEN1 (rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(PC_T1 "lin_arith" prove_tac[]);
val Ûsize_£_lemmaİ = save_pop_thm "size_£_lemma";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b·
	a  Finite
±	b  Finite
´	#(a £ b) + 2 * #(a ¡ b) = #a + #b
®);
a(REPEAT strip_tac THEN bc_thm_tac size_£_lemma);
a(asm_rewrite_tac[size_empty_thm, size_À_thm]);
val Ûsize_£_thmİ = save_pop_thm "size_£_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µt a b c·
	(µa·t a {} = 0)
±	(µa b c·a  Finite ± b  Finite ± c  Finite
	´	t a (b À c) + t a (b ¡ c) = t a b + t a c)
±	a  Finite ± b  Finite ± c  Finite
´	t a (b £ c) + 2 * t a (b ¡ c) = t a b + t a c
®);
a(REPEAT strip_tac);
a(bc_thm_tac size_£_lemma THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
val Ûsign_g_lemma1İ = save_pop_thm "sign_g_lemma1";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µt a b c·
	(µa·t {} a = 0)
±	(µa b c·a  Finite ± b  Finite ± c  Finite
	´	t (a À b) c + t (a ¡ b) c = t a c + t b c)
±	a  Finite ± b  Finite ± c  Finite
´	t (a £ b) c + 2 * t (a ¡ b) c = t a c + t b c
®);
a(REPEAT strip_tac);
a(bc_thm_tac(rewrite_rule[](µ_elim¬Ìx y· t y x® sign_g_lemma1)));
a(asm_rewrite_tac[] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val Ûsign_g_lemma2İ = save_pop_thm "sign_g_lemma2";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µt a b c·
	(µa·t a {} = 0)
±	(µa b c·a  Finite ± b  Finite ± c  Finite
	´	t a (b À c) + t a (b ¡ c) = t a b + t a c)
±	(µa·t {} a = 0)
±	(µa b c·a  Finite ± b  Finite ± c  Finite
	´	t (a À b) c + t (a ¡ b) c = t a c + t b c)
±	a  Finite ± b  Finite ± c  Finite
´	(t a (b £ c) + t b c) Mod 2 = (t (a £ b) c + t a b) Mod 2
®);
a(REPEAT strip_tac);
a(LEMMA_T ¬((t a (b £ c) + t b c) + 2 * t a (b ¡ c)) Mod 2 =
	((t (a £ b) c + t a b) + 2 * t (a ¡ b) c) Mod 2®
	(accept_tac o rewrite_rule[mod_2_clauses]));
a(LEMMA_T ¬((t a (b £ c) + t b c) + 2 * t a (b ¡ c)) =
	((t (a £ b) c + t a b) + 2 * t (a ¡ b) c)®
	rewrite_thm_tac);
a(rewrite_tac[pc_rule1"lin_arith" prove_rule[]
	¬µi j k:î·(i + j) + k = j + i + k®]);
a(ALL_FC_T rewrite_tac[sign_g_lemma1, sign_g_lemma2]);
a(PC_T1 "lin_arith" prove_tac[]);
val Ûsign_g_lemma4İ = save_pop_thm "sign_g_lemma4";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µm·
	 ~(î¯ 1) ^ m = ~(î¯ 1) ^ (m Mod 2)
®);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim¬m® mod_2_cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[mod_2_0_¯_î_exp_thm, mod_2_1_¯_î_exp_thm]
	THEN rewrite_tac[¯_î_exp_0_1_thm]);
val Û¯_î_exp_mod_2_thmİ = save_pop_thm "¯_î_exp_mod_2_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µI J K:î SET·
	{(i, j)|i  I À J ± j  K ± j < i} =
	{(i, j)|i  I ± j  K ± j < i} À
	{(i, j)|i  J ± j  K ± j < i}
±	{(i, j)|i  I ± j  J À K ± j < i} =
	{(i, j)|i  I ± j  J ± j < i} À
	{(i, j)|i  I ± j  K ± j < i}
±	{(i, j)|i  I ¡ J ± j  K ± j < i} =
	{(i, j)|i  I ± j  K ± j < i} ¡
	{(i, j)|i  J ± j  K ± j < i}
±	{(i, j)|i  I ± j  J ¡ K ± j < i} =
	{(i, j)|i  I ± j  J ± j < i} ¡
	{(i, j)|i  I ± j  K ± j < i}
®);
a(PC_T1 "sets_ext1" prove_tac[]);
val Ûsign_g_lemma5İ = save_pop_thm "sign_g_lemma5";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µI J:î SET·
	I  Finite ± J  Finite
´	{(i, j)|i  I ± j  J ± j < i}  Finite
®);
a(REPEAT strip_tac THEN bc_thm_tac €_finite_thm);
a(¶_tac¬I ¸ J® THEN ALL_FC_T rewrite_tac[¸_finite_size_thm]);
a(rewrite_tac[¸_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Ûsign_g_lemma6İ = save_pop_thm "sign_g_lemma6";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µI J K·
	I  Finite
±	J  Finite
±	K  Finite
´	Sign‰G (I £ J) K * Sign‰G I J
=	Sign‰G I (J £ K) * Sign‰G J K
®);
a(REPEAT strip_tac THEN rewrite_tac[sign_g_def,
	conv_rule(ONCE_MAP_C eq_sym_conv) ¯_î_exp_plus_thm]);
a(once_rewrite_tac[¯_î_exp_mod_2_thm]);
a(bc_thm_tac(prove_rule[]¬µx:¯; i j :î· j = i ´ x^i = x^j®));
a(bc_thm_tac(rewrite_rule[](µ_elim¬Ìa b:î SET·# {(i, j)|i  a ± j  b ± j < i}® sign_g_lemma4)));
a(asm_rewrite_tac[pc_rule1"sets_ext1" prove_rule[]
	¬{(i, j)|F} = {}®,
	size_empty_thm]);
a(DROP_ASMS_T discard_tac THEN rewrite_tac[sign_g_lemma5]);
a(REPEAT strip_tac THEN bc_thm_tac size_À_thm
	THEN ALL_FC_T rewrite_tac[sign_g_lemma6]);
val Ûsign_g_thmİ = save_pop_thm "sign_g_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µv w K·
	Supp v  Finite ± Supp w  Finite
´	 {(I, J)|I  Supp v ± J  Supp w ± K = I £ J}  Finite
®);
a(REPEAT strip_tac THEN bc_thm_tac €_finite_thm);
a(¶_tac¬Supp v ¸ Supp w® THEN ALL_FC_T rewrite_tac[¸_finite_size_thm]);
a(rewrite_tac[¸_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Ûtimes_g_finite_thmİ = save_pop_thm "times_g_finite_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µc v·
	³c = î¯ 0 ´ Supp (c *‰S v) = Supp v
®);
a(REPEAT strip_tac THEN PC_T1 "sets_ext1" rewrite_tac[supp_def, times_s_def]
	THEN µ_tac);
a(cases_tac¬v x = î¯ 0® THEN asm_rewrite_tac[¯_times_eq_0_thm]);
val Ûsupp_times_s_thmİ = save_pop_thm "supp_times_s_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µA·
	Supp (Ñ A) = A
®);
a(REPEAT strip_tac THEN PC_T1 "sets_ext1" rewrite_tac[supp_def, Ñ_def]
	THEN µ_tac);
a(cases_tac¬x  A® THEN asm_rewrite_tac[]);
val Ûsupp_Ñ_thmİ = save_pop_thm "supp_Ñ_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µA·
	Supp 0‰G = {}
±	Supp 1‰G = {{}}
®);
a(rewrite_tac[zero_g_def, one_g_def, supp_Ñ_thm, supp_clauses]);
val Ûsupp_zero_one_g_thmİ = save_pop_thm "supp_zero_one_g_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µv·
	î¯ 0 *‰S v = 0‰G
®);
a(REPEAT strip_tac THEN rewrite_tac[zero_g_def, times_s_def]);
val Ûzero_times_s_thmİ = save_pop_thm "zero_times_s_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µv·
	0‰G *‰G v = 0‰G
±	v *‰G 0‰G = 0‰G
®);
a(REPEAT µ_tac THEN rewrite_tac[times_g_def]);
a(rewrite_tac[supp_zero_one_g_thm, pc_rule1 "sets_ext1" prove_rule[]
	¬{(a, b)|F} = {}®,
	ind_sum_def]);
a(rewrite_tac[zero_g_def]);
val Ûzero_times_g_thmİ = save_pop_thm "zero_times_g_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µv w c·
	Supp v  Finite
±	Supp w  Finite
´	(c *‰S v) *‰G w = c *‰S (v *‰G w)
®);
a(REPEAT µ_tac THEN ´_tac);
a(cases_tac¬c = î¯ 0® THEN1 PC_T1 "predicates" asm_rewrite_tac[zero_times_s_thm, zero_times_g_thm]);
(* *** Goal "" *** *)
a(rewrite_tac[times_g_def] THEN µ_tac);
a(ALL_FC_T rewrite_tac[supp_times_s_thm]);
a(rewrite_tac[times_s_def]);
a(lemma_tac¬{(I, J)|I  Supp v ± J  Supp w ± x = I £ J}  Finite®
	THEN1 ALL_FC_T rewrite_tac[times_g_finite_thm]);
a(rewrite_tac[µ_elim¬c®¯_times_order_thm]);
a(pure_rewrite_tac[prove_rule[]
	¬ (Ì (I, J)· c * Sign‰G I J * v I * w J) =
	Ìx·c * (Ì (I, J)· Sign‰G I J * v I * w J) x ®]);
a(ALL_FC_T pure_rewrite_tac[ind_sum_const_times_thm]);
a(rewrite_tac[]);
val Ûtimes_g_linear_thm1İ = save_pop_thm "times_g_linear_thm1";
=TEX
%%%%
%%%%

=SML
(*
set_goal([], ¬µV1 V2 V3·
	Supp V1  Finite
±	Supp V2  Finite
±	Supp V3  Finite
´	(V1 *‰G V2) *‰G V3 = V1 *‰G (V2 *‰G V3)
®);
a(REPEAT strip_tac THEN rewrite_tac[times_g_def]);
val Ûtimes_g_assoc_thmİ = save_pop_thm "times_g_assoc_thm";
*)
=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val Ûsectionsİ = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="geomalg.th.doc", theory="geomalg"};
end;
=TEX
} %\Hide
\end{document}


