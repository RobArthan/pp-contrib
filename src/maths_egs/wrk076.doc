=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}
\def\Hide#1{\relax}
\title{Mathematical Case Studies: Real Vector Spaces and the Geometric Algebra}
\author{Rob Arthan}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
This document develops the basic theory real vector spaces and of the Geometric Algebra.
$GA(\infty)$.
\end{abstract}
\section{INTRODUCTION}
This document is one of a set of documents containing mathematical case studies in  {\ProductHOL}.
It deals with real vector spaces and the Geometric Algebra.
\section{REAL VECTOR SPACES}
=SML
force_delete_theory"geomalg" handle Fail _ => ();
open_theory"analysis";
new_theory"geomalg";
new_parent "groups";
new_parent "numbers";
set_merge_pcs["basic_hol1", "'sets_alg", "'ú", "'¯"];
=TEX
\subsection{Signature for Real Vector Spaces}

A candidate for being a vector space is something with the signature of a group together with an ¯-action on the elements.

¹HOLLABPROD ÛRVSİüüüüüüüüüüüüüüüüü
Ü	Group‰RVS	:'a GROUP;
Ü	Scale‰RVS	:¯ ­ 'a ­ 'a
°üüüüüüüüüüüüüüüüüüüüüüüüü

=SML
declare_alias("Grp", ¬Group‰RVS®);
declare_alias("Scale", ¬Scale‰RVS®);
=TEX


¹HOLCONST
Ü ÛPlus‰Vİ :  'a ­ 'a ­ 'a RVS ­ 'a;
Ü ÛMinus‰Vİ :  'a ­ 'a RVS ­ 'a;
Ü ÛSubtract‰Vİ :  'a ­ 'a ­ 'a RVS ­ 'a;
Ü Û0‰Vİ :  'a RVS ­ 'a;
Ü ÛScale‰Vİ :  ¯ ­ 'a ­ 'a RVS ­ 'a
÷üüüüüü
Ü µ R·	  (µv w· Plus‰V v w R = (v.w)(Grp R))
Ü 	± (µv· Minus‰V v R = (v ›~)(Grp R))
Ü	± (µv w· Subtract‰V v w R = (v.(w ›~)(Grp R))(Grp R))
Ü	± 0‰V R = Unit (Grp R)
Ü	± (µx v· Scale‰V x v R = (Scale R) x v)
°

=SML
declare_infix(310, "*‰s");
declare_infix(300, "+‰V");
declare_infix(305, "-‰V");
declare_alias("+‰V", ¬Plus‰V®);
declare_alias("~‰V", ¬Minus‰V®);
declare_alias("-‰V", ¬Subtract‰V®);
declare_alias("*‰s", ¬Scale‰V®);
=TEX

¹HOLCONST
Ü ÛAbelianGroupİ : 'a GROUP SET
÷üüüüüü
Ü µ G· G  AbelianGroup ¤ G  Group
Ü	± µ u v:'a· u  Car G ± v  Car G
Ü	         ´ (u.v) G = (v.u) G
°

¹HOLCONST
Ü ÛVS‰Rİ : 'a RVS SET
÷üüüüüü
Ü µ V·
Ü	V  VS‰R
Ü ¤	Grp V  AbelianGroup
Ü ±	(µx v w·  ((x*‰s v)V +‰V (x*‰s w)V)V = (x*‰s(v +‰V w) V) V)
Ü ±	(µx y v· ((x*‰s v)V +‰V (y*‰s v)V)V  = ((x + y) *‰s v) V)
Ü ±	(µx y:¯; v· (x*‰s(y*‰s v)V)V = ((x*y)*‰s v)V)
Ü ±	(µv· (î¯ 1*‰s v)V = v)
°


¹HOLCONST
Ü ÛLinİ : 'a RVS ¸ 'b RVS­ ('a ­ 'b) SET
÷üüüüüü
Ü µ V W f·
Ü	f  Lin(V, W)
Ü ¤	f  Homomorphism(Grp V, Grp W)
Ü ±	(µx v· f((x *‰s v) V) = (x *‰s f v)W)
°


¹HOLCONST
Ü ÛSuppİ : ('a ­ ¯) ­ 'a SET
÷üüüüüü
Ü µ f· Supp f = {x | ³f x = î¯ 0}
°

¹HOLCONST
Ü ÛFinSupp‰Gİ : ('a ­ ¯) GROUP
÷üüüüüü
Ü FinSupp‰G = MkGROUP {f | Supp f  Finite} (Ìf g a·f a + g a) (Ìa·î¯ 0) (Ìf a·~(f a))
°


¹HOLCONST
Ü ÛFree‰RVSİ : ('a ­ ¯) RVS
÷üüüüüü
Ü Free‰RVS = MkRVS FinSupp‰G (Ìx:¯; f· Ìa:'a·x * f a)
°



\section{THE GEOMETRIC ALGEBRA}


It is very convenient to have available the symmetric difference operator for sets. Indeed, it would be nice for this to be moved into the basic HOL theory of sets.
We follow Z in writing the symmetric difference of $a$ and $b$ as
=INLINEFT
a £ b
=TEX

=SML
declare_infix(250, "£");

¹HOLCONST
Ü $£ : 'a SET ­ 'a SET ­ 'a SET
÷üüüüüü
Ü µa b· a £ b = (a \ b) À (b \ a)
°

\subsection{The Algebra Operations}
¹HOLCONST
Ü ÛSign‰Gİ : î SET ­ î SET ­ ¯
÷üüüüüü
Ü µ I J· Sign‰G I J = ~(î¯ 1) ^ #{(i, j) | i  I ± j  J ± j < i}
°
=SML
declare_infix(310, "*‰G");
declare_type_abbrev("GA", [], ”î SET ­ ¯®);

¹HOLCONST
Ü $*‰G : GA ­ GA ­ GA
÷üüüüüü
Ü µ V W·
Ü	V *‰G W = ÌK·
Ü	“ {(I, J) | I  Supp V ± J  Supp W ± K = I £ J}
Ü	(Ì(I, J)· Sign‰G I J * V I * W J)
°
=TEX

%\bibliographystyle{fmu}
%\bibliography{fmu}

%\appendix
{%\HOLindexOff
\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{geomalg.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
=TEX
%%%%
%%%%
=SML
=SML
=TEX
%%%%
%%%%

=SML
val Ûgrp_defİ = get_spec¬Grp®;
val Ûabelian_group_defİ = get_spec¬AbelianGroup®;
val Ûvs_ops_defİ = get_spec¬Plus‰V®;
val Ûvs_defİ = get_spec¬VS‰R®;
val Ûrvs_defİ = get_spec¬MkRVS®;
val Ûlin_defİ = get_spec¬Lin®;
val Ûsupp_defİ = get_spec¬Supp®;
val Ûfin_supp_defİ = get_spec¬FinSupp‰G®;
val Ûfree_v_defİ = get_spec¬Free‰RVS®;
=TEX

=SML
val Û£_defİ = get_spec¬$£®;
val Ûsign_g_defİ = get_spec¬Sign‰G®;
val Ûtimes_g_defİ = get_spec¬$*‰G®;
=TEX
=SML
val Ûmod_2_clausesİ = rewrite_rule[] (µ_elim¬2®mod_clauses);
=TEX
=SML
set_goal([], ¬
	Supp (Ìx:'a· î¯ 0) = {}
±	(µf:'a ­ ¯· Supp (Ìx·~(f x)) = Supp f)
±	(µf g:'a ­ ¯· Supp (Ìx· f x + g x) € Supp f À Supp g)
±	(µc:¯; f:'a ­ ¯· Supp (Ìx· c*f x) € Supp f)
®);
a(PC_T1 "sets_ext1" rewrite_tac[supp_def] THEN REPEAT strip_tac
	THEN_TRY PC_T1 "¯_lin_arith" asm_prove_tac[]);
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
val Ûsupp_clausesİ = save_pop_thm "supp_clauses";
=TEX
=SML
set_goal([], ¬FinSupp‰G  AbelianGroup®);
a(rewrite_tac[fin_supp_def, abelian_group_def, group_def, group_ops_def, supp_clauses, empty_finite_thm] 
	THEN REPEAT strip_tac
	THEN_TRY PC_T1 "¯_lin_arith" prove_tac[]);
a(bc_thm_tac €_finite_thm);
a(¶_tac¬Supp x À Supp y® THEN 
	asm_rewrite_tac[supp_clauses, À_finite_thm]);
val Ûfin_supp_abelian_group_thmİ = save_pop_thm "fin_supp_abelian_group_thm";
=SML
set_goal([], ¬Free‰RVS  VS‰R®);
a(rewrite_tac[free_v_def, vs_def, vs_ops_def, grp_def,
	fin_supp_abelian_group_thm]);
a(rewrite_tac[fin_supp_def, group_ops_def, vs_ops_def]
	THEN (PC_T1 "¯_lin_arith" prove_tac[]));
val Ûfree_v_vs_thmİ = save_pop_thm "free_v_vs_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b c·
	a £ {} = a
±	{} £ a = a
±	a £ b = b £ a
±	a £ b £ c = (a £ b) £ c®);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_group_thmİ = save_pop_thm "£_group_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b c·
	a £ b £ c = (a £ b) £ c®);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_assoc_thmİ = save_pop_thm "£_assoc_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa·
	a £ {} = a
±	{} £ a = a
±	a £ a = {}®);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_clausesİ = save_pop_thm "£_clauses";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b·
	a ¡ b = {} ¤ a £ b = a À b®);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_eq_À_thmİ = save_pop_thm "£_eq_À_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b· a  Finite ± b  Finite ´ a £ b  Finite®);
a(REPEAT strip_tac THEN bc_thm_tac €_finite_thm
	THEN ¶_tac¬a À b®
	THEN asm_rewrite_tac[£_def, À_finite_thm]
	THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_finite_thmİ = save_pop_thm "£_finite_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µf a b·
	f {} = 0
±	(µa b· a  Finite ± b  Finite
	´	f(a À b) + f(a ¡ b) = f a + f b)
±	a  Finite
±	b  Finite
´	f(a £ b) + 2*f(a ¡ b) = f a + f b
®);
a(REPEAT strip_tac);
a(lemma_tac¬a À b  Finite® THEN1 asm_rewrite_tac[À_finite_thm]);
a(lemma_tac¬a ¡ b  Finite® THEN1 ALL_FC_T rewrite_tac[¡_finite_thm]);
a(lemma_tac¬a £ b  Finite® THEN1 all_fc_tac[£_finite_thm]);
a(LIST_SPEC_NTH_ASM_T 6 [¬a £ b®, ¬a ¡ b®] ante_tac);
a(LIST_SPEC_NTH_ASM_T 6 [¬a®, ¬b®] ante_tac);
a(DROP_NTH_ASM_T 6 discard_tac);
a(LEMMA_T ¬(a £ b) À a ¡ b = a À b ± (a £ b) ¡ a ¡ b = {}®
	asm_rewrite_thm_tac
	THEN1 (rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(PC_T1 "lin_arith" prove_tac[]);
val Ûsize_£_lemmaİ = save_pop_thm "size_£_lemma";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b·
	a  Finite
±	b  Finite
´	#(a £ b) + 2 * #(a ¡ b) = #a + #b
®);
a(REPEAT strip_tac THEN bc_thm_tac size_£_lemma);
a(asm_rewrite_tac[size_empty_thm, size_À_thm]);
val Ûsize_£_thmİ = save_pop_thm "size_£_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µt a b c·
	(µa·t a {} = 0)
±	(µa b c·a  Finite ± b  Finite ± c  Finite
	´	t a (b À c) + t a (b ¡ c) = t a b + t a c)
±	a  Finite ± b  Finite ± c  Finite
´	t a (b £ c) + 2 * t a (b ¡ c) = t a b + t a c
®);
a(REPEAT strip_tac);
a(bc_thm_tac size_£_lemma THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
val Ûsign_g_lemma1İ = save_pop_thm "sign_g_lemma1";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µt a b c·
	(µa·t {} a = 0)
±	(µa b c·a  Finite ± b  Finite ± c  Finite
	´	t (a À b) c + t (a ¡ b) c = t a c + t b c)
±	a  Finite ± b  Finite ± c  Finite
´	t (a £ b) c + 2 * t (a ¡ b) c = t a c + t b c
®);
a(REPEAT strip_tac);
a(bc_thm_tac(rewrite_rule[](µ_elim¬Ìx y· t y x® sign_g_lemma1)));
a(asm_rewrite_tac[] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val Ûsign_g_lemma2İ = save_pop_thm "sign_g_lemma2";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µt a b c·
	(µa·t a {} = 0)
±	(µa b c·a  Finite ± b  Finite ± c  Finite
	´	t a (b À c) + t a (b ¡ c) = t a b + t a c)
±	(µa·t {} a = 0)
±	(µa b c·a  Finite ± b  Finite ± c  Finite
	´	t (a À b) c + t (a ¡ b) c = t a c + t b c)
±	a  Finite ± b  Finite ± c  Finite
´	(t a (b £ c) + t b c) Mod 2 = (t (a £ b) c + t a b) Mod 2
®);
a(REPEAT strip_tac);
a(LEMMA_T ¬((t a (b £ c) + t b c) + 2 * t a (b ¡ c)) Mod 2 =
	((t (a £ b) c + t a b) + 2 * t (a ¡ b) c) Mod 2®
	(accept_tac o rewrite_rule[mod_2_clauses]));
a(LEMMA_T ¬((t a (b £ c) + t b c) + 2 * t a (b ¡ c)) =
	((t (a £ b) c + t a b) + 2 * t (a ¡ b) c)®
	rewrite_thm_tac);
a(rewrite_tac[pc_rule1"lin_arith" prove_rule[]
	¬µi j k:î·(i + j) + k = j + i + k®]);
a(ALL_FC_T rewrite_tac[sign_g_lemma1, sign_g_lemma2]);
a(PC_T1 "lin_arith" prove_tac[]);
val Ûsign_g_lemma4İ = save_pop_thm "sign_g_lemma4";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µm·
	 ~(î¯ 1) ^ m = ~(î¯ 1) ^ (m Mod 2)
®);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim¬m® mod_2_cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[mod_2_0_¯_î_exp_thm, mod_2_1_¯_î_exp_thm]
	THEN rewrite_tac[¯_î_exp_0_1_thm]);
val Û¯_î_exp_mod_2_thmİ = save_pop_thm "¯_î_exp_mod_2_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µI J K:î SET·
	{(i, j)|i  I À J ± j  K ± j < i} =
	{(i, j)|i  I ± j  K ± j < i} À
	{(i, j)|i  J ± j  K ± j < i}
±	{(i, j)|i  I ± j  J À K ± j < i} =
	{(i, j)|i  I ± j  J ± j < i} À
	{(i, j)|i  I ± j  K ± j < i}
±	{(i, j)|i  I ¡ J ± j  K ± j < i} =
	{(i, j)|i  I ± j  K ± j < i} ¡
	{(i, j)|i  J ± j  K ± j < i}
±	{(i, j)|i  I ± j  J ¡ K ± j < i} =
	{(i, j)|i  I ± j  J ± j < i} ¡
	{(i, j)|i  I ± j  K ± j < i}
®);
a(PC_T1 "sets_ext1" prove_tac[]);
val Ûsign_g_lemma5İ = save_pop_thm "sign_g_lemma5";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µI J:î SET·
	I  Finite ± J  Finite
´	{(i, j)|i  I ± j  J ± j < i}  Finite
®);
a(REPEAT strip_tac THEN bc_thm_tac €_finite_thm);
a(¶_tac¬I ¸ J® THEN ALL_FC_T rewrite_tac[¸_finite_size_thm]);
a(rewrite_tac[¸_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Ûsign_g_lemma6İ = save_pop_thm "sign_g_lemma6";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µI J K·
	I  Finite
±	J  Finite
±	K  Finite
´	Sign‰G (I £ J) K * Sign‰G I J
=	Sign‰G I (J £ K) * Sign‰G J K
®);
a(REPEAT strip_tac THEN rewrite_tac[sign_g_def,
	conv_rule(ONCE_MAP_C eq_sym_conv) ¯_î_exp_plus_thm]);
a(once_rewrite_tac[¯_î_exp_mod_2_thm]);
a(bc_thm_tac(prove_rule[]¬µx:¯; i j :î· j = i ´ x^i = x^j®));
a(bc_thm_tac(rewrite_rule[](µ_elim¬Ìa b:î SET·# {(i, j)|i  a ± j  b ± j < i}® sign_g_lemma4)));
a(asm_rewrite_tac[pc_rule1"sets_ext1" prove_rule[]
	¬{(i, j)|F} = {}®,
	size_empty_thm]);
a(DROP_ASMS_T discard_tac THEN rewrite_tac[sign_g_lemma5]);
a(REPEAT strip_tac THEN bc_thm_tac size_À_thm
	THEN ALL_FC_T rewrite_tac[sign_g_lemma6]);
val Ûsign_g_thmİ = save_pop_thm "sign_g_thm";
=TEX
%%%%
%%%%

=SML
(*
set_goal([], ¬µV1 V2 V3·
	Supp V1  Finite ± Supp V1 € Finite
±	Supp V2  Finite ± Supp V2 € Finite
±	Supp V3  Finite ± Supp V3 € Finite
´	(V1 *‰G V2) *‰G V3 = V1 *‰G (V2 *‰G V3)
®);
a(REPEAT strip_tac THEN rewrite_tac[times_g_def]);
val Ûtimes_g_assoc_thmİ = save_pop_thm "times_g_assoc_thm";
*)
=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val Ûsectionsİ = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="geomalg.th.doc", theory="geomalg"};
end;
=TEX
} %\Hide
\end{document}


