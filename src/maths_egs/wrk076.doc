=TEX
\documentclass[12pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\title{Primitive Recursion over Binary Representations}
\author{Rob Arthan}
\makeindex
\begin{document}
\vfill
\maketitle
=SML

¹HOLCONST
Ü Bits : î ­ î SET
÷üüüüüü
Ü	(µn·0  Bits n ¤ n Mod 2 = 1 )
Ü ±	(µm n· (m+1)  Bits n ¤ m  Bits(n Div 2))
°
=SML
declare_infix(250, "£");

¹HOLCONST
Ü $£ : 'a SET ­ 'a SET ­ 'a SET
÷üüüüüü
Ü µa b· a £ b = (a \ b) À (b \ a)
°
=SML
(*
¹HOLCONST
Ü GAProduct : î SET ­ î SET ­ ¯ ¸ î SET
÷üüüüüü
Ü µa b· GAProduct a b =
Ü	( {(i, j) | i  A ± j  B ± j < i} (Ìij· ~(î¯ 1)), a £ b)
°
=SML
*)
=TEX
%%%%
%%%%

=SML
val Û£_defİ = get_spec¬$£®;

(*
repeat drop_main_goal;
*)
push_consistency_goal ¬Bits® ;
a(lemma_tac¬¶B·
	(µn· B 0 n ¤ n Mod 2 = 1)
± 	(µm n· B (m+1) n ¤ B m (n Div 2))
®
	THEN1 prove_¶_tac);
a(¶_tac¬Ìn·{m | B m n}® THEN asm_rewrite_tac[]);
val _ = save_consistency_thm ¬Bits® (pop_thm());
val Ûbits_defİ = get_spec¬Bits®;
=TEX
%%%%
%%%%

=SML
val Ûmod_2_clausesİ = rewrite_rule[](µ_elim¬2®mod_clauses);
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µm n·m  Bits n ´ 2^m ¼ n®);
a(µ_tac THEN induction_tac¬m:î® THEN rewrite_tac[bits_def, î_exp_def]);
(* *** Goal "1" *** *)
a(contr_tac THEN lemma_tac¬n = 0® THEN1 PC_T1"lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(lemma_tac¬n = n Div 2 * 2 + n Mod 2®
	THEN1 (bc_thm_tac div_mod_thm
		THEN rewrite_tac[]));
a(PC_T1"lin_arith" asm_prove_tac[]);
val Ûbits_lemma1İ = save_pop_thm "bits_lemma1";

=TEX
%%%%
%%%%

=SML
set_goal([], ¬µm·m ¼ 2^m®);
a(µ_tac THEN induction_tac¬m:î® THEN rewrite_tac[î_exp_def]);
a(cases_tac¬m = 0® THEN1 asm_rewrite_tac[î_exp_def]);
a(PC_T1"lin_arith" asm_prove_tac[]);
val Ûbits_lemma2İ = save_pop_thm "bits_lemma2";

=TEX
%%%%
%%%%

=SML
set_goal([], ¬µn·Bits n  Finite®);
a(REPEAT strip_tac);
a(bc_thm_tac €_finite_thm);
a(¶_tac¬{i | i < n+1}® THEN PC_T1"sets_ext1" rewrite_tac[range_finite_size_thm]);
a(REPEAT strip_tac THEN all_fc_tac[bits_lemma1]);
a(strip_asm_tac(µ_elim¬x® bits_lemma2));
a(PC_T1"lin_arith" asm_prove_tac[]);
val Ûbits_finite_thmİ = save_pop_thm "bits_finite_thm";

=TEX
%%%%
%%%%

=SML
set_goal([], ¬µm· ³m = 0 ´ m Div 2 < m®);
a(REPEAT strip_tac);
a(lemma_tac¬m = m Div 2 * 2 + m Mod 2®
	THEN1 (bc_thm_tac div_mod_thm
		THEN rewrite_tac[]));
a(PC_T1"lin_arith" asm_prove_tac[]);
val Ûbits_lemma3İ = save_pop_thm "bits_lemma3";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬
	Bits 0 = {}
®);
a(PC_T1 "sets_ext1" rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(induction_tac ¬x® THEN asm_rewrite_tac[bits_def]);
val Ûbits_0_thmİ = save_pop_thm "bits_0_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µn·
	Bits n =
	(if n Mod 2 = 0 then {} else {0}) À
	{k | ¶m·m  Bits (n Div 2) ± k = m+1}
®);
a(PC_T1 "sets_ext1" rewrite_tac[] THEN REPEAT_UNTIL is_¤ strip_tac);
a(strip_asm_tac(µ_elim¬n® î_cases_thm));
(* *** Goal "1" *** *)
a(asm_rewrite_tac[bits_0_thm]);
(* *** Goal "2" *** *)
a(strip_asm_tac(µ_elim¬x® î_cases_thm));
(* *** Goal "2.1" *** *)
a(asm_rewrite_tac[bits_def]);
a(cases_tac¬(i+1) Mod 2 = 1® THEN asm_rewrite_tac[]);
a(lemma_tac¬(i+1) Mod 2 < 2®
	THEN1 (bc_thm_tac mod_less_thm
		THEN rewrite_tac[]));
a(LEMMA_T¬(i+1) Mod 2 = 0® rewrite_thm_tac
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[bits_def]);
a(LEMMA_T¬³i' + 1  if (i + 1) Mod 2 = 0 then {} else {0}® rewrite_thm_tac
	THEN1 (cases_tac ¬(i + 1) Mod 2 = 0® THEN asm_rewrite_tac[]));
a(REPEAT strip_tac THEN1 ¶_tac¬i'® THEN asm_rewrite_tac[]);
val Ûbits_recur_thm1İ = save_pop_thm "bits_recur_thm1";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬
	Bits 0 = {}
± µn·	Bits (n+1) =
	(if (n+1) Mod 2 = 0 then {} else {0}) À
	{k | ¶m·m  Bits ((n+1) Div 2) ± k = m+1}
®);
a(rewrite_tac[bits_0_thm] THEN strip_tac);
a(conv_tac (LEFT_C (once_rewrite_conv[bits_recur_thm1]))THEN rewrite_tac[]);
val Ûbits_recur_thmİ = save_pop_thm "bits_recur_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µA·
	A  Finite
´	{k | ¶m· m  A ± k = m + 1}  Finite
±	#{k | ¶m· m  A ± k = m + 1} = #A
®);
a(REPEAT µ_tac THEN ´_tac);
a(bc_thm_tac bijection_finite_size_thm);
a(¶_tac¬Ìm·m + 1® THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
val Ûbits_lemma4İ = save_pop_thm "bits_lemma4";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µA·
	A  Finite
´	“ {k | ¶m· m  A ± k = m + 1} (Ì d· 2 ^ d) =
	2 * “ A (Ì d· 2 ^ d)
®);
a(REPEAT strip_tac);
a(finite_induction_tac¬A®);
(* *** Goal "1" *** *)
a(rewrite_tac[ind_sum_î_def,
	pc_rule1"sets_ext1" prove_rule[]¬{x|F}={}®]);
(* *** Goal "2" *** *)
a(LEMMA_T¬{k|¶ m· m  {x} À A ± k = m + 1} =
	{x+1} À {k|¶ m· m  A ± k = m + 1}®
	rewrite_thm_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(LEMMA_T¬³ x+1  {k|¶ m· m  A ± k = m + 1}®
	asm_tac
	THEN1 (MERGE_PCS_T1 ["'î", "sets_ext1"] REPEAT strip_tac
		THEN all_var_elim_asm_tac));
a(lemma_tac¬{k|¶ m· m  A ± k = m + 1}  Finite®
	THEN1 ALL_FC_T rewrite_tac[bits_lemma4]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_î_def]);
a(rewrite_tac[î_exp_def] THEN PC_T1 "lin_arith" prove_tac[]);
val Ûbits_lemma5İ = save_pop_thm "bits_lemma5";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µA·
	A  Finite
´	{k | ¶m· m  A ± k = m + 1}  Finite
±	³0  {k | ¶m· m  A ± k = m + 1}
®);
a(REPEAT µ_tac THEN ´_tac THEN rewrite_tac[]);
a(all_fc_tac[bits_lemma4]);
val Ûbits_lemma6İ = save_pop_thm "bits_lemma6";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µf : 'a ­ î; x·
	“ {x} f = f x®);
a(REPEAT strip_tac);
a(pure_once_rewrite_tac[
	pc_rule1"sets_ext" prove_rule[]
	¬{x} = {x} À {}®]);
a(LEMMA_T¬({}:'a SET)  Finite ± ³x  {}®
	(±_THEN asm_tac)
	THEN1 rewrite_tac[empty_finite_thm]);
a(ALL_FC_T pure_rewrite_tac[ind_sum_î_def]);
a(rewrite_tac[ind_sum_î_def]);
val Ûind_sum_î_singleton_thmİ = save_pop_thm "ind_sum_î_singleton_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µn· n Div 2 = 0 ´ n = 0 ² n = 1
®);
a(REPEAT µ_tac THEN ´_tac);
a(LEMMA_T¬n = n Div 2 * 2 + n Mod 2®
	once_rewrite_thm_tac
	THEN1 (bc_thm_tac div_mod_thm
		THEN rewrite_tac[]));
a(asm_rewrite_tac[]);
a(lemma_tac¬n Mod 2 < 2®
	THEN1 (bc_thm_tac mod_less_thm
		THEN rewrite_tac[]));
a(PC_T1 "lin_arith" asm_prove_tac[]);
val Ûdiv_2_0_thmİ = save_pop_thm "div_2_0_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µn·“ (Bits n) (Ìd·2^d) = n®);
a(REPEAT strip_tac);
a(cases_tac¬n = 0®
	THEN1 asm_rewrite_tac[bits_recur_thm, ind_sum_î_def]);
a(POP_ASM_T ante_tac THEN cov_induction_tac¬n® THEN REPEAT strip_tac);
a(all_fc_tac[bits_lemma3]);
a(once_rewrite_tac[bits_recur_thm1]);
a(cases_tac¬n Div 2 = 0®);
(* *** Goal "1" *** *)
a(all_fc_tac[div_2_0_thm] THEN all_var_elim_asm_tac1);
a(asm_rewrite_tac[bits_0_thm,
	pc_rule1 "sets_ext" prove_rule[]¬{x|F}={}®,
	ind_sum_î_singleton_thm,
	î_exp_def]);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
a(strip_asm_tac(µ_elim¬n Div 2® bits_finite_thm));
a(LEMMA_T¬n = n Div 2 * 2 + n Mod 2® ante_tac
	THEN1 (bc_thm_tac div_mod_thm
		THEN rewrite_tac[]));
a(lemma_tac¬n Mod 2 < 2®
	THEN1 (bc_thm_tac mod_less_thm
		THEN rewrite_tac[]));
a(lemma_tac¬n Mod 2 = 0 ² n Mod 2 = 1®
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]
	THEN asm_rewrite_tac[]
	THEN STRIP_T (fn th => conv_tac(RIGHT_C (eq_match_conv th))));
(* *** Goal "2.1" *** *)
a(ALL_FC_T asm_rewrite_tac[bits_lemma5]);
a(PC_T1"lin_arith" prove_tac[]);
(* *** Goal "2.2" *** *)
a(PC_T1 "predicates" all_fc_tac[bits_lemma6]);
a(ALL_FC_T asm_rewrite_tac[ind_sum_î_def, bits_lemma5]);
a(rewrite_tac[î_exp_def] THEN PC_T1"lin_arith" prove_tac[]);
val Ûbits_sum_thmİ = save_pop_thm "bits_sum_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬OneOne Bits®);
a(rewrite_tac[one_one_def] THEN REPEAT strip_tac);
a(LEMMA_T ¬ “ (Bits x1) (Ì d· 2 ^ d) =  “ (Bits x2) (Ì d· 2 ^ d) ® ante_tac
	THEN1 asm_rewrite_tac[]);
a(rewrite_tac[bits_sum_thm]);
val Ûbits_one_one_thmİ = save_pop_thm "bits_one_one_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬ µ m n· Bits m = Bits n ¤ m = n®);
a(REPEAT strip_tac 
	THEN all_fc_tac[rewrite_rule[one_one_def] bits_one_one_thm]
	THEN asm_rewrite_tac[]);
val Ûbits_one_one_thm1İ = save_pop_thm "bits_one_one_thm1";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µm n:î·2^m < 2^n ¤ m < n®);
a(lemma_tac¬µi j:î·2^i < 2^(i+j+1)®);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN induction_tac¬j:î®);
(* *** Goal "1.1" *** *)
a(rewrite_tac[î_exp_def] THEN contr_tac);
a(LEMMA_T¬2^i=0® ante_tac THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(rewrite_tac[î_exp_eq_0_thm]);
(* *** Goal "1.2" *** *)
a(rewrite_tac[plus_assoc_thm1]);
a(once_rewrite_tac[î_exp_def]);
a(rewrite_tac[plus_assoc_thm]);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¬µi j:î·i < j ´ 2^i < 2^j®);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac THEN POP_ASM_T (
	strip_asm_tac o rewrite_rule[
		¼_def,
		pc_rule1 "lin_arith" prove_rule[]
		¬i < j ¤ i + 1 ¼ j®]));
a(all_var_elim_asm_tac1);
a(asm_rewrite_tac[pc_rule1 "lin_arith" prove_rule[]
		¬(i+1)+i' = i + i'+ 1®]);
(* *** Goal "2.2" *** *)
a(REPEAT µ_tac);
a(strip_asm_tac(list_µ_elim[¬m®, ¬n®] less_cases_thm)
	THEN all_asm_fc_tac[]
		THEN_TRY asm_rewrite_tac[]);
a(PC_T1 "lin_arith" asm_prove_tac[]);
val Ûî_exp_mono_thmİ = save_pop_thm "î_exp_mono_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬OneOne (Ìd·2^d)®);
a(rewrite_tac[one_one_def]);
a(µ_tac THEN induction_tac¬x1:î®
	THEN rewrite_tac[î_exp_def]);
(* *** Goal "1" *** *)
a(conv_tac(ONCE_MAP_C eq_sym_conv)
	THEN rewrite_tac[î_exp_eq_1_thm]);
(* *** Goal "2" *** *)
a(µ_tac THEN strip_asm_tac(µ_elim¬x2:î® î_cases_thm)
	THEN all_var_elim_asm_tac1);
(* *** Goal "2.1" *** *)
a(asm_rewrite_tac[î_exp_def,
	pc_rule1 "lin_arith" prove_rule[]
	¬µm· 2 * m = 1 ¤ 0 < m ± m < 1®]);
a(PC_T1 "lin_arith" prove_tac[]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[î_exp_def,
	pc_rule1 "lin_arith" prove_rule[]
	¬µm n· 2 * m = 2 * n ¤ m = n®]);
val Ûî_exp_2_one_one_thmİ = save_pop_thm "î_exp_2_one_one_thm";
val Ûî_exp_2_one_one_thm1İ = save_thm(
	"î_exp_one_one_thm1",
	rewrite_rule[one_one_def] î_exp_2_one_one_thm);

=TEX
%%%%
%%%%

=SML
set_goal([], ¬µn·
	Bits (2*n) = {k | ¶m·m  Bits n ± k = m + 1}®);
a(µ_tac THEN conv_tac(LEFT_C (once_rewrite_conv[bits_recur_thm1])));
a(rewrite_tac[rewrite_rule[µ_elim¬n® times_comm_thm](
	list_µ_elim[¬2®, ¬n®, ¬0®] div_mod_times_cancel_thm),
	mod_2_clauses]);
val Ûbits_lemma7İ = save_pop_thm "bits_lemma7";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µn A·
	(µm·m  A ´ m < n)
´	¶k· Bits k = A®);
a(µ_tac THEN induction_tac¬n:î®);
(* *** Goal "1" *** *)
a(rewrite_tac[] THEN REPEAT strip_tac);
a(¶_tac¬0® THEN rewrite_tac[bits_0_thm]);
a(PC_T1 "sets_ext1" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN cases_tac¬³n  A®);
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 3 bc_thm_tac THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [3] fc_tac);
a(cases_tac¬m' = n® THEN1 all_var_elim_asm_tac1);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(lemma_tac¬¶j·Bits j = {k | k + 1  A}®
	THEN1 DROP_NTH_ASM_T 3 bc_thm_tac
		THEN REPEAT strip_tac
		THEN all_asm_fc_tac[]);
a(cases_tac¬³0  A®);
(* *** Goal "2.2.1" *** *)
a(¶_tac¬2*j® THEN1 asm_rewrite_tac[bits_lemma7]);
a(PC_T1 "sets_ext1" rewrite_tac[]);
a(REPEAT strip_tac THEN1 asm_rewrite_tac[]);
a(strip_asm_tac(µ_elim¬x® î_cases_thm) THEN all_var_elim_asm_tac1);
a(¶_tac¬i® THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(¶_tac¬2*j+1® THEN1 asm_rewrite_tac[bits_recur_thm, bits_lemma7,
	mod_2_clauses,
	rewrite_rule[µ_elim¬j® times_comm_thm](
	list_µ_elim[¬2®, ¬j®, ¬1®] div_mod_times_cancel_thm)]);
a(PC_T1 "sets_ext1" asm_rewrite_tac[]);
a(REPEAT strip_tac THEN1 asm_rewrite_tac[]
	THEN1 all_var_elim_asm_tac1);
a(strip_asm_tac(µ_elim¬x® î_cases_thm));
(* *** Goal "2.2.2.1" *** *)
a(DROP_NTH_ASM_T 2 discard_tac THEN all_var_elim_asm_tac1);
a(¶_tac¬i® THEN REPEAT strip_tac);
val Ûbits_lemma8İ = save_pop_thm "bits_lemma8";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µA : î SET·
	A  Finite
´	¶n· µm·m  A ´ m < n®);
a(REPEAT strip_tac THEN finite_induction_tac¬A:î SET®);
(* *** Goal "1" *** *)
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(¶_tac¬n + x + 1® THEN REPEAT strip_tac
	THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(all_asm_fc_tac[] THEN PC_T1 "lin_arith" asm_prove_tac[]);
val Ûî_finite_bounded_thmİ = save_pop_thm "î_finite_bounded_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µA·
	A  Finite
´	¶k· Bits k = A®);
a(REPEAT strip_tac THEN bc_tac
	[bits_lemma8, î_finite_bounded_thm]
	THEN strip_tac);
val Ûbits_onto_finite_thmİ = save_pop_thm "bits_onto_finite_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µA·
	A  Finite
´	Bits (“ A (Ìd·2^d)) = A®);
a(REPEAT strip_tac THEN all_fc_tac[bits_onto_finite_thm]);
a(LEMMA_T ¬Bits (“ A (Ì d· 2 ^ d)) = Bits k®
	asm_rewrite_thm_tac);
a(rewrite_tac[bits_one_one_thm1]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[bits_sum_thm]);
val Ûbits_onto_finite_thm1İ = save_pop_thm "bits_onto_finite_thm1";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b c·
	a £ {} = a
±	{} £ a = a
±	a £ b = b £ a
±	a £ b £ c = (a £ b) £ c®);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_group_thmİ = save_pop_thm "£_group_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µa b·
	a ¡ b = {} ¤ a £ b = a À b®);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val Û£_eq_À_thmİ = save_pop_thm "£_eq_À_thm";
=TEX

\end{document}


