=IGN
********************************************************************************
wrk076.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2006 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}
%
% Macro for cloak-and-dagger work:
%
\def\Hide#1{\relax}
%
% Macros for various mathematical odds and ends:
%
\def\Func#1{{\mathsf{#1}}}
\def\GA{\Func{GA}}
\def\Zero{\mathbf{0}}
\def\One{\mathbf{1}}
\def\x{\mathbf{x}}
\def\y{\mathbf{y}}
\def\z{\mathbf{z}}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\def\E#1{\mathbf{e}_{#1}}
\def\F#1{\mathbf{f}_{#1}}
%
% Macros for the tables of theorem names
%
\def\ThmsII#1#2{%
{\vertbarfalse
\begin{center}
\begin{minipage}[t]{0.48\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.48\hsize}
#2
\end{minipage}
\end{center}}}
%
\def\ThmsIII#1#2#3{%
{\vertbarfalse
\begin{center}
\begin{minipage}[t]{0.32\hsize}
#1
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#2
\end{minipage}
\begin{minipage}[t]{0.32\hsize}
#3
\end{minipage}
\end{center}}}
%
%  article red tape:
%
\title{Mathematical Case Studies: the Geometric Algebra}
\author{Rob Arthan}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
This document is one of a series of mathematical case studies in  {\ProductHOL}.
It gives a construction of the Geometric Algebra $GA$.
\end{abstract}
\section{INTRODUCTION}
In \cite{Harrison05a}, Harrison advocates an approach to Euclidean geometry in HOL using a type constructor to model the individual Euclidean spaces $\R^{N}$.
In this document, we set up the framework for an alternative approach where one works in a fixed type that contains all of the $\bbR^{N}$.
In fact we do more than that and construct the {\em geometric algebra}. To quote Macdonald~\cite{Macdonald06}:

\begin{quotation}
\it
Geometric algebra is nothing less than a new approach to geometry.
Geometric objects (points, lines, planes, [\ldots]) are represented by members of an algebra, a {\em geometric algebra}, rather than by equations. Geometric operations (rotate, translate, intersect, [\ldots]) on the objects are represented by algebraic operations in the algebra, rather than by matrix operations.
Geometric algebra is {\em coordinate-free:} coordinates are needed only when specific objects or operations are under consideration.
\end{quotation}

Let me now give a potted account of geometric algebra.


The general finite-dimensional geometric algebra $\GA(p, q)$ is paremeterised by two natural numbers $p$ and $q$.
$\GA(p, q)$ is an associative algebra over the real numbers with a two-sided unit $\One$.
It is commutative iff. $p + q \le 1$.


Real multiples $\lambda\One$ of the unit element in $\GA(p, q)$ are called {\em scalars} and are ordered by taking $\lambda\One < \mu\One$ iff.  $\lambda < \mu$.
Under this ordering, the subalgebra of scalars is isomorphic as an ordered field with the real numbers.

$\GA(p, q)$ is generated as an algebra by a $p+q$-dimensional subspace called $\R^{p, q}$ whose members are called {\em vectors}.
If $\x \in \R^{p, q}$, then $\x^2$ is a scalar.
$\R^{p, q}$ contains subspaces $\R^{p, 0}$ and $\R^{0, q}$ of dimensions $p$ and $q$, respectively, such that for non-zero $\x \in \R^{p, 0}$, $\x^2 > 0$, while for non-zero $\x \in \R^{0, q}$
$\x^2 < 0$.

The {\em inner product} of vectors $\x$ and $\y$ is defined by $\x.\y = \frac{1}{2}(\x\y + \y\x)$ and is a scalar.
The inner product is a bilinear form, i.e., it satisfies the conditions $(\lambda\x).(\mu\y) = \lambda\mu(\x.\y)$, $(\x + \y).\z = \x.\z + \y.\z$,
$\x.(\y + \z) = \x.\y + \x.\z$.
Vectors $\x$ and $\y$ are said to be {\em orthogonal} iff. $\x.\y = 0$.
$\x$ and $\y$ are orthogonal iff. they anti-commute, i.e., iff. $\x\y = -\y\x$.

The {\em outer product} of vectors $\x$ and $\y$ is defined by $\x\land\y=\frac{1}{2}(\x\y -\y\x)$, so that $\x\y = \x.\y + \x\land\y$, which is a scalar iff. it is 0.
Vectors $\x$ and $\y$ are said to be {\em collinear} iff. $\x \land \y = 0$.
Thus, when $\x$ and $\y$ are orthogonal, $\x\y = \x \land \y$, while when they are collinear, $\x\y = \x . \y$.

Simple explicit constructions of the geometric algebras have been given by Macdonald~\cite{Macdonald02}, and by the author~\cite{Arthan06b}.
As noted in~\cite{Arthan06b} the union of all of the $\GA(p, q)$ can be constructed in one step giving what I will now refer to as {\em the} geometric algebra, $\GA = \GA(\infty, \infty)$.


=SML
force_delete_theory"geomalg" handle Fail _ => ();
open_theory"numbers";
new_theory"geomalg";
set_merge_pcs["basic_hol1", "'sets_alg", "'˙", "'Ø"];
=TEX

\section{THE GEOMETRIC ALGEBRA}

\subsection{Preliminaries}

It is very convenient to have available the symmetric difference operator for sets. Indeed, it would be nice for this to be moved into the basic HOL theory of sets.
We follow Z in writing the symmetric difference of $a$ and $b$ as
=INLINEFT
a £ b
=TEX

=SML
declare_infix(250, "£");
=TEX

πHOLCONST
‹ $£ : 'a SET ≠ 'a SET ≠ 'a SET
˜¸¸¸¸¸¸
‹ µa b∑ a £ b = (a \ b) ¿ (b \ a)
∞

The development of the theory begins with various simple facts about symmetric differences.
Symmetric difference makes the lattice of sets into a commutative group.
The script includes a conversion
=INLINEFT
£_nf_conv
=TEX
\ which gives a normal form for this group.

\ThmsIII{%
=GFT
£_group_thm
£_comm_thm
£_assoc_thm
=TEX
}{%
=GFT
£_clauses
£_finite_thm
size_£_lemma
=TEX
}{%
=GFT
£_finite_size_thm
£_infinite_thm
=TEX
}

The following is the function $\sigma$ of~\cite{Arthan06b} for use in specifying the multiplication in $\GA$.

πHOLCONST
‹ €SignâG› : ˙ SET ≠ ˙ SET ≠ Ø
˜¸¸¸¸¸¸
‹ µ I J∑	SignâG I J =
‹	~(ÓØ 1) ^ (#{(i, j) | i ç I ± j ç J ± j < i} + #{i | i ç I ± i ç J ± i < Ó˙ 0})
∞

After a lemma, we have {\em sign\_g\_thm} which is lemma 1 of~\cite{Arthan06b}.
The proof given is a little bit more long-winded and general than the simplified version recorded in~\cite{Arthan06b}.
As a utility we also have the theorem that says the values taken on by $\sigma$ are $\pm1$ and the calculations that give the values of $\E{i}^2$ and $\E{i}\E{j}$.

\ThmsIII{%
=GFT
Ø_Ó_exp_mod_2_thm
sign_g_thm
=TEX
}{%
=GFT
sign_g_cases_thm
sign_singleton_thm
=TEX
}{%
=GFT
sign_singletons_thm
=TEX
}
=TEX
\subsection{The Type Definition}
$\GA$ in HOL will be subtype of the type of all real-valued functions on sets of integers (specifically, it will comprise the functions whose support is a finite set of finite sets).
The following type abbreviation captures this.
=SML
declare_type_abbrev("_GA", [], î˙ SET ≠ ØÆ);
=TEX
πHOLCONST
‹	IsGARep : _GA ≠ BOOL
˜
‹	µu∑ IsGARep u § Supp u ç Finite ± Supp u Ä Finite
∞
We can now introduce the new type:
=SML
val €ga_def› = new_type_defn(["GA", "ga_def"], "GA", [],
	tac_proof(([], ¨∂u∑ IsGARep uÆ),
		∂_tac¨(ÃI∑ÓØ 0)Æ
	THEN	rewrite_tac[get_spec¨IsGARepÆ, get_spec¨SuppÆ,
		pc_rule1"sets_ext" prove_rule[]¨{x|F} = {}Æ,
		empty_finite_thm]));
=TEX
\newpage
\subsection{Specifying the Operations on the Type}\label{ops}
We now introduce the operations on the type $\GA$.
First of all, we define the fixity of the infix operators.
=SML
app declare_infix[(300, "+âG"), (310, "*âG"), (310, "*âS")];
=TEX

Now we define the operations.
The following is adapted from definition~2 of~\cite{Arthan06b}.
The function
=INLINEFT
MonâG
=TEX
\ maps a finite set of integers $I$ to the monomial basis element $\E{I}$ of~\cite{Arthan06b}.
The definition has four conjuncts:
the first conjunct says that $\GA$ is an associative real algebra with a two-sided unit (cf. the check-list in~\cite{Macdonald02};
the second conjunct gives the rule for multiplying monomials;
the third conjunct says that the monomials
=INLINEFT
MonâG I
=TEX
\ as $I$ ranges over finite sets of integers generate $\GA$ as a linear space, or, more precisely, it says that if $V$ is a linear subspace of $\GA$ that contains each of these monomials, then $V = \GA$;
the final conjunct says that the monomials
=INLINEFT
MonâG I
=TEX
\ as $I$ ranges over finite sets of integers are linearly independent, or more precisely, it says that for each $J$, there is a linear subspace of $\GA$ that contains 
=INLINEFT
MonâG I
=TEX
\ for all $I \not= J$, but does not contain
=INLINEFT
MonâG J
=TEX
.


πHOLCONST
‹ $€+âG› : GA ≠ GA ≠ GA;	€~âG› : GA ≠ GA;	€0âG› : GA;
‹ $€*âS› : Ø ≠ GA ≠ GA;
‹ $€*âG› : GA ≠ GA ≠ GA;	€1âG› : GA;		€MonâG› : ˙ SET ≠ GA
˜¸¸¸¸¸¸
‹ (µu v w a b∑
‹	 	u +âG v = v +âG u
‹	± 	(u +âG v) +âG w = u +âG v +âG w
‹	± 	u +âG 0âG = u ± u +âG ~âG u = 0âG
‹	± 	ÓØ 1 *âS u = u ± a *âS (b *âS u) = (a * b) *âS u
‹	± 	a *âS (u +âG v) = a *âS u +âG a *âS v
‹	± 	(a + b) *âS u = a *âS u +âG b *âS u
‹	± 	(u *âG v) *âG w = u *âG (v *âG w)
‹	±	u *âG (v +âG w) = u *âG v +âG u *âG w
‹	±	(v +âG w) *âG u = v *âG u +âG w *âG u
‹	±	(a *âS u) *âG v = a *âS u *âG v
‹	±	1âG *âG u = u ± u *âG 1âG = u ± 1âG = MonâG {})
‹ ± (µI J∑	I ç Finite ± J ç Finite
‹	¥	MonâG I *âG MonâG J = SignâG I J *âS MonâG(I £ J))
‹ ± (µV∑	(µI∑ I ç Finite ¥ MonâG I ç V)
‹	±	(µa u∑ u ç V ¥ a *âS u ç V)
‹	±	(µu v∑ u ç V ± v ç V ¥ u +âG v ç V)
‹	¥	(µu∑ u ç V))
‹ ± (µJ∑	J ç Finite
‹	¥	∂V∑	(µI∑ ≥I = J ± I ç Finite ¥ MonâG I ç V)
‹ 		±	(µa u∑ u ç V ¥ a *âS u ç V)
‹ 		±	(µu v∑ u ç V ± v ç V ¥ u +âG v ç V)
‹ 		±	≥MonâG J ç V)
∞

We now define the function
=INLINEFT
VecâG
=TEX
\ that maps an integer $i$ to the element $\E{i}$ of~\cite{Arthan06b} and the embedding of the naturals in $\GA$

πHOLCONST
‹ €VecâG› : ˙ ≠ GA
˜¸¸¸¸¸¸
‹ µ i∑ VecâG i = MonâG {i}
∞

πHOLCONST
‹ €ÓâG› : Ó ≠ GA
˜¸¸¸¸¸¸
‹ ÓâG 0 = 0âG ± µ m∑ ÓâG (m+1) = ÓâG m +âG 1âG
∞

=SML
declare_alias("á", ¨ÓâGÆ);
declare_alias("+", ¨$+âGÆ);
declare_alias("*", ¨$*âGÆ);
declare_alias("~", ¨~âGÆ);
=TEX


\ThmsIII{%
=GFT
ga_ops_def
ga_plus_assoc_thm
ga_plus_comm_thm
ga_plus_zero_thm
ga_plus_order_thm
ga_plus_0_thm
ga_0_1_thm
=TEX
}{%
=GFT
ga_plus_minus_thm
ga_eq_thm
á_plus_homomorphism_thm
ga_one_scale_thm
ga_scale_scale_assoc_thm
ga_scale_plus_distrib_thm
ga_plus_scale_distrib_thm
=TEX
}{%
=GFT
ga_times_assoc_thm
ga_times_plus_distrib_thm
ga_plus_times_distrib_thm
ga_scale_times_assoc_thm
ga_one_times_thm
ga_times_one_thm
ga_one_mon_thm
=TEX
}

\subsection{Some Linear Space Notions}
(Note: we use the term {\em linear space} for the usual notion of a vector space to avoid confusion with the privileged role of the 1-vectors in $\GA$).

We define the notion of a Linear subspace of $\GA$:

πHOLCONST
‹ €SubspaceâG› : GA SET SET
˜¸¸¸¸¸¸
‹ µV∑	V ç SubspaceâG §
‹		0âG ç V
‹	±	(µa u∑ u ç V ¥ a *âS u ç V)
‹	±	(µu v∑ u ç V ± v ç V ¥ u +âG v ç V)
∞
The linear space spanned by a subset of $\GA$ is defined as follows:

πHOLCONST
‹ €SpanâG› : GA SET ≠ GA SET
˜¸¸¸¸¸¸
‹ µX∑	SpanâG X = •{V | V ç SubspaceâG ± X Ä V}
∞
A set $X$ is linearly independent iff. the spans of its proper subsets are proper subsets of its span.
πHOLCONST
‹ €IndepâG› : GA SET SET
˜¸¸¸¸¸¸
‹ µX∑ X ç IndepâG § µY∑Y Ä X ± SpanâG Y = SpanâG X ¥ Y = X
∞
\ThmsIII{%
=GFT
ga_mon_span_thm
ga_mon_indep_thm
ga_mon_times_mon_thm 
ga_minus_clauses
ga_minus_eq_thm
ga_0_times_thm
ga_0_scale_thm
ga_scale_0_thm
ga_minus_1_scale_thm
=TEX
}{%
=GFT
finite_friend_thm
ga_mon_not_0_thm
ga_mon_1_thm
ga_mon_subgroup_thm
ga_vec_generators_thm
ga_vec_relations_thm
ga_vec_indep_thm
ga_span_subspace_thm
=TEX
}{%
=GFT
ga_Ä_span_thm
ga_span_Ä_thm
ga_trivial_subspaces_thm
ga_mon_span_bc_thm
ga_span_mon_thm
ga_span_mono_thm
ga_indep_thm
ga_mon_indep_thm1
=TEX
}

=TEX
\subsection{The Representatives for the Algebra Operations}\label{representatives}

The proof of the consistency of the specification of the operations of $\GA$ in section~\ref{ops} is made tolerable by introducing constants for the representatives of the operations on the representation type.

We adopt the convention of using an initial `\_' to distinguish operations on the representation type from corresponding operations on the new type.
=SML
declare_infix(300, "_+âG");
=TEX

πHOLCONST
‹ $€_+âG› : _GA ≠ _GA ≠ _GA
˜¸¸¸¸¸¸
‹ µ v w∑ v _+âG w = ÃK∑ v K + w K
∞
πHOLCONST
‹ €_~âG› : _GA ≠ _GA
˜¸¸¸¸¸¸
‹ µ v∑ _~âG v = ÃK∑ ~(v K)
∞
=SML
declare_infix(310, "_*âG");
=TEX

πHOLCONST
‹ $€_*âG› : _GA ≠ _GA ≠ _GA
˜¸¸¸¸¸¸
‹ µ v w∑
‹	v _*âG w = ÃK∑
‹	ì {(I, J) | I ç Supp v ± J ç Supp w ± K = I £ J}
‹	(Ã(I, J)∑ SignâG I J * v I * w J)
∞
=SML
declare_infix(310, "_*âS");
=TEX

πHOLCONST
‹ $€_*âS› : Ø ≠ _GA ≠ _GA
˜¸¸¸¸¸¸
‹ µ c v∑ c _*âS v = ÃK∑c * v K
∞

πHOLCONST
‹ €_0âG› : _GA
˜¸¸¸¸¸¸
‹ _0âG = ÃK∑ ÓØ 0
∞
πHOLCONST
‹ €_1âG› : _GA
˜¸¸¸¸¸¸
‹ _1âG = —{{}}
∞




{\raggedright
\bibliographystyle{plain}
\bibliography{fmu}}

%\appendix
{%\HOLindexOff
\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{wrk076.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
=TEX
%%%%
%%%%
=SML
=SML
=TEX
%%%%
%%%%

=TEX

=SML
val €£_def› = get_spec¨$£Æ;
val €sign_g_def› = get_spec¨SignâGÆ;
val €plus_g_def› = get_spec¨$_+âGÆ;
val €minus_g_def› = get_spec¨_~âGÆ;
val €times_g_def› = get_spec¨$_*âGÆ;
val €times_s_def› = get_spec¨$_*âSÆ;
val €zero_g_def› = get_spec¨_0âGÆ;
val €one_g_def› = get_spec¨_1âGÆ;
val €is_ga_rep_def› = get_spec¨IsGARepÆ;
=TEX
=SML
val €mod_2_clauses› = rewrite_rule[] (µ_elim¨2Æmod_clauses);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b c∑
	a £ {} = a
±	{} £ a = a
±	a £ b = b £ a
±	a £ b £ c = (a £ b) £ cÆ);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_group_thm› = save_pop_thm "£_group_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b∑ a £ b = b £ aÆ);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_comm_thm› = save_pop_thm "£_comm_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b c∑
	(a £ b) £ c = a £ b £ cÆ);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_assoc_thm› = save_pop_thm "£_assoc_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b∑
	a £ {} = a
±	{} £ a = a
±	a £ a = {}
±	a £ a = {}Æ);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_clauses› = save_pop_thm "£_clauses";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b c∑ a = b £ c § c = b £ aÆ);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_inverse_thm› = pop_thm(); (* "£_inverse_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨
	a £ a  = {}
±	a £ a £ b = b
±	{} £ a = a
±	a £ {} = a
±	a £ {} £ b = a £ bÆ);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_simp_thm› = pop_thm();
val €£_simp_conv› =
	let	val conv1 = FIRST_C(
			map (simple_eq_match_conv o all_µ_intro)
			(strip_±_rule £_simp_thm));
	in	conv1 THEN_C REPEAT_C conv1
	end;
fun €£_nf_conv› (ty : TYPE) = sort_conv term_order
	(inst_type_rule[(ty, î'aÆ)] £_comm_thm)
	(inst_type_rule[(ty, î'aÆ)] £_assoc_thm)
	£_simp_conv fail_conv;
=IGN
£_nf_conv î'aÆ ¨b £ aÆ;
£_nf_conv  î'aÆ ¨a £ bÆ;
£_nf_conv î'aÆ  ¨a £ b £ aÆ;
£_nf_conv î'aÆ  ¨a £ b £ (c £ {}) £ {} £ {} £ c £ aÆ;
£_nf_conv Ó ¨(x £ (x £ z) £ {1})Æ;
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b∑
	a ° b = {} § a £ b = a ¿ bÆ);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_eq_¿_thm› = pop_thm(); (* "£_eq_¿_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b∑ a ç Finite ± b ç Finite ¥ a £ b ç FiniteÆ);
a(REPEAT strip_tac THEN bc_thm_tac Ä_finite_thm
	THEN ∂_tac¨a ¿ bÆ
	THEN asm_rewrite_tac[£_def, ¿_finite_thm]
	THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_finite_thm› = save_pop_thm "£_finite_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µf a b∑
	f {} = 0
±	(µa b∑ a ç Finite ± b ç Finite
	¥	f(a ¿ b) + f(a ° b) = f a + f b)
±	a ç Finite
±	b ç Finite
¥	f(a £ b) + 2*f(a ° b) = f a + f b
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨a ¿ b ç FiniteÆ THEN1 asm_rewrite_tac[¿_finite_thm]);
a(lemma_tac¨a ° b ç FiniteÆ THEN1 ALL_FC_T rewrite_tac[°_finite_thm]);
a(lemma_tac¨a £ b ç FiniteÆ THEN1 all_fc_tac[£_finite_thm]);
a(LIST_SPEC_NTH_ASM_T 6 [¨a £ bÆ, ¨a ° bÆ] ante_tac);
a(LIST_SPEC_NTH_ASM_T 6 [¨aÆ, ¨bÆ] ante_tac);
a(DROP_NTH_ASM_T 6 discard_tac);
a(LEMMA_T ¨(a £ b) ¿ a ° b = a ¿ b ± (a £ b) ° a ° b = {}Æ
	asm_rewrite_thm_tac
	THEN1 (rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(PC_T1 "lin_arith" prove_tac[]);
val €size_£_lemma› = save_pop_thm "size_£_lemma";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b∑
	a ç Finite
±	b ç Finite
¥	a £ b ç Finite
±	#(a £ b) + 2 * #(a ° b) = #a + #b
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨a ¿ bÆ);
a(asm_rewrite_tac[¿_finite_thm, £_def]
	THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "2" *** *)
a(bc_thm_tac size_£_lemma);
a(asm_rewrite_tac[size_empty_thm, size_¿_thm]);
val €£_finite_size_thm› = save_pop_thm "£_finite_size_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b∑
	≥a ç Finite
±	b ç Finite
¥	≥a £ b ç Finite
Æ);
a(REPEAT strip_tac);
a(finite_induction_tac¨bÆ THEN1 asm_rewrite_tac[£_clauses]);
a(swap_nth_asm_concl_tac 2);
a(bc_thm_tac Ä_finite_thm THEN1 ∂_tac ¨{x} ¿ (a £ ({x} ¿ b'))Æ
	THEN asm_rewrite_tac[¿_finite_thm, singleton_finite_thm]);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €£_infinite_thm› = save_pop_thm "£_infinite_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µt a b c∑
	(µa∑t a {} = 0)
±	(µa b c∑a ç Finite ± b ç Finite ± c ç Finite
	¥	t a (b ¿ c) + t a (b ° c) = t a b + t a c)
±	a ç Finite ± b ç Finite ± c ç Finite
¥	t a (b £ c) + 2 * t a (b ° c) = t a b + t a c
Æ);
a(REPEAT strip_tac);
a(bc_thm_tac size_£_lemma THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
val €sign_g_lemma1› = pop_thm(); (* "sign_g_lemma1" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µt a b c∑
	(µa∑t {} a = 0)
±	(µa b c∑a ç Finite ± b ç Finite ± c ç Finite
	¥	t (a ¿ b) c + t (a ° b) c = t a c + t b c)
±	a ç Finite ± b ç Finite ± c ç Finite
¥	t (a £ b) c + 2 * t (a ° b) c = t a c + t b c
Æ);
a(REPEAT strip_tac);
a(bc_thm_tac(rewrite_rule[](µ_elim¨Ãx y∑ t y xÆ sign_g_lemma1)));
a(asm_rewrite_tac[] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
val €sign_g_lemma2› = pop_thm(); (* "sign_g_lemma2" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µt a b c∑
	(µa∑t a {} = 0)
±	(µa b c∑a ç Finite ± b ç Finite ± c ç Finite
	¥	t a (b ¿ c) + t a (b ° c) = t a b + t a c)
±	(µa∑t {} a = 0)
±	(µa b c∑a ç Finite ± b ç Finite ± c ç Finite
	¥	t (a ¿ b) c + t (a ° b) c = t a c + t b c)
±	a ç Finite ± b ç Finite ± c ç Finite
¥	(t a b + t (a £ b) c) Mod 2 = (t a (b £ c) + t b c) Mod 2
Æ);
a(REPEAT strip_tac);
a(LEMMA_T ¨
	((t a b + t (a £ b) c) + 2 * t (a ° b) c) Mod 2 =
	((t a (b £ c) + t b c) + 2 * t a (b ° c)) Mod 2Æ
	(accept_tac o rewrite_rule[mod_2_clauses]));
a(LEMMA_T ¨((t a (b £ c) + t b c) + 2 * t a (b ° c)) =
	((t a b + t (a £ b) c) + 2 * t (a ° b) c)Æ
	rewrite_thm_tac);
a(conv_tac(RIGHT_C (rewrite_conv[plus_assoc_thm])));
a(rewrite_tac[pc_rule1"lin_arith" prove_rule[]
	¨µi j k:Ó∑(i + j) + k = j + i + kÆ]);
a(ALL_FC_T rewrite_tac[sign_g_lemma1, sign_g_lemma2]);
a(PC_T1 "lin_arith" prove_tac[]);
val €sign_g_lemma4› = pop_thm(); (* "sign_g_lemma4" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µm∑
	 ~(ÓØ 1) ^ m = ~(ÓØ 1) ^ (m Mod 2)
Æ);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim¨mÆ mod_2_cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[mod_2_0_Ø_Ó_exp_thm, mod_2_1_Ø_Ó_exp_thm]
	THEN rewrite_tac[Ø_Ó_exp_0_1_thm]);
val €Ø_Ó_exp_mod_2_thm› = save_pop_thm "Ø_Ó_exp_mod_2_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µI J K:˙ SET∑
	{(i, j)|i ç I ¿ J ± j ç K ± j < i} =
	{(i, j)|i ç I ± j ç K ± j < i} ¿
	{(i, j)|i ç J ± j ç K ± j < i}
±	{(i, j)|i ç I ± j ç J ¿ K ± j < i} =
	{(i, j)|i ç I ± j ç J ± j < i} ¿
	{(i, j)|i ç I ± j ç K ± j < i}
±	{(i, j)|i ç I ° J ± j ç K ± j < i} =
	{(i, j)|i ç I ± j ç K ± j < i} °
	{(i, j)|i ç J ± j ç K ± j < i}
±	{(i, j)|i ç I ± j ç J ° K ± j < i} =
	{(i, j)|i ç I ± j ç J ± j < i} °
	{(i, j)|i ç I ± j ç K ± j < i}
Æ);
a(PC_T1 "sets_ext1" prove_tac[]);
val €sign_g_lemma5› = pop_thm(); (* "sign_g_lemma5" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µI J:˙ SET∑
	I ç Finite ± J ç Finite
¥	{(i, j)|i ç I ± j ç J ± j < i} ç Finite
Æ);
a(REPEAT strip_tac THEN bc_thm_tac Ä_finite_thm);
a(∂_tac¨I ∏ JÆ THEN ALL_FC_T rewrite_tac[∏_finite_size_thm]);
a(rewrite_tac[∏_def] THEN PC_T1 "sets_ext1" prove_tac[]);
val €sign_g_lemma6› = pop_thm(); (* "sign_g_lemma6" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µS1; I J K:˙ SET∑
	(µx y∑S1 x y = ~ (ÓØ 1) ^ # {(i, j)|i ç x ± j ç y ± j < i})
±	I ç Finite
±	J ç Finite
±	K ç Finite
¥	S1 I J * S1 (I £ J) K
=	S1 I (J £ K) * S1 J K
Æ);
a(REPEAT strip_tac THEN asm_rewrite_tac[
	conv_rule(ONCE_MAP_C eq_sym_conv) Ø_Ó_exp_plus_thm]);
a(once_rewrite_tac[Ø_Ó_exp_mod_2_thm]);
a(bc_thm_tac(prove_rule[]¨µx:Ø; i j :Ó∑ i = j ¥ x^i = x^jÆ));
a(bc_thm_tac(rewrite_rule[](µ_elim¨Ãa b:˙ SET∑# {(i, j)|i ç a ± j ç b ± j < i}Æ sign_g_lemma4)));
a(asm_rewrite_tac[pc_rule1"sets_ext1" prove_rule[]
	¨{(i, j)|F} = {}Æ,
	size_empty_thm]);
a(DROP_ASMS_T discard_tac THEN rewrite_tac[sign_g_lemma5]);
a(REPEAT strip_tac THEN bc_thm_tac size_¿_thm
	THEN ALL_FC_T rewrite_tac[sign_g_lemma6]);
val €sign_g_lemma7› = pop_thm(); (* "sign_g_lemma7" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b c∑
	a ç Finite
±	b ç Finite
±	c ç Finite
¥	(#a + #(b £ c)) Mod 2 = (#(a £ b) + #c) Mod 2
Æ);
a(REPEAT strip_tac);
a(LEMMA_T ¨((#a + #(b £ c)) + 2 * #(b ° c)) Mod 2 =
	((#(a £ b) + #c) + 2 * #(a ° b)) Mod 2Æ
	(accept_tac o rewrite_rule[mod_2_clauses]));
a(LEMMA_T ¨((#a + #(b £ c)) + 2 * #(b ° c)) =
	((#(a £ b) + #c) + 2 * #(a ° b)) Æ
	rewrite_thm_tac);
a(rewrite_tac[plus_assoc_thm] THEN rewrite_tac[µ_elim¨#cÆ plus_order_thm]);
a(ALL_FC_T rewrite_tac[arb_gen £_finite_size_thm]);
a(PC_T1 "lin_arith" prove_tac[]);
val €sign_g_lemma8› = pop_thm(); (* "sign_g_lemma8" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µI J K : ˙ SET∑
	{i|i ç I ± i ç J ± i < Ó˙ 0} =
	{i|i ç I ± i < Ó˙ 0} ° {j|j ç J ± j < Ó˙ 0}
±	{i|i ç I ± i ç J £ K ± i < Ó˙ 0} =
	({i|i ç I ± i < Ó˙ 0} ° {j|j ç J ± j < Ó˙ 0}) £
	({i|i ç I ± i < Ó˙ 0} ° {k|k ç K ± k < Ó˙ 0})
±	{i|i ç I £ J ± i ç K ± i < Ó˙ 0} =
	({i|i ç I ± i < Ó˙ 0} ° {k|k ç K ± k < Ó˙ 0}) £
	({j|j ç J ± j < Ó˙ 0} ° {k|k ç K ± k < Ó˙ 0})
Æ);
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext" prove_tac[]);
val €sign_g_lemma9› = pop_thm(); (* "sign_g_lemma9" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µS2; I J K:˙ SET∑
	(µx y∑S2 x y = ~ (ÓØ 1) ^ # {i|i ç x ± i ç y ± i < Ó˙ 0})
±	I ç Finite
±	J ç Finite
±	K ç Finite
¥	S2 I J * S2 (I £ J) K
=	S2 I (J £ K) * S2 J K
Æ);
a(REPEAT strip_tac THEN asm_rewrite_tac[
	conv_rule(ONCE_MAP_C eq_sym_conv) Ø_Ó_exp_plus_thm]);
a(once_rewrite_tac[Ø_Ó_exp_mod_2_thm]);
a(bc_thm_tac(prove_rule[]¨µx:Ø; i j :Ó∑ i = j ¥ x^i = x^jÆ));
a(rewrite_tac[sign_g_lemma9]);
a(bc_thm_tac sign_g_lemma8);
a(lemma_tac¨I ¿ J ¿ K ç FiniteÆ THEN1 asm_rewrite_tac[¿_finite_thm]);
a(LIST_DROP_NTH_ASM_T [2, 3, 4, 5] discard_tac);
a(REPEAT strip_tac THEN bc_thm_tac Ä_finite_thm
	THEN ∂_tac¨I ¿ J ¿ KÆ
	THEN REPEAT strip_tac
	THEN PC_T1 "sets_ext" asm_prove_tac[]);
val €sign_g_lemma10› = pop_thm(); (* "sign_g_lemma10" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µI J K:˙ SET∑
	I ç Finite
±	J ç Finite
±	K ç Finite
¥	SignâG I J * SignâG (I £ J) K
=	SignâG I (J £ K) * SignâG J K
Æ);
a(lemma_tac¨∂S1 S2∑
	(µx y:˙ SET∑S1 x y = ~ (ÓØ 1) ^ # {(i, j)|i ç x ± j ç y ± j < i})
±	(µx y:˙ SET∑S2 x y = ~ (ÓØ 1) ^ # {i|i ç x ± i ç y ± i < Ó˙ 0})Æ THEN1 prove_∂_tac);
a(REPEAT strip_tac);
a(LEMMA_T¨µx y∑SignâG x y = S1 x y * S2 x yÆ
	rewrite_thm_tac
	THEN1 (asm_rewrite_tac[sign_g_def, Ø_Ó_exp_plus_thm]));
a(rewrite_tac[Ø_times_assoc_thm]);
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]
	¨µx1 y2 y1 x2:Ø∑ x1 * x2 * y1 * y2 = (x1 * y1) * (x2 * y2)Æ]);
a(ALL_FC_T rewrite_tac[sign_g_lemma7, sign_g_lemma10]);
val €sign_g_thm› = save_pop_thm "sign_g_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µI J∑
	 SignâG I J = ÓØ 1 ≤ SignâG I J = ~(ÓØ 1)
Æ);
a(REPEAT µ_tac THEN rewrite_tac[sign_g_def]);
a(strip_asm_tac (µ_elim¨# {(i, j)|i ç I ± j ç J ± j < i}
             + # {i|i ç I ± i ç J ± i < Ó˙ 0}Æ mod_2_cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[mod_2_0_Ø_Ó_exp_thm, mod_2_1_Ø_Ó_exp_thm]
	THEN rewrite_tac[Ø_Ó_exp_0_1_thm]);
val €sign_g_cases_thm› = save_pop_thm "sign_g_cases_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨ µi∑ SignâG {i} {i} =
	if i < Ó˙ 0 then ~(ÓØ 1) else ÓØ 1 Æ);
a(REPEAT strip_tac THEN rewrite_tac[sign_g_def]);
a(LEMMA_T ¨{(i', j)|i' = i ± j = i ± j < i'} = {}Æ rewrite_thm_tac
	THEN1 (PC_T1 "sets_ext1" REPEAT strip_tac
		THEN all_var_elim_asm_tac1));
a(PC_T1 "predicates" cases_tac ¨i < Ó˙ 0Æ THEN asm_rewrite_tac[size_empty_thm]);
(* *** Goal "1" *** *)
a(LEMMA_T ¨{i'|i' = i ± i' = i ± i' < Ó˙ 0} = {i}Æ rewrite_thm_tac
	THEN1 (PC_T1 "sets_ext1" REPEAT strip_tac
		THEN all_var_elim_asm_tac1));
a(rewrite_tac[size_singleton_thm, Ø_Ó_exp_0_1_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨{i'|i' = i ± i' = i ± i' < Ó˙ 0} = {}Æ rewrite_thm_tac
	THEN1 (PC_T1 "sets_ext1" REPEAT strip_tac
		THEN all_var_elim_asm_tac1));
a(rewrite_tac[size_empty_thm, Ø_Ó_exp_0_1_thm]);
val €sign_singleton_thm› = save_pop_thm "sign_singleton_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨ µi j∑ ≥i = j ¥ SignâG {i} {j} =
	if i < j then ÓØ 1 else ~(ÓØ 1) Æ);
a(REPEAT strip_tac THEN rewrite_tac[sign_g_def]);
a(LEMMA_T ¨{i'|i' = i ± i' = j ± i' < Ó˙ 0} = {}Æ rewrite_thm_tac
	THEN1 (PC_T1 "sets_ext1" REPEAT strip_tac
		THEN all_var_elim_asm_tac1));
a(PC_T1 "predicates" cases_tac¨i < jÆ
	THEN asm_rewrite_tac[size_empty_thm]);
(* *** Goal "1" *** *)
a(LEMMA_T ¨{(i', j')| i' = i ± j' = j ± j' < i'} = {}Æ rewrite_thm_tac
	THEN1 (PC_T1 "sets_ext1" REPEAT strip_tac
		THEN all_var_elim_asm_tac1
		THEN PC_T1 "˙_lin_arith" asm_prove_tac[]));
a(rewrite_tac[size_empty_thm, Ø_Ó_exp_0_1_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨{(i', j')| i' = i ± j' = j ± j' < i'} = {(i, j)}Æ rewrite_thm_tac
	THEN1 (PC_T "sets_ext1" strip_tac
		THEN REPEAT strip_tac
		THEN all_var_elim_asm_tac1
		THEN PC_T1 "˙_lin_arith" asm_prove_tac[]));
a(rewrite_tac[size_singleton_thm, Ø_Ó_exp_0_1_thm]);
val €sign_singletons_thm› = save_pop_thm "sign_singletons_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µv w K∑
	Supp v ç Finite ≤ Supp w ç Finite
¥	 {(I, J)|I ç Supp v ± J ç Supp w ± K = I £ J} ç Finite
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN bc_thm_tac Ä_finite_thm);
a(∂_tac¨{(I, J) | I ç Supp v ± K = I £ J}Æ
	THEN REPEAT strip_tac
	THEN_LIST [id_tac,  PC_T1 "sets_ext1" prove_tac[]]);
a(lemma_tac¨{(I, J)|I ç Supp v ± K = I £ J} ç Finite ±
	#{(I, J)|I ç Supp v ± K = I £ J} = #(Supp v)Æ
	THEN1 bc_thm_tac bijection_finite_size_thm);
a(once_rewrite_tac[£_inverse_thm]);
a(∂_tac¨ÃI∑(I, I £ K)Æ THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" once_rewrite_tac[] THEN rewrite_tac[]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1
	THEN REPEAT strip_tac);
a(∂_tac¨x1Æ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN bc_thm_tac Ä_finite_thm);
a(∂_tac¨{(I, J) | J ç Supp w ± K = I £ J}Æ
	THEN REPEAT strip_tac
	THEN_LIST [id_tac,  PC_T1 "sets_ext1" prove_tac[]]);
a(lemma_tac¨{(I, J)| J ç Supp w ± K = I £ J} ç Finite ±
	#{(I, J)| J ç Supp w ± K = I £ J} = #(Supp w)Æ
	THEN1 bc_thm_tac bijection_finite_size_thm);
a(once_rewrite_tac[£_group_thm]);
a(once_rewrite_tac[£_inverse_thm]);
a(∂_tac¨ÃJ∑(J £ K, J)Æ THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" once_rewrite_tac[] THEN rewrite_tac[]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1
	THEN REPEAT strip_tac);
a(∂_tac¨x2Æ THEN REPEAT strip_tac);
val €times_g_finite_thm› = pop_thm(); (* "times_g_finite_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µc v∑
	≥c = ÓØ 0 ¥ Supp (c _*âS v) = Supp v
Æ);
a(REPEAT strip_tac THEN PC_T1 "sets_ext1" rewrite_tac[supp_def, times_s_def]
	THEN µ_tac);
a(cases_tac¨v x = ÓØ 0Æ THEN asm_rewrite_tac[Ø_times_eq_0_thm]);
val €supp_times_s_thm› = pop_thm(); (* "supp_times_s_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µA∑
	Supp _0âG = {}
±	Supp _1âG = {{}}
Æ);
a(rewrite_tac[zero_g_def, one_g_def, supp_—_thm, supp_clauses]);
val €supp_zero_one_g_thm› = pop_thm(); (* "supp_zero_one_g_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µv w∑
	Supp v ç Finite
¥	v _*âG w =
	ÃK∑ ì (Supp v) (Ã I∑ SignâG I (K £ I) * v I * w (K £ I))
Æ);
a(REPEAT strip_tac THEN rewrite_tac[times_g_def]);
a(lemma_tac¨{(I, J)|I ç Supp v ± J ç Supp w ± x = I £ J} ç FiniteÆ
	THEN1 ALL_FC_T asm_rewrite_tac[times_g_finite_thm]);
a(conv_tac eq_sym_conv);
a(bc_thm_tac ind_sum_transfer_thm);
a(rename_tac[(¨xÆ, "K")] THEN ∂_tac¨ÃI∑ (I, K £ I)Æ
	THEN PC_T1 "predicates" asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac);
a(rewrite_tac[Ø_times_eq_0_thm, supp_def]
	THEN taut_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "3" *** *)
a(rewrite_tac[]);
(* *** Goal "4" *** *)
a(lemma_tac¨µa b c:˙ SET∑((a £ b) £ a) = bÆ
	THEN1 (rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(∂â1_tac¨Fst yÆ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
val €times_g_def1› = pop_thm(); (* "times_g_def1" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µv w∑
	Supp w ç Finite
¥	v _*âG w =
	ÃK∑ ì (Supp w) (Ã J∑ SignâG (K £ J) J * v (K £ J) * w J)
Æ);
a(REPEAT strip_tac THEN rewrite_tac[times_g_def]);
a(lemma_tac¨{(I, J)|I ç Supp v ± J ç Supp w ± x = I £ J} ç FiniteÆ
	THEN1 ALL_FC_T asm_rewrite_tac[times_g_finite_thm]);
a(conv_tac eq_sym_conv);
a(bc_thm_tac ind_sum_transfer_thm);
a(rename_tac[(¨xÆ, "K")] THEN ∂_tac¨ÃJ∑ (K £ J, J)Æ
	THEN PC_T1 "predicates" asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac);
a(rewrite_tac[Ø_times_eq_0_thm, supp_def]
	THEN taut_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]);
(* *** Goal "3" *** *)
a(rewrite_tac[]);
(* *** Goal "4" *** *)
a(lemma_tac¨µa b c:˙ SET∑((b £ a) £ a) = bÆ
	THEN1 (rewrite_tac[£_def] THEN PC_T1 "sets_ext1" prove_tac[]));
a(∂â1_tac¨Snd yÆ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
val €times_g_def2› = pop_thm(); (* "times_g_def2" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µv∑
	ÓØ 0 _*âS v = _0âG
Æ);
a(REPEAT strip_tac THEN rewrite_tac[zero_g_def, times_s_def]);
val €zero_times_s_thm› = pop_thm(); (* "zero_times_s_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µv∑
	_0âG _*âG v = _0âG
±	v _*âG _0âG = _0âG
Æ);
a(REPEAT µ_tac THEN rewrite_tac[times_g_def]);
a(rewrite_tac[supp_zero_one_g_thm, pc_rule1 "sets_ext1" prove_rule[]
	¨{(a, b)|F} = {}Æ,
	ind_sum_def]);
a(rewrite_tac[zero_g_def]);
val €zero_times_g_thm› = pop_thm(); (* "zero_times_g_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu v∑
	u _+âG v = v _+âG u
Æ);
a(REPEAT µ_tac THEN rewrite_tac[plus_g_def]);
val €plus_g_comm_thm› = pop_thm(); (* "plus_g_comm_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu v w∑
	(u _+âG v) _+âG w = u _+âG (v _+âG w)
Æ);
a(REPEAT µ_tac THEN rewrite_tac[plus_g_def, Ø_plus_assoc_thm]);
val €plus_g_assoc_thm› = pop_thm(); (* "plus_g_assoc_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu∑
	u _+âG _0âG = u
Æ);
a(REPEAT µ_tac THEN rewrite_tac[plus_g_def, zero_g_def]);
val €plus_g_0_thm› = pop_thm(); (* "plus_g_0_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu∑
	u _+âG (_~âG u) = _0âG
Æ);
a(REPEAT µ_tac THEN rewrite_tac[plus_g_def, minus_g_def, zero_g_def]);
val €plus_g_minus_g_thm› = pop_thm(); (* "plus_g_minus_g_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu∑
	ÓØ 1 _*âS u = u
Æ);
a(REPEAT µ_tac THEN rewrite_tac[times_s_def]);
val €one_times_s_thm› = pop_thm(); (* "one_times_s_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b u∑
	a _*âS (b _*âS u) = (a * b) _*âS u
Æ);
a(REPEAT µ_tac THEN rewrite_tac[times_s_def, Ø_times_assoc_thm]);
val €times_s_times_s_thm› = pop_thm(); (* "times_s_times_s_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa u v∑
	a _*âS (u _+âG v) = (a _*âS u) _+âG (a _*âS v)
Æ);
a(REPEAT µ_tac THEN rewrite_tac[times_s_def, plus_g_def, Ø_times_plus_distrib_thm]);
val €times_s_plus_g_distrib_thm› = pop_thm(); (* "times_s_plus_g_distrib_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa b u∑
	(a + b) _*âS u = (a _*âS u) _+âG (b _*âS u)
Æ);
a(REPEAT µ_tac THEN rewrite_tac[times_s_def, plus_g_def, Ø_times_plus_distrib_thm]);
val €plus_times_s_distrib_thm› = pop_thm(); (* "plus_times_s_distrib_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu v w∑
	Supp u ç Finite ± Supp u Ä Finite
±	Supp v ç Finite ± Supp v Ä Finite
±	Supp w ç Finite ± Supp w Ä Finite
¥	(u _*âG v) _*âG w = u _*âG (v _*âG w)
Æ);
a(REPEAT strip_tac);
a(PC_T1 "predicates" (ALL_FC_T rewrite_tac) [arb_gen times_g_def2]);
a(PC_T1 "predicates" (ALL_FC_T rewrite_tac) [times_g_def1]);
a(LEMMA_T ¨µf; c:Ø∑ì (Supp v) f * c = ì (Supp v) (ÃI∑f I * c)Æ
	rewrite_thm_tac
	THEN1 (once_rewrite_tac[Ø_times_comm_thm]
		THEN ALL_FC_T rewrite_tac[ind_sum_const_times_thm]));
a(LEMMA_T ¨µf; c:Ø∑c * ì (Supp v) f = ì (Supp v) (ÃJ∑c * f J)Æ
	rewrite_thm_tac
	THEN1 ALL_FC_T rewrite_tac[ind_sum_const_times_thm]);
a(LEMMA_T ¨µf; c:Ø∑c * ì (Supp w) f = ì (Supp w) (ÃJ∑c * f J)Æ
	rewrite_thm_tac
	THEN1 ALL_FC_T rewrite_tac[ind_sum_const_times_thm]);
a(ALL_FC_T rewrite_tac[rewrite_rule[](µ_elim¨(Ã (K, L)∑ SignâG (x £ K) K * (SignâG ((x £ K) £ L) L * u ((x £ K) £ L) * v L) * r K)Æ
ind_sum_∏_thm)]);
a(ALL_FC_T rewrite_tac[rewrite_rule[](µ_elim¨Ã(I, J)∑SignâG I (x £ I) * u I * SignâG ((x £ I) £ J) J * v ((x £ I) £ J) * w JÆ
ind_sum_∏_thm)]);
a(lemma_tac¨(Supp w ∏ Supp v) ç Finite ± (Supp u ∏ Supp w) ç FiniteÆ
	THEN1 ALL_FC_T rewrite_tac[∏_finite_size_thm]);
a(bc_thm_tac ind_sum_transfer_thm);
a(∂_tac¨Ã(K, L)∑ ((x £ K) £ L, K)Æ
	THEN asm_rewrite_tac[]
	THEN rewrite_tac[∏_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[Ø_times_eq_0_thm, supp_def]
	THEN taut_tac);
(* *** Goal "2" *** *)
a(conv_tac(ONCE_MAP_C(£_nf_conv(hd(snd(dest_ctype(type_of¨xÆ)))))));
a(lemma_tac¨Fst x' ç Finite ± Snd x' ç FiniteÆ
	THEN1 LIST_DROP_NTH_ASM_T[6, 8]
		(PC_T1 "sets_ext1" (ALL_FC_T rewrite_tac)));
a(lemma_tac¨Fst x' £ Snd x' ç FiniteÆ
	THEN1 all_fc_tac[£_finite_size_thm]);
a(cases_tac¨≥x ç FiniteÆ);
(* *** Goal "2.1" *** *)
a(lemma_tac¨≥x £ Fst x' £ Snd x' ç FiniteÆ
	THEN1 all_fc_tac[£_infinite_thm]);
a(cases_tac¨x £ Fst x' £ Snd x' ç Supp uÆ
	THEN1 LIST_DROP_NTH_ASM_T[16]
		(PC_T1 "sets_ext1" all_fc_tac));
a(POP_ASM_T ante_tac THEN rewrite_tac[supp_def]);
a(STRIP_T rewrite_thm_tac);
(* *** Goal "2.2" *** *)
a(rewrite_tac[µ_elim¨SignâG (x £ Fst x' £ Snd x') (Snd x')Æ
	Ø_times_order_thm]
	THEN rewrite_tac[Ø_times_assoc_thm1]);
a(lemma_tac¨x £ Fst x' £ Snd x' ç FiniteÆ
	THEN1 all_fc_tac[£_finite_size_thm]);
a(LEMMA_T ¨x £ Fst x' = (x £ Fst x' £ Snd x') £ Snd x'Æ
	rewrite_thm_tac
	THEN1 (conv_tac  (ONCE_MAP_C(£_nf_conv(hd(snd(dest_ctype(type_of¨xÆ))))))
		THEN strip_tac));
a(ALL_FC_T rewrite_tac[sign_g_thm]);
a(LEMMA_T ¨(Snd x' £ Fst x') = (Fst x' £ Snd x')Æ
	rewrite_thm_tac
	THEN1 (conv_tac  (ONCE_MAP_C(£_nf_conv(hd(snd(dest_ctype(type_of¨xÆ))))))
		THEN strip_tac));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[Ø_times_eq_0_thm]
	THEN REPEAT strip_tac);
a(∂â1_tac¨(Snd y, (x £ Fst y) £ Snd y)Æ
	THEN1 asm_rewrite_tac[supp_def]
	THEN conv_tac  (ONCE_MAP_C(£_nf_conv(hd(snd(dest_ctype(type_of¨xÆ)))))));
a(REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(lemma_tac¨Fst y ç Finite ± Snd y ç FiniteÆ
	THEN1 LIST_DROP_NTH_ASM_T[14, 10]
		(PC_T1 "sets_ext1" (ALL_FC_T rewrite_tac)));
a(lemma_tac¨Fst y £ Snd y ç FiniteÆ
	THEN1 all_fc_tac[£_finite_size_thm]);
a(cases_tac¨≥x ç FiniteÆ);
(* *** Goal "3.1.1" *** *)
a(lemma_tac¨≥x £ Fst y £ Snd y ç FiniteÆ
	THEN1 all_fc_tac[£_infinite_thm]);
a(cases_tac¨x £ Fst y £ Snd y ç Supp vÆ
	THEN1 LIST_DROP_NTH_ASM_T[18]
		(PC_T1 "sets_ext1" all_fc_tac));
a(POP_ASM_T ante_tac THEN rewrite_tac[supp_def]);
a(STRIP_T rewrite_thm_tac);
(* *** Goal "3.1.2" *** *)
a(rewrite_tac[µ_elim¨SignâG (Fst y) (x £ Fst y £ Snd y)Æ
	Ø_times_order_thm]
	THEN rewrite_tac[Ø_times_assoc_thm1]);
a(lemma_tac¨x £ Fst y £ Snd y ç FiniteÆ
	THEN1 all_fc_tac[£_finite_size_thm]);
a(LEMMA_T ¨x £ Snd y = Fst y £ (x £ Fst y £ Snd y)Æ
	rewrite_thm_tac
	THEN1 (conv_tac  (ONCE_MAP_C(£_nf_conv(hd(snd(dest_ctype(type_of¨xÆ))))))
		THEN strip_tac));
a(ALL_FC_T rewrite_tac[sign_g_thm]);
a(conv_tac(ONCE_MAP_C(£_nf_conv(hd(snd(dest_ctype(type_of¨xÆ)))))));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "3.2" *** *)
a(DROP_NTH_ASM_T 3 (rewrite_thm_tac o eq_sym_rule));
a(asm_rewrite_tac[]);
a(conv_tac(ONCE_MAP_C(£_nf_conv(hd(snd(dest_ctype(type_of¨xÆ))))))
	THEN REPEAT strip_tac);
val €times_g_assoc_thm› = pop_thm(); (* "times_g_assoc_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu v w∑
	Supp u ç Finite
¥	u _*âG (v _+âG w) = (u _*âG v) _+âG (u _*âG w)
±	(v _+âG w) _*âG u = (v _*âG u) _+âG (w _*âG u)
Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(PC_T1 "predicates" (ALL_FC_T rewrite_tac)[arb_gen times_g_def1, arb_gen times_g_def2]);
a(rewrite_tac[plus_g_def, Ø_times_plus_distrib_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(conv_tac(LEFT_C(RAND_C(SIMPLE_Ã_C(RANDS_C(un_¬_conv¨I:˙ SETÆ))))));
a(ALL_FC_T rewrite_tac[ind_sum_plus_thm]);
(* *** Goal "2" *** *)
a(conv_tac(LEFT_C(RAND_C(SIMPLE_Ã_C(RANDS_C(un_¬_conv¨J:˙ SETÆ))))));
a(ALL_FC_T rewrite_tac[ind_sum_plus_thm]);
val €times_g_plus_g_distrib_thm› = pop_thm(); (* "times_g_plus_g_distrib" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu v a∑
	Supp u ç Finite
±	Supp v ç Finite
¥	(a _*âS u) _*âG v = a _*âS (u _*âG v)
Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(cases_tac¨a = ÓØ 0Æ THEN1 PC_T1 "predicates" asm_rewrite_tac[zero_times_s_thm, zero_times_g_thm]);
a(lemma_tac¨Supp (a _*âS u) ç FiniteÆ
	THEN1 ALL_FC_T asm_rewrite_tac[supp_times_s_thm]);
a(PC_T1 "predicates" (ALL_FC_T rewrite_tac)[times_g_def1]);
a(ALL_FC_T rewrite_tac[supp_times_s_thm]);
a(µ_tac THEN rewrite_tac[times_s_def]);
a(rewrite_tac[µ_elim¨aÆØ_times_order_thm]);
a(pure_rewrite_tac[prove_rule[]
	¨ (Ã I∑ a * SignâG I (x £ I) * u I * v (x £ I)) =
	ÃI∑a * (Ã I∑ SignâG I (x £ I) * u I * v (x £ I)) I Æ]);
a(ALL_FC_T rewrite_tac[ind_sum_const_times_thm]);
val €times_s_times_g_assoc_thm› = pop_thm(); (* "times_s_times_g_assoc_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu∑
	_1âG _*âG u = u
±	u _*âG _1âG = u
Æ);
a(REPEAT µ_tac);
a(lemma_tac¨Supp _1âG ç FiniteÆ
	THEN1 rewrite_tac[supp_zero_one_g_thm, singleton_finite_thm]);
a(ALL_FC_T rewrite_tac[times_g_def1, times_g_def2]);
a(rewrite_tac[supp_zero_one_g_thm, ind_sum_singleton_thm,
	sign_g_def, £_clauses,
	pc_rule1 "sets_ext1" prove_rule[] ¨{i|F} = {} ± {(i, j) | F} = {}Æ,
	size_empty_thm, one_g_def, —_def]);
val €one_g_times_g_thm› = pop_thm(); (* "one_g_times_g_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu∑~ (ÓØ 1) _*âS u = _~âG uÆ);
a(rewrite_tac[times_s_def, minus_g_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €minus_one_times_g_thm› = pop_thm(); (* "minus_one_times_g_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu∑_~âG(_~âG u) = uÆ);
a(rewrite_tac[minus_g_def]);
val €minus_g_minus_g_thm› = pop_thm(); (* "minus_g_minus_g_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µI i j∑
	I £ {i} = {j} § i = j ± I = {} ≤ ≥i = j ± I = {i; j}
Æ);
a(REPEAT µ_tac);
a(rewrite_tac[pc_rule1 "sets_ext1" prove_rule[£_def] 
¨µa b c∑a £ b = c § a = b £ cÆ]);
a(REPEAT_UNTIL is_≤ strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1);
a(cases_tac¨i = jÆ THEN asm_rewrite_tac[£_clauses]);
a(rewrite_tac[pc_rule1 "sets_ext1" prove_rule[] 
¨{i; j} = {i} ¿ {j}Æ]);
a(lemma_tac¨≥j = iÆ THEN1 (contr_tac THEN all_var_elim_asm_tac1));
a(LEMMA_T ¨{i} ° {j} = {}Æ ante_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(rewrite_tac[£_eq_¿_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[£_clauses]);
(* *** Goal "3" *** *)
a(all_var_elim_asm_tac1);
a(rewrite_tac[pc_rule1 "sets_ext1" prove_rule[] 
¨{i; j} = {i} ¿ {j}Æ]);
a(lemma_tac¨≥j = iÆ THEN1 (contr_tac THEN all_var_elim_asm_tac1));
a(LEMMA_T ¨{i} ° {j} = {}Æ ante_tac
	THEN1 PC_T1 "sets_ext1" asm_prove_tac[]);
a(rewrite_tac[£_eq_¿_thm] THEN STRIP_T rewrite_thm_tac);
val €times_g_singleton_lemma› = pop_thm(); (* "times_g_singleton_lemma" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µp f g x∑
	(if p then f else g) x = if p then f x else g x
Æ);
a(REPEAT strip_tac);
a(cases_tac¨pÆ THEN asm_rewrite_tac[]);
val €app_if_thm› = save_pop_thm "app_if_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu v∑
	Supp u ç Finite ± Supp u Ä Finite
±	Supp v ç Finite ± Supp v Ä Finite
¥	Supp (u _+âG v) ç Finite ± Supp (u _+âG v) Ä Finite
Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(lemma_tac¨Supp (u _+âG v) Ä Supp u ¿ Supp vÆ
	THEN1 rewrite_tac[plus_g_def, supp_clauses]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ä_finite_thm THEN ∂_tac¨Supp u ¿ Supp vÆ
	THEN asm_rewrite_tac[¿_finite_thm]);
(* *** Goal "2" *** *)
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]
	¨µb c d∑b Ä d ± c Ä d ¥ b ¿ c Ä dÆ]
	THEN all_fc_tac[
		pc_rule1 "sets_ext1" prove_rule[]
		¨µa b c∑a Ä b ± b Ä c ¥ a Ä cÆ]);
val €plus_g_finitary_thm› = pop_thm(); (* "plus_g_finitary_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µI∑
	I ç Finite
¥	Supp(—{I}) ç Finite ± Supp(—{I}) Ä Finite
Æ);
a(REPEAT strip_tac THEN rewrite_tac[supp_—_thm, singleton_finite_thm]);
a(PC_T1 "sets_ext1" once_rewrite_tac[] THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
val €—_finite_finitary_thm› = pop_thm(); (* "—_finite_finitary_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨
	(Supp(_0âG) ç Finite ± Supp(_0âG) Ä Finite)
±	Supp(_1âG) ç Finite ± Supp(_1âG) Ä Finite
Æ);
a(rewrite_tac[supp_zero_one_g_thm, empty_finite_thm, singleton_finite_thm]);
a(PC_T1 "sets_ext1" once_rewrite_tac[] THEN REPEAT strip_tac);
a(asm_rewrite_tac[empty_finite_thm]);
val €zero_one_finitary_thm› = pop_thm(); (* "zero_one_finitary_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µa u∑
	Supp u ç Finite ± Supp u Ä Finite
¥	Supp (a _*âS u) ç Finite ± Supp (a _*âS u) Ä Finite
Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(cases_tac¨a = ÓØ 0Æ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[zero_times_s_thm, zero_times_g_thm,
	supp_zero_one_g_thm, empty_finite_thm]);
(* *** Goal "2" *** *)
a(ALL_FC_T asm_rewrite_tac[supp_times_s_thm]);
val €times_s_finitary_thm› = pop_thm(); (* "times_s_finitary_thm" *);

=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu v∑
	Supp u ç Finite
±	Supp u ç Finite
¥	Supp (u _*âG v) Ä {K | ∂I J∑ I ç Supp u ± J ç Supp v ± K = I £ J}
Æ);
a(REPEAT strip_tac THEN rewrite_tac[times_g_def]);
a(conv_tac(LEFT_C(once_rewrite_conv[supp_def])));
a(PC_T1 "sets_ext" once_rewrite_tac[]
	THEN contr_tac);
a(swap_nth_asm_concl_tac 2 THEN rewrite_tac[]);
a(bc_thm_tac ind_sum_0_bc_thm);
a(REPEAT strip_tac THEN1 bc_thm_tac times_g_finite_thm
	THEN1 REPEAT strip_tac);
a(i_contr_tac THEN asm_prove_tac[]);
val €supp_times_g_thm› = pop_thm(); (* "supp_times_g_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu v∑
	Supp u ç Finite ± Supp u Ä Finite
±	Supp v ç Finite ± Supp v Ä Finite
¥	Supp (u _*âG v) ç Finite 
Æ);
a(REPEAT strip_tac THEN bc_thm_tac Ä_finite_thm);
a(∂_tac¨{K | ∂I J∑ I ç Supp u ± J ç Supp v ± K = I £ J}Æ
	THEN1 ALL_FC_T rewrite_tac[supp_times_g_thm]);
a(lemma_tac¨{K | ∂I J∑ I ç Supp u ± J ç Supp v ± K = I £ J} ç Finite
	± #{K | ∂I J∑ I ç Supp u ± J ç Supp v ± K = I £ J} º #(Supp u ∏ Supp v)Æ);
a(bc_thm_tac surjection_finite_size_thm
	THEN ALL_FC_T rewrite_tac[∏_finite_size_thm]);
a(∂_tac¨Ã(I, J)∑ I £ JÆ THEN rewrite_tac[]);
a(PC_T1 "sets_ext1" once_rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨(I, J)Æ THEN asm_rewrite_tac[∏_def]);
val €supp_times_g_finite_thm› = pop_thm(); (* "supp_times_g_finite_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu v∑
	Supp u ç Finite ± Supp u Ä Finite
±	Supp v ç Finite ± Supp v Ä Finite
¥	Supp (u _*âG v) ç Finite ± Supp (u _*âG v) Ä Finite
Æ);
a(REPEAT strip_tac THEN1 ALL_FC_T rewrite_tac[supp_times_g_finite_thm]);
a(bc_thm_tac(pc_rule1 "sets_ext1" prove_rule[]
	¨µa b c∑a Ä b ± b Ä c ¥ a Ä cÆ)
	THEN ∂_tac¨{K | ∂I J∑ I ç Supp u ± J ç Supp v ± K = I £ J}Æ
	THEN ALL_FC_T rewrite_tac[supp_times_g_thm]);
a(PC_T1 "sets_ext1" once_rewrite_tac[] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
a(all_fc_tac[£_finite_thm]);
val €times_g_finitary_thm› = pop_thm(); (* "times_g_finitary_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µu∑
	Supp (_~âG u) = Supp u
Æ);
a(REPEAT strip_tac THEN rewrite_tac[supp_def, minus_g_def]);
a(PC_T1 "sets_ext1" REPEAT strip_tac
	THEN PC_T1"Ø_lin_arith" asm_prove_tac[]);
val €supp_minus_g_thm› = pop_thm(); (* "supp_minus_g_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µI J∑
	—{I} _*âG —{J} = (ÃK∑ SignâG I J * —{I £ J} K)
Æ);
a(REPEAT strip_tac THEN rewrite_tac[times_g_def, supp_—_thm]);
a(cases_tac¨x = I £ JÆ THEN1 all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(LEMMA_T ¨ {(I', J')|I' = I ± J' = J ± I £ J = I' £ J'} = {(I, J)}Æ
	rewrite_thm_tac
	THEN1 (PC_T1 "sets_ext1" once_rewrite_tac[]
		THEN prove_tac[]));
a(rewrite_tac[ind_sum_singleton_thm, —_def]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨ {(I', J')|I' = I ± J' = J ± x = I' £ J'} = {}Æ
	rewrite_thm_tac
	THEN1 (PC_T1 "sets_ext1" once_rewrite_tac[]
		THEN REPEAT strip_tac
		THEN all_var_elim_asm_tac1));
a(asm_rewrite_tac[—_def, ind_sum_def]);
val €—_times_g_—_thm› = pop_thm(); (* "—_times_g_—_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µV∑
	(µa u∑ u ç V ¥ a _*âS u ç V)
±	(µu v∑ u ç V ± v ç V ¥ u _+âG v ç V)
±	(µI a∑ I ç Finite ¥ —{I} ç V)
¥	(µu∑ Supp u ç Finite ± Supp u Ä Finite ¥ u ç V)
Æ);
a(rewrite_tac[plus_g_def, times_s_def] THEN REPEAT strip_tac);
a(LEMMA_T ¨µA v∑A Ä Supp u ± Supp v = A ¥ v ç VÆ
	(fn th => bc_thm_tac th
		THEN ∂_tac¨Supp uÆ THEN rewrite_tac[]));
a(REPEAT strip_tac);
a(lemma_tac¨A ç FiniteÆ
	THEN1 (bc_thm_tac Ä_finite_thm
		THEN ∂_tac ¨Supp uÆ THEN asm_rewrite_tac[]));
a(LIST_DROP_NTH_ASM_T [2, 3] (MAP_EVERY ante_tac));
a(intro_µ_tac(¨vÆ, ¨vÆ));
a(finite_induction_tac¨AÆ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(PC_T1"sets_ext1" rewrite_tac[supp_def]);
a(REPEAT strip_tac
	THEN PC_T1 "predicates" lemma_tac¨v = ÃK∑ÓØ 0Æ
	THEN1 asm_rewrite_tac[]
	THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 4 (ante_tac o µ_elim¨{}:˙ SETÆ));
a(rewrite_tac[empty_finite_thm] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 6 (ante_tac o list_µ_elim[¨ÓØ 0Æ, ¨—{{}:˙ SET}Æ]));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(PC_T1 "predicates" lemma_tac
	¨∂w a∑ v = (Ã K∑ w K + (Ã K∑ a * — {x} K) K)
	± Supp w = AÆ);
(* *** Goal "2.1" *** *)
a(∂_tac¨ÃK∑if K = x then ÓØ 0 else v KÆ THEN ∂_tac¨v xÆ);
a(rewrite_tac[—_def] THEN REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(cases_tac¨x' = xÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[supp_def]);
a(PC_T1 "sets_ext1" once_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.1.2.1" *** *)
a(swap_nth_asm_concl_tac 1);
a(cases_tac¨x' = xÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 3 (ante_tac o µ_elim¨x'Æ));
a(asm_rewrite_tac[]);
a(PC_T1 "sets_ext1" once_rewrite_tac[]);
a(asm_rewrite_tac[]);
(* *** Goal "2.1.2.2" *** *)
a(cases_tac¨x' = xÆ THEN1 all_var_elim_asm_tac1);
a(asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 3 (ante_tac o µ_elim¨x'Æ));
a(asm_rewrite_tac[]);
a(PC_T1 "sets_ext1" once_rewrite_tac[]);
a(asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(PC_T "predicates" all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 9 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(DROP_NTH_ASM_T 4 (ante_tac o µ_elim¨wÆ));
a(asm_rewrite_tac[] THEN STRIP_T bc_thm_tac);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]
	¨µa b c∑a ¿ b Ä c ¥ b Ä cÆ]);
(* *** Goal "2.2.2" *** *)
a(LIST_DROP_NTH_ASM_T [8, 9] bc_tac);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]
	¨µx b c∑{x} ¿ b Ä c ¥ x ç cÆ]);
a(all_fc_tac[pc_rule1 "sets_ext1" prove_rule[]
	¨µx b c∑x ç b ± b Ä c ¥ x ç cÆ]);
val €—_finite_induction_thm› = pop_thm(); (* "—_finite_induction_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µJ∑
	J ç Finite
¥	∂V∑
	(µa u∑ u ç V ¥ a _*âS u ç V)
±	(µu v∑ u ç V ± v ç V ¥ u _+âG v ç V)
±	(µI a∑ ≥I = J ± I ç Finite ¥ —{I} ç V)
±	≥—{J} ç V
Æ);
a(REPEAT strip_tac);
a(∂_tac¨{u | Supp u ç Finite ± Supp u Ä Finite ± u J = ÓØ 0}Æ);
a(rewrite_tac[—_def, prove_rule[]¨µI∑I = J § J = IÆ]);
a(REPEAT strip_tac
	THEN_TRY ALL_FC_T rewrite_tac[times_s_finitary_thm,
		plus_g_finitary_thm,
		—_finite_finitary_thm]
	THEN_TRY asm_rewrite_tac[times_s_def, plus_g_def]);
val €—_finite_independent_thm› = pop_thm(); (* "—_finite_independent_thm" *);
=TEX
%%%%
%%%%
=SML
(*
drop_main_goal();

*)
push_consistency_goal ¨$+âGÆ;
a (strip_asm_tac (pure_rewrite_rule[is_ga_rep_def] (simple_¥_match_mp_rule type_lemmas_thm ga_def)));
a(∂_tac¨(
	(Ãu v∑ abs(rep u _+âG rep v)),
	(Ãu∑ abs(_~âG(rep u))),
	abs _0âG,
	(Ãa u∑ abs(a _*âS rep u)),
	(Ãu v∑ abs(rep u _*âG rep v)),
	abs _1âG,
	(ÃI∑abs(—{I})))Æ
	THEN asm_rewrite_tac[]
	THEN REPEAT ±_tac THEN REPEAT µ_tac);
(* *** Goal "1" *** *)
a(conv_tac(LEFT_C (rewrite_conv[µ_elim¨rep uÆ plus_g_comm_thm])));
a(asm_rewrite_tac[one_times_s_thm]);
a(LEMMA_T¨µx y∑
	rep(abs(rep x _+âG rep y)) = rep x _+âG rep y
±	rep(abs(rep x _*âG rep y)) = rep x _*âG rep yÆ
	rewrite_thm_tac);
(* *** Goal "1.1" *** *)
a(REPEAT µ_tac);
a(TOP_ASM_T(rewrite_thm_tac o conv_rule(ONCE_MAP_C eq_sym_conv)));
a(±_tac THEN_LIST
	[bc_thm_tac plus_g_finitary_thm,
	bc_thm_tac times_g_finitary_thm]
	THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(LEMMA_T ¨
	rep(abs _0âG) = _0âG
±	rep(abs _1âG) = _1âGÆ rewrite_thm_tac);
(* *** Goal "1.2.1" *** *)
a(TOP_ASM_T(rewrite_thm_tac o conv_rule(ONCE_MAP_C eq_sym_conv)));
a(rewrite_tac[zero_one_finitary_thm]);
(* *** Goal "1.2.2" *** *)
a(rewrite_tac[plus_g_0_thm, plus_g_assoc_thm,
	one_g_times_g_thm]);
a(LEMMA_T¨µx∑
	rep(abs(_~âG(rep x))) = _~âG (rep x)Æ
	rewrite_thm_tac);
(* *** Goal "1.2.2.1" *** *)
a(REPEAT µ_tac);
a(TOP_ASM_T(rewrite_thm_tac o conv_rule(ONCE_MAP_C eq_sym_conv)));
a(rewrite_tac[supp_minus_g_thm] THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.2" *** *)
a(asm_rewrite_tac[plus_g_minus_g_thm]);
a(LEMMA_T¨µs x∑
	rep(abs(s _*âS rep x)) = s _*âS rep xÆ
	rewrite_thm_tac);
(* *** Goal "1.2.2.2.1" *** *)
a(REPEAT µ_tac);
a(TOP_ASM_T(rewrite_thm_tac o conv_rule(ONCE_MAP_C eq_sym_conv)));
a(bc_thm_tac times_s_finitary_thm
	THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.2.2" *** *)
a(rewrite_tac[times_s_times_s_thm,
	times_s_plus_g_distrib_thm,
	plus_times_s_distrib_thm, one_g_def]);
a(lemma_tac¨
	(Supp (rep u) ç Finite ± Supp (rep u) Ä Finite)
±	(Supp (rep v) ç Finite ± Supp (rep v) Ä Finite)
±	(Supp (rep w) ç Finite ± Supp (rep w) Ä Finite)Æ
	THEN1 asm_rewrite_tac[]);
a(PC_T1 "predicates" (ALL_FC_T rewrite_tac)[
	times_g_assoc_thm,
	times_g_plus_g_distrib_thm,
	times_s_times_g_assoc_thm]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(lemma_tac¨I £ J ç FiniteÆ THEN1 all_fc_tac[£_finite_thm]);
a(LEMMA_T¨Supp(—{I}) ç Finite ± Supp(—{I}) Ä FiniteÆ
	ante_tac
	THEN1 (bc_thm_tac —_finite_finitary_thm
		THEN REPEAT strip_tac));
a(LEMMA_T¨Supp(—{J}) ç Finite ± Supp(—{J}) Ä FiniteÆ
	ante_tac
	THEN1 (bc_thm_tac —_finite_finitary_thm
		THEN REPEAT strip_tac));
a(LEMMA_T¨Supp(—{I £ J}) ç Finite ± Supp(—{I £ J}) Ä FiniteÆ
	ante_tac
	THEN1 (bc_thm_tac —_finite_finitary_thm
		THEN REPEAT strip_tac));
a(PC_T1 "predicates" asm_rewrite_tac[]);
a(PC_T1 "predicates" REPEAT strip_tac);
a(PC_T1 "predicates" asm_rewrite_tac[times_s_def, —_times_g_—_thm]);
(* *** Goal "3" *** *)
a(REPEAT strip_tac);
a(LEMMA_T¨u = abs(rep u)Æ once_rewrite_thm_tac
	THEN1 asm_rewrite_tac[]);
a(lemma_tac¨Supp(rep u) ç Finite ± Supp(rep u) Ä Finite ± abs(rep u) ç VÆ);
a(LEMMA_T¨µx∑Supp x ç Finite ± Supp x Ä Finite ¥
	Supp x ç Finite ± Supp x Ä Finite ± abs x ç VÆ
	bc_thm_tac THEN_LIST [id_tac, asm_rewrite_tac[]]);
a(bc_thm_tac(rewrite_rule[]
	(µ_elim¨{x | Supp x ç Finite ± Supp x Ä Finite ± abs x ç V}Æ —_finite_induction_thm)));
a(REPEAT strip_tac
	THEN_TRY ALL_FC_T asm_rewrite_tac[
		—_finite_finitary_thm,
		times_s_finitary_thm,
		plus_g_finitary_thm]);
(* *** Goal "3.1" *** *)
a(DROP_NTH_ASM_T 8 discard_tac);
a(DROP_NTH_ASM_T 5 (ante_tac o list_µ_elim[¨aÆ, ¨abs uÆ]));
a(DROP_NTH_ASM_T 6 (ante_tac o µ_elim¨uÆ));
a(PC_T1 "predicates"asm_rewrite_tac[]);
a(STRIP_T (PC_T1 "predicates" rewrite_thm_tac));
(* *** Goal "3.2" *** *)
a(DROP_NTH_ASM_T 11 discard_tac);
a(DROP_NTH_ASM_T 7 (ante_tac o list_µ_elim[¨abs uÆ, ¨abs vÆ]));
a(GET_NTH_ASM_T 9 (ante_tac o µ_elim¨uÆ));
a(DROP_NTH_ASM_T 9 (ante_tac o µ_elim¨vÆ));
a(PC_T1 "predicates"asm_rewrite_tac[]);
a(STRIP_T (PC_T1 "predicates" rewrite_thm_tac));
a(STRIP_T (PC_T1 "predicates" rewrite_thm_tac));
(* *** Goal "3.3" *** *)
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
(* *** Goal "4" *** *)
a(REPEAT strip_tac THEN all_fc_tac[—_finite_independent_thm]);
a(∂_tac¨{u | rep u ç V}Æ THEN rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
a(LEMMA_T¨Supp(—{I}) ç Finite ± Supp(—{I}) Ä FiniteÆ
	ante_tac
	THEN1 (bc_thm_tac —_finite_finitary_thm
		THEN REPEAT strip_tac));
a(PC_T1 "predicates" asm_rewrite_tac[] THEN STRIP_T asm_rewrite_thm_tac);
(* *** Goal "4.2" *** *)
a(LIST_DROP_NTH_ASM_T [5] all_fc_tac);
a(LEMMA_T¨rep(abs(a _*âS rep u)) = a _*âS rep uÆ
	asm_rewrite_thm_tac);
a(GET_NTH_ASM_T 7 (rewrite_thm_tac o conv_rule(ONCE_MAP_C eq_sym_conv)));
a(bc_thm_tac times_s_finitary_thm THEN asm_rewrite_tac[]);
(* *** Goal "4.3" *** *)
a(LIST_DROP_NTH_ASM_T [5] all_fc_tac);
a(LEMMA_T¨rep(abs(rep u _+âG rep v)) = rep u _+âG rep vÆ
	asm_rewrite_thm_tac);
a(GET_NTH_ASM_T 11 (rewrite_thm_tac o conv_rule(ONCE_MAP_C eq_sym_conv)));
a(bc_thm_tac plus_g_finitary_thm THEN asm_rewrite_tac[]);
(* *** Goal "4.4" *** *)
a(LEMMA_T¨rep(abs(—{J})) = —{J}Æ asm_rewrite_thm_tac);
a(GET_NTH_ASM_T 6 (rewrite_thm_tac o conv_rule(ONCE_MAP_C eq_sym_conv)));
a(bc_thm_tac —_finite_finitary_thm THEN asm_rewrite_tac[]);
val _ = save_consistency_thm ¨$+âGÆ (pop_thm());
val €ga_ops_def› = save_thm("ga_ops_def", get_spec ¨$+âGÆ);
=TEX
%%%%
%%%%

=SML
val €ga_vec_def› = get_spec¨VecâGÆ;
val €á_def› = get_spec¨ÓâGÆ;
=TEX
%%%%
%%%%

=SML
val [	€ga_plus_comm_thm›,
	€ga_plus_assoc_thm›,
	€ga_plus_zero_thm›,
	€ga_plus_minus_thm1› ] =
	map all_µ_intro(
		strip_±_rule(
			all_µ_elim(±_left_elim ga_ops_def))to 3);
val _ = save_thm("ga_plus_assoc_thm", ga_plus_assoc_thm);
val _ = save_thm("ga_plus_comm_thm", ga_plus_comm_thm);
val _ = save_thm("ga_plus_zero_thm", ga_plus_zero_thm);
=TEX
%%%%
%%%%

=SML
val €ga_plus_order_thm› = (
set_goal([], ¨µx y z:GA∑
	y + x = x + y
±	(x + y) + z = x + y + z
±	y + x + z = x + y + z	Æ);
a(REPEAT µ_tac THEN rewrite_tac[ga_plus_assoc_thm]);
a(rewrite_tac[µ_elim¨yÆ ga_plus_comm_thm, ga_plus_assoc_thm]);
save_pop_thm"ga_plus_order_thm"
);
=TEX
%%%%
%%%%

=SML
val €ga_plus_0_thm› = (
set_goal([], ¨µx:GA∑ x + á 0 = x ± á 0 + x = xÆ);
a(rewrite_tac[á_def, ga_plus_zero_thm, µ_elim¨0âGÆ ga_plus_comm_thm]);
save_pop_thm"ga_plus_0_thm"
);
=TEX
%%%%
%%%%

=SML
val €ga_0_1_thm› = (
set_goal([], ¨0âG = á 0 ± 1âG = á 1Æ);
a(pure_once_rewrite_tac[prove_rule [] ¨1 = 0 + 1Æ]);
a(pure_rewrite_tac[á_def]);
a(rewrite_tac[µ_elim¨0âGÆ ga_plus_comm_thm, ga_plus_zero_thm]);
save_pop_thm"ga_0_1_thm"
);
=TEX
%%%%
%%%%

=SML
val €ga_plus_minus_thm› = (
set_goal([], ¨µ x : GA ∑ x + ~ x = á 0 ± ~x + x = á 0Æ);
a(µ_tac);
a(rewrite_tac[µ_elim¨xÆ ga_plus_order_thm]);
a(rewrite_tac[á_def, ga_plus_minus_thm1]);
save_pop_thm"ga_plus_minus_thm"
);
=TEX
%%%%
%%%%

=SML
val €ga_eq_thm› = (
set_goal([], ¨µ x y : GA ∑ x = y § x + ~y = á 0Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[ga_plus_minus_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨(x + ~ y) + y = á 0 + yÆ ante_tac THEN1 asm_rewrite_tac[]);
a(rewrite_tac[ga_plus_assoc_thm, ga_plus_minus_thm, ga_plus_0_thm]);
save_pop_thm"ga_eq_thm"
);
=TEX
%%%%
%%%%

=SML
val €á_plus_homomorphism_thm› = (
set_goal([], ¨µ m n : Ó ∑ á(m + n) = á m + á nÆ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[á_def, ga_0_1_thm, ga_plus_0_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[plus_assoc_thm1, á_def, ga_plus_assoc_thm]);
save_pop_thm"á_plus_homomorphism_thm"
);
=TEX
%%%%
%%%%

=SML
val [	€ga_one_scale_thm›,
	€ga_scale_scale_assoc_thm›,
	€ga_scale_plus_distrib_thm›,
	€ga_plus_scale_distrib_thm›,
	€ga_times_assoc_thm›,
	€ga_times_plus_distrib_thm›,
	€ga_plus_times_distrib_thm›,
	€ga_scale_times_assoc_thm›,
	€ga_one_times_thm›,
	€ga_times_one_thm›,
	€ga_one_mon_thm› ] =
		map (conv_rule (TRY_C (rewrite_conv[ga_0_1_thm])) o all_µ_intro)(
		strip_±_rule(
			all_µ_elim(±_left_elim ga_ops_def)) from 4);
val _ = save_thm("ga_one_scale_thm", ga_one_scale_thm);
val _ = save_thm("ga_scale_scale_assoc_thm", ga_scale_scale_assoc_thm);
val _ = save_thm("ga_scale_plus_distrib_thm", ga_scale_plus_distrib_thm);
val _ = save_thm("ga_plus_scale_distrib_thm", ga_plus_scale_distrib_thm);
val _ = save_thm("ga_times_assoc_thm", ga_times_assoc_thm);
val _ = save_thm("ga_times_plus_distrib_thm", ga_times_plus_distrib_thm);
val _ = save_thm("ga_plus_times_distrib_thm", ga_plus_times_distrib_thm);
val _ = save_thm("ga_scale_times_assoc_thm", ga_scale_times_assoc_thm);
val _ = save_thm("ga_one_times_thm", ga_one_times_thm);
val _ = save_thm("ga_times_one_thm", ga_times_one_thm);
val _ = save_thm("ga_one_mon_thm", ga_one_mon_thm);
=TEX
%%%%
%%%%

=SML
=TEX
%%%%
%%%%

=SML
val [	€ga_mon_times_mon_thm›,
	€ga_mon_span_thm›,
	€ga_mon_indep_thm› ] =
		strip_±_rule(
			±_right_elim ga_ops_def);

val _ = save_thm("ga_mon_span_thm", ga_mon_span_thm);
val _ = save_thm("ga_mon_indep_thm", ga_mon_indep_thm);
val _ = save_thm("ga_mon_times_mon_thm ", ga_mon_times_mon_thm );
=TEX
%%%%
%%%%

=SML
val €ga_minus_clauses› = (
set_goal([], ¨µx y : GA∑
		~ (~ x) = x
	±	x + ~ x = á 0
	±	~ x + x = á 0
	±	~ (x + y) = ~ x + ~ y
	± 	~(á 0) = (á 0)Æ);
a(REPEAT µ_tac);
a(rewrite_tac[ga_plus_minus_thm]);
a(lemma_tac¨µx:GA∑~(~ x) = xÆ);
(* *** Goal "1" *** *)
a(strip_tac THEN once_rewrite_tac[ga_eq_thm]);
a(once_rewrite_tac[ga_plus_comm_thm]);
a(rewrite_tac[ga_plus_minus_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[] THEN strip_tac);
(* *** Goal "2.1" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[ga_eq_thm]);
a(asm_rewrite_tac[µ_elim¨~ yÆga_plus_order_thm]);
a(rewrite_tac[µ_elim¨yÆga_plus_order_thm, ga_plus_minus_thm, ga_plus_0_thm]);
(* *** Goal "2.2" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[ga_eq_thm]);
a(asm_rewrite_tac[ga_plus_0_thm]);
save_pop_thm"ga_minus_clauses"
);
=TEX
%%%%
%%%%

=SML
val €ga_minus_eq_thm› = (
set_goal([], ¨µx y : GA∑~x = ~y § x = yÆ);
a(REPEAT µ_tac);
a(conv_tac(LEFT_C eq_sym_conv));
a(once_rewrite_tac[ga_eq_thm]);
a(rewrite_tac[ga_minus_clauses, µ_elim¨xÆga_plus_order_thm]);
save_pop_thm"ga_minus_eq_thm"
);
=TEX
%%%%
%%%%

=SML
val €ga_0_times_thm› = (
set_goal([], ¨µu∑ á 0 * u = á 0Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨(u + á 0)*u = u*uÆ ante_tac
	THEN1 rewrite_tac[ga_plus_0_thm, ga_minus_clauses]);
a(rewrite_tac[ga_plus_times_distrib_thm]);
a(conv_tac (LEFT_C (once_rewrite_conv[ga_eq_thm])));
a(rewrite_tac[µ_elim¨á 0 * uÆ ga_plus_order_thm,
	ga_minus_clauses, ga_plus_0_thm]);
save_pop_thm"ga_0_times_thm"
);
=TEX
%%%%
%%%%

=SML
val €ga_0_scale_thm› = (
set_goal([], ¨µu∑ ÓØ 0 *âS u = á 0Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨(ÓØ 1 + ÓØ 0) *âS u = uÆ ante_tac
	THEN1 rewrite_tac[ga_one_scale_thm]);
a(pure_rewrite_tac[ga_plus_scale_distrib_thm, ga_one_scale_thm]);
a(conv_tac (LEFT_C (once_rewrite_conv[ga_eq_thm])));
a(rewrite_tac[µ_elim¨ÓØ 0 *âS uÆ ga_plus_order_thm,
	ga_minus_clauses, ga_plus_0_thm]);
save_pop_thm"ga_0_scale_thm"
);
=TEX
%%%%
%%%%

=SML
val €ga_scale_0_thm› = (
set_goal([], ¨µa∑ a *âS á 0 = á 0Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨a *âS (á 0 + á 0) = a *âS á 0Æ ante_tac
	THEN1 rewrite_tac[ga_plus_0_thm]);
a(pure_rewrite_tac[ga_scale_plus_distrib_thm]);
a(conv_tac (LEFT_C (once_rewrite_conv[ga_eq_thm])));
a(rewrite_tac[ga_plus_assoc_thm,
	ga_minus_clauses, ga_plus_0_thm]);
save_pop_thm"ga_scale_0_thm"
);
=TEX
%%%%
%%%%

=SML
val €ga_minus_1_scale_thm› = (
set_goal([], ¨µu∑ ~(ÓØ 1) *âS u = ~uÆ);
a(REPEAT strip_tac);
a(LEMMA_T¨(ÓØ 1 + ~(ÓØ 1)) *âS u + ~u = á 0 + ~uÆ ante_tac
	THEN1 rewrite_tac[ga_0_scale_thm]);
a(pure_rewrite_tac[ga_plus_scale_distrib_thm, ga_one_scale_thm]);
a(rewrite_tac[µ_elim¨~ (ÓØ 1) *âS uÆ ga_plus_order_thm,
	ga_minus_clauses, ga_plus_0_thm]);
save_pop_thm"ga_minus_1_scale_thm"
);
=TEX
%%%%
%%%%

=SML
val €finite_friend_thm› = (
set_goal([], ¨µb∑ b ç Finite ¥ ∂a∑a ç Finite ± ≥a = bÆ);
a(REPEAT strip_tac);
a(cases_tac¨{} = bÆ THEN1 all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(∂_tac¨{x}Æ THEN1 PC_T1 "sets_ext1" rewrite_tac[singleton_finite_thm]
	THEN prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨{}Æ THEN asm_rewrite_tac[empty_finite_thm]);
save_pop_thm"finite_friend_thm"
);
=TEX
%%%%
%%%%

=SML
val €ga_mon_not_0_thm› = (
set_goal([], ¨µI∑ I ç Finite ¥ ≥MonâG I = á 0Æ);
a(REPEAT strip_tac);
a(all_fc_tac[ga_mon_indep_thm]);
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
a(all_fc_tac[finite_friend_thm]);
a(LIST_DROP_NTH_ASM_T [6] all_fc_tac);
a(LIST_DROP_NTH_ASM_T [6] all_fc_tac);
a(LEMMA_T ¨ÓØ 0 *âS MonâG a ç VÆ ante_tac THEN1 asm_rewrite_tac[]);
a(rewrite_tac[ga_0_scale_thm]);
save_pop_thm"ga_mon_not_0_thm"
);
=TEX
%%%%
%%%%

=SML
val €ga_mon_1_thm› = (
set_goal([], ¨MonâG {} = á 1Æ);
a(accept_tac(eq_sym_rule ga_one_mon_thm));
save_pop_thm"ga_mon_1_thm"
);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µi j∑
	VecâG i *âG VecâG j =
	if	i < j
	then	MonâG{i; j}
	else if	j < i
	then	~(ÓØ 1) *âS MonâG{i; j}
	else if	i < Ó˙ 0
	then	~âG (á 1)
	else	 á 1
Æ);
a(REPEAT strip_tac THEN rewrite_tac[ga_vec_def]);
a(lemma_tac¨{i} ç Finite ± {j} ç FiniteÆ
	THEN1 rewrite_tac[singleton_finite_thm]);
a(ALL_FC_T rewrite_tac[ga_mon_times_mon_thm]);
a(cases_tac¨i = jÆ
	THEN1 (all_var_elim_asm_tac1
		THEN rewrite_tac[]));
(* *** Goal "1" *** *)
a(rewrite_tac[sign_singleton_thm, £_clauses,
	ga_mon_1_thm]);
a(PC_T1 "predicates" cases_tac¨j < Ó˙ 0Æ THEN asm_rewrite_tac[ga_one_scale_thm, ga_minus_1_scale_thm]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac[sign_singletons_thm]);
a(LEMMA_T¨{i} £ {j} = {i; j}Æ rewrite_thm_tac
	THEN1 (PC_T1 "sets_ext1" rewrite_tac[£_def]
		THEN REPEAT strip_tac
		THEN contr_tac
		THEN all_var_elim_asm_tac1));
a(PC_T1 "predicates" cases_tac¨i < jÆ THEN asm_rewrite_tac[ga_one_scale_thm]);
a(PC_T1 "predicates" lemma_tac ¨j < iÆ
	THEN1 PC_T1 "˙_lin_arith" asm_prove_tac[]
	THEN asm_rewrite_tac[]);
val €ga_vec_times_vec_thm› = pop_thm(); (* "ga_vec_times_vec_thm" *);
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µX∑
	(µi∑VecâG i ç X)
±	(µu∑ u ç X ¥ ~(ÓØ 1) *âS u ç X)
±	(µu v∑ u ç X ± v ç X ¥ u * v ç X)
¥	(µI∑ I ç Finite ¥ MonâG I ç X)
Æ);
a(REPEAT strip_tac);
a(finite_induction_tac ¨IÆ);
(* *** Goal "1" *** *)
a(LEMMA_T¨VecâG (Ó˙ 0) * VecâG (Ó˙ 0) ç XÆ ante_tac
	THEN1 (POP_ASM_T bc_thm_tac THEN asm_rewrite_tac[]));
a(rewrite_tac[ga_mon_1_thm, ga_vec_times_vec_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T¨VecâG x * MonâG I ç XÆ ante_tac
	THEN1 (DROP_NTH_ASM_T 4 bc_thm_tac THEN asm_rewrite_tac[]));
a(lemma_tac¨{x} ° I = {}Æ THEN1 
	(POP_ASM_T ante_tac THEN PC_T1 "sets_ext1" rewrite_tac[]
		THEN contr_tac THEN all_var_elim_asm_tac));
a(ALL_FC_T rewrite_tac[pc_rule1"sets_ext1" prove_rule[£_def] 
	¨µA∑A ° I = {} ¥ A ¿ I = A £ IÆ]);
a(rewrite_tac[ga_vec_def]);
a(lemma_tac¨{x} ç FiniteÆ THEN1 rewrite_tac[singleton_finite_thm]);
a(ALL_FC_T rewrite_tac[ga_mon_times_mon_thm]);
a(strip_asm_tac(list_µ_elim[¨{x}Æ, ¨IÆ] sign_g_cases_thm)
	THEN asm_rewrite_tac[ga_one_scale_thm]
	THEN REPEAT strip_tac);
a(LEMMA_T¨~(ÓØ 1) *âS (~ (ÓØ 1) *âS MonâG ({x} £ I)) ç XÆ ante_tac
	THEN1 (DROP_NTH_ASM_T 9 bc_thm_tac THEN asm_rewrite_tac[]));
a(rewrite_tac[ga_scale_scale_assoc_thm, ga_one_scale_thm]);
val €ga_mon_subgroup_thm› = save_pop_thm "ga_mon_subgroup_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µA∑
	(µi∑ VecâG i ç A)
±	(µu a∑ u ç A ¥ a *âS u ç A)
±	(µu v∑ u ç A ± v ç A ¥ u +âG v ç A)
±	(µu v∑ u ç A ± v ç A ¥ u *âG v ç A)
¥	(µu∑ u ç A)
Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(bc_thm_tac ga_mon_span_thm THEN asm_rewrite_tac[]);
a(bc_thm_tac ga_mon_subgroup_thm THEN asm_rewrite_tac[]);
val €ga_vec_generators_thm› = save_pop_thm "ga_vec_generators_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µi j∑
	VecâG i * VecâG i = (if i < Ó˙ 0 then ~ (á 1) else á 1)
±	(≥i = j ¥ VecâG i *âG VecâG j = ~(VecâG j * VecâG i))
Æ);
a(REPEAT µ_tac);
a(rewrite_tac[ga_vec_times_vec_thm] THEN REPEAT strip_tac);
a(LEMMA_T¨{j ; i} = {i; j}Æ rewrite_thm_tac
	THEN1 (PC_T1 "sets_ext1" rewrite_tac[]
		THEN REPEAT strip_tac
		THEN all_var_elim_asm_tac1));
a(PC_T1 "predicates" lemma_tac ¨i < j ± ≥j < i ≤ ≥i < j ± j < iÆ
	THEN1 PC_T1 "˙_lin_arith" asm_prove_tac[]
	THEN asm_rewrite_tac[ga_minus_1_scale_thm, ga_minus_clauses]);
val €ga_vec_relations_thm› = save_pop_thm "ga_vec_relations_thm";

=TEX
%%%%
%%%%

=SML
set_goal([], ¨µj∑∂ V∑
	(µi∑ ≥i = j ¥ VecâG i ç V)
±	(µa u∑ u ç V ¥ a *âS u ç V)
±	(µu v∑ u ç V ± v ç V ¥ u +âG v ç V)
±	≥VecâG j ç V
Æ);
a(REPEAT strip_tac THEN rewrite_tac[ga_vec_def]);
a(lemma_tac¨{j} ç FiniteÆ THEN1 rewrite_tac[singleton_finite_thm]);
a(all_fc_tac[ga_mon_indep_thm]);
a(∂_tac¨VÆ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 5 bc_thm_tac THEN rewrite_tac[singleton_finite_thm]);
a(PC_T1 "sets_ext1" rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨iÆ THEN asm_rewrite_tac[]);
=TEX
%%%%
%%%%

=SML
val €ga_vec_indep_thm› = save_pop_thm "ga_vec_indep_thm";
val €ga_subspace_def› = rewrite_rule[ga_0_1_thm]
	(get_spec¨SubspaceâGÆ);
val €ga_span_def› = get_spec¨SpanâGÆ;
val €ga_indep_def› = get_spec¨IndepâGÆ;
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µX∑ SpanâG X ç SubspaceâGÆ);
a(rewrite_tac[ga_span_def, ga_subspace_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LIST_GET_NTH_ASM_T[3, 5] bc_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(LIST_GET_NTH_ASM_T[2, 5] bc_tac THEN asm_rewrite_tac[]);
val €ga_span_subspace_thm› = save_pop_thm "ga_span_subspace_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µX∑ X Ä SpanâG XÆ);
a(PC_T1 "sets_ext1" rewrite_tac[ga_span_def] THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
val €ga_Ä_span_thm› = save_pop_thm "ga_Ä_span_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µV∑ V ç SubspaceâG ± X Ä V ¥ SpanâG X Ä VÆ);
a(rewrite_tac[ga_span_def, ga_subspace_def] THEN REPEAT strip_tac);
a(PC_T1 "sets_ext1" once_rewrite_tac[] THEN REPEAT strip_tac);
a(POP_ASM_T bc_thm_tac THEN asm_rewrite_tac[]);
val €ga_span_Ä_thm› = save_pop_thm "ga_span_Ä_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨
	Universe ç SubspaceâG
±	{á 0} ç SubspaceâGÆ);
a(rewrite_tac[ga_subspace_def] THEN REPEAT strip_tac
	THEN asm_rewrite_tac[ga_plus_0_thm, ga_scale_0_thm]);
val €ga_trivial_subspaces_thm› = save_pop_thm "ga_trivial_subspaces_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µV u∑
	(µ I∑ I ç Finite ¥ MonâG I ç V)
±	(µ a u∑ u ç V ¥ a *âS u ç V)
±	(µ u v∑ u ç V ± v ç V ¥ u + v ç V)
¥	u ç VÆ);
a(REPEAT strip_tac);
a(ante_tac(µ_elim¨VÆga_mon_span_thm) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val €ga_mon_span_bc_thm› = save_pop_thm "ga_mon_span_bc_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨
	SpanâG {u | ∂I∑ I ç Finite ± u = MonâG I} = UniverseÆ);
a(PC_T1 "sets_ext1" rewrite_tac[ga_span_def, ga_subspace_def]
	THEN REPEAT strip_tac);
a(bc_thm_tac ga_mon_span_bc_thm THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 2 bc_thm_tac);
a(∂_tac¨IÆ THEN REPEAT strip_tac);
val €ga_span_mon_thm› = save_pop_thm "ga_span_mon_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µX Y∑ X Ä Y ¥ SpanâG X Ä SpanâG YÆ);
a(PC_T1 "sets_ext1" rewrite_tac[ga_span_def]
	THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 3 bc_thm_tac THEN REPEAT strip_tac
	THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
val €ga_span_mono_thm› = save_pop_thm "ga_span_mono_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µX∑ X ç IndepâG § µx∑x ç X ¥ ≥x ç SpanâG (X \ {x})Æ);
a(rewrite_tac[ga_indep_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(contr_tac THEN lemma_tac¨X \ {x} Ä XÆ
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(all_fc_tac[ga_span_mono_thm]);
a(strip_asm_tac(µ_elim¨X \ {x}Æga_Ä_span_thm));
a(lemma_tac¨X Ä SpanâG (X \ {x})Æ
	THEN1 (PC_T1 "sets_ext1" REPEAT strip_tac));
(* *** Goal "1.1" *** *)
a(cases_tac¨x' = xÆ THEN1 asm_rewrite_tac[]);
a(LEMMA_T¨x' ç X \ {x}Æ asm_tac THEN1 REPEAT strip_tac);
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a(lemma_tac¨SpanâG X Ä SpanâG(X \ {x})Æ
	THEN1 (bc_thm_tac ga_span_Ä_thm
		THEN asm_rewrite_tac[ga_span_subspace_thm]));
a(all_fc_tac[pc_rule1 "sets_ext1"prove_rule[]
	¨µa b∑a Ä b ± b Ä a ¥ a = bÆ]);
a(LIST_DROP_NTH_ASM_T [10] all_fc_tac);
a(lemma_tac¨≥x ç XÆ);
a(POP_ASM_T (once_rewrite_thm_tac o eq_sym_rule)	
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(bc_thm_tac (pc_rule1 "sets_ext1"prove_rule[]
	¨µa b∑a Ä b ± b Ä a ¥ a = bÆ));
a(REPEAT strip_tac THEN PC_T "sets_ext1" contr_tac);
a(lemma_tac¨Y Ä X \ {x}Æ
	THEN1 (PC_T "sets_ext1" contr_tac
		THEN_TRY all_var_elim_asm_tac1
		THEN PC_T1 "sets_ext1" all_asm_fc_tac[]));
a(all_fc_tac[ga_span_mono_thm]);
a(strip_asm_tac(µ_elim¨YÆga_Ä_span_thm));
a(LIST_DROP_NTH_ASM_T [9] all_fc_tac);
a(strip_asm_tac(µ_elim¨XÆga_Ä_span_thm));
a(lemma_tac¨x  ç SpanâG (X \ {x})Æ);
a(bc_thm_tac(pc_rule1 "sets_ext" prove_rule[]
	¨µx a b∑x ç a ± a Ä b ¥ x ç bÆ));
a(∂_tac¨SpanâG YÆ THEN asm_rewrite_tac[]);
a(PC_T1 "sets_ext1" all_asm_fc_tac[]);
val €ga_indep_thm› = save_pop_thm "ga_indep_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨
	{u | ∂I∑ I ç Finite ± u = MonâG I} ç IndepâGÆ);
a(rewrite_tac[ga_span_def, ga_subspace_def,
	ga_indep_thm]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
a(all_fc_tac[ga_mon_indep_thm]);
a(∂_tac¨VÆ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[finite_friend_thm]);
a(LIST_DROP_NTH_ASM_T [6] all_fc_tac);
a(LEMMA_T ¨ÓØ 0 *âS MonâG a ç VÆ ante_tac
	THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(rewrite_tac[ga_0_scale_thm]);
(* *** Goal "2" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
a(cases_tac¨I' = IÆ THEN1 all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [7] all_fc_tac);
val €ga_mon_indep_thm1› = save_pop_thm "ga_mon_indep_thm1";
=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val €sections› = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="wrk076.th.doc", theory="geomalg"};
end;
=TEX
} %\Hide
\end{document}


