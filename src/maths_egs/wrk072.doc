=IGN
********************************************************************************
wrk072.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
$Id: wrk072.doc,v 1.8 2010/03/03 11:35:32 rda Exp rda $
********************************************************************************
% wrk072.doc $Revision: 1.8 $ $RCSfile: wrk072.doc,v $ $Date: 2010/03/03 11:35:32 $
=TEX
\documentclass[12pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}
\def\Hide#1{\relax}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\C{\mathbb{C}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\title{Mathematical Case Studies: the Complex Numbers\thanks{Copyright {\copyright} Lemma 1 Ltd. \number\year; filed in the {\Product} source code repository as {\tt wrk072.doc}; $Revision: 1.8 $.}}
\author{Rob Arthan\\{\tt rda@lemma-one.com}}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}

Definitions of the complex numbers and their arithmetic operators in {\ProductHOL} with proofs of some of their elementary algebraic properties.

\end{abstract}
%\newpage
%\tableofcontents
%\newpage
\section{INTRODUCTION}
This document contains the beginnings of a theory of complex arithmetic in {\ProductHOL}.

After some preliminaries, section~\ref{theory} introduces the field operations and the embedddings of the real numbers and of conjugation (which help to abbreviate the definition of reciprocals).
We then define the derived operations of binary subtraction and division and the embedding of the natural numbers.

A proof script contained in the source of this document but hidden from the printed document gives proofs that the complex numbers form a field and  of some elementary algebraic properties of complex conjugation and of the embeddings of the natural numbers and the real numbers in the complex numbers.
With one exception, the proofs comprise nothing more than simplifying using definitions and standard theorems and then application of the decision procedure for linear arithmetic to prove the resulting problem of real algebra.
The exception is proving that $xx^{-1} = 1$, which requires a few lines of reasoning about real squares.
A listing of the theorems proved is given in appendix~\ref{listing}.


\section{THE THEORY Ö}\label{theory}

\subsection{Preliminaries}
The following commands set up a theory to hold the definitions, theorems, etc.
The theory has the theory of analysis defined in ~\cite{LEMMA1/HOL/WRK066} for its parent, although the elementary algebraic theory only needs one or two little theorems about squares.
=SML
force_delete_theory"Ö" handle Fail _ => ();
open_theory"analysis";
new_theory"Ö";
new_parent"topology_¯";
=TEX
Now set up a convenient proof context:
=SML
set_merge_pcs["basic_hol1", "'ú", "'¯"];
=TEX
\subsection{The Type Ö}
The type Ö comprises pairs of real numbers.
We capture this in a type abbreviation:
=SML
declare_type_abbrev("Ö", [], ”¯ ¸ ¯®);
=TEX
\subsection{Algebraic Operators}
\subsubsection{Addition}

=SML
declare_infix(300, "+‰C");
=TEX

¹HOLCONST
Ü $Û+‰CÝ : Ö ­ Ö ­ Ö
÷üüüüüü
Üµ z w : Ö· z +‰C w = (Fst z + Fst w, Snd z + Snd w)
°

=SML
declare_alias("+", ¬$+‰C®);
=TEX
\subsubsection{Negation}

¹HOLCONST
Ü Û~‰CÝ : Ö ­ Ö
÷üüüüüü
Üµ z : Ö· ~‰C z = (~(Fst z), ~(Snd z))
°
=SML
declare_alias("~", ¬~‰C®);
=TEX

=TEX
\subsubsection{Multiplication}
=SML
declare_infix(310, "*‰C");
=TEX

¹HOLCONST
Ü $Û*‰CÝ : Ö ­ Ö ­ Ö
÷üüüüüü
Üµ z w : Ö·
Ü	z *‰C w = (Fst z * Fst w - Snd z * Snd w, Fst z * Snd w + Snd z * Fst w)
°

=SML
declare_alias("*", ¬$*‰C®);
=TEX
\subsubsection{Embedding of the Real Numbers}


¹HOLCONST
Ü Û¯ÖÝ : ¯ ­ Ö
÷üüüüüü
Üµx· ¯Ö x = (x, î¯ 0)
°
\subsubsection{Conjugation}
=SML
declare_postfix(320, "›_");
=TEX
¹HOLCONST
Ü Û$›_Ý : Ö ­ Ö
÷üüüüüü
Üµ z : Ö· z ›_ = (Fst z, ~(Snd z))
°
\subsubsection{Reciprocal}
=SML
declare_postfix(320, "›-›1›C");
=TEX

¹HOLCONST
Ü $Û›-›1›CÝ : Ö ­ Ö
÷üüüüüü
Üµ z : Ö· z ›-›1›C = z ›_ * ¯Ö(Fst (z * z ›_) ›-›1)
°

=SML
declare_alias("›-›1", ¬$›-›1›C®);
=TEX


\subsubsection{Subtraction}
=SML
declare_infix(300, "-‰C");
=TEX

¹HOLCONST
Ü $Û-‰CÝ : Ö ­ Ö ­ Ö
÷üüüüüü
Üµ z w : Ö· z -‰C w = z + ~w
°



\subsubsection{Division}
=SML
declare_infix(315, "/‰C");
=TEX

¹HOLCONST
Ü $Û/‰CÝ : Ö ­ Ö ­ Ö
÷üüüüüü
Üµ z w : Ö· z /‰C w = z * (w ›-›1)
°


=SML
declare_alias("/", ¬$/‰C®);
=TEX
\subsubsection{Embedding of the Natural Numbers}


¹HOLCONST
Ü ÛîÖÝ : î ­ Ö
÷üüüüüü
Üµm· îÖ m = ¯Ö(î¯ m)
°

\subsubsection{Exponentiation with Natural Number Exponents}

=SML
declare_infix(320, "^‰C");
=TEX
¹HOLCONST
Ü $Û^‰CÝ : Ö ­ î ­ Ö
÷üüüüüü
Ü	(µ z: Ö· z ^‰C 0 = îÖ 1)
Ü ±	(µ z: Ö; m· z ^‰C (m+1) = z * z ^‰C m)
°

=SML
declare_alias("^", ¬$^‰C®);
=TEX
\section{Topology}
The topology of Ö is just the product topology.
¹HOLCONST
Ü $ÛOpen‰CÝ : Ö SET SET
÷üüüüüü
Ü Open‰C = Open‰R ¸‰T Open‰R
°

=TEX
%\twocolumn[\section{INDEX}\label{INDEX}]
%{\printindex}

\bibliographystyle{plain}
\bibliography{fmu}

\appendix
{\HOLindexOff
\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{wrk072.th}}

=TEX
\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
=TEX
Set context for proofs in case of future expansion.
=SML
open_theory"Ö";
set_merge_pcs["basic_hol1", "'ú", "'¯"];
=TEX

%%%%
%%%%
=SML

val ÛÖ_plus_defÝ = get_spec ¬$+‰C®;
val ÛÖ_minus_defÝ = get_spec ¬~‰C®;
val ÛÖ_conj_defÝ = get_spec ¬$›_®;
val ÛÖ_times_defÝ = get_spec ¬$*‰C®;
val ÛÖ_recip_defÝ = get_spec ¬$›-›1›C®;
val ÛÖ_subtract_defÝ = get_spec ¬$-‰C®;
val ÛîÖ_defÝ = get_spec ¬îÖ®;
val Û¯Ö_defÝ = get_spec ¬¯Ö®;
val ÛÖ_î_exp_defÝ = get_spec ¬$^‰C®;
val ÛÖ_ops_defsÝ = [Ö_plus_def, Ö_minus_def, Ö_conj_def, Ö_times_def,
	Ö_recip_def, Ö_subtract_def, îÖ_def, ¯Ö_def, Ö_î_exp_def];
val Ûopen_Ö_defÝ = get_spec ¬Open‰C®;
=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y:Ö· x + y = y + x®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_plus_comm_thmÝ = save_pop_thm "Ö_plus_comm_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y z:Ö· (x + y) + z = x + y + z®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_plus_assoc_thmÝ = save_pop_thm "Ö_plus_assoc_thm";
=SML
set_goal([], ¬µ x:Ö· x + îÖ 0 = x®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_plus_0_thmÝ = save_pop_thm "Ö_plus_0_thm";
=SML
set_goal([], ¬µ x:Ö· x + ~x = îÖ 0®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_plus_minus_thmÝ = save_pop_thm "Ö_plus_minus_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x:Ö·
	x * (x ›_) = ¯Ö(Fst x ^ 2 + Snd x ^ 2)
®);
a(rewrite_tac (¯_î_exp_square_thm::Ö_ops_defs) THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_times_conj_thmÝ = save_pop_thm "Ö_times_conj_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y:Ö· x * y = y * x®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_times_comm_thmÝ = save_pop_thm "Ö_times_comm_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y z:Ö· (x * y) * z = x * y * z®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_times_assoc_thmÝ = save_pop_thm "Ö_times_assoc_thm";
=SML
set_goal([], ¬µ x:Ö· x * îÖ 1 = x®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_times_1_thmÝ = save_pop_thm "Ö_times_1_thm";
=SML
set_goal([], ¬µ x:Ö· ³x = îÖ 0 ´ x * x ›-›1 = îÖ 1®);
a(rewrite_tac [Ö_recip_def, Ö_times_conj_thm]);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) Ö_times_assoc_thm, Ö_times_conj_thm]);
a(rewrite_tac Ö_ops_defs);
a(µ_tac THEN STRIP_T asm_tac);
a(bc_thm_tac (rewrite_rule[](nth 2 (fc_canon(±_left_elim ¯_recip_clauses)))));
a(strip_asm_tac(µ_elim¬Fst x® ¯_0_¼_square_thm));
a(strip_asm_tac(µ_elim¬Snd x® ¯_0_¼_square_thm));
a(swap_nth_asm_concl_tac 3);
a(LEMMA_T ¬Fst x ^ 2 = î¯ 0 ± Snd x ^ 2  = î¯ 0® ante_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[¯_square_eq_0_thm]);
val ÛÖ_times_recip_thmÝ = save_pop_thm "Ö_times_recip_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y z:Ö· x * (y + z) = x * y + x * z®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_times_plus_distrib_thmÝ = save_pop_thm "Ö_times_plus_distrib_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y:Ö· (x + y) ›_  = x ›_ + y ›_®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_conj_plus_homomorphism_thmÝ = save_pop_thm "Ö_conj_plus_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y:Ö· (x * y) ›_  = x ›_ * y ›_®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_conj_times_homomorphism_thmÝ = save_pop_thm "Ö_conj_times_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y:¯· ¯Ö(x + y) = ¯Ö x + ¯Ö y®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û¯Ö_plus_homomorphism_thmÝ = save_pop_thm "¯Ö_plus_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y:¯· ¯Ö(x * y) = ¯Ö x * ¯Ö y®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û¯Ö_times_homomorphism_thmÝ = save_pop_thm "¯Ö_times_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y:î· îÖ(x + y) = îÖ x + îÖ y®);
a(rewrite_tac (î¯_plus_homomorphism_thm::Ö_ops_defs));
val ÛîÖ_plus_homomorphism_thmÝ = save_pop_thm "îÖ_plus_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y:î· îÖ(x * y) = îÖ x * îÖ y®);
a(rewrite_tac (î¯_times_homomorphism_thm::Ö_ops_defs));
val ÛîÖ_times_homomorphism_thmÝ = save_pop_thm "îÖ_times_homomorphism_thm";

=TEX
=IGN
set_goal([], ¬µ x y:ú· úÖ(x + y) = úÖ x + úÖ y®);
a(rewrite_tac (ú¯_plus_homomorphism_thm::Ö_ops_defs));
val ÛúÖ_plus_homomorphism_thmÝ = save_pop_thm "úÖ_plus_homomorphism_thm";

=TEX
=IGN
set_goal([], ¬µ x y:ú· úÖ(x * y) = úÖ x * úÖ y®);
a(rewrite_tac (ú¯_times_homomorphism_thm::Ö_ops_defs));
val ÛúÖ_times_homomorphism_thmÝ = save_pop_thm "úÖ_times_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x m·
	(Cos x, Sin x) ^ m =
	(Cos (î¯ m * x), Sin (î¯ m * x))
®);
a(REPEAT µ_tac THEN induction_tac¬m:î®
	THEN asm_rewrite_tac 
	(sin_def::î¯_plus_homomorphism_thm::
		¯_times_plus_distrib_thm::
		sin_cos_plus_thm::Ö_ops_defs));
a(PC_T1 "¯_lin_arith" prove_tac[]);
val Ûde_moivre_thmÝ = save_pop_thm "de_moivre_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬
	Open‰C  Topology
®);
a(rewrite_tac[open_Ö_def]);
a(bc_thm_tac product_topology_thm THEN rewrite_tac[open_¯_topology_thm]);
val Ûopen_Ö_topology_thmÝ = save_pop_thm "open_Ö_topology_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬
	Universe  Open‰C
®);
a(rewrite_tac[open_Ö_def]);
a(rewrite_tac[product_topology_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(¶_tac¬Universe® THEN ¶_tac¬Universe® THEN rewrite_tac[empty_universe_open_closed_thm]);
a(PC_T1 "sets_ext1" prove_tac[¸_def]);
val Ûuniverse_open_Ö_thmÝ = save_pop_thm "universe_open_Ö_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬
	Space‰T Open‰C = Universe
®);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(bc_thm_tac _space_t_thm);
a(¶_tac¬Universe® THEN PC_T1 "sets_ext1" rewrite_tac[universe_open_Ö_thm]);
val Ûspace_open_Ö_thmÝ = save_pop_thm "space_open_Ö_thm";
=TEX

%%%%
%%%%
=SML

set_goal([], ¬µÔ : 'a SET SET; r i: 'a ­ ¯·
	Ô  Topology
´	(	(Ìx·(r x, i x))  (Ô, Open‰C) Continuous
	¤	r  (Ô, Open‰R) Continuous
	±	i  (Ô, Open‰R) Continuous)
®);
a(REPEAT µ_tac THEN ´_tac);
a(strip_asm_tac open_¯_topology_thm);
a(rewrite_tac[open_Ö_def]);
a(ALL_FC_T1 fc_¤_canon rewrite_tac[product_continuous_¤_thm]);
val Ûcontinuous_open_Ö_thm1Ý = save_pop_thm "continuous_open_Ö_thm1";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µr i: ¯ ­ ¯·
	(Ìx·(r x, i x))  (Open‰R, Open‰C) Continuous ¤	
	(µx· r Cts x) ± (µx· i Cts x)
®);
a(REPEAT µ_tac);
a(strip_asm_tac open_¯_topology_thm);
a(ALL_FC_T1 fc_¤_canon rewrite_tac[continuous_open_Ö_thm1]);
a(rewrite_tac[continuous_cts_at_¯_thm]);
val Ûcontinuous_open_Ö_thm2Ý = save_pop_thm "continuous_open_Ö_thm2";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬
	(Ìx· (Sin x, Cos x))  (Open‰R, Open‰C) Continuous
®);
a(rewrite_tac[continuous_open_Ö_thm2, sin_cos_cts_thm]);
val Ûunit_circle_cover_continuous_thmÝ = save_pop_thm "unit_circle_cover_continuous_thm";

=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val ÛsectionsÝ = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="wrk072.th.doc", theory="Ö"};
end;
=TEX
} %\Hide
\end{document}


