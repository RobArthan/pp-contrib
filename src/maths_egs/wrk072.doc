=IGN
********************************************************************************
wrk072.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% wrk072.doc $Revision: 1.300 $ $RCSfile: imp507.doc,v $ $Date: 2005/09/16 10:26:46 $
=TEX
\documentclass[12pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}
\def\Hide#1{\relax}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\C{\mathbb{C}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\title{Mathematical Case Studies: the Complex Numbers}
\author{Rob Arthan\\{\tt rda@lemma-one.com}}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}

Definitions of the complex numbers and their arithmetic operators in {\ProductHOL} with proofs of some of their elementary algebraic properties.

\end{abstract}
%\newpage
%\tableofcontents
%\newpage
\section{INTRODUCTION}
This document contains the beginnings of a theory of complex arithmetic in {\ProductHOL}.

After some preliminaries, section~\ref{theory} introduces the field operations and the embedddings of the real numbers and of conjugation (which help to abbreviate the definition of reciprocals).
We then define the derived operations of binary subtraction and division and the embeddings of the natural numbers and integers.

A proof script contained in the source of this document but hidden from the printed document gives proofs that the complex numbers form a field and  of some elementary algebraic properties of complex conjugation and of the embeddings of the natural numbers, integers and the real numbers in the complex numbers.
With one exception, the proofs comprise nothing more than simplifying using definitions and standard theorems and then application of the decision procedure for linear arithmetic to prove the resulting problem of real algebra.
The exception is proving that $xx^{-1} = 1$, which requires a few lines of reasoning about real squares.
A listing of the theorems proved is given in appendix~\ref{listing}.


\section{THE THEORY Ö}\label{theory}
\subsection{Preliminaries}
The following commands set up a theory to hold the definitions, theorems, etc.
The theory has the theory of analysis defined in ~\cite{LEMMA1/HOL/WRK066} for its parent, although the elementary algebraic theory only needs one or two little theorems about squares.
=SML
force_delete_theory"Ö" handle Fail _ => ();
open_theory"analysis";
new_theory"Ö";
=TEX
Now set up a convenient proof context:
=SML
set_merge_pcs["basic_hol1", "'ú", "'¯"];
=TEX
\subsection{The Type Ö}
The type Ö comprises pairs of real numbers.
We capture this in a type abbreviation:
=SML
declare_type_abbrev("Ö", [], ”¯ ¸ ¯®);
=TEX
\subsection{Addition}

=SML
declare_infix(300, "+‰C");
=TEX

¹HOLCONST
Ü $Û+‰CÝ : Ö ­ Ö ­ Ö
÷üüüüüü
Üµ z w : Ö· z +‰C w = (Fst z + Fst w, Snd z + Snd w)
°

=SML
declare_alias("+", ¬$+‰C®);
=TEX
\subsection{Negation}

¹HOLCONST
Ü Û~‰CÝ : Ö ­ Ö
÷üüüüüü
Üµ z : Ö· ~‰C z = (~(Fst z), ~(Snd z))
°
=SML
declare_alias("~", ¬~‰C®);
=TEX

=TEX
\subsection{Multiplication}
=SML
declare_infix(310, "*‰C");
=TEX

¹HOLCONST
Ü $Û*‰CÝ : Ö ­ Ö ­ Ö
÷üüüüüü
Üµ z w : Ö·
Ü	z *‰C w = (Fst z * Fst w - Snd z * Snd w, Fst z * Snd w + Snd z * Fst w)
°

=SML
declare_alias("*", ¬$*‰C®);
=TEX
\subsection{Embedding of the Real Numbers}


¹HOLCONST
Ü Û¯ÖÝ : ¯ ­ Ö
÷üüüüüü
Üµx· ¯Ö x = (x, î¯ 0)
°
\subsection{Conjugation}
=SML
declare_postfix(320, "›_");
=TEX
¹HOLCONST
Ü Û$›_Ý : Ö ­ Ö
÷üüüüüü
Üµ z : Ö· z ›_ = (Fst z, ~(Snd z))
°
\subsection{Reciprocal}
=SML
declare_postfix(320, "›-›1›C");
=TEX

¹HOLCONST
Ü $Û›-›1›CÝ : Ö ­ Ö
÷üüüüüü
Üµ z : Ö· z ›-›1›C = z ›_ * ¯Ö(Fst (z * z ›_) ›-›1)
°

=SML
declare_alias("›-›1", ¬$›-›1›C®);
=TEX


\subsection{Subtraction}
=SML
declare_infix(300, "-‰C");
=TEX

¹HOLCONST
Ü $Û-‰CÝ : Ö ­ Ö ­ Ö
÷üüüüüü
Üµ z w : Ö· z -‰C w = z + ~w
°



\subsection{Division}
=SML
declare_infix(315, "/‰C");
=TEX

¹HOLCONST
Ü $Û/‰CÝ : Ö ­ Ö ­ Ö
÷üüüüüü
Üµ z w : Ö· z /‰C w = z * (w ›-›1)
°


=SML
declare_alias("/", ¬$/‰C®);
=TEX
\subsection{Embedding of the Natural Numbers}


¹HOLCONST
Ü ÛîÖÝ : î ­ Ö
÷üüüüüü
Üµm· îÖ m = ¯Ö(î¯ m)
°
\subsection{Embedding of the Integers}


¹HOLCONST
Ü ÛúÖÝ : ú ­ Ö
÷üüüüüü
Üµi· úÖ i = ¯Ö(ú¯ i)
°
=TEX
%\twocolumn[\section{INDEX}\label{INDEX}]
%{\printindex}

\bibliographystyle{plain}
\bibliography{fmu}

\appendix
{\HOLindexOff
\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{wrk072.th}}

=TEX
\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
=TEX
=SML
val ÛÖ_plus_defÝ = get_spec ¬$+‰C®;
val ÛÖ_minus_defÝ = get_spec ¬~‰C®;
val ÛÖ_conj_defÝ = get_spec ¬$›_®;
val ÛÖ_times_defÝ = get_spec ¬$*‰C®;
val ÛÖ_recip_defÝ = get_spec ¬$›-›1›C®;
val ÛÖ_subtract_defÝ = get_spec ¬$-‰C®;
val ÛîÖ_defÝ = get_spec ¬îÖ®;
val ÛúÖ_defÝ = get_spec ¬úÖ®;
val Û¯Ö_defÝ = get_spec ¬¯Ö®;
val ÛÖ_defsÝ = map get_spec(get_consts "-");
=SML
set_goal([], ¬µ x y:Ö· x + y = y + x®);
a(rewrite_tac Ö_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_plus_comm_thmÝ = save_pop_thm "Ö_plus_comm_thm";
=TEX
=SML
set_goal([], ¬µ x y z:Ö· (x + y) + z = x + y + z®);
a(rewrite_tac Ö_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_plus_assoc_thmÝ = save_pop_thm "Ö_plus_assoc_thm";
=SML
set_goal([], ¬µ x:Ö· x + îÖ 0 = x®);
a(rewrite_tac Ö_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_plus_0_thmÝ = save_pop_thm "Ö_plus_0_thm";
=SML
set_goal([], ¬µ x:Ö· x + ~x = îÖ 0®);
a(rewrite_tac Ö_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_plus_minus_thmÝ = save_pop_thm "Ö_plus_minus_thm";
=TEX
=SML
set_goal([], ¬µ x:Ö·
	x * (x ›_) = ¯Ö(Fst x ^ 2 + Snd x ^ 2)
®);
a(rewrite_tac (¯_î_exp_square_thm::Ö_defs) THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_times_conj_thmÝ = save_pop_thm "Ö_times_conj_thm";
=TEX
=SML
set_goal([], ¬µ x y:Ö· x * y = y * x®);
a(rewrite_tac Ö_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_times_comm_thmÝ = save_pop_thm "Ö_times_comm_thm";
=TEX
=SML
set_goal([], ¬µ x y z:Ö· (x * y) * z = x * y * z®);
a(rewrite_tac Ö_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_times_assoc_thmÝ = save_pop_thm "Ö_times_assoc_thm";
=SML
set_goal([], ¬µ x:Ö· x * îÖ 1 = x®);
a(rewrite_tac Ö_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_times_1_thmÝ = save_pop_thm "Ö_times_1_thm";
=SML
set_goal([], ¬µ x:Ö· ³x = îÖ 0 ´ x * x ›-›1 = îÖ 1®);
a(rewrite_tac [Ö_recip_def, Ö_times_conj_thm]);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) Ö_times_assoc_thm, Ö_times_conj_thm]);
a(rewrite_tac Ö_defs);
a(µ_tac THEN STRIP_T asm_tac);
a(bc_thm_tac (rewrite_rule[](nth 2 (fc_canon(±_left_elim ¯_recip_clauses)))));
a(strip_asm_tac(µ_elim¬Fst x® ¯_0_¼_square_thm));
a(strip_asm_tac(µ_elim¬Snd x® ¯_0_¼_square_thm));
a(swap_nth_asm_concl_tac 3);
a(LEMMA_T ¬Fst x ^ 2 = î¯ 0 ± Snd x ^ 2  = î¯ 0® ante_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[¯_square_eq_0_thm]);
val ÛÖ_times_recip_thmÝ = save_pop_thm "Ö_times_recip_thm";
=TEX
=SML
set_goal([], ¬µ x y z:Ö· x * (y + z) = x * y + x * z®);
a(rewrite_tac Ö_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_times_plus_distrib_thmÝ = save_pop_thm "Ö_times_plus_distrib_thm";
=TEX
=SML
set_goal([], ¬µ x y:Ö· (x + y) ›_  = x ›_ + y ›_®);
a(rewrite_tac Ö_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_conj_plus_homomorphism_thmÝ = save_pop_thm "Ö_conj_plus_homomorphism_thm";
=TEX
=SML
set_goal([], ¬µ x y:Ö· (x * y) ›_  = x ›_ * y ›_®);
a(rewrite_tac Ö_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_conj_times_homomorphism_thmÝ = save_pop_thm "Ö_conj_times_homomorphism_thm";
=TEX
=SML
set_goal([], ¬µ x y:¯· ¯Ö(x + y) = ¯Ö x + ¯Ö y®);
a(rewrite_tac Ö_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û¯Ö_plus_homomorphism_thmÝ = save_pop_thm "¯Ö_plus_homomorphism_thm";
=TEX
=SML
set_goal([], ¬µ x y:¯· ¯Ö(x * y) = ¯Ö x * ¯Ö y®);
a(rewrite_tac Ö_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û¯Ö_times_homomorphism_thmÝ = save_pop_thm "¯Ö_times_homomorphism_thm";
=TEX
=SML
set_goal([], ¬µ x y:î· îÖ(x + y) = îÖ x + îÖ y®);
a(rewrite_tac (î¯_plus_homomorphism_thm::Ö_defs));
val ÛîÖ_plus_homomorphism_thmÝ = save_pop_thm "îÖ_plus_homomorphism_thm";
=TEX
=SML
set_goal([], ¬µ x y:î· îÖ(x * y) = îÖ x * îÖ y®);
a(rewrite_tac (î¯_times_homomorphism_thm::Ö_defs));
val ÛîÖ_times_homomorphism_thmÝ = save_pop_thm "îÖ_times_homomorphism_thm";
=TEX
=SML
set_goal([], ¬µ x y:ú· úÖ(x + y) = úÖ x + úÖ y®);
a(rewrite_tac (ú¯_plus_homomorphism_thm::Ö_defs));
val ÛúÖ_plus_homomorphism_thmÝ = save_pop_thm "úÖ_plus_homomorphism_thm";
=TEX
=SML
set_goal([], ¬µ x y:ú· úÖ(x * y) = úÖ x * úÖ y®);
a(rewrite_tac (ú¯_times_homomorphism_thm::Ö_defs));
val ÛúÖ_times_homomorphism_thmÝ = save_pop_thm "úÖ_times_homomorphism_thm";
=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val ÛsectionsÝ = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="wrk072.th.doc", theory="Ö"};
end;
=TEX
} %\Hide
\end{document}


