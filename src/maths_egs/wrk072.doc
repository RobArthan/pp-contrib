=IGN
********************************************************************************
wrk072.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
wrk072.doc,v 1.15 2010/11/14 11:55:24 rda Exp
********************************************************************************
% wrk072.doc 1.15 wrk072.doc,v 2010/11/14 11:55:24
=TEX
\documentclass[12pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}
\def\Hide#1{\relax}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\C{\mathbb{C}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\title{Mathematical Case Studies: the Complex Numbers\thanks{Copyright {\copyright} Lemma 1 Ltd. \number\year; filed in the {\Product} source code repository as {\tt wrk072.doc}; 1.15.}}
\author{Rob Arthan\\{\tt rda@lemma-one.com}}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}

Definitions of the complex numbers and their arithmetic operators in {\ProductHOL} with proofs of some of their elementary algebraic properties.

\end{abstract}
%\newpage
%\tableofcontents
%\newpage
\section{INTRODUCTION}
This document contains the beginnings of a theory of complex arithmetic in {\ProductHOL}.

After some preliminaries, section~\ref{sec:algebra} introduces the field operations and the embedddings of the real numbers and of conjugation (which help to abbreviate the definition of reciprocals).
We then define the derived operations of binary subtraction and division and the embedding of the natural numbers.

In section~\ref{sec:topology} we introduce the topology on the complex numbers and define the exponential mapping of the real line onto the unit circle.

A proof script contained in the source of this document but hidden from the printed document proves several theorems about the complex numbers.
A listing of the theorems proved is given in appendix~\ref{listing}.

We prove that the complex numbers form a field and prove some elementary algebraic properties of complex conjugation and of the embeddings of the natural numbers and the real numbers in the complex numbers.
The proofs of these basic algebraic properties generally comprise little more than simplifying using definitions and standard theorems and then application of the decision procedure for linear arithmetic to prove the resulting problem of real algebra.
One exception is proving that $zz^{-1} = 1$, which requires a few lines of reasoning about real squares.

The proof scripts then go on to develop basic facts about the exponential mapping of the real line onto the unit circle, leading up to the important fact that it is a covering projection.



\section{THE ALGEBRA ÷}\label{sec:algebra}

\subsection{Preliminaries}
The following commands set up a theory to hold the definitions, theorems, etc.
The theory has the theory of analysis defined in ~\cite{LEMMA1/HOL/WRK066} for its parent, although the elementary algebraic theory only needs one or two little theorems about squares.
=SML
force_delete_theory"÷" handle Fail _ => ();
open_theory"analysis";
new_theory"÷";
new_parent"topology_Ø";
=IGN
open_theory"÷";
=TEX
Now set up a convenient proof context:
=SML
set_merge_pcs["basic_hol1", "'˙", "'Ø", "'sets_alg"];
=TEX
\subsection{The Type ÷}
The type ÷ comprises pairs of real numbers.
We capture this in a type abbreviation:
=SML
declare_type_abbrev("÷", [], îØ ∏ ØÆ);
=TEX
We declare aliases for the instances of the projection functions
that give the real and imaginary part of a complex number:
=SML
app declare_alias [
	("Re", ¨Fst : ÷ ≠ ØÆ),
	("Im", ¨Snd : ÷ ≠ ØÆ)];
=TEX

\subsection{Algebraic Operators}
\subsubsection{Addition}

=SML
declare_infix(300, "+âC");
=TEX

πHOLCONST
‹ $€+âC› : ÷ ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z w : ÷∑ z +âC w = (Re z + Re w, Im z + Im w)
∞

=SML
declare_alias("+", ¨$+âCÆ);
=TEX
\subsubsection{Negation}

πHOLCONST
‹ €~âC› : ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z : ÷∑ ~âC z = (~(Re z), ~(Im z))
∞
=SML
declare_alias("~", ¨~âCÆ);
=TEX

=TEX
\subsubsection{Multiplication}
=SML
declare_infix(310, "*âC");
=TEX

πHOLCONST
‹ $€*âC› : ÷ ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z w : ÷∑
‹	z *âC w = (Re z * Re w - Im z * Im w, Re z * Im w + Im z * Re w)
∞

=SML
declare_alias("*", ¨$*âCÆ);
=TEX
\subsubsection{Embedding of the Real Numbers}


πHOLCONST
‹ €Ø÷› : Ø ≠ ÷
˜¸¸¸¸¸¸
‹µx∑ Ø÷ x = (x, ÓØ 0)
∞

πHOLCONST
‹ €Ø…› : Ø ≠ ÷
˜¸¸¸¸¸¸
‹µx∑ Ø… x = (ÓØ 0, x)
∞
\subsubsection{The Imaginary Unit}

πHOLCONST
‹ €IâC› : ÷
˜¸¸¸¸¸¸
‹ IâC =Ø… 1.0
∞
\subsubsection{Conjugation}
=SML
declare_postfix(320, "õ_");
=TEX
πHOLCONST
‹ €$õ_› : ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z : ÷∑ z õ_ = (Re z, ~(Im z))
∞
\subsubsection{Reciprocal}
=SML
declare_postfix(320, "õ-õ1õC");
=TEX

πHOLCONST
‹ $€õ-õ1õC› : ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z : ÷∑ z õ-õ1õC = z õ_ * Ø÷(Re (z * z õ_) õ-õ1)
∞

=SML
declare_alias("õ-õ1", ¨$õ-õ1õCÆ);
=TEX


\subsubsection{Subtraction}
=SML
declare_infix(300, "-âC");
=TEX

πHOLCONST
‹ $€-âC› : ÷ ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z w : ÷∑ z -âC w = z + ~w
∞



\subsubsection{Division}
=SML
declare_infix(315, "/âC");
=TEX

πHOLCONST
‹ $€/âC› : ÷ ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z w : ÷∑ z /âC w = z * (w õ-õ1)
∞


=SML
declare_alias("/", ¨$/âCÆ);
=TEX
\subsubsection{Embedding of the Natural Numbers}


πHOLCONST
‹ €Ó÷› : Ó ≠ ÷
˜¸¸¸¸¸¸
‹µm∑ Ó÷ m = Ø÷(ÓØ m)
∞


πHOLCONST
‹ €Ó…› : Ó ≠ ÷
˜¸¸¸¸¸¸
‹µm∑ Ó… m = (0., ÓØ m)
∞

\subsubsection{Exponentiation with Natural Number Exponents}

=SML
declare_infix(320, "^âC");
=TEX
πHOLCONST
‹ $€^âC› : ÷ ≠ Ó ≠ ÷
˜¸¸¸¸¸¸
‹	(µ z: ÷∑ z ^âC 0 = Ó÷ 1)
‹ ±	(µ z: ÷; m∑ z ^âC (m+1) = z * z ^âC m)
∞

=SML
declare_alias("^", ¨$^âCÆ);
=TEX
\subsection{÷ {\it qua} Real Normed Space}
=SML
declare_infix(310, "*âRC");
=TEX

πHOLCONST
‹ $€*âRC› : Ø ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ x: Ø; v : ÷∑
‹	x *âRC v = Ø÷ x *âC v
∞

πHOLCONST
‹ €AbsâC› : ÷ ≠ Ø
˜¸¸¸¸¸¸
‹µ v : ÷∑
‹	AbsâC v = Sqrt(Re (v * v õ_))
∞

\subsection{Transcendental Functions}
\subsubsection{Exponential}
πHOLCONST
‹ €ExpâC› : ÷ ≠ ÷
˜¸¸¸¸¸¸
‹ µz∑ ExpâC z = Ø÷ (Exp(Re z)) * (Cos (Im z), Sin (Im z))
∞

=SML
declare_alias("Exp", ¨$ExpâCÆ);
=TEX

\section{POLYNOMIALS}\label{sec:polynomials}
As we did for the real numbers in \cite{LEMMA1/HOL/WRK066},
we define the set of polynomial function on the complex
numbers to be the smallest set of functions
that contains all constant functions and the identity function and that
is closed under pointwise addition and multiplication of functions.
πHOLCONST
‹ €PolyFuncâC› : (÷ ≠ ÷) SET
˜¸¸¸¸¸¸
‹ PolyFuncâC = •
‹	{	A
‹	|	(µc∑ (Ãx∑c) ç A)
‹	±	(Ãx∑x) ç A
‹	±	(µf g∑f ç A ± g ç A ¥ (Ãx∑f x + g x) ç A)
‹	±	(µf g∑f ç A ± g ç A ¥ (Ãx∑f x * g x) ç A) }
∞

The following function gives the $n$-partial sum of a series.

πHOLCONST
‹ €SeriesâC› : (Ó ≠ ÷) ≠ (Ó ≠ ÷)
˜¸¸¸¸¸¸
‹	(µs∑ SeriesâC s 0 = Ó÷ 0)
‹ ±	(µs n∑ SeriesâC s (n+1) = SeriesâC s n + s n)
∞

We represent a complex polynomial as a pair $(s, n)$ where $s$ is a sequence of coefficients and $n$ is a bound on the degree.
The following function maps such a pair to the polynomial function it represents.

πHOLCONST
‹ €PolyEvalâC› : (Ó ≠ ÷) ∏ Ó ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹	µs n z∑ PolyEvalâC (s, n) z = SeriesâC (Ãi∑ s i * z^i) (n+1)
∞
We now give the operations on coefficients that correspond to addition of polynomial functions \ldots

πHOLCONST
‹ €PlusCoeffsâC› : ((Ó ≠ ÷) ∏ Ó) ≠ ((Ó ≠ ÷) ∏ Ó) ≠ ((Ó ≠ ÷) ∏ Ó)
˜¸¸¸¸¸¸
‹ µs m t n∑
‹	PlusCoeffsâC (s, m) (t, n) =
‹	((Ãi∑	(if i º m then s i else Ó÷ 0) +
‹		(if i º n then t i else Ó÷ 0)), m+n)
∞

\ldots and to multiplication of one polynomial function by another.

πHOLCONST
‹ €TimesCoeffsâC› : ((Ó ≠ ÷) ∏ Ó) ≠ ((Ó ≠ ÷) ∏ Ó) ≠ ((Ó ≠ ÷) ∏ Ó)
˜¸¸¸¸¸¸
‹ 	(µs t n∑ TimesCoeffsâC (s, 0) (t, n) = ((Ãi∑ s 0 * t i), n))
‹±	(µs m t n∑
‹	TimesCoeffsâC (s, m+1) (t, n) =
‹	PlusCoeffsâC
‹	(TimesCoeffsâC (s, m) (t, n))
‹	((Ãi∑ if i º m then Ó÷ 0 else s (m+1) * t (i-(m+1))), m+n+1))
∞

\section{TOPOLOGICAL ASPECTS}\label{sec:topology}
The standard topology on ÷ is just the product topology:
πHOLCONST
‹ €OpenâC› : ÷ SET SET
˜¸¸¸¸¸¸
‹ OpenâC = OâR ∏âT OâR
∞
As with 
=INLINEFT
OpenâR
=TEX
\ it is convenient to have a short name for the topology:
=SML
declare_alias("OâC", ¨OpenâCÆ);
=TEX
The unit circle:
πHOLCONST
‹ €S1› : ÷ SET
˜¸¸¸¸¸¸
‹ S1 = {z | AbsâC z = 1.}
∞
and the exponential mapping of the real line onto the unit circle:
πHOLCONST
‹ €ExpS1› : Ø ≠ ÷
˜¸¸¸¸¸¸
‹ µt∑ ExpS1 t = (Cos t, Sin t)
∞

=TEX
%\twocolumn[\section{INDEX}\label{INDEX}]
%{\printindex}

\bibliographystyle{fmu}
\bibliography{fmu}

\appendix
{\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{wrk072.th}}


\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

=TEX
\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
\ftlinepenalty=9999
\section{PROOFS}

\subsection{Preamble}

=TEX
Set context for proofs in case of future expansion.
=SML
open_theory"÷";
set_merge_pcs["basic_hol1", "'˙", "'Ø", "'sets_alg"];
=TEX
Give ML bindings for the defining properties:
%%%%
%%%%
=SML

val €÷_plus_def› = get_spec ¨$+âCÆ;
val €÷_minus_def› = get_spec ¨~âCÆ;
val €÷_conj_def› = get_spec ¨$õ_Æ;
val €÷_times_def› = get_spec ¨$*âCÆ;
val €÷_recip_def› = get_spec ¨$õ-õ1õCÆ;
val €÷_subtract_def› = get_spec ¨$-âCÆ;
val €Ó÷_def› = get_spec ¨Ó÷Æ;
val €Ø÷_def› = get_spec ¨Ø÷Æ;
val €Ó…_def› = get_spec ¨Ó…Æ;
val €Ø…_def› = get_spec ¨Ø…Æ;
val €÷_i_def› = get_spec ¨IâCÆ;
val €Ø_÷_times_def› = get_spec ¨$*âRCÆ;
val €÷_Ó_exp_def› = get_spec ¨$^âCÆ;
val €÷_abs_def› = get_spec ¨AbsâCÆ;
val €÷_ops_defs› = [÷_plus_def, ÷_minus_def, ÷_conj_def, ÷_times_def,
	÷_recip_def, ÷_subtract_def, Ó÷_def, Ø÷_def, ÷_Ó_exp_def];
val €÷_poly_func_def› = get_spec ¨PolyFuncâCÆ;
val €÷_series_def› = get_spec ¨SeriesâCÆ;
val €÷_poly_eval_def› = get_spec ¨PolyEvalâCÆ;
val €÷_plus_coeffs_def› = get_spec ¨PlusCoeffsâCÆ;
val €÷_times_coeffs_def› = get_spec ¨TimesCoeffsâCÆ;
val €open_÷_def› = get_spec ¨OâCÆ;
val €s1_def› = get_spec ¨S1Æ;
val €÷_exp_def› = get_spec ¨ExpâCÆ;
val €exp_s1_def› = get_spec ¨ExpS1Æ;
val €exp_s1_def1› = §_t_elim (rewrite_conv[exp_s1_def]
	¨ExpS1 = (Ã x∑ (Cos x, Sin x))Æ);

=TEX

\subsection{Tools}
The following could usefully go elsewhere:


=SML
val €un_»_conv› : CONV =
	simple_eq_match_conv
		(conv_rule(ONCE_MAP_C eq_sym_conv) »_axiom);

=TEX
=TEX
\subsection{Basic Algebraic Properties}

%%%%
%%%%
=SML

val €÷_plus_comm_thm› = save_thm( "÷_plus_comm_thm", (
set_goal([], ¨µ x y:÷∑ x + y = y + xÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_plus_assoc_thm› = save_thm( "÷_plus_assoc_thm", (
set_goal([], ¨µ x y z:÷∑ (x + y) + z = x + y + zÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

val €÷_plus_assoc_thm1› = save_thm ("÷_plus_assoc_thm1",
	conv_rule(ONCE_MAP_C eq_sym_conv) ÷_plus_assoc_thm);
=SML

val €÷_plus_0_thm› = save_thm( "÷_plus_0_thm", (
set_goal([], ¨µ x:÷∑ x + Ó÷ 0 = x ± Ó÷0 + x = xÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=SML

val €÷_plus_minus_thm› = save_thm( "÷_plus_minus_thm", (
set_goal([], ¨µ x:÷∑ x + ~x = Ó÷ 0 ± ~x + x = Ó÷ 0Æ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_times_conj_thm› = save_thm( "÷_times_conj_thm", (
set_goal([], ¨µ x:÷∑
	x * (x õ_) = Ø÷(Re x ^ 2 + Im x ^ 2)
Æ);
a(rewrite_tac (Ø_Ó_exp_square_thm::÷_ops_defs) THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_times_comm_thm› = save_thm( "÷_times_comm_thm", (
set_goal([], ¨µ x y:÷∑ x * y = y * xÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_times_assoc_thm› = save_thm( "÷_times_assoc_thm", (
set_goal([], ¨µ x y z:÷∑ (x * y) * z = x * y * zÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

val €÷_times_assoc_thm1› = save_thm ("÷_times_assoc_thm1",
	conv_rule(ONCE_MAP_C eq_sym_conv) ÷_times_assoc_thm);

=SML

val €÷_times_1_thm› = save_thm( "÷_times_1_thm", (
set_goal([], ¨µ x:÷∑ x * Ó÷ 1 = x ± Ó÷ 1 * x = xÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));



=SML

val €÷_times_recip_thm› = save_thm( "÷_times_recip_thm", (
set_goal([], ¨µ x:÷∑ ≥x = Ó÷ 0 ¥ x * x õ-õ1 = Ó÷ 1Æ);
a(rewrite_tac [÷_recip_def, ÷_times_conj_thm]);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) ÷_times_assoc_thm, ÷_times_conj_thm]);
a(rewrite_tac ÷_ops_defs);
a(µ_tac THEN STRIP_T asm_tac);
a(bc_thm_tac (rewrite_rule[](nth 2 (fc_canon(±_left_elim Ø_recip_clauses)))));
a(strip_asm_tac(µ_elim¨Re xÆ Ø_0_º_square_thm));
a(strip_asm_tac(µ_elim¨Im xÆ Ø_0_º_square_thm));
a(swap_nth_asm_concl_tac 3);
a(LEMMA_T ¨Re x ^ 2 = ÓØ 0 ± Im x ^ 2  = ÓØ 0Æ ante_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[Ø_square_eq_0_thm]);
pop_thm()
));

val €÷_times_recip_thm1› = save_thm ("÷_times_recip_thm1",
	conv_rule(once_rewrite_conv[÷_times_comm_thm]) ÷_times_recip_thm);

=TEX

%%%%
%%%%
=SML

val €÷_times_eq_1_thm› = save_thm( "÷_times_eq_1_thm", (
set_goal([], ¨µ z w:÷∑ ≥z = Ó÷ 0 ± z*w = Ó÷ 1 ¥ w = z õ-õ1Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨z õ-õ1 * z * w = z õ-õ1Æ ante_tac
	THEN1 asm_rewrite_tac[÷_times_1_thm]);
a(rewrite_tac[÷_times_assoc_thm1]);
a(conv_tac(LEFT_C(LEFT_C(once_rewrite_conv[÷_times_comm_thm]))));
a(ALL_FC_T rewrite_tac[÷_times_recip_thm1]);
a(rewrite_tac[÷_times_1_thm]);
pop_thm()
));




=TEX

%%%%
%%%%
=SML

val €÷_times_plus_distrib_thm› = save_thm( "÷_times_plus_distrib_thm", (
set_goal([], ¨µ x y z:÷∑
	x * (y + z) = x * y + x * z
±	(x + y) * z = x * z + y * zÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_conj_plus_homomorphism_thm› = save_thm( "÷_conj_plus_homomorphism_thm", (
set_goal([], ¨µ x y:÷∑ (x + y) õ_  = x õ_ + y õ_Æ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_conj_times_homomorphism_thm› = save_thm( "÷_conj_times_homomorphism_thm", (
set_goal([], ¨µ x y:÷∑ (x * y) õ_  = x õ_ * y õ_Æ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €Ø÷_plus_homomorphism_thm› = save_thm( "Ø÷_plus_homomorphism_thm", (
set_goal([], ¨µ x y:Ø∑ Ø÷(x + y) = Ø÷ x + Ø÷ yÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €Ø÷_times_homomorphism_thm› = save_thm( "Ø÷_times_homomorphism_thm", (
set_goal([], ¨µ x y:Ø∑ Ø÷(x * y) = Ø÷ x * Ø÷ yÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €Ó÷_plus_homomorphism_thm› = save_thm( "Ó÷_plus_homomorphism_thm", (
set_goal([], ¨µ x y:Ó∑ Ó÷(x + y) = Ó÷ x + Ó÷ yÆ);
a(rewrite_tac (ÓØ_plus_homomorphism_thm::÷_ops_defs));
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €Ó÷_one_one_thm› = save_thm( "Ó÷_one_one_thm", (
set_goal([], ¨µ m n:Ó∑ Ó÷ m = Ó÷ n § m = nÆ);
a(rewrite_tac (ÓØ_one_one_thm::÷_ops_defs));
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €Ó÷_times_homomorphism_thm› = save_thm( "Ó÷_times_homomorphism_thm", (
set_goal([], ¨µ x y:Ó∑ Ó÷(x * y) = Ó÷ x * Ó÷ yÆ);
a(rewrite_tac (ÓØ_times_homomorphism_thm::÷_ops_defs));
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_plus_order_thm› = (
set_goal([], ¨µx y z:÷∑
	y + x = x + y
±	(x + y) + z = x + y + z
±	y + x + z = x + y + z	Æ);
a(REPEAT µ_tac THEN rewrite_tac[÷_plus_assoc_thm]);
a(rewrite_tac[µ_elim¨yÆ ÷_plus_comm_thm, ÷_plus_assoc_thm]);
save_pop_thm"÷_plus_order_thm"
);

=TEX

%%%%
%%%%
=SML
val €÷_eq_thm› = (
set_goal([], ¨µ x y : ÷ ∑ x = y § x + ~y = Ó÷ 0Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[÷_plus_minus_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨(x + ~ y) + y = Ó÷ 0 + yÆ ante_tac THEN1 asm_rewrite_tac[]);
a(rewrite_tac[÷_plus_assoc_thm, ÷_plus_minus_thm, ÷_plus_0_thm]);
save_pop_thm"Ø_eq_thm"
);
=TEX

%%%%
%%%%
=SML

val €÷_minus_clauses› = (
set_goal([], ¨µx y : ÷∑
		~ (~ x) = x
	±	x + ~ x = Ó÷ 0
	±	~ x + x = Ó÷ 0
	±	~ (x + y) = ~ x + ~ y
	± 	~(Ó÷ 0) = (Ó÷ 0)Æ);
a(REPEAT µ_tac);
a(rewrite_tac[÷_plus_minus_thm]);
a(lemma_tac¨µx:÷∑~(~ x) = xÆ);
(* *** Goal "1" *** *)
a(strip_tac THEN once_rewrite_tac[÷_eq_thm]);
a(rewrite_tac[÷_plus_minus_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[] THEN strip_tac);
(* *** Goal "2.1" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[÷_eq_thm]);
a(asm_rewrite_tac[µ_elim¨~ yÆ÷_plus_order_thm]);
a(rewrite_tac[µ_elim¨yÆ÷_plus_order_thm, ÷_plus_minus_thm, ÷_plus_0_thm]);
(* *** Goal "2.2" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[÷_eq_thm]);
a(asm_rewrite_tac[÷_plus_0_thm]);
save_pop_thm"÷_minus_clauses"
);

=TEX

%%%%
%%%%
=SML


val €÷_plus_clauses› = (
set_goal([], ¨
	µ x y z:÷∑
	(x + z = y + z § x = y)
±	(z + x = y + z § x = y)
±	(x + z = z + y § x = y)
±	(z + x = z + y § x = y)
±	(x + z = z § x = Ó÷ 0)
±	(z + x = z § x = Ó÷ 0)
±	(z = z + y § y = Ó÷ 0)
±	(z = y + z § y = Ó÷ 0)
±	x + Ó÷ 0 = x
±	Ó÷ 0 + x = x
±	≥ Ó÷ 1 = Ó÷ 0
±	≥ Ó÷ 0 = Ó÷ 1
Æ);
a(REPEAT µ_tac);
a(rewrite_tac[÷_plus_0_thm, Ó÷_one_one_thm, plus_clauses,
	µ_elim¨zÆ ÷_plus_order_thm]);
a(once_rewrite_tac[µ_elim¨z + xÆ ÷_eq_thm]);
a(once_rewrite_tac[µ_elim¨zÆ ÷_eq_thm]);
a(rewrite_tac[÷_minus_clauses, µ_elim¨~ zÆ ÷_plus_order_thm]);
a(rewrite_tac[÷_plus_assoc_thm1, ÷_minus_clauses, ÷_plus_0_thm]);
a(once_rewrite_tac[µ_elim¨xÆ ÷_eq_thm]);
a(rewrite_tac[]);
a(conv_tac(LEFT_C eq_sym_conv));
a(once_rewrite_tac[µ_elim¨Ó÷ 0Æ ÷_eq_thm]);
a(rewrite_tac[÷_minus_clauses, ÷_plus_0_thm]);
save_pop_thm"÷_plus_clauses"
);

=TEX

%%%%
%%%%
=SML

val €÷_times_order_thm› = (
set_goal([], ¨µ x : ÷ ∑ µ y z ∑
		y * x = x * y
	±	(x * y) * z = x * y * z
	±	y * x * z = x * y * zÆ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [list_µ_elim [¨yÆ,¨xÆ] ÷_times_comm_thm]);
(* *** Goal "2" *** *)
a (rewrite_tac [all_µ_elim ÷_times_assoc_thm]);
(* *** Goal "3" *** *)
a (rewrite_tac [list_µ_elim [¨yÆ,¨xÆ,¨zÆ] ÷_times_assoc_thm1]);
a (once_rewrite_tac [list_µ_elim [¨yÆ,¨xÆ] ÷_times_comm_thm]);
a (rewrite_tac [÷_times_assoc_thm]);
save_pop_thm "÷_times_order_thm"
);

=TEX

%%%%
%%%%
=SML

val €÷_times_0_thm1› = (
set_goal([], ¨µx:÷∑ x * Ó÷ 0 = Ó÷ 0Æ);
a(accept_tac(
	all_µ_intro
	(rewrite_rule[÷_plus_clauses, ÷_plus_0_thm](prove_rule[÷_times_plus_distrib_thm]
	¨x*(Ó÷ 0 + Ó÷ 0) = x * Ó÷ 0 + x * Ó÷ 0Æ))));
pop_thm()
);

=TEX

%%%%
%%%%
=SML

val €÷_times_0_thm› = (
set_goal([], ¨µx:÷∑ x * Ó÷ 0 = Ó÷ 0 ± Ó÷ 0 * x = Ó÷ 0Æ);
a(rewrite_tac[µ_elim¨x:÷Æ÷_times_order_thm, ÷_times_0_thm1]);
save_pop_thm "÷_times_0_thm"
);

=TEX
=SML
val €÷_times_eq_0_thm› = save_thm( "÷_times_eq_0_thm", (
set_goal([], ¨
	µx y:÷∑ x*y = Ó÷ 0 ¥ x = Ó÷ 0 ≤ y = Ó÷ 0
Æ);
a(contr_tac THEN all_fc_tac[÷_times_recip_thm1]);
a(LEMMA_T¨y = (x õ-õ1 * x) * yÆ ante_tac THEN1 asm_rewrite_tac[]
	THEN rewrite_tac[÷_times_assoc_thm, ÷_times_1_thm]
	THEN asm_rewrite_tac[÷_times_0_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_times_clauses› = (
set_goal ([], ¨µ x ∑ Ó÷ 0 * x = Ó÷ 0 ± x * Ó÷ 0 = Ó÷ 0 ± x * Ó÷ 1 = x ± Ó÷ 1 * x = xÆ);
a(rewrite_tac[÷_times_0_thm, ÷_times_1_thm]);
save_pop_thm "÷_times_clauses"
);

=TEX

%%%%
%%%%
=SML

val €÷_times_minus_thm1› = (
set_goal([], ¨µx y:÷∑ x * ~ y = ~(x * y)Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨x * ~ y + x * y = Ó÷ 0Æ);
(* *** Goal "1" *** *)
a(LEMMA_T ¨x * ~ y + x * y = x * (~y + y)Æ rewrite_thm_tac
	THEN1 rewrite_tac[÷_times_plus_distrib_thm]);
a(rewrite_tac[÷_minus_clauses, ÷_times_0_thm1]);
(* *** Goal "2" *** *)
a(once_rewrite_tac[÷_eq_thm]);
a(asm_rewrite_tac[÷_minus_clauses]);
pop_thm()
);

=TEX

%%%%
%%%%
=SML

val €÷_times_minus_thm› = (
set_goal([], ¨µx y:÷∑ ~x * y = ~(x * y) ± x * ~ y = ~(x * y) ± ~x * ~y = x * yÆ);
a(REPEAT µ_tac);
a(rewrite_tac[µ_elim¨yÆ÷_times_order_thm]);
a(rewrite_tac[÷_times_minus_thm1]);
a(rewrite_tac[µ_elim¨yÆ÷_times_order_thm]);
a(rewrite_tac[÷_times_minus_thm1, ÷_minus_clauses]);
save_pop_thm"÷_times_minus_thm"
);

=TEX

%%%%
%%%%
=SML

val €÷_Ó_exp_1_thm› = (
set_goal ([], ¨µ n : Ó ∑ Ó÷ 1^n = Ó÷ 1Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ
	THEN asm_rewrite_tac[÷_Ó_exp_def, ÷_times_clauses]);
save_pop_thm "÷_Ó_exp_1_thm"
);

=TEX

Note the following is primarily intended for the case when the exponent is a numeric literal (and will loop unless used with care).

%%%%
%%%%
=SML

val €÷_Ó_exp_rw_thm› = (
set_goal ([], ¨µ z :÷; n : Ó∑ z^n = if n = 0 then Ó÷ 1 else z * z^(n-1)Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ
	THEN asm_rewrite_tac[÷_Ó_exp_def]);
save_pop_thm "÷_Ó_exp_rw_thm"
);

=TEX

%%%%
%%%%
=SML

val €÷_Ó_exp_plus_thm› = (
set_goal ([], ¨µ z :÷; m n : Ó∑ z^(m+n) = z^m * z^nÆ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ
	THEN asm_rewrite_tac[÷_Ó_exp_def, plus_assoc_thm1, ÷_times_clauses]);
a(rewrite_tac[µ_elim¨zÆ ÷_times_order_thm]);
save_pop_thm "÷_Ó_exp_plus_thm"
);

=TEX

%%%%
%%%%
=SML

val €÷_Ó_exp_clauses› = (
set_goal ([], ¨µ z :÷; n : Ó ∑ z^0 = Ó÷ 1 ± z^1 = z ± Ó÷ 1^n = Ó÷ 1Æ);
a(rewrite_tac[÷_Ó_exp_1_thm]);
a(once_rewrite_tac[÷_Ó_exp_rw_thm] THEN rewrite_tac[]);
a(once_rewrite_tac[÷_Ó_exp_rw_thm] THEN rewrite_tac[÷_times_clauses]);
save_pop_thm "÷_Ó_exp_clauses"
);

=TEX
\subsection{A Proof Context}
\section{PROOF CONTEXT}

=TEX

=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt (current_ad_rw_canon())) thms)
);
=TEX
=SML
val _ = delete_pc "'÷" handle Fail _ => ();
val _ = new_pc "'÷";
(*
val _ = set_rw_eqn_cxt
		[	(¨x +âR yÆ, Ø_plus_conv),
			(¨x *âR yÆ, Ø_times_conv),
			(¨x -âR yÆ, Ø_subtract_conv),
			(¨AbsâR xÆ, Ø_abs_conv),
			(¨x /âR yÆ, Ø_over_conv),
			(¨x õ-õ1Æ, Ø_recip_conv),
			(¨x ^âN mÆ, Ø_Ó_exp_conv),
			(¨x ^âZ iÆ, Ø_˙_exp_conv),
			(¨(x:Ø) = yÆ, Ø_eq_conv),
			(¨x ºâR yÆ, Ø_º_conv),
			(¨x <âR yÆ, Ø_less_conv),
			(¨x æâR yÆ, Ø_æ_conv),
			(¨x >âR yÆ, Ø_greater_conv),
			(¨m /âN mÆ, Ø_frac_norm_conv),
			(¨Float x p (Ó˙ 0)Æ, float_conv),
			(¨MaxâR [x]Æ, Ø_max_conv),
			(¨MaxâR (Cons x (Cons y z))Æ, Ø_max_conv),
			(¨MinâR [x]Æ, Ø_min_conv),
			(¨MinâR (Cons x (Cons y z))Æ, Ø_min_conv)
		] "'÷";
*)
val _ = add_rw_thms [÷_plus_clauses, ÷_minus_clauses, ÷_times_clauses, ÷_Ó_exp_clauses]
	"'÷";
(*
val €pos› = (thms_to_eqn_cxt [Ø_minus_clauses, Ø_º_clauses, Ø_less_clauses]) @
		[	(¨(x:Ø) = yÆ, Ø_eq_conv),
			(¨x æâR yÆ, Ø_æ_conv),
			(¨x >âR yÆ, Ø_greater_conv)];
val €neg› = mapfilter (mk_≥ ** RAND_C) pos;
val €neutral› = [(¨x ºâR yÆ, Ø_º_conv), (¨x <âR yÆ, Ø_less_conv)];
val €strip_eqn_cxt› = neutral @ pos @ neg;
val _ = set_st_eqn_cxt strip_eqn_cxt "'÷";
val _ = set_sc_eqn_cxt strip_eqn_cxt "'÷";
*)

val _ = set_pr_tac basic_prove_tac "'÷";
val _ = set_pr_conv basic_prove_conv "'÷";

(*
val _ = commit_pc "'÷";
*)

val _ = set_merge_pcs["basic_hol1", "'˙", "'Ø", "'sets_alg", "'÷"];

=TEX
\subsection{de Moivre's Theorem}

%%%%
%%%%
=SML

val €de_moivre_thm› = save_thm( "de_moivre_thm", (
set_goal([], ¨µ x m∑
	(Cos x, Sin x) ^ m =
	(Cos (ÓØ m * x), Sin (ÓØ m * x))
Æ);
a(REPEAT µ_tac THEN induction_tac¨m:ÓÆ
	THEN asm_rewrite_tac 
	(sin_def::ÓØ_plus_homomorphism_thm::
		Ø_times_plus_distrib_thm::
		sin_cos_plus_thm::÷_ops_defs));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
\subsection{Polynomials}

The following is useful for evaluaating partial sums of series of specific known length:
%%%%
%%%%
=SML

val €÷_series_rw_thm› = save_thm ("÷_series_rw_thm", (
set_goal([], ¨µs n∑ SeriesâC s n = if n = 0 then Ó÷ 0 else s (n-1) + SeriesâC s (n-1)Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ
	THEN asm_rewrite_tac[÷_series_def]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML
val €÷_poly_eval_rec_thm› = save_thm( "÷_poly_eval_rec_thm", (
set_goal([], ¨
	(µs z∑ PolyEvalâC (s, 0) z = s 0)
±	(µs n z∑ PolyEvalâC (s, (n+1)) z = PolyEvalâC (s, n) z + s(n+1) * z^(n+1))
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[÷_poly_eval_def]);
a(REPEAT (once_rewrite_tac[÷_series_rw_thm] THEN rewrite_tac[]));
(* *** Goal "2" *** *)
a(rewrite_tac[÷_poly_eval_def]);
a(conv_tac (LEFT_C (once_rewrite_conv[÷_series_def])));
a(rewrite_tac[]);
pop_thm()
));


=TEX


%%%%
%%%%
=SML


val €÷_poly_eval_eq_thm1› = save_thm( "÷_poly_eval_eq_thm1", (
set_goal([], ¨µs t m z∑
	(µi∑ i º m ¥ s i = t i)
¥	PolyEvalâC (s, m) z = PolyEvalâC (t, m) z
Æ);
a(REPEAT µ_tac THEN induction_tac¨m:ÓÆ
	THEN asm_rewrite_tac[÷_poly_eval_rec_thm]);
(* *** Goal "1" *** *)
a(STRIP_T bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(STRIP_T (strip_asm_tac o µ_elim¨iÆ)
	THEN i_contr_tac THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(STRIP_T (strip_asm_tac o µ_elim¨m+1Æ) THEN asm_rewrite_tac[]);
pop_thm()
));

=TEX


%%%%
%%%%
=SML


val €÷_poly_eval_eq_thm2› = save_thm( "÷_poly_eval_eq_thm2", (
set_goal([], ¨µs m n z∑
	(µi∑ m < i ¥ s i = Ó÷ 0)
±	m º n
¥	PolyEvalâC (s, m) z = PolyEvalâC (s, n) z
Æ);
a(REPEAT µ_tac THEN induction_tac¨n:ÓÆ
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[÷_poly_eval_rec_thm]);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨m = n + 1Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[÷_poly_eval_rec_thm]);
(* *** Goal "3" *** *)
a(cases_tac¨m < n + 1Æ THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(lemma_tac¨m = n + 1Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 5 ante_tac THEN all_var_elim_asm_tac1);
a(rewrite_tac[÷_poly_eval_rec_thm]);
pop_thm()
));


=TEX


%%%%
%%%%
=SML

val €÷_poly_eval_eq_thm› = save_thm( "÷_poly_eval_eq_thm", (
set_goal([], ¨µs t m n z∑
	(µi∑ i º m ¥ s i = t i)
±	(µi∑ m < i ¥ t i = Ó÷ 0)
±	m º n
¥	PolyEvalâC (s, m) z = PolyEvalâC (t, n) z
Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨PolyEvalâC (t, n) z = PolyEvalâC (t, m) zÆ rewrite_thm_tac
	THEN1 ALL_FC_T rewrite_tac[÷_poly_eval_eq_thm2]);
a(bc_thm_tac ÷_poly_eval_eq_thm1 THEN asm_rewrite_tac[]);
pop_thm()
));


=TEX


%%%%
%%%%
=SML


val €÷_poly_eval_0_thm› = save_thm( "÷_poly_eval_0_thm", (
set_goal([], ¨µn z∑
	PolyEvalâC ((Ãi∑Ó÷ 0), n) z = Ó÷ 0
Æ);
a(REPEAT µ_tac THEN induction_tac¨n:ÓÆ
	THEN asm_rewrite_tac[÷_poly_eval_rec_thm]);
pop_thm()
));


=TEX


%%%%
%%%%
=SML


val €÷_poly_eval_minus_thm› = save_thm( "÷_poly_eval_minus_thm", (
set_goal([], ¨µs n z∑
	PolyEvalâC ((Ãi∑~(s i)), n) z = ~(PolyEvalâC (s, n) z)
Æ);
a(REPEAT µ_tac THEN induction_tac¨n:ÓÆ
	THEN asm_rewrite_tac[÷_poly_eval_rec_thm]);
a(rewrite_tac[÷_times_minus_thm]);
pop_thm()
));


=TEX


%%%%
%%%%
=SML


val €÷_poly_eval_plus_thm› = save_thm( "÷_poly_eval_plus_thm", (
set_goal([], ¨µs t n z∑
	PolyEvalâC ((Ãi∑s i + t i), n) z =
	PolyEvalâC (s, n) z + PolyEvalâC (t, n) z
Æ);
a(REPEAT µ_tac THEN induction_tac¨n:ÓÆ
	THEN asm_rewrite_tac[÷_poly_eval_rec_thm]);
a(rewrite_tac[÷_plus_assoc_thm,
	µ_elim¨PolyEvalâC (s, n) zÆ ÷_plus_order_thm,
	÷_times_plus_distrib_thm]);
a(rewrite_tac[µ_elim¨PolyEvalâC (t, n) zÆ ÷_plus_order_thm]);
pop_thm()
));

=TEX


%%%%
Now we will show that any polynomial function can be represented by a finite power series.

Constants \ldots
%%%%
%%%%
=SML

val €÷_const_eval_thm› = save_thm( "÷_const_eval_thm", (
set_goal([], ¨µc∑(Ãx∑c) = PolyEvalâC ((Ãi∑c), 0)Æ);
a(rewrite_tac[] THEN pure_rewrite_tac[÷_poly_eval_def, ÷_series_def]);
a(rewrite_tac ÷_ops_defs);
pop_thm()
));

=TEX
\ldots identity function \ldots
%%%%
%%%%
=SML

val €÷_id_eval_thm› = save_thm( "÷_id_eval_thm", (
set_goal([], ¨(Ãx∑x) = PolyEvalâC ((Ãi∑if i = 1 then Ó÷ 1 else Ó÷ 0), 1)Æ);
a(rewrite_tac[÷_poly_eval_def]);
a(REPEAT (once_rewrite_tac[÷_series_rw_thm] THEN rewrite_tac[]));
pop_thm()
));

=TEX
\ldots sums \ldots
%%%%
%%%%
=SML

=TEX
\ldots sums \ldots
%%%%
%%%%
=SML

val €÷_plus_eval_thm› = save_thm( "÷_plus_eval_thm", (
set_goal([], ¨µs m t n∑
	(Ãx∑ PolyEvalâC (s, m) x + PolyEvalâC (t, n) x) =
	PolyEvalâC (PlusCoeffsâC (s, m) (t, n))Æ);
a(REPEAT strip_tac THEN rewrite_tac[÷_plus_coeffs_def]);
a(EXTEND_PC_T1 "'sho_rw" pure_rewrite_tac[÷_poly_eval_plus_thm]);
a(bc_tac [prove_rule[]¨µa b c d:÷∑a = c ± b = d ¥ a + b = c + dÆ,
	÷_poly_eval_eq_thm]
	THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "1" (duplicates "2") *** *)
a(LEMMA_T ¨≥i º mÆ asm_rewrite_thm_tac THEN PC_T1 "lin_arith" asm_prove_tac[]);
pop_thm()
));
=TEX
which we can usefully reformulate thus
%%%%
%%%%
=SML

val €÷_plus_eval_rw_thm› = save_thm( "÷_plus_eval_rw_thm", (
set_goal([], ¨µsm tn∑
	PolyEvalâC (PlusCoeffsâC sm tn) =
	(Ãx∑ PolyEvalâC sm x + PolyEvalâC tn x) Æ);
a(REPEAT strip_tac);
a(pair_tac¨sm = (s, m)Æ THEN pair_tac¨tn = (t, n)Æ);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) ÷_plus_eval_thm]);
pop_thm()
));

=TEX
\ldots and products, which in this case require a little lemma first:
%%%%
%%%%
=SML

val €÷_const_times_eval_thm› = save_thm( "÷_const_times_eval_thm", (
set_goal([], ¨µc s m∑ PolyEvalâC ((Ãi∑c * s i), m) = (Ãx∑c * PolyEvalâC (s, m) x)Æ);
a(REPEAT strip_tac);
a(induction_tac¨mÆ THEN asm_rewrite_tac[÷_poly_eval_rec_thm]);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val €÷_times_eval_thm› = save_thm( "÷_times_eval_thm", (
set_goal([], ¨µs m t n∑
	(Ãx∑PolyEvalâC (s, m) x * PolyEvalâC (t, n) x) =
	PolyEvalâC (TimesCoeffsâC (s, m) (t, n))Æ);
a(REPEAT strip_tac THEN rewrite_tac[]);
a(induction_tac¨mÆ THEN
	rewrite_tac[÷_times_coeffs_def, ÷_poly_eval_rec_thm, ÷_const_times_eval_thm]
	THEN REPEAT strip_tac);
a(asm_rewrite_tac[÷_times_plus_distrib_thm, ÷_plus_eval_rw_thm]);
a(POP_ASM_T discard_tac THEN induction_tac¨nÆ THEN REPEAT strip_tac THEN
	asm_rewrite_tac[÷_poly_eval_rec_thm]);
(* *** Goal "1" *** *)
a(rewrite_tac[µ_elim¨t 0Æ ÷_times_order_thm]);
a(LEMMA_T ¨Ó÷ 0 = PolyEvalâC ((Ãi∑ Ó÷ 0), m) xÆ
	(fn th => conv_tac(RIGHT_C (once_rewrite_conv[th])))
	THEN1 rewrite_tac[÷_poly_eval_0_thm]);
a(conv_tac eq_sym_conv THEN bc_thm_tac ÷_poly_eval_eq_thm1
	THEN REPEAT strip_tac
	THEN1 asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[÷_times_plus_distrib_thm, ÷_poly_eval_rec_thm,
	pc_rule1 "lin_arith" prove_rule[]
		¨m + (n + 1) + 1 = (m + n + 1) + 1Æ]);
a(asm_rewrite_tac[pc_rule1 "lin_arith" prove_rule[]
		¨(m + n + 1) + 1 = m + n + 2Æ]);
a(rewrite_tac[minus_def, pc_rule1 "lin_arith" prove_rule[]
		¨m + n + 2 = (m+1) + (n+1)Æ]);
a(rewrite_tac[÷_Ó_exp_plus_thm]);
a(rewrite_tac[÷_times_assoc_thm, µ_elim¨t(n+1)Æ ÷_times_order_thm]);
pop_thm()
));

=TEX
which we can usefully reformulate thus
%%%%
%%%%
=SML

val €÷_times_eval_rw_thm› = save_thm( "÷_times_eval_rw_thm", (
set_goal([], ¨µsm tn∑
	PolyEvalâC (TimesCoeffsâC sm tn) =
	(Ãx∑ PolyEvalâC sm x * PolyEvalâC tn x) Æ);
a(REPEAT strip_tac);
a(pair_tac¨sm = (s, m)Æ THEN pair_tac¨tn = (t, n)Æ);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) ÷_times_eval_thm]);
pop_thm()
));


=TEX
Following what we did for the reals,
we now show that the set of all complex polynomial functions is the
range of the polynomial evaluation function. I.e., a function
is polynomial iff. it can be represented by a sequence of coefficients
and a degree.
We prove the two inclusions separately:
%%%%
%%%%
=SML


val €÷_poly_eval_Ä_poly_thm› = (
set_goal([], ¨{f | ∂s n∑ f = PolyEvalâC (s, n)} Ä PolyFuncâCÆ);
a(pure_rewrite_tac[÷_poly_func_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN induction_tac¨nÆ);
(* *** Goal "1" *** *)
a(conv_tac (LEFT_C un_»_conv));
a(pure_rewrite_tac[÷_poly_eval_rec_thm] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(conv_tac (LEFT_C un_»_conv));
a(pure_rewrite_tac[÷_poly_eval_rec_thm]);
a(GET_NTH_ASM_T 3 ho_bc_thm_tac THEN asm_rewrite_tac[»_axiom]);
a(GET_NTH_ASM_T 2 ho_bc_thm_tac THEN asm_rewrite_tac[]);
a(rewrite_tac[÷_Ó_exp_def]
	THEN POP_ASM_T discard_tac THEN induction_tac¨nÆ
	THEN asm_rewrite_tac[÷_Ó_exp_def]);
a(GET_NTH_ASM_T 2 ho_bc_thm_tac THEN asm_rewrite_tac[]);
pop_thm ()
);


=TEX
For the reverse inclusion, and for later use, it is convenient
to prove an induction theorem for polynomials and use it
to derive an induction tactic:
%%%%
%%%%
=SML

val €÷_poly_induction_thm› = save_thm( "÷_poly_induction_thm", (
set_goal([], ¨µp∑
		(µc∑p(Ãx∑c))
	±	(p(Ãx∑x))
	±	(µf g∑p f ± p g ¥  p(Ãx∑f x + g x))
	±	(µf g∑p f ± p g ¥ p(Ãx∑f x * g x))
	¥	(µh∑ h ç PolyFuncâC ¥ p h)
Æ);
a(rewrite_tac[÷_poly_func_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(PC_T1 "sets_ext1" POP_ASM_T (strip_asm_tac o µ_elim ¨{h | p h}Æ)
	THEN1 asm_prove_tac[] THEN all_asm_fc_tac[]);
pop_thm()
));


=TEX
Now the tactic, which expects a term of the form $f \in \mbox{\it PolyFunc}_C$ to
be in the assumptions (where $f$ is the induction variable).
%%%%
%%%%
=SML

fun €÷_poly_induction_tac› (tm : TERM) : TACTIC = (
	if not (is_var tm andalso type_of tm =: î÷ ≠ ÷Æ)
	then term_fail "÷_poly_induction_tac" 999001 [tm]
	else ( fn(asms, conc) =>
	let	val asm = find asms (fn t =>  
			let	val (x, s) = dest_bin_op "" 0 "ç" t;
			in	x =$ tm andalso s =$ ¨PolyFuncâCÆ
			end	handle Fail _ => false)
			handle Fail _ => fail "÷_poly_induction_tac" 999002 [];
	in	if not (is_free_in tm conc)
			then term_fail "÷_poly_induction_tac" 999003 [tm]
		else if any (asms drop (fn t => t =$ asm)) (is_free_in tm)
			then term_fail "÷_poly_induction_tac" 999004 [tm]
		else	(asm_ante_tac asm THEN gen_induction_tac1 ÷_poly_induction_thm) (asms, conc)
	end
	)
);



=TEX


%%%%
%%%%
=SML

val €÷_poly_Ä_poly_eval_thm› = (
set_goal([], ¨PolyFuncâC Ä {f | ∂s n∑ f = PolyEvalâC (s, n)}Æ);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(÷_poly_induction_tac¨xÆ);
(* *** Goal "1" *** *)
a(ante_tac ÷_const_eval_thm THEN prove_tac[]);
(* *** Goal "2" *** *)
a(ante_tac ÷_id_eval_thm THEN prove_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨Fst(PlusCoeffsâC (s, n) (s', n'))Æ THEN ∂_tac¨Snd(PlusCoeffsâC (s, n) (s', n'))Æ
	THEN rewrite_tac[]);
a(asm_rewrite_tac[÷_plus_eval_rw_thm]);
(* *** Goal "4" *** *)
a(∂_tac¨Fst(TimesCoeffsâC (s, n) (s', n'))Æ THEN ∂_tac¨Snd(TimesCoeffsâC (s, n) (s', n'))Æ
	THEN rewrite_tac[]);
a(asm_rewrite_tac[÷_times_eval_rw_thm]);
pop_thm ()
);

=TEX


%%%%
%%%%
=SML

val €÷_poly_func_eq_poly_eval_thm› = save_thm( "÷_poly_func_eq_poly_eval_thm", (
set_goal([], ¨PolyFuncâC = {f | ∂s n∑ f = PolyEvalâC (s, n)}Æ);
a(rewrite_tac[÷_poly_Ä_poly_eval_thm, ÷_poly_eval_Ä_poly_thm,
	pc_rule1 "sets_ext1" prove_rule[] ¨µa b∑a = b § a Ä b ± b Ä aÆ]);
pop_thm()
));

=TEX
\subsection{Topological Properties}

%%%%
%%%%
=SML

val €open_÷_topology_thm› = save_thm( "open_÷_topology_thm", (
set_goal([], ¨
	OâC ç Topology
Æ);
a(rewrite_tac[open_÷_def]);
a(bc_thm_tac product_topology_thm THEN rewrite_tac[open_Ø_topology_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €open_÷_hausdorff_thm› = save_thm( "open_÷_hausdorff_thm", (
set_goal([], ¨
	OâC ç Hausdorff
Æ);
a(rewrite_tac[open_÷_def, open_Ø_∏_open_Ø_hausdorff_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €universe_open_÷_thm› = save_thm( "universe_open_÷_thm", (
set_goal([], ¨
	Universe ç OâC
Æ);
a(rewrite_tac[open_÷_def]);
a(rewrite_tac[product_topology_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(∂_tac¨UniverseÆ THEN ∂_tac¨UniverseÆ THEN rewrite_tac[empty_universe_open_closed_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €space_t_open_÷_thm› = save_thm( "space_t_open_÷_thm", (
set_goal([], ¨
	SpaceâT OâC = Universe
Æ);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(bc_thm_tac ç_space_t_thm);
a(∂_tac¨UniverseÆ THEN PC_T1 "sets_ext1" rewrite_tac[universe_open_÷_thm]);
pop_thm()
));

val €space_t_subspace_open_÷_thm› = save_thm ("space_t_subspace_open_÷_thm",
	rewrite_rule[open_÷_topology_thm, space_t_open_÷_thm]
	(µ_elim¨OâCÆ subspace_topology_space_t_thm));

=TEX

%%%%
%%%%
=SML

val €÷_minus_continuous_thm› = save_thm( "÷_minus_continuous_thm", (
set_goal([], ¨~ ç (OâC, OâC) Continuous Æ);
a(LEMMA_T ¨~ = Ãz∑ (~ z : ÷)Æ once_rewrite_thm_tac
	THEN1 rewrite_tac[uncurry_def]);
a(rewrite_tac[÷_minus_def, open_÷_def]);
a(Ø_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML
val €÷_conj_continuous_thm› = save_thm( "÷_conj_continuous_thm", (
set_goal([], ¨$õ_ ç (OâC, OâC) Continuous Æ);
a(LEMMA_T ¨$õ_ = Ãz∑ z õ_Æ once_rewrite_thm_tac
	THEN1 rewrite_tac[uncurry_def]);
a(rewrite_tac[÷_conj_def, open_÷_def]);
a(Ø_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_plus_continuous_thm› = save_thm( "÷_plus_continuous_thm", (
set_goal([], ¨Uncurry $+ ç (OâC ∏âT OâC, OâC) Continuous Æ);
a(LEMMA_T ¨Uncurry $+ = Ã(w, z)∑ (w + z : ÷)Æ rewrite_thm_tac
	THEN1 rewrite_tac[uncurry_def]);
a(rewrite_tac[÷_plus_def, open_÷_def]);
a(Ø_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_times_continuous_thm› = save_thm( "÷_times_continuous_thm", (
set_goal([], ¨Uncurry $* ç (OâC ∏âT OâC, OâC) Continuous Æ);
a(LEMMA_T ¨Uncurry $* = Ã(w, z)∑ (w * z : ÷)Æ rewrite_thm_tac
	THEN1 rewrite_tac[uncurry_def]);
a(rewrite_tac[÷_times_def, open_÷_def]);
a(Ø_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_Ó_exp_continuous_thm› = save_thm( "÷_Ó_exp_continuous_thm", (
set_goal([], ¨µn∑ (Ãx:÷∑ x^n) ç (OâC, OâC) ContinuousÆ);
a(rewrite_tac[open_÷_def] THEN REPEAT strip_tac);
a(induction_tac¨nÆ THEN rewrite_tac[÷_Ó_exp_def]);
(* *** Goal "1" *** *)
a(Ø_continuity_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[÷_times_def] THEN Ø_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_poly_continuous_thm› = save_thm( "÷_poly_continuous_thm", (
set_goal([], ¨µf∑f ç PolyFuncâC ¥ f ç (OâC, OâC) Continuous Æ);
a(rewrite_tac[open_÷_def] THEN REPEAT strip_tac);
a(÷_poly_induction_tac ¨fÆ);
a(Ø_continuity_tac[]);
(* *** Goal "2" *** *)
a(Ø_continuity_tac[]);
(* *** Goal "3" *** *)
a(Ø_continuity_tac[rewrite_rule[open_÷_def]÷_plus_continuous_thm]);
(* *** Goal "4" *** *)
a(Ø_continuity_tac[rewrite_rule[open_÷_def]÷_times_continuous_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val €÷_series_continuous_thm› = save_thm( "÷_series_continuous_thm", (
set_goal([], ¨µ” s n∑
		” ç Topology
	±	(µi∑ s i ç (”, OâC) Continuous)
	¥	(Ãx∑ SeriesâC (Ãi∑ s i x) n) ç (”, OâC) Continuous Æ);
a(rewrite_tac[open_÷_def] THEN REPEAT strip_tac);
a(induction_tac¨nÆ THEN rewrite_tac[÷_series_def]);
(* *** Goal "1" *** *)
a(Ø_continuity_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[÷_plus_def] THEN Ø_continuity_tac[]
	THEN asm_rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val €exp_s1_continuous_thm› = save_thm( "exp_s1_continuous_thm", (
set_goal([], ¨
	ExpS1 ç (OâR, OâC) Continuous
Æ);
a(rewrite_tac[exp_s1_def1, open_÷_def]);
a(Ø_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_abs_squared_lemma› = save_thm( "÷_abs_squared_lemma", (
set_goal([], ¨µx y∑ Sqrt(x^2 + y^2) = 1. § x^2 + y^2 = 1. Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨0. º x^2 ± 0. º y^2Æ THEN1 rewrite_tac[Ø_0_º_square_thm]);
a(lemma_tac¨0. º x^2 + y^2Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [2, 3] discard_tac THEN all_fc_tac[sqrt_0_º_thm, sqrt_thm]);
a(POP_ASM_T (once_rewrite_thm_tac o eq_sym_rule));
a(asm_rewrite_tac[Ø_Ó_exp_square_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[sqrt_0_1_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML


val €ç_s1_lemma› = save_thm( "ç_s1_lemma", (
set_goal([], ¨µz∑ z ç S1 § Re z^2 + Im z^2 = 1.Æ);
a(MERGE_PCS_T1 ["'pair", "sets_ext1"] rewrite_tac[s1_def, ÷_abs_def, ÷_times_conj_thm, Ø÷_def, ÷_abs_squared_lemma]);
pop_thm()
));


=TEX

%%%%
%%%%
=SML

val €exp_exp_s1_thm› = save_thm( "exp_exp_s1_thm", (
set_goal([], ¨ExpS1 = (Exp : ÷ ≠ ÷) o Ø…Æ);
a(rewrite_tac[÷_times_def, o_def, exp_def, ÷_exp_def, Ø…_def, Ø÷_def, exp_s1_def]);
pop_thm()
));
=TEX

%%%%
%%%%
=SML

val €exp_s1_homomorphism_thm› = save_thm( "exp_s1_homomorphism_thm", (
set_goal([], ¨µx y∑ ExpS1(x + y) = ExpS1 x * ExpS1 yÆ);
a(rewrite_tac[exp_s1_def, ÷_times_def, sin_cos_plus_thm]);
pop_thm()
));

val €exp_s1_homomorphism_thm1› = save_thm ("exp_s1_homomorphism_thm1",
	conv_rule(ONCE_MAP_C eq_sym_conv) exp_s1_homomorphism_thm);


=TEX

%%%%
%%%%
=SML

val €exp_s1_minus_thm› = save_thm( "exp_s1_minus_thm", (
set_goal([], ¨µx∑ ExpS1(~x) = ExpS1 x õ-õ1Æ);
a(REPEAT strip_tac THEN bc_thm_tac ÷_times_eq_1_thm);
a(rewrite_tac[exp_s1_homomorphism_thm1]);
a(rewrite_tac[exp_s1_def, Ó÷_def, Ø÷_def, sin_def]);
a(contr_tac THEN ante_tac (µ_elim¨xÆ cos_squared_plus_sin_squared_thm));
a(asm_rewrite_tac[Ø_Ó_exp_square_thm]);
pop_thm()
));


=TEX

%%%%
%%%%
=SML

val €exp_s1_ç_s1_thm› = save_thm( "exp_s1_ç_s1_thm", (
set_goal([], ¨µx∑ ExpS1 x ç S1Æ);
a(rewrite_tac[exp_s1_def, ç_s1_lemma, cos_squared_plus_sin_squared_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €exp_s1_period_thm› = save_thm( "exp_s1_period_thm", (
set_goal([], ¨µx y∑ ExpS1 x = ExpS1 y § (∂m∑ y = x + ÓØ(2*m) * – ≤ x = y + ÓØ(2*m) * –)Æ);
a(lemma_tac¨
	(µx y∑ x < y ¥
		(ExpS1 x = ExpS1 y § (∂m∑ y = x + ÓØ(2*m) * –)))
±	(µx y m∑ x < y ¥ ≥ x = y + ÓØ (2 * m) * –)
Æ
	THEN1 ±_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[exp_s1_def,
	taut_rule¨µx y p∑ Cos x = y ± p § p ± Cos x = yÆ,
	sin_cos_period_thm]);
(* *** Goal "2" *** *)
a(contr_tac THEN all_var_elim_asm_tac1);
a(lemma_tac ¨0. º ÓØ (2 * m) * –Æ THEN_LIST [
	bc_thm_tac Ø_0_º_0_º_times_thm,
	PC_T1 "Ø_lin_arith" asm_prove_tac[]]);
a(rewrite_tac[ÓØ_º_thm] THEN rewrite_tac[Ø_º_def, –_def]);
(* *** Goal "3" *** *)
a(REPEAT µ_tac);
a(lemma_tac¨x = y ≤ x < y ≤ y < xÆ THEN1 PC_T1 "Ø_lin_arith" prove_tac[]
	THEN1 (all_var_elim_asm_tac THEN rewrite_tac[]));
(* *** Goal "3.1" *** *)
a(∂_tac¨0Æ THEN rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(LIST_DROP_NTH_ASM_T [2, 3] (ALL_FC_T1 fc_§_canon rewrite_tac));
(* *** Goal "3.3" *** *)
a(conv_tac(LEFT_C eq_sym_conv));
a(LIST_DROP_NTH_ASM_T [2, 3] (ALL_FC_T1 fc_§_canon rewrite_tac));
pop_thm()
));

=TEX

%%%%
%%%%
=SML


val €exp_s1_onto_thm› = save_thm( "exp_s1_onto_thm", (
set_goal([], ¨µz∑ z ç S1 ¥ ∂â1x∑ 0. º x ± x < 2. * – ± z = ExpS1 xÆ);
a(rewrite_tac[ç_s1_lemma, exp_s1_def] THEN REPEAT strip_tac);
a(bc_thm_tac sin_cos_onto_unit_circle_thm1 THEN strip_tac);
pop_thm()
));

=TEX

%%%%
%%%%
=SML


val €s1_times_thm› = save_thm( "s1_times_thm", (
set_goal([], ¨µz w∑ z ç S1 ± w ç S1 ¥ z*w ç S1Æ);
a(REPEAT strip_tac THEN all_fc_tac[exp_s1_onto_thm]
	THEN all_var_elim_asm_tac1);
a(rewrite_tac[exp_s1_homomorphism_thm1, exp_s1_ç_s1_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML


val €exp_s1_onto_thm1› = save_thm( "exp_s1_onto_thm1", (
set_goal([], ¨µc z∑
	z ç S1
¥	∂â1x∑ c - – º x ± x < c + – ± z = ExpS1 xÆ);
a(REPEAT strip_tac);
a(all_fc_tac[exp_s1_onto_thm] THEN all_var_elim_asm_tac1);
a(lemma_tac¨ExpS1 (x + – + ~c) ç S1Æ THEN1 rewrite_tac[exp_s1_ç_s1_thm]);
a(strip_asm_tac(µ_elim¨ExpS1 (x + – + ~c)Æ exp_s1_onto_thm));
a(∂â1_tac¨x' + c + ~ –Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(once_rewrite_tac[exp_s1_homomorphism_thm]);
a(DROP_NTH_ASM_T 2 (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[exp_s1_homomorphism_thm1]);
a(conv_tac(ONCE_MAP_C Ø_anf_conv) THEN rewrite_tac[]);
(* *** Goal "4" *** *)
a(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
	¨x'' = x' + c + ~ – § x'' + – - c = x'Æ]);
a(DROP_NTH_ASM_T 4 bc_thm_tac);
a(once_rewrite_tac[exp_s1_homomorphism_thm]);
a(asm_rewrite_tac[]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
pop_thm()
));


=TEX

%%%%
%%%%
=SML

val €exp_s1_onto_thm2› = save_thm( "exp_s1_onto_thm2", (
set_goal([], ¨µc z∑
	z ç S1 ±≥z = ExpS1 (c + –)
¥	∂â1x∑x ç OpenInterval (c - –) (c + –) ± z = ExpS1 xÆ);
a(rewrite_tac[open_interval_def] THEN REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨cÆ, ¨zÆ]exp_s1_onto_thm1));
a(∂â1_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 (strip_asm_tac o rewrite_rule[Ø_º_def])
	THEN all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(swap_nth_asm_concl_tac 3);
a(rewrite_tac[exp_s1_period_thm]);
a(∂_tac¨1Æ THEN rewrite_tac[]);
a(PC_T1"Ø_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 bc_thm_tac THEN asm_rewrite_tac[]);
a(PC_T1"Ø_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €exp_s1_covering_projection_lemma1› = save_thm( "exp_s1_covering_projection_lemma1", (
set_goal([], ¨µc∑
	S1 \ {ExpS1 (c + –)} =
	{z | ∂ x∑ x ç OpenInterval (c - –) (c + –) ± z = ExpS1 x}Æ);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[exp_s1_onto_thm2]);
a(∂_tac¨xÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[exp_s1_ç_s1_thm]);
(* *** Goal "3" *** *)
a(pure_asm_rewrite_tac[] THEN POP_ASM_T discard_tac);
a(POP_ASM_T ante_tac
	THEN rewrite_tac[open_interval_def]
	THEN strip_tac);
a(ante_tac (list_µ_elim[¨cÆ, ¨ExpS1 xÆ] exp_s1_onto_thm1));
a(rewrite_tac[exp_s1_ç_s1_thm] THEN strip_tac);
a(lemma_tac¨c + ~ – º xÆ THEN1 asm_rewrite_tac[Ø_º_def]);
a(lemma_tac¨x = x'Æ THEN1
	(DROP_NTH_ASM_T 2 bc_thm_tac THEN asm_rewrite_tac[])
	THEN all_var_elim_asm_tac1);
a(contr_tac);
a(DROP_NTH_ASM_T 2 (ante_tac o µ_elim¨c + ~ –Æ) THEN asm_rewrite_tac[]);
a(LEMMA_T ¨~ – < – ± ≥c + ~ – = x'Æ rewrite_thm_tac
	THEN1 (strip_asm_tac –_def
		THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(rewrite_tac[exp_s1_period_thm]);
a(∂_tac¨1Æ THEN rewrite_tac[]);
a(strip_asm_tac –_def
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
pop_thm()
));



=TEX

%%%%
%%%%
=SML

val €exp_s1_covering_projection_lemma2› = save_thm( "exp_s1_covering_projection_lemma2", (
set_goal([], ¨µx∑
	ExpS1 ç
	(OpenInterval (x - –) (x + –) ÚâT OâR,
		(S1 \ {ExpS1 (x + –)}) ÚâT OâC) 
			Homeomorphism
Æ);
a(REPEAT strip_tac);
a(rewrite_tac[exp_s1_covering_projection_lemma1]);
a(bc_thm_tac Ä_compact_homeomorphism_thm);
a(∂_tac¨ClosedInterval (x - –) (x + –)Æ);
a(rewrite_tac[open_Ø_topology_thm, open_Ø_hausdorff_thm,
	open_÷_topology_thm, open_÷_hausdorff_thm,
	exp_s1_continuous_thm, compact_compact_Ø_thm,
	closed_interval_compact_thm]);
a(rewrite_tac[open_interval_def, closed_interval_def]);
a(REPEAT strip_tac THEN1
	(PC_T1 "sets_ext1" rewrite_tac[]
	THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[Ø_º_def]));
(* *** Goal "1" *** *)
a(ante_tac(list_µ_elim[¨xÆ, ¨ExpS1 yÆ] exp_s1_onto_thm1)
	THEN rewrite_tac[exp_s1_ç_s1_thm]
	THEN REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨yÆ THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o eq_sym_rule)); 
a(lemma_tac¨x + ~ – º x'Æ THEN1 asm_rewrite_tac[Ø_º_def]);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac THEN all_var_elim_asm_tac);
(* *** Goal "2" *** *)
a(i_contr_tac THEN all_var_elim_asm_tac1);
a(POP_ASM_T (strip_asm_tac o eq_sym_rule));
a(ante_tac(list_µ_elim[¨x' + –Æ, ¨ExpS1 (x + –)Æ] exp_s1_onto_thm1)
	THEN rewrite_tac[exp_s1_ç_s1_thm]
	THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨x + –Æ THEN_TRY PC_T1"Ø_lin_arith" asm_prove_tac[]
	THEN all_var_elim_asm_tac1);
a(spec_nth_asm_tac 2 ¨x'Æ THEN_TRY PC_T1"Ø_lin_arith" asm_prove_tac[]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val €exp_s1_covering_projection_lemma3› = save_thm (
	"exp_s1_covering_projection_lemma3",
 rewrite_rule[open_Ø_topology_thm,
	open_÷_topology_thm,
	exp_s1_continuous_thm,
	exp_s1_ç_s1_thm,
	universe_subspace_topology_thm]
	(list_µ_elim[¨OâRÆ, ¨OâCÆ,
		¨Universe:Ø SETÆ, ¨S1Æ, ¨ExpS1Æ] 
			subspace_continuous_thm));

=TEX

%%%%
%%%%
=SML

val €exp_s1_covering_projection_lemma4› = save_thm( "exp_s1_covering_projection_lemma4", (
set_goal([], ¨µx∑
	ExpS1 x ç S1 \ {ExpS1 (x + –)}
Æ);
a(REPEAT strip_tac THEN1 rewrite_tac[exp_s1_ç_s1_thm]);
a(rewrite_tac[exp_s1_def, sin_cos_–_thm, sin_cos_plus_thm] THEN contr_tac);
a(lemma_tac¨Sin x = 0. ± Cos x = 0.Æ
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ante_tac (µ_elim¨xÆcos_squared_plus_sin_squared_thm));
a(asm_rewrite_tac[Ø_Ó_exp_square_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €exp_s1_covering_projection_lemma5› = save_thm( "exp_s1_covering_projection_lemma5", (
set_goal([], ¨µx y∑
	ExpS1 x = ExpS1 y
±	≥OpenInterval (x + ~ –) (x + –) °
		OpenInterval (y + ~ –) (y + –) = {}
¥	x = y
Æ);
a(PC_T1 "sets_ext1" rewrite_tac[exp_s1_period_thm, open_interval_def] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN strip_asm_tac (µ_elim¨m:ÓÆ Ó_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN all_asm_ante_tac
	THEN rewrite_tac[ÓØ_times_homomorphism_thm,
		ÓØ_plus_homomorphism_thm,
		Ø_times_plus_distrib_thm,
		Ø_times_assoc_thm]
	THEN	(lemma_tac ¨0. º ÓØ i * –Æ THEN_LIST [
		bc_thm_tac Ø_0_º_0_º_times_thm,
		PC_T1 "Ø_lin_arith" asm_prove_tac[]]));
(* *** Goal "1" (duplicates "2") *** *)
a(rewrite_tac[ÓØ_º_thm] THEN rewrite_tac[Ø_º_def, –_def]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val €÷_punctured_set_thm› = save_thm (
	"÷_punctured_set_thm",
	rewrite_rule[
		open_÷_topology_thm,
		open_÷_hausdorff_thm,
		space_t_open_÷_thm]
		(µ_elim¨OâCÆ punctured_hausdorff_thm));

=TEX
%%%%
%%%%
=SML

val €exp_s1_covering_projection_thm› = save_thm( "exp_s1_covering_projection_thm", (
set_goal([], ¨
	ExpS1 ç (OâR, S1 ÚâT OâC) CoveringProjection
Æ);
a(rewrite_tac[covering_projection_def, space_t_subspace_open_÷_thm,
	exp_s1_continuous_thm,
	exp_s1_covering_projection_lemma3]
	THEN REPEAT strip_tac);
a(all_fc_tac[exp_s1_onto_thm] THEN all_var_elim_asm_tac1);
a(∂_tac¨S1 \ {ExpS1(x + –)}Æ);
a(rewrite_tac[exp_s1_covering_projection_lemma4,
	÷_punctured_set_thm]);
a(lemma_tac¨0. < –Æ THEN1 rewrite_tac[–_def]);
a(∂_tac¨{I | ∂y∑ ExpS1 y = ExpS1 x
	± I = OpenInterval (y - –) (y + –)}Æ
	THEN rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN rewrite_tac[open_interval_open_thm]);
(* *** Goal "2" *** *)
a(lemma_tac¨≥ExpS1 x = ExpS1(x' + –)Æ);
(* *** Goal "2.1" *** *)
a(swap_nth_asm_concl_tac 1 THEN POP_ASM_T ante_tac);
a(rewrite_tac[exp_s1_homomorphism_thm]);
a(rewrite_tac[exp_s1_def, sin_cos_–_thm, ÷_times_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac (list_µ_elim[¨x'Æ, ¨ExpS1 xÆ]exp_s1_onto_thm2));
a(∂_tac¨OpenInterval (x'' + ~ –) (x'' + –)Æ
	THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac
	THEN rewrite_tac[open_interval_def]
	THEN PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2.2.2" *** *)
a(∂_tac¨x''Æ THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨ExpS1 y = ExpS1 y'Æ THEN1 asm_rewrite_tac[]
	THEN all_var_elim_asm_tac1);
a(ALL_FC_T rewrite_tac[exp_s1_covering_projection_lemma5]);
(* *** Goal "4" *** *)
a(lemma_tac¨S1 \ {ExpS1 (x + –)} Ä S1Æ
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(ALL_FC_T rewrite_tac[Ä_subspace_topology_thm]);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o eq_sym_rule));
a(all_var_elim_asm_tac1);
a(LEMMA_T ¨ExpS1 (x + –) = ExpS1 (y + –)Æ rewrite_thm_tac
	THEN1 asm_rewrite_tac[exp_s1_homomorphism_thm]);
a(rewrite_tac[rewrite_rule[]exp_s1_covering_projection_lemma2]);
pop_thm()
));

=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val €sections› = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="wrk072.th.doc", theory="÷"};
end;
=TEX
} %\Hide
\end{document}


