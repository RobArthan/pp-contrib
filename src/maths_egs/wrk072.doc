=IGN
********************************************************************************
wrk072.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
$Id: wrk072.doc,v 1.14 2010/11/06 16:30:56 rda Exp rda $
********************************************************************************
% wrk072.doc $Revision: 1.14 $ $RCSfile: wrk072.doc,v $ $Date: 2010/11/06 16:30:56 $
=TEX
\documentclass[12pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}
\def\Hide#1{\relax}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\C{\mathbb{C}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\title{Mathematical Case Studies: the Complex Numbers\thanks{Copyright {\copyright} Lemma 1 Ltd. \number\year; filed in the {\Product} source code repository as {\tt wrk072.doc}; $Revision: 1.14 $.}}
\author{Rob Arthan\\{\tt rda@lemma-one.com}}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}

Definitions of the complex numbers and their arithmetic operators in {\ProductHOL} with proofs of some of their elementary algebraic properties.

\end{abstract}
%\newpage
%\tableofcontents
%\newpage
\section{INTRODUCTION}
This document contains the beginnings of a theory of complex arithmetic in {\ProductHOL}.

After some preliminaries, section~\ref{sec:algebra} introduces the field operations and the embedddings of the real numbers and of conjugation (which help to abbreviate the definition of reciprocals).
We then define the derived operations of binary subtraction and division and the embedding of the natural numbers.

In section~\ref{sec:topology} we introduce the topology on the complex numbers and define the exponential mapping of the real line onto the unit circle.

A proof script contained in the source of this document but hidden from the printed document proves several theorems about the complex numbers.
A listing of the theorems proved is given in appendix~\ref{listing}.

We prove that the complex numbers form a field and prove some elementary algebraic properties of complex conjugation and of the embeddings of the natural numbers and the real numbers in the complex numbers.
The proofs of these basic algebraic properties generally comprise little more than simplifying using definitions and standard theorems and then application of the decision procedure for linear arithmetic to prove the resulting problem of real algebra.
One exception is proving that $zz^{-1} = 1$, which requires a few lines of reasoning about real squares.

The proof scripts then go on to develop basic facts about the exponential mapping of the real line onto the unit circle, leading up to the important fact that it is a covering projection.



\section{THE ALGEBRA ÷}\label{sec:algebra}

\subsection{Preliminaries}
The following commands set up a theory to hold the definitions, theorems, etc.
The theory has the theory of analysis defined in ~\cite{LEMMA1/HOL/WRK066} for its parent, although the elementary algebraic theory only needs one or two little theorems about squares.
=SML
force_delete_theory"÷" handle Fail _ => ();
open_theory"analysis";
new_theory"÷";
new_parent"topology_Ø";
=TEX
Now set up a convenient proof context:
=SML
set_merge_pcs["basic_hol1", "'˙", "'Ø", "'sets_alg"];
=TEX
\subsection{The Type ÷}
The type ÷ comprises pairs of real numbers.
We capture this in a type abbreviation:
=SML
declare_type_abbrev("÷", [], îØ ∏ ØÆ);
=TEX
\subsection{Algebraic Operators}
\subsubsection{Addition}

=SML
declare_infix(300, "+âC");
=TEX

πHOLCONST
‹ $€+âC› : ÷ ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z w : ÷∑ z +âC w = (Fst z + Fst w, Snd z + Snd w)
∞

=SML
declare_alias("+", ¨$+âCÆ);
=TEX
\subsubsection{Negation}

πHOLCONST
‹ €~âC› : ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z : ÷∑ ~âC z = (~(Fst z), ~(Snd z))
∞
=SML
declare_alias("~", ¨~âCÆ);
=TEX

=TEX
\subsubsection{Multiplication}
=SML
declare_infix(310, "*âC");
=TEX

πHOLCONST
‹ $€*âC› : ÷ ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z w : ÷∑
‹	z *âC w = (Fst z * Fst w - Snd z * Snd w, Fst z * Snd w + Snd z * Fst w)
∞

=SML
declare_alias("*", ¨$*âCÆ);
=TEX
\subsubsection{Embedding of the Real Numbers}


πHOLCONST
‹ €Ø÷› : Ø ≠ ÷
˜¸¸¸¸¸¸
‹µx∑ Ø÷ x = (x, ÓØ 0)
∞

πHOLCONST
‹ €Ø…› : Ø ≠ ÷
˜¸¸¸¸¸¸
‹µx∑ Ø… x = (ÓØ 0, x)
∞
\subsubsection{Conjugation}
=SML
declare_postfix(320, "õ_");
=TEX
πHOLCONST
‹ €$õ_› : ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z : ÷∑ z õ_ = (Fst z, ~(Snd z))
∞
\subsubsection{Reciprocal}
=SML
declare_postfix(320, "õ-õ1õC");
=TEX

πHOLCONST
‹ $€õ-õ1õC› : ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z : ÷∑ z õ-õ1õC = z õ_ * Ø÷(Fst (z * z õ_) õ-õ1)
∞

=SML
declare_alias("õ-õ1", ¨$õ-õ1õCÆ);
=TEX


\subsubsection{Subtraction}
=SML
declare_infix(300, "-âC");
=TEX

πHOLCONST
‹ $€-âC› : ÷ ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z w : ÷∑ z -âC w = z + ~w
∞



\subsubsection{Division}
=SML
declare_infix(315, "/âC");
=TEX

πHOLCONST
‹ $€/âC› : ÷ ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z w : ÷∑ z /âC w = z * (w õ-õ1)
∞


=SML
declare_alias("/", ¨$/âCÆ);
=TEX
\subsubsection{Embedding of the Natural Numbers}


πHOLCONST
‹ €Ó÷› : Ó ≠ ÷
˜¸¸¸¸¸¸
‹µm∑ Ó÷ m = Ø÷(ÓØ m)
∞


πHOLCONST
‹ €Ó…› : Ó ≠ ÷
˜¸¸¸¸¸¸
‹µm∑ Ó… m = (0., ÓØ m)
∞

\subsubsection{Exponentiation with Natural Number Exponents}

=SML
declare_infix(320, "^âC");
=TEX
πHOLCONST
‹ $€^âC› : ÷ ≠ Ó ≠ ÷
˜¸¸¸¸¸¸
‹	(µ z: ÷∑ z ^âC 0 = Ó÷ 1)
‹ ±	(µ z: ÷; m∑ z ^âC (m+1) = z * z ^âC m)
∞

=SML
declare_alias("^", ¨$^âCÆ);
=TEX
\subsection{÷ {\it qua} Real Normed Space}
=SML
declare_infix(310, "*âRC");
=TEX

πHOLCONST
‹ $€*âRC› : Ø ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ x: Ø; v : ÷∑
‹	x *âRC v = Ø÷ x *âC v
∞

πHOLCONST
‹ €AbsâC› : ÷ ≠ Ø
˜¸¸¸¸¸¸
‹µ v : ÷∑
‹	AbsâC v = Sqrt(Fst (v * v õ_))
∞

\section{POLYNOMIALS}\label{sec:polynomials}
The polynomial functions comprise the smallest set of functions
that contains all constant functions and the identity function and
is closed under pointwise addition and multiplication of functions.
πHOLCONST
‹ €PolyFuncâC› : (÷ ≠ ÷) SET
˜¸¸¸¸¸¸
‹ PolyFuncâC = •
‹	{	A
‹	|	(µc∑ (Ãx∑c) ç A)
‹	±	(Ãx∑x) ç A
‹	±	(µf g∑f ç A ± g ç A ¥ (Ãx∑f x + g x) ç A)
‹	±	(µf g∑f ç A ± g ç A ¥ (Ãx∑f x * g x) ç A) }
∞

For variety, we will represent complex polynomials as finite power series rather than lists of coefficients.
The following function gives the $n$-partial sum of a series.

πHOLCONST
‹ €SeriesâC› : (Ó ≠ ÷) ≠ (Ó ≠ ÷)
˜¸¸¸¸¸¸
‹	(µs∑ SeriesâC s 0 = Ó÷ 0)
‹ ±	(µs n∑ SeriesâC s (n+1) = SeriesâC s n + s n)
∞

The following function then sums a power series $s$ up to the term of degree $n$:

πHOLCONST
‹ €PowerSeriesâC› : (Ó ≠ ÷) ≠ Ó ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹	µs n z∑ PowerSeriesâC s n z = SeriesâC (Ãi∑ s i * z^i) (n+1)
∞

\section{TOPOLOGICAL ASPECTS}\label{sec:topology}
The topology of ÷ is just the product topology.
πHOLCONST
‹ €OpenâC› : ÷ SET SET
˜¸¸¸¸¸¸
‹ OpenâC = OpenâR ∏âT OpenâR
∞
The unit circle:
πHOLCONST
‹ €S1› : ÷ SET
˜¸¸¸¸¸¸
‹ S1 = {z | AbsâC z = 1.}
∞
and the exponential mapping of the real line onto the unit circle:
πHOLCONST
‹ €ExpS1› : Ø ≠ ÷
˜¸¸¸¸¸¸
‹ µt∑ ExpS1 t = (Cos t, Sin t)
∞

=TEX
%\twocolumn[\section{INDEX}\label{INDEX}]
%{\printindex}

\bibliographystyle{fmu}
\bibliography{fmu}

\appendix
{\HOLindexOff
\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{wrk072.th}}

=TEX
\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
\section{PROOFS}

\subsection{Preamble

=TEX
Set context for proofs in case of future expansion.
=SML
open_theory"÷";
set_merge_pcs["basic_hol1", "'˙", "'Ø", "'sets_alg"];
=TEX
Give ML bindings for the defining properties:
%%%%
%%%%
=SML

val €÷_plus_def› = get_spec ¨$+âCÆ;
val €÷_minus_def› = get_spec ¨~âCÆ;
val €÷_conj_def› = get_spec ¨$õ_Æ;
val €÷_times_def› = get_spec ¨$*âCÆ;
val €÷_recip_def› = get_spec ¨$õ-õ1õCÆ;
val €÷_subtract_def› = get_spec ¨$-âCÆ;
val €Ó÷_def› = get_spec ¨Ó÷Æ;
val €Ø÷_def› = get_spec ¨Ø÷Æ;
val €Ó…_def› = get_spec ¨Ó…Æ;
val €Ø…_def› = get_spec ¨Ø…Æ;
val €Ø_÷_times_def› = get_spec ¨$*âRCÆ;
val €÷_Ó_exp_def› = get_spec ¨$^âCÆ;
val €÷_abs_def› = get_spec ¨AbsâCÆ;
val €÷_ops_defs› = [÷_plus_def, ÷_minus_def, ÷_conj_def, ÷_times_def,
	÷_recip_def, ÷_subtract_def, Ó÷_def, Ø÷_def, ÷_Ó_exp_def];
val €÷_poly_func_def› = get_spec ¨PolyFuncâCÆ;
val €÷_series_def› = get_spec ¨SeriesâCÆ;
val €÷_power_series_def› = get_spec ¨PowerSeriesâCÆ;
val €open_÷_def› = get_spec ¨OpenâCÆ;
val €s1_def› = get_spec ¨S1Æ;
val €exp_s1_def› = get_spec ¨ExpS1Æ;
val €exp_s1_def1› = §_t_elim (rewrite_conv[exp_s1_def]
	¨ExpS1 = (Ã x∑ (Cos x, Sin x))Æ);
=TEX
\subsection{Basic Algebraic Properties}

%%%%
%%%%
=SML

set_goal([], ¨µ x y:÷∑ x + y = y + xÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €÷_plus_comm_thm› = save_pop_thm "÷_plus_comm_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µ x y z:÷∑ (x + y) + z = x + y + zÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €÷_plus_assoc_thm› = save_pop_thm "÷_plus_assoc_thm";

val €÷_plus_assoc_thm1› = save_thm ("÷_plus_assoc_thm1",
	conv_rule(ONCE_MAP_C eq_sym_conv) ÷_plus_assoc_thm);
=SML
set_goal([], ¨µ x:÷∑ x + Ó÷ 0 = x ± Ó÷0 + x = xÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €÷_plus_0_thm› = save_pop_thm "÷_plus_0_thm";
=SML
set_goal([], ¨µ x:÷∑ x + ~x = Ó÷ 0 ± ~x + x = Ó÷ 0Æ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €÷_plus_minus_thm› = save_pop_thm "÷_plus_minus_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µ x:÷∑
	x * (x õ_) = Ø÷(Fst x ^ 2 + Snd x ^ 2)
Æ);
a(rewrite_tac (Ø_Ó_exp_square_thm::÷_ops_defs) THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €÷_times_conj_thm› = save_pop_thm "÷_times_conj_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µ x y:÷∑ x * y = y * xÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €÷_times_comm_thm› = save_pop_thm "÷_times_comm_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µ x y z:÷∑ (x * y) * z = x * y * zÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €÷_times_assoc_thm› = save_pop_thm "÷_times_assoc_thm";

val €÷_times_assoc_thm1› = save_thm ("÷_times_assoc_thm1",
	conv_rule(ONCE_MAP_C eq_sym_conv) ÷_times_assoc_thm);

=SML

set_goal([], ¨µ x:÷∑ x * Ó÷ 1 = x ± Ó÷ 1 * x = xÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €÷_times_1_thm› = save_pop_thm "÷_times_1_thm";



=SML
set_goal([], ¨µ x:÷∑ ≥x = Ó÷ 0 ¥ x * x õ-õ1 = Ó÷ 1Æ);
a(rewrite_tac [÷_recip_def, ÷_times_conj_thm]);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) ÷_times_assoc_thm, ÷_times_conj_thm]);
a(rewrite_tac ÷_ops_defs);
a(µ_tac THEN STRIP_T asm_tac);
a(bc_thm_tac (rewrite_rule[](nth 2 (fc_canon(±_left_elim Ø_recip_clauses)))));
a(strip_asm_tac(µ_elim¨Fst xÆ Ø_0_º_square_thm));
a(strip_asm_tac(µ_elim¨Snd xÆ Ø_0_º_square_thm));
a(swap_nth_asm_concl_tac 3);
a(LEMMA_T ¨Fst x ^ 2 = ÓØ 0 ± Snd x ^ 2  = ÓØ 0Æ ante_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[Ø_square_eq_0_thm]);
val €÷_times_recip_thm› = save_pop_thm "÷_times_recip_thm";

val €÷_times_recip_thm1› = save_thm ("÷_times_recip_thm1",
	conv_rule(once_rewrite_conv[÷_times_comm_thm]) ÷_times_recip_thm);

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µ z w:÷∑ ≥z = Ó÷ 0 ± z*w = Ó÷ 1 ¥ w = z õ-õ1Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨z õ-õ1 * z * w = z õ-õ1Æ ante_tac
	THEN1 asm_rewrite_tac[÷_times_1_thm]);
a(rewrite_tac[÷_times_assoc_thm1]);
a(conv_tac(LEFT_C(LEFT_C(once_rewrite_conv[÷_times_comm_thm]))));
a(ALL_FC_T rewrite_tac[÷_times_recip_thm1]);
a(rewrite_tac[÷_times_1_thm]);
val €÷_times_eq_1_thm› = save_pop_thm "÷_times_eq_1_thm";


=TEX

%%%%
%%%%
=SML

set_goal([], ¨µ x y z:÷∑ x * (y + z) = x * y + x * zÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €÷_times_plus_distrib_thm› = save_pop_thm "÷_times_plus_distrib_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µ x y:÷∑ (x + y) õ_  = x õ_ + y õ_Æ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €÷_conj_plus_homomorphism_thm› = save_pop_thm "÷_conj_plus_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µ x y:÷∑ (x * y) õ_  = x õ_ * y õ_Æ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €÷_conj_times_homomorphism_thm› = save_pop_thm "÷_conj_times_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µ x y:Ø∑ Ø÷(x + y) = Ø÷ x + Ø÷ yÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €Ø÷_plus_homomorphism_thm› = save_pop_thm "Ø÷_plus_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µ x y:Ø∑ Ø÷(x * y) = Ø÷ x * Ø÷ yÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
val €Ø÷_times_homomorphism_thm› = save_pop_thm "Ø÷_times_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µ x y:Ó∑ Ó÷(x + y) = Ó÷ x + Ó÷ yÆ);
a(rewrite_tac (ÓØ_plus_homomorphism_thm::÷_ops_defs));
val €Ó÷_plus_homomorphism_thm› = save_pop_thm "Ó÷_plus_homomorphism_thm";
=TEX

%%%%
%%%%
=SML

set_goal([], ¨µ m n:Ó∑ Ó÷ m = Ó÷ n § m = nÆ);
a(rewrite_tac (ÓØ_one_one_thm::÷_ops_defs));
val €Ó÷_one_one_thm› = save_pop_thm "Ó÷_one_one_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µ x y:Ó∑ Ó÷(x * y) = Ó÷ x * Ó÷ yÆ);
a(rewrite_tac (ÓØ_times_homomorphism_thm::÷_ops_defs));
val €Ó÷_times_homomorphism_thm› = save_pop_thm "Ó÷_times_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

val €÷_plus_order_thm› = (
set_goal([], ¨µx y z:÷∑
	y + x = x + y
±	(x + y) + z = x + y + z
±	y + x + z = x + y + z	Æ);
a(REPEAT µ_tac THEN rewrite_tac[÷_plus_assoc_thm]);
a(rewrite_tac[µ_elim¨yÆ ÷_plus_comm_thm, ÷_plus_assoc_thm]);
save_pop_thm"÷_plus_order_thm"
);

=TEX

%%%%
%%%%
=SML
val €÷_eq_thm› = (
set_goal([], ¨µ x y : ÷ ∑ x = y § x + ~y = Ó÷ 0Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[÷_plus_minus_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨(x + ~ y) + y = Ó÷ 0 + yÆ ante_tac THEN1 asm_rewrite_tac[]);
a(rewrite_tac[÷_plus_assoc_thm, ÷_plus_minus_thm, ÷_plus_0_thm]);
save_pop_thm"Ø_eq_thm"
);
=TEX

%%%%
%%%%
=SML

val €÷_minus_clauses› = (
set_goal([], ¨µx y : ÷∑
		~ (~ x) = x
	±	x + ~ x = Ó÷ 0
	±	~ x + x = Ó÷ 0
	±	~ (x + y) = ~ x + ~ y
	± 	~(Ó÷ 0) = (Ó÷ 0)Æ);
a(REPEAT µ_tac);
a(rewrite_tac[÷_plus_minus_thm]);
a(lemma_tac¨µx:÷∑~(~ x) = xÆ);
(* *** Goal "1" *** *)
a(strip_tac THEN once_rewrite_tac[÷_eq_thm]);
a(rewrite_tac[÷_plus_minus_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[] THEN strip_tac);
(* *** Goal "2.1" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[÷_eq_thm]);
a(asm_rewrite_tac[µ_elim¨~ yÆ÷_plus_order_thm]);
a(rewrite_tac[µ_elim¨yÆ÷_plus_order_thm, ÷_plus_minus_thm, ÷_plus_0_thm]);
(* *** Goal "2.2" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[÷_eq_thm]);
a(asm_rewrite_tac[÷_plus_0_thm]);
save_pop_thm"÷_minus_clauses"
);

=TEX

%%%%
%%%%
=SML


val €÷_plus_clauses› = (
set_goal([], ¨
	µ x y z:÷∑
	(x + z = y + z § x = y)
±	(z + x = y + z § x = y)
±	(x + z = z + y § x = y)
±	(z + x = z + y § x = y)
±	(x + z = z § x = Ó÷ 0)
±	(z + x = z § x = Ó÷ 0)
±	(z = z + y § y = Ó÷ 0)
±	(z = y + z § y = Ó÷ 0)
±	x + Ó÷ 0 = x
±	Ó÷ 0 + x = x
±	≥ Ó÷ 1 = Ó÷ 0
±	≥ Ó÷ 0 = Ó÷ 1
Æ);
a(REPEAT µ_tac);
a(rewrite_tac[÷_plus_0_thm, Ó÷_one_one_thm, plus_clauses,
	µ_elim¨zÆ ÷_plus_order_thm]);
a(once_rewrite_tac[µ_elim¨z + xÆ ÷_eq_thm]);
a(once_rewrite_tac[µ_elim¨zÆ ÷_eq_thm]);
a(rewrite_tac[÷_minus_clauses, µ_elim¨~ zÆ ÷_plus_order_thm]);
a(rewrite_tac[÷_plus_assoc_thm1, ÷_minus_clauses, ÷_plus_0_thm]);
a(once_rewrite_tac[µ_elim¨xÆ ÷_eq_thm]);
a(rewrite_tac[]);
a(conv_tac(LEFT_C eq_sym_conv));
a(once_rewrite_tac[µ_elim¨Ó÷ 0Æ ÷_eq_thm]);
a(rewrite_tac[÷_minus_clauses, ÷_plus_0_thm]);
save_pop_thm"÷_plus_clauses"
);

=TEX

%%%%
%%%%
=SML

val €÷_times_order_thm› = (
set_goal([], ¨µ x : ÷ ∑ µ y z ∑
		y * x = x * y
	±	(x * y) * z = x * y * z
	±	y * x * z = x * y * zÆ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [list_µ_elim [¨yÆ,¨xÆ] ÷_times_comm_thm]);
(* *** Goal "2" *** *)
a (rewrite_tac [all_µ_elim ÷_times_assoc_thm]);
(* *** Goal "3" *** *)
a (rewrite_tac [list_µ_elim [¨yÆ,¨xÆ,¨zÆ] ÷_times_assoc_thm1]);
a (once_rewrite_tac [list_µ_elim [¨yÆ,¨xÆ] ÷_times_comm_thm]);
a (rewrite_tac [÷_times_assoc_thm]);
save_pop_thm "÷_times_order_thm"
);

=TEX

%%%%
%%%%
=SML

val €÷_times_0_thm1› = (
set_goal([], ¨µx:÷∑ x * Ó÷ 0 = Ó÷ 0Æ);
a(accept_tac(
	all_µ_intro
	(rewrite_rule[÷_plus_clauses, ÷_plus_0_thm](prove_rule[÷_times_plus_distrib_thm]
	¨x*(Ó÷ 0 + Ó÷ 0) = x * Ó÷ 0 + x * Ó÷ 0Æ))));
pop_thm()
);

=TEX

%%%%
%%%%
=SML

val €÷_times_0_thm› = (
set_goal([], ¨µx:÷∑ x * Ó÷ 0 = Ó÷ 0 ± Ó÷ 0 * x = Ó÷ 0Æ);
a(rewrite_tac[µ_elim¨x:÷Æ÷_times_order_thm, ÷_times_0_thm1]);
save_pop_thm "÷_times_0_thm"
);

=TEX

%%%%
%%%%
=SML

val €÷_times_clauses› = (
set_goal ([], ¨µ x ∑ Ó÷ 0 * x = Ó÷ 0 ± x * Ó÷ 0 = Ó÷ 0 ± x * Ó÷ 1 = x ± Ó÷ 1 * x = xÆ);
a(rewrite_tac[÷_times_0_thm, ÷_times_1_thm]);
save_pop_thm "÷_times_clauses"
);


=TEX
\subsection{A Proof Context}
\section{PROOF CONTEXT}

=TEX

=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt (current_ad_rw_canon())) thms)
);
=TEX
=SML
val _ = delete_pc "'÷" handle Fail _ => ();
val _ = new_pc "'÷";
(*
val _ = set_rw_eqn_cxt
		[	(¨x +âR yÆ, Ø_plus_conv),
			(¨x *âR yÆ, Ø_times_conv),
			(¨x -âR yÆ, Ø_subtract_conv),
			(¨AbsâR xÆ, Ø_abs_conv),
			(¨x /âR yÆ, Ø_over_conv),
			(¨x õ-õ1Æ, Ø_recip_conv),
			(¨x ^âN mÆ, Ø_Ó_exp_conv),
			(¨x ^âZ iÆ, Ø_˙_exp_conv),
			(¨(x:Ø) = yÆ, Ø_eq_conv),
			(¨x ºâR yÆ, Ø_º_conv),
			(¨x <âR yÆ, Ø_less_conv),
			(¨x æâR yÆ, Ø_æ_conv),
			(¨x >âR yÆ, Ø_greater_conv),
			(¨m /âN mÆ, Ø_frac_norm_conv),
			(¨Float x p (Ó˙ 0)Æ, float_conv),
			(¨MaxâR [x]Æ, Ø_max_conv),
			(¨MaxâR (Cons x (Cons y z))Æ, Ø_max_conv),
			(¨MinâR [x]Æ, Ø_min_conv),
			(¨MinâR (Cons x (Cons y z))Æ, Ø_min_conv)
		] "'÷";
*)
val _ = add_rw_thms [÷_plus_clauses, ÷_minus_clauses, ÷_times_clauses]
	"'÷";
(*
val €pos› = (thms_to_eqn_cxt [Ø_minus_clauses, Ø_º_clauses, Ø_less_clauses]) @
		[	(¨(x:Ø) = yÆ, Ø_eq_conv),
			(¨x æâR yÆ, Ø_æ_conv),
			(¨x >âR yÆ, Ø_greater_conv)];
val €neg› = mapfilter (mk_≥ ** RAND_C) pos;
val €neutral› = [(¨x ºâR yÆ, Ø_º_conv), (¨x <âR yÆ, Ø_less_conv)];
val €strip_eqn_cxt› = neutral @ pos @ neg;
val _ = set_st_eqn_cxt strip_eqn_cxt "'÷";
val _ = set_sc_eqn_cxt strip_eqn_cxt "'÷";
*)

val _ = set_pr_tac basic_prove_tac "'÷";
val _ = set_pr_conv basic_prove_conv "'÷";

(*
val _ = commit_pc "'÷";
*)

val _ = set_merge_pcs["basic_hol1", "'˙", "'Ø", "'sets_alg", "'÷"];

=TEX
\subsection{de Moivre's Theorem}

%%%%
%%%%
=SML

set_goal([], ¨µ x m∑
	(Cos x, Sin x) ^ m =
	(Cos (ÓØ m * x), Sin (ÓØ m * x))
Æ);
a(REPEAT µ_tac THEN induction_tac¨m:ÓÆ
	THEN asm_rewrite_tac 
	(sin_def::ÓØ_plus_homomorphism_thm::
		Ø_times_plus_distrib_thm::
		sin_cos_plus_thm::÷_ops_defs));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €de_moivre_thm› = save_pop_thm "de_moivre_thm";
=TEX
\subsection{Polynomials}

The following is useful for evaluaating partial sums of series of specific known length:
%%%%
%%%%
=SML

val €÷_series_rw_thm› = save_thm ("÷_const_eval_thm", (
set_goal([], ¨µs n∑ SeriesâC s n = if n = 0 then Ó÷ 0 else s (n-1) + SeriesâC s (n-1)Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ
	THEN asm_rewrite_tac[÷_series_def]);
pop_thm()
));

=TEX


%%%%
Now we will show that any polynomial function can be represented by a finite power series.

Constants \ldots
%%%%
%%%%
=SML
(*

set_goal([], ¨µc∑(Ãx∑c) = PowerSeriesâC (Ãi∑c) 0Æ);
a(rewrite_tac[] THEN pure_rewrite_tac[÷_power_series_def, ÷_series_def]);
a(rewrite_tac ÷_ops_defs);
val €÷_const_eval_thm› = save_pop_thm "÷_const_eval_thm";

=TEX
\ldots identity function \ldots
%%%%
%%%%
=SML

set_goal([], ¨(Ãx∑x) = PowerSeriesâC (Ãi∑if i = 1 then Ó÷ 1 else Ó÷ 0) 1Æ);
a(rewrite_tac[] THEN pure_rewrite_tac[÷_power_series_def, ÷_series_def]);

a(rewrite_tac[poly_eval_def]);
val €id_eval_thm› = save_pop_thm "id_eval_thm";

=TEX
\ldots sums \ldots
%%%%
%%%%
=SML

set_goal([], ¨µl1 l2∑
	(Ãx∑PolyEval l1 x + PolyEval l2 x) =
	PolyEval (PlusCoeffs l1 l2)Æ);
a(strip_tac);
a(list_induction_tac¨l1Æ THEN rewrite_tac[plus_coeffs_def, poly_eval_def]);
a(REPEAT strip_tac);
a(list_induction_tac¨l2Æ THEN rewrite_tac[plus_coeffs_def, poly_eval_def]);
a(DROP_NTH_ASM_T 2 (rewrite_thm_tac o conv_rule (BINDER_C eq_sym_conv)));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €plus_eval_thm› = save_pop_thm "plus_eval_thm";

=TEX
\ldots and products, which in this case require a little lemma first:
%%%%
%%%%
=SML

set_goal([], ¨µc l∑(Ãx∑c * PolyEval l x) = PolyEval (Map (Ãy∑c * y) l)Æ);
a(REPEAT strip_tac);
a(list_induction_tac¨lÆ THEN rewrite_tac[map_def, poly_eval_def]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
val €const_times_eval_thm› = save_pop_thm "const_times_eval_thm";

=TEX
%%%%
%%%%
=SML

set_goal([], ¨µl1 l2∑
	(Ãx∑PolyEval l1 x * PolyEval l2 x) =
	PolyEval (TimesCoeffs l1 l2)Æ);
a(strip_tac);
a(list_induction_tac¨l1Æ THEN
	rewrite_tac[times_coeffs_def, poly_eval_def, plus_coeffs_def]);
a(REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[]));
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) plus_eval_thm,
	conv_rule (ONCE_MAP_C eq_sym_conv) const_times_eval_thm,
	poly_eval_def]);
a(conv_tac (RANDS_C Ø_anf_conv));
a(asm_rewrite_tac[]);
val €times_eval_thm› = save_pop_thm "times_eval_thm";

*)
=TEX
For the reverse inclusion, and for later use, it is convenient
to prove an induction theorem for polynomials and use it
to derive an induction tactic:
%%%%
%%%%
=SML

set_goal([], ¨µp∑
		(µc∑p(Ãx∑c))
	±	(p(Ãx∑x))
	±	(µf g∑p f ± p g ¥  p(Ãx∑f x + g x))
	±	(µf g∑p f ± p g ¥ p(Ãx∑f x * g x))
	¥	(µh∑ h ç PolyFuncâC ¥ p h)
Æ);
a(rewrite_tac[÷_poly_func_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(PC_T1 "sets_ext1" POP_ASM_T (strip_asm_tac o µ_elim ¨{h | p h}Æ)
	THEN1 asm_prove_tac[] THEN all_asm_fc_tac[]);
val €÷_poly_induction_thm› = save_pop_thm "÷_poly_induction_thm";


=TEX
Now the tactic, which expects a term of the form $f \in \mbox{\it PolyFunc_C}$ to
be in the assumptions (where $f$ is the induction variable).
%%%%
%%%%
=SML

fun €÷_poly_induction_tac› (tm : TERM) : TACTIC = (
	if not (is_var tm andalso type_of tm =: î÷ ≠ ÷Æ)
	then term_fail "÷_poly_induction_tac" 999001 [tm]
	else ( fn(asms, conc) =>
	let	val asm = find asms (fn t =>  
			let	val (x, s) = dest_bin_op "" 0 "ç" t;
			in	x =$ tm andalso s =$ ¨PolyFuncâCÆ
			end	handle Fail _ => false)
			handle Fail _ => fail "÷_poly_induction_tac" 999002 [];
	in	if not (is_free_in tm conc)
			then term_fail "÷_poly_induction_tac" 999003 [tm]
		else if any (asms drop (fn t => t =$ asm)) (is_free_in tm)
			then term_fail "÷_poly_induction_tac" 999004 [tm]
		else	(asm_ante_tac asm THEN gen_induction_tac1 ÷_poly_induction_thm) (asms, conc)
	end
	)
);



(*

set_goal([], ¨
	µf∑f ç PolyFuncâC 
Æ);
a(rewrite_tac[open_÷_def]);
a(bc_thm_tac product_topology_thm THEN rewrite_tac[open_Ø_topology_thm]);
val €open_÷_topology_thm› = save_pop_thm "open_÷_topology_thm";

*)

=TEX
\subsection{Topological Properties}

%%%%
%%%%
=SML

set_goal([], ¨
	OpenâC ç Topology
Æ);
a(rewrite_tac[open_÷_def]);
a(bc_thm_tac product_topology_thm THEN rewrite_tac[open_Ø_topology_thm]);
val €open_÷_topology_thm› = save_pop_thm "open_÷_topology_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨
	OpenâC ç Hausdorff
Æ);
a(rewrite_tac[open_÷_def, open_Ø_∏_open_Ø_hausdorff_thm]);
val €open_÷_hausdorff_thm› = save_pop_thm "open_÷_hausdorff_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨
	Universe ç OpenâC
Æ);
a(rewrite_tac[open_÷_def]);
a(rewrite_tac[product_topology_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(∂_tac¨UniverseÆ THEN ∂_tac¨UniverseÆ THEN rewrite_tac[empty_universe_open_closed_thm]);
val €universe_open_÷_thm› = save_pop_thm "universe_open_÷_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨
	SpaceâT OpenâC = Universe
Æ);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(bc_thm_tac ç_space_t_thm);
a(∂_tac¨UniverseÆ THEN PC_T1 "sets_ext1" rewrite_tac[universe_open_÷_thm]);
val €space_t_open_÷_thm› = save_pop_thm "space_t_open_÷_thm";

val €space_t_subspace_open_÷_thm› = save_thm ("space_t_subspace_open_÷_thm",
	rewrite_rule[open_÷_topology_thm, space_t_open_÷_thm]
	(µ_elim¨OpenâCÆ subspace_topology_space_t_thm));

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µ‘ : 'a SET SET; r i: 'a ≠ Ø∑
	‘ ç Topology
¥	(	(Ãx∑(r x, i x)) ç (‘, OpenâC) Continuous
	§	r ç (‘, OpenâR) Continuous
	±	i ç (‘, OpenâR) Continuous)
Æ);
a(REPEAT µ_tac THEN ¥_tac);
a(strip_asm_tac open_Ø_topology_thm);
a(rewrite_tac[open_÷_def]);
a(ALL_FC_T1 fc_§_canon rewrite_tac[product_continuous_§_thm]);
val €continuous_open_÷_thm1› = save_pop_thm "continuous_open_÷_thm1";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µr i: Ø ≠ Ø∑
	(Ãx∑(r x, i x)) ç (OpenâR, OpenâC) Continuous §	
	(µx∑ r Cts x) ± (µx∑ i Cts x)
Æ);
a(REPEAT µ_tac);
a(strip_asm_tac open_Ø_topology_thm);
a(ALL_FC_T1 fc_§_canon rewrite_tac[continuous_open_÷_thm1]);
a(rewrite_tac[continuous_cts_at_Ø_thm]);
val €continuous_open_÷_thm2› = save_pop_thm "continuous_open_÷_thm2";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨
	ExpS1 ç (OpenâR, OpenâC) Continuous
Æ);
a(rewrite_tac[exp_s1_def1, continuous_open_÷_thm2, sin_cos_cts_thm]);
val €exp_s1_continuous_thm› = save_pop_thm "exp_s1_continuous_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µx y∑ Sqrt(x^2 + y^2) = 1. § x^2 + y^2 = 1. Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨0. º x^2 ± 0. º y^2Æ THEN1 rewrite_tac[Ø_0_º_square_thm]);
a(lemma_tac¨0. º x^2 + y^2Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [2, 3] discard_tac THEN all_fc_tac[sqrt_0_º_thm, sqrt_thm]);
a(POP_ASM_T (once_rewrite_thm_tac o eq_sym_rule));
a(asm_rewrite_tac[Ø_Ó_exp_square_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[sqrt_0_1_thm]);
val €÷_abs_squared_lemma› = save_pop_thm "÷_abs_squared_lemma";

=TEX

%%%%
%%%%
=SML


set_goal([], ¨µz∑ z ç S1 § Fst z^2 + Snd z^2 = 1.Æ);
a(MERGE_PCS_T1 ["'pair", "sets_ext1"] rewrite_tac[s1_def, ÷_abs_def, ÷_times_conj_thm, Ø÷_def, ÷_abs_squared_lemma]);
val €ç_s1_lemma› = save_pop_thm "ç_s1_lemma";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µx y∑ ExpS1(x + y) = ExpS1 x * ExpS1 yÆ);
a(rewrite_tac[exp_s1_def, ÷_times_def, sin_cos_plus_thm]);
val €exp_s1_homomorphism_thm› = save_pop_thm "exp_s1_homomorphism_thm";

val €exp_s1_homomorphism_thm1› = save_thm ("exp_s1_homomorphism_thm1",
	conv_rule(ONCE_MAP_C eq_sym_conv) exp_s1_homomorphism_thm);


=TEX

%%%%
%%%%
=SML

set_goal([], ¨µx∑ ExpS1(~x) = ExpS1 x õ-õ1Æ);
a(REPEAT strip_tac THEN bc_thm_tac ÷_times_eq_1_thm);
a(rewrite_tac[exp_s1_homomorphism_thm1]);
a(rewrite_tac[exp_s1_def, Ó÷_def, Ø÷_def, sin_def]);
a(contr_tac THEN ante_tac (µ_elim¨xÆ cos_squared_plus_sin_squared_thm));
a(asm_rewrite_tac[Ø_Ó_exp_square_thm]);
val €exp_s1_minus_thm› = save_pop_thm "exp_s1_minus_thm";


=TEX

%%%%
%%%%
=SML

set_goal([], ¨µx∑ ExpS1 x ç S1Æ);
a(rewrite_tac[exp_s1_def, ç_s1_lemma, cos_squared_plus_sin_squared_thm]);
val €exp_s1_ç_s1_thm› = save_pop_thm "exp_s1_ç_s1_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µx y∑ ExpS1 x = ExpS1 y § (∂m∑ y = x + ÓØ(2*m) * – ≤ x = y + ÓØ(2*m) * –)Æ);
a(lemma_tac¨
	(µx y∑ x < y ¥
		(ExpS1 x = ExpS1 y § (∂m∑ y = x + ÓØ(2*m) * –)))
±	(µx y m∑ x < y ¥ ≥ x = y + ÓØ (2 * m) * –)
Æ
	THEN1 ±_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[exp_s1_def,
	taut_rule¨µx y p∑ Cos x = y ± p § p ± Cos x = yÆ,
	sin_cos_period_thm]);
(* *** Goal "2" *** *)
a(contr_tac THEN all_var_elim_asm_tac1);
a(lemma_tac ¨0. º ÓØ (2 * m) * –Æ THEN_LIST [
	bc_thm_tac Ø_0_º_0_º_times_thm,
	PC_T1 "Ø_lin_arith" asm_prove_tac[]]);
a(rewrite_tac[ÓØ_º_thm] THEN rewrite_tac[Ø_º_def, –_def]);
(* *** Goal "3" *** *)
a(REPEAT µ_tac);
a(lemma_tac¨x = y ≤ x < y ≤ y < xÆ THEN1 PC_T1 "Ø_lin_arith" prove_tac[]
	THEN1 (all_var_elim_asm_tac THEN rewrite_tac[]));
(* *** Goal "3.1" *** *)
a(∂_tac¨0Æ THEN rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(LIST_DROP_NTH_ASM_T [2, 3] (ALL_FC_T1 fc_§_canon rewrite_tac));
(* *** Goal "3.3" *** *)
a(conv_tac(LEFT_C eq_sym_conv));
a(LIST_DROP_NTH_ASM_T [2, 3] (ALL_FC_T1 fc_§_canon rewrite_tac));
val €exp_s1_period_thm› = save_pop_thm "exp_s1_period_thm";

=TEX

%%%%
%%%%
=SML


set_goal([], ¨µz∑ z ç S1 ¥ ∂â1x∑ 0. º x ± x < 2. * – ± z = ExpS1 xÆ);
a(rewrite_tac[ç_s1_lemma, exp_s1_def] THEN REPEAT strip_tac);
a(bc_thm_tac sin_cos_onto_unit_circle_thm1 THEN strip_tac);
val €exp_s1_onto_thm› = save_pop_thm "exp_s1_onto_thm";

=TEX

%%%%
%%%%
=SML


set_goal([], ¨µz w∑ z ç S1 ± w ç S1 ¥ z*w ç S1Æ);
a(REPEAT strip_tac THEN all_fc_tac[exp_s1_onto_thm]
	THEN all_var_elim_asm_tac1);
a(rewrite_tac[exp_s1_homomorphism_thm1, exp_s1_ç_s1_thm]);
val €s1_times_thm› = save_pop_thm "s1_times_thm";

=TEX

%%%%
%%%%
=SML


set_goal([], ¨µc z∑
	z ç S1
¥	∂â1x∑ c - – º x ± x < c + – ± z = ExpS1 xÆ);
a(REPEAT strip_tac);
a(all_fc_tac[exp_s1_onto_thm] THEN all_var_elim_asm_tac1);
a(lemma_tac¨ExpS1 (x + – + ~c) ç S1Æ THEN1 rewrite_tac[exp_s1_ç_s1_thm]);
a(strip_asm_tac(µ_elim¨ExpS1 (x + – + ~c)Æ exp_s1_onto_thm));
a(∂â1_tac¨x' + c + ~ –Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(once_rewrite_tac[exp_s1_homomorphism_thm]);
a(DROP_NTH_ASM_T 2 (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[exp_s1_homomorphism_thm1]);
a(conv_tac(ONCE_MAP_C Ø_anf_conv) THEN rewrite_tac[]);
(* *** Goal "4" *** *)
a(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
	¨x'' = x' + c + ~ – § x'' + – - c = x'Æ]);
a(DROP_NTH_ASM_T 4 bc_thm_tac);
a(once_rewrite_tac[exp_s1_homomorphism_thm]);
a(asm_rewrite_tac[]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €exp_s1_onto_thm1› = save_pop_thm "exp_s1_onto_thm1";


=TEX

%%%%
%%%%
=SML

set_goal([], ¨µc z∑
	z ç S1 ±≥z = ExpS1 (c + –)
¥	∂â1x∑x ç OpenInterval (c - –) (c + –) ± z = ExpS1 xÆ);
a(rewrite_tac[open_interval_def] THEN REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨cÆ, ¨zÆ]exp_s1_onto_thm1));
a(∂â1_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 (strip_asm_tac o rewrite_rule[Ø_º_def])
	THEN all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(swap_nth_asm_concl_tac 3);
a(rewrite_tac[exp_s1_period_thm]);
a(∂_tac¨1Æ THEN rewrite_tac[]);
a(PC_T1"Ø_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 bc_thm_tac THEN asm_rewrite_tac[]);
a(PC_T1"Ø_lin_arith" asm_prove_tac[]);
val €exp_s1_onto_thm2› = save_pop_thm "exp_s1_onto_thm2";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µc∑
	S1 \ {ExpS1 (c + –)} =
	{z | ∂ x∑ x ç OpenInterval (c - –) (c + –) ± z = ExpS1 x}Æ);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[exp_s1_onto_thm2]);
a(∂_tac¨xÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[exp_s1_ç_s1_thm]);
(* *** Goal "3" *** *)
a(pure_asm_rewrite_tac[] THEN POP_ASM_T discard_tac);
a(POP_ASM_T ante_tac
	THEN rewrite_tac[open_interval_def]
	THEN strip_tac);
a(ante_tac (list_µ_elim[¨cÆ, ¨ExpS1 xÆ] exp_s1_onto_thm1));
a(rewrite_tac[exp_s1_ç_s1_thm] THEN strip_tac);
a(lemma_tac¨c + ~ – º xÆ THEN1 asm_rewrite_tac[Ø_º_def]);
a(lemma_tac¨x = x'Æ THEN1
	(DROP_NTH_ASM_T 2 bc_thm_tac THEN asm_rewrite_tac[])
	THEN all_var_elim_asm_tac1);
a(contr_tac);
a(DROP_NTH_ASM_T 2 (ante_tac o µ_elim¨c + ~ –Æ) THEN asm_rewrite_tac[]);
a(LEMMA_T ¨~ – < – ± ≥c + ~ – = x'Æ rewrite_thm_tac
	THEN1 (strip_asm_tac –_def
		THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(rewrite_tac[exp_s1_period_thm]);
a(∂_tac¨1Æ THEN rewrite_tac[]);
a(strip_asm_tac –_def
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val €exp_s1_covering_projection_lemma1› = save_pop_thm "exp_s1_covering_projection_lemma1";



=TEX

%%%%
%%%%
=SML

set_goal([], ¨µx∑
	ExpS1 ç
	(OpenInterval (x - –) (x + –) ÚâT OpenâR,
		(S1 \ {ExpS1 (x + –)}) ÚâT OpenâC) 
			Homeomorphism
Æ);
a(REPEAT strip_tac);
a(rewrite_tac[exp_s1_covering_projection_lemma1]);
a(bc_thm_tac Ä_compact_homeomorphism_thm);
a(∂_tac¨ClosedInterval (x - –) (x + –)Æ);
a(rewrite_tac[open_Ø_topology_thm, open_Ø_hausdorff_thm,
	open_÷_topology_thm, open_÷_hausdorff_thm,
	exp_s1_continuous_thm, compact_compact_Ø_thm,
	closed_interval_compact_thm]);
a(rewrite_tac[open_interval_def, closed_interval_def]);
a(REPEAT strip_tac THEN1
	(PC_T1 "sets_ext1" rewrite_tac[]
	THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[Ø_º_def]));
(* *** Goal "1" *** *)
a(ante_tac(list_µ_elim[¨xÆ, ¨ExpS1 yÆ] exp_s1_onto_thm1)
	THEN rewrite_tac[exp_s1_ç_s1_thm]
	THEN REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨yÆ THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o eq_sym_rule)); 
a(lemma_tac¨x + ~ – º x'Æ THEN1 asm_rewrite_tac[Ø_º_def]);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac THEN all_var_elim_asm_tac);
(* *** Goal "2" *** *)
a(i_contr_tac THEN all_var_elim_asm_tac1);
a(POP_ASM_T (strip_asm_tac o eq_sym_rule));
a(ante_tac(list_µ_elim[¨x' + –Æ, ¨ExpS1 (x + –)Æ] exp_s1_onto_thm1)
	THEN rewrite_tac[exp_s1_ç_s1_thm]
	THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨x + –Æ THEN_TRY PC_T1"Ø_lin_arith" asm_prove_tac[]
	THEN all_var_elim_asm_tac1);
a(spec_nth_asm_tac 2 ¨x'Æ THEN_TRY PC_T1"Ø_lin_arith" asm_prove_tac[]);
val €exp_s1_covering_projection_lemma2› = save_pop_thm "exp_s1_covering_projection_lemma2";


=TEX
%%%%
%%%%
=SML

val €exp_s1_covering_projection_lemma3› = save_thm (
	"exp_s1_covering_projection_lemma3",
 rewrite_rule[open_Ø_topology_thm,
	open_÷_topology_thm,
	exp_s1_continuous_thm,
	exp_s1_ç_s1_thm,
	universe_subspace_topology_thm]
	(list_µ_elim[¨OpenâRÆ, ¨OpenâCÆ,
		¨Universe:Ø SETÆ, ¨S1Æ, ¨ExpS1Æ] 
			subspace_continuous_thm));

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µx∑
	ExpS1 x ç S1 \ {ExpS1 (x + –)}
Æ);
a(REPEAT strip_tac THEN1 rewrite_tac[exp_s1_ç_s1_thm]);
a(rewrite_tac[exp_s1_def, sin_cos_–_thm, sin_cos_plus_thm] THEN contr_tac);
a(lemma_tac¨Sin x = 0. ± Cos x = 0.Æ
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ante_tac (µ_elim¨xÆcos_squared_plus_sin_squared_thm));
a(asm_rewrite_tac[Ø_Ó_exp_square_thm]);
val €exp_s1_covering_projection_lemma4› = save_pop_thm "exp_s1_covering_projection_lemma4";

=TEX

%%%%
%%%%
=SML

set_goal([], ¨µx y∑
	ExpS1 x = ExpS1 y
±	≥OpenInterval (x + ~ –) (x + –) °
		OpenInterval (y + ~ –) (y + –) = {}
¥	x = y
Æ);
a(PC_T1 "sets_ext1" rewrite_tac[exp_s1_period_thm, open_interval_def] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN strip_asm_tac (µ_elim¨m:ÓÆ Ó_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN all_asm_ante_tac
	THEN rewrite_tac[ÓØ_times_homomorphism_thm,
		ÓØ_plus_homomorphism_thm,
		Ø_times_plus_distrib_thm,
		Ø_times_assoc_thm]
	THEN	(lemma_tac ¨0. º ÓØ i * –Æ THEN_LIST [
		bc_thm_tac Ø_0_º_0_º_times_thm,
		PC_T1 "Ø_lin_arith" asm_prove_tac[]]));
(* *** Goal "1" (duplicates "2") *** *)
a(rewrite_tac[ÓØ_º_thm] THEN rewrite_tac[Ø_º_def, –_def]);
val €exp_s1_covering_projection_lemma5› = save_pop_thm "exp_s1_covering_projection_lemma5";

=TEX
%%%%
%%%%
=SML

val €÷_punctured_set_thm› = save_thm (
	"÷_punctured_set_thm",
	rewrite_rule[
		open_÷_topology_thm,
		open_÷_hausdorff_thm,
		space_t_open_÷_thm]
		(µ_elim¨OpenâCÆ punctured_hausdorff_thm));

=TEX
%%%%
%%%%
=SML

set_goal([], ¨
	ExpS1 ç (OpenâR, S1 ÚâT OpenâC) CoveringProjection
Æ);
a(rewrite_tac[covering_projection_def, space_t_subspace_open_÷_thm,
	exp_s1_continuous_thm,
	exp_s1_covering_projection_lemma3]
	THEN REPEAT strip_tac);
a(all_fc_tac[exp_s1_onto_thm] THEN all_var_elim_asm_tac1);
a(∂_tac¨S1 \ {ExpS1(x + –)}Æ);
a(rewrite_tac[exp_s1_covering_projection_lemma4,
	÷_punctured_set_thm]);
a(lemma_tac¨0. < –Æ THEN1 rewrite_tac[–_def]);
a(∂_tac¨{I | ∂y∑ ExpS1 y = ExpS1 x
	± I = OpenInterval (y - –) (y + –)}Æ
	THEN rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN rewrite_tac[open_interval_open_thm]);
(* *** Goal "2" *** *)
a(lemma_tac¨≥ExpS1 x = ExpS1(x' + –)Æ);
(* *** Goal "2.1" *** *)
a(swap_nth_asm_concl_tac 1 THEN POP_ASM_T ante_tac);
a(rewrite_tac[exp_s1_homomorphism_thm]);
a(rewrite_tac[exp_s1_def, sin_cos_–_thm, ÷_times_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac (list_µ_elim[¨x'Æ, ¨ExpS1 xÆ]exp_s1_onto_thm2));
a(∂_tac¨OpenInterval (x'' + ~ –) (x'' + –)Æ
	THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac
	THEN rewrite_tac[open_interval_def]
	THEN PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2.2.2" *** *)
a(∂_tac¨x''Æ THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨ExpS1 y = ExpS1 y'Æ THEN1 asm_rewrite_tac[]
	THEN all_var_elim_asm_tac1);
a(ALL_FC_T rewrite_tac[exp_s1_covering_projection_lemma5]);
(* *** Goal "4" *** *)
a(lemma_tac¨S1 \ {ExpS1 (x + –)} Ä S1Æ
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(ALL_FC_T rewrite_tac[Ä_subspace_topology_thm]);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o eq_sym_rule));
a(all_var_elim_asm_tac1);
a(LEMMA_T ¨ExpS1 (x + –) = ExpS1 (y + –)Æ rewrite_thm_tac
	THEN1 asm_rewrite_tac[exp_s1_homomorphism_thm]);
a(rewrite_tac[rewrite_rule[]exp_s1_covering_projection_lemma2]);
val €exp_s1_covering_projection_thm› = save_pop_thm "exp_s1_covering_projection_thm";

=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val €sections› = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="wrk072.th.doc", theory="÷"};
end;
=TEX
} %\Hide
\end{document}


