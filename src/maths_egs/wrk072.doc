=IGN
********************************************************************************
wrk072.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
wrk072.doc,v 1.15 2010/11/14 11:55:24 rda Exp
********************************************************************************
% wrk072.doc 1.15 wrk072.doc,v 2010/11/14 11:55:24
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{url}
\def\Hide#1{\relax}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\C{\mathbb{C}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\title{Mathematical Case Studies: the Complex Numbers\thanks{
First posted 17 September 2005;
for full changes history see: \protect\url{https://github.com/RobArthan/pp-contrib}.
}}
\author{Rob Arthan\\{\tt rda@lemma-one.com}}
\date{\FormatDate{\VCDate}}
\makeindex
\begin{document}
\vfill
\begin{titlepage}
\maketitle
\begin{abstract}

Definitions of the complex numbers and their arithmetic operators in {\ProductHOL} with proofs of some of their elementary algebraic properties.

\end{abstract}
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd 2005--\number\year \\
Reference: LEMMA1/HOL/WRK072; Current git revision: \VCVersion%


\end{centering}
\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
\tableofcontents
\newpage
\section{INTRODUCTION}
This document contains the beginnings of a theory of complex arithmetic in {\ProductHOL}.

After some preliminaries, section~\ref{sec:algebra} introduces the field operations and the embedddings of the real numbers and of conjugation (which help to abbreviate the definition of reciprocals).
We then define the derived operations of binary subtraction and division and the embedding of the natural numbers.

In section~\ref{sec:topology} we introduce the topology on the complex numbers and define the exponential mapping of the real line onto the unit circle.

A proof script contained in the source of this document but hidden from the printed document proves several theorems about the complex numbers.
A listing of the theorems proved is given in appendix~\ref{listing}.

We prove that the complex numbers form a field and prove some elementary algebraic properties of complex conjugation and of the embeddings of the natural numbers and the real numbers in the complex numbers.
The proofs of these basic algebraic properties generally comprise little more than simplifying using definitions and standard theorems and then application of the decision procedure for linear arithmetic to prove the resulting problem of real algebra.
One exception is proving that $zz^{-1} = 1$, which requires a few lines of reasoning about real squares.

The proof scripts then go on to develop basic facts about the exponential mapping of the real line onto the unit circle, leading up to the important fact that it is a covering projection.



\section{THE ALGEBRA Ö}\label{sec:algebra}

\subsection{Preliminaries}
The following commands set up a theory to hold the definitions, theorems, etc.
The theory has the theory of analysis defined in ~\cite{LEMMA1/HOL/WRK066} for its parent, although the elementary algebraic theory only needs one or two little theorems about squares.
=SML
force_delete_theory "Ö" handle Fail _ => ();
open_theory "analysis";
new_theory "Ö";
new_parent "homotopy";
new_parent "group_egs";
=IGN
open_theory"Ö";
=TEX
Now set up a convenient proof context:
=SML
set_merge_pcs["basic_hol1", "'ú", "'¯", "'sets_alg"];
=TEX
\subsection{The Type Ö}
The type Ö comprises pairs of real numbers.
We capture this in a type abbreviation:
=SML
declare_type_abbrev("Ö", [], ”¯ ¸ ¯®);
=TEX
We declare aliases for the instances of the projection functions
that give the real and imaginary part of a complex number:
=SML
app declare_alias [
	("Re", ¬Fst : Ö ­ ¯®),
	("Im", ¬Snd : Ö ­ ¯®)];
=TEX

\subsection{Algebraic Operators}
\subsubsection{Addition}

=SML
declare_infix(300, "+‰C");
=TEX

¹HOLCONST
Ü $Û+‰CÝ : Ö ­ Ö ­ Ö
÷üüüüüü
Üµ z w : Ö· z +‰C w = (Re z + Re w, Im z + Im w)
°

=SML
declare_alias("+", ¬$+‰C®);
=TEX
\subsubsection{Negation}

¹HOLCONST
Ü Û~‰CÝ : Ö ­ Ö
÷üüüüüü
Üµ z : Ö· ~‰C z = (~(Re z), ~(Im z))
°
=SML
declare_alias("~", ¬~‰C®);
=TEX

=TEX
\subsubsection{Multiplication}
=SML
declare_infix(310, "*‰C");
=TEX

¹HOLCONST
Ü $Û*‰CÝ : Ö ­ Ö ­ Ö
÷üüüüüü
Üµ z w : Ö·
Ü	z *‰C w = (Re z * Re w - Im z * Im w, Re z * Im w + Im z * Re w)
°

=SML
declare_alias("*", ¬$*‰C®);
=TEX
\subsubsection{Embedding of the Real Numbers}


¹HOLCONST
Ü Û¯ÖÝ : ¯ ­ Ö
÷üüüüüü
Üµx· ¯Ö x = (x, î¯ 0)
°

¹HOLCONST
Ü Û¯ÉÝ : ¯ ­ Ö
÷üüüüüü
Üµx· ¯É x = (î¯ 0, x)
°
\subsubsection{The Imaginary Unit}

¹HOLCONST
Ü ÛI‰CÝ : Ö
÷üüüüüü
Ü I‰C =¯É 1.0
°
\subsubsection{Conjugation}
=SML
declare_postfix(320, "›_");
=TEX
¹HOLCONST
Ü Û$›_Ý : Ö ­ Ö
÷üüüüüü
Üµ z : Ö· z ›_ = (Re z, ~(Im z))
°
\subsubsection{Reciprocal}
=SML
declare_postfix(320, "›-›1›C");
=TEX

¹HOLCONST
Ü $Û›-›1›CÝ : Ö ­ Ö
÷üüüüüü
Üµ z : Ö· z ›-›1›C = z ›_ * ¯Ö(Re (z * z ›_) ›-›1)
°

=SML
declare_alias("›-›1", ¬$›-›1›C®);
=TEX


\subsubsection{Subtraction}
=SML
declare_infix(300, "-‰C");
=TEX

¹HOLCONST
Ü $Û-‰CÝ : Ö ­ Ö ­ Ö
÷üüüüüü
Üµ z w : Ö· z -‰C w = z + ~w
°



\subsubsection{Division}
=SML
declare_infix(315, "/‰C");
=TEX

¹HOLCONST
Ü $Û/‰CÝ : Ö ­ Ö ­ Ö
÷üüüüüü
Üµ z w : Ö· z /‰C w = z * (w ›-›1)
°


=SML
declare_alias("/", ¬$/‰C®);
=TEX
\subsubsection{Embedding of the Natural Numbers}


¹HOLCONST
Ü ÛîÖÝ : î ­ Ö
÷üüüüüü
Üµm· îÖ m = ¯Ö(î¯ m)
°


¹HOLCONST
Ü ÛîÉÝ : î ­ Ö
÷üüüüüü
Üµm· îÉ m = (0., î¯ m)
°

\subsubsection{Exponentiation with Natural Number Exponents}

=SML
declare_infix(320, "^‰C");
=TEX
¹HOLCONST
Ü $Û^‰CÝ : Ö ­ î ­ Ö
÷üüüüüü
Ü	(µ z: Ö· z ^‰C 0 = îÖ 1)
Ü ±	(µ z: Ö; m· z ^‰C (m+1) = z * z ^‰C m)
°

=SML
declare_alias("^", ¬$^‰C®);
=TEX
\subsection{Ö {\it qua} Real Normed Space}
=SML
declare_infix(310, "*‰RC");
=TEX

¹HOLCONST
Ü $Û*‰RCÝ : ¯ ­ Ö ­ Ö
÷üüüüüü
Üµ x: ¯; v : Ö·
Ü	x *‰RC v = ¯Ö x *‰C v
°

¹HOLCONST
Ü ÛAbs‰CÝ : Ö ­ ¯
÷üüüüüü
Üµ v : Ö·
Ü	Abs‰C v = Sqrt(Re (v * v ›_))
°
=SML
declare_alias("Abs", ¬Abs‰C®);
=TEX
\subsection{Transcendental Functions}
\subsubsection{Exponential}
¹HOLCONST
Ü ÛExp‰CÝ : Ö ­ Ö
÷üüüüüü
Ü µz· Exp‰C z = ¯Ö (Exp(Re z)) * (Cos (Im z), Sin (Im z))
°

=SML
declare_alias("Exp", ¬$Exp‰C®);
=TEX
\subsubsection{Group Structures}

We now define the additive and multiplicative groups of complex numbers.

¹HOLCONST
Ü ÛÖ‰+Ý :  Ö GROUP;
Ü ÛÖ‰*Ý :  Ö GROUP
÷üüüüüü
Ü	Ö‰+ = MkGROUP Universe $+ (îÖ 0) ~
Ü ±	Ö‰* = MkGROUP {x | ³x = îÖ 0} $* (îÖ 1) $›-›1
°


\section{POLYNOMIALS}\label{sec:polynomials}
As we did for the real numbers in \cite{LEMMA1/HOL/WRK066},
we define the set of polynomial function on the complex
numbers to be the smallest set of functions
that contains all constant functions and the identity function and that
is closed under pointwise addition and multiplication of functions.
¹HOLCONST
Ü ÛPolyFunc‰CÝ : (Ö ­ Ö) SET
÷üüüüüü
Ü PolyFunc‰C = ¥
Ü	{	A
Ü	|	(µc· (Ìx·c)  A)
Ü	±	(Ìx·x)  A
Ü	±	(µf g·f  A ± g  A ´ (Ìx·f x + g x)  A)
Ü	±	(µf g·f  A ± g  A ´ (Ìx·f x * g x)  A) }
°

The following function gives the $n$-th partial sum of a series.

¹HOLCONST
Ü ÛSeries‰CÝ : (î ­ Ö) ­ (î ­ Ö)
÷üüüüüü
Ü	(µs· Series‰C s 0 = îÖ 0)
Ü ±	(µs n· Series‰C s (n+1) = Series‰C s n + s n)
°

We represent a complex polynomial as a pair $(s, n)$ where $s$ is a sequence of coefficients and $n$ is a bound on the degree.
The following function maps such a pair to the polynomial function it represents.

¹HOLCONST
Ü ÛPoly‰CÝ : (î ­ Ö) ¸ î ­ Ö ­ Ö
÷üüüüüü
Ü	µs n z· Poly‰C (s, n) z = Series‰C (Ìi· s i * z^i) (n+1)
°
We now give the operations on coefficients that correspond to addition of polynomial functions \ldots

¹HOLCONST
Ü ÛPlusCoeffs‰CÝ : ((î ­ Ö) ¸ î) ­ ((î ­ Ö) ¸ î) ­ ((î ­ Ö) ¸ î)
÷üüüüüü
Ü µs m t n·
Ü	PlusCoeffs‰C (s, m) (t, n) =
Ü	((Ìi·	(if i ¼ m then s i else îÖ 0) +
Ü		(if i ¼ n then t i else îÖ 0)), m+n)
°

\ldots and to multiplication of one polynomial function by another.

¹HOLCONST
Ü ÛTimesCoeffs‰CÝ : ((î ­ Ö) ¸ î) ­ ((î ­ Ö) ¸ î) ­ ((î ­ Ö) ¸ î)
÷üüüüüü
Ü 	(µs t n· TimesCoeffs‰C (s, 0) (t, n) = ((Ìi· s 0 * t i), n))
Ü±	(µs m t n·
Ü	TimesCoeffs‰C (s, m+1) (t, n) =
Ü	PlusCoeffs‰C
Ü	(TimesCoeffs‰C (s, m) (t, n))
Ü	((Ìi· if i ¼ m then îÖ 0 else s (m+1) * t (i-(m+1))), m+n+1))
°

\section{TOPOLOGICAL ASPECTS}\label{sec:topology}
The standard topology on Ö is just the product topology:
¹HOLCONST
Ü ÛOpen‰CÝ : Ö SET SET
÷üüüüüü
Ü Open‰C = O‰R ¸‰T O‰R
°
As with 
=INLINEFT
Open‰R
=TEX
\ it is convenient to have a short name for the topology:
=SML
declare_alias("O‰C", ¬Open‰C®);
=TEX
The unit circle $S^1$:
¹HOLCONST
Ü ÛS1Ý : Ö SET
÷üüüüüü
Ü S1 = {z | Abs‰C z = 1.}
°
=TEX
The topology on the unit circle:
¹HOLCONST
Ü ÛOpen‰S1Ý : Ö SET SET
÷üüüüüü
Ü Open‰S1 = S1 ò‰T O‰C
°
Again it is convenient to have a short name for the topology:
=SML
declare_alias("O‰S1", ¬Open‰S1®);
=TEX
and the exponential mapping of the real line onto the unit circle:
¹HOLCONST
Ü ÛExpS1Ý : ¯ ­ Ö
÷üüüüüü
Ü µt· ExpS1 t = (Cos t, Sin t)
°

The degree of a loop in the unit circle:
¹HOLCONST
Ü ÛLoopS1DegreeÝ : (¯ ­ Ö) ­ ú
÷üüüüüü
Ü µx f g·
Ü	f  Loops(O‰S1, x) ± g  Paths O‰R ± (µs· ExpS1(g s) = f s)
Ü ´	g 1. - g 0. = 2. * ú¯ (LoopS1Degree f) * Ð
°
The generator of the fundamental group of the circle.
¹HOLCONST
Ü ÛIotaS1Ý : ¯ ­ Ö
÷üüüüüü
Ü IotaS1 = (Ìt· if t ¼ 0. ² 1. ¼ t then îÖ 1 else ExpS1(2. * Ð * t))
°
The function that converts a self-mapping of the unit circle into a loop.
¹HOLCONST
Ü ÛS1S1LoopÝ : (Ö ­ Ö) ­ (¯ ­ Ö)
÷üüüüüü
Ü µf·	S1S1Loop f = (Ìt· f (IotaS1 t))
°

The degree of a self-mapping of the unit circle:
¹HOLCONST
Ü ÛS1S1DegreeÝ : (Ö ­ Ö) ­ ú
÷üüüüüü
Ü µf·	S1S1Degree f = LoopS1Degree (S1S1Loop f)
°

The degree of an element of the fundamental group of the unit circle:
¹HOLCONST
Ü ÛClassS1DegreeÝ : (¯ ­ Ö) ð ­ ú
÷üüüüüü
Ü µx p f·
Ü	p  Loops(O‰S1, x) / PathHomotopic O‰S1 ± f  p
Ü ´	ClassS1Degree p = LoopS1Degree f
°

=TEX
%\twocolumn[\section{INDEX}\label{INDEX}]
%{\printindex}

\bibliographystyle{fmu}
\bibliography{fmu}

\appendix
{\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{wrk072.th}}


\twocolumn[\section*{INDEX}\label{INDEX}]
\addcontentsline{toc}{section}{INDEX}
{\small\printindex}

=TEX
\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
\ftlinepenalty=9999
\section{PROOFS}

\subsection{Preamble}

=TEX
Set context for proofs in case of future expansion.
=SML
open_theory"Ö";
set_merge_pcs["basic_hol1", "'ú", "'¯", "'sets_alg"];
=TEX
Give ML bindings for the defining properties:
%%%%
%%%%
=SML

val ÛÖ_plus_defÝ = get_spec ¬$+‰C®;
val ÛÖ_minus_defÝ = get_spec ¬~‰C®;
val ÛÖ_conj_defÝ = get_spec ¬$›_®;
val ÛÖ_times_defÝ = get_spec ¬$*‰C®;
val ÛÖ_recip_defÝ = get_spec ¬$›-›1›C®;
val ÛÖ_subtract_defÝ = get_spec ¬$-‰C®;
val ÛîÖ_defÝ = get_spec ¬îÖ®;
val Û¯Ö_defÝ = get_spec ¬¯Ö®;
val ÛîÉ_defÝ = get_spec ¬îÉ®;
val Û¯É_defÝ = get_spec ¬¯É®;
val ÛÖ_i_defÝ = get_spec ¬I‰C®;
val Û¯_Ö_times_defÝ = get_spec ¬$*‰RC®;
val ÛÖ_î_exp_defÝ = get_spec ¬$^‰C®;
val ÛÖ_abs_defÝ = get_spec ¬Abs‰C®;
val ÛÖ_ops_defsÝ = [Ö_plus_def, Ö_minus_def, Ö_conj_def, Ö_times_def,
	Ö_recip_def, Ö_subtract_def, îÖ_def, ¯Ö_def, Ö_î_exp_def, Ö_abs_def];
val ÛÖ_additive_defÝ = get_spec¬Ö‰+®;
val ÛÖ_multiplicative_defÝ = get_spec¬Ö‰*®;
val ÛÖ_poly_func_defÝ = get_spec ¬PolyFunc‰C®;
val ÛÖ_series_defÝ = get_spec ¬Series‰C®;
val ÛÖ_poly_defÝ = get_spec ¬Poly‰C®;
val ÛÖ_plus_coeffs_defÝ = get_spec ¬PlusCoeffs‰C®;
val ÛÖ_times_coeffs_defÝ = get_spec ¬TimesCoeffs‰C®;
val Ûopen_Ö_defÝ = get_spec ¬O‰C®;
val Ûs1_defÝ = get_spec ¬S1®;
val Ûopen_s1_defÝ = get_spec ¬O‰S1®;
val ÛÖ_exp_defÝ = get_spec ¬Exp‰C®;
val Ûexp_s1_defÝ = get_spec ¬ExpS1®;
val Ûexp_s1_def1Ý = ¤_t_elim (rewrite_conv[exp_s1_def]
	¬ExpS1 = (Ì x· (Cos x, Sin x))®);
val Ûiota_s1_defÝ = get_spec ¬IotaS1®;
val Ûs1_s1_loop_defÝ = get_spec ¬S1S1Loop®;
val Ûs1_s1_degree_defÝ = get_spec ¬S1S1Degree®;

=TEX

\subsection{Tools}
The following could usefully go elsewhere:


=SML
val Ûun_È_convÝ : CONV =
	simple_eq_match_conv
		(conv_rule(ONCE_MAP_C eq_sym_conv) È_axiom);

=TEX
=TEX
\subsection{Basic Algebraic Properties}

%%%%
%%%%
=SML

val ÛÖ_plus_comm_thmÝ = save_thm( "Ö_plus_comm_thm", (
set_goal([], ¬µ x y:Ö· x + y = y + x®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛÖ_plus_assoc_thmÝ = save_thm( "Ö_plus_assoc_thm", (
set_goal([], ¬µ x y z:Ö· (x + y) + z = x + y + z®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

val ÛÖ_plus_assoc_thm1Ý = save_thm ("Ö_plus_assoc_thm1",
	conv_rule(ONCE_MAP_C eq_sym_conv) Ö_plus_assoc_thm);
=SML

val ÛÖ_plus_0_thmÝ = save_thm( "Ö_plus_0_thm", (
set_goal([], ¬µ x:Ö· x + îÖ 0 = x ± îÖ0 + x = x®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

=SML

val ÛÖ_plus_minus_thmÝ = save_thm( "Ö_plus_minus_thm", (
set_goal([], ¬µ x:Ö· x + ~x = îÖ 0 ± ~x + x = îÖ 0®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛÖ_times_conj_thmÝ = save_thm( "Ö_times_conj_thm", (
set_goal([], ¬µ x:Ö·
	x * (x ›_) = ¯Ö(Re x ^ 2 + Im x ^ 2)
®);
a(rewrite_tac (¯_î_exp_square_thm::Ö_ops_defs) THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛÖ_times_comm_thmÝ = save_thm( "Ö_times_comm_thm", (
set_goal([], ¬µ x y:Ö· x * y = y * x®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛÖ_times_assoc_thmÝ = save_thm( "Ö_times_assoc_thm", (
set_goal([], ¬µ x y z:Ö· (x * y) * z = x * y * z®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

val ÛÖ_times_assoc_thm1Ý = save_thm ("Ö_times_assoc_thm1",
	conv_rule(ONCE_MAP_C eq_sym_conv) Ö_times_assoc_thm);

=TEX
=SML

val ÛÖ_times_1_thmÝ = save_thm( "Ö_times_1_thm", (
set_goal([], ¬µ x:Ö· x * îÖ 1 = x ± îÖ 1 * x = x®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
=SML


val Û¯_square_plus_square_eq_0_thmÝ = save_thm( "¯_square_plus_square_eq_0_thm", (
set_goal([], ¬
	µ x y· x^2 + y^2 = 0. ¤ x = 0. ± y = 0.
®);
a(REPEAT_UNTIL is_¤ strip_tac THEN ¤_tac THEN_TRY asm_rewrite_tac[]);
a(strip_asm_tac(µ_elim¬x® ¯_0_¼_square_thm));
a(strip_asm_tac(µ_elim¬y® ¯_0_¼_square_thm));
a(LEMMA_T ¬x ^ 2 = 0. ± y ^ 2  = 0.® ante_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a(rewrite_tac[¯_square_eq_0_thm]);
pop_thm()
));


=TEX
=SML

val ÛÖ_times_recip_thmÝ = save_thm( "Ö_times_recip_thm", (
set_goal([], ¬µ x:Ö· ³x = îÖ 0 ´ x * x ›-›1 = îÖ 1®);
a(rewrite_tac [Ö_recip_def, Ö_times_conj_thm]);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) Ö_times_assoc_thm, Ö_times_conj_thm]);
a(rewrite_tac Ö_ops_defs);
a(µ_tac THEN STRIP_T asm_tac);
a(bc_thm_tac (rewrite_rule[](nth 2 (fc_canon(±_left_elim ¯_recip_clauses)))));
a(asm_rewrite_tac[¯_square_plus_square_eq_0_thm]);
pop_thm()
));

val ÛÖ_times_recip_thm1Ý = save_thm ("Ö_times_recip_thm1",
	conv_rule(once_rewrite_conv[Ö_times_comm_thm]) Ö_times_recip_thm);

=TEX

%%%%
%%%%
=SML

val ÛÖ_times_eq_1_thmÝ = save_thm( "Ö_times_eq_1_thm", (
set_goal([], ¬µ z w:Ö· ³z = îÖ 0 ± z*w = îÖ 1 ´ w = z ›-›1®);
a(REPEAT strip_tac);
a(LEMMA_T¬z ›-›1 * z * w = z ›-›1® ante_tac
	THEN1 asm_rewrite_tac[Ö_times_1_thm]);
a(rewrite_tac[Ö_times_assoc_thm1]);
a(conv_tac(LEFT_C(LEFT_C(once_rewrite_conv[Ö_times_comm_thm]))));
a(ALL_FC_T rewrite_tac[Ö_times_recip_thm1]);
a(rewrite_tac[Ö_times_1_thm]);
pop_thm()
));




=TEX

%%%%
%%%%
=SML

val ÛÖ_times_plus_distrib_thmÝ = save_thm( "Ö_times_plus_distrib_thm", (
set_goal([], ¬µ x y z:Ö·
	x * (y + z) = x * y + x * z
±	(x + y) * z = x * z + y * z®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛÖ_conj_plus_homomorphism_thmÝ = save_thm( "Ö_conj_plus_homomorphism_thm", (
set_goal([], ¬µ x y:Ö· (x + y) ›_  = x ›_ + y ›_®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛÖ_conj_times_homomorphism_thmÝ = save_thm( "Ö_conj_times_homomorphism_thm", (
set_goal([], ¬µ x y:Ö· (x * y) ›_  = x ›_ * y ›_®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val Û¯Ö_plus_homomorphism_thmÝ = save_thm( "¯Ö_plus_homomorphism_thm", (
set_goal([], ¬µ x y:¯· ¯Ö(x + y) = ¯Ö x + ¯Ö y®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val Û¯Ö_times_homomorphism_thmÝ = save_thm( "¯Ö_times_homomorphism_thm", (
set_goal([], ¬µ x y:¯· ¯Ö(x * y) = ¯Ö x * ¯Ö y®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛîÖ_plus_homomorphism_thmÝ = save_thm( "îÖ_plus_homomorphism_thm", (
set_goal([], ¬µ x y:î· îÖ(x + y) = îÖ x + îÖ y®);
a(rewrite_tac (î¯_plus_homomorphism_thm::Ö_ops_defs));
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛîÖ_one_one_thmÝ = save_thm( "îÖ_one_one_thm", (
set_goal([], ¬µ m n:î· îÖ m = îÖ n ¤ m = n®);
a(rewrite_tac (î¯_one_one_thm::Ö_ops_defs));
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛîÖ_times_homomorphism_thmÝ = save_thm( "îÖ_times_homomorphism_thm", (
set_goal([], ¬µ x y:î· îÖ(x * y) = îÖ x * îÖ y®);
a(rewrite_tac (î¯_times_homomorphism_thm::Ö_ops_defs));
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛÖ_plus_order_thmÝ = (
set_goal([], ¬µx y z:Ö·
	y + x = x + y
±	(x + y) + z = x + y + z
±	y + x + z = x + y + z	®);
a(REPEAT µ_tac THEN rewrite_tac[Ö_plus_assoc_thm]);
a(rewrite_tac[µ_elim¬y® Ö_plus_comm_thm, Ö_plus_assoc_thm]);
save_pop_thm"Ö_plus_order_thm"
);

=TEX

%%%%
%%%%
=SML
val ÛÖ_eq_thmÝ = (
set_goal([], ¬µ x y : Ö · x = y ¤ x + ~y = îÖ 0®);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[Ö_plus_minus_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¬(x + ~ y) + y = îÖ 0 + y® ante_tac THEN1 asm_rewrite_tac[]);
a(rewrite_tac[Ö_plus_assoc_thm, Ö_plus_minus_thm, Ö_plus_0_thm]);
save_pop_thm"Ö_eq_thm"
);
=TEX

%%%%
%%%%
=SML

val ÛÖ_minus_clausesÝ = (
set_goal([], ¬µx y : Ö·
		~ (~ x) = x
	±	x + ~ x = îÖ 0
	±	~ x + x = îÖ 0
	±	~ (x + y) = ~ x + ~ y
	± 	~(îÖ 0) = (îÖ 0)®);
a(REPEAT µ_tac);
a(rewrite_tac[Ö_plus_minus_thm]);
a(lemma_tac¬µx:Ö·~(~ x) = x®);
(* *** Goal "1" *** *)
a(strip_tac THEN once_rewrite_tac[Ö_eq_thm]);
a(rewrite_tac[Ö_plus_minus_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[] THEN strip_tac);
(* *** Goal "2.1" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[Ö_eq_thm]);
a(asm_rewrite_tac[µ_elim¬~ y®Ö_plus_order_thm]);
a(rewrite_tac[µ_elim¬y®Ö_plus_order_thm, Ö_plus_minus_thm, Ö_plus_0_thm]);
(* *** Goal "2.2" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[Ö_eq_thm]);
a(asm_rewrite_tac[Ö_plus_0_thm]);
save_pop_thm"Ö_minus_clauses"
);

=TEX

%%%%
%%%%
=SML


val ÛÖ_plus_clausesÝ = (
set_goal([], ¬
	µ x y z:Ö·
	(x + z = y + z ¤ x = y)
±	(z + x = y + z ¤ x = y)
±	(x + z = z + y ¤ x = y)
±	(z + x = z + y ¤ x = y)
±	(x + z = z ¤ x = îÖ 0)
±	(z + x = z ¤ x = îÖ 0)
±	(z = z + y ¤ y = îÖ 0)
±	(z = y + z ¤ y = îÖ 0)
±	x + îÖ 0 = x
±	îÖ 0 + x = x
±	³ îÖ 1 = îÖ 0
±	³ îÖ 0 = îÖ 1
®);
a(REPEAT µ_tac);
a(rewrite_tac[Ö_plus_0_thm, îÖ_one_one_thm, plus_clauses,
	µ_elim¬z® Ö_plus_order_thm]);
a(once_rewrite_tac[µ_elim¬z + x® Ö_eq_thm]);
a(once_rewrite_tac[µ_elim¬z® Ö_eq_thm]);
a(rewrite_tac[Ö_minus_clauses, µ_elim¬~ z® Ö_plus_order_thm]);
a(rewrite_tac[Ö_plus_assoc_thm1, Ö_minus_clauses, Ö_plus_0_thm]);
a(once_rewrite_tac[µ_elim¬x® Ö_eq_thm]);
a(rewrite_tac[]);
a(conv_tac(LEFT_C eq_sym_conv));
a(once_rewrite_tac[µ_elim¬îÖ 0® Ö_eq_thm]);
a(rewrite_tac[Ö_minus_clauses, Ö_plus_0_thm]);
save_pop_thm"Ö_plus_clauses"
);

=TEX

%%%%
%%%%
=SML

val ÛÖ_times_order_thmÝ = (
set_goal([], ¬µ x : Ö · µ y z ·
		y * x = x * y
	±	(x * y) * z = x * y * z
	±	y * x * z = x * y * z®);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [list_µ_elim [¬y®,¬x®] Ö_times_comm_thm]);
(* *** Goal "2" *** *)
a (rewrite_tac [all_µ_elim Ö_times_assoc_thm]);
(* *** Goal "3" *** *)
a (rewrite_tac [list_µ_elim [¬y®,¬x®,¬z®] Ö_times_assoc_thm1]);
a (once_rewrite_tac [list_µ_elim [¬y®,¬x®] Ö_times_comm_thm]);
a (rewrite_tac [Ö_times_assoc_thm]);
save_pop_thm "Ö_times_order_thm"
);

=TEX

%%%%
%%%%
=SML

val ÛÖ_times_0_thm1Ý = (
set_goal([], ¬µx:Ö· x * îÖ 0 = îÖ 0®);
a(accept_tac(
	all_µ_intro
	(rewrite_rule[Ö_plus_clauses, Ö_plus_0_thm](prove_rule[Ö_times_plus_distrib_thm]
	¬x*(îÖ 0 + îÖ 0) = x * îÖ 0 + x * îÖ 0®))));
pop_thm()
);

=TEX

%%%%
%%%%
=SML

val ÛÖ_times_0_thmÝ = (
set_goal([], ¬µx:Ö· x * îÖ 0 = îÖ 0 ± îÖ 0 * x = îÖ 0®);
a(rewrite_tac[µ_elim¬x:Ö®Ö_times_order_thm, Ö_times_0_thm1]);
save_pop_thm "Ö_times_0_thm"
);

=TEX
=SML
val ÛÖ_times_eq_0_thmÝ = save_thm( "Ö_times_eq_0_thm", (
set_goal([], ¬
	µx y:Ö· x*y = îÖ 0 ´ x = îÖ 0 ² y = îÖ 0
®);
a(contr_tac THEN all_fc_tac[Ö_times_recip_thm1]);
a(LEMMA_T¬y = (x ›-›1 * x) * y® ante_tac THEN1 asm_rewrite_tac[]
	THEN rewrite_tac[Ö_times_assoc_thm, Ö_times_1_thm]
	THEN asm_rewrite_tac[Ö_times_0_thm]);
pop_thm()
));


=TEX
=SML

val ÛÖ_times_eq_0_thm1Ý = save_thm( "Ö_times_eq_0_thm1", (
set_goal([], ¬
	µx y:Ö· x*y = îÖ 0 ¤ x = îÖ 0 ² y = îÖ 0
®);
a(REPEAT_UNTIL is_² strip_tac THEN1 bc_thm_tac Ö_times_eq_0_thm THEN REPEAT strip_tac
	THEN asm_rewrite_tac[Ö_times_0_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛÖ_times_clausesÝ = (
set_goal ([], ¬µ x · îÖ 0 * x = îÖ 0 ± x * îÖ 0 = îÖ 0 ± x * îÖ 1 = x ± îÖ 1 * x = x®);
a(rewrite_tac[Ö_times_0_thm, Ö_times_1_thm]);
save_pop_thm "Ö_times_clauses"
);

=TEX

%%%%
%%%%
=SML

val ÛÖ_times_minus_thm1Ý = (
set_goal([], ¬µx y:Ö· x * ~ y = ~(x * y)®);
a(REPEAT strip_tac);
a(lemma_tac ¬x * ~ y + x * y = îÖ 0®);
(* *** Goal "1" *** *)
a(LEMMA_T ¬x * ~ y + x * y = x * (~y + y)® rewrite_thm_tac
	THEN1 rewrite_tac[Ö_times_plus_distrib_thm]);
a(rewrite_tac[Ö_minus_clauses, Ö_times_0_thm1]);
(* *** Goal "2" *** *)
a(once_rewrite_tac[Ö_eq_thm]);
a(asm_rewrite_tac[Ö_minus_clauses]);
pop_thm()
);

=TEX

%%%%
%%%%
=SML

val ÛÖ_times_minus_thmÝ = (
set_goal([], ¬µx y:Ö· ~x * y = ~(x * y) ± x * ~ y = ~(x * y) ± ~x * ~y = x * y®);
a(REPEAT µ_tac);
a(rewrite_tac[µ_elim¬y®Ö_times_order_thm]);
a(rewrite_tac[Ö_times_minus_thm1]);
a(rewrite_tac[µ_elim¬y®Ö_times_order_thm]);
a(rewrite_tac[Ö_times_minus_thm1, Ö_minus_clauses]);
save_pop_thm"Ö_times_minus_thm"
);

=TEX

%%%%
%%%%
=SML

val ÛÖ_î_exp_1_thmÝ = (
set_goal ([], ¬µ n : î · îÖ 1^n = îÖ 1®);
a(REPEAT strip_tac THEN induction_tac¬n:î®
	THEN asm_rewrite_tac[Ö_î_exp_def, Ö_times_clauses]);
save_pop_thm "Ö_î_exp_1_thm"
);

=TEX

%%%%
%%%%
=SML

val ÛÖ_î_exp_0_thmÝ = (
set_goal ([], ¬µ n : î · îÖ 0^(n+1) = îÖ 0®);
a(REPEAT strip_tac THEN induction_tac¬n:î®
	THEN asm_rewrite_tac[Ö_î_exp_def, Ö_times_clauses]);
save_pop_thm "Ö_î_exp_0_thm"
);

=TEX

Note the following is primarily intended for the case when the exponent is a numeric literal (and will loop unless used with care).

%%%%
%%%%
=SML

val ÛÖ_î_exp_rw_thmÝ = (
set_goal ([], ¬µ z :Ö; n : î· z^n = if n = 0 then îÖ 1 else z * z^(n-1)®);
a(REPEAT strip_tac THEN induction_tac¬n:î®
	THEN asm_rewrite_tac[Ö_î_exp_def]);
save_pop_thm "Ö_î_exp_rw_thm"
);

=TEX

%%%%
%%%%
=SML

val ÛÖ_î_exp_plus_thmÝ = (
set_goal ([], ¬µ z :Ö; m n : î· z^(m+n) = z^m * z^n®);
a(REPEAT strip_tac THEN induction_tac¬n:î®
	THEN asm_rewrite_tac[Ö_î_exp_def, plus_assoc_thm1, Ö_times_clauses]);
a(rewrite_tac[µ_elim¬z® Ö_times_order_thm]);
save_pop_thm "Ö_î_exp_plus_thm"
);

=TEX

%%%%
%%%%
=SML

val ÛÖ_î_exp_clausesÝ = (
set_goal ([], ¬µ z :Ö; n : î · z^0 = îÖ 1 ± z^1 = z ± îÖ 1^n = îÖ 1 ± îÖ 0^(n+1) = îÖ 0®);
a(rewrite_tac[Ö_î_exp_1_thm, Ö_î_exp_0_thm]);
a(once_rewrite_tac[Ö_î_exp_rw_thm] THEN rewrite_tac[]);
a(once_rewrite_tac[Ö_î_exp_rw_thm] THEN rewrite_tac[Ö_times_clauses]);
save_pop_thm "Ö_î_exp_clauses"
);

=TEX
\subsection{A Proof Context}
\section{PROOF CONTEXT}

=TEX

=SML
fun Ûthms_to_eqn_cxtÝ (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt (current_ad_rw_canon())) thms)
);
=TEX
=SML
val _ = delete_pc "'Ö" handle Fail _ => ();
val _ = new_pc "'Ö";
(*
val _ = set_rw_eqn_cxt
		[	(¬x +‰R y®, ¯_plus_conv),
			(¬x *‰R y®, ¯_times_conv),
			(¬x -‰R y®, ¯_subtract_conv),
			(¬Abs‰R x®, ¯_abs_conv),
			(¬x /‰R y®, ¯_over_conv),
			(¬x ›-›1®, ¯_recip_conv),
			(¬x ^‰N m®, ¯_î_exp_conv),
			(¬x ^‰Z i®, ¯_ú_exp_conv),
			(¬(x:¯) = y®, ¯_eq_conv),
			(¬x ¼‰R y®, ¯_¼_conv),
			(¬x <‰R y®, ¯_less_conv),
			(¬x ¾‰R y®, ¯_¾_conv),
			(¬x >‰R y®, ¯_greater_conv),
			(¬m /‰N m®, ¯_frac_norm_conv),
			(¬Float x p (îú 0)®, float_conv),
			(¬Max‰R [x]®, ¯_max_conv),
			(¬Max‰R (Cons x (Cons y z))®, ¯_max_conv),
			(¬Min‰R [x]®, ¯_min_conv),
			(¬Min‰R (Cons x (Cons y z))®, ¯_min_conv)
		] "'Ö";
*)
val _ = add_rw_thms [Ö_plus_clauses, Ö_minus_clauses, Ö_times_clauses, Ö_î_exp_clauses]
	"'Ö";
(*
val ÛposÝ = (thms_to_eqn_cxt [¯_minus_clauses, ¯_¼_clauses, ¯_less_clauses]) @
		[	(¬(x:¯) = y®, ¯_eq_conv),
			(¬x ¾‰R y®, ¯_¾_conv),
			(¬x >‰R y®, ¯_greater_conv)];
val ÛnegÝ = mapfilter (mk_³ ** RAND_C) pos;
val ÛneutralÝ = [(¬x ¼‰R y®, ¯_¼_conv), (¬x <‰R y®, ¯_less_conv)];
val Ûstrip_eqn_cxtÝ = neutral @ pos @ neg;
val _ = set_st_eqn_cxt strip_eqn_cxt "'Ö";
val _ = set_sc_eqn_cxt strip_eqn_cxt "'Ö";
*)

val _ = set_pr_tac basic_prove_tac "'Ö";
val _ = set_pr_conv basic_prove_conv "'Ö";

(*
val _ = commit_pc "'Ö";
*)

val _ = set_merge_pcs["basic_hol1", "'ú", "'¯", "'sets_alg", "'Ö"];


=TEX

%%%%
%%%%
=SML

val ÛÖ_î_exp_times_thmÝ = save_thm( "Ö_î_exp_times_thm", (
set_goal([], ¬µn; z w : Ö·
	(z * w)^n = z^n * w^n
®);
a(REPEAT strip_tac THEN induction_tac¬n:î® THEN asm_rewrite_tac[Ö_î_exp_def]);
a(rewrite_tac[Ö_times_assoc_thm]);
a(rewrite_tac[µ_elim¬w® Ö_times_order_thm]);
pop_thm()
));


=TEX

%%%%
%%%%
=SML

val ÛÖ_î_exp_³_eq_0_thmÝ = save_thm( "Ö_î_exp_³_eq_0_thm", (
set_goal([], ¬µn; z : Ö·
	³z = îÖ 0 ´ ³z^n = îÖ 0
®);
a(REPEAT strip_tac THEN induction_tac¬n:î® THEN asm_rewrite_tac[Ö_î_exp_def]);
a(contr_tac THEN all_fc_tac[Ö_times_eq_0_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛÖ_î_exp_recip_thmÝ = save_thm( "Ö_î_exp_recip_thm", (
set_goal([], ¬µn; z : Ö·
	³z = îÖ 0 ´ (z ›-›1)^n = (z^n)›-›1
®);
a(REPEAT strip_tac THEN bc_thm_tac Ö_times_eq_1_thm);
a(REPEAT strip_tac THEN1 ALL_FC_T rewrite_tac[Ö_î_exp_³_eq_0_thm]);
a(induction_tac¬n® THEN rewrite_tac[Ö_î_exp_def]);
a(rewrite_tac[Ö_times_assoc_thm] THEN asm_rewrite_tac[µ_elim¬z ›-›1® Ö_times_order_thm]);
a(ALL_FC_T rewrite_tac[Ö_times_recip_thm1]);
pop_thm()
));


=TEX

%%%%
%%%%
=SML

val ÛÖ_î_exp_minus_thmÝ = save_thm( "Ö_î_exp_minus_thm", (
set_goal([], ¬µm n; z : Ö·
	m ¼ n ± ³z = îÖ 0
´	z^(n - m) = z^n * (z^m)›-›1
®);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 ante_tac THEN intro_µ_tac1¬m® THEN induction_tac¬n®
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac Ö_ops_defs);
(* *** Goal "2" *** *)
a(cases_tac¬m' ¼ n®);
(* *** Goal "2.1" *** *)
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac);
a(LEMMA_T ¬(n + 1) - m' = (n - m') + 1® rewrite_thm_tac);
(* *** Goal "2.1.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN DROP_ASMS_T discard_tac);
a(rewrite_tac[¼_def] THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(rewrite_tac[plus_assoc_thm]);
(* *** Goal "2.1.2" *** *)
a(asm_rewrite_tac[Ö_î_exp_def, Ö_times_assoc_thm]);
(* *** Goal "2.2" *** *)
a(lemma_tac ¬m' = n + 1® THEN1 PC_T1 "lin_arith" asm_prove_tac[] THEN all_var_elim_asm_tac1);
a(rewrite_tac[Ö_î_exp_def] THEN conv_tac eq_sym_conv);
a(bc_thm_tac Ö_times_recip_thm);
a(asm_rewrite_tac[Ö_times_eq_0_thm1]);
a(ALL_FC_T rewrite_tac[Ö_î_exp_³_eq_0_thm]);
pop_thm()
));



=TEX
\subsection{Additive and Multiplicative Group Properties}
=TEX
=SML
set_goal([], ¬
	Ö‰+  Group
®);
a(rewrite_tac[Ö_additive_def, group_def, group_ops_def, Ö_plus_assoc_thm]);
val ÛÖ_additive_group_thmÝ = save_pop_thm "Ö_additive_group_thm";



=TEX
=SML
set_goal([], ¬
	Ö‰*  Group
®);
a(rewrite_tac[Ö_multiplicative_def, group_def, group_ops_def, Ö_times_assoc_thm]);
a(contr_tac THEN fc_tac[Ö_times_eq_0_thm, Ö_times_recip_thm1, Ö_times_recip_thm]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
val ÛÖ_multiplicative_group_thmÝ = save_pop_thm "Ö_multiplicative_group_thm";

=TEX
=SML
set_goal([], ¬
	Car Ö‰+ = Universe
±	(µx y:Ö· (x . y) Ö‰+ = x + y)
±	Unit Ö‰+ = îÖ 0
±	(µx:Ö· (x ›~) Ö‰+ = ~x)
®);
a(rewrite_tac[Ö_additive_def, group_ops_def]);
val ÛÖ_additive_ops_thmÝ = save_pop_thm "Ö_additive_ops_thm";
=TEX
=SML
set_goal([], ¬
	Car Ö‰* = {x | ³x = îÖ 0}
±	(µx y:Ö· (x . y) Ö‰* = x * y)
±	Unit Ö‰* = îÖ 1
±	(µx:Ö· (x ›~) Ö‰* = x ›-›1)
®);
a(rewrite_tac[Ö_multiplicative_def, group_ops_def]);
val ÛÖ_multiplicative_ops_thmÝ = save_pop_thm "Ö_multiplicative_ops_thm";

=TEX
=SML
set_goal([], ¬Ö‰+ = ¯‰+ ¸‰G ¯‰+®);
a(rewrite_tac[group_eq_group_thm]);
a(rewrite_tac[Ö_additive_def, group_ops_def, ¸_group_def, ¯_additive_ops_thm]);
a(rewrite_tac[Ö_plus_def, Ö_minus_def, îÖ_def, ¯Ö_def, ¸_def]);
a(PC_T1"sets_ext1" rewrite_tac[]);
val ÛÖ_eq_¯_¸_¯_thmÝ = save_pop_thm "Ö_eq_¯_¸_¯_thm";

=TEX
=SML
val ÛÖ_additive_Ö_multiplicative_homomorphism_defÝ =
	save_thm("Ö_additive_Ö_multiplicative_homomorphism_def",
		rewrite_rule[Ö_multiplicative_ops_thm, Ö_additive_ops_thm]
			 (list_µ_elim[¬Ö‰+®, ¬Ö‰*®] homomorphism_def));

=TEX
=SML
set_goal([], ¬
	Exp  Homomorphism(Ö‰+, Ö‰*)
®);
a(rewrite_tac[ Ö_additive_Ö_multiplicative_homomorphism_def]);
a(conv_tac (TOP_MAP_C Ì_pair_conv));
a(rewrite_tac[Ö_exp_def, exp_clauses, Ö_plus_def, Ö_times_def, ¯Ö_def, îÖ_def,
	sin_cos_plus_thm]);
a(conv_tac (MAP_C ¯_anf_conv));
a(contr_tac);
a(lemma_tac¬³Exp x1 = 0.® THEN1 rewrite_tac[exp_³_eq_0_thm]);
a(fc_tac[¯_times_eq_0_thm]);
a(ante_tac(µ_elim¬x2® cos_squared_plus_sin_squared_thm));
a(asm_rewrite_tac[]);
val ÛÖ_exp_homomorphism_thmÝ = save_pop_thm "Ö_exp_homomorphism_thm";

=TEX
=SML
set_goal([], ¬µc·
	(Ìx·c * x)  Homomorphism(Ö‰+, Ö‰+)
®);
a(rewrite_tac[Ö_additive_def, group_ops_def, homomorphism_def, Ö_times_plus_distrib_thm]);
val ÛÖ_linear_homomorphism_thmÝ = save_pop_thm "Ö_linear_homomorphism_thm";


=TEX
\subsection{de Moivre's Theorem}

%%%%
%%%%
=SML

val Ûde_moivre_thmÝ = save_thm( "de_moivre_thm", (
set_goal([], ¬µ x m·
	(Cos x, Sin x) ^ m =
	(Cos (î¯ m * x), Sin (î¯ m * x))
®);
a(REPEAT µ_tac THEN induction_tac¬m:î®
	THEN asm_rewrite_tac 
	(sin_def::î¯_plus_homomorphism_thm::
		¯_times_plus_distrib_thm::
		sin_cos_plus_thm::Ö_ops_defs));
a(PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
\subsection{Polynomials}

The following is useful for evaluaating partial sums of series of specific known length:
%%%%
%%%%
=SML

val ÛÖ_series_rw_thmÝ = save_thm ("Ö_series_rw_thm", (
set_goal([], ¬µs n· Series‰C s n = if n = 0 then îÖ 0 else s (n-1) + Series‰C s (n-1)®);
a(REPEAT strip_tac THEN induction_tac¬n:î®
	THEN asm_rewrite_tac[Ö_series_def]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML
val ÛÖ_poly_rec_thmÝ = save_thm( "Ö_poly_rec_thm", (
set_goal([], ¬
	(µs z· Poly‰C (s, 0) z = s 0)
±	(µs n z· Poly‰C (s, (n+1)) z = Poly‰C (s, n) z + s(n+1) * z^(n+1))
®);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[Ö_poly_def]);
a(REPEAT (once_rewrite_tac[Ö_series_rw_thm] THEN rewrite_tac[]));
(* *** Goal "2" *** *)
a(rewrite_tac[Ö_poly_def]);
a(conv_tac (LEFT_C (once_rewrite_conv[Ö_series_def])));
a(rewrite_tac[]);
pop_thm()
));


=TEX


%%%%
%%%%
=SML


val ÛÖ_poly_eq_thm1Ý = save_thm( "Ö_poly_eq_thm1", (
set_goal([], ¬µs t m z·
	(µi· i ¼ m ´ s i = t i)
´	Poly‰C (s, m) z = Poly‰C (t, m) z
®);
a(REPEAT µ_tac THEN induction_tac¬m:î®
	THEN asm_rewrite_tac[Ö_poly_rec_thm]);
(* *** Goal "1" *** *)
a(STRIP_T bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(STRIP_T (strip_asm_tac o µ_elim¬i®)
	THEN i_contr_tac THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(STRIP_T (strip_asm_tac o µ_elim¬m+1®) THEN asm_rewrite_tac[]);
pop_thm()
));

=TEX


%%%%
%%%%
=SML


val ÛÖ_poly_eq_thm2Ý = save_thm( "Ö_poly_eq_thm2", (
set_goal([], ¬µs m n z·
	(µi· m < i ´ s i = îÖ 0)
±	m ¼ n
´	Poly‰C (s, m) z = Poly‰C (s, n) z
®);
a(REPEAT µ_tac THEN induction_tac¬n:î®
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[Ö_poly_rec_thm]);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¬m = n + 1® THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[Ö_poly_rec_thm]);
(* *** Goal "3" *** *)
a(cases_tac¬m < n + 1® THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(lemma_tac¬m = n + 1® THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 5 ante_tac THEN all_var_elim_asm_tac1);
a(rewrite_tac[Ö_poly_rec_thm]);
pop_thm()
));


=TEX


%%%%
%%%%
=SML

val ÛÖ_poly_eq_thmÝ = save_thm( "Ö_poly_eq_thm", (
set_goal([], ¬µs t m n z·
	(µi· i ¼ m ´ s i = t i)
±	(µi· m < i ´ t i = îÖ 0)
±	m ¼ n
´	Poly‰C (s, m) z = Poly‰C (t, n) z
®);
a(REPEAT strip_tac);
a(LEMMA_T¬Poly‰C (t, n) z = Poly‰C (t, m) z® rewrite_thm_tac
	THEN1 ALL_FC_T rewrite_tac[Ö_poly_eq_thm2]);
a(bc_thm_tac Ö_poly_eq_thm1 THEN asm_rewrite_tac[]);
pop_thm()
));


=TEX


%%%%
%%%%
=SML


val ÛÖ_poly_0_thmÝ = save_thm( "Ö_poly_0_thm", (
set_goal([], ¬µn z·
	Poly‰C ((Ìi·îÖ 0), n) z = îÖ 0
®);
a(REPEAT µ_tac THEN induction_tac¬n:î®
	THEN asm_rewrite_tac[Ö_poly_rec_thm]);
pop_thm()
));


=TEX


%%%%
%%%%
=SML


val ÛÖ_poly_minus_thmÝ = save_thm( "Ö_poly_minus_thm", (
set_goal([], ¬µs n z·
	Poly‰C ((Ìi·~(s i)), n) z = ~(Poly‰C (s, n) z)
®);
a(REPEAT µ_tac THEN induction_tac¬n:î®
	THEN asm_rewrite_tac[Ö_poly_rec_thm]);
a(rewrite_tac[Ö_times_minus_thm]);
pop_thm()
));


=TEX


%%%%
%%%%
=SML


val ÛÖ_poly_plus_thmÝ = save_thm( "Ö_poly_plus_thm", (
set_goal([], ¬µs t n z·
	Poly‰C ((Ìi·s i + t i), n) z =
	Poly‰C (s, n) z + Poly‰C (t, n) z
®);
a(REPEAT µ_tac THEN induction_tac¬n:î®
	THEN asm_rewrite_tac[Ö_poly_rec_thm]);
a(rewrite_tac[Ö_plus_assoc_thm,
	µ_elim¬Poly‰C (s, n) z® Ö_plus_order_thm,
	Ö_times_plus_distrib_thm]);
a(rewrite_tac[µ_elim¬Poly‰C (t, n) z® Ö_plus_order_thm]);
pop_thm()
));

=TEX


%%%%
Now we will show that any polynomial function can be represented by a finite power series.

Constants \ldots
%%%%
%%%%
=SML

val ÛÖ_const_eval_thmÝ = save_thm( "Ö_const_eval_thm", (
set_goal([], ¬µc·(Ìx·c) = Poly‰C ((Ìi·c), 0)®);
a(rewrite_tac[] THEN pure_rewrite_tac[Ö_poly_def, Ö_series_def]);
a(rewrite_tac Ö_ops_defs);
pop_thm()
));

=TEX
\ldots identity function \ldots
%%%%
%%%%
=SML

val ÛÖ_id_eval_thmÝ = save_thm( "Ö_id_eval_thm", (
set_goal([], ¬(Ìx·x) = Poly‰C ((Ìi·if i = 1 then îÖ 1 else îÖ 0), 1)®);
a(rewrite_tac[Ö_poly_def]);
a(REPEAT (once_rewrite_tac[Ö_series_rw_thm] THEN rewrite_tac[]));
pop_thm()
));

=TEX
\ldots sums \ldots
%%%%
%%%%
=SML

=TEX
\ldots sums \ldots
%%%%
%%%%
=SML

val ÛÖ_plus_eval_thmÝ = save_thm( "Ö_plus_eval_thm", (
set_goal([], ¬µs m t n·
	(Ìx· Poly‰C (s, m) x + Poly‰C (t, n) x) =
	Poly‰C (PlusCoeffs‰C (s, m) (t, n))®);
a(REPEAT strip_tac THEN rewrite_tac[Ö_plus_coeffs_def]);
a(EXTEND_PC_T1 "'sho_rw" pure_rewrite_tac[Ö_poly_plus_thm]);
a(bc_tac [prove_rule[]¬µa b c d:Ö·a = c ± b = d ´ a + b = c + d®,
	Ö_poly_eq_thm]
	THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "1" (duplicates "2") *** *)
a(LEMMA_T ¬³i ¼ m® asm_rewrite_thm_tac THEN PC_T1 "lin_arith" asm_prove_tac[]);
pop_thm()
));
=TEX
which we can usefully reformulate thus
%%%%
%%%%
=SML

val ÛÖ_plus_eval_rw_thmÝ = save_thm( "Ö_plus_eval_rw_thm", (
set_goal([], ¬µsm tn·
	Poly‰C (PlusCoeffs‰C sm tn) =
	(Ìx· Poly‰C sm x + Poly‰C tn x) ®);
a(REPEAT strip_tac);
a(pair_tac¬sm = (s, m)® THEN pair_tac¬tn = (t, n)®);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) Ö_plus_eval_thm]);
pop_thm()
));

=TEX
\ldots and products, which in this case require a little lemma first:
%%%%
%%%%
=SML

val ÛÖ_const_times_eval_thmÝ = save_thm( "Ö_const_times_eval_thm", (
set_goal([], ¬µc s m· Poly‰C ((Ìi·c * s i), m) = (Ìx·c * Poly‰C (s, m) x)®);
a(REPEAT strip_tac);
a(induction_tac¬m® THEN asm_rewrite_tac[Ö_poly_rec_thm]);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val ÛÖ_times_eval_thmÝ = save_thm( "Ö_times_eval_thm", (
set_goal([], ¬µs m t n·
	(Ìx·Poly‰C (s, m) x * Poly‰C (t, n) x) =
	Poly‰C (TimesCoeffs‰C (s, m) (t, n))®);
a(REPEAT strip_tac THEN rewrite_tac[]);
a(induction_tac¬m® THEN
	rewrite_tac[Ö_times_coeffs_def, Ö_poly_rec_thm, Ö_const_times_eval_thm]
	THEN REPEAT strip_tac);
a(asm_rewrite_tac[Ö_times_plus_distrib_thm, Ö_plus_eval_rw_thm]);
a(POP_ASM_T discard_tac THEN induction_tac¬n® THEN REPEAT strip_tac THEN
	asm_rewrite_tac[Ö_poly_rec_thm]);
(* *** Goal "1" *** *)
a(rewrite_tac[µ_elim¬t 0® Ö_times_order_thm]);
a(LEMMA_T ¬îÖ 0 = Poly‰C ((Ìi· îÖ 0), m) x®
	(fn th => conv_tac(RIGHT_C (once_rewrite_conv[th])))
	THEN1 rewrite_tac[Ö_poly_0_thm]);
a(conv_tac eq_sym_conv THEN bc_thm_tac Ö_poly_eq_thm1
	THEN REPEAT strip_tac
	THEN1 asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[Ö_times_plus_distrib_thm, Ö_poly_rec_thm,
	pc_rule1 "lin_arith" prove_rule[]
		¬m + (n + 1) + 1 = (m + n + 1) + 1®]);
a(asm_rewrite_tac[pc_rule1 "lin_arith" prove_rule[]
		¬(m + n + 1) + 1 = m + n + 2®]);
a(rewrite_tac[minus_def, pc_rule1 "lin_arith" prove_rule[]
		¬m + n + 2 = (m+1) + (n+1)®]);
a(rewrite_tac[Ö_î_exp_plus_thm]);
a(rewrite_tac[Ö_times_assoc_thm, µ_elim¬t(n+1)® Ö_times_order_thm]);
pop_thm()
));

=TEX
which we can usefully reformulate thus
%%%%
%%%%
=SML

val ÛÖ_times_eval_rw_thmÝ = save_thm( "Ö_times_eval_rw_thm", (
set_goal([], ¬µsm tn·
	Poly‰C (TimesCoeffs‰C sm tn) =
	(Ìx· Poly‰C sm x * Poly‰C tn x) ®);
a(REPEAT strip_tac);
a(pair_tac¬sm = (s, m)® THEN pair_tac¬tn = (t, n)®);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) Ö_times_eval_thm]);
pop_thm()
));


=TEX
Following what we did for the reals,
we now show that the set of all complex polynomial functions is the
range of the polynomial evaluation function. I.e., a function
is polynomial iff. it can be represented by a sequence of coefficients
and a degree.
We prove the two inclusions separately:
%%%%
%%%%
=SML


val ÛÖ_poly_€_poly_thmÝ = (
set_goal([], ¬{f | ¶s n· f = Poly‰C (s, n)} € PolyFunc‰C®);
a(pure_rewrite_tac[Ö_poly_func_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN induction_tac¬n®);
(* *** Goal "1" *** *)
a(conv_tac (LEFT_C un_È_conv));
a(pure_rewrite_tac[Ö_poly_rec_thm] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(conv_tac (LEFT_C un_È_conv));
a(pure_rewrite_tac[Ö_poly_rec_thm]);
a(GET_NTH_ASM_T 3 ho_bc_thm_tac THEN asm_rewrite_tac[È_axiom]);
a(GET_NTH_ASM_T 2 ho_bc_thm_tac THEN asm_rewrite_tac[]);
a(rewrite_tac[Ö_î_exp_def]
	THEN POP_ASM_T discard_tac THEN induction_tac¬n®
	THEN asm_rewrite_tac[Ö_î_exp_def]);
a(GET_NTH_ASM_T 2 ho_bc_thm_tac THEN asm_rewrite_tac[]);
pop_thm ()
);


=TEX
For the reverse inclusion, and for later use, it is convenient
to prove an induction theorem for polynomials and use it
to derive an induction tactic:
%%%%
%%%%
=SML

val ÛÖ_poly_induction_thmÝ = save_thm( "Ö_poly_induction_thm", (
set_goal([], ¬µp·
		(µc·p(Ìx·c))
	±	(p(Ìx·x))
	±	(µf g·p f ± p g ´  p(Ìx·f x + g x))
	±	(µf g·p f ± p g ´ p(Ìx·f x * g x))
	´	(µh· h  PolyFunc‰C ´ p h)
®);
a(rewrite_tac[Ö_poly_func_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(PC_T1 "sets_ext1" POP_ASM_T (strip_asm_tac o µ_elim ¬{h | p h}®)
	THEN1 asm_prove_tac[] THEN all_asm_fc_tac[]);
pop_thm()
));


=TEX
Now the tactic, which expects a term of the form $f \in \mbox{\it PolyFunc}_C$ to
be in the assumptions (where $f$ is the induction variable).
%%%%
%%%%
=SML

fun ÛÖ_poly_induction_tacÝ (tm : TERM) : TACTIC = (
	if not (is_var tm andalso type_of tm =: ”Ö ­ Ö®)
	then term_fail "Ö_poly_induction_tac" 999001 [tm]
	else ( fn(asms, conc) =>
	let	val asm = find asms (fn t =>  
			let	val (x, s) = dest_bin_op "" 0 "" t;
			in	x =$ tm andalso s =$ ¬PolyFunc‰C®
			end	handle Fail _ => false)
			handle Fail _ => fail "Ö_poly_induction_tac" 999002 [];
	in	if not (is_free_in tm conc)
			then term_fail "Ö_poly_induction_tac" 999003 [tm]
		else if any (asms drop (fn t => t =$ asm)) (is_free_in tm)
			then term_fail "Ö_poly_induction_tac" 999004 [tm]
		else	(asm_ante_tac asm THEN gen_induction_tac1 Ö_poly_induction_thm) (asms, conc)
	end
	)
);



=TEX


%%%%
%%%%
=SML

val ÛÖ_poly_€_poly_eval_thmÝ = (
set_goal([], ¬PolyFunc‰C € {f | ¶s n· f = Poly‰C (s, n)}®);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(Ö_poly_induction_tac¬x®);
(* *** Goal "1" *** *)
a(ante_tac Ö_const_eval_thm THEN prove_tac[]);
(* *** Goal "2" *** *)
a(ante_tac Ö_id_eval_thm THEN prove_tac[]);
(* *** Goal "3" *** *)
a(¶_tac¬Fst(PlusCoeffs‰C (s, n) (s', n'))® THEN ¶_tac¬Snd(PlusCoeffs‰C (s, n) (s', n'))®
	THEN rewrite_tac[]);
a(asm_rewrite_tac[Ö_plus_eval_rw_thm]);
(* *** Goal "4" *** *)
a(¶_tac¬Fst(TimesCoeffs‰C (s, n) (s', n'))® THEN ¶_tac¬Snd(TimesCoeffs‰C (s, n) (s', n'))®
	THEN rewrite_tac[]);
a(asm_rewrite_tac[Ö_times_eval_rw_thm]);
pop_thm ()
);

=TEX


%%%%
%%%%
=SML

val ÛÖ_poly_func_eq_poly_eval_thmÝ = save_thm( "Ö_poly_func_eq_poly_eval_thm", (
set_goal([], ¬PolyFunc‰C = {f | ¶s n· f = Poly‰C (s, n)}®);
a(rewrite_tac[Ö_poly_€_poly_eval_thm, Ö_poly_€_poly_thm,
	pc_rule1 "sets_ext1" prove_rule[] ¬µa b·a = b ¤ a € b ± b € a®]);
pop_thm()
));

=TEX
\subsection{Topological Properties}

%%%%
%%%%
=SML

val Ûopen_Ö_topology_thmÝ = save_thm( "open_Ö_topology_thm", (
set_goal([], ¬
	O‰C  Topology
®);
a(rewrite_tac[open_Ö_def]);
a(bc_thm_tac product_topology_thm THEN rewrite_tac[open_¯_topology_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val Ûopen_Ö_hausdorff_thmÝ = save_thm( "open_Ö_hausdorff_thm", (
set_goal([], ¬
	O‰C  Hausdorff
®);
a(rewrite_tac[open_Ö_def, open_¯_¸_open_¯_hausdorff_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val Ûuniverse_open_Ö_thmÝ = save_thm( "universe_open_Ö_thm", (
set_goal([], ¬
	Universe  O‰C
®);
a(rewrite_tac[open_Ö_def]);
a(rewrite_tac[product_topology_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(¶_tac¬Universe® THEN ¶_tac¬Universe® THEN rewrite_tac[empty_universe_open_closed_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val Ûspace_t_open_Ö_thmÝ = save_thm( "space_t_open_Ö_thm", (
set_goal([], ¬
	Space‰T O‰C = Universe
®);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(bc_thm_tac _space_t_thm);
a(¶_tac¬Universe® THEN PC_T1 "sets_ext1" rewrite_tac[universe_open_Ö_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val Ûspace_t_subspace_open_Ö_thmÝ = save_thm ("space_t_subspace_open_Ö_thm",
	rewrite_rule[open_Ö_topology_thm, space_t_open_Ö_thm]
	(µ_elim¬O‰C® subspace_topology_space_t_thm));


=TEX
%%%%
%%%%
=SML

val Ûsubspace_Ö_topology_thmÝ = save_thm( "subspace_Ö_topology_thm", (
	(rewrite_rule[open_Ö_topology_thm] o µ_elim¬O‰C®) subspace_topology_thm
));

=TEX
%%%%
%%%%
=SML

val ÛÖ_minus_continuous_thmÝ = save_thm( "Ö_minus_continuous_thm", (
set_goal([], ¬~  (O‰C, O‰C) Continuous ®);
a(LEMMA_T ¬~ = Ìz· (~ z : Ö)® once_rewrite_thm_tac
	THEN1 rewrite_tac[uncurry_def]);
a(rewrite_tac[Ö_minus_def, open_Ö_def]);
a(¯_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML
val ÛÖ_conj_continuous_thmÝ = save_thm( "Ö_conj_continuous_thm", (
set_goal([], ¬$›_  (O‰C, O‰C) Continuous ®);
a(LEMMA_T ¬$›_ = Ìz· z ›_® once_rewrite_thm_tac
	THEN1 rewrite_tac[uncurry_def]);
a(rewrite_tac[Ö_conj_def, open_Ö_def]);
a(¯_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛÖ_plus_continuous_thmÝ = save_thm( "Ö_plus_continuous_thm", (
set_goal([], ¬Uncurry $+  (O‰C ¸‰T O‰C, O‰C) Continuous ®);
a(LEMMA_T ¬Uncurry $+ = Ì(w, z)· (w + z : Ö)® rewrite_thm_tac
	THEN1 rewrite_tac[uncurry_def]);
a(rewrite_tac[Ö_plus_def, open_Ö_def]);
a(¯_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛÖ_times_continuous_thmÝ = save_thm( "Ö_times_continuous_thm", (
set_goal([], ¬Uncurry $*  (O‰C ¸‰T O‰C, O‰C) Continuous ®);
a(LEMMA_T ¬Uncurry $* = Ì(w, z)· (w * z : Ö)® rewrite_thm_tac
	THEN1 rewrite_tac[uncurry_def]);
a(rewrite_tac[Ö_times_def, open_Ö_def]);
a(¯_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛÖ_î_exp_continuous_thmÝ = save_thm( "Ö_î_exp_continuous_thm", (
set_goal([], ¬µn· (Ìx:Ö· x^n)  (O‰C, O‰C) Continuous®);
a(rewrite_tac[open_Ö_def] THEN REPEAT strip_tac);
a(induction_tac¬n® THEN rewrite_tac[Ö_î_exp_def]);
(* *** Goal "1" *** *)
a(¯_continuity_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[Ö_times_def] THEN ¯_continuity_tac[]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val ÛÖ_series_continuous_thmÝ = save_thm( "Ö_series_continuous_thm", (
set_goal([], ¬µÓ s n·
		Ó  Topology
	±	(µi· s i  (Ó, O‰C) Continuous)
	´	(Ìx· Series‰C (Ìi· s i x) n)  (Ó, O‰C) Continuous ®);
a(rewrite_tac[open_Ö_def] THEN REPEAT strip_tac);
a(induction_tac¬n® THEN rewrite_tac[Ö_series_def]);
(* *** Goal "1" *** *)
a(¯_continuity_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[Ö_plus_def] THEN ¯_continuity_tac[]
	THEN asm_rewrite_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛÖ_poly_func_continuous_thmÝ = save_thm( "Ö_poly_func_continuous_thm", (
set_goal([], ¬µf·f  PolyFunc‰C ´ f  (O‰C, O‰C) Continuous ®);
a(rewrite_tac[open_Ö_def] THEN REPEAT strip_tac);
a(Ö_poly_induction_tac ¬f®);
a(¯_continuity_tac[]);
(* *** Goal "2" *** *)
a(¯_continuity_tac[]);
(* *** Goal "3" *** *)
a(¯_continuity_tac[rewrite_rule[open_Ö_def]Ö_plus_continuous_thm]);
(* *** Goal "4" *** *)
a(¯_continuity_tac[rewrite_rule[open_Ö_def]Ö_times_continuous_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val Ûexp_s1_continuous_thmÝ = save_thm( "exp_s1_continuous_thm", (
set_goal([], ¬
	ExpS1  (O‰R, O‰C) Continuous
®);
a(rewrite_tac[exp_s1_def1, open_Ö_def]);
a(¯_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val ÛÖ_abs_squared_lemmaÝ = save_thm( "Ö_abs_squared_lemma", (
set_goal([], ¬µx y· Sqrt(x^2 + y^2) = 1. ¤ x^2 + y^2 = 1. ®);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¬0. ¼ x^2 ± 0. ¼ y^2® THEN1 rewrite_tac[¯_0_¼_square_thm]);
a(lemma_tac¬0. ¼ x^2 + y^2® THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [2, 3] discard_tac THEN all_fc_tac[sqrt_0_¼_thm, sqrt_thm]);
a(POP_ASM_T (once_rewrite_thm_tac o eq_sym_rule));
a(asm_rewrite_tac[¯_î_exp_square_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[sqrt_0_1_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML


val Û_s1_lemmaÝ = save_thm( "_s1_lemma", (
set_goal([], ¬µz· z  S1 ¤ Re z^2 + Im z^2 = 1.®);
a(MERGE_PCS_T1 ["'pair", "sets_ext1"] rewrite_tac[s1_def, Ö_abs_def, Ö_times_conj_thm, ¯Ö_def, Ö_abs_squared_lemma]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val Ûopen_s1_topology_thmÝ = save_thm ( "open_s1_topology_thm", ( 
set_goal([], ¬ O‰S1  Topology ®);
a(rewrite_tac[open_s1_def] THEN basic_topology_tac[open_Ö_topology_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val Ûspace_t_open_s1_thmÝ = save_thm ( "space_t_open_s1_thm", ( 
set_goal([], ¬Space‰T O‰S1 = S1 ®);
a(rewrite_tac[open_s1_def, space_t_subspace_open_Ö_thm]);
pop_thm()
));


=TEX
Constant functions are continuous:
%%%%
%%%%

=SML

val Ûopen_Ö_const_continuous_thmÝ = save_thm("open_Ö_const_continuous_thm",
	all_µ_intro(
	rewrite_rule[open_Ö_topology_thm, space_t_open_Ö_thm]
	(list_µ_elim[¬Ó : 'a SET SET®, ¬O‰C®] const_continuous_thm)));

=TEX

as is the identity function:
%%%%
%%%%

=SML

val Ûopen_Ö_id_continuous_thmÝ = save_thm("open_Ö_id_continuous_thm",
	rewrite_rule[open_Ö_topology_thm]
	(µ_elim¬O‰C® id_continuous_thm));



=TEX
It is now useful to set up a proof context to eliminate various trivial facts.
%%%%
%%%%

=SML
val _ = delete_pc "'topology_Ö" handle Fail _ => ();
val _ = new_pc "'topology_Ö";

val _ = add_rw_thms [
	open_Ö_topology_thm,
	space_t_open_Ö_thm,
	open_Ö_id_continuous_thm,
	(rewrite_rule[open_Ö_topology_thm] o µ_elim¬O‰C®) open_Ö_const_continuous_thm,
	subspace_Ö_topology_thm,
	open_s1_topology_thm,
	space_t_open_s1_thm
	]
	"'topology_Ö";
local
	fun Ûthms_to_eqn_cxtÝ (thms:THM list) : EQN_CXT = (
		flat(map (cthm_eqn_cxt initial_rw_canon) thms)
	);
	val pos_bits = thms_to_eqn_cxt [open_Ö_topology_thm];
	val neg_strips = map (mk_³ ** RAND_C) pos_bits;
	val new_strips = pos_bits @ neg_strips;
in
	val _ = set_st_eqn_cxt new_strips "'topology_Ö";
	val _ = set_sc_eqn_cxt new_strips "'topology_Ö";

end;

val _ = set_pr_tac basic_prove_tac "'topology_Ö";
val _ = set_pr_conv basic_prove_conv "'topology_Ö";

(*
val _ = commit_pc "'topology_Ö";
*)

val _ = set_merge_pcs["basic_hol1", "'ú", "'¯", "'sets_alg", "'topology_¯", "'topology_Ö", "'Ö"];



=TEX
\subsection{Absolute Value}
=TEX

%%%%
%%%%
=SML

val Û¯_0_¼_square_plus_square_thmÝ = save_thm( "¯_0_¼_square_plus_square_thm", (
set_goal([], ¬
	µ x y· 0. ¼ x^2 + y^2
®);
a(REPEAT strip_tac);
a((strip_asm_tac o µ_elim¬x®) ¯_0_¼_square_thm);
a((strip_asm_tac o µ_elim¬y®) ¯_0_¼_square_thm);
a(PC_T1 "¯_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val Û¯_square_eq_0_thmÝ = save_thm( "¯_square_eq_0_thm", (
set_goal([], ¬
	µ x· 0. ¼ x ´ (Sqrt x = 0. ¤ x = 0.)
®);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[sqrt_0_1_thm]);
a(ALL_FC_T (once_rewrite_tac o map eq_sym_rule)[sqrt_thm]);
a(asm_rewrite_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val Û¯_2d_cauchy_schwarz_thmÝ = save_thm( "¯_2d_cauchy_schwarz_thm", (
set_goal([], ¬µ a b c d : ¯· 
	a*c + b*d ¼ Sqrt(a^2 + b^2) * Sqrt(c^2 + d^2)
®);
a(REPEAT strip_tac);
a(lemma_tac¬0. ¼ a^2 + b^2 ± 0. ¼ c^2 + d^2®
	THEN1 rewrite_tac[¯_0_¼_square_plus_square_thm]);
a(all_fc_tac[sqrt_0_¼_thm]);
a(lemma_tac¬0. ¼ Sqrt(a^2 + b^2) * Sqrt(c^2 + d^2)®
	THEN1 all_fc_tac[¯_0_¼_0_¼_times_thm]);
a(cases_tac¬³0. ¼ a*c + b*d® THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a(ALL_FC_T1 fc_¤_canon rewrite_tac[square_mono_¼_thm]);
a(ALL_FC_T rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) sqrt_times_thm]);
a(lemma_tac¬0. ¼ (a^2 + b^2) * (c^2 + d^2)®
	THEN1 all_fc_tac[¯_0_¼_0_¼_times_thm]);
a(ALL_FC_T rewrite_tac[sqrt_thm]);
a(once_rewrite_tac[pc_rule1"¯_lin_arith" prove_rule[]¬µx y·x ¼ y ¤ 0. ¼ y - x®]);
a(conv_tac (ONCE_MAP_C ¯_anf_conv));
a((ante_tac o µ_elim ¬(a*d - b*c)®) ¯_0_¼_square_thm);
a(PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));


=TEX

%%%%
%%%%
=SML

val Û¯_2d_triangle_inequality_thmÝ = save_thm( "¯_2d_triangle_inequality_thm", (
set_goal([], ¬µ a b c d : ¯· 
	Sqrt((a + c)^2 + (b + d)^2) ¼ Sqrt(a^2 + b^2) + Sqrt(c^2 + d^2)
®);
a(REPEAT strip_tac);
a(lemma_tac¬0. ¼ (a + c)^2 + (b + d)^2 ± 0. ¼ a^2 + b^2 ± 0. ¼ c^2 + d^2®
	THEN1 rewrite_tac[¯_0_¼_square_plus_square_thm]);
a(all_fc_tac[sqrt_0_¼_thm]);
a(lemma_tac¬0. ¼ Sqrt(a^2 + b^2) + Sqrt(c^2 + d^2)®
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a(ALL_FC_T1 fc_¤_canon rewrite_tac[square_mono_¼_thm]);
a(conv_tac (RIGHT_C (ONCE_MAP_C ¯_anf_conv)));
a(ALL_FC_T rewrite_tac[sqrt_thm]);
a(once_rewrite_tac[pc_rule1"¯_lin_arith" prove_rule[]¬µx y·x ¼ y ¤ 0. ¼ y - x®]);
a(conv_tac (ONCE_MAP_C ¯_anf_conv));
a((ante_tac o all_µ_elim) ¯_2d_cauchy_schwarz_thm);
a(PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val ÛÖ_abs_times_thmÝ = save_thm( "Ö_abs_times_thm", (
set_goal([], ¬
	µ z w· Abs‰C(z * w) = Abs‰C z * Abs‰C w
®);
a(REPEAT strip_tac THEN rewrite_tac[Ö_abs_def]);
a(LEMMA_T ¬Re ((z * w) * (z * w) ›_) = Re(z * z  ›_) * Re (w * w ›_)® rewrite_thm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(bc_thm_tac sqrt_times_thm);
a(rewrite_tac Ö_ops_defs THEN conv_tac(ONCE_MAP_C ¯_anf_conv)
	THEN rewrite_tac[¯_0_¼_square_plus_square_thm]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val ÛÖ_abs_plus_thmÝ = save_thm( "Ö_abs_plus_thm", (
set_goal([], ¬
	µ z w· Abs‰C(z + w) ¼ Abs‰C z + Abs‰C w
®);
a(REPEAT strip_tac);
a(pair_tac¬z = (a, b)® THEN pair_tac¬w = (c, d)®);
a(rewrite_tac Ö_ops_defs);
a((ante_tac o all_µ_elim) ¯_2d_triangle_inequality_thm);
a(conv_tac (ONCE_MAP_C ¯_anf_conv) THEN strip_tac);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val ÛÖ_abs_eq_0_thmÝ = save_thm( "Ö_abs_eq_0_thm", (
set_goal([], ¬
	µ z· Abs‰C z = 0. ¤ z = îÖ 0
®);
a(µ_tac THEN rewrite_tac Ö_ops_defs THEN conv_tac(ONCE_MAP_C ¯_anf_conv));
a(lemma_tac¬0. ¼ Re z ^ 2 + Im z ^ 2® THEN1 rewrite_tac[¯_0_¼_square_plus_square_thm]);
a(ALL_FC_T1 fc_¤_canon rewrite_tac[¯_square_eq_0_thm]);
a(rewrite_tac[¯_square_plus_square_eq_0_thm]);
pop_thm()
));


val ÛÖ_abs_eq_0_thm1Ý = save_thm( "Ö_abs_eq_0_thm1",
	conv_rule (BINDER_C eq_sym_conv) Ö_abs_eq_0_thm);


=TEX
%%%%
%%%%
=SML

val ÛÖ_0_¼_abs_thmÝ = save_thm( "Ö_0_¼_abs_thm", (
set_goal([], ¬
	µ z· 0. ¼ Abs‰C z
®);
a(µ_tac THEN rewrite_tac Ö_ops_defs);
a(bc_thm_tac sqrt_0_¼_thm);
a(conv_tac (RIGHT_C (¯_anf_conv)));
a(rewrite_tac[¯_0_¼_square_plus_square_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val ÛÖ_abs_continuous_thmÝ = save_thm( "Ö_abs_continuous_thm", (
set_goal([], ¬
	Abs‰C  (O‰C, O‰R) Continuous
®);
a(pure_rewrite_tac[prove_rule[Ö_abs_def] ¬Abs‰C = (Ìz· Sqrt ((Ìv· Re (v * v ›_)) z))® ]);
a(bc_thm_tac comp_continuous_thm THEN rewrite_tac[]);
a(¶_tac¬{x | 0. ¼ x} ò‰T O‰R® THEN rewrite_tac[sqrt_continuous_thm, subspace_¯_topology_thm]);
a(bc_thm_tac subspace_range_continuous_bc_thm THEN rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac Ö_ops_defs THEN conv_tac (ONCE_MAP_C ¯_anf_conv));
a(rewrite_tac[¯_0_¼_square_plus_square_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[open_Ö_def]);
a(¯_continuity_tac(map (rewrite_rule[open_Ö_def])[Ö_conj_continuous_thm, Ö_times_continuous_thm]));
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val Ûexp_exp_s1_thmÝ = save_thm( "exp_exp_s1_thm", (
set_goal([], ¬ExpS1 = (Exp : Ö ­ Ö) o ¯É®);
a(rewrite_tac[Ö_times_def, o_def, exp_def, Ö_exp_def, ¯É_def, ¯Ö_def, exp_s1_def]);
pop_thm()
));
=TEX

%%%%
%%%%
=SML

val Ûexp_s1_homomorphism_thmÝ = save_thm( "exp_s1_homomorphism_thm", (
set_goal([], ¬µx y· ExpS1(x + y) = ExpS1 x * ExpS1 y®);
a(rewrite_tac[exp_s1_def, Ö_times_def, sin_cos_plus_thm]);
pop_thm()
));

val Ûexp_s1_homomorphism_thm1Ý = save_thm ("exp_s1_homomorphism_thm1",
	conv_rule(ONCE_MAP_C eq_sym_conv) exp_s1_homomorphism_thm);


=TEX

%%%%
%%%%
=SML

val Ûexp_s1_minus_thmÝ = save_thm( "exp_s1_minus_thm", (
set_goal([], ¬µx· ExpS1(~x) = ExpS1 x ›-›1®);
a(REPEAT strip_tac THEN bc_thm_tac Ö_times_eq_1_thm);
a(rewrite_tac[exp_s1_homomorphism_thm1]);
a(rewrite_tac[exp_s1_def, îÖ_def, ¯Ö_def, sin_def]);
a(contr_tac THEN ante_tac (µ_elim¬x® cos_squared_plus_sin_squared_thm));
a(asm_rewrite_tac[¯_î_exp_square_thm]);
pop_thm()
));


=TEX

%%%%
%%%%
=SML

val Ûexp_s1__s1_thmÝ = save_thm( "exp_s1__s1_thm", (
set_goal([], ¬µx· ExpS1 x  S1®);
a(rewrite_tac[exp_s1_def, _s1_lemma, cos_squared_plus_sin_squared_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val Ûexp_s1_period_thmÝ = save_thm( "exp_s1_period_thm", (
set_goal([], ¬µx y· ExpS1 x = ExpS1 y ¤ (¶m· y = x + î¯(2*m) * Ð ² x = y + î¯(2*m) * Ð)®);
a(lemma_tac¬
	(µx y· x < y ´
		(ExpS1 x = ExpS1 y ¤ (¶m· y = x + î¯(2*m) * Ð)))
±	(µx y m· x < y ´ ³ x = y + î¯ (2 * m) * Ð)
®
	THEN1 ±_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[exp_s1_def,
	taut_rule¬µx y p· Cos x = y ± p ¤ p ± Cos x = y®,
	sin_cos_period_thm]);
(* *** Goal "2" *** *)
a(contr_tac THEN all_var_elim_asm_tac1);
a(lemma_tac ¬0. ¼ î¯ (2 * m) * Ð® THEN_LIST [
	bc_thm_tac ¯_0_¼_0_¼_times_thm,
	PC_T1 "¯_lin_arith" asm_prove_tac[]]);
a(rewrite_tac[î¯_¼_thm] THEN rewrite_tac[¯_¼_def, Ð_def]);
(* *** Goal "3" *** *)
a(REPEAT µ_tac);
a(lemma_tac¬x = y ² x < y ² y < x® THEN1 PC_T1 "¯_lin_arith" prove_tac[]
	THEN1 (all_var_elim_asm_tac THEN rewrite_tac[]));
(* *** Goal "3.1" *** *)
a(¶_tac¬0® THEN rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(LIST_DROP_NTH_ASM_T [2, 3] (ALL_FC_T1 fc_¤_canon rewrite_tac));
(* *** Goal "3.3" *** *)
a(conv_tac(LEFT_C eq_sym_conv));
a(LIST_DROP_NTH_ASM_T [2, 3] (ALL_FC_T1 fc_¤_canon rewrite_tac));
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val Ûexp_s1_period_thm1Ý = save_thm( "exp_s1_period_thm1", (
set_goal([], ¬µx y· ExpS1 x = ExpS1 y ¤  ¶i· y = x + 2. * ú¯ i * Ð®);
a(asm_rewrite_tac[exp_s1_period_thm] THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(¶_tac ¬îú m® THEN rewrite_tac[î¯_times_homomorphism_thm, ú¯_îú_thm]
	THEN PC_T1 "¯_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(¶_tac ¬~(îú m)® THEN rewrite_tac[î¯_times_homomorphism_thm, ú¯_îú_thm]
	THEN PC_T1 "¯_lin_arith" prove_tac[]);
(* *** Goal "3" *** *)
a((strip_asm_tac o µ_elim¬i®) ú_cases_thm THEN all_var_elim_asm_tac1
	THEN ¶_tac ¬m® THEN rewrite_tac[î¯_times_homomorphism_thm, ú¯_îú_thm]
		THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML


val Ûexp_s1_onto_thmÝ = save_thm( "exp_s1_onto_thm", (
set_goal([], ¬µz· z  S1 ´ ¶‰1x· 0. ¼ x ± x < 2. * Ð ± z = ExpS1 x®);
a(rewrite_tac[_s1_lemma, exp_s1_def] THEN REPEAT strip_tac);
a(bc_thm_tac sin_cos_onto_unit_circle_thm1 THEN strip_tac);
pop_thm()
));

=TEX

%%%%
%%%%
=SML


val Ûs1_times_thmÝ = save_thm( "s1_times_thm", (
set_goal([], ¬µz w· z  S1 ± w  S1 ´ z*w  S1®);
a(REPEAT strip_tac THEN all_fc_tac[exp_s1_onto_thm]
	THEN all_var_elim_asm_tac1);
a(rewrite_tac[exp_s1_homomorphism_thm1, exp_s1__s1_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML


val Ûexp_s1_onto_thm1Ý = save_thm( "exp_s1_onto_thm1", (
set_goal([], ¬µc z·
	z  S1
´	¶‰1x· c - Ð ¼ x ± x < c + Ð ± z = ExpS1 x®);
a(REPEAT strip_tac);
a(all_fc_tac[exp_s1_onto_thm] THEN all_var_elim_asm_tac1);
a(lemma_tac¬ExpS1 (x + Ð + ~c)  S1® THEN1 rewrite_tac[exp_s1__s1_thm]);
a(strip_asm_tac(µ_elim¬ExpS1 (x + Ð + ~c)® exp_s1_onto_thm));
a(¶‰1_tac¬x' + c + ~ Ð® THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(once_rewrite_tac[exp_s1_homomorphism_thm]);
a(DROP_NTH_ASM_T 2 (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[exp_s1_homomorphism_thm1]);
a(conv_tac(ONCE_MAP_C ¯_anf_conv) THEN rewrite_tac[]);
(* *** Goal "4" *** *)
a(rewrite_tac[pc_rule1"¯_lin_arith" prove_rule[]
	¬x'' = x' + c + ~ Ð ¤ x'' + Ð - c = x'®]);
a(DROP_NTH_ASM_T 4 bc_thm_tac);
a(once_rewrite_tac[exp_s1_homomorphism_thm]);
a(asm_rewrite_tac[]);
a(PC_T1 "¯_lin_arith" asm_prove_tac[]);
pop_thm()
));


=TEX

%%%%
%%%%
=SML

val Ûexp_s1_onto_thm2Ý = save_thm( "exp_s1_onto_thm2", (
set_goal([], ¬µc z·
	z  S1 ±³z = ExpS1 (c + Ð)
´	¶‰1x·x  OpenInterval (c - Ð) (c + Ð) ± z = ExpS1 x®);
a(rewrite_tac[open_interval_def] THEN REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¬c®, ¬z®]exp_s1_onto_thm1));
a(¶‰1_tac¬x® THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 (strip_asm_tac o rewrite_rule[¯_¼_def])
	THEN all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(swap_nth_asm_concl_tac 3);
a(rewrite_tac[exp_s1_period_thm]);
a(¶_tac¬1® THEN rewrite_tac[]);
a(PC_T1"¯_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 bc_thm_tac THEN asm_rewrite_tac[]);
a(PC_T1"¯_lin_arith" asm_prove_tac[]);
pop_thm()
));


=TEX

%%%%
%%%%
=SML


val Ûexp_s1_onto_thm3Ý = save_thm( "exp_s1_onto_thm3", (
set_goal([], ¬µz· z  S1 ´ ¶x· ExpS1 x = z®);
a(REPEAT strip_tac THEN all_fc_tac[exp_s1_onto_thm]);
a(¶_tac¬x® THEN asm_rewrite_tac[]);
pop_thm()
));


=TEX

%%%%
%%%%
=SML

val Ûexp_s1_covering_projection_lemma1Ý = save_thm( "exp_s1_covering_projection_lemma1", (
set_goal([], ¬µc·
	S1 \ {ExpS1 (c + Ð)} =
	{z | ¶ x· x  OpenInterval (c - Ð) (c + Ð) ± z = ExpS1 x}®);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[exp_s1_onto_thm2]);
a(¶_tac¬x® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[exp_s1__s1_thm]);
(* *** Goal "3" *** *)
a(pure_asm_rewrite_tac[] THEN POP_ASM_T discard_tac);
a(POP_ASM_T ante_tac
	THEN rewrite_tac[open_interval_def]
	THEN strip_tac);
a(ante_tac (list_µ_elim[¬c®, ¬ExpS1 x®] exp_s1_onto_thm1));
a(rewrite_tac[exp_s1__s1_thm] THEN strip_tac);
a(lemma_tac¬c + ~ Ð ¼ x® THEN1 asm_rewrite_tac[¯_¼_def]);
a(lemma_tac¬x = x'® THEN1
	(DROP_NTH_ASM_T 2 bc_thm_tac THEN asm_rewrite_tac[])
	THEN all_var_elim_asm_tac1);
a(contr_tac);
a(DROP_NTH_ASM_T 2 (ante_tac o µ_elim¬c + ~ Ð®) THEN asm_rewrite_tac[]);
a(LEMMA_T ¬~ Ð < Ð ± ³c + ~ Ð = x'® rewrite_thm_tac
	THEN1 (strip_asm_tac Ð_def
		THEN PC_T1 "¯_lin_arith" asm_prove_tac[]));
a(rewrite_tac[exp_s1_period_thm]);
a(¶_tac¬1® THEN rewrite_tac[]);
a(strip_asm_tac Ð_def
	THEN PC_T1 "¯_lin_arith" asm_prove_tac[]);
pop_thm()
));



=TEX

%%%%
%%%%
=SML

val Ûexp_s1_covering_projection_lemma2Ý = save_thm( "exp_s1_covering_projection_lemma2", (
set_goal([], ¬µx·
	ExpS1 
	(OpenInterval (x - Ð) (x + Ð) ò‰T O‰R,
		(S1 \ {ExpS1 (x + Ð)}) ò‰T O‰C) 
			Homeomorphism
®);
a(REPEAT strip_tac);
a(rewrite_tac[exp_s1_covering_projection_lemma1]);
a(bc_thm_tac €_compact_homeomorphism_thm);
a(¶_tac¬ClosedInterval (x - Ð) (x + Ð)®);
a(rewrite_tac[open_¯_topology_thm, open_¯_hausdorff_thm,
	open_Ö_topology_thm, open_Ö_hausdorff_thm,
	exp_s1_continuous_thm, compact_compact_¯_thm,
	closed_interval_compact_thm]);
a(rewrite_tac[open_interval_def, closed_interval_def]);
a(REPEAT strip_tac THEN1
	(PC_T1 "sets_ext1" rewrite_tac[]
	THEN PC_T1 "¯_lin_arith" prove_tac[]));
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[¯_¼_def]));
(* *** Goal "1" *** *)
a(ante_tac(list_µ_elim[¬x®, ¬ExpS1 y®] exp_s1_onto_thm1)
	THEN rewrite_tac[exp_s1__s1_thm]
	THEN REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¬y® THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o eq_sym_rule)); 
a(lemma_tac¬x + ~ Ð ¼ x'® THEN1 asm_rewrite_tac[¯_¼_def]);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac THEN all_var_elim_asm_tac);
(* *** Goal "2" *** *)
a(i_contr_tac THEN all_var_elim_asm_tac1);
a(POP_ASM_T (strip_asm_tac o eq_sym_rule));
a(ante_tac(list_µ_elim[¬x' + Ð®, ¬ExpS1 (x + Ð)®] exp_s1_onto_thm1)
	THEN rewrite_tac[exp_s1__s1_thm]
	THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¬x + Ð® THEN_TRY PC_T1"¯_lin_arith" asm_prove_tac[]
	THEN all_var_elim_asm_tac1);
a(spec_nth_asm_tac 2 ¬x'® THEN_TRY PC_T1"¯_lin_arith" asm_prove_tac[]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val Ûexp_s1_covering_projection_lemma3Ý = save_thm (
	"exp_s1_covering_projection_lemma3",
 rewrite_rule[open_¯_topology_thm,
	open_Ö_topology_thm,
	exp_s1_continuous_thm,
	exp_s1__s1_thm,
	universe_subspace_topology_thm]
	(list_µ_elim[¬O‰R®, ¬O‰C®,
		¬Universe:¯ SET®, ¬S1®, ¬ExpS1®] 
			subspace_continuous_thm));

=TEX

%%%%
%%%%
=SML

val Ûexp_s1_covering_projection_lemma4Ý = save_thm( "exp_s1_covering_projection_lemma4", (
set_goal([], ¬µx·
	ExpS1 x  S1 \ {ExpS1 (x + Ð)}
®);
a(REPEAT strip_tac THEN1 rewrite_tac[exp_s1__s1_thm]);
a(rewrite_tac[exp_s1_def, sin_cos_Ð_thm, sin_cos_plus_thm] THEN contr_tac);
a(lemma_tac¬Sin x = 0. ± Cos x = 0.®
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a(ante_tac (µ_elim¬x®cos_squared_plus_sin_squared_thm));
a(asm_rewrite_tac[¯_î_exp_square_thm]);
pop_thm()
));

=TEX

=TEX

%%%%
%%%%
=SML

val Ûexp_s1_covering_projection_lemma5Ý = save_thm( "exp_s1_covering_projection_lemma5", (
set_goal([], ¬µx y·
	ExpS1 x = ExpS1 y
±	³OpenInterval (x + ~ Ð) (x + Ð) ¡
		OpenInterval (y + ~ Ð) (y + Ð) = {}
´	x = y
®);
a(PC_T1 "sets_ext1" rewrite_tac[exp_s1_period_thm, open_interval_def] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN strip_asm_tac (µ_elim¬m:î® î_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN all_asm_ante_tac
	THEN rewrite_tac[î¯_times_homomorphism_thm,
		î¯_plus_homomorphism_thm,
		¯_times_plus_distrib_thm,
		¯_times_assoc_thm]
	THEN	(lemma_tac ¬0. ¼ î¯ i * Ð® THEN_LIST [
		bc_thm_tac ¯_0_¼_0_¼_times_thm,
		PC_T1 "¯_lin_arith" asm_prove_tac[]]));
(* *** Goal "1" (duplicates "2") *** *)
a(rewrite_tac[î¯_¼_thm] THEN rewrite_tac[¯_¼_def, Ð_def]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val ÛÖ_punctured_set_thmÝ = save_thm (
	"Ö_punctured_set_thm",
	rewrite_rule[
		open_Ö_topology_thm,
		open_Ö_hausdorff_thm,
		space_t_open_Ö_thm]
		(µ_elim¬O‰C® punctured_hausdorff_thm));

=TEX
%%%%
%%%%
=SML

val Ûexp_s1_covering_projection_thmÝ = save_thm( "exp_s1_covering_projection_thm", (
set_goal([], ¬
	ExpS1  (O‰R, O‰S1) CoveringProjection
®);
a(rewrite_tac[covering_projection_def, space_t_subspace_open_Ö_thm,
	exp_s1_continuous_thm,
	exp_s1_covering_projection_lemma3, open_s1_def]
	THEN REPEAT strip_tac);
a(all_fc_tac[exp_s1_onto_thm] THEN all_var_elim_asm_tac1);
a(¶_tac¬S1 \ {ExpS1(x + Ð)}®);
a(rewrite_tac[exp_s1_covering_projection_lemma4,
	Ö_punctured_set_thm]);
a(lemma_tac¬0. < Ð® THEN1 rewrite_tac[Ð_def]);
a(¶_tac¬{I | ¶y· ExpS1 y = ExpS1 x
	± I = OpenInterval (y - Ð) (y + Ð)}®
	THEN rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN rewrite_tac[open_interval_open_thm]);
(* *** Goal "2" *** *)
a(lemma_tac¬³ExpS1 x = ExpS1(x' + Ð)®);
(* *** Goal "2.1" *** *)
a(swap_nth_asm_concl_tac 1 THEN POP_ASM_T ante_tac);
a(rewrite_tac[exp_s1_homomorphism_thm]);
a(rewrite_tac[exp_s1_def, sin_cos_Ð_thm, Ö_times_def]);
a(PC_T1 "¯_lin_arith" prove_tac[]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac (list_µ_elim[¬x'®, ¬ExpS1 x®]exp_s1_onto_thm2));
a(¶_tac¬OpenInterval (x'' + ~ Ð) (x'' + Ð)®
	THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac
	THEN rewrite_tac[open_interval_def]
	THEN PC_T1 "¯_lin_arith" prove_tac[]);
(* *** Goal "2.2.2" *** *)
a(¶_tac¬x''® THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¬ExpS1 y = ExpS1 y'® THEN1 asm_rewrite_tac[]
	THEN all_var_elim_asm_tac1);
a(ALL_FC_T rewrite_tac[exp_s1_covering_projection_lemma5]);
(* *** Goal "4" *** *)
a(lemma_tac¬S1 \ {ExpS1 (x + Ð)} € S1®
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(ALL_FC_T rewrite_tac[€_subspace_topology_thm]);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o eq_sym_rule));
a(all_var_elim_asm_tac1);
a(LEMMA_T ¬ExpS1 (x + Ð) = ExpS1 (y + Ð)® rewrite_thm_tac
	THEN1 asm_rewrite_tac[exp_s1_homomorphism_thm]);
a(rewrite_tac[rewrite_rule[]exp_s1_covering_projection_lemma2]);
pop_thm()
));



=TEX
%%%%
%%%%

=SML

val Ûexp_s1_path_lifting_thmÝ = save_thm( "exp_s1_path_lifting_thm",
	(all_µ_intro o 
		rewrite_rule [exp_s1_covering_projection_thm, open_¯_topology_thm,
			open_Ö_topology_thm, space_t_¯_thm, open_s1_topology_thm] o
			list_µ_elim [
				¬O‰R®, ¬O‰S1®, ¬ExpS1®])
						covering_projection_path_lifting_bc_thm);

=TEX
%%%%
%%%%

=SML

val Ûexp_s1_path_lifting_thm1Ý = save_thm ( "exp_s1_path_lifting_thm1", ( 
set_goal([], ¬
µ y f·
	f  Paths O‰S1
´	(¶ g· g  Paths O‰R ± (µ s· ExpS1 (g s) = f s))®);
a(REPEAT strip_tac);
a(lemma_tac¬¶x· ExpS1 x = f 0.®);
(* *** Goal "1" *** *)
a(lemma_tac¬f 0.  S1®);
(* *** Goal "1.1" *** *)
a(ALL_FC_T (MAP_EVERY ante_tac) [paths_space_t_thm]);
a(rewrite_tac[space_t_open_s1_thm] THEN STRIP_T rewrite_thm_tac);
(* *** Goal "1.2" *** *)
a(contr_tac THEN all_fc_tac[conv_rule (ONCE_MAP_C eq_sym_conv) exp_s1_onto_thm]
	THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_fc_tac[exp_s1_path_lifting_thm]);
a(¶_tac¬g® THEN asm_rewrite_tac[]);
pop_thm()
));


=TEX
%%%%
%%%%

=SML
(*

val Ûs1_s1_loop_thmÝ = save_thm ( "s1_s1_loop_thm", ( 
set_goal([], ¬
µ f·
	f  (O‰S1, O‰S1) Continuous
´	(Ì t· f (ExpS1 (2. * Ð * t)))  Loops(O‰S1, f (îÖ 0))®);
a(rewrite_tac[loops_def, paths_def] THEN REPEAT strip_tac);


pop_thm()
));

*)
=TEX
%%%%
%%%%

=SML

val Ûexp_s1_unique_path_lifting_thmÝ = save_thm( "exp_s1_unique_path_lifting_thm", (
set_goal([], ¬
µf g a·
	f  Paths O‰R ± g  Paths O‰R ±
	(µx· ExpS1(f x) = ExpS1(g x)) ±
	g a = f a
´	µx· f x = g x
®);
a(REPEAT µ_tac THEN ´_tac);
a((bc_thm_tac o rewrite_rule [exp_s1_covering_projection_thm, open_¯_topology_thm,
			open_Ö_topology_thm, open_s1_topology_thm, space_t_¯_thm,
			universe_¯_connected_thm] o
			list_µ_elim [
				¬O‰R®, ¬O‰R®, ¬O‰S1®, ¬ExpS1®])
						unique_lifting_bc_thm
	THEN ¶_tac¬a®);
a(ALL_FC_T asm_rewrite_tac[(rewrite_rule [open_¯_topology_thm] o µ_elim¬O‰R®) paths_continuous_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val Ûtranslated_path_¯_path_thmÝ = save_thm ( "translated_path_¯_path_thm", ( 
set_goal([], ¬
µf c· f  Paths O‰R ´ (Ìx· f x + c)  Paths O‰R
®);
a(rewrite_tac[paths_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(¯_continuity_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val Ûú¯_minus_homomorphism_thmÝ = save_thm ( "ú¯_minus_homomorphism_thm", ( 
set_goal([], ¬
µi· ú¯(~i) = ~(ú¯ i)
®);
a(REPEAT strip_tac);
a(LEMMA_T ¬ú¯ i + ú¯(~i) = 0.® (fn th => ante_tac th THEN  PC_T1 "¯_lin_arith" prove_tac[]));
a(LEMMA_T  ¬ú¯ i + ú¯(~i) = ú¯(i + ~i)® rewrite_thm_tac THEN1 
	(pure_rewrite_tac[ú¯_plus_homomorphism_thm] THEN rewrite_tac[]));
a(rewrite_tac [ú¯_îú_thm]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML

(*
drop_main_goal();
*)

val _ = save_consistency_thm ¬LoopS1Degree® (
push_consistency_goal ¬LoopS1Degree®;
a(prove_¶_tac THEN REPEAT strip_tac);
a(rename_tac[(¬f'®, "f")] THEN
	lemma_tac¬¶D· µg· f  Loops (O‰S1, f 0.) ± g  Paths O‰R ± (µ s· ExpS1 (g s) = f s) ´
		g 1. + ~(g 0.) = 2. * ú¯ D * Ð®);
(* *** Goal "1" *** *)
a(cases_tac¬f  Loops(O‰S1, f 0.)® THEN asm_rewrite_tac[]);
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[loops_def]));
a(all_fc_tac[exp_s1_path_lifting_thm1]);
a(LEMMA_T ¬ExpS1(g 0.) = ExpS1(g 1.)® ante_tac);
(* *** Goal "1.1" *** *)
a(conv_tac eq_sym_conv THEN asm_rewrite_tac[] THEN DROP_NTH_ASM_T 3 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(rewrite_tac[exp_s1_period_thm1,
	pc_rule1 "¯_lin_arith" prove_rule[] ¬µx y z:¯·x = y + z ¤ x - y = z®]
		THEN REPEAT strip_tac);
a(¶_tac¬i® THEN strip_tac THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(rename_tac[(¬g'®, "h")] THEN REPEAT strip_tac);
a(LEMMA_T ¬µx· (Ìy· h y + ~(h 0.) + g 0.) x = g x®
	(fn th => (ante_tac o µ_elim ¬1.® o rewrite_rule[]) th THEN PC_T1 "¯_lin_arith" prove_tac[]));
a(bc_thm_tac exp_s1_unique_path_lifting_thm);
a(¶_tac¬0.® THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(bc_thm_tac translated_path_¯_path_thm	THEN REPEAT strip_tac);
(* *** Goal "1.2.2" *** *)
a(LEMMA_T¬ExpS1(h 0.) =  ExpS1(g 0.)® ante_tac THEN1 asm_rewrite_tac[]);
a(POP_ASM_T (rewrite_thm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
a(rewrite_tac[exp_s1_period_thm1] THEN REPEAT strip_tac);
a(¶_tac¬~i® THEN asm_rewrite_tac[ú¯_minus_homomorphism_thm]);
a(PC_T1 "¯_lin_arith" prove_tac[]);
(* *** Goal "1.2.2.3" *** *)
a(PC_T1 "¯_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(¶_tac¬D® THEN once_rewrite_tac[_loops_thm]);
a(REPEAT µ_tac THEN cases_tac ¬x = f 0.® THEN asm_rewrite_tac[]);
pop_thm()
);

val Ûloop_s1_degree_defÝ = get_spec ¬LoopS1Degree®;

=TEX
%%%%
%%%%

=SML

val Ûexp_s1_path_fibration_thmÝ = save_thm ( "exp_s1_path_fibration_thm", ( 
set_goal([], ¬ µf H·
	f  Paths O‰R
±	H  (O‰R ¸‰T O‰R, O‰S1) Continuous
±	(µ x· H (x, 0.) = ExpS1 (f x))
´	(¶ L·
		L  (O‰R ¸‰T O‰R, O‰R) Continuous
	±	(µ x· L (x, 0.) = f x)
	±	(µ x s· s  ClosedInterval 0. 1. ´ ExpS1 (L (x, s)) = H (x, s)))
®);
a(rewrite_tac[paths_def] THEN REPEAT strip_tac);
a((bc_thm_tac o all_µ_intro o 
		rewrite_rule [exp_s1_covering_projection_thm, open_¯_topology_thm,
			homotopy_lifting_property_def,
			open_Ö_topology_thm, space_t_¯_thm, open_s1_topology_thm] o
			list_µ_elim [
				¬O‰R®, ¬O‰R®, ¬O‰S1®, ¬ExpS1®])
						covering_projection_fibration_thm
	THEN asm_rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML

local
	
val ÛÖ_continuity_fact_thmsÝ : THM list = map (rewrite_rule[open_Ö_def]) [
	Ö_minus_continuous_thm,
	Ö_conj_continuous_thm,
	Ö_plus_continuous_thm,
	Ö_times_continuous_thm,
	Ö_abs_continuous_thm,
	Ö_î_exp_continuous_thm,
	exp_s1_continuous_thm];

in

fun ÛÖ_continuity_tacÝ (thms : THM list): TACTIC = (
	TRY (rewrite_tac[open_Ö_def]) THEN
		¯_continuity_tac (thms @ Ö_continuity_fact_thms)
);

end (* local ... in ... end *);

=TEX
%%%%
%%%%
=SML

val Ûexp_s1_0_thmÝ = save_thm ( "exp_s1_thm", ( 
set_goal([], ¬
	ExpS1 0. = îÖ 1
®);
a(rewrite_tac[exp_s1_def, îÖ_def, ¯Ö_def, sin_def]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val Ûexp_s1_2_i_Ð_thmÝ = save_thm ( "exp_s1_2_Ð_thm", ( 
set_goal([], ¬
	µi· ExpS1 (2. * ú¯ i * Ð) = îÖ 1
®);
a(strip_tac THEN rewrite_tac[eq_sym_rule exp_s1_0_thm, exp_s1_period_thm1]);
a(¶_tac¬~i® THEN rewrite_tac[ú¯_minus_homomorphism_thm]
	THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));



=TEX
%%%%
%%%%
=SML

val Ûiota_s1_loop_thmÝ = save_thm ( "iota_s1_loop_thm", ( 
set_goal([], ¬
	IotaS1  Loops(O‰S1, îÖ 1)
®);
a(rewrite_tac[eq_sym_rule exp_s1_0_thm, iota_s1_def]);
a((bc_thm_tac o rewrite_rule[] o
	list_µ_elim[¬O‰S1®, ¬Ìt·ExpS1(2. * Ð * t)®])loop_from_arc_thm
		THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[open_s1_def] THEN bc_thm_tac subspace_range_continuous_bc_thm);
a(rewrite_tac[exp_s1__s1_thm]);
a(Ö_continuity_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[exp_s1_period_thm1] THEN ¶_tac¬~(îú 1)®);
a(rewrite_tac[ú¯_minus_homomorphism_thm, ú¯_def]
	THEN PC_T1 "¯_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val Ûiota_s1_continuous_thmÝ = save_thm ( "iota_s1_continuous_thm", ( 
set_goal([], ¬
	IotaS1 (O‰R, O‰S1) Continuous
®);
a((ante_tac o rewrite_rule[loops_def, paths_def]) iota_s1_loop_thm THEN REPEAT strip_tac);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val Ûs1_s1_loop_loop_thmÝ = save_thm ( "s1_s1_loop_loop_thm", ( 
set_goal([], ¬
µf· f  (O‰S1, O‰S1) Continuous ´ S1S1Loop f  Loops(O‰S1, f(îÖ 1))
®);
a(REPEAT strip_tac THEN strip_asm_tac iota_s1_loop_thm);
a(ALL_FC_T (MAP_EVERY ante_tac) [(rewrite_rule[open_s1_topology_thm] o
		list_µ_elim[¬O‰S1®, ¬O‰S1®]) loop_comp_continuous_loop_thm]);
a(rewrite_tac[s1_s1_loop_def]);
pop_thm()
));



=TEX
%%%%
%%%%
=SML

val ÛÐ_recip_clausesÝ = save_thm ( "Ð_recip_clauses", ( 
set_goal([], ¬
	Ð * Ð ›-›1 = 1. ± Ð ›-›1 * Ð = 1.
®);
a(conv_tac (RIGHT_C (once_rewrite_conv[¯_times_comm_thm])));
a(rewrite_tac[] THEN bc_thm_tac ¯_times_recip_thm);
a(strip_asm_tac Ð_def THEN PC_T1 "¯_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val Ûtimes_2_Ð_lemmaÝ = save_thm ( "times_2_Ð_lemma", ( 
set_goal([], ¬
	µx y· x = 2. * y * Ð ¤ y = (1/2) * x * Ð ›-›1
®);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(conv_tac (RIGHT_C ¯_anf_conv));
a(rewrite_tac[¯_times_assoc_thm1, Ð_recip_clauses]);
(* *** Goal "2" *** *)
a(conv_tac (RIGHT_C ¯_anf_conv));
a(rewrite_tac[¯_times_assoc_thm1, Ð_recip_clauses]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val Ûú_¼_cases_thm1Ý = save_thm("ú_¼_cases_thm1",
	rewrite_rule[ú_less_def] ú_less_cases_thm);
val Û¯_times_mono_¤_thm1Ý = save_thm("¯_times_mono_¤_thm1",
	(conv_rule (ONCE_MAP_C eq_sym_conv)) ¯_times_mono_¤_thm);

val Ûú¯_0_less_thmÝ = save_thm ( "ú¯_0_less_thm", ( 
set_goal([], ¬
	µi· 0. < ú¯ i ¤ îú 0 < i
®);
a(strip_tac);
a((strip_asm_tac o µ_elim¬i®) ú_cases_thm1 THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(rewrite_tac[ú¯_îú_thm, îú_less_thm, î¯_less_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[pc_rule1 "¯_lin_arith" prove_rule[]¬µx· 0. < x ¤ ~x < 0.®,
	pc_rule1 "ú_lin_arith" prove_rule[]¬µx· îú 0 < x ¤ ~x < îú 0®,
	îú_less_thm]);
a(rewrite_tac[ú¯_minus_homomorphism_thm, îú_less_thm, îú_plus_homomorphism_thm,
	ú¯_def, ú¯_îú_thm,î¯_less_thm]);
pop_thm()
));


val Ûú¯_less_thmÝ = save_thm ( "ú¯_less_thm", ( 
set_goal([], ¬
	µi j· ú¯ i < ú¯ j ¤ i < j
®);
a(REPEAT µ_tac THEN once_rewrite_tac[pc_rule1 "¯_lin_arith" prove_rule[]¬µx y· x < y ¤ 0. < y - x®,
	pc_rule1 "ú_lin_arith" prove_rule[]¬µx y· x < y ¤ îú 0 < y -  x®]);
a(LEMMA_T ¬ú¯ j + ~(ú¯ i) = ú¯(j + ~i)® rewrite_thm_tac
	THEN1 rewrite_tac[ú¯_def, ú¯_minus_homomorphism_thm]);
a(rewrite_tac[ú¯_0_less_thm]);
pop_thm()
));


val Ûú¯_one_one_thmÝ = save_thm ( "ú¯_one_one_thm", ( 
set_goal([], ¬
	µi j· ú¯ i = ú¯ j ¤ i = j
®);
a(REPEAT µ_tac THEN rewrite_tac[pc_rule1 "¯_lin_arith" prove_rule[]¬µx y:¯· x = y ¤ ³x < y ± ³y < x®,
	pc_rule1 "ú_lin_arith" prove_rule[]¬µx y:ú· x = y ¤ ³x < y ± ³y < x®]);
a(rewrite_tac[ú¯_less_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val Ûdiscrete_subgroup_¯_discrete_thmÝ = save_thm ( "discrete_subgroup_¯_discrete_thm", ( 
set_goal([], ¬µc·
	0. < c ´ {z | ¶i· z = c * ú¯ i} ò‰T O‰R  Discrete‰T
®);
a(REPEAT strip_tac);
a(lemma_tac¬{z | ¶i· z = c * ú¯ i} ò‰T O‰R  Topology® THEN1 basic_topology_tac[]);
a(ALL_FC_T1 fc_¤_canon rewrite_tac[open_singletons_discrete_thm]);
a(rewrite_tac[subspace_¯_space_t_thm, subspace_topology_def]
	THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(¶_tac ¬OpenInterval (c * ú¯ i - c) (c * ú¯ i + c)®
	THEN rewrite_tac[open_interval_open_thm]);
a(rewrite_tac[open_interval_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(prove_tac[]);
(* *** Goal "4" *** *)
a(rename_tac[(¬i'®, "j")] THEN swap_nth_asm_concl_tac 1);
a(LIST_DROP_NTH_ASM_T [1, 2] (MAP_EVERY ante_tac) THEN POP_ASM_T discard_tac);
a(LEMMA_T¬c * ú¯ i + ~ c = c * ú¯ (i - îú 1)® rewrite_thm_tac
	THEN1 (rewrite_tac[ú¯_def, ú¯_minus_homomorphism_thm] THEN PC_T1 "¯_lin_arith" prove_tac[]));
a(LEMMA_T¬c * ú¯ i + c = c * ú¯ (i + îú 1)® rewrite_thm_tac
	THEN1 (rewrite_tac[ú¯_def, ú¯_minus_homomorphism_thm] THEN PC_T1 "¯_lin_arith" prove_tac[]));
a(ALL_FC_T1 fc_¤_canon rewrite_tac[¯_times_mono_¤_thm1]);
a(rewrite_tac[ú¯_less_thm]);
a(REPEAT strip_tac THEN LEMMA_T ¬i = j® rewrite_thm_tac);
a(PC_T1 "ú_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val Ûker_exp_s1_discrete_thmÝ = save_thm ( "ker_exp_s1_discrete_thm", ( 
set_goal([], ¬
	{z | ¶i· z = 2. * ú¯ i * Ð} ò‰T O‰R  Discrete‰T
®);
a(rewrite_tac[pc_rule1 "¯_lin_arith" prove_rule[]¬µx· 2. * x * Ð = (2. * Ð) * x®]);
a(bc_thm_tac discrete_subgroup_¯_discrete_thm);
a(strip_asm_tac Ð_def THEN PC_T1 "¯_lin_arith" asm_prove_tac[]);
pop_thm()
));


=TEX
%%%%
%%%%

The below works around a possible bug in higher-order matching.

=SML

val Ûs1_s1_degree_homotopy_invariant_lemma1Ý = save_thm ( "s1_s1_degree_homotopy_invariant_lemma1", ( 
set_goal([], ¬µH· 
	H  (O‰S1 ¸‰T O‰R, O‰S1) Continuous
´	(Ì(y, s)· H(IotaS1 y, s))  (O‰R ¸‰T O‰R, O‰S1) Continuous
®);
a(REPEAT strip_tac);
a(LEMMA_T ¬(Ì(y, s)· H(IotaS1 y, s)) = (Ìys·H((Ì(y, s)· (IotaS1 y, s)) ys))®
	pure_rewrite_thm_tac THEN1 rewrite_tac[]);
a(bc_thm_tac comp_continuous_thm);
a(¶_tac¬O‰S1 ¸‰T O‰R® THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(Ö_continuity_tac[iota_s1_continuous_thm]);
(* *** Goal "2" *** *)
a(basic_topology_tac[]);
(* *** Goal "1.3" *** *)
a(basic_topology_tac[]);
pop_thm()
));


=TEX
%%%%
%%%%

The below works around a possible bug in higher-order matching.

=SML

val Ûs1_s1_degree_homotopy_invariant_lemma2Ý = save_thm ( "s1_s1_degree_homotopy_invariant_lemma2", ( 
set_goal([], ¬µH· 
	L  (O‰R ¸‰T O‰R, O‰R) Continuous
´	(Ì y· L (IotaI y, 1.))  Paths O‰R
®);
a(REPEAT strip_tac);
a(LEMMA_T ¬(Ì y· L (IotaI y, 1.)) = (Ì y· (Ìz· L (z, 1.)) (IotaI y))®
		pure_rewrite_thm_tac
	THEN1 rewrite_tac[]);
a(bc_thm_tac comp_iota_i_path_thm);
a(REPEAT strip_tac THEN Ö_continuity_tac[]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML


val Ûs1_s1_degree_homotopy_invariant_thmÝ = save_thm ( "s1_s1_degree_homotopy_invariant_thm", ( 
set_goal([], ¬µf g· 
	((O‰S1, {}, O‰S1) Homotopic) f g
´	S1S1Degree f = S1S1Degree g
®);
a(REPEAT strip_tac THEN all_fc_tac[
	(rewrite_rule[] o list_µ_elim[¬O‰S1®, ¬O‰S1®])homotopic_continuous_thm]);
a(DROP_NTH_ASM_T 3 ante_tac
	THEN rewrite_tac[homotopic_def, homotopy_def, s1_s1_degree_def, s1_s1_loop_def]
	THEN REPEAT strip_tac);
a(all_fc_tac[µ_elim¬f® s1_s1_loop_loop_thm]);
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[loops_def]));
a(all_fc_tac [paths_space_t_thm]);
a(POP_ASM_T (ante_tac o µ_elim¬0.®));
a(rewrite_tac[] THEN strip_tac);
a(all_fc_tac[exp_s1_onto_thm3]);
a(all_fc_tac[exp_s1_path_lifting_thm]);
a(rename_tac[(¬g'®, "lf")] THEN all_fc_tac [s1_s1_degree_homotopy_invariant_lemma1]);
a(lemma_tac¬µy· (Ì(y, s)· H(IotaS1 y, s)) (y, 0.) = ExpS1(lf y)®
	THEN1 asm_rewrite_tac[s1_s1_loop_def]);
a(all_fc_tac[exp_s1_path_fibration_thm]);
a(POP_ASM_T ante_tac THEN rewrite_tac[closed_interval_def] THEN REPEAT strip_tac);
a(lemma_tac¬µs·0. ¼ s ± s ¼ 1. ´ (Ìy· ExpS1(L(IotaI y, s)))  Loops(O‰S1, ExpS1(L(0., s)))®);
(* *** Goal "1" *** *)
a(rewrite_tac[loops_def] THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(LEMMA_T ¬(Ì y· ExpS1 (L (IotaI y, s))) = (Ì y· (Ìz· ExpS1 (L (z, s))) (IotaI y))®
		pure_rewrite_thm_tac
	THEN1 rewrite_tac[]);
a(bc_thm_tac comp_iota_i_path_thm);
a(REPEAT strip_tac THEN Ö_continuity_tac[]);
a(rewrite_tac[open_s1_def] THEN bc_thm_tac subspace_range_continuous_bc_thm);
a(rewrite_tac[exp_s1_continuous_thm, exp_s1__s1_thm]);
(* *** Goal "1.2" *** *)
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
a(asm_rewrite_tac[iota_i_def]);
(* *** Goal "1.3" *** *)
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
a(asm_rewrite_tac[iota_i_def]);
a(LEMMA_T¬³t ¼ 0.® rewrite_thm_tac THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a(LEMMA_T ¬(if t ¼ 1. then t else 1.) = 1.® rewrite_thm_tac
	THEN1 (cases_tac ¬t ¼ 1.® THEN asm_rewrite_tac[] THEN PC_T1 "¯_lin_arith" asm_prove_tac[]));
a(LEMMA_T¬IotaS1 1. = IotaS1 0.® rewrite_thm_tac THEN DROP_ASMS_T discard_tac);
a(rewrite_tac[iota_s1_def]);
(* *** Goal "2" *** *)
a(all_fc_tac [s1_s1_degree_homotopy_invariant_lemma2]);
a(GET_NTH_ASM_T 2 (strip_asm_tac o µ_elim¬1.®));
a(lemma_tac¬(µ s· ExpS1 ((Ì y· L (IotaI y, 1.)) s) = (Ì y· ExpS1 (L (IotaI y, 1.))) s)®
	THEN1 rewrite_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [loop_s1_degree_def] THEN rewrite_tac[]);
a(POP_ASM_T discard_tac);
a(LEMMA_T¬(Ì y· ExpS1 (L (IotaI y, 1.))) = (Ì t· g (IotaS1 t))® rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[] THEN lemma_tac ¬µx· ExpS1 (L (x, 1.)) = H (IotaS1 x, 1.)®);
(* *** Goal "2.1.1" *** *)
a(REPEAT strip_tac THEN GET_NTH_ASM_T 4 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2.1.2" *** *)
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(rewrite_tac[iota_s1_def, iota_i_def]);
a(if_cases_tac THEN asm_rewrite_tac[]);
a(PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(GET_NTH_ASM_T 5 (rewrite_thm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
a(LEMMA_T ¬IotaI 1. = 1. ± IotaI 0. = 0.® rewrite_thm_tac THEN1 rewrite_tac[iota_i_def]);
a(REPEAT strip_tac);
a(LEMMA_T¬L (1., 1.) + ~ (L (0., 1.)) = L (1., 0.) + ~ (L (0., 0.))® ante_tac);
(* *** Goal "2.2.1" *** *)
a(lemma_tac ¬¶c· µs· L(1., IotaI s) + ~(L(0., IotaI s)) = c®);
(* *** Goal "2.2.1.1" *** *)
a((bc_thm_tac o rewrite_rule [ker_exp_s1_discrete_thm, universe_¯_connected_thm] o
	list_µ_elim[¬O‰R®, ¬{z | ¶i· z = 2. * ú¯ i * Ð} ò‰T O‰R®,
		¬(Ìs· L(1., IotaI s) + ~(L(0., IotaI s)))®])
			connected_discrete_continuous_thm);
a(bc_thm_tac subspace_range_continuous_bc_thm THEN rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.2.1.1.1" *** *)
a(LEMMA_T ¬ExpS1 (L (0., IotaI x')) = ExpS1(L(1., IotaI x'))®
	(strip_asm_tac o rewrite_rule[exp_s1_period_thm1]));
(* *** Goal "2.2.1.1.1.1" *** *)
a(lemma_tac¬0. ¼ IotaI x' ± IotaI x' ¼ 1.®
	THEN1 (rewrite_tac[iota_i_def] THEN if_cases_tac THEN asm_rewrite_tac[]
		THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]));
a(LIST_DROP_NTH_ASM_T [8] (ALL_FC_T rewrite_tac));
a(rewrite_tac[iota_s1_def]);
(* *** Goal "2.2.1.1.1.2" *** *)
a(¶_tac¬i® THEN POP_ASM_T rewrite_thm_tac);
a(PC_T1 "¯_lin_arith" prove_tac[]);
(* *** Goal "2.2.1.1.2" *** *)
a(Ö_continuity_tac[iota_i_continuous_thm]);
(* *** Goal "2.2.1.2" *** *)
a(POP_ASM_T (fn th => (ante_tac o µ_elim¬0.®) th THEN (ante_tac o µ_elim¬1.®) th));
a(rewrite_tac[iota_i_def] THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a(LIST_DROP_NTH_ASM_T [1, 2] rewrite_tac);
a(asm_rewrite_tac[ú¯_one_one_thm, times_2_Ð_lemma]);
a(rewrite_tac[¯_times_assoc_thm1]);
a(rewrite_tac[¯_times_assoc_thm, Ð_recip_clauses, ú¯_one_one_thm, s1_s1_loop_def]);
pop_thm()
));



=TEX
%%%%
%%%%

=SML

val ÛÖ_î_exp__s1_thmÝ = save_thm ( "Ö_î_exp__s1_thm", ( 
set_goal([], ¬µn z·
	z  S1 ´ z^n  S1
®);
a(REPEAT strip_tac THEN induction_tac ¬n:î® THEN rewrite_tac[Ö_î_exp_def]);
(* *** Goal "1" *** *)
a(LEMMA_T ¬îÖ 1 = ExpS1 0.® rewrite_thm_tac);
(* *** Goal "1.1" *** *)
a(rewrite_tac[îÖ_def, exp_s1_def, ¯Ö_def, sin_def]);
(* *** Goal "1.2" *** *)
a(rewrite_tac[exp_s1__s1_thm]);
(* *** Goal "2" *** *)
a(all_fc_tac[s1_times_thm]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML

val ÛÖ_î_exp_s1_s1_continuous_thmÝ = save_thm ( "Ö_î_exp_s1_s1_continuous_thm", ( 
set_goal([], ¬µn· 
	(Ìz· z^n)  (O‰S1, O‰S1) Continuous
®);
a(strip_tac THEN conv_tac ((RIGHT_C o RAND_C o RIGHT_C o rewrite_conv) [open_s1_def]) );
a(bc_thm_tac subspace_range_continuous_bc_thm THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac [Ö_î_exp__s1_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[open_s1_def] THEN bc_thm_tac subspace_domain_continuous_thm);
a(rewrite_tac[] THEN Ö_continuity_tac[]);
pop_thm()
));


=TEX
%%%%
%%%%

=SML

val Ûs1_s1_degree_Ö_î_exp_thmÝ = save_thm ( "s1_s1_degree_Ö_î_exp_thm", ( 
set_goal([], ¬µn· 
	S1S1Degree (Ìz· z^n) = îú n
®);
a(strip_tac THEN rewrite_tac[s1_s1_degree_def]);
a(lemma_tac¬S1S1Loop (Ì z· z ^ n)  Loops(O‰S1, îÖ 1)®);
(* *** Goal "1" *** *)
a((ante_tac o µ_elim¬(Ì z:Ö· z ^ n)®) s1_s1_loop_loop_thm);
a(rewrite_tac[Ö_î_exp_s1_s1_continuous_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¬(Ì x· (Ìy· 2. * Ð * î¯ n * y) (IotaI x))  Paths O‰R® ante_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac comp_iota_i_path_thm);
a(rewrite_tac[] THEN ¯_continuity_tac[]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[] THEN strip_tac);
a(lemma_tac¬µ s· ExpS1 ((Ì x· 2. * Ð * î¯ n * IotaI x) s) = S1S1Loop (Ì z· z ^ n) s®);
(* *** Goal "2.2.1" *** *)
a(µ_tac THEN rewrite_tac[exp_s1_def, s1_s1_loop_def, iota_s1_def, iota_i_def]);
a(if_cases_tac THEN asm_rewrite_tac[de_moivre_thm]
	THEN_TRY SOLVED_T (rewrite_tac[sin_def, îÖ_def, ¯Ö_def]));
(* *** Goal "2.2.1.1" *** *)
a(lemma_tac¬s = 1.® THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN rewrite_tac[îÖ_def, ¯Ö_def]);
a(rewrite_tac[pc_rule1 "¯_lin_arith" prove_rule[] ¬µx y z : ¯· x * y * z = (x * z) * y®,
	rewrite_rule [î¯_times_homomorphism_thm] sin_cos_even_times_Ð_thm]);
(* *** Goal "2.2.1.2" *** *)
a(rewrite_tac[îÖ_def, ¯Ö_def]);
a(rewrite_tac[pc_rule1 "¯_lin_arith" prove_rule[] ¬µx y z : ¯· x * y * z = (x * z) * y®,
	rewrite_rule [î¯_times_homomorphism_thm] sin_cos_even_times_Ð_thm]);
(* *** Goal "2.2.1.3" *** *)
a((conv_tac o ONCE_MAP_C) ¯_anf_conv THEN REPEAT strip_tac);
(* *** Goal "2.2.1.4" *** *)
a(PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2.2" *** *)
a(ALL_FC_T (MAP_EVERY ante_tac) [loop_s1_degree_def]);
a(rewrite_tac[times_2_Ð_lemma, ¯_times_assoc_thm1, iota_i_def]);
a(rewrite_tac[pc_rule1 "¯_lin_arith" prove_rule[] ¬µx y z : ¯· (x * y) * z = y * x * z®,
	Ð_recip_clauses]);
a(LEMMA_T ¬î¯ n = ú¯(îú n)® rewrite_thm_tac THEN1 rewrite_tac[ú¯_îú_thm]);
a(rewrite_tac[ú¯_one_one_thm]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML

val Û¯_recip_Ö_abs_continuous_thmÝ = save_thm ( "¯_recip_Ö_abs_continuous_thm", ( 
set_goal([], ¬
	(Ìz· Abs z ›-›1)  (~{îÖ 0} ò‰T O‰C, {x | 0. < x} ò‰T O‰R) Continuous
®);
a(bc_thm_tac subspace_range_continuous_bc_thm);
a(rewrite_tac[space_t_subspace_open_Ö_thm, Ö_abs_eq_0_thm1] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac ¯_0_less_0_less_recip_thm);
a((strip_asm_tac o µ_elim¬x®) Ö_0_¼_abs_thm);
a(PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(bc_thm_tac comp_continuous_thm);
a(¶_tac¬~{0.} ò‰T O‰R® THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac subspace_range_continuous_bc_thm
	THEN rewrite_tac[space_t_subspace_open_Ö_thm, Ö_abs_eq_0_thm]);
a(bc_thm_tac subspace_domain_continuous_thm THEN rewrite_tac[Ö_abs_continuous_thm]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[(rewrite_rule[(rewrite_rule[open_¯_hausdorff_thm,
	universe_subspace_topology_thm] o
		list_µ_elim[¬O‰R®, ¬Universe:¯ SET®]) punctured_hausdorff_thm] o 
			µ_elim¬~{0.}®) ¯_continuous_cts_thm]);
a(accept_tac recip_cts_thm);
pop_thm()
));

=TEX
%%%%
%%%%

=SML

val Û¯Ö_continuous_thmÝ = save_thm ( "¯Ö_thm", ( 
set_goal([], ¬
	¯Ö  (O‰R, O‰C) Continuous
®);
a(rewrite_tac[prove_rule[¯Ö_def] ¬¯Ö = (Ìx·(x, 0.))®]);
a(Ö_continuity_tac[]);
pop_thm()
));

=TEX

Multiplication is a continuous function from the torus to the circle:
%%%%
%%%%

=SML

val Ûs1_times_continuous_thmÝ = save_thm ( "s1_times_continuous_thm", ( 
set_goal([], ¬
	Uncurry $*  (O‰S1 ¸‰T O‰S1, O‰S1) Continuous
®);
a((conv_tac o RIGHT_C o RAND_C o RIGHT_C) (rewrite_conv[open_s1_def]));
a(bc_thm_tac subspace_range_continuous_bc_thm THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac product_topology_thm THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN pair_tac¬x = (a, b)®);
a(rewrite_tac[¸_def, (rewrite_rule[] o list_µ_elim[¬O‰S1®, ¬O‰S1®])product_topology_space_t_thm]);
a(rewrite_tac[s1_def] THEN REPEAT strip_tac THEN asm_rewrite_tac[Ö_abs_times_thm]);
(* *** Goal "3" *** *)
a(rewrite_tac[open_s1_def, 
	(rewrite_rule [] o list_µ_elim[¬O‰C®, ¬O‰C®]) subspace_product_subspace_thm]);
a(bc_thm_tac subspace_domain_continuous_thm);
a(rewrite_tac[Ö_times_continuous_thm]);
a(basic_topology_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML

val ÛÖ_abs_¯_abs_thmÝ = save_thm ( "Ö_abs_¯_abs_thm", ( 
set_goal([], ¬
	µx· Abs(¯Ö x) = Abs x
®);
a(REPEAT strip_tac THEN rewrite_tac Ö_ops_defs);
a(conv_tac (ONCE_MAP_C ¯_anf_conv) THEN rewrite_tac[sqrt_square_thm]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML

val Ûpp_s1__s1_thmÝ = save_thm ( "pp_s1__s1_thm", ( 
set_goal([], ¬
	µz· ³z = îÖ 0 ´ z * ¯Ö (Abs z ›-›1)  S1
®);
a(µ_tac THEN pair_tac¬(z:Ö) = (a, b)®);
a(rewrite_tac[Ö_abs_eq_0_thm1]);
a(rewrite_tac (s1_def :: Ö_ops_defs) THEN conv_tac (MAP_C ¯_anf_conv));
a(lemma_tac¬0. ¼ a^2 + b^2® THEN1 rewrite_tac[¯_0_¼_square_plus_square_thm]);
a(ALL_FC_T1 fc_¤_canon rewrite_tac[¯_square_eq_0_thm] THEN REPEAT strip_tac);
a(lemma_tac¬0. < a^2 + b^2® THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) ¯_times_plus_distrib_thm]);
a(ALL_FC_T rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) sqrt_recip_thm]);
a(all_fc_tac[¯_0_less_0_less_recip_thm]);
a(lemma_tac¬0. ¼ (a^2 + b^2)›-›1® THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[sqrt_thm]);
a(lemma_tac¬³(a^2 + b^2)›-›1 = 0.® THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[¯_times_recip_thm]);
a(rewrite_tac[sqrt_0_1_thm]);
pop_thm()
));



=TEX

%%%%
%%%%
=SML

val ÛÖ_poly_continuous_thmÝ = save_thm( "Ö_poly_continuous_thm", (
set_goal([], ¬µc n· Poly‰C (c, n)  (O‰C, O‰C) Continuous ®);
a(REPEAT strip_tac THEN once_rewrite_tac[(eq_sym_rule o µ_elim¬Poly‰C(c, n)®)È_axiom]);
a(pure_rewrite_tac[Ö_poly_def]);
a(ho_bc_thm_tac Ö_series_continuous_thm);
a(REPEAT strip_tac THEN Ö_continuity_tac[]);
pop_thm()
));



=TEX
%%%%
%%%%

=SML

val Ûpp_s1_continuous_thmÝ = save_thm ( "pp_s1_continuous_thm", ( 
set_goal([], ¬
	(Ìz· z * ¯Ö (Abs z ›-›1))  (~{îÖ 0} ò‰T O‰C, O‰S1) Continuous
®);
a(rewrite_tac[open_s1_def] THEN bc_thm_tac subspace_range_continuous_bc_thm);
a(rewrite_tac[space_t_subspace_open_Ö_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[pp_s1__s1_thm]);
(* *** Goal "2" *** *)
a(basic_continuity_tac[Ö_times_continuous_thm]);
a(¶_tac¬O‰C ¸‰T O‰C®);
a(rewrite_tac[Ö_times_continuous_thm] THEN REPEAT strip_tac THEN1 basic_topology_tac[]);
a(basic_continuity_tac[]);
(* *** Goal "2.1" *** *)
a(bc_thm_tac subspace_range_continuous_thm);
a(¶_tac¬~{îÖ 0}® THEN rewrite_tac[]);
a(bc_thm_tac i_continuous_thm THEN rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(basic_continuity_tac[¯Ö_continuous_thm]);
a(¶_tac¬O‰R® THEN rewrite_tac[¯Ö_continuous_thm]);
a(bc_thm_tac subspace_range_continuous_thm);
a(¶_tac¬{x | 0. < x}® THEN rewrite_tac[¯_recip_Ö_abs_continuous_thm]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val ÛÖ_times_series_thmÝ = save_thm( "Ö_times_series_thm", (
set_goal([], ¬µz c n·
		z * Series‰C c n = Series‰C (Ìi· z * c i) n
®);
a(REPEAT strip_tac THEN induction_tac¬n:î® THEN
	asm_rewrite_tac[Ö_series_def, Ö_times_plus_distrib_thm]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val ÛÖ_series_const_thmÝ = save_thm( "Ö_series_const_thm", (
set_goal([], ¬µn z·
	Series‰C (Ìi· z) n = îÖ n * z
®);
a(REPEAT strip_tac THEN induction_tac¬n:î® THEN asm_rewrite_tac[Ö_series_def]);
a(rewrite_tac[îÖ_plus_homomorphism_thm, Ö_times_plus_distrib_thm]);
pop_thm()
));



=TEX
%%%%
%%%%
=SML

val ÛÖ_series_eq_thmÝ = save_thm( "Ö_series_eq_thm", (
set_goal([], ¬µn c d·
	(µi· i < n ´ c i = d i)
´	Series‰C c n = Series‰C d n
®);
a(µ_tac THEN induction_tac¬n:î® THEN REPEAT strip_tac THEN rewrite_tac[Ö_series_def]);
a(LEMMA_T ¬c n = d n® rewrite_thm_tac
	THEN1 (POP_ASM_T bc_thm_tac THEN REPEAT strip_tac));
a(DROP_NTH_ASM_T 2 bc_thm_tac THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 bc_thm_tac THEN PC_T1 "lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%

Here it would be nice to have ANF for complex arithmetic.
=SML

val Ûfta_lemma1Ý = save_thm( "fta_lemma", (
set_goal([], ¬µc n z t·
		Series‰C (Ì i· c i * ¯Ö t^(n-i) * z^i) (n + 1) 
	=	¯Ö t * (Series‰C (Ì i· c i * ¯Ö t^((n-1)-i) * z^i) n) + c n * z^n
®);
a(REPEAT strip_tac THEN induction_tac¬n:î® THEN rewrite_tac[Ö_series_def]);
a(POP_ASM_T discard_tac);
a(rewrite_tac[Ö_times_plus_distrib_thm, Ö_times_series_thm]);
a(rewrite_tac[µ_elim¬c n® Ö_times_order_thm]);
a(LEMMA_T ¬µm; u v w:Ö· u * v * u^m * w = v * u^(m+1) * w® rewrite_thm_tac
	THEN1 REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[µ_elim¬w® Ö_times_order_thm]);
a(rewrite_tac[µ_elim¬v® Ö_times_order_thm, Ö_î_exp_def]);
(* *** Goal "2" *** *)
a(LEMMA_T ¬
	Series‰C (Ìi· c i * ¯Ö t ^ (n - i + 1) * z ^ i) n = 
	Series‰C (Ìi· if i < n then c i * ¯Ö t ^ (n - i + 1) * z ^ i else îÖ 0) n
® rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac Ö_series_eq_thm THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(LEMMA_T ¬µi·
	(if i < n then c i * ¯Ö t ^ (n - i + 1) * z ^ i else îÖ 0) =
	(if i < n then c i * ¯Ö t ^ ((n + 1) - i) * z ^ i else îÖ 0)                                ® rewrite_thm_tac);
(* *** Goal "2.2.1" *** *)
a(REPEAT strip_tac THEN if_cases_tac THEN asm_rewrite_tac[]);
a(LEMMA_T ¬n - i + 1 = (n + 1) - i® rewrite_thm_tac);
a(LEMMA_T ¬i ¼ n® (strip_asm_tac o rewrite_rule[¼_def]) THEN1 PC_T1 "lin_arith" asm_prove_tac[]
	THEN all_var_elim_asm_tac1);
a(rewrite_tac[µ_elim¬i'® plus_order_thm]);
a(rewrite_tac[µ_elim¬1® plus_order_thm]);
a(rewrite_tac[plus_assoc_thm1]);
(* *** Goal "2.2.2" *** *)
a(bc_thm_tac Ö_series_eq_thm THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val Ûfta_lemma2Ý = save_thm( "fta_lemma2", (
set_goal([], ¬µc n z t·
	³t = 0.
´	Series‰C (Ì i· c i * ¯Ö t^(n-i) * z^i) (n + 1) = ¯Ö t^n * Poly‰C (c, n) (z * ¯Ö t ›-›1)
®);
a(REPEAT strip_tac THEN induction_tac¬n:î® THEN rewrite_tac[Ö_series_def, Ö_poly_def]);
a(POP_ASM_T discard_tac);
a(rewrite_tac[Ö_times_plus_distrib_thm, Ö_times_series_thm]);
a((bc_thm_tac o prove_rule[])¬µa x b y c z :Ö· c = z ± b = y ± a = x ´ (a + b) + c = (x + y) + z®
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[µ_elim¬c(n+1)® Ö_times_order_thm]);
a((bc_thm_tac o prove_rule[])¬µa x y:Ö· x = y ´ a * x = a * y®);
a(rewrite_tac[Ö_î_exp_times_thm]);
a(rewrite_tac[µ_elim¬z^(n+1)® Ö_times_order_thm]);
a(LEMMA_T ¬µx y· x = y ¤ x * îÖ 1 = y® pure_once_rewrite_thm_tac THEN1 rewrite_tac[]);
a((bc_thm_tac o prove_rule[])¬µa x y:Ö· x = y ´ a * x = a * y®);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) Ö_î_exp_times_thm]);
a(LEMMA_T ¬¯Ö t * ¯Ö t ›-›1 = îÖ 1® rewrite_thm_tac);
a(bc_thm_tac Ö_times_recip_thm);
a(asm_rewrite_tac[¯Ö_def, îÖ_def]);
(* *** Goal "2" *** *)
a(rewrite_tac[µ_elim¬c n® Ö_times_order_thm]);
a((bc_thm_tac o prove_rule[])¬µa x y:Ö· x = y ´ a * x = a * y®);
a(rewrite_tac[Ö_î_exp_def, Ö_times_assoc_thm]);
a((bc_thm_tac o prove_rule[])¬µa x y:Ö· x = y ´ a * x = a * y®);
a(rewrite_tac[Ö_î_exp_times_thm]);
a(rewrite_tac[µ_elim¬z^n® Ö_times_order_thm]);
a(LEMMA_T ¬µx y· x = y ¤ x * îÖ 1 = y® pure_once_rewrite_thm_tac THEN1 rewrite_tac[]);
a((bc_thm_tac o prove_rule[])¬µa x y:Ö· x = y ´ a * x = a * y®);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) Ö_î_exp_times_thm]);
a(LEMMA_T ¬¯Ö t * ¯Ö t ›-›1 = îÖ 1® rewrite_thm_tac);
a(bc_thm_tac Ö_times_recip_thm);
a(asm_rewrite_tac[¯Ö_def, îÖ_def]);
(* *** Goal "3" *** *)
a(bc_thm_tac Ö_series_eq_thm);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(rewrite_tac[µ_elim¬c i® Ö_times_order_thm]);
a((bc_thm_tac o prove_rule[])¬µa x y:Ö· x = y ´ a * x = a * y®);
a(rewrite_tac[Ö_î_exp_times_thm]);
a(rewrite_tac[µ_elim¬z ^ i® Ö_times_order_thm]);
a((bc_thm_tac o prove_rule[])¬µa x y:Ö· x = y ´ a * x = a * y®);
a(lemma_tac¬³¯Ö t = îÖ 0® THEN1 asm_rewrite_tac Ö_ops_defs);
a(lemma_tac¬i ¼ n + 1® THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[Ö_î_exp_recip_thm, Ö_î_exp_minus_thm]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val Ûfta_lemma3Ý = save_thm( "fta_lemma3", (
set_goal([], ¬µc n·
	(Ì(z, t)· Series‰C (Ì i· c i * ¯Ö t^(n-i) * z^i) (n + 1))  (O‰C ¸‰T O‰R, O‰C) Continuous 
®);
a(REPEAT strip_tac THEN conv_tac(ONCE_MAP_C Ì_pair_conv));
a((bc_thm_tac o
	conv_rule (ONCE_MAP_C Ì_pair_conv) o
	rewrite_rule[] o
	list_µ_elim[¬O‰C ¸‰T O‰R®, ¬Ìi (z, t)· c i * ¯Ö t^(n-i) * z^i®, ¬n+1®])
		Ö_series_continuous_thm);
a(REPEAT strip_tac THEN1 basic_topology_tac[]);
a(Ö_continuity_tac[rewrite_rule[open_Ö_def] ¯Ö_continuous_thm]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val Ûfta_lemma4Ý = save_thm( "fta_lemma4", (
set_goal([], ¬µc n·
	(µz· ³Poly‰C (c, n) z = îÖ 0)
´	(Ìz· z * ¯Ö (Abs z ›-›1)) o (Ì(z, t)· Poly‰C (c, n) (¯Ö t*z))  (O‰S1 ¸‰T O‰R, O‰S1) Continuous 
®);
a(REPEAT strip_tac THEN bc_thm_tac o_continuous_thm);
a(¶_tac ¬~{îÖ 0} ò‰T O‰C® THEN rewrite_tac[pp_s1_continuous_thm]);
a(REPEAT strip_tac THEN1 basic_topology_tac[]);
a(bc_thm_tac subspace_range_continuous_bc_thm);
a(rewrite_tac[] THEN REPEAT strip_tac THEN1 basic_topology_tac[] THEN1 asm_rewrite_tac[]);
a(rewrite_tac[open_s1_def]);
a(once_rewrite_tac[(eq_sym_rule o µ_elim¬O‰R®) universe_subspace_topology_thm]);
a(rewrite_tac[(rewrite_rule[] o list_µ_elim[¬O‰C®, ¬O‰R®]) subspace_product_subspace_thm]);
a(bc_thm_tac subspace_domain_continuous_thm);
a(REPEAT strip_tac THEN1 basic_topology_tac[]);
a(Ö_continuity_tac[¯Ö_continuous_thm, Ö_poly_continuous_thm]
	THEN rewrite_tac[eq_sym_rule open_Ö_def, ¯Ö_continuous_thm, Ö_poly_continuous_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val Ûfta_lemma5Ý = save_thm( "fta_lemma5", (
set_goal([], ¬µc n·
	(µz· ³Poly‰C (c, n) z = îÖ 0)
´	((O‰S1, {}, O‰S1) Homotopic)
	((Ìz· z * ¯Ö (Abs z ›-›1)) o (Ìz· Poly‰C (c, n) (îÖ 0)))
	((Ìz· z * ¯Ö (Abs z ›-›1)) o (Poly‰C (c, n)))
®);
a(REPEAT strip_tac THEN rewrite_tac[homotopic_def, homotopy_def]);
a(¶_tac¬(Ìz· z * ¯Ö (Abs z ›-›1)) o (Ì(z, t)· Poly‰C (c, n) (¯Ö t*z))®
	THEN ALL_FC_T rewrite_tac[fta_lemma4]);
a(rewrite_tac[o_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac Ö_ops_defs);
(* *** Goal "2" *** *)
a(rewrite_tac Ö_ops_defs);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val Ûfta_lemma6Ý = save_thm( "fta_lemma6", (
set_goal([], ¬µc n·
	(µz· ³Poly‰C (c, n) z = îÖ 0) ± ³c n = îÖ 0
´	(Ìz· z * ¯Ö (Abs z ›-›1)) o (Ì(z, t)· Series‰C (Ì i· c i * ¯Ö t^(n-i) * z^i) (n + 1))
		 (O‰S1 ¸‰T O‰R, O‰S1) Continuous 
®);
a(REPEAT strip_tac THEN bc_thm_tac o_continuous_thm);
a(¶_tac ¬~{îÖ 0} ò‰T O‰C® THEN rewrite_tac[pp_s1_continuous_thm]);
a(REPEAT strip_tac THEN1 basic_topology_tac[]);
a(bc_thm_tac subspace_range_continuous_bc_thm);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(basic_topology_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[]);
(* *** Goal "3" *** *)
a(pair_tac¬x = (w, s)® THEN POP_ASM_T ante_tac);
a(rewrite_tac[(rewrite_rule[] o list_µ_elim[¬O‰S1®, ¬O‰R®])product_topology_space_t_thm, ¸_def]);
a(REPEAT strip_tac THEN cases_tac¬s = 0.® THEN1 all_var_elim_asm_tac1);
(* *** Goal "3.1" *** *)
a(LEMMA_T ¬
	Series‰C (Ì i· c i * ¯Ö 0. ^ (n - i) * w ^ i) (n + 1) =
	Series‰C (Ì i·if i = n then c n * w^n else îÖ 0) (n + 1)® rewrite_thm_tac);
(* *** Goal "3.1.1" *** *)
a(bc_thm_tac Ö_series_eq_thm THEN REPEAT strip_tac THEN rewrite_tac[]);
a(if_cases_tac THEN asm_rewrite_tac[]);
a(lemma_tac¬i < n® THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(POP_ASM_T ante_tac THEN DROP_ASMS_T discard_tac);
a(rewrite_tac[less_def, ¼_def] THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(rewrite_tac[µ_elim¬i® plus_order_thm]);
a(rewrite_tac[µ_elim¬i'® plus_order_thm]);
a(rewrite_tac Ö_ops_defs);
(* *** Goal "3.1.2" *** *)
a(rewrite_tac[Ö_series_def]);
a(LEMMA_T ¬
	Series‰C (Ì i· if i = n then c n * w ^ n else îÖ 0) n =
	Series‰C (Ì i· îÖ 0) n® rewrite_thm_tac);
(* *** Goal "3.1.2.1" *** *)
a(bc_thm_tac Ö_series_eq_thm THEN REPEAT strip_tac THEN rewrite_tac[]);
a(if_cases_tac THEN asm_rewrite_tac[]);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "3.1.2.2" *** *)
a(rewrite_tac[Ö_series_const_thm]);
a(asm_rewrite_tac [Ö_times_eq_0_thm1]);
a(bc_thm_tac Ö_î_exp_³_eq_0_thm);
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[Ö_abs_eq_0_thm, s1_def]);
a(rewrite_tac (sqrt_0_1_thm::Ö_ops_defs));
(* *** Goal "3.2" *** *)
a(lemma_tac¬³¯Ö s = îÖ 0® THEN1 asm_rewrite_tac Ö_ops_defs);
a(ALL_FC_T rewrite_tac[fta_lemma2]);
a((strip_asm_tac o list_µ_elim[¬n®, ¬¯Ö s®]) Ö_î_exp_³_eq_0_thm);
a(asm_rewrite_tac[Ö_times_eq_0_thm1]);
(* *** Goal "4" *** *)
a(rewrite_tac[open_s1_def]);
a(once_rewrite_tac[(eq_sym_rule o µ_elim¬O‰R®) universe_subspace_topology_thm]);
a(rewrite_tac[(rewrite_rule[] o list_µ_elim[¬O‰C®, ¬O‰R®]) subspace_product_subspace_thm]);
a(bc_thm_tac subspace_domain_continuous_thm);
a(REPEAT strip_tac THEN1 basic_topology_tac[]);
a(rewrite_tac[fta_lemma3]);
fta_lemma3;
pop_thm()
));

=TEX
%%%%
%%%%
=SML
(*

val Ûfta_lemma7Ý = save_thm( "fta_lemma7", (
set_goal([], ¬µc n·
	(µz· ³Poly‰C (c, n) z = îÖ 0) ± ³c n = îÖ 0
´	((O‰S1, {}, O‰S1) Homotopic)
	(Ìz· z^n)
	((Ìz· z * ¯Ö (Abs z ›-›1)) o (Poly‰C (c, n)))
®);
a(REPEAT strip_tac THEN rewrite_tac[homotopic_def, homotopy_def]);
a(¶_tac¬(Ì(z, t)· Series‰C (Ì i· c i * ¯Ö t^(n-i) * z^i) (n + 1))®
	THEN ALL_FC_T rewrite_tac[fta_lemma3]);
a(rewrite_tac[o_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac Ö_ops_defs);
(* *** Goal "2" *** *)
a(rewrite_tac Ö_ops_defs);


pop_thm()
));

*)
=TEX
%%%%
%%%%

=SML

val Ûconstant_term_0_root_thmÝ = save_thm ( "constant_term_0_root_thm", ( 
set_goal([], ¬µs n· 
	s 0 = îÖ 0 ´ Poly‰C (s, n) (îÖ 0) = îÖ 0
®);
a(rewrite_tac[Ö_poly_def] THEN REPEAT strip_tac THEN induction_tac¬n:î®);
(* *** Goal "1" *** *)
a(pure_rewrite_tac[Ö_series_def] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(once_rewrite_tac[Ö_series_def] THEN asm_rewrite_tac[]);
pop_thm()
));

=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val ÛsectionsÝ = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="wrk072.th.doc", theory="Ö"};
end;
=TEX
} %\Hide
\end{document}


