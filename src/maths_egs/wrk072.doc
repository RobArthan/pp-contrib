=IGN
********************************************************************************
wrk072.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
$Id: wrk072.doc,v 1.10 2010/10/24 13:37:17 rda Exp rda $
********************************************************************************
% wrk072.doc $Revision: 1.10 $ $RCSfile: wrk072.doc,v $ $Date: 2010/10/24 13:37:17 $
=TEX
\documentclass[12pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}
\def\Hide#1{\relax}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\C{\mathbb{C}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\title{Mathematical Case Studies: the Complex Numbers\thanks{Copyright {\copyright} Lemma 1 Ltd. \number\year; filed in the {\Product} source code repository as {\tt wrk072.doc}; $Revision: 1.10 $.}}
\author{Rob Arthan\\{\tt rda@lemma-one.com}}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}

Definitions of the complex numbers and their arithmetic operators in {\ProductHOL} with proofs of some of their elementary algebraic properties.

\end{abstract}
%\newpage
%\tableofcontents
%\newpage
\section{INTRODUCTION}
This document contains the beginnings of a theory of complex arithmetic in {\ProductHOL}.

After some preliminaries, section~\ref{theory} introduces the field operations and the embedddings of the real numbers and of conjugation (which help to abbreviate the definition of reciprocals).
We then define the derived operations of binary subtraction and division and the embedding of the natural numbers.

A proof script contained in the source of this document but hidden from the printed document gives proofs that the complex numbers form a field and  of some elementary algebraic properties of complex conjugation and of the embeddings of the natural numbers and the real numbers in the complex numbers.
With one exception, the proofs comprise nothing more than simplifying using definitions and standard theorems and then application of the decision procedure for linear arithmetic to prove the resulting problem of real algebra.
The exception is proving that $xx^{-1} = 1$, which requires a few lines of reasoning about real squares.
A listing of the theorems proved is given in appendix~\ref{listing}.


\section{THE THEORY Ö}\label{theory}

\subsection{Preliminaries}
The following commands set up a theory to hold the definitions, theorems, etc.
The theory has the theory of analysis defined in ~\cite{LEMMA1/HOL/WRK066} for its parent, although the elementary algebraic theory only needs one or two little theorems about squares.
=SML
force_delete_theory"Ö" handle Fail _ => ();
open_theory"analysis";
new_theory"Ö";
new_parent"topology_¯";
=TEX
Now set up a convenient proof context:
=SML
set_merge_pcs["basic_hol1", "'ú", "'¯", "'sets_alg"];
=TEX
\subsection{The Type Ö}
The type Ö comprises pairs of real numbers.
We capture this in a type abbreviation:
=SML
declare_type_abbrev("Ö", [], ”¯ ¸ ¯®);
=TEX
\subsection{Algebraic Operators}
\subsubsection{Addition}

=SML
declare_infix(300, "+‰C");
=TEX

¹HOLCONST
Ü $Û+‰Cİ : Ö ­ Ö ­ Ö
÷üüüüüü
Üµ z w : Ö· z +‰C w = (Fst z + Fst w, Snd z + Snd w)
°

=SML
declare_alias("+", ¬$+‰C®);
=TEX
\subsubsection{Negation}

¹HOLCONST
Ü Û~‰Cİ : Ö ­ Ö
÷üüüüüü
Üµ z : Ö· ~‰C z = (~(Fst z), ~(Snd z))
°
=SML
declare_alias("~", ¬~‰C®);
=TEX

=TEX
\subsubsection{Multiplication}
=SML
declare_infix(310, "*‰C");
=TEX

¹HOLCONST
Ü $Û*‰Cİ : Ö ­ Ö ­ Ö
÷üüüüüü
Üµ z w : Ö·
Ü	z *‰C w = (Fst z * Fst w - Snd z * Snd w, Fst z * Snd w + Snd z * Fst w)
°

=SML
declare_alias("*", ¬$*‰C®);
=TEX
\subsubsection{Embedding of the Real Numbers}


¹HOLCONST
Ü Û¯Öİ : ¯ ­ Ö
÷üüüüüü
Üµx· ¯Ö x = (x, î¯ 0)
°
\subsubsection{Conjugation}
=SML
declare_postfix(320, "›_");
=TEX
¹HOLCONST
Ü Û$›_İ : Ö ­ Ö
÷üüüüüü
Üµ z : Ö· z ›_ = (Fst z, ~(Snd z))
°
\subsubsection{Reciprocal}
=SML
declare_postfix(320, "›-›1›C");
=TEX

¹HOLCONST
Ü $Û›-›1›Cİ : Ö ­ Ö
÷üüüüüü
Üµ z : Ö· z ›-›1›C = z ›_ * ¯Ö(Fst (z * z ›_) ›-›1)
°

=SML
declare_alias("›-›1", ¬$›-›1›C®);
=TEX


\subsubsection{Subtraction}
=SML
declare_infix(300, "-‰C");
=TEX

¹HOLCONST
Ü $Û-‰Cİ : Ö ­ Ö ­ Ö
÷üüüüüü
Üµ z w : Ö· z -‰C w = z + ~w
°



\subsubsection{Division}
=SML
declare_infix(315, "/‰C");
=TEX

¹HOLCONST
Ü $Û/‰Cİ : Ö ­ Ö ­ Ö
÷üüüüüü
Üµ z w : Ö· z /‰C w = z * (w ›-›1)
°


=SML
declare_alias("/", ¬$/‰C®);
=TEX
\subsubsection{Embedding of the Natural Numbers}


¹HOLCONST
Ü ÛîÖİ : î ­ Ö
÷üüüüüü
Üµm· îÖ m = ¯Ö(î¯ m)
°

\subsubsection{Exponentiation with Natural Number Exponents}

=SML
declare_infix(320, "^‰C");
=TEX
¹HOLCONST
Ü $Û^‰Cİ : Ö ­ î ­ Ö
÷üüüüüü
Ü	(µ z: Ö· z ^‰C 0 = îÖ 1)
Ü ±	(µ z: Ö; m· z ^‰C (m+1) = z * z ^‰C m)
°

=SML
declare_alias("^", ¬$^‰C®);
=TEX
\section{Ö {\it qua} Real Normed Space}
=SML
declare_infix(310, "*‰RC");
=TEX

¹HOLCONST
Ü $Û*‰RCİ : ¯ ­ Ö ­ Ö
÷üüüüüü
Üµ x: ¯; v : Ö·
Ü	x *‰RC v = ¯Ö x *‰C v
°

¹HOLCONST
Ü $ÛAbs‰Cİ : Ö ­ ¯
÷üüüüüü
Üµ v : Ö·
Ü	Abs‰C v = Sqrt(Fst (v * v ›_))
°

\section{Topology}
The topology of Ö is just the product topology.
¹HOLCONST
Ü $ÛOpen‰Cİ : Ö SET SET
÷üüüüüü
Ü Open‰C = Open‰R ¸‰T Open‰R
°
The unit circle:
¹HOLCONST
Ü $ÛS1İ : Ö SET
÷üüüüüü
Ü S1 = {z | Abs‰C z = 1.}
°
and the exponential mapping of the real line onto the unit circle:
¹HOLCONST
Ü $ÛExpS1İ : ¯ ­ Ö
÷üüüüüü
Ü µt· ExpS1 t = (Cos t, Sin t)
°

=TEX
%\twocolumn[\section{INDEX}\label{INDEX}]
%{\printindex}

\bibliographystyle{plain}
\bibliography{fmu}

\appendix
{\HOLindexOff
\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{wrk072.th}}

=TEX
\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
=TEX
Set context for proofs in case of future expansion.
=SML
open_theory"Ö";
set_merge_pcs["basic_hol1", "'ú", "'¯", "'sets_alg"];
=TEX

%%%%
%%%%
=SML

val ÛÖ_plus_defİ = get_spec ¬$+‰C®;
val ÛÖ_minus_defİ = get_spec ¬~‰C®;
val ÛÖ_conj_defİ = get_spec ¬$›_®;
val ÛÖ_times_defİ = get_spec ¬$*‰C®;
val ÛÖ_recip_defİ = get_spec ¬$›-›1›C®;
val ÛÖ_subtract_defİ = get_spec ¬$-‰C®;
val ÛîÖ_defİ = get_spec ¬îÖ®;
val Û¯Ö_defİ = get_spec ¬¯Ö®;
val Û¯_Ö_times_defİ = get_spec ¬$*‰RC®;
val ÛÖ_î_exp_defİ = get_spec ¬$^‰C®;
val ÛÖ_abs_defİ = get_spec ¬Abs‰C®;
val ÛÖ_ops_defsİ = [Ö_plus_def, Ö_minus_def, Ö_conj_def, Ö_times_def,
	Ö_recip_def, Ö_subtract_def, îÖ_def, ¯Ö_def, Ö_î_exp_def];
val Ûopen_Ö_defİ = get_spec ¬Open‰C®;
val Ûs1_defİ = get_spec ¬S1®;
val Ûexp_s1_defİ = get_spec ¬ExpS1®;
val Ûexp_s1_def1İ = ¤_t_elim (rewrite_conv[exp_s1_def]
	¬ExpS1 = (Ì x· (Cos x, Sin x))®);
=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y:Ö· x + y = y + x®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_plus_comm_thmİ = save_pop_thm "Ö_plus_comm_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y z:Ö· (x + y) + z = x + y + z®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_plus_assoc_thmİ = save_pop_thm "Ö_plus_assoc_thm";

val ÛÖ_plus_assoc_thm1İ = save_thm ("Ö_plus_assoc_thm1",
	conv_rule(ONCE_MAP_C eq_sym_conv) Ö_plus_assoc_thm);
=SML
set_goal([], ¬µ x:Ö· x + îÖ 0 = x®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_plus_0_thmİ = save_pop_thm "Ö_plus_0_thm";
=SML
set_goal([], ¬µ x:Ö· x + ~x = îÖ 0®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_plus_minus_thmİ = save_pop_thm "Ö_plus_minus_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x:Ö·
	x * (x ›_) = ¯Ö(Fst x ^ 2 + Snd x ^ 2)
®);
a(rewrite_tac (¯_î_exp_square_thm::Ö_ops_defs) THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_times_conj_thmİ = save_pop_thm "Ö_times_conj_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y:Ö· x * y = y * x®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_times_comm_thmİ = save_pop_thm "Ö_times_comm_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y z:Ö· (x * y) * z = x * y * z®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_times_assoc_thmİ = save_pop_thm "Ö_times_assoc_thm";

val ÛÖ_times_assoc_thm1İ = save_thm ("Ö_times_assoc_thm1",
	conv_rule(ONCE_MAP_C eq_sym_conv) Ö_times_assoc_thm);

=SML
set_goal([], ¬µ x:Ö· x * îÖ 1 = x®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_times_1_thmİ = save_pop_thm "Ö_times_1_thm";
=SML
set_goal([], ¬µ x:Ö· ³x = îÖ 0 ´ x * x ›-›1 = îÖ 1®);
a(rewrite_tac [Ö_recip_def, Ö_times_conj_thm]);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) Ö_times_assoc_thm, Ö_times_conj_thm]);
a(rewrite_tac Ö_ops_defs);
a(µ_tac THEN STRIP_T asm_tac);
a(bc_thm_tac (rewrite_rule[](nth 2 (fc_canon(±_left_elim ¯_recip_clauses)))));
a(strip_asm_tac(µ_elim¬Fst x® ¯_0_¼_square_thm));
a(strip_asm_tac(µ_elim¬Snd x® ¯_0_¼_square_thm));
a(swap_nth_asm_concl_tac 3);
a(LEMMA_T ¬Fst x ^ 2 = î¯ 0 ± Snd x ^ 2  = î¯ 0® ante_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[¯_square_eq_0_thm]);
val ÛÖ_times_recip_thmİ = save_pop_thm "Ö_times_recip_thm";

val ÛÖ_times_recip_thm1İ = save_thm ("Ö_times_recip_thm1",
	conv_rule(once_rewrite_conv[Ö_times_comm_thm]) Ö_times_recip_thm);

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ z w:Ö· ³z = îÖ 0 ± z*w = îÖ 1 ´ w = z ›-›1®);
a(REPEAT strip_tac);
a(LEMMA_T¬z ›-›1 * z * w = z ›-›1® ante_tac
	THEN1 asm_rewrite_tac[Ö_times_1_thm]);
a(rewrite_tac[Ö_times_assoc_thm1]);
a(conv_tac(LEFT_C(LEFT_C(once_rewrite_conv[Ö_times_comm_thm]))));
a(ALL_FC_T rewrite_tac[Ö_times_recip_thm1]);
a(rewrite_tac[Ö_times_1_thm]);
val ÛÖ_times_eq_1_thmİ = save_pop_thm "Ö_times_eq_1_thm";


=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y z:Ö· x * (y + z) = x * y + x * z®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_times_plus_distrib_thmİ = save_pop_thm "Ö_times_plus_distrib_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y:Ö· (x + y) ›_  = x ›_ + y ›_®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_conj_plus_homomorphism_thmİ = save_pop_thm "Ö_conj_plus_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y:Ö· (x * y) ›_  = x ›_ * y ›_®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val ÛÖ_conj_times_homomorphism_thmİ = save_pop_thm "Ö_conj_times_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y:¯· ¯Ö(x + y) = ¯Ö x + ¯Ö y®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û¯Ö_plus_homomorphism_thmİ = save_pop_thm "¯Ö_plus_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y:¯· ¯Ö(x * y) = ¯Ö x * ¯Ö y®);
a(rewrite_tac Ö_ops_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û¯Ö_times_homomorphism_thmİ = save_pop_thm "¯Ö_times_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y:î· îÖ(x + y) = îÖ x + îÖ y®);
a(rewrite_tac (î¯_plus_homomorphism_thm::Ö_ops_defs));
val ÛîÖ_plus_homomorphism_thmİ = save_pop_thm "îÖ_plus_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x y:î· îÖ(x * y) = îÖ x * îÖ y®);
a(rewrite_tac (î¯_times_homomorphism_thm::Ö_ops_defs));
val ÛîÖ_times_homomorphism_thmİ = save_pop_thm "îÖ_times_homomorphism_thm";

=TEX
=IGN
set_goal([], ¬µ x y:ú· úÖ(x + y) = úÖ x + úÖ y®);
a(rewrite_tac (ú¯_plus_homomorphism_thm::Ö_ops_defs));
val ÛúÖ_plus_homomorphism_thmİ = save_pop_thm "úÖ_plus_homomorphism_thm";

=TEX
=IGN
set_goal([], ¬µ x y:ú· úÖ(x * y) = úÖ x * úÖ y®);
a(rewrite_tac (ú¯_times_homomorphism_thm::Ö_ops_defs));
val ÛúÖ_times_homomorphism_thmİ = save_pop_thm "úÖ_times_homomorphism_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µ x m·
	(Cos x, Sin x) ^ m =
	(Cos (î¯ m * x), Sin (î¯ m * x))
®);
a(REPEAT µ_tac THEN induction_tac¬m:î®
	THEN asm_rewrite_tac 
	(sin_def::î¯_plus_homomorphism_thm::
		¯_times_plus_distrib_thm::
		sin_cos_plus_thm::Ö_ops_defs));
a(PC_T1 "¯_lin_arith" prove_tac[]);
val Ûde_moivre_thmİ = save_pop_thm "de_moivre_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬
	Open‰C  Topology
®);
a(rewrite_tac[open_Ö_def]);
a(bc_thm_tac product_topology_thm THEN rewrite_tac[open_¯_topology_thm]);
val Ûopen_Ö_topology_thmİ = save_pop_thm "open_Ö_topology_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬
	Open‰C  Hausdorff
®);
a(rewrite_tac[open_Ö_def, open_¯_¸_open_¯_hausdorff_thm]);
val Ûopen_Ö_hausdorff_thmİ = save_pop_thm "open_Ö_hausdorff_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬
	Universe  Open‰C
®);
a(rewrite_tac[open_Ö_def]);
a(rewrite_tac[product_topology_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(¶_tac¬Universe® THEN ¶_tac¬Universe® THEN rewrite_tac[empty_universe_open_closed_thm]);
val Ûuniverse_open_Ö_thmİ = save_pop_thm "universe_open_Ö_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬
	Space‰T Open‰C = Universe
®);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(bc_thm_tac _space_t_thm);
a(¶_tac¬Universe® THEN PC_T1 "sets_ext1" rewrite_tac[universe_open_Ö_thm]);
val Ûspace_t_open_Ö_thmİ = save_pop_thm "space_t_open_Ö_thm";

val Ûspace_t_subspace_open_Ö_thmİ = save_thm ("space_t_subspace_open_Ö_thm",
	rewrite_rule[open_Ö_topology_thm, space_t_open_Ö_thm]
	(µ_elim¬Open‰C® subspace_topology_space_t_thm));

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µÔ : 'a SET SET; r i: 'a ­ ¯·
	Ô  Topology
´	(	(Ìx·(r x, i x))  (Ô, Open‰C) Continuous
	¤	r  (Ô, Open‰R) Continuous
	±	i  (Ô, Open‰R) Continuous)
®);
a(REPEAT µ_tac THEN ´_tac);
a(strip_asm_tac open_¯_topology_thm);
a(rewrite_tac[open_Ö_def]);
a(ALL_FC_T1 fc_¤_canon rewrite_tac[product_continuous_¤_thm]);
val Ûcontinuous_open_Ö_thm1İ = save_pop_thm "continuous_open_Ö_thm1";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µr i: ¯ ­ ¯·
	(Ìx·(r x, i x))  (Open‰R, Open‰C) Continuous ¤	
	(µx· r Cts x) ± (µx· i Cts x)
®);
a(REPEAT µ_tac);
a(strip_asm_tac open_¯_topology_thm);
a(ALL_FC_T1 fc_¤_canon rewrite_tac[continuous_open_Ö_thm1]);
a(rewrite_tac[continuous_cts_at_¯_thm]);
val Ûcontinuous_open_Ö_thm2İ = save_pop_thm "continuous_open_Ö_thm2";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬
	ExpS1  (Open‰R, Open‰C) Continuous
®);
a(rewrite_tac[exp_s1_def1, continuous_open_Ö_thm2, sin_cos_cts_thm]);
val Ûexp_s1_continuous_thmİ = save_pop_thm "exp_s1_continuous_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µx y· Sqrt(x^2 + y^2) = 1. ¤ x^2 + y^2 = 1. ®);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¬0. ¼ x^2 ± 0. ¼ y^2® THEN1 rewrite_tac[¯_0_¼_square_thm]);
a(lemma_tac¬0. ¼ x^2 + y^2® THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [2, 3] discard_tac THEN all_fc_tac[sqrt_0_¼_thm, sqrt_thm]);
a(POP_ASM_T (once_rewrite_thm_tac o eq_sym_rule));
a(asm_rewrite_tac[¯_î_exp_square_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[sqrt_0_1_thm]);
val ÛÖ_abs_squared_lemmaİ = save_pop_thm "Ö_abs_squared_lemma";

=TEX

%%%%
%%%%
=SML


set_goal([], ¬µz· z  S1 ¤ Fst z^2 + Snd z^2 = 1.®);
a(MERGE_PCS_T1 ["'pair", "sets_ext1"] rewrite_tac[s1_def, Ö_abs_def, Ö_times_conj_thm, ¯Ö_def, Ö_abs_squared_lemma]);
val Û_s1_lemmaİ = save_pop_thm "_s1_lemma";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µx y· ExpS1(x + y) = ExpS1 x * ExpS1 y®);
a(rewrite_tac[exp_s1_def, Ö_times_def, sin_cos_plus_thm]);
val Ûexp_s1_homomorphism_thmİ = save_pop_thm "exp_s1_homomorphism_thm";

val Ûexp_s1_homomorphism_thm1İ = save_thm ("exp_s1_homomorphism_thm1",
	conv_rule(ONCE_MAP_C eq_sym_conv) exp_s1_homomorphism_thm);


=TEX

%%%%
%%%%
=SML

set_goal([], ¬µx· ExpS1(~x) = ExpS1 x ›-›1®);
a(REPEAT strip_tac THEN bc_thm_tac Ö_times_eq_1_thm);
a(rewrite_tac[exp_s1_homomorphism_thm1]);
a(rewrite_tac[exp_s1_def, îÖ_def, ¯Ö_def, sin_def]);
a(contr_tac THEN ante_tac (µ_elim¬x® cos_squared_plus_sin_squared_thm));
a(asm_rewrite_tac[¯_î_exp_square_thm]);
val Ûexp_s1_minus_thmİ = save_pop_thm "exp_s1_minus_thm";


=TEX

%%%%
%%%%
=SML

set_goal([], ¬µx· ExpS1 x  S1®);
a(rewrite_tac[exp_s1_def, _s1_lemma, cos_squared_plus_sin_squared_thm]);
val Ûexp_s1__s1_thmİ = save_pop_thm "exp_s1__s1_thm";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µx y· ExpS1 x = ExpS1 y ¤ (¶m· y = x + î¯(2*m) * Ğ ² x = y + î¯(2*m) * Ğ)®);
a(lemma_tac¬
	(µx y· x < y ´
		(ExpS1 x = ExpS1 y ¤ (¶m· y = x + î¯(2*m) * Ğ)))
±	(µx y m· x < y ´ ³ x = y + î¯ (2 * m) * Ğ)
®
	THEN1 ±_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[exp_s1_def,
	taut_rule¬µx y p· Cos x = y ± p ¤ p ± Cos x = y®,
	sin_cos_period_thm]);
(* *** Goal "2" *** *)
a(contr_tac THEN all_var_elim_asm_tac1);
a(lemma_tac ¬0. ¼ î¯ (2 * m) * Ğ® THEN_LIST [
	bc_thm_tac ¯_0_¼_0_¼_times_thm,
	PC_T1 "¯_lin_arith" asm_prove_tac[]]);
a(rewrite_tac[î¯_¼_thm] THEN rewrite_tac[¯_¼_def, Ğ_def]);
(* *** Goal "3" *** *)
a(REPEAT µ_tac);
a(lemma_tac¬x = y ² x < y ² y < x® THEN1 PC_T1 "¯_lin_arith" prove_tac[]
	THEN1 (all_var_elim_asm_tac THEN rewrite_tac[]));
(* *** Goal "3.1" *** *)
a(¶_tac¬0® THEN rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(LIST_DROP_NTH_ASM_T [2, 3] (ALL_FC_T1 fc_¤_canon rewrite_tac));
(* *** Goal "3.3" *** *)
a(conv_tac(LEFT_C eq_sym_conv));
a(LIST_DROP_NTH_ASM_T [2, 3] (ALL_FC_T1 fc_¤_canon rewrite_tac));
val Ûexp_s1_period_thmİ = save_pop_thm "exp_s1_period_thm";

=TEX

%%%%
%%%%
=SML


set_goal([], ¬µz· z  S1 ´ ¶‰1x· 0. ¼ x ± x < 2. * Ğ ± z = ExpS1 x®);
a(rewrite_tac[_s1_lemma, exp_s1_def] THEN REPEAT strip_tac);
a(bc_thm_tac sin_cos_onto_unit_circle_thm1 THEN strip_tac);
val Ûexp_s1_onto_thmİ = save_pop_thm "exp_s1_onto_thm";

=TEX

%%%%
%%%%
=SML


set_goal([], ¬µz w· z  S1 ± w  S1 ´ z*w  S1®);
a(REPEAT strip_tac THEN all_fc_tac[exp_s1_onto_thm]
	THEN all_var_elim_asm_tac1);
a(rewrite_tac[exp_s1_homomorphism_thm1, exp_s1__s1_thm]);
val Ûs1_times_thmİ = save_pop_thm "s1_times_thm";

=TEX

%%%%
%%%%
=SML


set_goal([], ¬µc z·
	z  S1
´	¶‰1x· c - Ğ ¼ x ± x < c + Ğ ± z = ExpS1 x®);
a(REPEAT strip_tac);
a(all_fc_tac[exp_s1_onto_thm] THEN all_var_elim_asm_tac1);
a(lemma_tac¬ExpS1 (x + Ğ + ~c)  S1® THEN1 rewrite_tac[exp_s1__s1_thm]);
a(strip_asm_tac(µ_elim¬ExpS1 (x + Ğ + ~c)® exp_s1_onto_thm));
a(¶‰1_tac¬x' + c + ~ Ğ® THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(once_rewrite_tac[exp_s1_homomorphism_thm]);
a(DROP_NTH_ASM_T 2 (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[exp_s1_homomorphism_thm1]);
a(conv_tac(ONCE_MAP_C ¯_anf_conv) THEN rewrite_tac[]);
(* *** Goal "4" *** *)
a(rewrite_tac[pc_rule1"¯_lin_arith" prove_rule[]
	¬x'' = x' + c + ~ Ğ ¤ x'' + Ğ - c = x'®]);
a(DROP_NTH_ASM_T 4 bc_thm_tac);
a(once_rewrite_tac[exp_s1_homomorphism_thm]);
a(asm_rewrite_tac[]);
a(PC_T1 "¯_lin_arith" asm_prove_tac[]);
val Ûexp_s1_onto_thm1İ = save_pop_thm "exp_s1_onto_thm1";


=TEX

%%%%
%%%%
=SML

set_goal([], ¬µc z·
	z  S1 ±³z = ExpS1 (c + Ğ)
´	¶‰1x·x  OpenInterval (c - Ğ) (c + Ğ) ± z = ExpS1 x®);
a(rewrite_tac[open_interval_def] THEN REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¬c®, ¬z®]exp_s1_onto_thm1));
a(¶‰1_tac¬x® THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 (strip_asm_tac o rewrite_rule[¯_¼_def])
	THEN all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(swap_nth_asm_concl_tac 3);
a(rewrite_tac[exp_s1_period_thm]);
a(¶_tac¬1® THEN rewrite_tac[]);
a(PC_T1"¯_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 bc_thm_tac THEN asm_rewrite_tac[]);
a(PC_T1"¯_lin_arith" asm_prove_tac[]);
val Ûexp_s1_onto_thm2İ = save_pop_thm "exp_s1_onto_thm2";

=TEX

%%%%
%%%%
=SML

set_goal([], ¬µc·
	{z | z  S1 ±³z = ExpS1 (c + Ğ)} =
	{z | ¶ x· x  OpenInterval (c - Ğ) (c + Ğ) ± z = ExpS1 x}®);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[exp_s1_onto_thm2]);
a(¶_tac¬x® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[exp_s1__s1_thm]);
(* *** Goal "3" *** *)
a(pure_asm_rewrite_tac[] THEN POP_ASM_T discard_tac);
a(POP_ASM_T ante_tac
	THEN rewrite_tac[open_interval_def]
	THEN strip_tac);
a(ante_tac (list_µ_elim[¬c®, ¬ExpS1 x®] exp_s1_onto_thm1));
a(rewrite_tac[exp_s1__s1_thm] THEN strip_tac);
a(lemma_tac¬c + ~ Ğ ¼ x® THEN1 asm_rewrite_tac[¯_¼_def]);
a(lemma_tac¬x = x'® THEN1
	(DROP_NTH_ASM_T 2 bc_thm_tac THEN asm_rewrite_tac[])
	THEN all_var_elim_asm_tac1);
a(contr_tac);
a(DROP_NTH_ASM_T 2 (ante_tac o µ_elim¬c + ~ Ğ®) THEN asm_rewrite_tac[]);
a(LEMMA_T ¬~ Ğ < Ğ ± ³c + ~ Ğ = x'® rewrite_thm_tac
	THEN1 (strip_asm_tac Ğ_def
		THEN PC_T1 "¯_lin_arith" asm_prove_tac[]));
a(rewrite_tac[exp_s1_period_thm]);
a(¶_tac¬1® THEN rewrite_tac[]);
a(strip_asm_tac Ğ_def
	THEN PC_T1 "¯_lin_arith" asm_prove_tac[]);
val Ûexp_s1_covering_projection_lemma1İ = save_pop_thm "exp_s1_covering_projection_lemma1";



=TEX

%%%%
%%%%
=SML

set_goal([], ¬µx·
	ExpS1 
	(OpenInterval (x - Ğ) (x + Ğ) ò‰T Open‰R,
		{z | z  S1 ±³z = ExpS1 (x + Ğ)} ò‰T Open‰C) 
			Homeomorphism
®);
a(REPEAT strip_tac);
a(rewrite_tac[exp_s1_covering_projection_lemma1]);
a(bc_thm_tac €_compact_homeomorphism_thm);
a(¶_tac¬ClosedInterval (x - Ğ) (x + Ğ)®);
a(rewrite_tac[open_¯_topology_thm, open_¯_hausdorff_thm,
	open_Ö_topology_thm, open_Ö_hausdorff_thm,
	exp_s1_continuous_thm, compact_compact_¯_thm,
	closed_interval_compact_thm]);
a(rewrite_tac[open_interval_def, closed_interval_def]);
a(REPEAT strip_tac THEN1
	(PC_T1 "sets_ext1" rewrite_tac[]
	THEN PC_T1 "¯_lin_arith" prove_tac[]));
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[¯_¼_def]));
(* *** Goal "1" *** *)
a(ante_tac(list_µ_elim[¬x®, ¬ExpS1 y®] exp_s1_onto_thm1)
	THEN rewrite_tac[exp_s1__s1_thm]
	THEN REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¬y® THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o eq_sym_rule)); 
a(lemma_tac¬x + ~ Ğ ¼ x'® THEN1 asm_rewrite_tac[¯_¼_def]);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac THEN all_var_elim_asm_tac);
(* *** Goal "2" *** *)
a(i_contr_tac THEN all_var_elim_asm_tac1);
a(POP_ASM_T (strip_asm_tac o eq_sym_rule));
a(ante_tac(list_µ_elim[¬x' + Ğ®, ¬ExpS1 (x + Ğ)®] exp_s1_onto_thm1)
	THEN rewrite_tac[exp_s1__s1_thm]
	THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¬x + Ğ® THEN_TRY PC_T1"¯_lin_arith" asm_prove_tac[]
	THEN all_var_elim_asm_tac1);
a(spec_nth_asm_tac 2 ¬x'® THEN_TRY PC_T1"¯_lin_arith" asm_prove_tac[]);
val Ûexp_s1_covering_projection_lemma2İ = save_pop_thm "exp_s1_covering_projection_lemma2";


=TEX

%%%%
%%%%
=SML

(*

set_goal([], ¬
	ExpS1  (Open‰R, S1 ò‰T Open‰C) CoveringProjection
®);
a(rewrite_tac[covering_projection_def, space_t_subspace_open_Ö_thm,
	exp_s1_continuous_thm]);
a(bc_thm_tac €_compact_homeomorphism_thm);
a(¶_tac¬ClosedInterval (x - Ğ) (x + Ğ)®);
a(rewrite_tac[open_¯_topology_thm, open_¯_hausdorff_thm,
	open_Ö_topology_thm, open_Ö_hausdorff_thm,
	exp_s1_continuous_thm, compact_compact_¯_thm,
	closed_interval_compact_thm]);
a(rewrite_tac[open_interval_def, closed_interval_def]);
a(REPEAT strip_tac THEN1
	(PC_T1 "sets_ext1" rewrite_tac[]
	THEN PC_T1 "¯_lin_arith" prove_tac[]));
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[¯_¼_def]));
(* *** Goal "1" *** *)
a(ante_tac(list_µ_elim[¬x®, ¬ExpS1 y®] exp_s1_onto_thm1)
	THEN rewrite_tac[exp_s1__s1_thm]
	THEN REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¬y® THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o eq_sym_rule)); 
a(lemma_tac¬x + ~ Ğ ¼ x'® THEN1 asm_rewrite_tac[¯_¼_def]);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac THEN all_var_elim_asm_tac);
(* *** Goal "2" *** *)
a(i_contr_tac THEN all_var_elim_asm_tac1);
a(POP_ASM_T (strip_asm_tac o eq_sym_rule));
a(ante_tac(list_µ_elim[¬x' + Ğ®, ¬ExpS1 (x + Ğ)®] exp_s1_onto_thm1)
	THEN rewrite_tac[exp_s1__s1_thm]
	THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¬x + Ğ® THEN_TRY PC_T1"¯_lin_arith" asm_prove_tac[]
	THEN all_var_elim_asm_tac1);
a(spec_nth_asm_tac 2 ¬x'® THEN_TRY PC_T1"¯_lin_arith" asm_prove_tac[]);
val Ûexp_s1_covering_projection_lemma2İ = save_pop_thm "exp_s1_covering_projection_lemma2";

*)

=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val Ûsectionsİ = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="wrk072.th.doc", theory="Ö"};
end;
=TEX
} %\Hide
\end{document}


