=IGN
********************************************************************************
wrk072.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
wrk072.doc,v 1.15 2010/11/14 11:55:24 rda Exp
********************************************************************************
% wrk072.doc 1.15 wrk072.doc,v 2010/11/14 11:55:24
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{url}
\def\Hide#1{\relax}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\C{\mathbb{C}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\title{Mathematical Case Studies: the Complex Numbers\thanks{
First posted 17 September 2005;
for full changes history see: \protect\url{https://github.com/RobArthan/pp-contrib}.
}}
\author{Rob Arthan\\{\tt rda@lemma-one.com}}
\date{\FormatDate{\VCDate}}
\makeindex
\begin{document}
\vfill
\begin{titlepage}
\maketitle
\begin{abstract}

Definitions of the complex numbers and their arithmetic operators in {\ProductHOL} with proofs of some of their elementary algebraic properties.

\end{abstract}
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd 2005--\number\year \\
Reference: LEMMA1/HOL/WRK072; Current git revision: \VCVersion%


\end{centering}
\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
\tableofcontents
\newpage
\section{INTRODUCTION}
This document contains the beginnings of a theory of complex arithmetic in {\ProductHOL}.

After some preliminaries, section~\ref{sec:algebra} introduces the field operations and the embedddings of the real numbers and of conjugation (which help to abbreviate the definition of reciprocals).
We then define the derived operations of binary subtraction and division and the embedding of the natural numbers.

In section~\ref{sec:topology} we introduce the topology on the complex numbers and define the exponential mapping of the real line onto the unit circle.

A proof script contained in the source of this document but hidden from the printed document proves several theorems about the complex numbers.
A listing of the theorems proved is given in appendix~\ref{listing}.

We prove that the complex numbers form a field and prove some elementary algebraic properties of complex conjugation and of the embeddings of the natural numbers and the real numbers in the complex numbers.
The proofs of these basic algebraic properties generally comprise little more than simplifying using definitions and standard theorems and then application of the decision procedure for linear arithmetic to prove the resulting problem of real algebra.
One exception is proving that $zz^{-1} = 1$, which requires a few lines of reasoning about real squares.

The proof scripts then go on to develop basic facts about the exponential mapping of the real line onto the unit circle, leading up to the important fact that it is a covering projection.



\section{THE ALGEBRA ÷}\label{sec:algebra}

\subsection{Preliminaries}
The following commands set up a theory to hold the definitions, theorems, etc.
The theory has the theory of analysis defined in ~\cite{LEMMA1/HOL/WRK066} for its parent, although the elementary algebraic theory only needs one or two little theorems about squares.
=SML
force_delete_theory "÷" handle Fail _ => ();
open_theory "analysis";
new_theory "÷";
new_parent "homotopy";
new_parent "group_egs";
=IGN
open_theory"÷";
=TEX
Now set up a convenient proof context:
=SML
set_merge_pcs["basic_hol1", "'˙", "'Ø", "'sets_alg"];
=TEX
\subsection{The Type ÷}
The type ÷ comprises pairs of real numbers.
We capture this in a type abbreviation:
=SML
declare_type_abbrev("÷", [], îØ ∏ ØÆ);
=TEX
We declare aliases for the instances of the projection functions
that give the real and imaginary part of a complex number:
=SML
app declare_alias [
	("Re", ¨Fst : ÷ ≠ ØÆ),
	("Im", ¨Snd : ÷ ≠ ØÆ)];
=TEX

\subsection{Algebraic Operators}
\subsubsection{Addition}

=SML
declare_infix(300, "+âC");
=TEX

πHOLCONST
‹ $€+âC› : ÷ ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z w : ÷∑ z +âC w = (Re z + Re w, Im z + Im w)
∞

=SML
declare_alias("+", ¨$+âCÆ);
=TEX
\subsubsection{Negation}

πHOLCONST
‹ €~âC› : ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z : ÷∑ ~âC z = (~(Re z), ~(Im z))
∞
=SML
declare_alias("~", ¨~âCÆ);
=TEX

=TEX
\subsubsection{Multiplication}
=SML
declare_infix(310, "*âC");
=TEX

πHOLCONST
‹ $€*âC› : ÷ ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z w : ÷∑
‹	z *âC w = (Re z * Re w - Im z * Im w, Re z * Im w + Im z * Re w)
∞

=SML
declare_alias("*", ¨$*âCÆ);
=TEX
\subsubsection{Embedding of the Real Numbers}


πHOLCONST
‹ €Ø÷› : Ø ≠ ÷
˜¸¸¸¸¸¸
‹µx∑ Ø÷ x = (x, ÓØ 0)
∞

πHOLCONST
‹ €Ø…› : Ø ≠ ÷
˜¸¸¸¸¸¸
‹µx∑ Ø… x = (ÓØ 0, x)
∞
\subsubsection{The Imaginary Unit}

πHOLCONST
‹ €IâC› : ÷
˜¸¸¸¸¸¸
‹ IâC =Ø… 1.0
∞
\subsubsection{Conjugation}
=SML
declare_postfix(320, "õ_");
=TEX
πHOLCONST
‹ €$õ_› : ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z : ÷∑ z õ_ = (Re z, ~(Im z))
∞
\subsubsection{Reciprocal}
=SML
declare_postfix(320, "õ-õ1õC");
=TEX

πHOLCONST
‹ $€õ-õ1õC› : ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z : ÷∑ z õ-õ1õC = z õ_ * Ø÷(Re (z * z õ_) õ-õ1)
∞

=SML
declare_alias("õ-õ1", ¨$õ-õ1õCÆ);
=TEX


\subsubsection{Subtraction}
=SML
declare_infix(300, "-âC");
=TEX

πHOLCONST
‹ $€-âC› : ÷ ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z w : ÷∑ z -âC w = z + ~w
∞



\subsubsection{Division}
=SML
declare_infix(315, "/âC");
=TEX

πHOLCONST
‹ $€/âC› : ÷ ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ z w : ÷∑ z /âC w = z * (w õ-õ1)
∞


=SML
declare_alias("/", ¨$/âCÆ);
=TEX
\subsubsection{Embedding of the Natural Numbers}


πHOLCONST
‹ €Ó÷› : Ó ≠ ÷
˜¸¸¸¸¸¸
‹µm∑ Ó÷ m = Ø÷(ÓØ m)
∞


πHOLCONST
‹ €Ó…› : Ó ≠ ÷
˜¸¸¸¸¸¸
‹µm∑ Ó… m = (0., ÓØ m)
∞

\subsubsection{Exponentiation with Natural Number Exponents}

=SML
declare_infix(320, "^âC");
=TEX
πHOLCONST
‹ $€^âC› : ÷ ≠ Ó ≠ ÷
˜¸¸¸¸¸¸
‹	(µ z: ÷∑ z ^âC 0 = Ó÷ 1)
‹ ±	(µ z: ÷; m∑ z ^âC (m+1) = z * z ^âC m)
∞

=SML
declare_alias("^", ¨$^âCÆ);
=TEX
\subsection{÷ {\it qua} Real Normed Space}
=SML
declare_infix(310, "*âRC");
=TEX

πHOLCONST
‹ $€*âRC› : Ø ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹µ x: Ø; v : ÷∑
‹	x *âRC v = Ø÷ x *âC v
∞

πHOLCONST
‹ €AbsâC› : ÷ ≠ Ø
˜¸¸¸¸¸¸
‹µ v : ÷∑
‹	AbsâC v = Sqrt(Re (v * v õ_))
∞

\subsection{Transcendental Functions}
\subsubsection{Exponential}
πHOLCONST
‹ €ExpâC› : ÷ ≠ ÷
˜¸¸¸¸¸¸
‹ µz∑ ExpâC z = Ø÷ (Exp(Re z)) * (Cos (Im z), Sin (Im z))
∞

=SML
declare_alias("Exp", ¨$ExpâCÆ);
=TEX
\subsubsection{Group Structures}

We now define the additive and multiplicative groups of complex numbers.

πHOLCONST
‹ €÷â+› :  ÷ GROUP;
‹ €÷â*› :  ÷ GROUP
˜¸¸¸¸¸¸
‹	÷â+ = MkGROUP Universe $+ (Ó÷ 0) ~
‹ ±	÷â* = MkGROUP {x | ≥x = Ó÷ 0} $* (Ó÷ 1) $õ-õ1
∞


\section{POLYNOMIALS}\label{sec:polynomials}
As we did for the real numbers in \cite{LEMMA1/HOL/WRK066},
we define the set of polynomial function on the complex
numbers to be the smallest set of functions
that contains all constant functions and the identity function and that
is closed under pointwise addition and multiplication of functions.
πHOLCONST
‹ €PolyFuncâC› : (÷ ≠ ÷) SET
˜¸¸¸¸¸¸
‹ PolyFuncâC = •
‹	{	A
‹	|	(µc∑ (Ãx∑c) ç A)
‹	±	(Ãx∑x) ç A
‹	±	(µf g∑f ç A ± g ç A ¥ (Ãx∑f x + g x) ç A)
‹	±	(µf g∑f ç A ± g ç A ¥ (Ãx∑f x * g x) ç A) }
∞

The following function gives the $n$-th partial sum of a series.

πHOLCONST
‹ €SeriesâC› : (Ó ≠ ÷) ≠ (Ó ≠ ÷)
˜¸¸¸¸¸¸
‹	(µs∑ SeriesâC s 0 = Ó÷ 0)
‹ ±	(µs n∑ SeriesâC s (n+1) = SeriesâC s n + s n)
∞

We represent a complex polynomial as a pair $(s, n)$ where $s$ is a sequence of coefficients and $n$ is a bound on the degree.
The following function maps such a pair to the polynomial function it represents.

πHOLCONST
‹ €PolyEvalâC› : (Ó ≠ ÷) ∏ Ó ≠ ÷ ≠ ÷
˜¸¸¸¸¸¸
‹	µs n z∑ PolyEvalâC (s, n) z = SeriesâC (Ãi∑ s i * z^i) (n+1)
∞
We now give the operations on coefficients that correspond to addition of polynomial functions \ldots

πHOLCONST
‹ €PlusCoeffsâC› : ((Ó ≠ ÷) ∏ Ó) ≠ ((Ó ≠ ÷) ∏ Ó) ≠ ((Ó ≠ ÷) ∏ Ó)
˜¸¸¸¸¸¸
‹ µs m t n∑
‹	PlusCoeffsâC (s, m) (t, n) =
‹	((Ãi∑	(if i º m then s i else Ó÷ 0) +
‹		(if i º n then t i else Ó÷ 0)), m+n)
∞

\ldots and to multiplication of one polynomial function by another.

πHOLCONST
‹ €TimesCoeffsâC› : ((Ó ≠ ÷) ∏ Ó) ≠ ((Ó ≠ ÷) ∏ Ó) ≠ ((Ó ≠ ÷) ∏ Ó)
˜¸¸¸¸¸¸
‹ 	(µs t n∑ TimesCoeffsâC (s, 0) (t, n) = ((Ãi∑ s 0 * t i), n))
‹±	(µs m t n∑
‹	TimesCoeffsâC (s, m+1) (t, n) =
‹	PlusCoeffsâC
‹	(TimesCoeffsâC (s, m) (t, n))
‹	((Ãi∑ if i º m then Ó÷ 0 else s (m+1) * t (i-(m+1))), m+n+1))
∞

\section{TOPOLOGICAL ASPECTS}\label{sec:topology}
The standard topology on ÷ is just the product topology:
πHOLCONST
‹ €OpenâC› : ÷ SET SET
˜¸¸¸¸¸¸
‹ OpenâC = OâR ∏âT OâR
∞
As with 
=INLINEFT
OpenâR
=TEX
\ it is convenient to have a short name for the topology:
=SML
declare_alias("OâC", ¨OpenâCÆ);
=TEX
The unit circle $S^1$:
πHOLCONST
‹ €S1› : ÷ SET
˜¸¸¸¸¸¸
‹ S1 = {z | AbsâC z = 1.}
∞
=TEX
The topology on the unit circle:
πHOLCONST
‹ €OpenâS1› : ÷ SET SET
˜¸¸¸¸¸¸
‹ OpenâS1 = S1 ÚâT OâC
∞
Again it is convenient to have a short name for the topology:
=SML
declare_alias("OâS1", ¨OpenâS1Æ);
=TEX
and the exponential mapping of the real line onto the unit circle:
πHOLCONST
‹ €ExpS1› : Ø ≠ ÷
˜¸¸¸¸¸¸
‹ µt∑ ExpS1 t = (Cos t, Sin t)
∞

The length of a lift of a path in $S^1$ to the universal cover:
πHOLCONST
‹ €PathS1LiftLength› : (Ø ≠ ÷) ≠ Ø
˜¸¸¸¸¸¸
‹ µf g∑
‹	f ç Paths OâS1 ± g ç Paths OâR ± (µs∑ ExpS1(g s) = f s)
‹ ¥	g 1. - g 0. = PathS1LiftLength f
∞

The degree of a loop in the unit circle:
πHOLCONST
‹ €LoopS1Degree› : (Ø ≠ ÷) ≠ ˙
˜¸¸¸¸¸¸
‹ µx f g∑
‹	f ç Loops(OâS1, x) ± g ç Paths OâR ± (µs∑ ExpS1(g s) = f s)
‹ ¥	g 1. - g 0. = 2. * ˙Ø (LoopS1Degree f) * –
∞
The generator of the fundamental group of the circle.
πHOLCONST
‹ €IotaS1› : Ø ≠ ÷
˜¸¸¸¸¸¸
‹ IotaS1 = (Ãt∑ if t º 0. ≤ 1. º t then Ó÷ 1 else ExpS1(2. * – * t))
∞
The function that converts a self-mapping of the unit circle into a loop.
πHOLCONST
‹ €S1S1Loop› : (÷ ≠ ÷) ≠ (Ø ≠ ÷)
˜¸¸¸¸¸¸
‹ µf∑	S1S1Loop f = (Ãt∑ f (IotaS1 t))
∞

The degree of a self-mapping of the unit circle:
πHOLCONST
‹ €S1S1Degree› : (÷ ≠ ÷) ≠ ˙
˜¸¸¸¸¸¸
‹ µf∑	S1S1Degree f = LoopS1Degree (S1S1Loop f)
∞

The degree of an element of the fundamental group of the unit circle:
πHOLCONST
‹ €ClassS1Degree› : (Ø ≠ ÷)  ≠ ˙
˜¸¸¸¸¸¸
‹ µx p f∑
‹	p ç Loops(OâS1, x) / PathHomotopic OâS1 ± f ç p
‹ ¥	ClassS1Degree p = LoopS1Degree f
∞

=TEX
%\twocolumn[\section{INDEX}\label{INDEX}]
%{\printindex}

\bibliographystyle{fmu}
\bibliography{fmu}

\appendix
{\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{wrk072.th}}


\twocolumn[\section*{INDEX}\label{INDEX}]
\addcontentsline{toc}{section}{INDEX}
{\small\printindex}

=TEX
\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
\ftlinepenalty=9999
\section{PROOFS}

\subsection{Preamble}

=TEX
Set context for proofs in case of future expansion.
=SML
open_theory"÷";
set_merge_pcs["basic_hol1", "'˙", "'Ø", "'sets_alg"];
=TEX
Give ML bindings for the defining properties:
%%%%
%%%%
=SML

val €÷_plus_def› = get_spec ¨$+âCÆ;
val €÷_minus_def› = get_spec ¨~âCÆ;
val €÷_conj_def› = get_spec ¨$õ_Æ;
val €÷_times_def› = get_spec ¨$*âCÆ;
val €÷_recip_def› = get_spec ¨$õ-õ1õCÆ;
val €÷_subtract_def› = get_spec ¨$-âCÆ;
val €Ó÷_def› = get_spec ¨Ó÷Æ;
val €Ø÷_def› = get_spec ¨Ø÷Æ;
val €Ó…_def› = get_spec ¨Ó…Æ;
val €Ø…_def› = get_spec ¨Ø…Æ;
val €÷_i_def› = get_spec ¨IâCÆ;
val €Ø_÷_times_def› = get_spec ¨$*âRCÆ;
val €÷_Ó_exp_def› = get_spec ¨$^âCÆ;
val €÷_abs_def› = get_spec ¨AbsâCÆ;
val €÷_ops_defs› = [÷_plus_def, ÷_minus_def, ÷_conj_def, ÷_times_def,
	÷_recip_def, ÷_subtract_def, Ó÷_def, Ø÷_def, ÷_Ó_exp_def];
val €÷_additive_def› = get_spec¨÷â+Æ;
val €÷_multiplicative_def› = get_spec¨÷â*Æ;
val €÷_poly_func_def› = get_spec ¨PolyFuncâCÆ;
val €÷_series_def› = get_spec ¨SeriesâCÆ;
val €÷_poly_eval_def› = get_spec ¨PolyEvalâCÆ;
val €÷_plus_coeffs_def› = get_spec ¨PlusCoeffsâCÆ;
val €÷_times_coeffs_def› = get_spec ¨TimesCoeffsâCÆ;
val €open_÷_def› = get_spec ¨OâCÆ;
val €s1_def› = get_spec ¨S1Æ;
val €open_s1_def› = get_spec ¨OâS1Æ;
val €÷_exp_def› = get_spec ¨ExpâCÆ;
val €exp_s1_def› = get_spec ¨ExpS1Æ;
val €exp_s1_def1› = §_t_elim (rewrite_conv[exp_s1_def]
	¨ExpS1 = (Ã x∑ (Cos x, Sin x))Æ);
val €iota_s1_def› = get_spec ¨IotaS1Æ;
val €s1_s1_loop_def› = get_spec ¨S1S1LoopÆ;
val €s1_s1_degree_def› = get_spec ¨S1S1DegreeÆ;

=TEX

\subsection{Tools}
The following could usefully go elsewhere:


=SML
val €un_»_conv› : CONV =
	simple_eq_match_conv
		(conv_rule(ONCE_MAP_C eq_sym_conv) »_axiom);

=TEX
=TEX
\subsection{Basic Algebraic Properties}

%%%%
%%%%
=SML

val €÷_plus_comm_thm› = save_thm( "÷_plus_comm_thm", (
set_goal([], ¨µ x y:÷∑ x + y = y + xÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_plus_assoc_thm› = save_thm( "÷_plus_assoc_thm", (
set_goal([], ¨µ x y z:÷∑ (x + y) + z = x + y + zÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

val €÷_plus_assoc_thm1› = save_thm ("÷_plus_assoc_thm1",
	conv_rule(ONCE_MAP_C eq_sym_conv) ÷_plus_assoc_thm);
=SML

val €÷_plus_0_thm› = save_thm( "÷_plus_0_thm", (
set_goal([], ¨µ x:÷∑ x + Ó÷ 0 = x ± Ó÷0 + x = xÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=SML

val €÷_plus_minus_thm› = save_thm( "÷_plus_minus_thm", (
set_goal([], ¨µ x:÷∑ x + ~x = Ó÷ 0 ± ~x + x = Ó÷ 0Æ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_times_conj_thm› = save_thm( "÷_times_conj_thm", (
set_goal([], ¨µ x:÷∑
	x * (x õ_) = Ø÷(Re x ^ 2 + Im x ^ 2)
Æ);
a(rewrite_tac (Ø_Ó_exp_square_thm::÷_ops_defs) THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_times_comm_thm› = save_thm( "÷_times_comm_thm", (
set_goal([], ¨µ x y:÷∑ x * y = y * xÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_times_assoc_thm› = save_thm( "÷_times_assoc_thm", (
set_goal([], ¨µ x y z:÷∑ (x * y) * z = x * y * zÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

val €÷_times_assoc_thm1› = save_thm ("÷_times_assoc_thm1",
	conv_rule(ONCE_MAP_C eq_sym_conv) ÷_times_assoc_thm);

=SML

val €÷_times_1_thm› = save_thm( "÷_times_1_thm", (
set_goal([], ¨µ x:÷∑ x * Ó÷ 1 = x ± Ó÷ 1 * x = xÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));



=SML

val €÷_times_recip_thm› = save_thm( "÷_times_recip_thm", (
set_goal([], ¨µ x:÷∑ ≥x = Ó÷ 0 ¥ x * x õ-õ1 = Ó÷ 1Æ);
a(rewrite_tac [÷_recip_def, ÷_times_conj_thm]);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) ÷_times_assoc_thm, ÷_times_conj_thm]);
a(rewrite_tac ÷_ops_defs);
a(µ_tac THEN STRIP_T asm_tac);
a(bc_thm_tac (rewrite_rule[](nth 2 (fc_canon(±_left_elim Ø_recip_clauses)))));
a(strip_asm_tac(µ_elim¨Re xÆ Ø_0_º_square_thm));
a(strip_asm_tac(µ_elim¨Im xÆ Ø_0_º_square_thm));
a(swap_nth_asm_concl_tac 3);
a(LEMMA_T ¨Re x ^ 2 = ÓØ 0 ± Im x ^ 2  = ÓØ 0Æ ante_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[Ø_square_eq_0_thm]);
pop_thm()
));

val €÷_times_recip_thm1› = save_thm ("÷_times_recip_thm1",
	conv_rule(once_rewrite_conv[÷_times_comm_thm]) ÷_times_recip_thm);

=TEX

%%%%
%%%%
=SML

val €÷_times_eq_1_thm› = save_thm( "÷_times_eq_1_thm", (
set_goal([], ¨µ z w:÷∑ ≥z = Ó÷ 0 ± z*w = Ó÷ 1 ¥ w = z õ-õ1Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨z õ-õ1 * z * w = z õ-õ1Æ ante_tac
	THEN1 asm_rewrite_tac[÷_times_1_thm]);
a(rewrite_tac[÷_times_assoc_thm1]);
a(conv_tac(LEFT_C(LEFT_C(once_rewrite_conv[÷_times_comm_thm]))));
a(ALL_FC_T rewrite_tac[÷_times_recip_thm1]);
a(rewrite_tac[÷_times_1_thm]);
pop_thm()
));




=TEX

%%%%
%%%%
=SML

val €÷_times_plus_distrib_thm› = save_thm( "÷_times_plus_distrib_thm", (
set_goal([], ¨µ x y z:÷∑
	x * (y + z) = x * y + x * z
±	(x + y) * z = x * z + y * zÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_conj_plus_homomorphism_thm› = save_thm( "÷_conj_plus_homomorphism_thm", (
set_goal([], ¨µ x y:÷∑ (x + y) õ_  = x õ_ + y õ_Æ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_conj_times_homomorphism_thm› = save_thm( "÷_conj_times_homomorphism_thm", (
set_goal([], ¨µ x y:÷∑ (x * y) õ_  = x õ_ * y õ_Æ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €Ø÷_plus_homomorphism_thm› = save_thm( "Ø÷_plus_homomorphism_thm", (
set_goal([], ¨µ x y:Ø∑ Ø÷(x + y) = Ø÷ x + Ø÷ yÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €Ø÷_times_homomorphism_thm› = save_thm( "Ø÷_times_homomorphism_thm", (
set_goal([], ¨µ x y:Ø∑ Ø÷(x * y) = Ø÷ x * Ø÷ yÆ);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €Ó÷_plus_homomorphism_thm› = save_thm( "Ó÷_plus_homomorphism_thm", (
set_goal([], ¨µ x y:Ó∑ Ó÷(x + y) = Ó÷ x + Ó÷ yÆ);
a(rewrite_tac (ÓØ_plus_homomorphism_thm::÷_ops_defs));
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €Ó÷_one_one_thm› = save_thm( "Ó÷_one_one_thm", (
set_goal([], ¨µ m n:Ó∑ Ó÷ m = Ó÷ n § m = nÆ);
a(rewrite_tac (ÓØ_one_one_thm::÷_ops_defs));
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €Ó÷_times_homomorphism_thm› = save_thm( "Ó÷_times_homomorphism_thm", (
set_goal([], ¨µ x y:Ó∑ Ó÷(x * y) = Ó÷ x * Ó÷ yÆ);
a(rewrite_tac (ÓØ_times_homomorphism_thm::÷_ops_defs));
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_plus_order_thm› = (
set_goal([], ¨µx y z:÷∑
	y + x = x + y
±	(x + y) + z = x + y + z
±	y + x + z = x + y + z	Æ);
a(REPEAT µ_tac THEN rewrite_tac[÷_plus_assoc_thm]);
a(rewrite_tac[µ_elim¨yÆ ÷_plus_comm_thm, ÷_plus_assoc_thm]);
save_pop_thm"÷_plus_order_thm"
);

=TEX

%%%%
%%%%
=SML
val €÷_eq_thm› = (
set_goal([], ¨µ x y : ÷ ∑ x = y § x + ~y = Ó÷ 0Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[÷_plus_minus_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨(x + ~ y) + y = Ó÷ 0 + yÆ ante_tac THEN1 asm_rewrite_tac[]);
a(rewrite_tac[÷_plus_assoc_thm, ÷_plus_minus_thm, ÷_plus_0_thm]);
save_pop_thm"Ø_eq_thm"
);
=TEX

%%%%
%%%%
=SML

val €÷_minus_clauses› = (
set_goal([], ¨µx y : ÷∑
		~ (~ x) = x
	±	x + ~ x = Ó÷ 0
	±	~ x + x = Ó÷ 0
	±	~ (x + y) = ~ x + ~ y
	± 	~(Ó÷ 0) = (Ó÷ 0)Æ);
a(REPEAT µ_tac);
a(rewrite_tac[÷_plus_minus_thm]);
a(lemma_tac¨µx:÷∑~(~ x) = xÆ);
(* *** Goal "1" *** *)
a(strip_tac THEN once_rewrite_tac[÷_eq_thm]);
a(rewrite_tac[÷_plus_minus_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[] THEN strip_tac);
(* *** Goal "2.1" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[÷_eq_thm]);
a(asm_rewrite_tac[µ_elim¨~ yÆ÷_plus_order_thm]);
a(rewrite_tac[µ_elim¨yÆ÷_plus_order_thm, ÷_plus_minus_thm, ÷_plus_0_thm]);
(* *** Goal "2.2" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[÷_eq_thm]);
a(asm_rewrite_tac[÷_plus_0_thm]);
save_pop_thm"÷_minus_clauses"
);

=TEX

%%%%
%%%%
=SML


val €÷_plus_clauses› = (
set_goal([], ¨
	µ x y z:÷∑
	(x + z = y + z § x = y)
±	(z + x = y + z § x = y)
±	(x + z = z + y § x = y)
±	(z + x = z + y § x = y)
±	(x + z = z § x = Ó÷ 0)
±	(z + x = z § x = Ó÷ 0)
±	(z = z + y § y = Ó÷ 0)
±	(z = y + z § y = Ó÷ 0)
±	x + Ó÷ 0 = x
±	Ó÷ 0 + x = x
±	≥ Ó÷ 1 = Ó÷ 0
±	≥ Ó÷ 0 = Ó÷ 1
Æ);
a(REPEAT µ_tac);
a(rewrite_tac[÷_plus_0_thm, Ó÷_one_one_thm, plus_clauses,
	µ_elim¨zÆ ÷_plus_order_thm]);
a(once_rewrite_tac[µ_elim¨z + xÆ ÷_eq_thm]);
a(once_rewrite_tac[µ_elim¨zÆ ÷_eq_thm]);
a(rewrite_tac[÷_minus_clauses, µ_elim¨~ zÆ ÷_plus_order_thm]);
a(rewrite_tac[÷_plus_assoc_thm1, ÷_minus_clauses, ÷_plus_0_thm]);
a(once_rewrite_tac[µ_elim¨xÆ ÷_eq_thm]);
a(rewrite_tac[]);
a(conv_tac(LEFT_C eq_sym_conv));
a(once_rewrite_tac[µ_elim¨Ó÷ 0Æ ÷_eq_thm]);
a(rewrite_tac[÷_minus_clauses, ÷_plus_0_thm]);
save_pop_thm"÷_plus_clauses"
);

=TEX

%%%%
%%%%
=SML

val €÷_times_order_thm› = (
set_goal([], ¨µ x : ÷ ∑ µ y z ∑
		y * x = x * y
	±	(x * y) * z = x * y * z
	±	y * x * z = x * y * zÆ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [list_µ_elim [¨yÆ,¨xÆ] ÷_times_comm_thm]);
(* *** Goal "2" *** *)
a (rewrite_tac [all_µ_elim ÷_times_assoc_thm]);
(* *** Goal "3" *** *)
a (rewrite_tac [list_µ_elim [¨yÆ,¨xÆ,¨zÆ] ÷_times_assoc_thm1]);
a (once_rewrite_tac [list_µ_elim [¨yÆ,¨xÆ] ÷_times_comm_thm]);
a (rewrite_tac [÷_times_assoc_thm]);
save_pop_thm "÷_times_order_thm"
);

=TEX

%%%%
%%%%
=SML

val €÷_times_0_thm1› = (
set_goal([], ¨µx:÷∑ x * Ó÷ 0 = Ó÷ 0Æ);
a(accept_tac(
	all_µ_intro
	(rewrite_rule[÷_plus_clauses, ÷_plus_0_thm](prove_rule[÷_times_plus_distrib_thm]
	¨x*(Ó÷ 0 + Ó÷ 0) = x * Ó÷ 0 + x * Ó÷ 0Æ))));
pop_thm()
);

=TEX

%%%%
%%%%
=SML

val €÷_times_0_thm› = (
set_goal([], ¨µx:÷∑ x * Ó÷ 0 = Ó÷ 0 ± Ó÷ 0 * x = Ó÷ 0Æ);
a(rewrite_tac[µ_elim¨x:÷Æ÷_times_order_thm, ÷_times_0_thm1]);
save_pop_thm "÷_times_0_thm"
);

=TEX
=SML
val €÷_times_eq_0_thm› = save_thm( "÷_times_eq_0_thm", (
set_goal([], ¨
	µx y:÷∑ x*y = Ó÷ 0 ¥ x = Ó÷ 0 ≤ y = Ó÷ 0
Æ);
a(contr_tac THEN all_fc_tac[÷_times_recip_thm1]);
a(LEMMA_T¨y = (x õ-õ1 * x) * yÆ ante_tac THEN1 asm_rewrite_tac[]
	THEN rewrite_tac[÷_times_assoc_thm, ÷_times_1_thm]
	THEN asm_rewrite_tac[÷_times_0_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_times_clauses› = (
set_goal ([], ¨µ x ∑ Ó÷ 0 * x = Ó÷ 0 ± x * Ó÷ 0 = Ó÷ 0 ± x * Ó÷ 1 = x ± Ó÷ 1 * x = xÆ);
a(rewrite_tac[÷_times_0_thm, ÷_times_1_thm]);
save_pop_thm "÷_times_clauses"
);

=TEX

%%%%
%%%%
=SML

val €÷_times_minus_thm1› = (
set_goal([], ¨µx y:÷∑ x * ~ y = ~(x * y)Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨x * ~ y + x * y = Ó÷ 0Æ);
(* *** Goal "1" *** *)
a(LEMMA_T ¨x * ~ y + x * y = x * (~y + y)Æ rewrite_thm_tac
	THEN1 rewrite_tac[÷_times_plus_distrib_thm]);
a(rewrite_tac[÷_minus_clauses, ÷_times_0_thm1]);
(* *** Goal "2" *** *)
a(once_rewrite_tac[÷_eq_thm]);
a(asm_rewrite_tac[÷_minus_clauses]);
pop_thm()
);

=TEX

%%%%
%%%%
=SML

val €÷_times_minus_thm› = (
set_goal([], ¨µx y:÷∑ ~x * y = ~(x * y) ± x * ~ y = ~(x * y) ± ~x * ~y = x * yÆ);
a(REPEAT µ_tac);
a(rewrite_tac[µ_elim¨yÆ÷_times_order_thm]);
a(rewrite_tac[÷_times_minus_thm1]);
a(rewrite_tac[µ_elim¨yÆ÷_times_order_thm]);
a(rewrite_tac[÷_times_minus_thm1, ÷_minus_clauses]);
save_pop_thm"÷_times_minus_thm"
);

=TEX

%%%%
%%%%
=SML

val €÷_Ó_exp_1_thm› = (
set_goal ([], ¨µ n : Ó ∑ Ó÷ 1^n = Ó÷ 1Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ
	THEN asm_rewrite_tac[÷_Ó_exp_def, ÷_times_clauses]);
save_pop_thm "÷_Ó_exp_1_thm"
);

=TEX

Note the following is primarily intended for the case when the exponent is a numeric literal (and will loop unless used with care).

%%%%
%%%%
=SML

val €÷_Ó_exp_rw_thm› = (
set_goal ([], ¨µ z :÷; n : Ó∑ z^n = if n = 0 then Ó÷ 1 else z * z^(n-1)Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ
	THEN asm_rewrite_tac[÷_Ó_exp_def]);
save_pop_thm "÷_Ó_exp_rw_thm"
);

=TEX

%%%%
%%%%
=SML

val €÷_Ó_exp_plus_thm› = (
set_goal ([], ¨µ z :÷; m n : Ó∑ z^(m+n) = z^m * z^nÆ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ
	THEN asm_rewrite_tac[÷_Ó_exp_def, plus_assoc_thm1, ÷_times_clauses]);
a(rewrite_tac[µ_elim¨zÆ ÷_times_order_thm]);
save_pop_thm "÷_Ó_exp_plus_thm"
);

=TEX

%%%%
%%%%
=SML

val €÷_Ó_exp_clauses› = (
set_goal ([], ¨µ z :÷; n : Ó ∑ z^0 = Ó÷ 1 ± z^1 = z ± Ó÷ 1^n = Ó÷ 1Æ);
a(rewrite_tac[÷_Ó_exp_1_thm]);
a(once_rewrite_tac[÷_Ó_exp_rw_thm] THEN rewrite_tac[]);
a(once_rewrite_tac[÷_Ó_exp_rw_thm] THEN rewrite_tac[÷_times_clauses]);
save_pop_thm "÷_Ó_exp_clauses"
);

=TEX
\subsection{A Proof Context}
\section{PROOF CONTEXT}

=TEX

=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt (current_ad_rw_canon())) thms)
);
=TEX
=SML
val _ = delete_pc "'÷" handle Fail _ => ();
val _ = new_pc "'÷";
(*
val _ = set_rw_eqn_cxt
		[	(¨x +âR yÆ, Ø_plus_conv),
			(¨x *âR yÆ, Ø_times_conv),
			(¨x -âR yÆ, Ø_subtract_conv),
			(¨AbsâR xÆ, Ø_abs_conv),
			(¨x /âR yÆ, Ø_over_conv),
			(¨x õ-õ1Æ, Ø_recip_conv),
			(¨x ^âN mÆ, Ø_Ó_exp_conv),
			(¨x ^âZ iÆ, Ø_˙_exp_conv),
			(¨(x:Ø) = yÆ, Ø_eq_conv),
			(¨x ºâR yÆ, Ø_º_conv),
			(¨x <âR yÆ, Ø_less_conv),
			(¨x æâR yÆ, Ø_æ_conv),
			(¨x >âR yÆ, Ø_greater_conv),
			(¨m /âN mÆ, Ø_frac_norm_conv),
			(¨Float x p (Ó˙ 0)Æ, float_conv),
			(¨MaxâR [x]Æ, Ø_max_conv),
			(¨MaxâR (Cons x (Cons y z))Æ, Ø_max_conv),
			(¨MinâR [x]Æ, Ø_min_conv),
			(¨MinâR (Cons x (Cons y z))Æ, Ø_min_conv)
		] "'÷";
*)
val _ = add_rw_thms [÷_plus_clauses, ÷_minus_clauses, ÷_times_clauses, ÷_Ó_exp_clauses]
	"'÷";
(*
val €pos› = (thms_to_eqn_cxt [Ø_minus_clauses, Ø_º_clauses, Ø_less_clauses]) @
		[	(¨(x:Ø) = yÆ, Ø_eq_conv),
			(¨x æâR yÆ, Ø_æ_conv),
			(¨x >âR yÆ, Ø_greater_conv)];
val €neg› = mapfilter (mk_≥ ** RAND_C) pos;
val €neutral› = [(¨x ºâR yÆ, Ø_º_conv), (¨x <âR yÆ, Ø_less_conv)];
val €strip_eqn_cxt› = neutral @ pos @ neg;
val _ = set_st_eqn_cxt strip_eqn_cxt "'÷";
val _ = set_sc_eqn_cxt strip_eqn_cxt "'÷";
*)

val _ = set_pr_tac basic_prove_tac "'÷";
val _ = set_pr_conv basic_prove_conv "'÷";

(*
val _ = commit_pc "'÷";
*)

val _ = set_merge_pcs["basic_hol1", "'˙", "'Ø", "'sets_alg", "'÷"];
=TEX
\subsection{Additive and Multiplicative Group Properties}
=TEX
=SML
set_goal([], ¨
	÷â+ ç Group
Æ);
a(rewrite_tac[÷_additive_def, group_def, group_ops_def, ÷_plus_assoc_thm]);
val €÷_additive_group_thm› = save_pop_thm "÷_additive_group_thm";



=TEX
=SML
set_goal([], ¨
	÷â* ç Group
Æ);
a(rewrite_tac[÷_multiplicative_def, group_def, group_ops_def, ÷_times_assoc_thm]);
a(contr_tac THEN fc_tac[÷_times_eq_0_thm, ÷_times_recip_thm1, ÷_times_recip_thm]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
val €÷_multiplicative_group_thm› = save_pop_thm "÷_multiplicative_group_thm";

=TEX
=SML
set_goal([], ¨
	Car ÷â+ = Universe
±	(µx y:÷∑ (x . y) ÷â+ = x + y)
±	Unit ÷â+ = Ó÷ 0
±	(µx:÷∑ (x õ~) ÷â+ = ~x)
Æ);
a(rewrite_tac[÷_additive_def, group_ops_def]);
val €÷_additive_ops_thm› = save_pop_thm "÷_additive_ops_thm";
=TEX
=SML
set_goal([], ¨
	Car ÷â* = {x | ≥x = Ó÷ 0}
±	(µx y:÷∑ (x . y) ÷â* = x * y)
±	Unit ÷â* = Ó÷ 1
±	(µx:÷∑ (x õ~) ÷â* = x õ-õ1)
Æ);
a(rewrite_tac[÷_multiplicative_def, group_ops_def]);
val €÷_multiplicative_ops_thm› = save_pop_thm "÷_multiplicative_ops_thm";

=TEX
=SML
set_goal([], ¨÷â+ = Øâ+ ∏âG Øâ+Æ);
a(rewrite_tac[group_eq_group_thm]);
a(rewrite_tac[÷_additive_def, group_ops_def, ∏_group_def, Ø_additive_ops_thm]);
a(rewrite_tac[÷_plus_def, ÷_minus_def, Ó÷_def, Ø÷_def, ∏_def]);
a(PC_T1"sets_ext1" rewrite_tac[]);
val €÷_eq_Ø_∏_Ø_thm› = save_pop_thm "÷_eq_Ø_∏_Ø_thm";

=TEX
=SML
val €÷_additive_÷_multiplicative_homomorphism_def› =
	save_thm("÷_additive_÷_multiplicative_homomorphism_def",
		rewrite_rule[÷_multiplicative_ops_thm, ÷_additive_ops_thm]
			 (list_µ_elim[¨÷â+Æ, ¨÷â*Æ] homomorphism_def));

=TEX
=SML
set_goal([], ¨
	Exp ç Homomorphism(÷â+, ÷â*)
Æ);
a(rewrite_tac[ ÷_additive_÷_multiplicative_homomorphism_def]);
a(conv_tac (TOP_MAP_C Ã_pair_conv));
a(rewrite_tac[÷_exp_def, exp_clauses, ÷_plus_def, ÷_times_def, Ø÷_def, Ó÷_def,
	sin_cos_plus_thm]);
a(conv_tac (MAP_C Ø_anf_conv));
a(contr_tac);
a(lemma_tac¨≥Exp x1 = 0.Æ THEN1 rewrite_tac[exp_≥_eq_0_thm]);
a(fc_tac[Ø_times_eq_0_thm]);
a(ante_tac(µ_elim¨x2Æ cos_squared_plus_sin_squared_thm));
a(asm_rewrite_tac[]);
val €÷_exp_homomorphism_thm› = save_pop_thm "÷_exp_homomorphism_thm";

=TEX
=SML
set_goal([], ¨µc∑
	(Ãx∑c * x) ç Homomorphism(÷â+, ÷â+)
Æ);
a(rewrite_tac[÷_additive_def, group_ops_def, homomorphism_def, ÷_times_plus_distrib_thm]);
val €÷_linear_homomorphism_thm› = save_pop_thm "÷_linear_homomorphism_thm";


=TEX
\subsection{de Moivre's Theorem}

%%%%
%%%%
=SML

val €de_moivre_thm› = save_thm( "de_moivre_thm", (
set_goal([], ¨µ x m∑
	(Cos x, Sin x) ^ m =
	(Cos (ÓØ m * x), Sin (ÓØ m * x))
Æ);
a(REPEAT µ_tac THEN induction_tac¨m:ÓÆ
	THEN asm_rewrite_tac 
	(sin_def::ÓØ_plus_homomorphism_thm::
		Ø_times_plus_distrib_thm::
		sin_cos_plus_thm::÷_ops_defs));
a(PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
\subsection{Polynomials}

The following is useful for evaluaating partial sums of series of specific known length:
%%%%
%%%%
=SML

val €÷_series_rw_thm› = save_thm ("÷_series_rw_thm", (
set_goal([], ¨µs n∑ SeriesâC s n = if n = 0 then Ó÷ 0 else s (n-1) + SeriesâC s (n-1)Æ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ
	THEN asm_rewrite_tac[÷_series_def]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML
val €÷_poly_eval_rec_thm› = save_thm( "÷_poly_eval_rec_thm", (
set_goal([], ¨
	(µs z∑ PolyEvalâC (s, 0) z = s 0)
±	(µs n z∑ PolyEvalâC (s, (n+1)) z = PolyEvalâC (s, n) z + s(n+1) * z^(n+1))
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[÷_poly_eval_def]);
a(REPEAT (once_rewrite_tac[÷_series_rw_thm] THEN rewrite_tac[]));
(* *** Goal "2" *** *)
a(rewrite_tac[÷_poly_eval_def]);
a(conv_tac (LEFT_C (once_rewrite_conv[÷_series_def])));
a(rewrite_tac[]);
pop_thm()
));


=TEX


%%%%
%%%%
=SML


val €÷_poly_eval_eq_thm1› = save_thm( "÷_poly_eval_eq_thm1", (
set_goal([], ¨µs t m z∑
	(µi∑ i º m ¥ s i = t i)
¥	PolyEvalâC (s, m) z = PolyEvalâC (t, m) z
Æ);
a(REPEAT µ_tac THEN induction_tac¨m:ÓÆ
	THEN asm_rewrite_tac[÷_poly_eval_rec_thm]);
(* *** Goal "1" *** *)
a(STRIP_T bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(STRIP_T (strip_asm_tac o µ_elim¨iÆ)
	THEN i_contr_tac THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(STRIP_T (strip_asm_tac o µ_elim¨m+1Æ) THEN asm_rewrite_tac[]);
pop_thm()
));

=TEX


%%%%
%%%%
=SML


val €÷_poly_eval_eq_thm2› = save_thm( "÷_poly_eval_eq_thm2", (
set_goal([], ¨µs m n z∑
	(µi∑ m < i ¥ s i = Ó÷ 0)
±	m º n
¥	PolyEvalâC (s, m) z = PolyEvalâC (s, n) z
Æ);
a(REPEAT µ_tac THEN induction_tac¨n:ÓÆ
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[÷_poly_eval_rec_thm]);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨m = n + 1Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[÷_poly_eval_rec_thm]);
(* *** Goal "3" *** *)
a(cases_tac¨m < n + 1Æ THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(lemma_tac¨m = n + 1Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 5 ante_tac THEN all_var_elim_asm_tac1);
a(rewrite_tac[÷_poly_eval_rec_thm]);
pop_thm()
));


=TEX


%%%%
%%%%
=SML

val €÷_poly_eval_eq_thm› = save_thm( "÷_poly_eval_eq_thm", (
set_goal([], ¨µs t m n z∑
	(µi∑ i º m ¥ s i = t i)
±	(µi∑ m < i ¥ t i = Ó÷ 0)
±	m º n
¥	PolyEvalâC (s, m) z = PolyEvalâC (t, n) z
Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨PolyEvalâC (t, n) z = PolyEvalâC (t, m) zÆ rewrite_thm_tac
	THEN1 ALL_FC_T rewrite_tac[÷_poly_eval_eq_thm2]);
a(bc_thm_tac ÷_poly_eval_eq_thm1 THEN asm_rewrite_tac[]);
pop_thm()
));


=TEX


%%%%
%%%%
=SML


val €÷_poly_eval_0_thm› = save_thm( "÷_poly_eval_0_thm", (
set_goal([], ¨µn z∑
	PolyEvalâC ((Ãi∑Ó÷ 0), n) z = Ó÷ 0
Æ);
a(REPEAT µ_tac THEN induction_tac¨n:ÓÆ
	THEN asm_rewrite_tac[÷_poly_eval_rec_thm]);
pop_thm()
));


=TEX


%%%%
%%%%
=SML


val €÷_poly_eval_minus_thm› = save_thm( "÷_poly_eval_minus_thm", (
set_goal([], ¨µs n z∑
	PolyEvalâC ((Ãi∑~(s i)), n) z = ~(PolyEvalâC (s, n) z)
Æ);
a(REPEAT µ_tac THEN induction_tac¨n:ÓÆ
	THEN asm_rewrite_tac[÷_poly_eval_rec_thm]);
a(rewrite_tac[÷_times_minus_thm]);
pop_thm()
));


=TEX


%%%%
%%%%
=SML


val €÷_poly_eval_plus_thm› = save_thm( "÷_poly_eval_plus_thm", (
set_goal([], ¨µs t n z∑
	PolyEvalâC ((Ãi∑s i + t i), n) z =
	PolyEvalâC (s, n) z + PolyEvalâC (t, n) z
Æ);
a(REPEAT µ_tac THEN induction_tac¨n:ÓÆ
	THEN asm_rewrite_tac[÷_poly_eval_rec_thm]);
a(rewrite_tac[÷_plus_assoc_thm,
	µ_elim¨PolyEvalâC (s, n) zÆ ÷_plus_order_thm,
	÷_times_plus_distrib_thm]);
a(rewrite_tac[µ_elim¨PolyEvalâC (t, n) zÆ ÷_plus_order_thm]);
pop_thm()
));

=TEX


%%%%
Now we will show that any polynomial function can be represented by a finite power series.

Constants \ldots
%%%%
%%%%
=SML

val €÷_const_eval_thm› = save_thm( "÷_const_eval_thm", (
set_goal([], ¨µc∑(Ãx∑c) = PolyEvalâC ((Ãi∑c), 0)Æ);
a(rewrite_tac[] THEN pure_rewrite_tac[÷_poly_eval_def, ÷_series_def]);
a(rewrite_tac ÷_ops_defs);
pop_thm()
));

=TEX
\ldots identity function \ldots
%%%%
%%%%
=SML

val €÷_id_eval_thm› = save_thm( "÷_id_eval_thm", (
set_goal([], ¨(Ãx∑x) = PolyEvalâC ((Ãi∑if i = 1 then Ó÷ 1 else Ó÷ 0), 1)Æ);
a(rewrite_tac[÷_poly_eval_def]);
a(REPEAT (once_rewrite_tac[÷_series_rw_thm] THEN rewrite_tac[]));
pop_thm()
));

=TEX
\ldots sums \ldots
%%%%
%%%%
=SML

=TEX
\ldots sums \ldots
%%%%
%%%%
=SML

val €÷_plus_eval_thm› = save_thm( "÷_plus_eval_thm", (
set_goal([], ¨µs m t n∑
	(Ãx∑ PolyEvalâC (s, m) x + PolyEvalâC (t, n) x) =
	PolyEvalâC (PlusCoeffsâC (s, m) (t, n))Æ);
a(REPEAT strip_tac THEN rewrite_tac[÷_plus_coeffs_def]);
a(EXTEND_PC_T1 "'sho_rw" pure_rewrite_tac[÷_poly_eval_plus_thm]);
a(bc_tac [prove_rule[]¨µa b c d:÷∑a = c ± b = d ¥ a + b = c + dÆ,
	÷_poly_eval_eq_thm]
	THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "1" (duplicates "2") *** *)
a(LEMMA_T ¨≥i º mÆ asm_rewrite_thm_tac THEN PC_T1 "lin_arith" asm_prove_tac[]);
pop_thm()
));
=TEX
which we can usefully reformulate thus
%%%%
%%%%
=SML

val €÷_plus_eval_rw_thm› = save_thm( "÷_plus_eval_rw_thm", (
set_goal([], ¨µsm tn∑
	PolyEvalâC (PlusCoeffsâC sm tn) =
	(Ãx∑ PolyEvalâC sm x + PolyEvalâC tn x) Æ);
a(REPEAT strip_tac);
a(pair_tac¨sm = (s, m)Æ THEN pair_tac¨tn = (t, n)Æ);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) ÷_plus_eval_thm]);
pop_thm()
));

=TEX
\ldots and products, which in this case require a little lemma first:
%%%%
%%%%
=SML

val €÷_const_times_eval_thm› = save_thm( "÷_const_times_eval_thm", (
set_goal([], ¨µc s m∑ PolyEvalâC ((Ãi∑c * s i), m) = (Ãx∑c * PolyEvalâC (s, m) x)Æ);
a(REPEAT strip_tac);
a(induction_tac¨mÆ THEN asm_rewrite_tac[÷_poly_eval_rec_thm]);
a(rewrite_tac ÷_ops_defs THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val €÷_times_eval_thm› = save_thm( "÷_times_eval_thm", (
set_goal([], ¨µs m t n∑
	(Ãx∑PolyEvalâC (s, m) x * PolyEvalâC (t, n) x) =
	PolyEvalâC (TimesCoeffsâC (s, m) (t, n))Æ);
a(REPEAT strip_tac THEN rewrite_tac[]);
a(induction_tac¨mÆ THEN
	rewrite_tac[÷_times_coeffs_def, ÷_poly_eval_rec_thm, ÷_const_times_eval_thm]
	THEN REPEAT strip_tac);
a(asm_rewrite_tac[÷_times_plus_distrib_thm, ÷_plus_eval_rw_thm]);
a(POP_ASM_T discard_tac THEN induction_tac¨nÆ THEN REPEAT strip_tac THEN
	asm_rewrite_tac[÷_poly_eval_rec_thm]);
(* *** Goal "1" *** *)
a(rewrite_tac[µ_elim¨t 0Æ ÷_times_order_thm]);
a(LEMMA_T ¨Ó÷ 0 = PolyEvalâC ((Ãi∑ Ó÷ 0), m) xÆ
	(fn th => conv_tac(RIGHT_C (once_rewrite_conv[th])))
	THEN1 rewrite_tac[÷_poly_eval_0_thm]);
a(conv_tac eq_sym_conv THEN bc_thm_tac ÷_poly_eval_eq_thm1
	THEN REPEAT strip_tac
	THEN1 asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[÷_times_plus_distrib_thm, ÷_poly_eval_rec_thm,
	pc_rule1 "lin_arith" prove_rule[]
		¨m + (n + 1) + 1 = (m + n + 1) + 1Æ]);
a(asm_rewrite_tac[pc_rule1 "lin_arith" prove_rule[]
		¨(m + n + 1) + 1 = m + n + 2Æ]);
a(rewrite_tac[minus_def, pc_rule1 "lin_arith" prove_rule[]
		¨m + n + 2 = (m+1) + (n+1)Æ]);
a(rewrite_tac[÷_Ó_exp_plus_thm]);
a(rewrite_tac[÷_times_assoc_thm, µ_elim¨t(n+1)Æ ÷_times_order_thm]);
pop_thm()
));

=TEX
which we can usefully reformulate thus
%%%%
%%%%
=SML

val €÷_times_eval_rw_thm› = save_thm( "÷_times_eval_rw_thm", (
set_goal([], ¨µsm tn∑
	PolyEvalâC (TimesCoeffsâC sm tn) =
	(Ãx∑ PolyEvalâC sm x * PolyEvalâC tn x) Æ);
a(REPEAT strip_tac);
a(pair_tac¨sm = (s, m)Æ THEN pair_tac¨tn = (t, n)Æ);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) ÷_times_eval_thm]);
pop_thm()
));


=TEX
Following what we did for the reals,
we now show that the set of all complex polynomial functions is the
range of the polynomial evaluation function. I.e., a function
is polynomial iff. it can be represented by a sequence of coefficients
and a degree.
We prove the two inclusions separately:
%%%%
%%%%
=SML


val €÷_poly_eval_Ä_poly_thm› = (
set_goal([], ¨{f | ∂s n∑ f = PolyEvalâC (s, n)} Ä PolyFuncâCÆ);
a(pure_rewrite_tac[÷_poly_func_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN induction_tac¨nÆ);
(* *** Goal "1" *** *)
a(conv_tac (LEFT_C un_»_conv));
a(pure_rewrite_tac[÷_poly_eval_rec_thm] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(conv_tac (LEFT_C un_»_conv));
a(pure_rewrite_tac[÷_poly_eval_rec_thm]);
a(GET_NTH_ASM_T 3 ho_bc_thm_tac THEN asm_rewrite_tac[»_axiom]);
a(GET_NTH_ASM_T 2 ho_bc_thm_tac THEN asm_rewrite_tac[]);
a(rewrite_tac[÷_Ó_exp_def]
	THEN POP_ASM_T discard_tac THEN induction_tac¨nÆ
	THEN asm_rewrite_tac[÷_Ó_exp_def]);
a(GET_NTH_ASM_T 2 ho_bc_thm_tac THEN asm_rewrite_tac[]);
pop_thm ()
);


=TEX
For the reverse inclusion, and for later use, it is convenient
to prove an induction theorem for polynomials and use it
to derive an induction tactic:
%%%%
%%%%
=SML

val €÷_poly_induction_thm› = save_thm( "÷_poly_induction_thm", (
set_goal([], ¨µp∑
		(µc∑p(Ãx∑c))
	±	(p(Ãx∑x))
	±	(µf g∑p f ± p g ¥  p(Ãx∑f x + g x))
	±	(µf g∑p f ± p g ¥ p(Ãx∑f x * g x))
	¥	(µh∑ h ç PolyFuncâC ¥ p h)
Æ);
a(rewrite_tac[÷_poly_func_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(PC_T1 "sets_ext1" POP_ASM_T (strip_asm_tac o µ_elim ¨{h | p h}Æ)
	THEN1 asm_prove_tac[] THEN all_asm_fc_tac[]);
pop_thm()
));


=TEX
Now the tactic, which expects a term of the form $f \in \mbox{\it PolyFunc}_C$ to
be in the assumptions (where $f$ is the induction variable).
%%%%
%%%%
=SML

fun €÷_poly_induction_tac› (tm : TERM) : TACTIC = (
	if not (is_var tm andalso type_of tm =: î÷ ≠ ÷Æ)
	then term_fail "÷_poly_induction_tac" 999001 [tm]
	else ( fn(asms, conc) =>
	let	val asm = find asms (fn t =>  
			let	val (x, s) = dest_bin_op "" 0 "ç" t;
			in	x =$ tm andalso s =$ ¨PolyFuncâCÆ
			end	handle Fail _ => false)
			handle Fail _ => fail "÷_poly_induction_tac" 999002 [];
	in	if not (is_free_in tm conc)
			then term_fail "÷_poly_induction_tac" 999003 [tm]
		else if any (asms drop (fn t => t =$ asm)) (is_free_in tm)
			then term_fail "÷_poly_induction_tac" 999004 [tm]
		else	(asm_ante_tac asm THEN gen_induction_tac1 ÷_poly_induction_thm) (asms, conc)
	end
	)
);



=TEX


%%%%
%%%%
=SML

val €÷_poly_Ä_poly_eval_thm› = (
set_goal([], ¨PolyFuncâC Ä {f | ∂s n∑ f = PolyEvalâC (s, n)}Æ);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(÷_poly_induction_tac¨xÆ);
(* *** Goal "1" *** *)
a(ante_tac ÷_const_eval_thm THEN prove_tac[]);
(* *** Goal "2" *** *)
a(ante_tac ÷_id_eval_thm THEN prove_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨Fst(PlusCoeffsâC (s, n) (s', n'))Æ THEN ∂_tac¨Snd(PlusCoeffsâC (s, n) (s', n'))Æ
	THEN rewrite_tac[]);
a(asm_rewrite_tac[÷_plus_eval_rw_thm]);
(* *** Goal "4" *** *)
a(∂_tac¨Fst(TimesCoeffsâC (s, n) (s', n'))Æ THEN ∂_tac¨Snd(TimesCoeffsâC (s, n) (s', n'))Æ
	THEN rewrite_tac[]);
a(asm_rewrite_tac[÷_times_eval_rw_thm]);
pop_thm ()
);

=TEX


%%%%
%%%%
=SML

val €÷_poly_func_eq_poly_eval_thm› = save_thm( "÷_poly_func_eq_poly_eval_thm", (
set_goal([], ¨PolyFuncâC = {f | ∂s n∑ f = PolyEvalâC (s, n)}Æ);
a(rewrite_tac[÷_poly_Ä_poly_eval_thm, ÷_poly_eval_Ä_poly_thm,
	pc_rule1 "sets_ext1" prove_rule[] ¨µa b∑a = b § a Ä b ± b Ä aÆ]);
pop_thm()
));

=TEX
\subsection{Topological Properties}

%%%%
%%%%
=SML

val €open_÷_topology_thm› = save_thm( "open_÷_topology_thm", (
set_goal([], ¨
	OâC ç Topology
Æ);
a(rewrite_tac[open_÷_def]);
a(bc_thm_tac product_topology_thm THEN rewrite_tac[open_Ø_topology_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €open_÷_hausdorff_thm› = save_thm( "open_÷_hausdorff_thm", (
set_goal([], ¨
	OâC ç Hausdorff
Æ);
a(rewrite_tac[open_÷_def, open_Ø_∏_open_Ø_hausdorff_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €universe_open_÷_thm› = save_thm( "universe_open_÷_thm", (
set_goal([], ¨
	Universe ç OâC
Æ);
a(rewrite_tac[open_÷_def]);
a(rewrite_tac[product_topology_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
a(∂_tac¨UniverseÆ THEN ∂_tac¨UniverseÆ THEN rewrite_tac[empty_universe_open_closed_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €space_t_open_÷_thm› = save_thm( "space_t_open_÷_thm", (
set_goal([], ¨
	SpaceâT OâC = Universe
Æ);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(bc_thm_tac ç_space_t_thm);
a(∂_tac¨UniverseÆ THEN PC_T1 "sets_ext1" rewrite_tac[universe_open_÷_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €space_t_subspace_open_÷_thm› = save_thm ("space_t_subspace_open_÷_thm",
	rewrite_rule[open_÷_topology_thm, space_t_open_÷_thm]
	(µ_elim¨OâCÆ subspace_topology_space_t_thm));

=TEX

%%%%
%%%%
=SML

val €space_t_subpace_÷_thm› = save_thm( "space_t_subpace_÷_thm", (
set_goal([], ¨
	µA∑ SpaceâT (A ÚâT OâC) = A
Æ);
a(ante_tac(µ_elim ¨OâCÆ subspace_topology_space_t_thm));
a(rewrite_tac[open_÷_topology_thm, space_t_open_÷_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_minus_continuous_thm› = save_thm( "÷_minus_continuous_thm", (
set_goal([], ¨~ ç (OâC, OâC) Continuous Æ);
a(LEMMA_T ¨~ = Ãz∑ (~ z : ÷)Æ once_rewrite_thm_tac
	THEN1 rewrite_tac[uncurry_def]);
a(rewrite_tac[÷_minus_def, open_÷_def]);
a(Ø_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML
val €÷_conj_continuous_thm› = save_thm( "÷_conj_continuous_thm", (
set_goal([], ¨$õ_ ç (OâC, OâC) Continuous Æ);
a(LEMMA_T ¨$õ_ = Ãz∑ z õ_Æ once_rewrite_thm_tac
	THEN1 rewrite_tac[uncurry_def]);
a(rewrite_tac[÷_conj_def, open_÷_def]);
a(Ø_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_plus_continuous_thm› = save_thm( "÷_plus_continuous_thm", (
set_goal([], ¨Uncurry $+ ç (OâC ∏âT OâC, OâC) Continuous Æ);
a(LEMMA_T ¨Uncurry $+ = Ã(w, z)∑ (w + z : ÷)Æ rewrite_thm_tac
	THEN1 rewrite_tac[uncurry_def]);
a(rewrite_tac[÷_plus_def, open_÷_def]);
a(Ø_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_times_continuous_thm› = save_thm( "÷_times_continuous_thm", (
set_goal([], ¨Uncurry $* ç (OâC ∏âT OâC, OâC) Continuous Æ);
a(LEMMA_T ¨Uncurry $* = Ã(w, z)∑ (w * z : ÷)Æ rewrite_thm_tac
	THEN1 rewrite_tac[uncurry_def]);
a(rewrite_tac[÷_times_def, open_÷_def]);
a(Ø_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_Ó_exp_continuous_thm› = save_thm( "÷_Ó_exp_continuous_thm", (
set_goal([], ¨µn∑ (Ãx:÷∑ x^n) ç (OâC, OâC) ContinuousÆ);
a(rewrite_tac[open_÷_def] THEN REPEAT strip_tac);
a(induction_tac¨nÆ THEN rewrite_tac[÷_Ó_exp_def]);
(* *** Goal "1" *** *)
a(Ø_continuity_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[÷_times_def] THEN Ø_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_poly_continuous_thm› = save_thm( "÷_poly_continuous_thm", (
set_goal([], ¨µf∑f ç PolyFuncâC ¥ f ç (OâC, OâC) Continuous Æ);
a(rewrite_tac[open_÷_def] THEN REPEAT strip_tac);
a(÷_poly_induction_tac ¨fÆ);
a(Ø_continuity_tac[]);
(* *** Goal "2" *** *)
a(Ø_continuity_tac[]);
(* *** Goal "3" *** *)
a(Ø_continuity_tac[rewrite_rule[open_÷_def]÷_plus_continuous_thm]);
(* *** Goal "4" *** *)
a(Ø_continuity_tac[rewrite_rule[open_÷_def]÷_times_continuous_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val €÷_series_continuous_thm› = save_thm( "÷_series_continuous_thm", (
set_goal([], ¨µ” s n∑
		” ç Topology
	±	(µi∑ s i ç (”, OâC) Continuous)
	¥	(Ãx∑ SeriesâC (Ãi∑ s i x) n) ç (”, OâC) Continuous Æ);
a(rewrite_tac[open_÷_def] THEN REPEAT strip_tac);
a(induction_tac¨nÆ THEN rewrite_tac[÷_series_def]);
(* *** Goal "1" *** *)
a(Ø_continuity_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[÷_plus_def] THEN Ø_continuity_tac[]
	THEN asm_rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val €exp_s1_continuous_thm› = save_thm( "exp_s1_continuous_thm", (
set_goal([], ¨
	ExpS1 ç (OâR, OâC) Continuous
Æ);
a(rewrite_tac[exp_s1_def1, open_÷_def]);
a(Ø_continuity_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €÷_abs_squared_lemma› = save_thm( "÷_abs_squared_lemma", (
set_goal([], ¨µx y∑ Sqrt(x^2 + y^2) = 1. § x^2 + y^2 = 1. Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨0. º x^2 ± 0. º y^2Æ THEN1 rewrite_tac[Ø_0_º_square_thm]);
a(lemma_tac¨0. º x^2 + y^2Æ THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LIST_DROP_NTH_ASM_T [2, 3] discard_tac THEN all_fc_tac[sqrt_0_º_thm, sqrt_thm]);
a(POP_ASM_T (once_rewrite_thm_tac o eq_sym_rule));
a(asm_rewrite_tac[Ø_Ó_exp_square_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[sqrt_0_1_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML


val €ç_s1_lemma› = save_thm( "ç_s1_lemma", (
set_goal([], ¨µz∑ z ç S1 § Re z^2 + Im z^2 = 1.Æ);
a(MERGE_PCS_T1 ["'pair", "sets_ext1"] rewrite_tac[s1_def, ÷_abs_def, ÷_times_conj_thm, Ø÷_def, ÷_abs_squared_lemma]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val €open_s1_topology_thm› = save_thm ( "open_s1_topology_thm", ( 
set_goal([], ¨ OâS1 ç Topology Æ);
a(rewrite_tac[open_s1_def] THEN basic_topology_tac[open_÷_topology_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val €space_t_open_s1_thm› = save_thm ( "space_t_open_s1_thm", ( 
set_goal([], ¨SpaceâT OâS1 = S1 Æ);
a(rewrite_tac[open_s1_def, space_t_subpace_÷_thm]);
pop_thm()
));


=TEX
Constant functions are continuous:
%%%%
%%%%

=SML

val €open_÷_const_continuous_thm› = save_thm("open_÷_const_continuous_thm",
	all_µ_intro(
	rewrite_rule[open_÷_topology_thm, space_t_open_÷_thm]
	(list_µ_elim[¨” : 'a SET SETÆ, ¨OâCÆ] const_continuous_thm)));

=TEX

as is the identity function:
%%%%
%%%%

=SML

val €open_÷_id_continuous_thm› = save_thm("open_÷_id_continuous_thm",
	rewrite_rule[open_÷_topology_thm]
	(µ_elim¨OâCÆ id_continuous_thm));



=TEX
It is now useful to set up a proof context to eliminate various trivial facts.
%%%%
%%%%

=SML
val _ = delete_pc "'topology_÷" handle Fail _ => ();
val _ = new_pc "'topology_÷";

val _ = add_rw_thms [
	open_÷_topology_thm,
	space_t_open_÷_thm,
	open_÷_id_continuous_thm,
	(rewrite_rule[open_÷_topology_thm] o µ_elim¨OâCÆ) open_÷_const_continuous_thm,
	open_s1_topology_thm,
	space_t_open_s1_thm
	]
	"'topology_÷";
local
	fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
		flat(map (cthm_eqn_cxt initial_rw_canon) thms)
	);
	val pos_bits = thms_to_eqn_cxt [open_÷_topology_thm];
	val neg_strips = map (mk_≥ ** RAND_C) pos_bits;
	val new_strips = pos_bits @ neg_strips;
in
	val _ = set_st_eqn_cxt new_strips "'topology_÷";
	val _ = set_sc_eqn_cxt new_strips "'topology_÷";

end;

val _ = set_pr_tac basic_prove_tac "'topology_÷";
val _ = set_pr_conv basic_prove_conv "'topology_÷";

(*
val _ = commit_pc "'topology_÷";
*)

val _ = set_merge_pcs["basic_hol1", "'˙", "'Ø", "'sets_alg", "'topology_Ø", "'topology_÷", "'÷"];

=TEX

%%%%
%%%%
=SML

val €exp_exp_s1_thm› = save_thm( "exp_exp_s1_thm", (
set_goal([], ¨ExpS1 = (Exp : ÷ ≠ ÷) o Ø…Æ);
a(rewrite_tac[÷_times_def, o_def, exp_def, ÷_exp_def, Ø…_def, Ø÷_def, exp_s1_def]);
pop_thm()
));
=TEX

%%%%
%%%%
=SML

val €exp_s1_homomorphism_thm› = save_thm( "exp_s1_homomorphism_thm", (
set_goal([], ¨µx y∑ ExpS1(x + y) = ExpS1 x * ExpS1 yÆ);
a(rewrite_tac[exp_s1_def, ÷_times_def, sin_cos_plus_thm]);
pop_thm()
));

val €exp_s1_homomorphism_thm1› = save_thm ("exp_s1_homomorphism_thm1",
	conv_rule(ONCE_MAP_C eq_sym_conv) exp_s1_homomorphism_thm);


=TEX

%%%%
%%%%
=SML

val €exp_s1_minus_thm› = save_thm( "exp_s1_minus_thm", (
set_goal([], ¨µx∑ ExpS1(~x) = ExpS1 x õ-õ1Æ);
a(REPEAT strip_tac THEN bc_thm_tac ÷_times_eq_1_thm);
a(rewrite_tac[exp_s1_homomorphism_thm1]);
a(rewrite_tac[exp_s1_def, Ó÷_def, Ø÷_def, sin_def]);
a(contr_tac THEN ante_tac (µ_elim¨xÆ cos_squared_plus_sin_squared_thm));
a(asm_rewrite_tac[Ø_Ó_exp_square_thm]);
pop_thm()
));


=TEX

%%%%
%%%%
=SML

val €exp_s1_ç_s1_thm› = save_thm( "exp_s1_ç_s1_thm", (
set_goal([], ¨µx∑ ExpS1 x ç S1Æ);
a(rewrite_tac[exp_s1_def, ç_s1_lemma, cos_squared_plus_sin_squared_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €exp_s1_period_thm› = save_thm( "exp_s1_period_thm", (
set_goal([], ¨µx y∑ ExpS1 x = ExpS1 y § (∂m∑ y = x + ÓØ(2*m) * – ≤ x = y + ÓØ(2*m) * –)Æ);
a(lemma_tac¨
	(µx y∑ x < y ¥
		(ExpS1 x = ExpS1 y § (∂m∑ y = x + ÓØ(2*m) * –)))
±	(µx y m∑ x < y ¥ ≥ x = y + ÓØ (2 * m) * –)
Æ
	THEN1 ±_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[exp_s1_def,
	taut_rule¨µx y p∑ Cos x = y ± p § p ± Cos x = yÆ,
	sin_cos_period_thm]);
(* *** Goal "2" *** *)
a(contr_tac THEN all_var_elim_asm_tac1);
a(lemma_tac ¨0. º ÓØ (2 * m) * –Æ THEN_LIST [
	bc_thm_tac Ø_0_º_0_º_times_thm,
	PC_T1 "Ø_lin_arith" asm_prove_tac[]]);
a(rewrite_tac[ÓØ_º_thm] THEN rewrite_tac[Ø_º_def, –_def]);
(* *** Goal "3" *** *)
a(REPEAT µ_tac);
a(lemma_tac¨x = y ≤ x < y ≤ y < xÆ THEN1 PC_T1 "Ø_lin_arith" prove_tac[]
	THEN1 (all_var_elim_asm_tac THEN rewrite_tac[]));
(* *** Goal "3.1" *** *)
a(∂_tac¨0Æ THEN rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(LIST_DROP_NTH_ASM_T [2, 3] (ALL_FC_T1 fc_§_canon rewrite_tac));
(* *** Goal "3.3" *** *)
a(conv_tac(LEFT_C eq_sym_conv));
a(LIST_DROP_NTH_ASM_T [2, 3] (ALL_FC_T1 fc_§_canon rewrite_tac));
pop_thm()
));

=TEX

%%%%
%%%%
=SML

val €exp_s1_period_thm1› = save_thm( "exp_s1_period_thm1", (
set_goal([], ¨µx y∑ ExpS1 x = ExpS1 y §  ∂i∑ y = x + 2. * ˙Ø i * –Æ);
a(asm_rewrite_tac[exp_s1_period_thm] THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(∂_tac ¨Ó˙ mÆ THEN rewrite_tac[ÓØ_times_homomorphism_thm, ˙Ø_Ó˙_thm]
	THEN PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac ¨~(Ó˙ m)Æ THEN rewrite_tac[ÓØ_times_homomorphism_thm, ˙Ø_Ó˙_thm]
	THEN PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "3" *** *)
a((strip_asm_tac o µ_elim¨iÆ) ˙_cases_thm THEN all_var_elim_asm_tac1
	THEN ∂_tac ¨mÆ THEN rewrite_tac[ÓØ_times_homomorphism_thm, ˙Ø_Ó˙_thm]
		THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML


val €exp_s1_onto_thm› = save_thm( "exp_s1_onto_thm", (
set_goal([], ¨µz∑ z ç S1 ¥ ∂â1x∑ 0. º x ± x < 2. * – ± z = ExpS1 xÆ);
a(rewrite_tac[ç_s1_lemma, exp_s1_def] THEN REPEAT strip_tac);
a(bc_thm_tac sin_cos_onto_unit_circle_thm1 THEN strip_tac);
pop_thm()
));

=TEX

%%%%
%%%%
=SML


val €s1_times_thm› = save_thm( "s1_times_thm", (
set_goal([], ¨µz w∑ z ç S1 ± w ç S1 ¥ z*w ç S1Æ);
a(REPEAT strip_tac THEN all_fc_tac[exp_s1_onto_thm]
	THEN all_var_elim_asm_tac1);
a(rewrite_tac[exp_s1_homomorphism_thm1, exp_s1_ç_s1_thm]);
pop_thm()
));

=TEX

%%%%
%%%%
=SML


val €exp_s1_onto_thm1› = save_thm( "exp_s1_onto_thm1", (
set_goal([], ¨µc z∑
	z ç S1
¥	∂â1x∑ c - – º x ± x < c + – ± z = ExpS1 xÆ);
a(REPEAT strip_tac);
a(all_fc_tac[exp_s1_onto_thm] THEN all_var_elim_asm_tac1);
a(lemma_tac¨ExpS1 (x + – + ~c) ç S1Æ THEN1 rewrite_tac[exp_s1_ç_s1_thm]);
a(strip_asm_tac(µ_elim¨ExpS1 (x + – + ~c)Æ exp_s1_onto_thm));
a(∂â1_tac¨x' + c + ~ –Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(once_rewrite_tac[exp_s1_homomorphism_thm]);
a(DROP_NTH_ASM_T 2 (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[exp_s1_homomorphism_thm1]);
a(conv_tac(ONCE_MAP_C Ø_anf_conv) THEN rewrite_tac[]);
(* *** Goal "4" *** *)
a(rewrite_tac[pc_rule1"Ø_lin_arith" prove_rule[]
	¨x'' = x' + c + ~ – § x'' + – - c = x'Æ]);
a(DROP_NTH_ASM_T 4 bc_thm_tac);
a(once_rewrite_tac[exp_s1_homomorphism_thm]);
a(asm_rewrite_tac[]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
pop_thm()
));


=TEX

%%%%
%%%%
=SML

val €exp_s1_onto_thm2› = save_thm( "exp_s1_onto_thm2", (
set_goal([], ¨µc z∑
	z ç S1 ±≥z = ExpS1 (c + –)
¥	∂â1x∑x ç OpenInterval (c - –) (c + –) ± z = ExpS1 xÆ);
a(rewrite_tac[open_interval_def] THEN REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨cÆ, ¨zÆ]exp_s1_onto_thm1));
a(∂â1_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 (strip_asm_tac o rewrite_rule[Ø_º_def])
	THEN all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(swap_nth_asm_concl_tac 3);
a(rewrite_tac[exp_s1_period_thm]);
a(∂_tac¨1Æ THEN rewrite_tac[]);
a(PC_T1"Ø_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 bc_thm_tac THEN asm_rewrite_tac[]);
a(PC_T1"Ø_lin_arith" asm_prove_tac[]);
pop_thm()
));


=TEX

%%%%
%%%%
=SML


val €exp_s1_onto_thm3› = save_thm( "exp_s1_onto_thm3", (
set_goal([], ¨µz∑ z ç S1 ¥ ∂x∑ ExpS1 x = zÆ);
a(REPEAT strip_tac THEN all_fc_tac[exp_s1_onto_thm]);
a(∂_tac¨xÆ THEN asm_rewrite_tac[]);
pop_thm()
));


=TEX

%%%%
%%%%
=SML

val €exp_s1_covering_projection_lemma1› = save_thm( "exp_s1_covering_projection_lemma1", (
set_goal([], ¨µc∑
	S1 \ {ExpS1 (c + –)} =
	{z | ∂ x∑ x ç OpenInterval (c - –) (c + –) ± z = ExpS1 x}Æ);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[exp_s1_onto_thm2]);
a(∂_tac¨xÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[exp_s1_ç_s1_thm]);
(* *** Goal "3" *** *)
a(pure_asm_rewrite_tac[] THEN POP_ASM_T discard_tac);
a(POP_ASM_T ante_tac
	THEN rewrite_tac[open_interval_def]
	THEN strip_tac);
a(ante_tac (list_µ_elim[¨cÆ, ¨ExpS1 xÆ] exp_s1_onto_thm1));
a(rewrite_tac[exp_s1_ç_s1_thm] THEN strip_tac);
a(lemma_tac¨c + ~ – º xÆ THEN1 asm_rewrite_tac[Ø_º_def]);
a(lemma_tac¨x = x'Æ THEN1
	(DROP_NTH_ASM_T 2 bc_thm_tac THEN asm_rewrite_tac[])
	THEN all_var_elim_asm_tac1);
a(contr_tac);
a(DROP_NTH_ASM_T 2 (ante_tac o µ_elim¨c + ~ –Æ) THEN asm_rewrite_tac[]);
a(LEMMA_T ¨~ – < – ± ≥c + ~ – = x'Æ rewrite_thm_tac
	THEN1 (strip_asm_tac –_def
		THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(rewrite_tac[exp_s1_period_thm]);
a(∂_tac¨1Æ THEN rewrite_tac[]);
a(strip_asm_tac –_def
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
pop_thm()
));



=TEX

%%%%
%%%%
=SML

val €exp_s1_covering_projection_lemma2› = save_thm( "exp_s1_covering_projection_lemma2", (
set_goal([], ¨µx∑
	ExpS1 ç
	(OpenInterval (x - –) (x + –) ÚâT OâR,
		(S1 \ {ExpS1 (x + –)}) ÚâT OâC) 
			Homeomorphism
Æ);
a(REPEAT strip_tac);
a(rewrite_tac[exp_s1_covering_projection_lemma1]);
a(bc_thm_tac Ä_compact_homeomorphism_thm);
a(∂_tac¨ClosedInterval (x - –) (x + –)Æ);
a(rewrite_tac[open_Ø_topology_thm, open_Ø_hausdorff_thm,
	open_÷_topology_thm, open_÷_hausdorff_thm,
	exp_s1_continuous_thm, compact_compact_Ø_thm,
	closed_interval_compact_thm]);
a(rewrite_tac[open_interval_def, closed_interval_def]);
a(REPEAT strip_tac THEN1
	(PC_T1 "sets_ext1" rewrite_tac[]
	THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[Ø_º_def]));
(* *** Goal "1" *** *)
a(ante_tac(list_µ_elim[¨xÆ, ¨ExpS1 yÆ] exp_s1_onto_thm1)
	THEN rewrite_tac[exp_s1_ç_s1_thm]
	THEN REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨yÆ THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o eq_sym_rule)); 
a(lemma_tac¨x + ~ – º x'Æ THEN1 asm_rewrite_tac[Ø_º_def]);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac THEN all_var_elim_asm_tac);
(* *** Goal "2" *** *)
a(i_contr_tac THEN all_var_elim_asm_tac1);
a(POP_ASM_T (strip_asm_tac o eq_sym_rule));
a(ante_tac(list_µ_elim[¨x' + –Æ, ¨ExpS1 (x + –)Æ] exp_s1_onto_thm1)
	THEN rewrite_tac[exp_s1_ç_s1_thm]
	THEN REPEAT strip_tac);
a(spec_nth_asm_tac 3 ¨x + –Æ THEN_TRY PC_T1"Ø_lin_arith" asm_prove_tac[]
	THEN all_var_elim_asm_tac1);
a(spec_nth_asm_tac 2 ¨x'Æ THEN_TRY PC_T1"Ø_lin_arith" asm_prove_tac[]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val €exp_s1_covering_projection_lemma3› = save_thm (
	"exp_s1_covering_projection_lemma3",
 rewrite_rule[open_Ø_topology_thm,
	open_÷_topology_thm,
	exp_s1_continuous_thm,
	exp_s1_ç_s1_thm,
	universe_subspace_topology_thm]
	(list_µ_elim[¨OâRÆ, ¨OâCÆ,
		¨Universe:Ø SETÆ, ¨S1Æ, ¨ExpS1Æ] 
			subspace_continuous_thm));

=TEX

%%%%
%%%%
=SML

val €exp_s1_covering_projection_lemma4› = save_thm( "exp_s1_covering_projection_lemma4", (
set_goal([], ¨µx∑
	ExpS1 x ç S1 \ {ExpS1 (x + –)}
Æ);
a(REPEAT strip_tac THEN1 rewrite_tac[exp_s1_ç_s1_thm]);
a(rewrite_tac[exp_s1_def, sin_cos_–_thm, sin_cos_plus_thm] THEN contr_tac);
a(lemma_tac¨Sin x = 0. ± Cos x = 0.Æ
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(ante_tac (µ_elim¨xÆcos_squared_plus_sin_squared_thm));
a(asm_rewrite_tac[Ø_Ó_exp_square_thm]);
pop_thm()
));

=TEX

=TEX

%%%%
%%%%
=SML

val €exp_s1_covering_projection_lemma5› = save_thm( "exp_s1_covering_projection_lemma5", (
set_goal([], ¨µx y∑
	ExpS1 x = ExpS1 y
±	≥OpenInterval (x + ~ –) (x + –) °
		OpenInterval (y + ~ –) (y + –) = {}
¥	x = y
Æ);
a(PC_T1 "sets_ext1" rewrite_tac[exp_s1_period_thm, open_interval_def] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN strip_asm_tac (µ_elim¨m:ÓÆ Ó_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN all_asm_ante_tac
	THEN rewrite_tac[ÓØ_times_homomorphism_thm,
		ÓØ_plus_homomorphism_thm,
		Ø_times_plus_distrib_thm,
		Ø_times_assoc_thm]
	THEN	(lemma_tac ¨0. º ÓØ i * –Æ THEN_LIST [
		bc_thm_tac Ø_0_º_0_º_times_thm,
		PC_T1 "Ø_lin_arith" asm_prove_tac[]]));
(* *** Goal "1" (duplicates "2") *** *)
a(rewrite_tac[ÓØ_º_thm] THEN rewrite_tac[Ø_º_def, –_def]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val €÷_punctured_set_thm› = save_thm (
	"÷_punctured_set_thm",
	rewrite_rule[
		open_÷_topology_thm,
		open_÷_hausdorff_thm,
		space_t_open_÷_thm]
		(µ_elim¨OâCÆ punctured_hausdorff_thm));

=TEX
%%%%
%%%%
=SML

val €exp_s1_covering_projection_thm› = save_thm( "exp_s1_covering_projection_thm", (
set_goal([], ¨
	ExpS1 ç (OâR, OâS1) CoveringProjection
Æ);
a(rewrite_tac[covering_projection_def, space_t_subspace_open_÷_thm,
	exp_s1_continuous_thm,
	exp_s1_covering_projection_lemma3, open_s1_def]
	THEN REPEAT strip_tac);
a(all_fc_tac[exp_s1_onto_thm] THEN all_var_elim_asm_tac1);
a(∂_tac¨S1 \ {ExpS1(x + –)}Æ);
a(rewrite_tac[exp_s1_covering_projection_lemma4,
	÷_punctured_set_thm]);
a(lemma_tac¨0. < –Æ THEN1 rewrite_tac[–_def]);
a(∂_tac¨{I | ∂y∑ ExpS1 y = ExpS1 x
	± I = OpenInterval (y - –) (y + –)}Æ
	THEN rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T "sets_ext1" strip_tac THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN rewrite_tac[open_interval_open_thm]);
(* *** Goal "2" *** *)
a(lemma_tac¨≥ExpS1 x = ExpS1(x' + –)Æ);
(* *** Goal "2.1" *** *)
a(swap_nth_asm_concl_tac 1 THEN POP_ASM_T ante_tac);
a(rewrite_tac[exp_s1_homomorphism_thm]);
a(rewrite_tac[exp_s1_def, sin_cos_–_thm, ÷_times_def]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac (list_µ_elim[¨x'Æ, ¨ExpS1 xÆ]exp_s1_onto_thm2));
a(∂_tac¨OpenInterval (x'' + ~ –) (x'' + –)Æ
	THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac
	THEN rewrite_tac[open_interval_def]
	THEN PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2.2.2" *** *)
a(∂_tac¨x''Æ THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨ExpS1 y = ExpS1 y'Æ THEN1 asm_rewrite_tac[]
	THEN all_var_elim_asm_tac1);
a(ALL_FC_T rewrite_tac[exp_s1_covering_projection_lemma5]);
(* *** Goal "4" *** *)
a(lemma_tac¨S1 \ {ExpS1 (x + –)} Ä S1Æ
	THEN1 PC_T1 "sets_ext1" prove_tac[]);
a(ALL_FC_T rewrite_tac[Ä_subspace_topology_thm]);
a(DROP_NTH_ASM_T 3 (strip_asm_tac o eq_sym_rule));
a(all_var_elim_asm_tac1);
a(LEMMA_T ¨ExpS1 (x + –) = ExpS1 (y + –)Æ rewrite_thm_tac
	THEN1 asm_rewrite_tac[exp_s1_homomorphism_thm]);
a(rewrite_tac[rewrite_rule[]exp_s1_covering_projection_lemma2]);
pop_thm()
));



=TEX
%%%%
%%%%

=SML

val €exp_s1_path_lifting_thm› = save_thm( "exp_s1_path_lifting_thm",
	(all_µ_intro o 
		rewrite_rule [exp_s1_covering_projection_thm, open_Ø_topology_thm,
			open_÷_topology_thm, space_t_Ø_thm, open_s1_topology_thm] o
			list_µ_elim [
				¨OâRÆ, ¨OâS1Æ, ¨ExpS1Æ])
						covering_projection_path_lifting_bc_thm);

=TEX
%%%%
%%%%

=SML

val €exp_s1_path_lifting_thm1› = save_thm ( "exp_s1_path_lifting_thm1", ( 
set_goal([], ¨
µ y f∑
	f ç Paths OâS1
¥	(∂ g∑ g ç Paths OâR ± (µ s∑ ExpS1 (g s) = f s))Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂x∑ ExpS1 x = f 0.Æ);
(* *** Goal "1" *** *)
a(lemma_tac¨f 0. ç S1Æ);
(* *** Goal "1.1" *** *)
a(ALL_FC_T (MAP_EVERY ante_tac) [paths_space_t_thm]);
a(rewrite_tac[space_t_open_s1_thm] THEN STRIP_T rewrite_thm_tac);
(* *** Goal "1.2" *** *)
a(contr_tac THEN all_fc_tac[conv_rule (ONCE_MAP_C eq_sym_conv) exp_s1_onto_thm]
	THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_fc_tac[exp_s1_path_lifting_thm]);
a(∂_tac¨gÆ THEN asm_rewrite_tac[]);
pop_thm()
));


=TEX
%%%%
%%%%

=SML
(*

val €s1_s1_loop_thm› = save_thm ( "s1_s1_loop_thm", ( 
set_goal([], ¨
µ f∑
	f ç (OâS1, OâS1) Continuous
¥	(Ã t∑ f (ExpS1 (2. * – * t))) ç Loops(OâS1, f (Ó÷ 0))Æ);
a(rewrite_tac[loops_def, paths_def] THEN REPEAT strip_tac);


pop_thm()
));

*)
=TEX
%%%%
%%%%

=SML

val €exp_s1_unique_path_lifting_thm› = save_thm( "exp_s1_unique_path_lifting_thm", (
set_goal([], ¨
µf g a∑
	f ç Paths OâR ± g ç Paths OâR ±
	(µx∑ ExpS1(f x) = ExpS1(g x)) ±
	g a = f a
¥	µx∑ f x = g x
Æ);
a(REPEAT µ_tac THEN ¥_tac);
a((bc_thm_tac o rewrite_rule [exp_s1_covering_projection_thm, open_Ø_topology_thm,
			open_÷_topology_thm, open_s1_topology_thm, space_t_Ø_thm,
			universe_Ø_connected_thm] o
			list_µ_elim [
				¨OâRÆ, ¨OâRÆ, ¨OâS1Æ, ¨ExpS1Æ])
						unique_lifting_bc_thm
	THEN ∂_tac¨aÆ);
a(ALL_FC_T asm_rewrite_tac[(rewrite_rule [open_Ø_topology_thm] o µ_elim¨OâRÆ) paths_continuous_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val €translated_path_Ø_path_thm› = save_thm ( "translated_path_Ø_path_thm", ( 
set_goal([], ¨
µf c∑ f ç Paths OâR ¥ (Ãx∑ f x + c) ç Paths OâR
Æ);
a(rewrite_tac[paths_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(Ø_continuity_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val €˙Ø_minus_homomorphism_thm› = save_thm ( "˙Ø_minus_homomorphism_thm", ( 
set_goal([], ¨
µi∑ ˙Ø(~i) = ~(˙Ø i)
Æ);
a(REPEAT strip_tac);
a(LEMMA_T ¨˙Ø i + ˙Ø(~i) = 0.Æ (fn th => ante_tac th THEN  PC_T1 "Ø_lin_arith" prove_tac[]));
a(LEMMA_T  ¨˙Ø i + ˙Ø(~i) = ˙Ø(i + ~i)Æ rewrite_thm_tac THEN1 
	(pure_rewrite_tac[˙Ø_plus_homomorphism_thm] THEN rewrite_tac[]));
a(rewrite_tac [˙Ø_Ó˙_thm]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML

(*
drop_main_goal();
*)

val _ = save_consistency_thm ¨PathS1LiftLengthÆ (
push_consistency_goal ¨PathS1LiftLengthÆ;
a(prove_∂_tac THEN REPEAT strip_tac);
a(cases_tac¨f' ç Paths OâS1Æ THEN asm_rewrite_tac[]);
a(all_fc_tac[exp_s1_path_lifting_thm1]);
a(∂_tac¨g 1.- g 0.Æ THEN REPEAT strip_tac);
a(rename_tac[(¨g'Æ, "h")] THEN rewrite_tac[]);
a(LEMMA_T ¨µx∑ (Ãy∑ h y + ~(h 0.) + g 0.) x = g xÆ
	(fn th => (ante_tac o µ_elim ¨1.Æ o rewrite_rule[]) th THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(bc_thm_tac exp_s1_unique_path_lifting_thm);
a(∂_tac¨0.Æ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac translated_path_Ø_path_thm	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_T¨ExpS1(h 0.) =  ExpS1(g 0.)Æ ante_tac THEN1 asm_rewrite_tac[]);
a(POP_ASM_T (rewrite_thm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
a(rewrite_tac[exp_s1_period_thm1] THEN REPEAT strip_tac);
a(∂_tac¨~iÆ THEN asm_rewrite_tac[˙Ø_minus_homomorphism_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "3" *** *)
a(PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
);

val €path_s1_lift_length_def› = get_spec ¨PathS1LiftLengthÆ;

=TEX
%%%%
%%%%

=SML

(*
drop_main_goal();
*)

val _ = save_consistency_thm ¨LoopS1DegreeÆ (
push_consistency_goal ¨LoopS1DegreeÆ;
a(prove_∂_tac THEN REPEAT strip_tac);
a(rename_tac[(¨f'Æ, "f")] THEN
	lemma_tac¨∂D∑ µg∑ f ç Loops (OâS1, f 0.) ± g ç Paths OâR ± (µ s∑ ExpS1 (g s) = f s) ¥
		g 1. + ~(g 0.) = 2. * ˙Ø D * –Æ);
(* *** Goal "1" *** *)
a(cases_tac¨f ç Loops(OâS1, f 0.)Æ THEN asm_rewrite_tac[]);
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[loops_def]));
a(all_fc_tac[exp_s1_path_lifting_thm1]);
a(LEMMA_T ¨ExpS1(g 0.) = ExpS1(g 1.)Æ ante_tac);
(* *** Goal "1.1" *** *)
a(conv_tac eq_sym_conv THEN asm_rewrite_tac[] THEN DROP_NTH_ASM_T 3 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(rewrite_tac[exp_s1_period_thm1,
	pc_rule1 "Ø_lin_arith" prove_rule[] ¨µx y z:Ø∑x = y + z § x - y = zÆ]
		THEN REPEAT strip_tac);
a(∂_tac¨iÆ THEN strip_tac THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(rename_tac[(¨g'Æ, "h")] THEN REPEAT strip_tac);
a(LEMMA_T ¨µx∑ (Ãy∑ h y + ~(h 0.) + g 0.) x = g xÆ
	(fn th => (ante_tac o µ_elim ¨1.Æ o rewrite_rule[]) th THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(bc_thm_tac exp_s1_unique_path_lifting_thm);
a(∂_tac¨0.Æ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(bc_thm_tac translated_path_Ø_path_thm	THEN REPEAT strip_tac);
(* *** Goal "1.2.2" *** *)
a(LEMMA_T¨ExpS1(h 0.) =  ExpS1(g 0.)Æ ante_tac THEN1 asm_rewrite_tac[]);
a(POP_ASM_T (rewrite_thm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
a(rewrite_tac[exp_s1_period_thm1] THEN REPEAT strip_tac);
a(∂_tac¨~iÆ THEN asm_rewrite_tac[˙Ø_minus_homomorphism_thm]);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "1.2.2.3" *** *)
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨DÆ THEN once_rewrite_tac[ç_loops_thm]);
a(REPEAT µ_tac THEN cases_tac ¨x = f 0.Æ THEN asm_rewrite_tac[]);
pop_thm()
);

val €loop_s1_degree_def› = get_spec ¨LoopS1DegreeÆ;

=TEX
%%%%
%%%%

=SML

val €exp_s1_path_fibration_thm› = save_thm ( "exp_s1_path_fibration_thm", ( 
set_goal([], ¨ µf H∑
	f ç Paths OâR
±	H ç (OâR ∏âT OâR, OâS1) Continuous
±	(µ x∑ H (x, 0.) = ExpS1 (f x))
¥	(∂ L∑
		L ç (OâR ∏âT OâR, OâR) Continuous
	±	(µ x∑ L (x, 0.) = f x)
	±	(µ x s∑ s ç ClosedInterval 0. 1. ¥ ExpS1 (L (x, s)) = H (x, s)))
Æ);
a(rewrite_tac[paths_def] THEN REPEAT strip_tac);
a((bc_thm_tac o all_µ_intro o 
		rewrite_rule [exp_s1_covering_projection_thm, open_Ø_topology_thm,
			homotopy_lifting_property_def,
			open_÷_topology_thm, space_t_Ø_thm, open_s1_topology_thm] o
			list_µ_elim [
				¨OâRÆ, ¨OâRÆ, ¨OâS1Æ, ¨ExpS1Æ])
						covering_projection_fibration_thm
	THEN asm_rewrite_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%

=SML

local
	
val €÷_continuity_fact_thms› : THM list = map (rewrite_rule[open_÷_def]) [
	÷_minus_continuous_thm,
	÷_conj_continuous_thm,
	÷_plus_continuous_thm,
	÷_times_continuous_thm,
	÷_Ó_exp_continuous_thm,
	exp_s1_continuous_thm];

in

fun €÷_continuity_tac› (thms : THM list): TACTIC = (
	TRY (rewrite_tac[open_÷_def]) THEN
		Ø_continuity_tac (thms @ ÷_continuity_fact_thms)
);

end (* local ... in ... end *);

=TEX
%%%%
%%%%
=SML

val €exp_s1_0_thm› = save_thm ( "exp_s1_thm", ( 
set_goal([], ¨
	ExpS1 0. = Ó÷ 1
Æ);
a(rewrite_tac[exp_s1_def, Ó÷_def, Ø÷_def, sin_def]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val €exp_s1_2_i_–_thm› = save_thm ( "exp_s1_2_–_thm", ( 
set_goal([], ¨
	µi∑ ExpS1 (2. * ˙Ø i * –) = Ó÷ 1
Æ);
a(strip_tac THEN rewrite_tac[eq_sym_rule exp_s1_0_thm, exp_s1_period_thm1]);
a(∂_tac¨~iÆ THEN rewrite_tac[˙Ø_minus_homomorphism_thm]
	THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));



=TEX
%%%%
%%%%
=SML

val €iota_s1_loop_thm› = save_thm ( "iota_s1_loop_thm", ( 
set_goal([], ¨
	IotaS1 ç Loops(OâS1, Ó÷ 1)
Æ);
a(rewrite_tac[eq_sym_rule exp_s1_0_thm, iota_s1_def]);
a((bc_thm_tac o rewrite_rule[] o
	list_µ_elim[¨OâS1Æ, ¨Ãt∑ExpS1(2. * – * t)Æ])loop_from_arc_thm
		THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[open_s1_def] THEN bc_thm_tac subspace_range_continuous_bc_thm);
a(rewrite_tac[exp_s1_ç_s1_thm]);
a(÷_continuity_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[exp_s1_period_thm1] THEN ∂_tac¨~(Ó˙ 1)Æ);
a(rewrite_tac[˙Ø_minus_homomorphism_thm, ˙Ø_def]
	THEN PC_T1 "Ø_lin_arith" prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val €iota_s1_continuous_thm› = save_thm ( "iota_s1_continuous_thm", ( 
set_goal([], ¨
	IotaS1 ç(OâR, OâS1) Continuous
Æ);
a((ante_tac o rewrite_rule[loops_def, paths_def]) iota_s1_loop_thm THEN REPEAT strip_tac);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val €s1_s1_loop_loop_thm› = save_thm ( "s1_s1_loop_loop_thm", ( 
set_goal([], ¨
µf∑ f ç (OâS1, OâS1) Continuous ¥ S1S1Loop f ç Loops(OâS1, f(Ó÷ 1))
Æ);
a(REPEAT strip_tac THEN strip_asm_tac iota_s1_loop_thm);
a(ALL_FC_T (MAP_EVERY ante_tac) [(rewrite_rule[open_s1_topology_thm] o
		list_µ_elim[¨OâS1Æ, ¨OâS1Æ]) loop_comp_continuous_loop_thm]);
a(rewrite_tac[s1_s1_loop_def]);
pop_thm()
));



=TEX
%%%%
%%%%
=SML

val €–_recip_clauses› = save_thm ( "–_recip_clauses", ( 
set_goal([], ¨
	– * – õ-õ1 = 1. ± – õ-õ1 * – = 1.
Æ);
a(conv_tac (RIGHT_C (once_rewrite_conv[Ø_times_comm_thm])));
a(rewrite_tac[] THEN bc_thm_tac Ø_times_recip_thm);
a(strip_asm_tac –_def THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val €times_2_–_lemma› = save_thm ( "times_2_–_lemma", ( 
set_goal([], ¨
	µx y∑ x = 2. * y * – § y = (1/2) * x * – õ-õ1
Æ);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(conv_tac (RIGHT_C Ø_anf_conv));
a(rewrite_tac[Ø_times_assoc_thm1, –_recip_clauses]);
(* *** Goal "2" *** *)
a(conv_tac (RIGHT_C Ø_anf_conv));
a(rewrite_tac[Ø_times_assoc_thm1, –_recip_clauses]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val €˙_º_cases_thm1› = save_thm("˙_º_cases_thm1",
	rewrite_rule[˙_less_def] ˙_less_cases_thm);
val €Ø_times_mono_§_thm1› = save_thm("Ø_times_mono_thm1",
	(conv_rule (ONCE_MAP_C eq_sym_conv)) Ø_times_mono_§_thm);

val €˙Ø_0_less_thm› = save_thm ( "˙Ø_0_less_thm", ( 
set_goal([], ¨
	µi∑ 0. < ˙Ø i § Ó˙ 0 < i
Æ);
a(strip_tac);
a((strip_asm_tac o µ_elim¨iÆ) ˙_cases_thm1 THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(rewrite_tac[˙Ø_Ó˙_thm, Ó˙_less_thm, ÓØ_less_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µx∑ 0. < x § ~x < 0.Æ,
	pc_rule1 "˙_lin_arith" prove_rule[]¨µx∑ Ó˙ 0 < x § ~x < Ó˙ 0Æ,
	Ó˙_less_thm]);
a(rewrite_tac[˙Ø_minus_homomorphism_thm, Ó˙_less_thm, Ó˙_plus_homomorphism_thm,
	˙Ø_def, ˙Ø_Ó˙_thm,ÓØ_less_thm]);
pop_thm()
));


val €˙Ø_less_thm› = save_thm ( "˙Ø_less_thm", ( 
set_goal([], ¨
	µi j∑ ˙Ø i < ˙Ø j § i < j
Æ);
a(REPEAT µ_tac THEN once_rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µx y∑ x < y § 0. < y - xÆ,
	pc_rule1 "˙_lin_arith" prove_rule[]¨µx y∑ x < y § Ó˙ 0 < y -  xÆ]);
a(LEMMA_T ¨˙Ø j + ~(˙Ø i) = ˙Ø(j + ~i)Æ rewrite_thm_tac
	THEN1 rewrite_tac[˙Ø_def, ˙Ø_minus_homomorphism_thm]);
a(rewrite_tac[˙Ø_0_less_thm]);
pop_thm()
));


val €˙Ø_one_one_thm› = save_thm ( "˙Ø_one_one_thm", ( 
set_goal([], ¨
	µi j∑ ˙Ø i = ˙Ø j § i = j
Æ);
a(REPEAT µ_tac THEN rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µx y:Ø∑ x = y § ≥x < y ± ≥y < xÆ,
	pc_rule1 "˙_lin_arith" prove_rule[]¨µx y:˙∑ x = y § ≥x < y ± ≥y < xÆ]);
a(rewrite_tac[˙Ø_less_thm]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val €discrete_subgroup_Ø_discrete_thm› = save_thm ( "discrete_subgroup_Ø_discrete_thm", ( 
set_goal([], ¨µc∑
	0. < c ¥ {z | ∂i∑ z = c * ˙Ø i} ÚâT OâR ç DiscreteâT
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨{z | ∂i∑ z = c * ˙Ø i} ÚâT OâR ç TopologyÆ THEN1 basic_topology_tac[]);
a(ALL_FC_T1 fc_§_canon rewrite_tac[open_singletons_discrete_thm]);
a(rewrite_tac[subspace_Ø_space_t_thm, subspace_topology_def]
	THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(∂_tac ¨OpenInterval (c * ˙Ø i - c) (c * ˙Ø i + c)Æ
	THEN rewrite_tac[open_interval_open_thm]);
a(rewrite_tac[open_interval_def] THEN PC_T1 "sets_ext1" REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(prove_tac[]);
(* *** Goal "4" *** *)
a(rename_tac[(¨i'Æ, "j")] THEN swap_nth_asm_concl_tac 1);
a(LIST_DROP_NTH_ASM_T [1, 2] (MAP_EVERY ante_tac) THEN POP_ASM_T discard_tac);
a(LEMMA_T¨c * ˙Ø i + ~ c = c * ˙Ø (i - Ó˙ 1)Æ rewrite_thm_tac
	THEN1 (rewrite_tac[˙Ø_def, ˙Ø_minus_homomorphism_thm] THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(LEMMA_T¨c * ˙Ø i + c = c * ˙Ø (i + Ó˙ 1)Æ rewrite_thm_tac
	THEN1 (rewrite_tac[˙Ø_def, ˙Ø_minus_homomorphism_thm] THEN PC_T1 "Ø_lin_arith" prove_tac[]));
a(ALL_FC_T1 fc_§_canon rewrite_tac[Ø_times_mono_§_thm1]);
a(rewrite_tac[˙Ø_less_thm]);
a(REPEAT strip_tac THEN LEMMA_T ¨i = jÆ rewrite_thm_tac);
a(PC_T1 "˙_lin_arith" asm_prove_tac[]);
pop_thm()
));

=TEX
%%%%
%%%%
=SML

val €ker_exp_s1_discrete_thm› = save_thm ( "ker_exp_s1_discrete_thm", ( 
set_goal([], ¨
	{z | ∂i∑ z = 2. * ˙Ø i * –} ÚâT OâR ç DiscreteâT
Æ);
a(rewrite_tac[pc_rule1 "Ø_lin_arith" prove_rule[]¨µx∑ 2. * x * – = (2. * –) * xÆ]);
a(bc_thm_tac discrete_subgroup_Ø_discrete_thm);
a(strip_asm_tac –_def THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
pop_thm()
));


=TEX
%%%%
%%%%

The below works around a possible bug in higher-order matching.

=SML

val €s1_s1_degree_homotopy_invariant_lemma1› = save_thm ( "s1_s1_degree_homotopy_invariant_lemma1", ( 
set_goal([], ¨µH∑ 
	H ç (OâS1 ∏âT OâR, OâS1) Continuous
¥	(Ã(y, s)∑ H(IotaS1 y, s)) ç (OâR ∏âT OâR, OâS1) Continuous
Æ);
a(REPEAT strip_tac);
a(LEMMA_T ¨(Ã(y, s)∑ H(IotaS1 y, s)) = (Ãys∑H((Ã(y, s)∑ (IotaS1 y, s)) ys))Æ
	pure_rewrite_thm_tac THEN1 rewrite_tac[]);
a(bc_thm_tac comp_continuous_thm);
a(∂_tac¨OâS1 ∏âT OâRÆ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(÷_continuity_tac[iota_s1_continuous_thm]);
(* *** Goal "2" *** *)
a(basic_topology_tac[]);
(* *** Goal "1.3" *** *)
a(basic_topology_tac[]);
pop_thm()
));


=TEX
%%%%
%%%%

The below works around a possible bug in higher-order matching.

=SML

val €s1_s1_degree_homotopy_invariant_lemma2› = save_thm ( "s1_s1_degree_homotopy_invariant_lemma2", ( 
set_goal([], ¨µH∑ 
	L ç (OâR ∏âT OâR, OâR) Continuous
¥	(Ã y∑ L (IotaI y, 1.)) ç Paths OâR
Æ);
a(REPEAT strip_tac);
a(LEMMA_T ¨(Ã y∑ L (IotaI y, 1.)) = (Ã y∑ (Ãz∑ L (z, 1.)) (IotaI y))Æ
		pure_rewrite_thm_tac
	THEN1 rewrite_tac[]);
a(bc_thm_tac comp_iota_i_path_thm);
a(REPEAT strip_tac THEN ÷_continuity_tac[]);
pop_thm()
));


=TEX
%%%%
%%%%
=SML

val €s1_s1_degree_homotopy_invariant_thm› = save_thm ( "s1_s1_degree_homotopy_invariant_thm", ( 
set_goal([], ¨µf g∑ 
	f ç (OâS1, OâS1) Continuous ±
	g ç (OâS1, OâS1) Continuous ±
	((OâS1, {}, OâS1) Homotopic) f g
¥	S1S1Degree f = S1S1Degree g
Æ);
a(rewrite_tac[homotopic_def, homotopy_def, s1_s1_degree_def, s1_s1_loop_def] THEN REPEAT strip_tac);
a(all_fc_tac[µ_elim¨fÆ s1_s1_loop_loop_thm]);
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[loops_def]));
a(all_fc_tac [paths_space_t_thm]);
a(POP_ASM_T (ante_tac o µ_elim¨0.Æ));
a(rewrite_tac[] THEN strip_tac);
a(all_fc_tac[exp_s1_onto_thm3]);
a(all_fc_tac[exp_s1_path_lifting_thm]);
a(rename_tac[(¨g'Æ, "lf")] THEN all_fc_tac [s1_s1_degree_homotopy_invariant_lemma1]);
a(lemma_tac¨µy∑ (Ã(y, s)∑ H(IotaS1 y, s)) (y, 0.) = ExpS1(lf y)Æ
	THEN1 asm_rewrite_tac[s1_s1_loop_def]);
a(all_fc_tac[exp_s1_path_fibration_thm]);
a(POP_ASM_T ante_tac THEN rewrite_tac[closed_interval_def] THEN REPEAT strip_tac);
a(lemma_tac¨µs∑0. º s ± s º 1. ¥ (Ãy∑ ExpS1(L(IotaI y, s))) ç Loops(OâS1, ExpS1(L(0., s)))Æ);
(* *** Goal "1" *** *)
a(rewrite_tac[loops_def] THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(LEMMA_T ¨(Ã y∑ ExpS1 (L (IotaI y, s))) = (Ã y∑ (Ãz∑ ExpS1 (L (z, s))) (IotaI y))Æ
		pure_rewrite_thm_tac
	THEN1 rewrite_tac[]);
a(bc_thm_tac comp_iota_i_path_thm);
a(REPEAT strip_tac THEN ÷_continuity_tac[]);
a(rewrite_tac[open_s1_def] THEN bc_thm_tac subspace_range_continuous_bc_thm);
a(rewrite_tac[exp_s1_continuous_thm, exp_s1_ç_s1_thm]);
(* *** Goal "1.2" *** *)
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
a(asm_rewrite_tac[iota_i_def]);
(* *** Goal "1.3" *** *)
a(LIST_DROP_NTH_ASM_T [4] all_fc_tac);
a(asm_rewrite_tac[iota_i_def]);
a(LEMMA_T¨≥t º 0.Æ rewrite_thm_tac THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a(LEMMA_T ¨(if t º 1. then t else 1.) = 1.Æ rewrite_thm_tac
	THEN1 (cases_tac ¨t º 1.Æ THEN asm_rewrite_tac[] THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(LEMMA_T¨IotaS1 1. = IotaS1 0.Æ rewrite_thm_tac THEN DROP_ASMS_T discard_tac);
a(rewrite_tac[iota_s1_def]);
(* *** Goal "2" *** *)
a(all_fc_tac [s1_s1_degree_homotopy_invariant_lemma2]);
a(GET_NTH_ASM_T 2 (strip_asm_tac o µ_elim¨1.Æ));
a(lemma_tac¨(µ s∑ ExpS1 ((Ã y∑ L (IotaI y, 1.)) s) = (Ã y∑ ExpS1 (L (IotaI y, 1.))) s)Æ
	THEN1 rewrite_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac) [loop_s1_degree_def] THEN rewrite_tac[]);
a(POP_ASM_T discard_tac);
a(LEMMA_T¨(Ã y∑ ExpS1 (L (IotaI y, 1.))) = (Ã t∑ g (IotaS1 t))Æ rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[] THEN lemma_tac ¨µx∑ ExpS1 (L (x, 1.)) = H (IotaS1 x, 1.)Æ);
(* *** Goal "2.1.1" *** *)
a(REPEAT strip_tac THEN GET_NTH_ASM_T 4 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2.1.2" *** *)
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(rewrite_tac[iota_s1_def, iota_i_def]);
a(if_cases_tac THEN asm_rewrite_tac[]);
a(PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(GET_NTH_ASM_T 5 (rewrite_thm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
a(LEMMA_T ¨IotaI 1. = 1. ± IotaI 0. = 0.Æ rewrite_thm_tac THEN1 rewrite_tac[iota_i_def]);
a(REPEAT strip_tac);
a(LEMMA_T¨L (1., 1.) + ~ (L (0., 1.)) = L (1., 0.) + ~ (L (0., 0.))Æ ante_tac);
(* *** Goal "2.2.1" *** *)
a(lemma_tac ¨∂c∑ µs∑ L(1., IotaI s) + ~(L(0., IotaI s)) = cÆ);
(* *** Goal "2.2.1.1" *** *)
a((bc_thm_tac o rewrite_rule [ker_exp_s1_discrete_thm, universe_Ø_connected_thm] o
	list_µ_elim[¨OâRÆ, ¨{z | ∂i∑ z = 2. * ˙Ø i * –} ÚâT OâRÆ,
		¨(Ãs∑ L(1., IotaI s) + ~(L(0., IotaI s)))Æ])
			connected_discrete_continuous_thm);
a(REPEAT strip_tac THEN1 (bc_thm_tac subspace_topology_thm THEN REPEAT strip_tac));
a(bc_thm_tac subspace_range_continuous_bc_thm THEN rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.2.1.1.1" *** *)
a(LEMMA_T ¨ExpS1 (L (0., IotaI x')) = ExpS1(L(1., IotaI x'))Æ
	(strip_asm_tac o rewrite_rule[exp_s1_period_thm1]));
(* *** Goal "2.2.1.1.1.1" *** *)
a(lemma_tac¨0. º IotaI x' ± IotaI x' º 1.Æ
	THEN1 (rewrite_tac[iota_i_def] THEN if_cases_tac THEN asm_rewrite_tac[]
		THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a(LIST_DROP_NTH_ASM_T [8] (ALL_FC_T rewrite_tac));
a(rewrite_tac[iota_s1_def]);
(* *** Goal "2.2.1.1.1.2" *** *)
a(∂_tac¨iÆ THEN POP_ASM_T rewrite_thm_tac);
a(PC_T1 "Ø_lin_arith" prove_tac[]);
(* *** Goal "2.2.1.1.2" *** *)
a(÷_continuity_tac[iota_i_continuous_thm]);
(* *** Goal "2.2.1.2" *** *)
a(POP_ASM_T (fn th => (ante_tac o µ_elim¨0.Æ) th THEN (ante_tac o µ_elim¨1.Æ) th));
a(rewrite_tac[iota_i_def] THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a(LIST_DROP_NTH_ASM_T [1, 2] rewrite_tac);
a(asm_rewrite_tac[˙Ø_one_one_thm, times_2_–_lemma]);
a(rewrite_tac[Ø_times_assoc_thm1]);
a(rewrite_tac[Ø_times_assoc_thm, –_recip_clauses, ˙Ø_one_one_thm, s1_s1_loop_def]);
pop_thm()
));

=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val €sections› = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="wrk072.th.doc", theory="÷"};
end;
=TEX
} %\Hide
\end{document}


