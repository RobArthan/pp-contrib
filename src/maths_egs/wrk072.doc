=IGN
********************************************************************************
wrk072.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% wrk072.doc $Revision: 1.5 $ $RCSfile: wrk072.doc,v $ $Date: 2005/09/17 13:13:07 $
=TEX
\documentclass[12pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{A4}
\def\Hide#1{\relax}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\C{\mathbb{C}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\title{Mathematical Case Studies: the Complex Numbers}
\author{Rob Arthan\\{\tt rda@lemma-one.com}}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}

Definitions of the complex numbers and their arithmetic operators in {\ProductHOL} with proofs of some of their elementary algebraic properties.

\end{abstract}
%\newpage
%\tableofcontents
%\newpage
\section{INTRODUCTION}
This document contains the beginnings of a theory of complex arithmetic in {\ProductHOL}.

After some preliminaries, section~\ref{theory} introduces the field operations and the embedddings of the real numbers and of conjugation (which help to abbreviate the definition of reciprocals).
We then define the derived operations of binary subtraction and division and the embedding of the natural numbers.

A proof script contained in the source of this document but hidden from the printed document gives proofs that the complex numbers form a field and  of some elementary algebraic properties of complex conjugation and of the embeddings of the natural numbers and the real numbers in the complex numbers.
With one exception, the proofs comprise nothing more than simplifying using definitions and standard theorems and then application of the decision procedure for linear arithmetic to prove the resulting problem of real algebra.
The exception is proving that $xx^{-1} = 1$, which requires a few lines of reasoning about real squares.
A listing of the theorems proved is given in appendix~\ref{listing}.


\section{THE THEORY %bbC%}\label{theory}

\subsection{Preliminaries}
The following commands set up a theory to hold the definitions, theorems, etc.
The theory has the theory of analysis defined in ~\cite{LEMMA1/HOL/WRK066} for its parent, although the elementary algebraic theory only needs one or two little theorems about squares.
=SML
force_delete_theory"%bbC%" handle Fail _ => ();
open_theory"analysis";
new_theory"%bbC%";
=TEX
Now set up a convenient proof context:
=SML
set_merge_pcs["basic_hol1", "'ú", "'¯"];
=TEX
\subsection{The Type %bbC%}
The type %bbC% comprises pairs of real numbers.
We capture this in a type abbreviation:
=SML
declare_type_abbrev("%bbC%", [], ”¯ ¸ ¯®);
=TEX
\subsection{Addition}

=SML
declare_infix(300, "+‰C");
=TEX

¹HOLCONST
Ü $Û+‰CÝ : %bbC% ­ %bbC% ­ %bbC%
÷üüüüüü
Üµ z w : %bbC%· z +‰C w = (Fst z + Fst w, Snd z + Snd w)
°

=SML
declare_alias("+", ¬$+‰C®);
=TEX
\subsection{Negation}

¹HOLCONST
Ü Û~‰CÝ : %bbC% ­ %bbC%
÷üüüüüü
Üµ z : %bbC%· ~‰C z = (~(Fst z), ~(Snd z))
°
=SML
declare_alias("~", ¬~‰C®);
=TEX

=TEX
\subsection{Multiplication}
=SML
declare_infix(310, "*‰C");
=TEX

¹HOLCONST
Ü $Û*‰CÝ : %bbC% ­ %bbC% ­ %bbC%
÷üüüüüü
Üµ z w : %bbC%·
Ü	z *‰C w = (Fst z * Fst w - Snd z * Snd w, Fst z * Snd w + Snd z * Fst w)
°

=SML
declare_alias("*", ¬$*‰C®);
=TEX
\subsection{Embedding of the Real Numbers}


¹HOLCONST
Ü Û¯%bbC%Ý : ¯ ­ %bbC%
÷üüüüüü
Üµx· ¯%bbC% x = (x, î¯ 0)
°
\subsection{Conjugation}
=SML
declare_postfix(320, "›_");
=TEX
¹HOLCONST
Ü Û$›_Ý : %bbC% ­ %bbC%
÷üüüüüü
Üµ z : %bbC%· z ›_ = (Fst z, ~(Snd z))
°
\subsection{Reciprocal}
=SML
declare_postfix(320, "›-›1›C");
=TEX

¹HOLCONST
Ü $Û›-›1›CÝ : %bbC% ­ %bbC%
÷üüüüüü
Üµ z : %bbC%· z ›-›1›C = z ›_ * ¯%bbC%(Fst (z * z ›_) ›-›1)
°

=SML
declare_alias("›-›1", ¬$›-›1›C®);
=TEX


\subsection{Subtraction}
=SML
declare_infix(300, "-‰C");
=TEX

¹HOLCONST
Ü $Û-‰CÝ : %bbC% ­ %bbC% ­ %bbC%
÷üüüüüü
Üµ z w : %bbC%· z -‰C w = z + ~w
°



\subsection{Division}
=SML
declare_infix(315, "/‰C");
=TEX

¹HOLCONST
Ü $Û/‰CÝ : %bbC% ­ %bbC% ­ %bbC%
÷üüüüüü
Üµ z w : %bbC%· z /‰C w = z * (w ›-›1)
°


=SML
declare_alias("/", ¬$/‰C®);
=TEX
\subsection{Embedding of the Natural Numbers}


¹HOLCONST
Ü Ûî%bbC%Ý : î ­ %bbC%
÷üüüüüü
Üµm· î%bbC% m = ¯%bbC%(î¯ m)
°
% \subsection{Embedding of the Integers}


% ¹HOLCONST
% Ü Ûú%bbC%Ý : ú ­ %bbC%
% ÷üüüüüü
% Üµi· ú%bbC% i = ¯%bbC%(ú¯ i)
% °
\subsection{Exponentiation with Natural Number Exponents}

=SML
declare_infix(320, "^‰C");
=TEX
¹HOLCONST
Ü $Û^‰CÝ : %bbC% ­ î ­ %bbC%
÷üüüüüü
Ü	(µ z: %bbC%· z ^‰C 0 = î%bbC% 1)
Ü ±	(µ z: %bbC%; m· z ^‰C (m+1) = z * z ^‰C m)
°

=SML
declare_alias("^", ¬$^‰C®);
=TEX

=TEX
%\twocolumn[\section{INDEX}\label{INDEX}]
%{\printindex}

\bibliographystyle{plain}
\bibliography{fmu}

\appendix
{\HOLindexOff
\let\Section\section
\let\subsection\Hide
\def\section#1{\Section{#1}\label{listing}}
\let\subsection\Hide
\include{wrk072.th}}

=TEX
\end{document} %% COMMENT THIS LINE OUT TO TYPESET THE PROOF SCRIPTS
=TEX
=SML
val Û%bbC%_plus_defÝ = get_spec ¬$+‰C®;
val Û%bbC%_minus_defÝ = get_spec ¬~‰C®;
val Û%bbC%_conj_defÝ = get_spec ¬$›_®;
val Û%bbC%_times_defÝ = get_spec ¬$*‰C®;
val Û%bbC%_recip_defÝ = get_spec ¬$›-›1›C®;
val Û%bbC%_subtract_defÝ = get_spec ¬$-‰C®;
val Ûî%bbC%_defÝ = get_spec ¬î%bbC%®;
val Û¯%bbC%_defÝ = get_spec ¬¯%bbC%®;
=IGN
val Ûú%bbC%_defÝ = get_spec ¬ú%bbC%®;
=SML
val Û%bbC%_î_exp_defÝ = get_spec ¬$^‰C®;
val Û%bbC%_defsÝ = map get_spec(get_consts "-");
=TEX
=SML
set_goal([], ¬µ x y:%bbC%· x + y = y + x®);
a(rewrite_tac %bbC%_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û%bbC%_plus_comm_thmÝ = save_pop_thm "%bbC%_plus_comm_thm";
=TEX
=SML
set_goal([], ¬µ x y z:%bbC%· (x + y) + z = x + y + z®);
a(rewrite_tac %bbC%_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û%bbC%_plus_assoc_thmÝ = save_pop_thm "%bbC%_plus_assoc_thm";
=SML
set_goal([], ¬µ x:%bbC%· x + î%bbC% 0 = x®);
a(rewrite_tac %bbC%_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û%bbC%_plus_0_thmÝ = save_pop_thm "%bbC%_plus_0_thm";
=SML
set_goal([], ¬µ x:%bbC%· x + ~x = î%bbC% 0®);
a(rewrite_tac %bbC%_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û%bbC%_plus_minus_thmÝ = save_pop_thm "%bbC%_plus_minus_thm";
=TEX
=SML
set_goal([], ¬µ x:%bbC%·
	x * (x ›_) = ¯%bbC%(Fst x ^ 2 + Snd x ^ 2)
®);
a(rewrite_tac (¯_î_exp_square_thm::%bbC%_defs) THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û%bbC%_times_conj_thmÝ = save_pop_thm "%bbC%_times_conj_thm";
=TEX
=SML
set_goal([], ¬µ x y:%bbC%· x * y = y * x®);
a(rewrite_tac %bbC%_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û%bbC%_times_comm_thmÝ = save_pop_thm "%bbC%_times_comm_thm";
=TEX
=SML
set_goal([], ¬µ x y z:%bbC%· (x * y) * z = x * y * z®);
a(rewrite_tac %bbC%_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û%bbC%_times_assoc_thmÝ = save_pop_thm "%bbC%_times_assoc_thm";
=SML
set_goal([], ¬µ x:%bbC%· x * î%bbC% 1 = x®);
a(rewrite_tac %bbC%_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û%bbC%_times_1_thmÝ = save_pop_thm "%bbC%_times_1_thm";
=SML
set_goal([], ¬µ x:%bbC%· ³x = î%bbC% 0 ´ x * x ›-›1 = î%bbC% 1®);
a(rewrite_tac [%bbC%_recip_def, %bbC%_times_conj_thm]);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) %bbC%_times_assoc_thm, %bbC%_times_conj_thm]);
a(rewrite_tac %bbC%_defs);
a(µ_tac THEN STRIP_T asm_tac);
a(bc_thm_tac (rewrite_rule[](nth 2 (fc_canon(±_left_elim ¯_recip_clauses)))));
a(strip_asm_tac(µ_elim¬Fst x® ¯_0_¼_square_thm));
a(strip_asm_tac(µ_elim¬Snd x® ¯_0_¼_square_thm));
a(swap_nth_asm_concl_tac 3);
a(LEMMA_T ¬Fst x ^ 2 = î¯ 0 ± Snd x ^ 2  = î¯ 0® ante_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[¯_square_eq_0_thm]);
val Û%bbC%_times_recip_thmÝ = save_pop_thm "%bbC%_times_recip_thm";
=TEX
=SML
set_goal([], ¬µ x y z:%bbC%· x * (y + z) = x * y + x * z®);
a(rewrite_tac %bbC%_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û%bbC%_times_plus_distrib_thmÝ = save_pop_thm "%bbC%_times_plus_distrib_thm";
=TEX
=SML
set_goal([], ¬µ x y:%bbC%· (x + y) ›_  = x ›_ + y ›_®);
a(rewrite_tac %bbC%_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û%bbC%_conj_plus_homomorphism_thmÝ = save_pop_thm "%bbC%_conj_plus_homomorphism_thm";
=TEX
=SML
set_goal([], ¬µ x y:%bbC%· (x * y) ›_  = x ›_ * y ›_®);
a(rewrite_tac %bbC%_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û%bbC%_conj_times_homomorphism_thmÝ = save_pop_thm "%bbC%_conj_times_homomorphism_thm";
=TEX
=SML
set_goal([], ¬µ x y:¯· ¯%bbC%(x + y) = ¯%bbC% x + ¯%bbC% y®);
a(rewrite_tac %bbC%_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û¯%bbC%_plus_homomorphism_thmÝ = save_pop_thm "¯%bbC%_plus_homomorphism_thm";
=TEX
=SML
set_goal([], ¬µ x y:¯· ¯%bbC%(x * y) = ¯%bbC% x * ¯%bbC% y®);
a(rewrite_tac %bbC%_defs THEN PC_T1 "¯_lin_arith" prove_tac[]);
val Û¯%bbC%_times_homomorphism_thmÝ = save_pop_thm "¯%bbC%_times_homomorphism_thm";
=TEX
=SML
set_goal([], ¬µ x y:î· î%bbC%(x + y) = î%bbC% x + î%bbC% y®);
a(rewrite_tac (î¯_plus_homomorphism_thm::%bbC%_defs));
val Ûî%bbC%_plus_homomorphism_thmÝ = save_pop_thm "î%bbC%_plus_homomorphism_thm";
=TEX
=SML
set_goal([], ¬µ x y:î· î%bbC%(x * y) = î%bbC% x * î%bbC% y®);
a(rewrite_tac (î¯_times_homomorphism_thm::%bbC%_defs));
val Ûî%bbC%_times_homomorphism_thmÝ = save_pop_thm "î%bbC%_times_homomorphism_thm";
=TEX
=IGN
set_goal([], ¬µ x y:ú· ú%bbC%(x + y) = ú%bbC% x + ú%bbC% y®);
a(rewrite_tac (ú¯_plus_homomorphism_thm::%bbC%_defs));
val Ûú%bbC%_plus_homomorphism_thmÝ = save_pop_thm "ú%bbC%_plus_homomorphism_thm";
=TEX
=IGN
set_goal([], ¬µ x y:ú· ú%bbC%(x * y) = ú%bbC% x * ú%bbC% y®);
a(rewrite_tac (ú¯_times_homomorphism_thm::%bbC%_defs));
val Ûú%bbC%_times_homomorphism_thmÝ = save_pop_thm "ú%bbC%_times_homomorphism_thm";
=TEX
=SML
set_goal([], ¬µ x m·
	(Cos x, Sin x) ^ m =
	(Cos (î¯ m * x), Sin (î¯ m * x))
®);
a(REPEAT µ_tac THEN induction_tac¬m:î®
	THEN asm_rewrite_tac 
	(sin_def::î¯_plus_homomorphism_thm::
		¯_times_plus_distrib_thm::
		sin_cos_plus_thm::%bbC%_defs));
a(PC_T1 "¯_lin_arith" prove_tac[]);
val Ûde_moivre_thmÝ = save_pop_thm "de_moivre_thm";
=TEX
\Hide{
=SML
local 
	open	ListerSupport;
	val ÛsectionsÝ = [LSBanner, LSThms];
	val {print=pt, out=ot, out1=ot1} = gen_theory_lister sections;
	fun output_banner (thyn : string) = "THEOREMS IN THE THEORY " ^ (case thyn of "-" => get_current_theory_name () | _ => thyn);
	fun output_theorems (par : {out_file:string, theory:string}) : unit = (
		(ot output_banner par) handle ex => reraise ex "z_output_theory"
	);
in
	val _ = output_theorems{out_file="wrk072.th.doc", theory="%bbC%"};
end;
=TEX
} %\Hide
\end{document}


