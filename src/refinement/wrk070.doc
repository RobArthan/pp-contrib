=TEX
\documentclass{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\def\Hide#1{\relax}
\title{On Refinement and Partial Correctness}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\section{Introduction}
This note is a working paper on refinement and partial correctness.
It aims to provide a simple formal model in which to reason about
refinement notations along the lines of the Compliance Notation.
It is particularly intended to assist with work on handling more
complex control flow than is currently handled in the Compliance Notation.

\section{A Compliance Notation Example}
Since this note may need to be understood at some future date by an audience
who are not familiar with the Compliance Notation, this section contains
a simple example. However, as the current audience are expected to
know about the Compliance Notation, this is just a place-holder and
the accompanying narrative has not yet been written.

\subsection{Package Specification}
\Hide{
=SML
new_script{name = "SUM", state=initial_cn_state};
=TEX
}
πCN
package €sum› is
  type €data› is range -1000 .. 1000;
  €acc_neg›, €acc_pos› : data;
  procedure €sum_pos› (x : in data)
  Ñ ACC_NEG, ACC_POS [ ~10 º X º 10,
          X < 0 ± ACC_NEG = ACC_NEGâ0 + X ± ACC_POS = ACC_POSâ0 ≤
          X = 0 ± ACC_NEG = ACC_POS = 0 ≤
          X > 0 ± ACC_POS = ACC_POSâ0 + X ± ACC_NEG = ACC_NEGâ0 ];
end sum;
∞
=TEX
\subsection{Package Body}
\Hide{
=SML
new_script{name = "SUM_BODY", state=get_cn_state()};
=TEX
}
πCN
package body €sum› is
  procedure €sum_pos› (x : in data)
  Ñ ACC_NEG, ACC_POS [
          X < 0 ± ACC_NEG = ACC_NEGâ0 + X ± ACC_POS = ACC_POSâ0 ≤
          X = 0 ± ACC_NEG = ACC_POS = 0 ≤
          X > 0 ± ACC_POS = ACC_POSâ0 + X ± ACC_NEG = ACC_NEGâ0]
  is
  begin
    if     x = 0
    then   acc_neg := 0; acc_pos := 0;
    else   Ñ ACC_NEG, ACC_POS [ X Ω 0,
           X Ω 0 ±
          (X < 0 ± ACC_NEG = ACC_NEGâ0 + X ± ACC_POS = ACC_POSâ0 ≤
           X > 0 ± ACC_POS = ACC_POSâ0 + X ± ACC_NEG = ACC_NEGâ0) 	] (else_part)
    end if;
  end sum_pos;
end sum;
∞
πCN
 (else_part) √
        if x <= 0
        then acc_neg := acc_neg + x;
        else acc_pos := acc_pos + x;
        end if;
∞
\Hide{
=SML
set_pc"cn1";
val vcs = rev(map (hd ** snd) (get_conjectures "-"));
fun try_tactic acc tac ((vc as (name, term))::more) = (
	(delete_thm name handle Fail _ => t_thm);
	(save_thm(name, tac_proof(([], term), tac)); try_tactic acc tac more)
	handle Fail _ => try_tactic (vc::acc) tac more
) | try_tactic acc _ [] = rev acc;
val vcs1 = try_tactic []
	(cn_vc_simp_tac[] THEN REPEAT strip_tac) vcs;
val vcs2 = try_tactic []
	(cn_vc_simp_tac[] THEN PC_T1 "z_lin_arith" asm_prove_tac[]) vcs1;
=TEX
}
=SML
output_z_document{script = "SUM", out_file="refine1.zed"};
output_z_document{script = "SUM_BODY", out_file="refine2.zed"};
=TEX
\Hide{
=SH
sed -e '/^$/d' -e '/^[a-zA-Z(]/{
	i\
	=SML
}' < refine1.zed | sed -e '/^	/s/	//' | sieve tex > refine1.zed.tex
sed -e '/^$/d' -e '/^[a-zA-Z(]/{
	i\
	=SML
}' < refine2.zed | sed -e '/^	/s/	//' | sieve tex > refine2.zed.tex
=TEX
}
=IGN
print_z_document "SUM";
print_z_document "SUM_BODY";
=TEX
%{\ftlinepenalty=9999
%\underscoreoff\subsection{Z Documents}
%\input{refine1.zed.tex}
%\input{refine2.zed.tex}}
\section{A Z Model For Refinement Notations}
We wish to give a formal model for understanding refinement notations
along the lines of the Compliance Notation.
This section builds up this material.
\subsection{Preamble}
The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"z_library";
set_pc"z_library1";
force_delete_theory"refinement" handle Fail _ => ();
new_theory"refinement";
ReaderWriterSupport.PrettyNames.add_new_symbols[
	(["refinedby"], Value "√", ReaderWriterSupport.PrettyNames.Simple)
] handle Fail _ => ();
=TEX
\subsection{States and State Transformers}
The internal structure of states is not relevant to our purposes.
We just introduce a given set to represent the states:
πZ
‹ [€STATE›]
∞

A state transformer is just a relation on states:
πZ
‹ €STATE_TRANSFORMER› ¶ STATE ™ STATE
∞
We think of a state transformer $t$ as {\em responding} to a state, the {\em before-state},
$s$ in its domain by non-deterministically selecting some {\em response} or {\em after-state},
which is a state $s'$ such that $(s, s') \in t$.

\subsection{A First Notion of Program}
Our first notion of programs has five syntactic categories:

\begin{center}
\begin{tabular}{|l|p{4in}|}\hline
Atom &
This comprises some set of primitive operations on the state. In a typical
imperative language, the atoms might be the denotations of assignment statements
and procedure calls. In the Compliance Notation, the denotation of a procedure
call is represented by an instance of the formal specification appearing
in the procedure header.
\\\hline
Seq &
Sequential composition
\\\hline
If &
If-then-else
\\\hline
While &
While-loop
\\\hline
Spec &
Programs with specifications; the specification is a state transformer
that we would like the program to refine. In a notation like the Compliance Notation
the specifications would be the denotations of pre- and post-condition pairs.
However, it is necessary for to record the pre-condition separately.
\\\hline
\end{tabular}

\end{center}

Here in a notation like the Compliance Notation, the states will be
assignments of values to program variables.
Syntactically, a pre-condition is a predicate whose free variables are program variables and a post-condition is a predicate whose free variables are
program variables with optional decoration to distinguish values in the before-state
from values in the after-state.
A pre-condition denotes the set of assignments, $\alpha$, in which the program
variables satisfy the pre-condition and a post-condition denotes
the relation, $\rho$, which holds between two states $s$ and $s'$ when $s \times s'$
satisfies the post-condition after makihng the appropriate binding of before- and after-values
to the variables in the post-condition.

Taken together, we can often think of the pre- and post-condition as denoting the state transformer
=INLINEFT
¡ Ú “
=TEX
.
However, we lose some expressiveness in doing this, since, for example,
if the post-condition is unsatisfiable, the pre-condition effectively
defines a set of states in which the program must not terminate.
Consequently, we must keep a separate record of the pre-condition. 

Quite often, we will work with post-conditions having the form
{\it STATE} $\times$ $\beta$, where $\beta$ is some set of
states. These correspond to syntactic post-conditions that do
not mention initial values (i.e., values in the before-state).
The state transformer,
=INLINEFT
¡ Ú “
=TEX
\ of the previous paragraph reduces to
=INLINEFT
¡ ∏ ¬
=TEX
\ in this special case and we will sometimes just talk of
the set $\beta$ representing the post-condition.


A predicate on states is just a set of states, i.e., the denotation of the
usual syntactic notion of a predicate:
πZ
‹ €PRED› ¶ STATE
∞

As discussed above, specifications comprises a ;predicate
giving the pre-condition and a state transforme giving the post-condition.
πZ
‹ €SPEC› ¶ PRED ∏ STATE_TRANSFORMER
∞

We can now represent programs abstractly using the following free type, in which we freely
mingle semantic and syntactic domains to simplify later work. We also use a tree
structure rather than a linear list for sequential composition, since that is semantically
harmless, and, again, helps to keep things simple later on.
πZ
‹ €PROG› ::=
‹	€Atom› (STATE_TRANSFORMER)
‹ |	€Seq› (PROG ∏ PROG)
‹ |	€If› (PRED ∏ PROG ∏ PROG)
‹ |	€While› (PRED ∏ PROG)
‹ |	€Spec› (SPEC ∏ PROG)
∞
The following function gives the semantics of this notion of a program.
The semantic value of a program is a state transformer.
In the semantics, the specifications in the syntactic category Spec are just
ignored --- it is the actual code that determines the semantics, not our aspirations
for it.
πZAX
‹ €semantics› : PROG ≠ STATE_TRANSFORMER
˜¸¸¸¸¸¸
‹ µt : STATE_TRANSFORMER; pâ1, pâ2 : PROG; c : PRED; s : SPEC∑
‹	semantics (Atom t) = t
‹ ±	semantics (Seq (pâ1, pâ2)) = semantics pâ1 ª semantics pâ2
‹ ±	semantics (If(c, pâ1, pâ2)) = semantics pâ2 ´ (c Ú semantics pâ1)
‹ ±	semantics (While(c, pâ1)) = (c Ú semantics pâ1)Á*Í Å c
‹ ±	semantics (Spec(s, pâ1)) = semantics pâ1
∞
It is in the above that the convenience of dealing with partial correctness
begins to become apparent. The semantics of a while-loop says that the
body of the loop is to be executed repeatedly in states satisfying
the predicate $c$ until a state which does not satisfy $c$ is reached.
If this fails to terminate the result is just the empty relation.
The semantics of total correctness demand
a much more complex representation, but we have no need of that.
\subsection{Refinement}
Refinement is a notion that is fundamental to the notion of program
correctness that we will define; however, it is a semantic notion
that is independent of the syntax of programs.
Recall that a specification statement comprises a predicate, the
pre-condition, and a state transformer, the post-condition.
One specification statement, 
=INLINEFT
sâ2 = (precâ2, postcâ2)
=TEX
\ refines another
=INLINEFT
sâ1 = (precâ1, postcâ1)
=TEX
\ iff.
=INLINEFT
precâ2
=TEX
\ includes
=INLINEFT
precâ1
=TEX
, the domain of
=INLINEFT
postcâ2
=TEX
\ includes all elements of the domain of
=INLINEFT
postcâ1
=TEX
\ that satisfy
=INLINEFT
precâ1
=TEX
\ and the restriction of
=INLINEFT
postcâ2
=TEX
\ to
=INLINEFT
precâ1
=TEX
\ is contained in
=INLINEFT
postcâ1
=TEX
.
The first two of these conditions amount to the
the traditional notion of liveness --- they say, in effect, that $s_2$ is able to
respond in any state that $s_1$ can respond in. The third
condition is the traditional notion of safety --- it says that any response
made by $s_2$ in a state satisfying the pre-condition of $s_1$
is a response that could also be made by $s_1$.

πZ
‹ relation _ √ _
∞

πZAX
‹ €_ √ _› : SPEC ™ SPEC
˜¸¸¸¸¸¸
‹ µprecâ1, precâ2 : PRED; postcâ1, postcâ2 : STATE_TRANSFORMER∑
‹	(precâ1, postcâ1) √ (precâ2, postcâ2)
‹ §	precâ1 Ä precâ2
‹ ±	precâ1 ° dom postcâ1 Ä dom postcâ2
‹ ±	precâ1 Ú postcâ2 Ä postcâ1
∞



If $t_1$ and $t_2$ are two state transformers.
The $t_1$ {\em cut-down} of $t_2$ is the largest set of states, $c$ say,
such that $(c, t_2)$ refines $(c, t_2)$.
We write this as $t_1 \downarrow t_2$.

πZ
‹ function 7 _ %downarrow% _
∞
πZAX
‹ €_ %downarrow% _› : STATE_TRANSFORMER ∏ STATE_TRANSFORMER ≠ STATE
˜¸¸¸¸¸¸
‹ µtâ1, tâ2 : STATE_TRANSFORMER∑
‹	tâ1 %downarrow% tâ2 = ﬁ{c : STATE | (c, tâ1) √ (c, tâ2)}
∞
The following conjecture states the main properties of the cut-down.
πZ
‹ cutdown_clauses_cnj ?Ù
‹	µtâ1, tâ2 : STATE_TRANSFORMER∑
‹	(tâ1 %downarrow% tâ2, tâ1) √ (tâ1 %downarrow% tâ2, tâ2)
‹ ±	(µc : STATE | (c, tâ1) √ (c, tâ2) ∑ c Ä tâ1 %downarrow% tâ2)
∞

There are many equivalent ways of formulating the above definition.
The following conjecture records one alternative giving a pointwise
construction.
πZ
‹ cutdown_pointwise_cnj ?Ù
‹	µtâ1, tâ2 : STATE_TRANSFORMER∑
‹	tâ1 %downarrow% tâ2 = {s : STATE | ({s}, tâ1) √ ({s}, tâ2)}
∞
\subsection{Program Correctness}
Intuitively, a program is correct if every part of it that has a specification
satisfies that specification. 
As always we are only concerned
with partial correctness here: a program, $p$,
is then correct if every part of it that has a specification will either
fail to terminate or will satisfy the specification
when $p$. We write
=INLINEFT
%models% p
=TEX
\ when this holds.

πZ
‹ relation %models% _
∞
We can now formally define the relation $(\_ \models \_)$.
In the clause for the syntactic category Spec, note that we insist
that the program does not terminate in states that satisfy the
precondition but make the post-condition unsatisfiable.
πZAX
‹ €%models% _› :  PROG
˜¸¸¸¸¸¸
‹ µt : STATE_TRANSFORMER; pâ1, pâ2 : PROG; c : PRED; s : SPEC∑
‹	(%models% (Atom t))
‹ ±	(%models% (Seq (pâ1, pâ2)) § %models% pâ1 ± %models% pâ2)
‹ ±	(%models% (If(c, pâ1, pâ2)) § %models% pâ1 ± %models% pâ2)
‹ ±	(%models% (While(c, pâ1)) § %models% pâ1)
‹ ±	(%models% (Spec(s, pâ1)) 
‹	§ 	s √ (STATE, semantics pâ1)
‹	±	%models% pâ1)
∞
\subsection{Precondition Calculation}
A pre-condition calculator is a function that takes a program and a post-condition as
its argument and returns a predicate that, we hope, gives the pre-condition for
achieving the post-condition. In practice, such a function might conceptually
be partial, because, for example, there may be atomic statement forms that are
intractable. However, these can always be handled by returning an empty
pre-condition, so we take pre-condition calculators to be total functions.
πZ
‹ €PREC_CALC› ¶ PROG ∏ STATE_TRANSFORMER ≠ PRED
∞
A pre-condition calculator is sound if the pre-condition it returns
for any program and post-condition is such that execution
of the program subject to the pre-condition refines the specification
statement formed from the returned pre-condition and the given post-condition.
πZAX
‹ €sound_prec_calc› : PREC_CALC
˜¸¸¸¸¸¸
‹ µpc : PREC_CALC∑
‹	pc ç sound_prec_calc
‹ §	(µprog : PROG; postc : STATE_TRANSFORMER; prec : PRED
‹	|	prec = pc (prog, postc)
‹	∑	(prec, postc) √ (prec, semantics prog))
∞

The notion of soundness is a purely semantic one: it does not require
those parts of the program that have specifications actually to satisfy
those specifications. The stronger notion of correctness imposes
this requirement. To formulate this for a given program and post-condition,
{\it postc}, say, for which the pre-condition calculator returns the
pre-condition, {\it prec}, say, we take the relation
{\it postc} $\times$ {\it prec} as the specification of the program and
require that the resulting program be correct with respect to this specification
in any state.

πZAX
‹ €correct_prec_calc› : PREC_CALC
˜¸¸¸¸¸¸
‹ µpc : PREC_CALC∑
‹	pc ç correct_prec_calc
‹ §	(µprog : PROG; postc : STATE_TRANSFORMER; prec : PRED
‹	|	prec = pc (prog, postc)
‹	∑	%models% Spec((prec, postc), prog))
∞
We can now formulate the conjecture that correctness for pre-condition calculators is indeed a stronger
notion than soundness.
πZ
‹ correct_prec_calc_sound_cnj ?Ù correct_prec_calc Ä sound_prec_calc
∞

\subsection{Proofs}
=SML
set_goal([], ÒSTATE_TRANSFORMER = UÆ);
a(rewrite_tac(map z_get_spec[ÒSTATEÆ, ÒSTATE_TRANSFORMERÆ, Ò(_™_)Æ]));
val €state_transformer_u_thm› = save_pop_thm "state_transformer_u_thm";
=TEX
=SML
val €state_u_thm› = save_thm("state_u_thm",
	(z_get_spec ÒSTATEÆ));
val €prog_u_thm› = save_thm("prog_u_thm",
	(z_get_spec ÒPROGÆ));
val €pred_u_thm› = save_thm("pred_u_thm",
	rewrite_rule[state_u_thm] (z_get_spec ÒPREDÆ));
val €spec_u_thm› = save_thm("spec_u_thm",
	rewrite_rule[pred_u_thm, state_transformer_u_thm] (z_get_spec ÒSPECÆ));
=TEX
=SML
set_goal([], Òµ sâ1, sâ2 : U∑
	sâ1 √ sâ2
           § sâ1.1 Ä sâ2.1
             ± sâ1.1 ° dom (sâ1.2) Ä dom (sâ2.2)
             ± sâ1.1 Ú sâ2.2 Ä sâ1.2Æ);
a(z_µ_tac);
a(LEMMA_TÒsâ1 = (sâ1.1, sâ1.2) ± sâ2 = (sâ2.1, sâ2.2)Æ pure_once_rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" REPEAT strip_tac);
a(pure_rewrite_tac[rewrite_rule[state_transformer_u_thm, pred_u_thm] (z_get_spec Ò(_√_)Æ)]);
a(rewrite_tac[]);
val €refines_thm› = save_pop_thm "refines_thm";
=TEX
=SML
val €cutdown_thm› = save_thm("cutdown_thm",
	rewrite_rule[state_transformer_u_thm, state_u_thm]
		(z_get_spec Ò(_%downarrow%_)Æ));
=TEX
=SML
set_goal([], Ò
	sound_prec_calc =
	{	pc : PREC_CALC
	|	µ prog : U; postc : U; prec : U
		| prec = pc (prog, postc)
		∑ (prec, postc) √ (prec, semantics prog)}Æ);
a(strip_asm_tac
	(rewrite_rule[prog_u_thm, pred_u_thm, state_transformer_u_thm]
		(z_get_specÒsound_prec_calcÆ)));
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac Òx1 ç PREC_CALCÆ THEN1 PC_T1 "z_library_ext" all_asm_fc_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(ASM_FC_T1 fc_§_canon rewrite_tac[]);
a(POP_ASM_T accept_tac);
val €sound_prec_calc_thm› = save_pop_thm "sound_prec_calc_thm";
=TEX
=SML
set_goal([], Ò
	correct_prec_calc =
	{	pc : PREC_CALC
	|	µ prog : U; postc : U; prec : U
		| prec = pc (prog, postc)
		∑ %models% Spec ((prec, postc), prog)}Æ);
a(strip_asm_tac (rewrite_rule[prog_u_thm, pred_u_thm, state_transformer_u_thm]
	(z_get_specÒcorrect_prec_calcÆ)));
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac Òx1 ç PREC_CALCÆ THEN1 PC_T1 "z_library_ext" all_asm_fc_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(ASM_FC_T1 fc_§_canon rewrite_tac[]);
a(POP_ASM_T accept_tac);
val €correct_prec_calc_thm› = save_pop_thm "correct_prec_calc_thm";
=TEX
=SML
val €correct_thm› = save_thm("correct_thm",
	rewrite_rule[state_transformer_u_thm, spec_u_thm, state_u_thm, prog_u_thm, pred_u_thm]
		(z_get_spec Ò(%models%_)Æ));
=TEX
=SML
set_goal([], get_conjecture "-" "cutdown_clauses_cnj");
a(rewrite_tac[state_transformer_u_thm, state_u_thm, refines_thm, cutdown_thm] THEN
	REPEAT strip_tac
	THEN PC_T1 "z_library_ext" REPEAT strip_tac
	THEN PC_T1 "z_library_ext" asm_prove_tac[]);
a(z_∂_tacÒ{x1}Æ THEN PC_T1 "z_library_ext" asm_prove_tac[]);
val €cutdown_clauses›  = save_pop_thm"cutdown_clauses";
=TEX
=SML
set_goal([], get_conjecture "-" "cutdown_pointwise_cnj");
a(REPEAT strip_tac);
a(rewrite_tac[state_transformer_u_thm, state_u_thm, refines_thm, cutdown_thm] THEN
	PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(z_∂_tacÒ{x1}Æ THEN REPEAT strip_tac);
val €cutdown_pointwise_thm›  = save_pop_thm"cutdown_pointwise_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "correct_prec_calc_sound_cnj");
a(rewrite_tac[correct_prec_calc_thm, sound_prec_calc_thm]);
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN DROP_ASMS_T discard_tac);
a(rewrite_tac[refines_thm, correct_thm]);
a(taut_tac);
val €correct_prec_calc_sound_thm›  = save_pop_thm"correct_prec_calc_sound_thm";
=TEX

\subsection{Epilogue}
=SML
z_output_theory{out_file="refine.th.doc", theory="-"};
=TEX
{\HOLindexOff
\let\Section\subsection
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{refine.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

=TEX

\end{document}
=IGN
