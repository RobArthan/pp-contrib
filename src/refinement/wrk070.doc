=TEX
\documentclass{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\def\Hide#1{\relax}
\title{On Refinement}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\section{A Compliance Notation Example}
\subsection{Package Specification}
=SML
new_script{name = "SUM", state=initial_cn_state};

πCN
package €sum› is
  type €data› is range -1000 .. 1000;
  €acc_neg›, €acc_pos› : data;
  procedure €sum_pos› (x : in data)
  Ñ ACC_NEG, ACC_POS [ ~10 º X º 10,
          X < 0 ± ACC_NEG = ACC_NEGâ0 + X ± ACC_POS = ACC_POSâ0 ≤
          X = 0 ± ACC_NEG = ACC_POS = 0 ≤
          X > 0 ± ACC_POS = ACC_POSâ0 + X ± ACC_NEG = ACC_NEGâ0 ];
end sum;
∞
=TEX
\subsection{Package Body}
=SML
new_script{name = "SUM_BODY", state=get_cn_state()};
πCN
package body €sum› is
  procedure €sum_pos› (x : in data)
  Ñ ACC_NEG, ACC_POS [
          X < 0 ± ACC_NEG = ACC_NEGâ0 + X ± ACC_POS = ACC_POSâ0 ≤
          X = 0 ± ACC_NEG = ACC_POS = 0 ≤
          X > 0 ± ACC_POS = ACC_POSâ0 + X ± ACC_NEG = ACC_NEGâ0]
  is
  begin
    if     x = 0
    then   acc_neg := 0; acc_pos := 0;
    else   Ñ ACC_NEG, ACC_POS [ X Ω 0,
           X Ω 0 ±
          (X < 0 ± ACC_NEG = ACC_NEGâ0 + X ± ACC_POS = ACC_POSâ0 ≤
           X > 0 ± ACC_POS = ACC_POSâ0 + X ± ACC_NEG = ACC_NEGâ0) 	] (else_part)
    end if;
  end sum_pos;
end sum;
∞
πCN
 (else_part) √
        if x <= 0
        then acc_neg := acc_neg + x;
        else acc_pos := acc_pos + x;
        end if;
∞
\Hide{
=SML
set_pc"cn1";
val vcs = rev(map (hd ** snd) (get_conjectures "-"));
fun try_tactic acc tac ((vc as (name, term))::more) = (
	(delete_thm name handle Fail _ => t_thm);
	(save_thm(name, tac_proof(([], term), tac)); try_tactic acc tac more)
	handle Fail _ => try_tactic (vc::acc) tac more
) | try_tactic acc _ [] = rev acc;
val vcs1 = try_tactic []
	(cn_vc_simp_tac[] THEN REPEAT strip_tac) vcs;
val vcs2 = try_tactic []
	(cn_vc_simp_tac[] THEN PC_T1 "z_lin_arith" asm_prove_tac[]) vcs1;
=TEX
}
=SML
output_z_document{script = "SUM", out_file="refine1.zed"};
output_z_document{script = "SUM_BODY", out_file="refine2.zed"};
=TEX
\Hide{
=SH
sed -e '/^$/d' -e '/^[a-zA-Z(]/{
	i\
	=SML
}' < refine1.zed | sed -e '/^	/s/	//' | sieve tex > refine1.zed.tex
sed -e '/^$/d' -e '/^[a-zA-Z(]/{
	i\
	=SML
}' < refine2.zed | sed -e '/^	/s/	//' | sieve tex > refine2.zed.tex
=TEX
}
=IGN
print_z_document "SUM";
print_z_document "SUM_BODY";
=TEX
{\ftlinepenalty=9999
\underscoreoff\subsection{Z Documents}
\input{refine1.zed.tex}
\input{refine2.zed.tex}}
\section{A Z Model}
\subsection{Preamble}
=SML
open_theory"z_library";
force_delete_theory"refinement" handle Fail _ => ();
new_theory"refinement";
ReaderWriterSupport.PrettyNames.add_new_symbols[
	(["refinedby"], Value "√", ReaderWriterSupport.PrettyNames.Simple)
] handle Fail _ => ();
=TEX
\subsection{States and State Transformers}
The internal structure of states is not relevant to our purposes.
We just introduce a given set to represent the states:
πZ
‹ [€STATE›]
∞

A state transformer is just a relation on states:
πZ
‹ €STATE_TRANSFORMER› ¶ STATE ™ STATE
∞
We think of a state transformer $t$ as {\em responding} to a state, the {\em before-state},
$s$ in its domain by non-deterministically selecting some {\em response} or {\em after-state},
which is a state $s'$ such that $(s, s') \in t$.

\subsection{A First Notion of Program}
Our first notion of programs has five syntactic categories:
\begin{description}
\item[Atom:] this comprises some set of primitive operations on the state. In a typical
imperative language, the atoms might be the denotations of assignment statements.
\item[Seq:] sequential composition
\item[If:] if-then-else
\item[While:] while-loop
\item[Spec:] programs with specifications; the specification is a state transformer
that we would like the program to refine. In a notation like the Compliance Notation
the specifications would be the denotations of pre- and post-condition pairs.
\end{description}

Here in a notation like the Compliance Notation, the states will be
assignments of values to program variables.
A pre-conditions is predicate whose free variables are program variables.
A post-condition is a predicate whose free variables are
program variables with optional decoration to distinguish values in the before-state
from values in the after-state.
A pre-condition denotes the set of assignments, $\alpha$, in which the program
variables satisfy the pre-condition and a post-condition denotes
the relation, $\rho$, which holds between two states $s$ and $s'$ when $s \times s'$
satisfies the post-condition after makihng the appropriate binding of before- and after-values
to the variables in the post-condition.
Taken together, we think of the pre- and post-condition as denoting the state transformer
=INLINEFT
¡ Ú “
=TEX
.

A predicate on states is just a set of states, i.e., the denotation of the
usual syntactic notion of a predicate:
πZ
‹ €PREDICATE› ¶ STATE
∞

As discussed above, specifications are just state transformers:
πZ
‹ €SPECIFICATION› ¶ STATE_TRANSFORMER
∞

We can now represent programs abstractly using the following free type, in which we freely
mingle semantic and syntactic domains to simplify later work. We also use a tree
structure rather than a linear list for sequential composition, since that is semantically
harmless, and, again, helps to keep things simple later on.
πZ
‹ €PROGRAM1› ::=
‹	€Atom1› (STATE_TRANSFORMER)
‹ |	€Seq1› (PROGRAM1 ∏ PROGRAM1)
‹ |	€If1› (PREDICATE ∏ PROGRAM1 ∏ PROGRAM1)
‹ |	€While1› (PREDICATE ∏ PROGRAM1)
‹ |	€Spec1› (SPECIFICATION ∏ PROGRAM1)
∞
The following function gives the semantics of this first notion of a program.
The semantic value of a program is a state transformer.
In the semantics, the specifications in the syntactic category Spec are just
ignored --- it is the actual code that determines the semantics, not our aspirations
for it.
πZAX
‹ €semantics1› : PROGRAM1 ≠ STATE_TRANSFORMER
˜¸¸¸¸¸¸
‹ µt : STATE_TRANSFORMER; pâ1, pâ2 : PROGRAM1; c : PREDICATE; s : SPECIFICATION∑
‹	semantics1 (Atom1 t) = t
‹ ±	semantics1 (Seq1 (pâ1, pâ2)) = semantics1 pâ1 ª semantics1 pâ2
‹ ±	semantics1 (If1(c, pâ1, pâ2)) = semantics1 pâ2 ´ (c Ú semantics1 pâ1)
‹ ±	semantics1 (While1(c, pâ1)) = (c Ú semantics1 pâ1)Á*Í Å c
‹ ±	semantics1 (Spec1(s, pâ1)) = semantics1 pâ1
∞
It is in the above that the convenience of dealing with partial correctness
begins to become apparent. The semantics of a while-loop says that the
body of the loop is to be executed repeatedly in states satisfying
the predicate $c$ until a state which does not satisfy $c$ is reached.
If this fails to terminate the result is just the empty relation.
The semantics of total correctness demand
a much more complex representation, but we have no need of that.
\subsection{Refinement}
Refinement is a notion that is fundamental to the notion of program
correctness that we will define; however, it is a semantic notion
that is independent of the syntax of programs.

A state transformer $t_2$ refines another state transformer $t_1$ iff.
the domain of $t_2$ includes that of $t_1$ and every pair $(s, s')$ related
by $t_2$ are also related by $t_2$. The first of these conditions is
the traditional notion of liveness --- it says that $t_2$ is able to
respond in any state that $t_1$ can respond in. The second
condition is the traditional notion of safety --- it says that any response
made by $t_2$ in a state in which $t_1$ could respond
is a response that could also be made by $t_1$.
We write $t_1 \sqsubseteq t2$ to mean that $t_2$ refines $t_1$.
πZ
‹ relation _ √ _
∞

πZAX
‹ €_ √ _› : STATE_TRANSFORMER ™ STATE_TRANSFORMER
˜¸¸¸¸¸¸
‹ µtâ1, tâ2 : STATE_TRANSFORMER∑
‹	tâ1 √ tâ2 § dom tâ1 Ä dom tâ2 ± dom tâ1 Ú tâ2 Ä tâ1
∞

\subsection{Program Correctness}
Intuitively, a program is correct if every part of it that has a specification
satisfies that specification. We relativise this notion to a notion
of correctness with respect to a given set of starting states, identified
by some predicate, $c$. A program, $p$, is then correct with respect to $c$
if every part of it that has a specification will satisfy the specification
when $p$ is started in a state in $c$. We write
=INLINEFT
c %models% p
=TEX
\ when this holds.
πZ
‹ relation _ %models% _
∞
πZAX
‹ €_ %models% _› : PREDICATE ™ PROGRAM1
˜¸¸¸¸¸¸
‹ µt : STATE_TRANSFORMER; pâ1, pâ2 : PROGRAM1; câ1, câ2 : PREDICATE; s : SPECIFICATION∑
‹	(câ1 %models% (Atom1 t))
‹ ±	(câ1 %models% (Seq1 (pâ1, pâ2)) § câ1 %models% pâ1 ± semantics1 pâ1 ®câ1© %models% pâ2)
‹ ±	(câ1 %models% (If1(câ2, pâ1, pâ2)) § câ1 ° câ2 %models% pâ1 ± câ1 \ câ2 %models% pâ2)
‹ ±	(câ1 %models% (While1(câ2, pâ1)) § (câ1 ° dom (semantics1(While1(câ2, pâ1)))) %models% pâ1)
‹ ±	(câ1 %models% (Spec1(s, pâ1)) § câ1 ° dom s %models% pâ1 ± câ1 Ú s √ semantics1 pâ1)
∞

\subsection{Epilogue}
=SML
z_output_theory{out_file="refine.th.doc", theory="-"};
=TEX
{\HOLindexOff
\let\Section\subsection
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{refine.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

=TEX

\end{document}
=IGN
