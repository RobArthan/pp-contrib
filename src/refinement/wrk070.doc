=TEX
\documentclass{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\def\Hide#1{\relax}
\title{On Refinement and Partial Correctness}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\section{Introduction}
This note is a working paper on refinement and partial correctness.
It aims to provide a simple formal model in {\ProductZ}
in which to reason about
refinement notations along the lines of the Compliance Notation.
It is particularly intended to assist with work on handling more
complex control flow than is currently handled in the Compliance Notation.

The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"z_library";
set_pc"z_library1";
force_delete_theory"refinement" handle Fail _ => ();
new_theory"refinement";
ReaderWriterSupport.PrettyNames.add_new_symbols[
	(["refinedby"], Value "√", ReaderWriterSupport.PrettyNames.Simple)
] handle Fail _ => ();
=TEX
\section{States and State Transformers}
The internal structure of states is not relevant to our purposes.
We just introduce a given set to represent the states:
πZ
‹ [€STATE›]
∞

A state transformer is just a relation on states:
πZ
‹ €STATE_TRANSFORMER› ¶ STATE ™ STATE
∞
We think of a state transformer $t$ as {\em responding} to a state, the {\em before-state},
$s$ in its domain by non-deterministically selecting some {\em response} or {\em after-state},
which is a state $s'$ such that $(s, s') \in t$.

\section{A First Notion of Program}
Our first notion of programs has five syntactic categories:

\begin{center}
\begin{tabular}{|l|p{4in}|}\hline
Atom &
This comprises some set of primitive operations on the state. In a typical
imperative language, the atoms might be the denotations of assignment statements
and procedure calls. In the Compliance Notation, the denotation of a procedure
call is represented by an instance of the formal specification appearing
in the procedure header.
\\\hline
Seq &
Sequential composition
\\\hline
If &
If-then-else
\\\hline
While &
While-loop
\\\hline
Spec &
Programs with specifications; the specification is a state transformer
that we would like the program to refine. In a notation like the Compliance Notation
the specifications would be the denotations of pre- and post-condition pairs.
However, it is necessary for to record the pre-condition separately.
\\\hline
\end{tabular}

\end{center}

Here in a notation like the Compliance Notation, the states will be
assignments of values to program variables.
In our model, a predicate on states is just a set of states, i.e., the denotation of the
usual syntactic notion of a predicate:
πZ
‹ €PRED› ¶ STATE
∞

Syntactically, a pre-condition is a predicate whose free variables are program variables and a post-condition is a predicate whose free variables are
program variables with optional decoration to distinguish values in the before-state
from values in the after-state.
A pre-condition denotes the set of assignments, $\alpha$, in which the program
variables satisfy the pre-condition and a post-condition denotes
the relation, $\rho$, which holds between two states $s$ and $s'$ when $s \times s'$
satisfies the post-condition after makihng the appropriate binding of before- and after-values
to the variables in the post-condition.

Taken together, we can often think of the pre- and post-condition as denoting the state transformer
=INLINEFT
¡ Ú “
=TEX
.
However, we lose some expressiveness in doing this, since, for example,
if the post-condition is unsatisfiable, the pre-condition effectively
defines a set of states in which the program must not terminate.
Consequently, we must keep a separate record of the pre-condition. 
So a specification is a pair comprising a predicate giving the pre-condition
and a state transformer giving the post-condition. As we will be making
formal presently, our reading of a specification requires the program
not to terminate in before-states that satisfy the pre-condition but to
which the post-condition cannot respond.
πZ
‹ €SPEC› ¶ PRED ∏ STATE_TRANSFORMER
∞

We can now represent programs abstractly using the following free type, in which we freely
mingle semantic and syntactic concepts to simplify later work. We also use a tree
structure rather than a linear list for sequential composition, since that is semantically
harmless, and, again, helps to keep things simple later on.
πZ
‹ €PROG› ::=
‹	€Atom› (STATE_TRANSFORMER)
‹ |	€Seq› (PROG ∏ PROG)
‹ |	€If› (PRED ∏ PROG ∏ PROG)
‹ |	€While› (PRED ∏ PROG)
‹ |	€Spec› (SPEC ∏ PROG)
∞
The following function gives the semantics of this notion of a program.
The semantic value of a program is a state transformer.
In the semantics, the specifications in the syntactic category Spec are just
ignored --- it is the actual code that determines the semantics, not our aspirations
for it.
πZAX
‹ €semantics› : PROG ≠ STATE_TRANSFORMER
˜¸¸¸¸¸¸
‹ µt : STATE_TRANSFORMER; pâ1, pâ2 : PROG; c : PRED; s : SPEC∑
‹	semantics (Atom t) = t
‹ ±	semantics (Seq (pâ1, pâ2)) = semantics pâ1 ª semantics pâ2
‹ ±	semantics (If(c, pâ1, pâ2)) = semantics pâ2 ´ (c Ú semantics pâ1)
‹ ±	semantics (While(c, pâ1)) = (c Ú semantics pâ1)Á*Í Å c
‹ ±	semantics (Spec(s, pâ1)) = semantics pâ1
∞
It is in the above that the convenience of dealing with partial correctness
begins to become apparent. The semantics of a while-loop says that the
body of the loop is to be executed repeatedly in states satisfying
the predicate $c$ until a state which does not satisfy $c$ is reached.
If this fails to terminate the result is just the empty relation.
The semantics of total correctness demand
a much more complex representation, but we have no need of that.

As a simple check on our definitions and to give a first exercise
in reasoning by induction over the syntax of programs, let us
state as a conjecture the claim that the function on programs
which simply strips out all the specifications is semantics-preserving:
πZ
‹ strip_specs_cnj ?Ù
‹	µ	strip_specs: PROG ≠ PROG
‹	|	µt : STATE_TRANSFORMER; pâ1, pâ2 : PROG; c : PRED; s : SPEC∑
‹		strip_specs (Atom t) = (Atom t)
‹	 ±	strip_specs (Seq (pâ1, pâ2)) = Seq (strip_specs pâ1, strip_specs pâ2)
‹	 ±	strip_specs (If(c, pâ1, pâ2)) = If(c, strip_specs pâ1, strip_specs pâ2)
‹	 ±	strip_specs (While(c, pâ1)) = While(c, strip_specs pâ1)
‹	 ±	strip_specs (Spec(s, pâ1)) = strip_specs pâ1
‹	∑ µp : PROG∑ semantics(strip_specs p) = semantics p
∞

\section{Refinement}
Refinement is a notion that is fundamental to the notion of program
correctness that we will define; however, it is a semantic notion
that is independent of the syntax of programs.
Recall that a specification comprises a predicate, the
pre-condition, and a state transformer, the post-condition.
One specification, 
=INLINEFT
sâ2 = (precâ2, postcâ2)
=TEX
\ refines another
=INLINEFT
sâ1 = (precâ1, postcâ1)
=TEX
\ iff.
=INLINEFT
precâ2
=TEX
\ includes
=INLINEFT
precâ1
=TEX
\ and the restriction of
=INLINEFT
postcâ2
=TEX
\ to
=INLINEFT
precâ1
=TEX
\ is contained in
=INLINEFT
postcâ1
=TEX
.
The first of these conditions is a vestigial analogue of liveness in our partial
correctness view of refinement --- it actually says that $s_2$ may weaken the
pre-condition and so be more specific about its requirements for non-termination.
The second condition is the traditional notion of safety --- it says that any response
made by $s_2$ in a state satisfying the pre-condition of $s_1$
is a response that could also be made by $s_1$ and (partiality, again), this
includes the possibility that $s_2$ may be unable to respond where $s_1$ can.

πZ
‹ relation _ √ _
∞

πZAX
‹ €_ √ _› : SPEC ™ SPEC
˜¸¸¸¸¸¸
‹ µprecâ1, precâ2 : PRED; postcâ1, postcâ2 : STATE_TRANSFORMER∑
‹	(precâ1, postcâ1) √ (precâ2, postcâ2)
‹ §	precâ1 Ä precâ2
‹ ±	precâ1 Ú postcâ2 Ä postcâ1
∞
To check the definitions, we state two simple conjectures about refinement.
The first says that any specification with an empty pre-condition is
chaotic --- it may be refined by any specification:
πZ
‹ chaos_cnj ?Ù µ postc : STATE_TRANSFORMER; s : SPEC∑ (ö, postc) √ s
∞
The secondc conjecture says that when $s_2$ refines $s_1$, then
the post-condition of $s_2$ cannot respond in any 
state in the pre-condition of $s_1$ for which the post-condition of
$s_1$ cannot respond.
πZ
‹ deadlock_cnj ?Ù
‹ µ precâ1, precâ2 : PRED; postcâ1, postcâ2 : STATE_TRANSFORMER∑
‹	(precâ1, postcâ1) √ (precâ2, postcâ2)
‹ ¥	(precâ1 \ dom postcâ1) ° dom postcâ2 = ö
∞


If $t_1$ and $t_2$ are two post-conditions.
The $t_1$ {\em cut-down} of $t_2$ is the largest set of states, $c$ say,
such that $(c, t_2)$ refines $(c, t_1)$.
We write this as $t_1 \downarrow t_2$.

πZ
‹ function 7 _ %downarrow% _
∞
πZAX
‹ €_ %downarrow% _› : STATE_TRANSFORMER ∏ STATE_TRANSFORMER ≠ STATE
˜¸¸¸¸¸¸
‹ µtâ1, tâ2 : STATE_TRANSFORMER∑
‹	tâ1 %downarrow% tâ2 = ﬁ{c : STATE | (c, tâ1) √ (c, tâ2)}
∞
The following conjecture states the main properties of the cut-down.
πZ
‹ cutdown_clauses_cnj ?Ù
‹	µtâ1, tâ2 : STATE_TRANSFORMER∑
‹	(tâ1 %downarrow% tâ2, tâ1) √ (tâ1 %downarrow% tâ2, tâ2)
‹ ±	(µc : STATE | (c, tâ1) √ (c, tâ2) ∑ c Ä tâ1 %downarrow% tâ2)
∞

There are many equivalent ways of formulating the above definition.
The following conjecture records one alternative giving a pointwise
construction.
πZ
‹ cutdown_pointwise_cnj ?Ù
‹	µtâ1, tâ2 : STATE_TRANSFORMER∑
‹	tâ1 %downarrow% tâ2 = {s : STATE | ({s}, tâ1) √ ({s}, tâ2)}
∞
\section{Program Correctness}
Intuitively, a program is correct if every part of it that has a specification
satisfies that specification. We relativise this notion to a notion
of correctness with respect to a given set of starting states, identified
by some predicate, $c$. A program, $p$, is then correct with respect to $c$
if every part of it that has a specification will satisfy the specification
when $p$ is started in a state in $c$. We write
=INLINEFT
c %models% p
=TEX
\ when this holds.
πZ
‹ relation _ %models% _
∞
πZAX
‹ €_ %models% _› : PRED ™ PROG
˜¸¸¸¸¸¸
‹ µt, postc : STATE_TRANSFORMER; pâ1, pâ2 : PROG; câ1, câ2, prec : PRED∑
‹	(câ1 %models% (Atom t))
‹ ±	(câ1 %models% (Seq (pâ1, pâ2)) § câ1 %models% pâ1 ± semantics pâ1 ®câ1© %models% pâ2)
‹ ±	(câ1 %models% (If(câ2, pâ1, pâ2)) § câ1 ° câ2 %models% pâ1 ± câ1 \ câ2 %models% pâ2)
‹ ±	(câ1 %models% (While(câ2, pâ1)) § (câ1 ° câ2) %models% pâ1)
‹ ±	(câ1 %models% (Spec((prec, postc), pâ1))
‹		§ (câ1 ° prec, postc) √ (câ1, semantics pâ1) ± (câ1 ° prec) %models% pâ1)
∞
Any program should be correct with respect to the empty set of starting states:
πZ
‹ empty_correct_cnj ?Ù µprog : PROG∑ ö %models% prog
∞

\section{Precondition Calculation}
A pre-condition calculator is a function that takes a program and a post-condition as
its argument and returns a predicate that, we hope, gives the pre-condition for
achieving the post-condition. In practice, such a function might conceptually
be partial, because, for example, there may be atomic statement forms that are
intractable. However, these can always be handled by returning an empty
pre-condition, so we take pre-condition calculators to be total functions.
πZ
‹ €PREC_CALC› ¶ PROG ∏ STATE_TRANSFORMER ≠ PRED
∞
A pre-condition calculator is sound if the pre-condition it returns
for any program and post-condition is such that execution
of the program subject to the pre-condition refines the specification
statement formed from the returned pre-condition and the given post-condition.
πZAX
‹ €sound_prec_calc› : PREC_CALC
˜¸¸¸¸¸¸
‹ µpc : PREC_CALC∑
‹	pc ç sound_prec_calc
‹ §	(µprog : PROG; postc : STATE_TRANSFORMER; prec : PRED
‹	|	prec = pc (prog, postc)
‹	∑	(prec, postc) √ (prec, semantics prog))
∞

The notion of soundness is a purely semantic one: it does not require
those parts of the program that have specifications actually to satisfy
those specifications. The stronger notion of correctness imposes
this requirement. To formulate this for a given program and post-condition,
{\it postc}, say, for which the pre-condition calculator returns the
pre-condition, {\it prec}, say, we take the pair
{\it (prec, prostc)} as the specification of the program and
require that the resulting program be correct.

πZAX
‹ €correct_prec_calc› : PREC_CALC
˜¸¸¸¸¸¸
‹ µpc : PREC_CALC∑
‹	pc ç correct_prec_calc
‹ §	(µprog : PROG; postc : STATE_TRANSFORMER; prec : PRED
‹	|	prec = pc (prog, postc)
‹	∑	prec %models% Spec((prec, postc), prog))
∞
We can now formulate the (not very deep)
conjecture that correctness for pre-condition calculators is indeed a stronger
notion than soundness.
πZ
‹ correct_prec_calc_sound_cnj ?Ù correct_prec_calc Ä sound_prec_calc
∞
We can also exhibit a correct, but not at all useful, pre-condition calculator,
which simply offers the empty set as a pre-condition which will achieve
any desired post-condition:
πZ
‹ trivial_correct_prec_calc_cnj ?Ù
‹	µ pc : PREC_CALC
‹	|	µprog : PROG; post : STATE_TRANSFORMER∑ pc (prog, post) = ö
‹	∑	pc ç correct_prec_calc
∞

We now give a model of a more useful pre-condition calculator. The description
is a loose one.
πZAX
‹ €prec_calc› : PREC_CALC
˜¸¸¸¸¸¸
‹ µt, postc, postcâ1 : STATE_TRANSFORMER; pâ1, pâ2 : PROG; c, precâ1 : PRED∑
‹
‹	prec_calc (Atom t, postc) = postc %downarrow% t
‹
‹ ± 	prec_calc (Seq (pâ1, pâ2), postc) = ﬁ
‹		{ final : STATE; initial, middle : STATE
‹		| middle = prec_calc(pâ2, STATE ∏ {final})
‹		± initial = prec_calc(pâ1, STATE ∏ middle)
‹		∑ initial ° postcÁ~Í ®{final}© }
‹
‹ ±	prec_calc (If(c, pâ1, pâ2), postc) =
‹		(prec_calc(pâ1, postc) ° c) ¿ (prec_calc(pâ2, postc) \ c)
‹
‹ ±	(∂ bef, aft : PRED
‹	 |	bef = prec_calc(pâ1, STATE ∏ aft)
‹	 ∑	prec_calc (While(c, pâ1), postc) =
‹		{ st : (dom((id STATE) ° postc) \ c) ¿ (bef ° c)
‹		| (dom postc ° c) ∏ (aft \ c) Ä postc})
‹
‹ ±	prec_calc (Spec((precâ1, postcâ1), pâ1), postc) =
‹		 (postc %downarrow% postcâ1) ° precâ1 ° prec_calc(pâ1, postcâ1)
∞
We conjecture that the above is a correct pre-condition calculator:
πZ
‹ correct_prec_calc_cnj ?Ù prec_calc ç correct_prec_calc
∞

\section{Proofs}
=SML
set_goal([], ÒSTATE_TRANSFORMER = UÆ);
a(rewrite_tac(map z_get_spec[ÒSTATEÆ, ÒSTATE_TRANSFORMERÆ, Ò(_™_)Æ]));
val €state_transformer_u_thm› = save_pop_thm "state_transformer_u_thm";
=TEX
=SML
val €state_u_thm› = save_thm("state_u_thm",
	(z_get_spec ÒSTATEÆ));
val €prog_u_thm› = save_thm("prog_u_thm",
	(z_get_spec ÒPROGÆ));
val €pred_u_thm› = save_thm("pred_u_thm",
	rewrite_rule[state_u_thm] (z_get_spec ÒPREDÆ));
val €spec_u_thm› = save_thm("spec_u_thm",
	rewrite_rule[pred_u_thm, state_transformer_u_thm] (z_get_spec ÒSPECÆ));
=TEX
=SML
set_goal([], Òµ sâ1, sâ2 : U∑
	sâ1 √ sâ2
           § sâ1.1 Ä sâ2.1
             ± sâ1.1 Ú sâ2.2 Ä sâ1.2Æ);
a(z_µ_tac);
a(LEMMA_TÒsâ1 = (sâ1.1, sâ1.2) ± sâ2 = (sâ2.1, sâ2.2)Æ pure_once_rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" REPEAT strip_tac);
a(pure_rewrite_tac[rewrite_rule[state_transformer_u_thm, pred_u_thm] (z_get_spec Ò(_√_)Æ)]);
a(rewrite_tac[]);
val €refines_thm› = save_pop_thm "refines_thm";
=TEX
=SML
val €cutdown_thm› = save_thm("cutdown_thm",
	rewrite_rule[state_transformer_u_thm, state_u_thm]
		(z_get_spec Ò(_%downarrow%_)Æ));
=TEX
=SML
set_goal([], Ò
	sound_prec_calc =
	{	pc : PREC_CALC
	|	µ prog : U; postc : U; prec : U
		| prec = pc (prog, postc)
		∑ (prec, postc) √ (prec, semantics prog)}Æ);
a(strip_asm_tac
	(rewrite_rule[prog_u_thm, pred_u_thm, state_transformer_u_thm]
		(z_get_specÒsound_prec_calcÆ)));
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac Òx1 ç PREC_CALCÆ THEN1 PC_T1 "z_library_ext" all_asm_fc_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(ASM_FC_T1 fc_§_canon rewrite_tac[]);
a(POP_ASM_T accept_tac);
val €sound_prec_calc_thm› = save_pop_thm "sound_prec_calc_thm";
=TEX
=SML
set_goal([], Ò
	correct_prec_calc =
	{	pc : PREC_CALC
	|	µ prog : U; postc : U; prec : U
		| prec = pc (prog, postc)
		∑ prec %models% Spec ((prec, postc), prog)}Æ);
a(strip_asm_tac (rewrite_rule[prog_u_thm, pred_u_thm, state_transformer_u_thm]
	(z_get_specÒcorrect_prec_calcÆ)));
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac Òx1 ç PREC_CALCÆ THEN1 PC_T1 "z_library_ext" all_asm_fc_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(ASM_FC_T1 fc_§_canon rewrite_tac[]);
a(POP_ASM_T accept_tac);
val €correct_prec_calc_thm› = save_pop_thm "correct_prec_calc_thm";
=TEX
=SML
val €correct_thm› = save_thm("correct_thm",
	rewrite_rule[state_transformer_u_thm, spec_u_thm, state_u_thm, prog_u_thm, pred_u_thm]
		(z_get_spec Ò(_%models%_)Æ));
=TEX
=SML
val €semantics_thm› = save_thm("semantics_thm",
	rewrite_rule[state_transformer_u_thm, spec_u_thm, state_u_thm, prog_u_thm, pred_u_thm]
		(z_get_spec ÒsemanticsÆ));
=TEX
=SML
val €prec_calc_thm› = save_thm("prec_calc_thm",
	rewrite_rule[state_transformer_u_thm, spec_u_thm, state_u_thm, prog_u_thm, pred_u_thm]
		(z_get_spec Òprec_calcÆ));
=TEX
=SML
set_goal([], ¨
	µp∑
	(µt∑ p ÒAtom tÆ)
±	(µ p1 p2∑ p p1 ± p p2 ¥ p ÒSeq(p1, p2)Æ)
±	(µ c p1 p2∑p p1 ± p p2 ¥ p ÒIf(c, p1, p2)Æ)
±	(µ c p1∑p p1 ¥ p ÒWhile(c, p1)Æ)
±	(µ s p1∑ p p1 ¥ p ÒSpec(s, p1)Æ)
¥	(µ prg∑ p prg)
Æ);
a(REPEAT strip_tac);
a(LEMMA_T Òµprg : U∑ ¨p prgÆÆ rewrite_thm_tac);
let
	val thms = (rev o strip_±_rule o
		rewrite_rule[state_transformer_u_thm, pred_u_thm, prog_u_thm] o
		z_get_spec)ÒAtomÆ;
in
	a(bc_thm_tac ((pc_rule1 "z_library_ext" rewrite_rule[] o
		z_µ_elim Ò{prg:U | ¨p prgÆ}Æ o hd) thms));
	a(MAP_EVERY strip_asm_tac (tl thms))
end;
a(PC_T1 "z_library_ext" REPEAT strip_tac THEN all_fc_tac[z_fun_app_clauses]
	THEN all_var_elim_asm_tac1 THEN1 asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(LEMMA_T Òx = (x.1, x.2)Æ once_rewrite_thm_tac THEN1 PC_T1 "z_library_ext" rewrite_tac[]
	THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T Òx = (x.1, x.2, x.3)Æ once_rewrite_thm_tac THEN1 PC_T1 "z_library_ext" rewrite_tac[]
	THEN ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "3" *** *)
a(LEMMA_T Òx = (x.1, x.2)Æ once_rewrite_thm_tac THEN1 PC_T1 "z_library_ext" rewrite_tac[]
	THEN ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "4" *** *)
a(LEMMA_T Òx = (x.1, x.2)Æ once_rewrite_thm_tac THEN1 PC_T1 "z_library_ext" rewrite_tac[]
	THEN ALL_ASM_FC_T rewrite_tac[]);
val €prog_induction_thm› = save_pop_thm"prog_induction_thm";
=TEX
=SML
val €prog_induction_tac› = gen_induction_tac prog_induction_thm;
=TEX
=SML
set_goal([], get_conjecture "-" "strip_specs_cnj");
a(rewrite_tac[state_transformer_u_thm, prog_u_thm, pred_u_thm, spec_u_thm] THEN
	REPEAT strip_tac);
a(prog_induction_tacÒpÆ THEN asm_rewrite_tac[semantics_thm]);
val strip_specs_thm = save_pop_thm "strip_specs_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "chaos_cnj");
a(rewrite_tac[refines_thm] THEN PC_T1 "z_library_ext" prove_tac[]);
val €chaos_thm›  = save_pop_thm"chaos_thm";
=TEX
=SML
val €chaos_u_thm› = save_thm("chaos_u_thm",
	rewrite_rule[state_transformer_u_thm, spec_u_thm] chaos_thm);
=TEX
=SML
set_goal([], get_conjecture "-" "deadlock_cnj");
a(rewrite_tac[refines_thm] THEN PC_T1 "z_library_ext" prove_tac[]);
val €deadlock_thm›  = save_pop_thm"deadlock_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "cutdown_clauses_cnj");
a(rewrite_tac[state_transformer_u_thm, state_u_thm, refines_thm, cutdown_thm] THEN
	REPEAT strip_tac
	THEN PC_T1 "z_library_ext" REPEAT strip_tac
	THEN PC_T1 "z_library_ext" asm_prove_tac[]);
val €cutdown_clauses›  = save_pop_thm"cutdown_clauses";
=TEX
=SML
val €cutdown_u_clauses›  = save_thm("cutdown_u_clauses",
	rewrite_rule[state_transformer_u_thm, state_u_thm] cutdown_clauses);
=TEX
=SML
set_goal([], get_conjecture "-" "cutdown_pointwise_cnj");
a(REPEAT strip_tac);
a(rewrite_tac[state_transformer_u_thm, state_u_thm, refines_thm, cutdown_thm] THEN
	PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(z_∂_tacÒ{x1}Æ THEN PC_T1 "z_library_ext" asm_prove_tac[]);
val €cutdown_pointwise_thm›  = save_pop_thm"cutdown_pointwise_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "correct_prec_calc_sound_cnj");
a(rewrite_tac[correct_prec_calc_thm, sound_prec_calc_thm]);
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN DROP_ASMS_T discard_tac);
a(rewrite_tac[refines_thm, correct_thm] THEN taut_tac);
val €correct_prec_calc_sound_thm›  = save_pop_thm"correct_prec_calc_sound_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "empty_correct_cnj");
a(rewrite_tac[prog_u_thm] THEN REPEAT strip_tac);
a(prog_induction_tacÒprogÆ THEN_TRY rewrite_tac[correct_thm] THEN REPEAT strip_tac);
a(LEMMA_T Òs = (s.1, s.2)Æ once_rewrite_thm_tac THEN1 PC_T1 "z_library_ext" REPEAT strip_tac);
a(asm_rewrite_tac[correct_thm, chaos_u_thm]);
val €empty_correct_thm›  = save_pop_thm"empty_correct_thm";
=TEX
=SML
val €empty_correct_u_thm› = save_thm("empty_correct_u_thm",
	rewrite_rule[prog_u_thm] empty_correct_thm);
=TEX
=SML
set_goal([], get_conjecture "-" "trivial_correct_prec_calc_cnj");
a(rewrite_tac[prog_u_thm, state_transformer_u_thm]);
a(REPEAT strip_tac THEN asm_rewrite_tac[correct_prec_calc_thm, correct_thm]);
a(REPEAT strip_tac THEN asm_rewrite_tac[chaos_u_thm, empty_correct_u_thm]);
val €trivial_correct_prec_calc_thm›  = save_pop_thm"trivial_correct_prec_calc_thm";
=TEX
=IGN
set_goal([], get_conjecture "-" "correct_prec_calc_cnj");
a(rewrite_tac[correct_prec_calc_thm, prec_calc_thm]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(z_intro_µ_tacÒ(postc¶postc)Æ);
a(prog_induction_tac ÒprogÆ );
(* *** Goal "1" *** *)
a(rewrite_tac[prec_calc_thm, correct_thm, semantics_thm, cutdown_u_clauses]);
(* *** Goal "1" *** *)
a(rewrite_tac[prec_calc_thm, correct_thm, semantics_thm]);

val €correct_prec_calc_thm›  = save_pop_thm"correct_prec_calc_thm";

\section{Epilogue}
=SML
z_output_theory{out_file="refine.th.doc", theory="-"};
=TEX
{\HOLindexOff
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{refine.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

=TEX

\end{document}
=IGN
set_goal([], Ò
	µf: PROG ≠ ˙
	|  µt : STATE_TRANSFORMER; pâ1, pâ2 : PROG; c : PRED; s : SPEC∑
		f (Atom t) = 1
	 ±	f (Seq (pâ1, pâ2)) = f pâ1 + f pâ2 + 1
	 ±	f (If(c, pâ1, pâ2)) = f pâ1 + f pâ2 + 1
	 ±	f (While(c, pâ1)) = f pâ1 + 1
	 ±	f (Spec(s, pâ1)) = f pâ1 + 1
	∑ µp : PROG∑ f p > 0Æ);
a(rewrite_tac[state_transformer_u_thm, prog_u_thm, pred_u_thm, spec_u_thm] THEN
	REPEAT strip_tac);
a(prog_induction_tacÒpÆ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[] THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[] THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "4" *** *)
a(asm_rewrite_tac[] THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "5" *** *)
a(asm_rewrite_tac[] THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val thm1 = pop_thm();
=TEX
=IGN
