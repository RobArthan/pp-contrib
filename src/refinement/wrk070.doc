=TEX
\documentclass{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\def\Hide#1{\relax}
\title{On Refinement and Partial Correctness}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\section{Introduction}
This note is a working paper on refinement and partial correctness.
It aims to provide a simple formal model in {\ProductZ}
in which to reason about
refinement notations along the lines of the Compliance Notation.
It is particularly intended to assist with work on handling more
complex control flow than is currently handled in the Compliance Notation.

The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"z_library";
set_pc"z_library1";
force_delete_theory"refinement" handle Fail _ => ();
new_theory"refinement";
ReaderWriterSupport.PrettyNames.add_new_symbols[
	(["refinedby"], Value "√", ReaderWriterSupport.PrettyNames.Simple)
] handle Fail _ => ();
=TEX
\section{States and State Transformers}
The internal structure of states is not relevant to our purposes.
We just introduce a given set to represent the states:
πZ
‹ [€STATE›]
∞

A state transformer is just a relation on states:
πZ
‹ €STATE_TRANSFORMER› ¶ STATE ™ STATE
∞
{\raggedright
We think of a state transformer $t$ as {\em responding} to a state, the {\em before-state},
$s$ in its domain by non-deterministically selecting some {\em response} or {\em after-state},
which is a state $s'$ such that $(s, s') \in t$.

}
\section{A First Notion of Program}
Our first notion of programs has five syntactic categories:

\begin{center}
\begin{tabular}{|l|p{4in}|}\hline
Atom &
This comprises some set of primitive operations on the state. In a typical
imperative language, the atoms might be the denotations of assignment statements
and procedure calls. In the Compliance Notation, the denotation of a procedure
call is represented by an instance of the formal specification appearing
in the procedure header.
\\\hline
Seq &
Sequential composition
\\\hline
If &
If-then-else
\\\hline
While &
While-loop
\\\hline
Spec &
Programs with specifications; the specification is a state transformer
that we would like the program to refine. In a notation like the Compliance Notation
the specifications would be the denotations of pre- and post-condition pairs.
However, it is necessary for to record the pre-condition separately.
\\\hline
\end{tabular}

\end{center}

Here in a notation like the Compliance Notation, the states will be
assignments of values to program variables.
In our model, a predicate on states is just a set of states, i.e., the denotation of the
usual syntactic notion of a predicate:
πZ
‹ €PRED› ¶ STATE
∞

Syntactically, a pre-condition is a predicate whose free variables are program variables and a post-condition is a predicate whose free variables are
program variables with optional decoration to distinguish values in the before-state
from values in the after-state.
A pre-condition denotes the set of assignments, $\alpha$, in which the program
variables satisfy the pre-condition and a post-condition denotes
the relation, $\rho$, which holds between two states $s$ and $s'$ when $s \times s'$
satisfies the post-condition after makihng the appropriate binding of before- and after-values
to the variables in the post-condition.

Taken together, we can often think of the pre- and post-condition as denoting the state transformer
=INLINEFT
¡ Ú “
=TEX
.
However, we lose some expressiveness in doing this, since, for example,
if the post-condition is unsatisfiable, the pre-condition effectively
defines a set of states in which the program must not terminate.
Consequently, we must keep a separate record of the pre-condition. 
So a specification is a pair comprising a predicate giving the pre-condition
and a state transformer giving the post-condition. As we will be making
formal presently, our reading of a specification requires the program
not to terminate in before-states that satisfy the pre-condition but to
which the post-condition cannot respond.
πZ
‹ €SPEC› ¶ PRED ∏ STATE_TRANSFORMER
∞

We can now represent programs abstractly using the following free type, in which we freely
mingle semantic and syntactic concepts to simplify later work. We also use a tree
structure rather than a linear list for sequential composition, since that is semantically
harmless, and, again, helps to keep things simple later on.
πZ
‹ €PROG› ::=
‹	€Atom› (STATE_TRANSFORMER)
‹ |	€Seq› (PROG ∏ PROG)
‹ |	€If› (PRED ∏ PROG ∏ PROG)
‹ |	€While› (PRED ∏ PROG)
‹ |	€Spec› (SPEC ∏ PROG)
∞
The following function gives the semantics of this notion of a program.
The semantic value of a program is a state transformer.
In the semantics, the specifications in the syntactic category Spec are just
ignored --- it is the actual code that determines the semantics, not our aspirations
for it.
πZAX
‹ €semantics› : PROG ≠ STATE_TRANSFORMER
˜¸¸¸¸¸¸
‹ µt : STATE_TRANSFORMER; pâ1, pâ2 : PROG; c : PRED; s : SPEC∑
‹	semantics (Atom t) = t
‹ ±	semantics (Seq (pâ1, pâ2)) = semantics pâ1 ª semantics pâ2
‹ ±	semantics (If(c, pâ1, pâ2)) = (c Ú semantics pâ1) ¿ (c · semantics pâ2)
‹ ±	semantics (While(c, pâ1)) = (c Ú semantics pâ1)Á*Í Å c
‹ ±	semantics (Spec(s, pâ1)) = semantics pâ1
∞
It is in the above that the convenience of dealing with partial correctness
begins to become apparent. The semantics of a while-loop says that the
body of the loop is to be executed repeatedly in states satisfying
the predicate $c$ until a state which does not satisfy $c$ is reached.
If this fails to terminate the result is just the empty relation.
The semantics of total correctness demand
a much more complex representation, but we have no need of that.

As a simple check on our definitions and to give a first exercise
in reasoning by induction over the syntax of programs, let us
state as a conjecture the claim that the function on programs
which simply strips out all the specifications is semantics-preserving:
πZ
‹ strip_specs_cnj ?Ù
‹	µ	strip_specs: PROG ≠ PROG
‹	|	µt : STATE_TRANSFORMER; pâ1, pâ2 : PROG; c : PRED; s : SPEC∑
‹		strip_specs (Atom t) = (Atom t)
‹	 ±	strip_specs (Seq (pâ1, pâ2)) = Seq (strip_specs pâ1, strip_specs pâ2)
‹	 ±	strip_specs (If(c, pâ1, pâ2)) = If(c, strip_specs pâ1, strip_specs pâ2)
‹	 ±	strip_specs (While(c, pâ1)) = While(c, strip_specs pâ1)
‹	 ±	strip_specs (Spec(s, pâ1)) = strip_specs pâ1
‹	∑ µp : PROG∑ semantics(strip_specs p) = semantics p
∞

\section{Refinement}
Refinement is a notion that is fundamental to the notion of program
correctness that we will define; however, it is a semantic notion
that is independent of the syntax of programs.
Recall that a specification comprises a predicate, the
pre-condition, and a state transformer, the post-condition.
One specification, 
=INLINEFT
sâ2 = (precâ2, postcâ2)
=TEX
\ refines another
=INLINEFT
sâ1 = (precâ1, postcâ1)
=TEX
\ iff.
=INLINEFT
precâ2
=TEX
\ includes
=INLINEFT
precâ1
=TEX
\ and the restriction of
=INLINEFT
postcâ2
=TEX
\ to
=INLINEFT
precâ1
=TEX
\ is contained in
=INLINEFT
postcâ1
=TEX
.
The first of these conditions is a vestigial analogue of liveness in our partial
correctness view of refinement --- it actually says that $s_2$ may weaken the
pre-condition and so be more specific about its requirements for non-termination.
The second condition is the traditional notion of safety --- it says that any response
made by $s_2$ in a state satisfying the pre-condition of $s_1$
is a response that could also be made by $s_1$ and (partiality, again), this
includes the possibility that $s_2$ may be unable to respond where $s_1$ can.

πZ
‹ relation _ √ _
∞

πZAX
‹ €_ √ _› : SPEC ™ SPEC
˜¸¸¸¸¸¸
‹ µprecâ1, precâ2 : PRED; postcâ1, postcâ2 : STATE_TRANSFORMER∑
‹	(precâ1, postcâ1) √ (precâ2, postcâ2)
‹ §	precâ1 Ä precâ2
‹ ±	precâ1 Ú postcâ2 Ä postcâ1
∞
To check the definitions, we state a few simple conjectures about refinement.
The first says that any specification with an empty pre-condition is
chaotic --- it may be refined by any specification:
πZ
‹ chaos_cnj ?Ù µ postc : STATE_TRANSFORMER; s : SPEC∑ (ö, postc) √ s
∞
The second conjecture says that when $s_2$ refines $s_1$, then
the post-condition of $s_2$ cannot respond in any 
state in the pre-condition of $s_1$ for which the post-condition of
$s_1$ cannot respond.
πZ
‹ deadlock_cnj ?Ù
‹ µ precâ1, precâ2 : PRED; postcâ1, postcâ2 : STATE_TRANSFORMER∑
‹	(precâ1, postcâ1) √ (precâ2, postcâ2)
‹ ¥	(precâ1 \ dom postcâ1) ° dom postcâ2 = ö
∞
The ``diamond'' in the next conjecture is the lattice of inclusions
between the four sets $a$, $b$, $c$ and $d$. Only three of the four
inclusions needs to be stated explicitly since the fourth is in
the definition of refinement:
πZ
‹ diamond_refines_cnj ?Ù
‹	µa, b, c, d : PRED; tâ1, tâ2 : STATE_TRANSFORMER∑
‹		a Ä b ± (b, tâ1) √ (d, tâ2)
‹	±	a Ä c Ä d
‹	¥	(a, tâ1) √ (c, tâ2)
∞

\section{Program Correctness}
Intuitively, a program is correct if every part of it that has a specification
satisfies that specification. We relativise this notion to a notion
of correctness with respect to a given set of starting states, identified
by some predicate, $c$. A program, $p$, is then correct with respect to $c$
if every part of it that has a specification will satisfy the specification
when $p$ is started in a state in $c$. We write
=INLINEFT
c %models% p
=TEX
\ when this holds.
πZ
‹ relation _ %models% _
∞
πZAX
‹ €_ %models% _› : PRED ™ PROG
˜¸¸¸¸¸¸
‹ µt, postc : STATE_TRANSFORMER; pâ1, pâ2 : PROG; câ1, câ2, prec : PRED∑
‹	(câ1 %models% (Atom t))
‹ ±	(câ1 %models% (Seq (pâ1, pâ2)) § câ1 %models% pâ1 ± semantics pâ1 ®câ1© %models% pâ2)
‹ ±	(câ1 %models% (If(câ2, pâ1, pâ2)) § câ1 ° câ2 %models% pâ1 ± câ1 \ câ2 %models% pâ2)
‹ ±	(câ1 %models% (While(câ2, pâ1)) § (câ1 ° câ2) %models% pâ1)
‹ ±	(câ1 %models% (Spec((prec, postc), pâ1))
‹		§ (câ1 ° prec, postc) √ (câ1, semantics pâ1) ± (câ1 ° prec) %models% pâ1)
∞
Any program should be correct with respect to the empty set of starting states:
πZ
‹ empty_correct_cnj ?Ù µprog : PROG∑ ö %models% prog
∞
Moreover if a program is correct with respect to some set of starting states
it is also correct with respect to any subset of those states.
πZ
‹ correct_mono_cnj ?Ù
‹	µcâ1, câ2 : PRED; prog : PROG∑ câ1 Ä câ2 ± câ2 %models% prog ¥ câ1 %models% prog
∞

\section{Pre-condition Calculation}
The basic idea pre-condition calculator is a function that takes a program and a 
post-condition as
its argument and returns a predicate that, we hope, gives the pre-condition for
achieves the post-condition.
In practice, such a function might conceptually
be partial, because, for example, there may be atomic statement forms that are
intractable. However, these can always be handled by returning an empty
pre-condition, so we take pre-condition calculators to be total functions.

When one looks into the details of defining a useful pre-condition calculator
one finds that it is a really a post-condition transformer: in order to
give an algorithm that works by recursion over the structure of a program,
one must work with post-conditions, i.e., relations on states, rather than
just states. The domain of all these relations corresponds
as the initial program state throughout the calculation. The calculation
essentially works backwards through the program reversing the effects
of program execution. When one has completed the pre-condition
calculation the range of the resulting relation now corresponds to the
initial program state as well, and one may extract the desired post-condition
by intersecting with the identity relation.

πZ
‹ €PREC_CALC› ¶ PROG ∏ STATE_TRANSFORMER ≠ STATE_TRANSFORMER
∞
In principle, a pre-condition calculator is sound if the pre-condition it returns
for any program and post-condition is such that execution
of the program subject to the pre-condition refines the specification
statement formed from the returned pre-condition and the given post-condition.
In practice, we require a slightly stronger condition which ensures that
pre-condition calculation interacts nicely with sequential composition.

πZAX
‹ €sound_prec_calc› : PREC_CALC
˜¸¸¸¸¸¸
‹ µpc : PREC_CALC∑
‹	pc ç sound_prec_calc
‹ §	(µprog : PROG; postc, postc' : STATE_TRANSFORMER
‹	|	postc = pc(prog, postc')
‹	∑	(dom postc, postc') √ (dom postc, postc ª semantics prog))
∞

We can easily exhibit a sound but not at all useful, pre-condition calculator,
which simply offers the empty set as a pre-condition which will achieve
any desired post-condition:
πZ
‹ trivial_prec_calc_sound_cnj ?Ù
‹	µ pc : PREC_CALC
‹	|	µprog : PROG; post : STATE_TRANSFORMER∑ pc (prog, post) = ö
‹	∑	pc ç sound_prec_calc
∞

We will now give a model of a more useful pre-condition calculator.
The treatment of if-then-else is made more readable using the
following two variants on range restriction and anti-restriction:
πZ
‹ fun 7 _ íâ* _, _ Åâ* _
∞
ù[X, Y]úúúúúúúúúúúúúúúú
‹ _ €íâ*› _ : (X ™ Y) ∏ Y ≠ (X ™ Y);
‹ _ €Åâ*› _ : (X ™ Y) ∏ Y ≠ (X ™ Y)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹µ R : X ™ Y; T :  Y ∑
‹	R íâ* T = {x : X; y : Y | (x, y) ç R ± (µz : Y | (x, z) ç R ∑ z ç T)} ;
‹µ R : X ™ Y; T :  Y ∑
‹	R Åâ* T = {x : X; y : Y | (x, y) ç R ± (µz : Y | (x, z) ç R ∑ z é T)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Now we can define the useful pre-condition calculator.
πZAX
‹ €prec_calc› : PREC_CALC
˜¸¸¸¸¸¸
‹ µt, postc, postcâ1 : STATE_TRANSFORMER; pâ1, pâ2 : PROG; c, precâ1 : PRED∑
‹
‹	prec_calc (Atom t, postc) = {s, s' : STATE | {s'} Ú t Ä {s} Ú postc}
‹
‹ ±	prec_calc (Seq (pâ1, pâ2), postc) = prec_calc(pâ1, prec_calc(pâ2, postc)) 
‹
‹ ±	prec_calc (If(c, pâ1, pâ2), postc) =
‹		(prec_calc(pâ1, postc) íâ* c) ¿ (prec_calc(pâ2, postc) Åâ* c)
‹
‹ ±	(∂ body_postc : STATE_TRANSFORMER; bef, aft : PRED
‹	 |	bef = dom (prec_calc(pâ1, body_postc) ° (id STATE))
‹	 ±	aft = ran body_postc
‹	 ∑	prec_calc (While(c, pâ1), postc) =
‹			postc Å c ¿
‹			{ ss' : dom postc ∏ c
‹			| c Ä bef ± dom postc ∏ (aft \ c) Ä postc })
‹
‹ ±	prec_calc (Spec((precâ1, postcâ1), pâ1), postc) =
‹		{ s : STATE; s' : STATE | {s'} Ú postcâ1 Ä {s} Ú postc } í
‹		(precâ1 ° dom(prec_calc(pâ1, postcâ1) ° (id STATE)))
∞
We conjecture that the above is sound:
πZ
‹ prec_calc_sound_cnj ?Ù prec_calc ç sound_prec_calc
∞
\newpage
\appendix
\section{Proofs}
=TEX
\ftlinepenalty=999
=SML
set_goal([], ÒSTATE_TRANSFORMER = UÆ);
a(rewrite_tac(map z_get_spec[ÒSTATEÆ, ÒSTATE_TRANSFORMERÆ, Ò(_™_)Æ]));
val €state_transformer_u_thm› = save_pop_thm "state_transformer_u_thm";
=TEX
=SML
val €state_u_thm› = save_thm("state_u_thm",
	(z_get_spec ÒSTATEÆ));
val €prog_u_thm› = save_thm("prog_u_thm",
	(z_get_spec ÒPROGÆ));
val €pred_u_thm› = save_thm("pred_u_thm",
	rewrite_rule[state_u_thm] (z_get_spec ÒPREDÆ));
val €spec_u_thm› = save_thm("spec_u_thm",
	rewrite_rule[pred_u_thm, state_transformer_u_thm] (z_get_spec ÒSPECÆ));
=TEX
=SML
set_goal([], Òµ sâ1, sâ2 : U∑
	sâ1 √ sâ2
           § sâ1.1 Ä sâ2.1
             ± sâ1.1 Ú sâ2.2 Ä sâ1.2Æ);
a(z_µ_tac);
a(LEMMA_TÒsâ1 = (sâ1.1, sâ1.2) ± sâ2 = (sâ2.1, sâ2.2)Æ pure_once_rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" REPEAT strip_tac);
a(pure_rewrite_tac[rewrite_rule[state_transformer_u_thm, pred_u_thm] (z_get_spec Ò(_√_)Æ)]);
a(rewrite_tac[]);
val €refines_thm› = save_pop_thm "refines_thm";
=TEX
=SML
set_goal([], Òµ R : U; T : U∑
	R íâ* T = { x : U; y : U | (x, y) ç R ± (µ z : U | (x, z) ç R ∑ z ç T) }Æ);
a(REPEAT strip_tac);
a(rewrite_tac[rewrite_rule[z_™_thm](z_gen_pred_elim[ÒU∫{dom R}Æ, ÒU∫{T}Æ](z_get_specÒ(_íâ*_)Æ))]);
val €strong_rres_thm› = save_pop_thm "strong_rres_thm";
=TEX
=SML
set_goal([], Òµ R : U; T : U∑
	R Åâ* T = { x : U; y : U | (x, y) ç R ± (µ z : U | (x, z) ç R ∑ z é T) }Æ);
a(REPEAT strip_tac);
a(rewrite_tac[rewrite_rule[z_™_thm](z_gen_pred_elim[ÒU∫{dom R}Æ, ÒU∫{T}Æ](z_get_specÒ(_íâ*_)Æ))]);
val €strong_rantires_thm› = save_pop_thm "strong_rantires_thm";
=TEX
=SML
set_goal([], Ò
	sound_prec_calc =
	{	pc : PREC_CALC
	|	µ prog : U; postc, postc' : U
		| postc = pc (prog, postc')
		∑ (dom postc, postc') √ (dom postc, postc ª semantics prog)}Æ);
a(strip_asm_tac
	(rewrite_rule[prog_u_thm, pred_u_thm, state_transformer_u_thm]
		(z_get_specÒsound_prec_calcÆ)));
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac Òx1 ç PREC_CALCÆ THEN1 PC_T1 "z_library_ext" all_asm_fc_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(ASM_FC_T1 fc_§_canon rewrite_tac[]);
a(POP_ASM_T accept_tac);
val €sound_prec_calc_thm› = save_pop_thm "sound_prec_calc_thm";
=TEX
=SML
val €correct_thm› = save_thm("correct_thm",
	rewrite_rule[state_transformer_u_thm, spec_u_thm, state_u_thm, prog_u_thm, pred_u_thm]
		(z_get_spec Ò(_%models%_)Æ));
=TEX
=SML
val €semantics_thm› = save_thm("semantics_thm",
	rewrite_rule[state_transformer_u_thm, spec_u_thm, state_u_thm, prog_u_thm, pred_u_thm]
		(z_get_spec ÒsemanticsÆ));
=TEX
=SML
val €prec_calc_thm› = save_thm("prec_calc_thm",
	rewrite_rule[state_transformer_u_thm, spec_u_thm, state_u_thm, prog_u_thm, pred_u_thm]
		(z_get_spec Òprec_calcÆ));
=TEX
=SML
set_goal([], ¨
	µp∑
	(µt∑ p ÒAtom tÆ)
±	(µ p1 p2∑ p p1 ± p p2 ¥ p ÒSeq(p1, p2)Æ)
±	(µ c p1 p2∑p p1 ± p p2 ¥ p ÒIf(c, p1, p2)Æ)
±	(µ c p1∑p p1 ¥ p ÒWhile(c, p1)Æ)
±	(µ prec postc p1∑ p p1 ¥ p ÒSpec((prec, postc), p1)Æ)
¥	(µ prg∑ p prg)
Æ);
a(REPEAT strip_tac);
a(LEMMA_T Òµprg : U∑ ¨p prgÆÆ rewrite_thm_tac);
let
	val thms = (rev o strip_±_rule o
		rewrite_rule[state_transformer_u_thm, pred_u_thm, prog_u_thm] o
		z_get_spec)ÒAtomÆ;
in
	a(bc_thm_tac ((pc_rule1 "z_library_ext" rewrite_rule[] o
		z_µ_elim Ò{prg:U | ¨p prgÆ}Æ o hd) thms));
	a(MAP_EVERY strip_asm_tac (tl thms))
end;
a(PC_T1 "z_library_ext" REPEAT strip_tac THEN all_fc_tac[z_fun_app_clauses]
	THEN all_var_elim_asm_tac1 THEN1 asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(LEMMA_T Òx = (x.1, x.2)Æ once_rewrite_thm_tac THEN1 PC_T1 "z_library_ext" rewrite_tac[]
	THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T Òx = (x.1, x.2, x.3)Æ once_rewrite_thm_tac THEN1 PC_T1 "z_library_ext" rewrite_tac[]
	THEN ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "3" *** *)
a(LEMMA_T Òx = (x.1, x.2)Æ once_rewrite_thm_tac THEN1 PC_T1 "z_library_ext" rewrite_tac[]
	THEN ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "4" *** *)
a(LEMMA_T Òx = ((x.1.1, x.1.2), x.2)Æ once_rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" rewrite_tac[]
	THEN ALL_ASM_FC_T rewrite_tac[]);
val €prog_induction_thm› = save_pop_thm"prog_induction_thm";
=TEX
=SML
val €prog_induction_tac› = gen_induction_tac prog_induction_thm;
=TEX
=SML
set_goal([], get_conjecture "-" "strip_specs_cnj");
a(rewrite_tac[state_transformer_u_thm, prog_u_thm, pred_u_thm, spec_u_thm] THEN
	REPEAT strip_tac);
a(prog_induction_tacÒpÆ THEN asm_rewrite_tac[semantics_thm]);
val strip_specs_thm = save_pop_thm "strip_specs_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "chaos_cnj");
a(rewrite_tac[refines_thm] THEN PC_T1 "z_library_ext" prove_tac[]);
val €chaos_thm›  = save_pop_thm"chaos_thm";
=TEX
=SML
val €chaos_u_thm› = save_thm("chaos_u_thm",
	rewrite_rule[state_transformer_u_thm, spec_u_thm] chaos_thm);
=TEX
=SML
set_goal([], get_conjecture "-" "deadlock_cnj");
a(rewrite_tac[refines_thm] THEN PC_T1 "z_library_ext" prove_tac[]);
val €deadlock_thm›  = save_pop_thm"deadlock_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "empty_correct_cnj");
a(rewrite_tac[prog_u_thm] THEN REPEAT strip_tac);
a(prog_induction_tacÒprogÆ THEN_TRY rewrite_tac[correct_thm] THEN REPEAT strip_tac);
a(asm_rewrite_tac[correct_thm, chaos_u_thm]);
val €empty_correct_thm›  = save_pop_thm"empty_correct_thm";
=TEX
The following is a special case of the diamond theorem and may turn out not
be needed.
=SML
set_goal([], Òµprecâ1, precâ2 : PRED; postc : STATE_TRANSFORMER; s : SPEC∑
	(precâ2, postc) √ s ± precâ1 Ä precâ2 ¥ (precâ1, postc) √ sÆ);
a(rewrite_tac[refines_thm] THEN PC_T1 "z_library_ext" prove_tac[]);
val €refines_mono_thm›  = save_pop_thm"refines_mono_thm";
val €refines_mono_u_thm›  = save_thm(
	"refines_mono_u_thm",
	rewrite_rule[pred_u_thm, state_transformer_u_thm, spec_u_thm] refines_mono_thm);
=TEX
=SML
set_goal([], get_conjecture "-" "diamond_refines_cnj");
a(rewrite_tac[refines_thm] THEN PC_T1 "z_library_ext" prove_tac[]);
val €diamond_refines_thm›  = save_pop_thm"diamond_refines_thm";
val €diamond_refines_u_thm›  = save_thm("diamond_refines_u_thm",
	rewrite_rule[pred_u_thm, state_transformer_u_thm, spec_u_thm] diamond_refines_thm);
=TEX
=SML
set_goal([], get_conjecture "-" "correct_mono_cnj");
a(rewrite_tac[prog_u_thm, pred_u_thm] THEN REPEAT_UNTIL is_¥ strip_tac);
a(z_intro_µ_tac Ò(c1¶câ1, c2¶câ2)Æ);
a(prog_induction_tacÒprogÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[correct_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[correct_thm]);
a(REPEAT strip_tac THEN1 all_asm_fc_tac[]);
a(lemma_tacÒsemantics p1 ® c1 © Ä semantics p1 ® c2 ©Æ THEN1
	PC_T1 "z_library_ext" asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(rewrite_tac[correct_thm] THEN REPEAT_UNTIL is_± strip_tac);
a(lemma_tacÒc1 ° c Ä c2 ° c ± c1 \ c  Ä c2 \ cÆ THEN1
	PC_T1 "z_library_ext" asm_prove_tac[]);
a(all_asm_fc_tac[] THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(rewrite_tac[correct_thm] THEN REPEAT strip_tac);
a(lemma_tacÒc1 ° c Ä c2 ° cÆ THEN1
	PC_T1 "z_library_ext" asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "5" *** *)
a(rewrite_tac[correct_thm] THEN REPEAT strip_tac);
(* *** Goal "5.1" *** *)
a(lemma_tacÒc1 ° prec Ä c2 ° prec ± c1 ° prec Ä c1Æ THEN1
	PC_T1 "z_library_ext" asm_prove_tac[]);
a(all_fc_tac[diamond_refines_u_thm]);
(* *** Goal "5.2" *** *)
a(lemma_tacÒc1 ° prec Ä c2 ° precÆ THEN1
	PC_T1 "z_library_ext" asm_prove_tac[]);
a(all_asm_fc_tac[]);
val €correct_mono_thm›  = save_pop_thm"correct_mono_thm";
=TEX
=SML
val €correct_mono_u_thm› = save_thm("correct_mono_u_thm",
	rewrite_rule[pred_u_thm, prog_u_thm] correct_mono_thm);
=TEX
=SML
val €empty_correct_u_thm› = save_thm("empty_correct_u_thm",
	rewrite_rule[prog_u_thm] empty_correct_thm);
=TEX
=SML
set_goal([], get_conjecture "-" "trivial_prec_calc_sound_cnj");
a(rewrite_tac[prog_u_thm, state_transformer_u_thm]);
a(REPEAT strip_tac THEN asm_rewrite_tac[sound_prec_calc_thm]);
a(REPEAT strip_tac THEN asm_rewrite_tac[chaos_u_thm, empty_correct_u_thm]);
val €trivial_correct_prec_calc_thm›  = save_pop_thm"trivial_correct_prec_calc_thm";
=TEX
=SML
set_goal([], Ò
	µ R:U; c:U; x, y:U
	| (x, y) ç (c Ú R)Á*Í Å c
	∑ y é c ± (y = x ≤ x ç c ± (∂z:U∑z ç c ± (z, y) ç R))
Æ);
a(rewrite_tac[z_reflex_trans_closure_thm] THEN PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 3 Ò{a, b : U | a = b ≤ a ç c}Æ
	THEN PC_T1"z_library_ext" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 3 Ò{a, b, z : U | a = b ≤ z ç c ± (z, b) ç R∑(a, b)}Æ
	THEN PC_T1"z_library_ext" asm_prove_tac[]);
val €while_lemma›  = save_pop_thm"while_lemma";
=TEX
=SML
set_goal([], get_conjecture "-" "prec_calc_sound_cnj");
a(rewrite_tac[sound_prec_calc_thm, prec_calc_thm]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(z_intro_µ_tacÒ(postc'¶postc')Æ);
a(prog_induction_tac ÒprogÆ);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" rewrite_tac[prec_calc_thm, semantics_thm, refines_thm]);
a(PC_T1 "z_library_ext" REPEAT strip_tac);
a(z_spec_nth_asm_tac 2 Ò(x1'¶y, x2¶x2)Æ THEN_TRY all_var_elim_asm_tac);
(* *** Goal "1.1" *** *)
a(z_spec_nth_asm_tac 3 Ò(x1'¶y', x2¶x2)Æ THEN all_var_elim_asm_tac);
(* *** Goal "1.2" *** *)
a(z_spec_nth_asm_tac 3 Ò(x1'¶y', x2¶x2)Æ THEN all_var_elim_asm_tac);
(* *** Goal "2" *** *)
a(all_asm_ante_tac THEN rewrite_tac[prec_calc_thm, semantics_thm, refines_thm]
	THEN REPEAT strip_tac);
a(z_spec_nth_asm_tac 2 Òprec_calc (p2, postc')Æ THEN POP_ASM_T ante_tac);
a(z_spec_nth_asm_tac 1 Òpostc'Æ THEN DROP_ASMS_T (ante_tac o hd));
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "3" *** *)
a(all_asm_ante_tac THEN rewrite_tac[prec_calc_thm, semantics_thm, refines_thm]
	THEN REPEAT strip_tac);
a(z_spec_nth_asm_tac 2 Òpostc'Æ THEN POP_ASM_T ante_tac);
a(z_spec_nth_asm_tac 1 Òpostc'Æ THEN DROP_ASMS_T (ante_tac o hd));
a(rewrite_tac[strong_rres_thm, strong_rantires_thm] THEN
	PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "4" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(nth 3 (strip_±_rule(rewrite_rule[](z_µ_elimÒ
	(t¶postc', postc¶postc',
	postcâ1¶postc', pâ1¶p1,
	pâ2¶p1, c¶c, precâ1¶c)Æ(±_right_elim prec_calc_thm))))) THEN asm_rewrite_tac[]);
a(POP_ASM_T discard_tac THEN all_var_elim_asm_tac1);
a(z_spec_nth_asm_tac 1 Òbody_postcÆ THEN DROP_ASMS_T (ante_tac o hd));
a(rewrite_tac[semantics_thm, refines_thm] THEN REPEAT strip_tac);
a(REPEAT_N 4 (PC_T1 "z_library_ext" once_rewrite_tac[]) THEN REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(lemma_tacÒ≥y' ç cÆ THEN1 PC_T1 "z_library_ext" asm_prove_tac[]);
a(fc_tac[while_lemma] THEN PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "4.2" *** *)
a(fc_tac[while_lemma] THEN_TRY all_var_elim_asm_tac);
a(lemma_tacÒz ç dom (prec_calc (p1, body_postc) ° (id _))Æ THEN1
	(LIST_GET_NTH_ASM_T [3, 6] (MAP_EVERY ante_tac) THEN
	PC_T1 "z_library_ext" prove_tac[]));
a(lemma_tacÒ(z, z) ç prec_calc (p1, body_postc)Æ THEN1
	(LIST_GET_NTH_ASM_T [1] (MAP_EVERY ante_tac) THEN
	PC_T1 "z_library_ext" prove_tac[]));
a(rename_tac[(ÒyÆ, "yy")] THEN lemma_tacÒ(z, x2) ç body_postcÆ THEN1
	(LIST_GET_NTH_ASM_T [1, 4, 12] (MAP_EVERY ante_tac) THEN
		PC_T1 "z_library_ext" prove_tac[]));
a(LIST_GET_NTH_ASM_T [1, 4, 8, 11] (MAP_EVERY ante_tac) THEN
		PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "4.3" *** *)
a(rename_tac[(ÒyÆ, "yy")] THEN lemma_tacÒ≥y' ç cÆ THEN1
	PC_T1 "z_library_ext" asm_prove_tac[]);
a(fc_tac[while_lemma] THEN PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "4.4" *** *)
a(fc_tac[while_lemma] THEN_TRY all_var_elim_asm_tac);
a(lemma_tacÒz ç dom (prec_calc (p1, body_postc) ° (id _))Æ THEN1
	(LIST_GET_NTH_ASM_T [3, 7] (MAP_EVERY ante_tac) THEN
	PC_T1 "z_library_ext" prove_tac[]));
a(lemma_tacÒ(z, z) ç prec_calc (p1, body_postc)Æ THEN1
	(LIST_GET_NTH_ASM_T [1] (MAP_EVERY ante_tac) THEN
	PC_T1 "z_library_ext" prove_tac[]));
a(rename_tac[(ÒyÆ, "yy")] THEN lemma_tacÒ(z, x2) ç body_postcÆ THEN1
	(LIST_GET_NTH_ASM_T [1, 4, 12] (MAP_EVERY ante_tac) THEN
		PC_T1 "z_library_ext" prove_tac[]));
a(LIST_GET_NTH_ASM_T [1, 4, 9, 12] (MAP_EVERY ante_tac) THEN
		PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "5" *** *)
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 1 ÒpostcÆ THEN DROP_ASMS_T (ante_tac o hd));
a(rewrite_tac[prec_calc_thm, semantics_thm, refines_thm]);
a(PC_T1 "z_library_ext" REPEAT strip_tac THEN all_var_elim_asm_tac);
a(lemma_tacÒ(y''', x2) ç postcÆ THEN1
	(LIST_GET_NTH_ASM_T [1, 2, 8] (MAP_EVERY ante_tac) THEN
	PC_T1 "z_library_ext" prove_tac[]));
a(PC_T1 "z_library_ext" (z_spec_nth_asm_tac 5) Ò(x2¶y''', x3¶x2)Æ
	THEN all_var_elim_asm_tac);
val €prec_calc_sound_thm›  = save_pop_thm"prec_calc_sound_thm";
=TEX
\section{Epilogue}
=SML
z_output_theory{out_file="refine.th.doc", theory="-"};
=TEX
{\HOLindexOff
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{refine.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

=TEX

\end{document}
=IGN
