=TEX
\documentclass[12pt]{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\def\Hide#1{\relax}
\title{On Refinement and Partial Correctness}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\section{Introduction}
This note is a working paper on refinement and partial correctness.
It aims to provide a simple formal model in {\ProductZ}
in which to reason about
refinement notations along the lines of the Compliance Notation.
It is particularly intended to assist with work on handling more
complex control flow than is currently handled in the Compliance Notation.

The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"z_library";
set_pc"z_library1";
force_delete_theory"refinement" handle Fail _ => ();
new_theory"refinement";
ReaderWriterSupport.PrettyNames.add_new_symbols[
	(["refinedby"], Value "√", ReaderWriterSupport.PrettyNames.Simple)
] handle Fail _ => ();
=TEX
\section{States and State Transformers}
The internal structure of states is not relevant to our purposes.
We just introduce a given set to represent the states:
πZ
‹ [€STATE›]
∞

A state transformer is just a relation on states:
πZ
‹ €STATE_TRANSFORMER› ¶ STATE ™ STATE
∞
{\raggedright
We think of a state transformer $t$ as {\em responding} to a state, the {\em before-state},
$s$ in its domain by non-deterministically selecting some {\em response} or {\em after-state},
which is a state $s'$ such that $(s, s') \in t$.

}
\section{A First Notion of Program}
Our first notion of programs has five syntactic categories:

\begin{center}
\begin{tabular}{|l|p{4in}|}\hline
Atom &
This comprises some set of primitive operations on the state. In a typical
imperative language, the atoms might be the denotations of assignment statements
and procedure calls. In the Compliance Notation, the denotation of a procedure
call is represented by an instance of the formal specification appearing
in the procedure header.
\\\hline
Seq &
Sequential composition
\\\hline
If &
If-then-else
\\\hline
While &
While-loop
\\\hline
Spec &
Programs with specifications; the specification is a state transformer
that we would like the program to refine. In a notation like the Compliance Notation
the specifications would be the denotations of pre- and post-condition pairs.
However, it is necessary for to record the pre-condition separately.
\\\hline
\end{tabular}

\end{center}

Here in a notation like the Compliance Notation, the states will be
assignments of values to program variables.
In our model, a predicate on states is just a set of states, i.e., the denotation of the
usual syntactic notion of a predicate:
πZ
‹ €PRED› ¶ STATE
∞

Syntactically, a pre-condition is a predicate whose free variables are program variables and a post-condition is a predicate whose free variables are
program variables with optional decoration to distinguish values in the before-state
from values in the after-state.
A pre-condition denotes the set of assignments, $\alpha$, in which the program
variables satisfy the pre-condition and a post-condition denotes
the relation, $\rho$, which holds between two states $s$ and $s'$ when $s \times s'$
satisfies the post-condition after makihng the appropriate binding of before- and after-values
to the variables in the post-condition.

Taken together, we can often think of the pre- and post-condition as denoting the state transformer
=INLINEFT
¡ Ú “
=TEX
.
However, we lose some expressiveness in doing this, since, for example,
if the post-condition is unsatisfiable, the pre-condition effectively
defines a set of states in which the program must not terminate.
Consequently, we must keep a separate record of the pre-condition. 
So a specification is a pair comprising a predicate giving the pre-condition
and a state transformer giving the post-condition. As we will be making
formal presently, our reading of a specification requires the program
not to terminate in before-states that satisfy the pre-condition but to
which the post-condition cannot respond.
πZ
‹ €PRE_COND› ¶ PRED
∞
πZ
‹ €POST_COND› ¶ STATE ™ STATE
∞
πZ
‹ €SPEC› ¶ PRE_COND ∏ POST_COND
∞

We can now represent programs abstractly using the following free type, in which we freely
mingle semantic and syntactic concepts to simplify later work. We also use a tree
structure rather than a linear list for sequential composition, since that is semantically
harmless, and, again, helps to keep things simple later on.
πZ
‹ €PROG› ::=
‹	€Atom› (STATE_TRANSFORMER)
‹ |	€Seq› (PROG ∏ PROG)
‹ |	€If› (PRED ∏ PROG ∏ PROG)
‹ |	€While› (PRED ∏ PROG)
‹ |	€Spec› (SPEC ∏ PROG)
∞
The following function gives the semantics of this notion of a program.
The semantic value of a program is a state transformer.
In the semantics, the specifications in the syntactic category Spec are just
ignored --- it is the actual code that determines the semantics, not our aspirations
for it.
πZAX
‹ €semantics› : PROG ≠ STATE_TRANSFORMER
˜¸¸¸¸¸¸
‹ µt : STATE_TRANSFORMER; pâ1, pâ2 : PROG; c : PRED; s : SPEC∑
‹	semantics (Atom t) = t
‹ ±	semantics (Seq (pâ1, pâ2)) = semantics pâ1 ª semantics pâ2
‹ ±	semantics (If(c, pâ1, pâ2)) = (c Ú semantics pâ1) ¿ (c · semantics pâ2)
‹ ±	semantics (While(c, pâ1)) = (c Ú semantics pâ1)Á*Í Å c
‹ ±	semantics (Spec(s, pâ1)) = semantics pâ1
∞
It is in the above that the convenience of dealing with partial correctness
begins to become apparent. The semantics of a while-loop says that the
body of the loop is to be executed repeatedly in states satisfying
the predicate $c$ until a state which does not satisfy $c$ is reached.
If this fails to terminate the result is just the empty relation.
The semantics of total correctness demand
a much more complex representation, but we have no need of that.

As a simple check on our definitions and to give a first exercise
in reasoning by induction over the syntax of programs, let us
state as a conjecture the claim that the function on programs
which simply strips out all the specifications is semantics-preserving:
πZ
‹ strip_specs_cnj ?Ù
‹	µ	strip_specs: PROG ≠ PROG
‹	|	µt : STATE_TRANSFORMER; pâ1, pâ2 : PROG; c : PRED; s : SPEC∑
‹		strip_specs (Atom t) = (Atom t)
‹	 ±	strip_specs (Seq (pâ1, pâ2)) = Seq (strip_specs pâ1, strip_specs pâ2)
‹	 ±	strip_specs (If(c, pâ1, pâ2)) = If(c, strip_specs pâ1, strip_specs pâ2)
‹	 ±	strip_specs (While(c, pâ1)) = While(c, strip_specs pâ1)
‹	 ±	strip_specs (Spec(s, pâ1)) = strip_specs pâ1
‹	∑ µp : PROG∑ semantics(strip_specs p) = semantics p
∞

\section{Refinement}
Refinement is a notion that is fundamental to the notion of program
correctness that we will define; however, it is a semantic notion
that is independent of the syntax of programs.
Recall that a specification comprises a predicate, the
pre-condition, and a state transformer, the post-condition.
One specification, 
=INLINEFT
sâ2 = (precâ2, postcâ2)
=TEX
\ refines another
=INLINEFT
sâ1 = (precâ1, postcâ1)
=TEX
\ iff.
=INLINEFT
precâ2
=TEX
\ includes
=INLINEFT
precâ1
=TEX
\ and the restriction of
=INLINEFT
postcâ2
=TEX
\ to
=INLINEFT
precâ1
=TEX
\ is contained in
=INLINEFT
postcâ1
=TEX
.
The first of these conditions is a vestigial analogue of liveness in our partial
correctness view of refinement --- it actually says that $s_2$ may weaken the
pre-condition and so be more specific about its requirements for non-termination.
The second condition is the traditional notion of safety --- it says that any response
made by $s_2$ in a state satisfying the pre-condition of $s_1$
is a response that could also be made by $s_1$ and (partiality, again), this
includes the possibility that $s_2$ may be unable to respond where $s_1$ can.

πZ
‹ relation _ √ _
∞

πZAX
‹ €_ √ _› : SPEC ™ SPEC
˜¸¸¸¸¸¸
‹ µprecâ1, precâ2 : PRE_COND; postcâ1, postcâ2 : POST_COND∑
‹	(precâ1, postcâ1) √ (precâ2, postcâ2)
‹ §	precâ1 Ä precâ2
‹ ±	precâ1 Ú postcâ2 Ä postcâ1
∞
To check the definitions, we state a few simple conjectures about refinement.
The first says that any specification with an empty pre-condition is
chaotic --- it may be refined by any specification:
πZ
‹ chaos_cnj ?Ù µ postc : POST_COND; s : SPEC∑ (ö, postc) √ s
∞
The second conjecture says that when $s_2$ refines $s_1$, then
the post-condition of $s_2$ cannot respond in any 
state in the pre-condition of $s_1$ for which the post-condition of
$s_1$ cannot respond.
πZ
‹ deadlock_cnj ?Ù
‹ µ precâ1, precâ2 : PRE_COND; postcâ1, postcâ2 : POST_COND∑
‹	(precâ1, postcâ1) √ (precâ2, postcâ2)
‹ ¥	(precâ1 \ dom postcâ1) ° dom postcâ2 = ö
∞
The ``diamond'' in the next conjecture is the lattice of inclusions
between the four sets $a$, $b$, $c$ and $d$. Only three of the four
inclusions needs to be stated explicitly since the fourth is in
the definition of refinement:
πZ
‹ diamond_refines_cnj ?Ù
‹	µa, b, c, d : PRE_COND; tâ1, tâ2 : POST_COND∑
‹		a Ä b ± (b, tâ1) √ (d, tâ2)
‹	±	a Ä c Ä d
‹	¥	(a, tâ1) √ (c, tâ2)
∞

\section{Program Correctness}
For a program to be correct every part of it that has a specification
must satisfy that specification. We write
=INLINEFT
p %models% s
=TEX
\ to mean that program $p$ satisfies specification £s£.
πZ
‹ relation _ %models% _
∞
πZAX
‹ €_ %models% _› : PROG ™ SPEC
˜¸¸¸¸¸¸
‹ µ prog : PROG; prec : PRE_COND; postc : POST_COND ∑
‹	prog %models% (prec, postc) § (prec, postc) √ (prec, semantics prog)
∞

However, correctness also requires the pre-condition of each specification
in the program to be satisfied whenever the relevant part of the program
is executed.
if $p$ is a program and $c$ is a set of states, we write $p \perp c$,
if no pre-condition in $p$ will be violated when $p$ is executed in
a starting state in $c$.
For the want of a better name, we will say that $p$ is {\em upright} on $c$.

πZ
‹ relation _ ‚ _
∞

πZAX
‹ €_ ‚ _› : PROG ™ PRED
˜¸¸¸¸¸¸
‹ µt : STATE_TRANSFORMER; postc : POST_COND; pâ1, pâ2 : PROG;
‹  câ1, câ2, prec : PRE_COND∑
‹	((Atom t) ‚ câ1)
‹ ±	((Seq (pâ1, pâ2) ‚ câ1) § pâ1 ‚ câ1 ± pâ2 ‚ semantics pâ1 ®câ1©)
‹ ±	((If(câ2, pâ1, pâ2) ‚ câ1) § pâ1 ‚ câ1 ° câ2 ± pâ2 ‚ câ1 \ câ2)
‹ ±	((While(câ2, pâ1) ‚ câ1) § pâ1 ‚ (câ1 ° câ2))
‹ ±	((Spec((prec, postc), pâ1) ‚ câ1) § (câ1 Ä prec ± pâ1 ‚ câ1))
∞
Uprightness enjoys the following two useful properties:
πZ
‹ upright_mono_cnj ?Ù
‹	µ prog : PROG; câ1, câ2 : PRED∑
‹		prog ‚ câ1
‹	±	câ2 Ä câ1
‹	¥	prog ‚ câ2
∞
πZ
‹ upright_cup_cnj ?Ù
‹	µ prog : PROG; câ1, câ2 : PRED∑
‹		prog ‚ câ1
‹	±	prog ‚ câ2
‹	¥	prog ‚ câ1 ¿ câ2
∞

\section{Pre-condition Calculation}
The simplest idea of a pre-condition calculator is a function that takes a program and a 
post-condition as
its argument and returns a predicate that, we hope, gives the pre-condition for
achieves the post-condition.

When one looks into the details of defining a useful pre-condition calculator
one finds that it is a really a post-condition transformer: in order to
give an algorithm that works by recursion over the structure of a program,
one must work with post-conditions, i.e., relations on states, rather than
just states. The domain of all these relations corresponds
to an appropriate initial program state throughout the calculation. The calculation
essentially works backwards through the program reversing the effects
of program execution. 
πZ
‹ €PREC_CALC› ¶ PROG ∏ POST_COND ≠ POST_COND
∞
In principle, a pre-condition calculator is sound if the pre-condition it returns
for any program and post-condition is such that execution
of the program subject to the pre-condition refines the specification
statement formed from the returned pre-condition and the given post-condition.
In practice, we require a slightly stronger condition which ensures that
pre-condition calculation interacts nicely with sequential composition.

πZAX
‹ €sound_prec_calc› : PREC_CALC
˜¸¸¸¸¸¸
‹ µpc : PREC_CALC∑
‹	pc ç sound_prec_calc
‹ §	(µprog : PROG; postc, postc' : POST_COND
‹	|	postc = pc(prog, postc')
‹	∑	(dom postc, postc') √ (dom postc, postc ª semantics prog))
∞
When one has completed the pre-condition
calculation the range of the resulting relation now corresponds to the
initial program state as well, and one may extract the desired post-condition
by intersecting with the identity relation.
Using this idea, we can formulate, the (not very deep) conjecture that
if the program has a specification at the top level and if the calculated
pre-condition contains the pre-condition of the specification, then
the program satisfies the specification:
πZ
‹ prec_calc_sat_cnj ?Ù
‹	µ pc : PREC_CALC; c_prec, s_prec: PRE_COND;
‹	  s_postc : POST_COND; p : PROG
‹	|	pc ç sound_prec_calc
‹	±	c_prec = dom (pc(Spec((s_prec, s_postc), p), s_postc) ° (id STATE))
‹	±	s_prec Ä c_prec
‹	∑	p %models% (s_prec, s_postc)
∞

We can easily exhibit a sound but not at all useful, pre-condition calculator,
which simply offers the empty set as a pre-condition which will achieve
any desired post-condition:
πZ
‹ trivial_prec_calc_sound_cnj ?Ù
‹	µ pc : PREC_CALC
‹	|	µprog : PROG; postc : POST_COND∑ pc (prog, postc) = ö
‹	∑	pc ç sound_prec_calc
∞

We will now give a model of a more useful pre-condition calculator.
There are some preliminaries to take care of:
the treatment of if-then-else is made more readable using the
following two variants on the theme of range restriction and
range anti-restriction:
πZ
‹ fun 7 _ íâ* _, _ Åâ* _
∞
ù[X, Y]úúúúúúúúúúúúúúúú
‹ _ €íâ*› _ : (X ™ Y) ∏ Y ≠ (X ™ Y);
‹ _ €Åâ*› _ : (X ™ Y) ∏ Y ≠ (X ™ Y)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹µ R : X ™ Y; T :  Y ∑
‹	R íâ* T = {x : X; y : Y | (x, y) ç R ± (µz : Y | (x, z) ç R ∑ z ç T)} ;
‹µ R : X ™ Y; T :  Y ∑
‹	R Åâ* T = {x : X; y : Y | (x, y) ç R ± (µz : Y | (x, z) ç R ∑ z é T)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
The useful pre-condition calculator will use a heuristic to propose
a specification for the body of a while-loop. The following loose specification
suggests how this is done in the Compliance Notation, which actually insists
syntactically that the body of a loop be given as a specification statement.
The soundness of the pre-condition calculator is independent of
the heuristic --- it has to be, because as the following definition shows,
one possibility is that the specification is just taken from the program.
πZAX
‹ €guess_spec› : PROG ≠ SPEC
˜¸¸¸¸¸¸
‹ µs : SPEC; p : PROG ∑ guess_spec(Spec(s, p)) = s
∞
Now we can define the useful pre-condition calculator.
πZAX
‹ €prec_calc› : PREC_CALC
˜¸¸¸¸¸¸
‹ µt : STATE_TRANSFORMER; postc, postcâ1 : POST_COND;
‹  pâ1, pâ2 : PROG; c : PRED;
‹  precâ1 : PRE_COND; body_prec : PRED; body_postc : POST_COND∑
‹
‹	prec_calc (Atom t, postc) = {s, s' : STATE | {s'} Ú t Ä {s} Ú postc}
‹
‹ ±	prec_calc (Seq (pâ1, pâ2), postc) = prec_calc(pâ1, prec_calc(pâ2, postc)) 
‹
‹ ±	prec_calc (If(c, pâ1, pâ2), postc) =
‹		(prec_calc(pâ1, postc) íâ* c) ¿ (prec_calc(pâ2, postc) Åâ* c)
‹
‹ ±	((body_prec, body_postc) = guess_spec pâ1
‹	 ¥	prec_calc (While(c, pâ1), postc) =
‹			postc Å c ¿
‹			{ ss' : dom postc ∏ c
‹			| c Ä body_prec
‹			± body_prec Ä dom (prec_calc(pâ1, body_postc) ° (id STATE))
‹			± dom postc ∏ (body_postc®body_prec© \ c) Ä postc })
‹
‹ ±	prec_calc (Spec((precâ1, postcâ1), pâ1), postc) =
‹		{ s : STATE; s' : STATE | {s'} Ú postcâ1 Ä {s} Ú postc } íâ*
‹		(precâ1 ° dom(prec_calc(pâ1, postcâ1) ° (id STATE)))
∞
We conjecture that the above is sound:
πZ
‹ prec_calc_sound_cnj ?Ù prec_calc ç sound_prec_calc
∞
The following conjecture gives a useful property of our useful pre-condition
calculator, which turns out to be a simple consequence of its soundness.
πZ
‹ prec_calc_dom_cnj ?Ù
‹	µ prog: PROG; postc : POST_COND
‹	∑	dom (prec_calc(prog, postc) ° (id STATE)) ° dom (semantics prog)
‹			Ä dom postc
∞

We also conjecture that a program is ``upright'' in every state in the pre-condition
produced by the above pre-condition calculator, i.e., no execution of
the program can cause the pre-condition of any specification in the program
to be violated in those states.
πZ
‹ prec_calc_upright_cnj ?Ù
‹	µ prog: PROG; postc, postc' : POST_COND
‹	|	postc = prec_calc(prog, postc')
‹	∑	prog %bottom% ran postc
∞
\newpage
\appendix
\section{Proofs}
=TEX
\ftlinepenalty=999
=SML
delete_pc"'refinement" handle Fail _ => ();
new_pc "'refinement";

set_goal([], Ò
	STATE_TRANSFORMER = U
±	STATE = U
±	PRED = U
±	PRE_COND = U
±	POST_COND = U
±	PROG = U
±	SPEC = U
±	(_ ™ _) = UÆ
);
a(rewrite_tac(map z_get_spec[
	ÒSTATE_TRANSFORMERÆ,
	ÒSTATEÆ,
	ÒPREDÆ,
	ÒPRE_CONDÆ,
	ÒPOST_CONDÆ,
	ÒPROGÆ,
	ÒSPECÆ,
	Ò(_ ™ _)Æ]));
val €refinement_u_thm› = save_pop_thm "refinement_u_thm";
set_u_simp_eqn_cxt (u_simp_eqn_cxt [refinement_u_thm]) "'refinement";
set_merge_pcs["'refinement", "z_library1"];
=TEX
=SML
set_goal([], Òµ sâ1, sâ2 : U∑
	sâ1 √ sâ2
           § sâ1.1 Ä sâ2.1
             ± sâ1.1 Ú sâ2.2 Ä sâ1.2Æ);
a(z_µ_tac);
a(LEMMA_TÒsâ1 = (sâ1.1, sâ1.2) ± sâ2 = (sâ2.1, sâ2.2)Æ pure_once_rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" REPEAT strip_tac);
a(pure_rewrite_tac[(z_get_spec Ò(_√_)Æ)]);
a(rewrite_tac[]);
val €refines_def› = save_pop_thm "refines_def";
=TEX
=SML
set_goal([], Òµ R : U; T : U∑
	R íâ* T = { x : U; y : U | (x, y) ç R ± (µ z : U | (x, z) ç R ∑ z ç T) }Æ);
a(REPEAT strip_tac);
a(rewrite_tac[rewrite_rule[z_™_thm]
	(z_gen_pred_elim[ÒU∫{dom R}Æ, ÒU∫{T}Æ](z_get_specÒ(_íâ*_)Æ))]);
val €strong_rres_thm› = save_pop_thm "strong_rres_thm";
=TEX
=SML
set_goal([], Òµ R : U; T : U∑
	R Åâ* T = { x : U; y : U | (x, y) ç R ± (µ z : U | (x, z) ç R ∑ z é T) }Æ);
a(REPEAT strip_tac);
a(rewrite_tac[rewrite_rule[z_™_thm]
	(z_gen_pred_elim[ÒU∫{dom R}Æ, ÒU∫{T}Æ](z_get_specÒ(_íâ*_)Æ))]);
val €strong_rantires_thm› = save_pop_thm "strong_rantires_thm";
=TEX
=SML
set_goal([], Ò
	sound_prec_calc =
	{	pc : PREC_CALC
	|	µ prog : U; postc, postc' : U
		| postc = pc (prog, postc')
		∑ (dom postc, postc') √ (dom postc, postc ª semantics prog)}Æ);
a(strip_asm_tac(rewrite_rule[] (z_get_specÒsound_prec_calcÆ)));
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac Òx1 ç PREC_CALCÆ THEN1 PC_T1 "z_library_ext" all_asm_fc_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(ASM_FC_T1 fc_§_canon rewrite_tac[]);
a(rewrite_tac[refinement_u_thm] THEN POP_ASM_T accept_tac);
val €sound_prec_calc_thm› = save_pop_thm "sound_prec_calc_thm";
=TEX
=SML
val €semantics_def› = save_thm("semantics_def",
	rewrite_rule[refinement_u_thm](z_get_spec ÒsemanticsÆ));
=TEX
=SML
val €sat_def› = save_thm("sat_def",
	rewrite_rule[refinement_u_thm] (z_get_spec Ò(_%models%_)Æ));
=TEX
=SML
val €upright_def› = save_thm("upright_def",
	rewrite_rule[refinement_u_thm] (z_get_spec Ò(_%bottom%_)Æ));
=TEX
=SML
val €prec_calc_def› = save_thm("prec_calc_def",
	rewrite_rule[refinement_u_thm] (z_get_spec Òprec_calcÆ));
=TEX
=SML
set_goal([], ¨
	µp∑
	(µt∑ p ÒAtom tÆ)
±	(µ p1 p2∑ p p1 ± p p2 ¥ p ÒSeq(p1, p2)Æ)
±	(µ c p1 p2∑p p1 ± p p2 ¥ p ÒIf(c, p1, p2)Æ)
±	(µ c p1∑p p1 ¥ p ÒWhile(c, p1)Æ)
±	(µ prec postc p1∑ p p1 ¥ p ÒSpec((prec, postc), p1)Æ)
¥	(µ prg∑ p prg)
Æ);
a(REPEAT strip_tac);
a(LEMMA_T Òµprg : U∑ ¨p prgÆÆ rewrite_thm_tac);
let
	val thms = (rev o strip_±_rule o
		rewrite_rule[refinement_u_thm] o
		z_get_spec)ÒAtomÆ;
in
	a(bc_thm_tac ((pc_rule1 "z_library_ext" rewrite_rule[] o
		z_µ_elim Ò{prg:U | ¨p prgÆ}Æ o hd) thms));
	a(MAP_EVERY strip_asm_tac (tl thms))
end;
a(PC_T1 "z_library_ext" REPEAT strip_tac THEN all_fc_tac[z_fun_app_clauses]
	THEN all_var_elim_asm_tac1 THEN1 asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(LEMMA_T Òx = (x.1, x.2)Æ once_rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" rewrite_tac[]
	THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T Òx = (x.1, x.2, x.3)Æ once_rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" rewrite_tac[]
	THEN ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "3" *** *)
a(LEMMA_T Òx = (x.1, x.2)Æ once_rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" rewrite_tac[]
	THEN ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "4" *** *)
a(LEMMA_T Òx = ((x.1.1, x.1.2), x.2)Æ once_rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" rewrite_tac[]
	THEN ALL_ASM_FC_T rewrite_tac[]);
val €prog_induction_thm› = save_pop_thm"prog_induction_thm";
=TEX
=SML
val €prog_induction_tac› = gen_induction_tac prog_induction_thm;
=TEX
=SML
set_goal([], get_conjecture "-" "strip_specs_cnj");
a(REPEAT strip_tac);
a(prog_induction_tacÒpÆ THEN asm_rewrite_tac[semantics_def]);
val strip_specs_thm = save_pop_thm "strip_specs_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "chaos_cnj");
a(rewrite_tac[refines_def] THEN PC_T1 "z_library_ext" prove_tac[]);
val €chaos_thm›  = save_pop_thm"chaos_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "deadlock_cnj");
a(rewrite_tac[refines_def] THEN PC_T1 "z_library_ext" prove_tac[]);
val €deadlock_thm›  = save_pop_thm"deadlock_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "diamond_refines_cnj");
a(rewrite_tac[refines_def] THEN PC_T1 "z_library_ext" prove_tac[]);
val €diamond_refines_thm›  = save_pop_thm"diamond_refines_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "upright_mono_cnj");
a(REPEAT strip_tac THEN all_asm_ante_tac);
a(z_intro_µ_tacÒ(c1¶câ1, c2¶câ2)Æ THEN prog_induction_tacÒprogÆ
	THEN rewrite_tac[upright_def]);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN1 all_asm_fc_tac[]);
a(lemma_tacÒsemantics p1 ®c2© Ä semantics p1 ®c1©Æ
	THEN1 PC_T1 "z_library_ext" asm_prove_tac[]
	THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(lemma_tacÒc2 ° c Ä c1 ° cÆ
	THEN1 PC_T1 "z_library_ext" asm_prove_tac[]
	THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(lemma_tacÒc2 \ c Ä c1 \ cÆ
	THEN1 PC_T1 "z_library_ext" asm_prove_tac[]
	THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(REPEAT strip_tac);
a(lemma_tacÒc2 ° c Ä c1 ° cÆ
	THEN1 PC_T1 "z_library_ext" asm_prove_tac[]
	THEN all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(PC_T1 "z_sets_ext" asm_prove_tac[]);
val €upright_mono_thm›  = save_pop_thm"upright_mono_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "upright_cup_cnj");
a(REPEAT strip_tac THEN all_asm_ante_tac);
a(z_intro_µ_tacÒ(c1¶câ1, c2¶câ2)Æ THEN prog_induction_tacÒprogÆ
	THEN rewrite_tac[upright_def]);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN1 all_asm_fc_tac[]);
a(LEMMA_TÒsemantics p1 ®c1 ¿ c2© = semantics p1 ®c1© ¿ semantics p1 ®c2©Æ
		rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" prove_tac[]
	THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(LEMMA_TÒ(c1 ¿ c2) ° c = (c1 ° c) ¿ (c2 ° c)Æ rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" asm_prove_tac[]
	THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(LEMMA_TÒ(c1 ¿ c2) \ c = (c1 \ c) ¿ (c2 \ c)Æ rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" asm_prove_tac[]
	THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(REPEAT strip_tac);
a(LEMMA_TÒ(c1 ¿ c2) ° c = (c1 ° c) ¿ (c2 ° c)Æ rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" asm_prove_tac[]
	THEN all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(PC_T1 "z_sets_ext" asm_prove_tac[]);
val €upright_cup_thm›  = save_pop_thm"upright_cup_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "prec_calc_sat_cnj");
a(rewrite_tac[sound_prec_calc_thm, sat_def, refines_def] THEN REPEAT strip_tac);
a(z_spec_nth_asm_tac 3 Ò(
	prog¶Spec ((s_prec, s_postc), p),
	postc'¶s_postc,
	postc ¶ pc (Spec ((s_prec, s_postc), p), s_postc))Æ
	THEN all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN rewrite_tac[semantics_def]);
a(DROP_ASMS_T (ante_tac o hd) THEN PC_T1 "z_library_ext" REPEAT strip_tac);
a(PC_T1 "z_library_ext" all_asm_fc_tac[] THEN all_var_elim_asm_tac);
a(PC_T1 "z_library_ext" asm_prove_tac[]);
val €prec_calc_sat_thm›  = save_pop_thm"prec_calc_sat_thm";
=TEX
=SML
set_goal([], Ò
	µ R:U; c:U; x, y:U
	| (x, y) ç (c Ú R)Á*Í Å c
	∑ y é c ± (y = x ≤ x ç c ± (∂z:U∑z ç c ± (z, y) ç R))
Æ);
a(rewrite_tac[z_reflex_trans_closure_thm]
	THEN PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 3 Ò{a, b : U | a = b ≤ a ç c}Æ
	THEN PC_T1"z_library_ext" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 3 Ò{a, b, z : U | a = b ≤ z ç c ± (z, b) ç R∑(a, b)}Æ
	THEN PC_T1"z_library_ext" asm_prove_tac[]);
val €while_lemma›  = save_pop_thm"while_lemma";
=TEX
=SML
set_goal([], get_conjecture "-" "trivial_prec_calc_sound_cnj");
a(REPEAT strip_tac THEN asm_rewrite_tac[sound_prec_calc_thm]);
a(REPEAT strip_tac THEN asm_rewrite_tac[rewrite_rule[]chaos_thm]);
val €trivial_sound_prec_calc_thm›  = save_pop_thm"trivial_sound_prec_calc_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "prec_calc_sound_cnj");
a(rewrite_tac[sound_prec_calc_thm, prec_calc_def]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(z_intro_µ_tacÒ(postc'¶postc')Æ);
a(prog_induction_tac ÒprogÆ);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" rewrite_tac[prec_calc_def, semantics_def, refines_def]);
a(PC_T1 "z_library_ext" REPEAT strip_tac);
a(z_spec_nth_asm_tac 2 Ò(x1'¶y, x2¶x2)Æ THEN_TRY all_var_elim_asm_tac);
(* *** Goal "1.1" *** *)
a(z_spec_nth_asm_tac 3 Ò(x1'¶y', x2¶x2)Æ THEN all_var_elim_asm_tac);
(* *** Goal "1.2" *** *)
a(z_spec_nth_asm_tac 3 Ò(x1'¶y', x2¶x2)Æ THEN all_var_elim_asm_tac);
(* *** Goal "2" *** *)
a(all_asm_ante_tac THEN rewrite_tac[prec_calc_def, semantics_def, refines_def]
	THEN REPEAT strip_tac);
a(z_spec_nth_asm_tac 2 Òprec_calc (p2, postc')Æ THEN POP_ASM_T ante_tac);
a(z_spec_nth_asm_tac 1 Òpostc'Æ THEN DROP_ASMS_T (ante_tac o hd));
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "3" *** *)
a(all_asm_ante_tac THEN rewrite_tac[prec_calc_def, semantics_def, refines_def]
	THEN REPEAT strip_tac);
a(z_spec_nth_asm_tac 2 Òpostc'Æ THEN POP_ASM_T ante_tac);
a(z_spec_nth_asm_tac 1 Òpostc'Æ THEN DROP_ASMS_T (ante_tac o hd));
a(rewrite_tac[strong_rres_thm, strong_rantires_thm] THEN
	PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "4" *** *)
a(REPEAT strip_tac);
a(lemma_tacÒ∂body_prec:U; body_postc:U∑ (body_prec, body_postc) = guess_spec p1Æ
	THEN1 (z_∂_tacÒ(body_prec¶(guess_spec p1).1, body_postc¶(guess_spec p1).2)Æ
		THEN PC_T1 "z_library_ext" REPEAT strip_tac));
a(ALL_FC_T rewrite_tac[prec_calc_def]);
a(POP_ASM_T discard_tac THEN POP_ASM_T (ante_tac o z_µ_elimÒbody_postcÆ));
a(rewrite_tac[semantics_def, refines_def] THEN REPEAT strip_tac);
a(REPEAT_N 4 (PC_T1 "z_library_ext" once_rewrite_tac[]));
a(REPEAT_UNTIL is_¥ z_strip_tac THEN rewrite_tac[]);
a(bc_thm_tac(prove_rule[]¨µa b c∑(b ¥ c) ¥ (a ± b ¥ c)Æ));
a(REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(lemma_tacÒ≥y ç cÆ THEN1 PC_T1 "z_library_ext" asm_prove_tac[]);
a(fc_tac[while_lemma] THEN PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "4.2" *** *)
a(fc_tac[while_lemma] THEN_TRY all_var_elim_asm_tac);
a(lemma_tacÒz ç body_prec ± z ç dom (prec_calc (p1, body_postc) ° (id _))Æ THEN1
	(LIST_GET_NTH_ASM_T [3, 6, 7] (MAP_EVERY ante_tac) THEN
	PC_T1 "z_sets_ext" prove_tac[]));
a(lemma_tacÒ(z, z) ç prec_calc (p1, body_postc)Æ THEN1
	(LIST_GET_NTH_ASM_T [1] (MAP_EVERY ante_tac) THEN
	PC_T1 "z_library_ext" prove_tac[]));
a(lemma_tacÒ(z, x2) ç body_postcÆ THEN1
	(LIST_GET_NTH_ASM_T [1, 5, 13] (MAP_EVERY ante_tac) THEN
		PC_T1 "z_library_ext" prove_tac[]));
a(lemma_tacÒx2 ç body_postc®body_prec©Æ THEN1
	(LIST_GET_NTH_ASM_T [1, 4] (MAP_EVERY ante_tac) THEN
		PC_T1 "z_library_ext" prove_tac[]));
a(LIST_GET_NTH_ASM_T [1, 6, 10, 14] (MAP_EVERY ante_tac) THEN
		PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "5" *** *)
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 1 ÒpostcÆ THEN DROP_ASMS_T (ante_tac o hd));
a(PC_T1 "z_library_ext" rewrite_tac
	[prec_calc_def, semantics_def, refines_def, strong_rres_thm]);
a(PC_T1 "z_library_ext" REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [3] all_fc_tac THEN all_var_elim_asm_tac);
a(LIST_DROP_NTH_ASM_T [8] all_fc_tac);
a(LEMMA_T Òy'' = y''Æ asm_tac THEN1 strip_tac);
a(LIST_DROP_NTH_ASM_T [8] all_fc_tac THEN all_var_elim_asm_tac);
val €prec_calc_sound_thm›  = save_pop_thm"prec_calc_sound_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "prec_calc_dom_cnj");
a(REPEAT strip_tac);
a(ante_tac(z_µ_elimÒ(
	prog¶prog,
	postc'¶postc,
	postc ¶ prec_calc (prog, postc))Æ
	(±_right_elim(rewrite_rule[sound_prec_calc_thm]prec_calc_sound_thm))));
a(rewrite_tac[refines_def] THEN PC_T1 "z_library_ext" REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(PC_T1 "z_library_ext" (z_spec_nth_asm_tac 3) Ò(x1¶y, x2¶y')Æ
	THEN PC_T1 "z_library_ext" asm_prove_tac[]);
val €prec_calc_dom_thm›  = save_pop_thm"prec_calc_dom_thm";
=TEX
=SML
set_goal([],ÒµR1, R2: U∑
	ran (R1 íâ* c ¿ R2 Åâ* c) ° c Ä ran R1
±	ran (R1 íâ* c ¿ R2 Åâ* c) \ c Ä ran R2
Æ);
a(rewrite_tac[strong_rres_thm, strong_rantires_thm, refinement_u_thm]
	THEN  PC_T1 "z_library_ext" asm_prove_tac[]);
val €if_lemma› = pop_thm();
=TEX
=SML
set_goal([], get_conjecture "-" "prec_calc_upright_cnj");
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(z_intro_µ_tacÒ(postc'¶postc')Æ);
a(prog_induction_tac ÒprogÆ THEN rewrite_tac[upright_def, prec_calc_def]);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN1 asm_rewrite_tac[]);
a(strip_asm_tac (rewrite_rule[sound_prec_calc_thm] prec_calc_sound_thm));
a(z_spec_nth_asm_tac 1 Ò(prog¶p1, postc'¶prec_calc(p2, postc'),
	postc¶prec_calc(p1, prec_calc(p2, postc')))Æ);
a(POP_ASM_T ante_tac THEN rewrite_tac[refines_def] THEN REPEAT strip_tac);
a(bc_thm_tac(rewrite_rule[] (conv_rule z_µ_elim_conv upright_mono_thm)));
a(∂_tacÒran(prec_calc(p2, postc'))Æ THEN asm_rewrite_tac[]);
a(POP_ASM_T ante_tac THEN PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac(rewrite_rule[] (conv_rule z_µ_elim_conv upright_mono_thm)));
a(∂_tac Òran (prec_calc (p1, postc'))Æ);
a(asm_rewrite_tac[if_lemma]);
(* *** Goal "2.2" *** *)
a(bc_thm_tac(rewrite_rule[] (conv_rule z_µ_elim_conv upright_mono_thm)));
a(∂_tac Òran (prec_calc (p2, postc'))Æ);
a(asm_rewrite_tac[if_lemma]);
(* *** Goal "3" *** *)
a(REPEAT strip_tac);
a(lemma_tacÒ∂body_prec:U; body_postc:U∑ (body_prec, body_postc) = guess_spec p1Æ
	THEN1 (z_∂_tacÒ(body_prec¶(guess_spec p1).1, body_postc¶(guess_spec p1).2)Æ
		THEN PC_T1 "z_library_ext" REPEAT strip_tac));
a(ALL_FC_T rewrite_tac[prec_calc_def] THEN POP_ASM_T discard_tac);
a(bc_thm_tac(rewrite_rule[] (conv_rule z_µ_elim_conv upright_mono_thm)));
a(∂_tac Òran(prec_calc (p1, body_postc))Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
a(TOP_ASM_T ante_tac THEN PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "4" *** *)
a(REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(rewrite_tac[strong_rres_thm] THEN PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "4.2" *** *)
a(bc_thm_tac(rewrite_rule[] (conv_rule z_µ_elim_conv upright_mono_thm)));
a(∂_tac Òran (prec_calc (p1, postc))Æ THEN asm_rewrite_tac[strong_rres_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1
	THEN contr_tac THEN all_asm_fc_tac[]);
val €prec_calc_upright_thm›  = save_pop_thm"prec_calc_upright_thm";
=TEX
\section{Epilogue}
=SML
z_output_theory{out_file="refine.th.doc", theory="-"};
=TEX
{\HOLindexOff\small
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{refine.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

=TEX

\end{document}
=IGN
