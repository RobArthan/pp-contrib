=TEX
\documentclass{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\def\Hide#1{\relax}
\title{On Refinement}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\section{A Compliance Notation Example}
\subsection{Package Specification}
=SML
new_script{name = "SUM", state=initial_cn_state};

πCN
package €sum› is
  type €data› is range -1000 .. 1000;
  €acc_neg›, €acc_pos› : data;
  procedure €sum_pos› (x : in data)
  Ñ ACC_NEG, ACC_POS [ ~10 º X º 10,
          X < 0 ± ACC_NEG = ACC_NEGâ0 + X ± ACC_POS = ACC_POSâ0 ≤
          X = 0 ± ACC_NEG = ACC_POS = 0 ≤
          X > 0 ± ACC_POS = ACC_POSâ0 + X ± ACC_NEG = ACC_NEGâ0 ];
end sum;
∞
=TEX
\subsection{Package Body}
=SML
new_script{name = "SUM_BODY", state=get_cn_state()};
πCN
package body €sum› is
  procedure €sum_pos› (x : in data)
  Ñ ACC_NEG, ACC_POS [
          X < 0 ± ACC_NEG = ACC_NEGâ0 + X ± ACC_POS = ACC_POSâ0 ≤
          X = 0 ± ACC_NEG = ACC_POS = 0 ≤
          X > 0 ± ACC_POS = ACC_POSâ0 + X ± ACC_NEG = ACC_NEGâ0]
  is
  begin
    if     x = 0
    then   acc_neg := 0; acc_pos := 0;
    else   Ñ ACC_NEG, ACC_POS [ X Ω 0,
           X Ω 0 ±
          (X < 0 ± ACC_NEG = ACC_NEGâ0 + X ± ACC_POS = ACC_POSâ0 ≤
           X > 0 ± ACC_POS = ACC_POSâ0 + X ± ACC_NEG = ACC_NEGâ0) 	] (else_part)
    end if;
  end sum_pos;
end sum;
∞
πCN
 (else_part) √
        if x <= 0
        then acc_neg := acc_neg + x;
        else acc_pos := acc_pos + x;
        end if;
∞
\Hide{
=SML
set_pc"cn1";
val vcs = rev(map (hd ** snd) (get_conjectures "-"));
fun try_tactic acc tac ((vc as (name, term))::more) = (
	(delete_thm name handle Fail _ => t_thm);
	(save_thm(name, tac_proof(([], term), tac)); try_tactic acc tac more)
	handle Fail _ => try_tactic (vc::acc) tac more
) | try_tactic acc _ [] = rev acc;
val vcs1 = try_tactic []
	(cn_vc_simp_tac[] THEN REPEAT strip_tac) vcs;
val vcs2 = try_tactic []
	(cn_vc_simp_tac[] THEN PC_T1 "z_lin_arith" asm_prove_tac[]) vcs1;
=TEX
}
=SML
output_z_document{script = "SUM", out_file="refine1.zed"};
output_z_document{script = "SUM_BODY", out_file="refine2.zed"};
=TEX
\Hide{
=SH
sed -e '/^$/d' -e '/^[a-zA-Z(]/{
	i\
	=SML
}' < refine1.zed | sed -e '/^	/s/	//' | sieve tex > refine1.zed.tex
sed -e '/^$/d' -e '/^[a-zA-Z(]/{
	i\
	=SML
}' < refine2.zed | sed -e '/^	/s/	//' | sieve tex > refine2.zed.tex
=TEX
}
=IGN
print_z_document "SUM";
print_z_document "SUM_BODY";
=TEX
{\ftlinepenalty=9999
\underscoreoff\subsection{Z Documents}
\input{refine1.zed.tex}
\input{refine2.zed.tex}}
\section{A Z Model}
\subsection{Preamble}
=SML
open_theory"z_library";
set_pc"z_library1";
force_delete_theory"refinement" handle Fail _ => ();
new_theory"refinement";
ReaderWriterSupport.PrettyNames.add_new_symbols[
	(["refinedby"], Value "√", ReaderWriterSupport.PrettyNames.Simple)
] handle Fail _ => ();
=TEX
\subsection{States and State Transformers}
The internal structure of states is not relevant to our purposes.
We just introduce a given set to represent the states:
πZ
‹ [€STATE›]
∞

A state transformer is just a relation on states:
πZ
‹ €STATE_TRANSFORMER› ¶ STATE ™ STATE
∞
We think of a state transformer $t$ as {\em responding} to a state, the {\em before-state},
$s$ in its domain by non-deterministically selecting some {\em response} or {\em after-state},
which is a state $s'$ such that $(s, s') \in t$.

\subsection{A First Notion of Program}
Our first notion of programs has five syntactic categories:
\begin{description}
\item[Atom:] this comprises some set of primitive operations on the state. In a typical
imperative language, the atoms might be the denotations of assignment statements.
\item[Seq:] sequential composition
\item[If:] if-then-else
\item[While:] while-loop
\item[Spec:] programs with specifications; the specification is a state transformer
that we would like the program to refine. In a notation like the Compliance Notation
the specifications would be the denotations of pre- and post-condition pairs.
\end{description}

Here in a notation like the Compliance Notation, the states will be
assignments of values to program variables.
A pre-conditions is predicate whose free variables are program variables.
A post-condition is a predicate whose free variables are
program variables with optional decoration to distinguish values in the before-state
from values in the after-state.
A pre-condition denotes the set of assignments, $\alpha$, in which the program
variables satisfy the pre-condition and a post-condition denotes
the relation, $\rho$, which holds between two states $s$ and $s'$ when $s \times s'$
satisfies the post-condition after makihng the appropriate binding of before- and after-values
to the variables in the post-condition.
Taken together, we think of the pre- and post-condition as denoting the state transformer
=INLINEFT
¡ Ú “
=TEX
.

A predicate on states is just a set of states, i.e., the denotation of the
usual syntactic notion of a predicate:
πZ
‹ €PREDICATE› ¶ STATE
∞

As discussed above, specifications are just state transformers:
πZ
‹ €SPECIFICATION› ¶ STATE_TRANSFORMER
∞

We can now represent programs abstractly using the following free type, in which we freely
mingle semantic and syntactic domains to simplify later work. We also use a tree
structure rather than a linear list for sequential composition, since that is semantically
harmless, and, again, helps to keep things simple later on.
πZ
‹ €PROGRAM› ::=
‹	€Atom› (STATE_TRANSFORMER)
‹ |	€Seq› (PROGRAM ∏ PROGRAM)
‹ |	€If› (PREDICATE ∏ PROGRAM ∏ PROGRAM)
‹ |	€While› (PREDICATE ∏ PROGRAM)
‹ |	€Spec› (SPECIFICATION ∏ PROGRAM)
∞
The following function gives the semantics of this first notion of a program.
The semantic value of a program is a state transformer.
In the semantics, the specifications in the syntactic category Spec are just
ignored --- it is the actual code that determines the semantics, not our aspirations
for it.
πZAX
‹ €semantics› : PROGRAM ≠ STATE_TRANSFORMER
˜¸¸¸¸¸¸
‹ µt : STATE_TRANSFORMER; pâ1, pâ2 : PROGRAM; c : PREDICATE; s : SPECIFICATION∑
‹	semantics (Atom t) = t
‹ ±	semantics (Seq (pâ1, pâ2)) = semantics pâ1 ª semantics pâ2
‹ ±	semantics (If(c, pâ1, pâ2)) = semantics pâ2 ´ (c Ú semantics pâ1)
‹ ±	semantics (While(c, pâ1)) = (c Ú semantics pâ1)Á*Í Å c
‹ ±	semantics (Spec(s, pâ1)) = semantics pâ1
∞
It is in the above that the convenience of dealing with partial correctness
begins to become apparent. The semantics of a while-loop says that the
body of the loop is to be executed repeatedly in states satisfying
the predicate $c$ until a state which does not satisfy $c$ is reached.
If this fails to terminate the result is just the empty relation.
The semantics of total correctness demand
a much more complex representation, but we have no need of that.
\subsection{Refinement}
Refinement is a notion that is fundamental to the notion of program
correctness that we will define; however, it is a semantic notion
that is independent of the syntax of programs.

A state transformer $t_2$ refines another state transformer $t_1$ iff.
the domain of $t_2$ includes that of $t_1$ and every pair $(s, s')$ related
by $t_2$ are also related by $t_2$. The first of these conditions is
the traditional notion of liveness --- it says that $t_2$ is able to
respond in any state that $t_1$ can respond in. The second
condition is the traditional notion of safety --- it says that any response
made by $t_2$ in a state in which $t_1$ could respond
is a response that could also be made by $t_1$.
We write $t_1 \sqsubseteq t2$ to mean that $t_2$ refines $t_1$.
πZ
‹ relation _ √ _
∞

πZAX
‹ €_ √ _› : STATE_TRANSFORMER ™ STATE_TRANSFORMER
˜¸¸¸¸¸¸
‹ µtâ1, tâ2 : STATE_TRANSFORMER∑
‹	tâ1 √ tâ2 § dom tâ1 Ä dom tâ2 ± dom tâ1 Ú tâ2 Ä tâ1
∞

If $t_1$ and $t_2$ are any two state transformers.
The $t_1$ {\em cut-down} of $t_2$ is the largest set of states, $c$ say,
such that $t_2$ refines the restriction of $t_1$ to $c$.
We write this as $t_1 \downarrow t_2$.

πZ
‹ function 7 _ %downarrow% _
∞
πZAX
‹ €_ %downarrow% _› : STATE_TRANSFORMER ∏ STATE_TRANSFORMER ≠ STATE
˜¸¸¸¸¸¸
‹ µtâ1, tâ2 : STATE_TRANSFORMER∑
‹	tâ1 %downarrow% tâ2 = ﬁ{c : STATE | c Ú tâ1 √ tâ2}
∞
The following conjecture states the main properties of the cut-down.
πZ
‹ cutdown_clauses_cnj ?Ù
‹	µtâ1, tâ2 : STATE_TRANSFORMER∑
‹	tâ1 %downarrow% tâ2 Ú tâ1 √ tâ2
‹ ±	(µc : STATE | c Ú tâ1 √ tâ2 ∑ c Ä tâ1 %downarrow% tâ2)
∞

There are many equivalent ways of formulating the above definition.
The following conjecture records one alternative giving a pointwise
construction.
πZ
‹ cutdown_pointwise_cnj ?Ù
‹	µtâ1, tâ2 : STATE_TRANSFORMER∑
‹	tâ1 %downarrow% tâ2 = {s : STATE | s ç dom tâ1 ¥ {s} Ú tâ1 √ tâ2}
∞
\subsection{Program Correctness}
Intuitively, a program is correct if every part of it that has a specification
satisfies that specification. We relativise this notion to a notion
of correctness with respect to a given set of starting states, identified
by some predicate, $c$. A program, $p$, is then correct with respect to $c$
if every part of it that has a specification will satisfy the specification
when $p$ is started in a state in $c$. We write
=INLINEFT
c %models% p
=TEX
\ when this holds.
πZ
‹ relation _ %models% _
∞
πZAX
‹ €_ %models% _› : PREDICATE ™ PROGRAM
˜¸¸¸¸¸¸
‹ µt : STATE_TRANSFORMER; pâ1, pâ2 : PROGRAM; câ1, câ2 : PREDICATE; s : SPECIFICATION∑
‹	(câ1 %models% (Atom t))
‹ ±	(câ1 %models% (Seq (pâ1, pâ2)) § câ1 %models% pâ1 ± semantics pâ1 ®câ1© %models% pâ2)
‹ ±	(câ1 %models% (If(câ2, pâ1, pâ2)) § câ1 ° câ2 %models% pâ1 ± câ1 \ câ2 %models% pâ2)
‹ ±	(câ1 %models% (While(câ2, pâ1)) § (câ1 ° dom (semantics(While(câ2, pâ1)))) %models% pâ1)
‹ ±	(câ1 %models% (Spec(s, pâ1)) § câ1 ° dom s %models% pâ1 ± câ1 Ú s √ semantics pâ1)
∞
\subsection{Precondition Calculation}
A pre-condition calculator is a function that takes a program and a post-condition as
its argument and returns a predicate that, we hope, gives the pre-condition for
achieving the post-condition. In practice, such a function might conceptually
be partial, because, for example, there may be atomic statement forms that are
intractable. However, these can always be handled by returning an empty
pre-condition, so we take pre-condition calculators to be total functions.
πZ
‹ €PREC_CALC› ¶ PROGRAM ∏ PREDICATE ≠ PREDICATE
∞
A pre-condition calculator is sound if the pre-condition it returns
for any program and post-condition is such that execution of the
program in any state satisfying the pre-condition will indeed result
in a state satisfying the post-condition.
πZAX
‹ €sound_prec_calc› : PREC_CALC
˜¸¸¸¸¸¸
‹ µpc : PREC_CALC∑
‹	pc ç sound_prec_calc
‹ §	(µprog : PROGRAM; postc, prec : PREDICATE
‹	|	prec = pc (prog, postc)
‹	∑	semantics prog ®prec© Ä postc)
∞
The notion of soundness is a purely semantic one: it does not require
those parts of the program that have specifications actually to satisfy
those specifications. The stronger notion of correctness imposes
this requirement. To formulate this for a given program and post-condition,
{\it postc}, say, for which the pre-condition calculator returns the
pre-condition, {\it prec}, say, we take the relation
{\it postc} $\times$ {\it prec} as the specification of the program and
require that the resulting program be correct with respect to this specification
in any state.
πZAX
‹ €correct_prec_calc› : PREC_CALC
˜¸¸¸¸¸¸
‹ µpc : PREC_CALC∑
‹	pc ç sound_prec_calc
‹ §	(µprog : PROGRAM; postc, prec : PREDICATE
‹	|	prec = pc (prog, postc)
‹	∑	STATE %models% Spec(prec ∏ postc, prog))
∞
We can now formulate the conjecture that correctness for pre-condition calculators is indeed a stronger
notion than soundness.
πZ
‹ correct_prec_calc_sound_cnj ?Ù correct_prec_calc Ä sound_prec_calc
∞

\subsection{Proofs}
=SML
set_goal([], ÒSTATE_TRANSFORMER = UÆ);
a(rewrite_tac(map z_get_spec[ÒSTATEÆ, ÒSTATE_TRANSFORMERÆ, Ò(_™_)Æ]));
val €state_transformer_u_thm› = save_pop_thm "state_transformer_u_thm";
=TEX
=SML
val €state_u_thm› = save_thm("state_u_thm",
	(z_get_spec ÒSTATEÆ));
val €refines_thm› = save_thm("refines_thm",
	rewrite_rule[state_transformer_u_thm] (z_get_spec Ò(_√_)Æ));
val €cutdown_thm› = save_thm("cutdown_thm",
	rewrite_rule[state_transformer_u_thm, state_u_thm] (z_get_spec Ò(_%downarrow%_)Æ));
=TEX
=SML
set_goal([], get_conjecture "-" "cutdown_clauses_cnj");
a(rewrite_tac[state_transformer_u_thm, state_u_thm, refines_thm, cutdown_thm] THEN
	REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(z_∂_tacÒ{x1}Æ THEN PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac);
a(z_∂_tacÒ{x1}Æ THEN PC_T1 "z_library_ext" asm_prove_tac[]);
val cutdown_clauses  = save_pop_thm"cutdown_clauses";
=TEX
=SML
set_goal([], get_conjecture "-" "cutdown_pointwise_cnj");
a(REPEAT strip_tac);
a(rewrite_tac[state_transformer_u_thm, state_u_thm, refines_thm, cutdown_thm] THEN
	PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(z_∂_tacÒ{x1}Æ THEN PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "4" *** *)
a(z_∂_tacÒ{x1}Æ THEN REPEAT strip_tac);
val cutdown_pointwise_thm  = save_pop_thm"cutdown_pointwise_thm";
=TEX

\subsection{Epilogue}
=SML
z_output_theory{out_file="refine.th.doc", theory="-"};
=TEX
{\HOLindexOff
\let\Section\subsection
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{refine.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

=TEX

\end{document}
=IGN
