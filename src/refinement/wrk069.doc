=IGN
# N.B. This document was prepared in ProofPower V2.5.4 but should work on 2.5.1 or later
# and probably earlier as well.
#
# Uses bibliography file bookspapers.bib
# needs EPS files refcalc1.eps and refcalc2.eps; to create these run xfig on refcalc1.fig
# and refcalc2.fig and export as EPS.
#
# To process the document in batch:
pp_make_database -f -p zed refcalc
docsml refcalc
pp -i refcalc -d refcalc </dev/null >refcalc.run.log
doctex refcalc refcalc.th
docdvi refcalc
# That will give you a document "refcalc.dvi" to print off and read.
# To process the document interactively:
pp_make_database -f -p zed refcalc
xpp -f refcalc.doc -c pp -d refcalc &
# then either do use_file"refcalc" to load the lot and start interacting with
# the results, or, select-and-execute your way through a chunk at a time.
=TEX
\documentclass[12pt]{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\usepackage{epsf}
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\def\Hide#1{\relax}
%Macros for references (to be converted to bibtex presently).
\def\Unifying{{Hoare \& He \cite{hoare98}}}
\def\Methods{{Jones \cite{jones92}}}
\def\TwoJims{{Woodcock and Davies\cite{woodcock96}}}


\title{On Refinement Calculus and Partial Correctness \\ (DRAFT)}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\section{Introduction}\label{Intro}
\subsection{Background and Motivation}

This note is intended as the first of a series concerned with a style of system specification in which
the claims that can be verified have the form ``system $p$
satisfies specification $s$ under normal circumstances''.
This notion of correctness is traditionally referred to as partial correctness,
although a more impartial term such as ``algorithmic correctness'' is
preferred by some.
A total correctness claim has the form ``system $p$
always satisfies specification $s$''.

I should explain what is meant by ``normal circumstances'':
we have in a mind some notion of mathematically rigorous system
specification. Such a notion will always be relative to some conventions
and assumptions about the relationship between the mathematical model
and the physical systems under consideration. For example, in
program specification, the modelling conventions might be the abstractions
involved in a formal semantics for the programming language and the modelling
assumptions might include an assumption that  no exceptions are raised causing control to pass
from the programming language execution environment to the operating
system under which it runs. We take normal circumstances to be those
in which the modelling assumptions hold --- abnormal circumstances are those
in which the model breaks down and something external to the model is required
to deal with the situation.


For many practical purposes, partial correctness is
a much more useful notion than total correctness.
For example, in program analysis, tools other than formal specification and proof may be
better suited to automatic analysis of normal termination.
Furthermore, partial correctness claims have the clear advantage
of sometimes being true in physical reality, whereas total
correctness claims never are (e.g., consider what happens when a
power supply fails). We believe the partial correctness approach
is much closer in spirit to normal engineering practice: no engineered
artefact is perfect. Much of the work in any engineering task is
in combining potentially faulty subsystems so as to
produce a system that is adequately resilient for its intended
purpose. 

Some technologies, such as programming languages, apparently offer
the possibility of formal proof of total correctness. However, such a proof
is always relative to some mathematical model which is invariably an idealisation
of the physical reality of the delivered artefact. While this possibility is
of considerable theoretical importance, we believe that there is considerable
practical value in having a mathematically rigorous theory that reflects the
potential for failure in any engineered component.

The original motivation for this work lay in program specification.
However, it became clear that with just a little additional abstraction,
much of the theory has a much wider domain of application.
In this first note, we look at a very general class of systems and system
specifications. 

The most general notion of the act of specifying a system is first to identify some
set $P$ of possible systems and then to identify a subset $A \subseteq P$
of acceptable systems. We may call this the {\it property-based} approach.
It is advocated in {\Methods}
as a general method for specifying and verifying critical system properties.
The advantages and disadvantages of this view both lie in its
generality: on the one hand, it is clearly adequate to deal with any system property
that is amenable to any form of mathematical specification, on the other hand
it gives no guidance whatsoever as to how to proceed: the modelling conventions
and assumptions in any given situation need to be carefully designed and inspected
to ensure they are fit for their intended purpose.

An approach that has a very long tradition, particularly in program verification,
is to observe that almost any system can be viewed as some kind of binary
relation, say between inputs and outputs, or between successive states
of a state transition machine. This {\it relational} approach leads to a notion
of {\em refinement} whereby implementations are viewed as
binary relations of the same kind  as are used for specifications and refinement
rules are given defining what a valid implementation of a specification is.
(The corresponding notion for the property-based approach is just set-theoretic
inclusion or membership. The refinement rules give more useful insights
in the relational approach.)


In a relatively recent work, {\Unifying}, this approach is advocated
as providing a unifying framework for dealing with a wide class of programming
languages and programs. However, the approach as described in {\Unifying} is
heavily biased towards the total correctness viewpoint. This actually leads to
considerable technical complications and the solutions taken in {\Unifying}
lead to counter-intuitive results: for example,  they preclude the design of
a system which can create order from chaos --- a very common engineering
requirement.

It is certainly possible to adapt the relational approach to give a notion
of partial correctness. Indeed, the approach we will take in this note
embraces this as a special case. However, viewing specifications as
binary relations leads to a significant loss of expressiveness in
the partial correctness version. The problem is that when dealing with
the possibility of failure, the specifier may need to
demand failure under certain circumstances. Unfortunately, the relational approach
gives no way of distinguishing between cases where failure is required
and cases where the behaviour is unspecified.
Our approach is to augment the binary relation with a set indicating
the domain in which the specifier has a definite interest in behaviour.
This is, essentially just the pre- and post-condition style of
specification that is familiar from Floyd-Hoare logic and notations like
VDM. However, the partial correctness interpretation of the pre-condition
makes it play a much more important role than it does in a total
correctness approach (which is why {\Unifying} is able to do without it,
except as a syntactic convention).


Please note this is work-in-progress and the current version of
this note lacks any serious attempt to cite the literature or
compare the results with other work.


\subsection{Notation}

We will develop our theory using the Z notation. We will give definitions in Z and
state our theorems as Z conjectures. The Z definitions have all been type-checked 
and the conjectures have all been proved using the {\Product} system. The master
of this document is in fact a {\Product} literate script which can be processed
automatically to check the definitions and replay the proofs. For brevity, the
proof commands are suppressed from the printed form of the document.


\Hide{
The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"z_library";
set_pc"z_library1";
force_delete_theory"refinement" handle Fail _ => ();
new_theory"refinement";
ReaderWriterSupport.PrettyNames.add_new_symbols[
	(["refinedby"], Value "√", ReaderWriterSupport.PrettyNames.Simple), 
	(["ident"], Value "È", ReaderWriterSupport.PrettyNames.Simple)
] handle Fail _ => ();
=TEX
}

We use infix notation for the following relation
and function symbols:
πZ
‹ rel _ √ _, _ %models% _, _ È_
∞
πZ
‹ fun 7 _ %sqcap% _, _ %sqcup% _, _ Á$Í
∞
We use postfix notation for the following function and generic symbols:
πZ
‹ fun 7 _ Á$Í
∞
πZ
‹ gen 9 _ Á‚Í
∞





\section{Inputs, Outputs , Pre-conditions, Post-conditions}\label{STATE}

We wish to construct a semantic model of specification of operations
via pre- and post-conditions.
Our operations have inputs and outputs that could be memory states, or data streams or anything
else appropriate  to the modelling task at hand.
The internal structure of inputs and outputs is not relevant to our purposes for the time being
--- our definitions will be generic with respect to the set, $X$, of inputs and the set, $Y$, of outputs.

For modelling the semantics of a conventional imperative programming language,
the inputs and outputs would both be
assignments of values to program variables.
We take this as our motivating example in this section.

In our formulation, a predicate on a is just a subset of it, i.e., the denotation of the
usual syntactic notion of a predicate.

πZ
‹ €PRED›[X] ¶ X
∞

For the programming language example, a pre-condition would be given
syntactically as a predicate whose free variables are program variables and a post-condition as a predicate whose free variables are
program variables with optional decoration to distinguish values in the before-state
from values in the after-state.
A pre-condition denotes the set of assignments, $\alpha$, in which the program
variables satisfy the pre-condition and a post-condition denotes
the relation, $\rho$, which holds between a before-state $s$ and an after-state $s'$ when $s \times s'$
satisfies the post-condition after makihng the appropriate binding of before- and after-values
to the variables in the post-condition.

Taken together, we can often think of the pre- and post-condition as denoting the relatioin
=INLINEFT
¡ Ú “
=TEX
.
However,as we will be making
formal presently, our reading of a specification will require the program
not to terminate in before-states that satisfy the pre-condition but to
which the post-condition cannot respond.
Consequently we lose some expressiveness if we throw away the pre-condition,
for example, if the post-condition is unsatisfiable, the pre-condition
defines a set of states in which the program must not terminate.
We therefore keep a separate record of the pre-condition. 
So a specification is a pair comprising a predicate giving the pre-condition
and a binary relation between inputsw and outputs giving the post-condition.

πZ
‹ €PRE_COND›[X] ¶ PRED[X]
∞
πZ
‹ €POST_COND›[X, Y] ¶ X ™ Y
∞
πZ
‹ €SPEC›[X, Y] ¶ PRE_COND[X] ∏ POST_COND[X, Y]
∞

To give examples in the sequel, we will borrow some syntax from the Compliance Notation, in 
which states comprise assignments of values to program variables representing the execution
state of an Ada program.
In the Compliance Notation, specifications are written using {\em specification statements}
which have the following general form:
{
\vertbarfalse

=GFT
	Ñ %calW% [%calP%, %calQ% ]
=TEX
where $\cal W$ is a list of program variables called the {\it frame} and
$\cal P$ and $\cal Q$ are syntactic predicates giving the pre-condition and post-condition respectively.
In the post-condition a subscript 0 may be used
to distinguish variables that refer to the before-state from variables that refer to the after-state.
The frame lists the program variables that may be changed by the code being specified.
For example, here are specification statements for {\em(a)} a fragment of code
that exchanges the value of two program variables, $X$ and $Y$, possibly with a side-effect on a third
variable, $T$; and, {\em(b)} a fragment of code that divides one variable, $Y$, by
another, $X$, subject to the pre-condition that $X$ be positive.

=GFT
	Ñ X, Y , T [true, X = Yâ0 ± Y = Xâ0]			(a)
	Ñ Y [X > 0, Y = Yâ0 / X ]				(b)
=TEX

In our semantic view, a syntactic specification statement of this sort denotes a specification
in the above semantic sense whose pre-condition
is the denotation of the given syntactic pre-condition and whose post-condition is
the relation denoted by the given post-condition conjoined with the requirement that any variable
not listed in the frame must be unchanged.

}
\section{Refinement}\label{refines}
Refinement is a notion that is fundamental to this work.
Refinement is the relation that obtains between a specification and a satisfactory implementation
of that specification, where, in
the present context an ``implementation'' is simply a specification, typically more
definite than the specification it refines. Since we are only concerned with partial
correctness, we consider an implementation to be satisfactory even if it fails to respond
in some situations where the specification appears to require a response.
More formally, we will say that one specification, 
=INLINEFT
sâ2 = (precâ2, postcâ2)
=TEX
\ refines another
=INLINEFT
sâ1 = (precâ1, postcâ1)
=TEX
\ iff:
\begin{itemize}
\item
=INLINEFT
precâ2
=TEX
\ includes
=INLINEFT
precâ1
=TEX
; and:
\item the restriction of
=INLINEFT
postcâ2
=TEX
\ to
=INLINEFT
precâ1
=TEX
\ is contained in
=INLINEFT
postcâ1
=TEX
.
\end{itemize}
The first of these conditions is a vestigial analogue of liveness in our partial
correctness view of refinement.
The traditional notion of liveness allows the pre-condition to be weakened
but requires
=INLINEFT
postcâ2
=TEX
\ to be at least as responsive as
=INLINEFT
postcâ1
=TEX
\ in states where
=INLINEFT
precâ1
=TEX
\ holds.
Here, we do not impose the latter requirement.
We just say is that $s_2$ may not strengthen the
pre-condition of $s_1$: this amounts to saying that $s_2$ must not be
less specific than $s_1$ in its requirements for non-termination.

The second condition is the traditional notion of safety --- it says that any response
made by $s_2$ in a state satisfying the pre-condition of $s_1$
is a response that could also be made by $s_1$. This
includes the possibility that $s_2$ may be unable to respond where $s_1$ can.

ù[ X, Y ]úúúúúúúúúúú
‹ €_ √ _› : SPEC[X, Y] ™ SPEC[X, Y]
˜¸¸¸¸¸¸
‹ µprecâ1, precâ2 : PRE_COND[X]; postcâ1, postcâ2 : POST_COND[X, Y]∑
‹	(precâ1, postcâ1) √ (precâ2, postcâ2)
‹ §	precâ1 Ä precâ2
‹ ±	precâ1 Ú postcâ2 Ä postcâ1
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

We now explore the properties of the refinement relation. First of all, we note that
refinement is a pre-order (i.e., it is reflexive and transitive):
πZ
‹ refinement_pre_order_cnj ?Ù 
‹	µ sâ1, sâ2 , sâ3: SPEC∑
‹		sâ1 √ sâ1
‹±		(sâ1 √ sâ2 ± sâ2 √ sâ3 ¥ sâ1 √ sâ3)
∞

However, refinement is not antisymmetric, i.e., it is possible to have
$s_1 \sqsubseteq s_2$ and $s_2 \sqsubseteq s_1$ without having $s_1 = s_2$.
This happens because two specifications with the same post-condition may differ only
with respect to responses to before-states that do not satisfy the pre-condition
and are therefore irrelevant in our definition of refinement%
\footnote{
We could require all our specifications to be such that the
pre-condition contains the domain of the post-condition. We prefer not to impose this
restriction except where necessary. This is technically more convenient and is also
more faithful to actual examples, e.g, in the example,
=INLINEFT
Ñ Y [X > 0, Y = Yâ0 / X ]
=TEX
\ that we have already discussed, the denotation of the post-condition considered
in isolation includes the possibility that $X$ be negative in the before-state.
}.
To remedy this, where necessary, let us say that two specifications are equivalent if they refine one another:

ù[X, Y]úúúúúúúúúúú
‹ €_ È _› : SPEC[X, Y] ™ SPEC[X, Y]
˜¸¸¸¸¸¸
‹ µsâ1, sâ2 : SPEC[X, Y]∑
‹	sâ1 È sâ2 § sâ1 √ sâ2 ± sâ2 √ sâ1
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

That $\equiv$ is an equivalence relation follows from the fact that $\sqsubseteq$ is a pre-order.
The pre-order induces a pre-order on the equivalence classes which will necessarily also
be a partial order, i.e., it will also be antisymmetric.
Rather than work with equivalence classes in the sequel, we will work with canonical
representatives when necessary.
These canonical representatives are defined by the following which reduces a specification
to a normal form in which the post-condition is empty outside the pre-condition.
ù[X, Y]úúúúúúúúúúú
‹ €_ Á$Í› : SPEC[X, Y] ≠ SPEC[X, Y]
˜¸¸¸¸¸¸
‹ µprec : PRE_COND[X]; postc : POST_COND[X, Y]∑
‹	(prec, postc)Á$Í = (prec, prec Ú postc)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

The reduction operator (which is useful enough to be worth the dollar in its name!) is
idempotent:
πZ
‹ reduce_reduce_cnj ?Ù µ s : SPEC∑ (sÁ$Í)Á$Í = sÁ$Í
∞
The following theorem shows that the reduction operator does indeed pick
a canonical representative from each $\equiv$-equivalence class: 
πZ
‹ equiv_cnj ?Ù µ sâ1, sâ2 : SPEC∑ sâ1 È sâ2 § sâ1Á$Í = sâ2Á$Í
∞

Our next theorem says that
refinement is independent of choice of representative in each equivalence class:
=GFT
πZ
‹ refinement_reduce_cnj ?Ù µ sâ1, sâ2 : SPEC∑ sâ1 √ sâ1 § sâ1Á$Í √ sâ1Á$Í
∞
Let use define the {\em reduced} specifications to be those in the range of the reduction operator:
ù[X, Y]úúúúúúúúúúú
‹ €REDUCED› : SPEC[X, Y] 
˜¸¸¸¸¸¸
‹ 	REDUCED  = {s : SPEC∑ sÁ$Í}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

When restricted to reduced specifications, refinement does indeed become antisymmetric:
πZ
‹ refinement_antisym_cnj ?Ù µ sâ1, sâ2 : REDUCED∑ sâ1 √ sâ2 ± sâ2 √ sâ1 ¥ sâ1 = sâ2
∞
We now want to show that refinement of reduced specifications is a complete lattice.
We now define constants that help us state this and other results. First of all constants
relating to tops, bottoms etc. We use upper-case namesfor the contituents of specifications
and mixed upper-lower case names for specifications. 
ù[X]úúúúúúúúúúú
‹ €TRUE›, €FALSE› : PRE_COND[X]
˜¸¸¸¸¸¸
‹ 	TRUE = X;
‹	FALSE = ö
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

ù[X, Y]úúúúúúúúúúú
‹ €ABORT› : POST_COND[X, Y];
‹ €CHAOS› : PRE_COND[X] ≠ POST_COND[X, Y];
‹ €Abort›, €Chaos› : PRE_COND[X] ≠ SPEC[X, Y];
‹ €Bottom› , €Top›: SPEC[X, Y]
˜¸¸¸¸¸¸
‹	ABORT = ö;
‹	µ prec : PRE_COND[X]∑
‹		CHAOS prec = prec ∏ Y
‹	±	Abort prec = (prec, ABORT)
‹	±	Chaos prec = (prec, CHAOS prec);
‹	Bottom = Chaos ö;
‹	Top = Abort TRUE 
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

Bottom and top are indeed the bottom and top elements of the pre-order:
πZ
‹ bottom_top_cnj ?Ù µ s : SPEC∑ Bottom √ s √ Top
∞

Meets (greatest lower bounds) turn out to be straightforward to define and verify:
ù[X, Y]úúúúúúúúúúú
‹ €Meet› : SPEC[X, Y] ≠ SPEC[X, Y]
˜¸¸¸¸
‹µA :  SPEC[X, Y]∑ Meet A = (•{s : A∑ s.1}, ﬁ{s : A∑ s.2})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Now we can state the conjecture that meets are indeed greatest lower bounds.

πZ
‹ refinement_meet_cnj ?Ù 
‹	µ A : SPEC∑ µt : A∑ Meet A √ t;
‹	µ A : SPEC; s : SPEC∑ (µt : A∑ s √ t) ¥ s √ Meet A
∞

Joins turn out to be trickier. We first define a function that maps
a specification, $s$ say to the post-condition that allows precisely those
state transitions that $s$ forbids forbids:
ù[X, Y]úúúúúúúúúúú
‹ €Forbidden› : SPEC[X, Y] ≠ POST_COND[X, Y]
˜¸¸¸¸
‹µs : SPEC[X, Y]∑
‹	Forbidden s = CHAOS (s.1) \ s.2
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
A more explicit equation for fobidden sets is useful\footnote{
For convenience in stating this and other theorems, we use the generic constant $U$ which is
defined as part of the {\Product} Z library as if by the
generic definition
=INLINEFT
U[X] ¶ X
=TEX
, so that $U$ with the generic parameter left implicit denotes the
universal set of whatever type is required by the context.
}:

πZ
‹ forbidden_def_cnj ?Ù 
‹	µ s : SPEC∑ 
‹		Forbidden s = { x : U; y : U | x ç s.1 ± ≥(x, y) ç s.2}
∞
The following conjecture is useful to check the definition of the forbiden function and in proving
later results.
πZ
‹ forbidden_cnj ?Ù 
‹	µ sâ1, sâ2 : SPEC∑ 
‹		sâ1 √ sâ2 § sâ1.1 Ä sâ2.1 ± sâ2.2 ° (Forbidden sâ1) = ö
∞

Now we can define joins. The pre-condition of the join of a set of
specifications is just the union of the individual pre-conditions.
The post-condition is obtained from  the union of the post-conditions by
removing all transitions that are forbidden by some specification in the set.
ù[X, Y]úúúúúúúúúúú
‹ €Join› : SPEC[X, Y] ≠ SPEC[X, Y]
˜¸¸¸¸
‹µA :  SPEC[X, Y]∑
‹	Join A = (ﬁ{s : A∑ s.1}, (ﬁ{s : A∑(sÁ$Í).2}) \ (ﬁ{s : A∑Forbidden s}))
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
In elementary working with join it is often more convenient to
have more explicit set comprehensions:
πZ
‹ join_def_cnj ?Ù 
‹	µ A : SPEC∑ Join A = 
‹		({s : A; x : U | x ç s.1∑ x},
‹		{s : A; x : U;  y : U
‹		| x ç s.1 ± (x, y) ç s.2 ± (µt : A∑ x ç t.1 ¥ (x, y) ç t.2)
‹		∑ (x, y)})
∞
It is useful to be able to calculate the forbidden set of a join
πZ
‹ forbidden_join_cnj ?Ù 
‹	µ A : SPEC∑ 
‹		Forbidden(Join A) = ﬁ{s : A∑ Forbidden s}
∞
Now we can state the theorem that our joins are indeed least upper bounds.
πZ
‹ refinement_join_cnj ?Ù  
‹	µ A : SPEC∑ µt : A∑ t √ Join A;
‹	µ A : SPEC; s : SPEC∑ (µt : A∑ t √ s) ¥ Join A √ s
∞

Given that arbitrary meets and joins exist, we can now define binary meets and joins in terms of them.
At this point, the observant reader who is not familiar with the traditions of our style of
specification will note that the passage from the language of set-theoretic inclusion, union and
intersection, to the language of refinement, meets and joins involves not only squaring off
the corners of the symbols but also looking at them upside down in a mirror. This is perhaps
unfortunate, but it is the tradition and we feel obliged to follow it.
ù[X, Y]úúúúúúúúúúú
‹ €_%sqcap%_›, €_%sqcup%_›: SPEC[X, Y] ∏ SPEC[X, Y] ≠ SPEC[X, Y]
˜¸¸¸¸
‹µsâ1, sâ2 : SPEC[X, Y]∑
‹	sâ1 %sqcap% sâ2 = Meet{sâ1, sâ2}
‹±	sâ1 %sqcup% sâ2 = Join{sâ1, sâ2}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

The following formulae for binary meets and joins are often simpler to use
(and probably easier to understand) than the general definitions:
πZ
‹ meet2_cnj ?Ù µsâ1, sâ2 : SPEC∑ sâ1 %sqcap% sâ2 = (sâ1.1 ° sâ2.1, sâ1.2 ¿ sâ2.2)
∞
πZ
‹ join2_cnj ?Ù µsâ1, sâ2 : SPEC∑
‹	sâ1 %sqcup% sâ2 =
‹	 (	sâ1.1 ¿ sâ2.1, 
‹		((sâ1.1 ° sâ1.1) Ú (sâ1.2 ° sâ2.2))
‹	 ¿	((sâ1.1 \ sâ2.1) Ú sâ1.2)
‹	 ¿	((sâ2.1 \ sâ1.1) Ú sâ2.2))
∞
\section{Relations with Other Approaches}
In {\Unifying}, a theory based on total correctness is developed.
This theory is syntactic and involves various artifices that are on the face of it mainly introduced to
obtain various algebraic laws. 
A semantics and rather simpler account is given in {\TwoJims}.
Total correctness effectively means restricting attention to specification in our sense
in which the domain of the post-condition contains the pre-condition.
This has the advantage that, if we take the canonical representation, we can
discard the pre-condition since it may be recovered as the domain of the post-condition.

{\TwoJims} proceed to point out that for total relations, the notion of
refinement reduces to set-theoretic inclusion of relations. In this section we show that
this idea generalises to our partial correctness notion.  To do this we first introduce
some more notation:
=INLINEFT
XÁ‚Í
=TEX
\ is to be the result of augmenting a set $X$ with an additional element ‚.
We represent
=INLINEFT
XÁ‚Í
=TEX
\ as the set of all subsets of $X$ with at most one element:

πZ
‹ €X Á‚Í› ¶ { A : X | µx, y : A∑ x  = y}
∞

$\iota$ and ‚ are then defined as follows (and act very much as if they were constructors
of a generic free type).

ù[ X ]úúúúúúúúúúú
‹ €‚› : X Á‚Í ;
‹ €…› : X ≠ X Á‚Í 
˜¸¸¸¸¸¸
‹		‚ = ö;
‹µx : X∑ 	… x = {x}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

The function {\it lift} maps a specification in our sense to the relation between
augmented inputs and augmented outputs which agrees with the post-condition
where the pre-condition holds and is chaos outside the pre-condition.
This definition agrees with the one given in {\TwoJims} on specifications
that happen to be total\footnote{
In fact, we do not actually need to augment the input set $X$, an
analogue of {\it lift} could be defined mapping specifications to
relations between $X$ and
=INLINEFT
YÁ‚Í
=TEX
\ and this would carry refinements to inclusions just like the formulation here.
We have chosen to augment $X$ for uniformity with {\TwoJims} and because
this formulation seems likely to have nicer compositionality properties.
}.

ù[ X, Y ]úúúúúúúúúúú
‹ €lift› : SPEC[X, Y] ≠ X Á‚Í  ™ Y Á‚Í
˜¸¸¸¸¸¸
‹ µprec : PRE_COND[X]; postc : POST_COND[X, Y]∑
‹	lift(prec, postc) = 
‹	{ xa : XÁ‚Í; ya : YÁ‚Í
‹	|	xa = ‚
‹	≤	(∂x : X∑ ≥x ç prec ± xa = … x)
‹	≤	(∂x : X; y : Y∑ x ç prec ± (x, y) ç postc ± xa = … x± ya = … y) }
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

We can now claim the theorem that refinement as we have defined it is equivalent to
inclusion of the lifted relations.

πZ
‹ refinement_lift_cnj ?Ù µsâ1, sâ2: SPEC∑ sâ1 √ sâ2 § lift sâ2 Ä lift sâ1
∞
Together with earlier results this shows that our refinement ordering is isomorphic
to a complete sublattice of the lattice of relations on the sets of augmented inputs and outputs.
Our final theorem characterises this sublattice.
πZ
‹ ran_lift_cnj ?Ù
‹	ran lift =
‹	{	r : (_Á‚Í) ™ (_Á‚Í)
‹	|	µx:(_Á‚Í); y : (_Á‚Í)∑ (‚, y) ç r ± ((x, ‚) ç r ¥ (x, y) ç r)}
∞
=TEX

\bibliographystyle{plain}
\bibliography{bookspapers}
\newpage
\appendix
=TEX
{\HOLindexOff\small
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{refcalc.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%
%% Comment out next line to include the proofs in the printed document:
\end{document}

\section{Proofs}
=TEX
\ftlinepenalty=999
=SML
open_theory"refinement";
delete_pc"'refcalc" handle Fail _ => ();
new_pc "'refcalc";
set_pc"z_library1";
set_goal([], Ò
	PRED = U
±	PRE_COND = U
±	POST_COND = U
±	SPEC = U
Æ);
a(rewrite_tac(map z_get_spec[
	ÒPREDÆ,
	ÒPRE_CONDÆ,
	ÒPOST_CONDÆ,
	ÒSPECÆ
]));
a(PC_T1 "z_library_ext" prove_tac[]);
val €refcalc_u_thm› = save_pop_thm "refcalc_u_thm";
set_u_simp_eqn_cxt (u_simp_eqn_cxt [refcalc_u_thm]) "'refcalc";
set_merge_pcs["'refcalc", "z_library1"];
=TEX
=SML
fun  z_get_u_spec tm = (
	(z_gen_pred_elim(dest_z_tupleÒ(U, U)Æ) o z_get_spec) tm
	handle Fail _ => (z_gen_pred_elim[ÒUÆ] o z_get_spec) tm
);
=TEX
=SML
set_goal([], Òµ sâ1, sâ2 : U∑
	sâ1 √ sâ2
	§ sâ1.1 Ä sâ2.1
	± sâ1.1 Ú sâ2.2 Ä sâ1.2Æ);
a(z_µ_tac);
a(LEMMA_TÒsâ1 = (sâ1.1, sâ1.2) ± sâ2 = (sâ2.1, sâ2.2)Æ pure_once_rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" REPEAT strip_tac);
a(pure_rewrite_tac[z_get_u_spec Ò(_√_)Æ]);
a(rewrite_tac[]);
val €refines_def› = save_pop_thm "refines_def";
=TEX
=SML
set_goal([], Òµ s: U∑
	sÁ$Í = (s.1, s.1 Ú s.2)
Æ);
a(z_µ_tac);
a(LEMMA_TÒs = (s.1, s.2) Æ pure_once_rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" REPEAT strip_tac);
a(rewrite_tac[z_get_u_spec Ò(_Á$Í)Æ]);
val €reduce_def› = save_pop_thm "reduce_def";
=TEX
=SML
val €equiv_def› = save_thm( "equiv_def" , ±_right_elim (z_get_u_specÒ(_È_)Æ));
val €true_def› = save_thm( "true_def" , ±_right_elim (z_get_u_specÒTRUEÆ));
val €abort_def› = save_thm( "abort_def" , ±_right_elim (z_get_u_specÒABORTÆ));
val €forbidden_def› = save_thm( "forbidden_def" , ±_right_elim (z_get_u_specÒForbiddenÆ));
val €meet_def› = save_thm( "meet_def" , ±_right_elim (z_get_u_specÒMeetÆ));
val €join_def› = save_thm( "join_def" , ±_right_elim (z_get_u_specÒJoinÆ));
val €reduced_def› = save_thm( "reduced_def" , z_get_u_specÒREDUCEDÆ);
val €meet2_def› = save_thm( "meet2_def" , ±_right_elim (z_get_u_specÒ(_%sqcap%_)Æ));
val €join2_def› = save_thm( "join2_def" , ±_right_elim (z_get_u_specÒ(_%sqcup%_)Æ));
=TEX
=SML
set_goal([], get_conjecture"-" "reduce_reduce_cnj");
a(rewrite_tac[reduce_def, equiv_def] THEN
	PC_T1 "z_library_ext" asm_prove_tac[]);
val €reduce_reduce_thm› = save_pop_thm "reduce_reduce_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "equiv_cnj");
a(rewrite_tac[refines_def, reduce_def, equiv_def,
	pc_rule1 "z_sets_ext" prove_rule[] ÒµA, B : U∑ A = B § A Ä B ± B Ä AÆ]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €equiv_thm› = save_pop_thm "equiv_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "refinement_pre_order_cnj");
a(rewrite_tac[refines_def] THEN PC_T1 "z_library_ext" prove_tac[]);
a(REPEAT (all_asm_fc_tac[]));
val €refinement_pre_order_thm› = save_pop_thm "refinement_pre_order_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "refinement_reduce_cnj");
a(rewrite_tac[refines_def, reduce_def] THEN PC_T1 "z_library_ext" prove_tac[]);
val €refinement_reduce_thm› = save_pop_thm "refinement_reduce_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "refinement_antisym_cnj");
a(rewrite_tac[rewrite_rule[equiv_def] equiv_thm, z_get_specÒREDUCEDÆ] THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN POP_ASM_T ante_tac);
a(rewrite_tac[reduce_reduce_thm]);
val €refinement_antisym_thm› = save_pop_thm "refinement_antisym_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "bottom_top_cnj");
a(rewrite_tac[abort_def, true_def, refines_def] THEN REPEAT strip_tac);
val €bottom_top_thm› = save_pop_thm "bottom_top_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "refinement_meet_cnj");
a(rewrite_tac[refines_def, meet_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" asm_prove_tac[]);
a(z_spec_nth_asm_tac 1 Òt.1Æ);
a(z_spec_nth_asm_tac 1 ÒtÆ);
(* *** Goal "2" *** *)
a(PC_T1 "z_library_ext" asm_prove_tac[]);
a(z_∂_tac Òt.2Æ THEN REPEAT strip_tac);
a(z_∂_tac ÒtÆ THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "4" *** *)
a(POP_ASM_T ante_tac THEN PC_T1 "z_library_ext" rewrite_tac[] THEN REPEAT strip_tac);
a(z_spec_nth_asm_tac 5 Òs'Æ);
a(z_spec_nth_asm_tac 1 Ò(x1 ¶ x1, x2 ¶ x2)Æ);
a(z_spec_nth_asm_tac 5 Ò(x1 ¶ x1, x2 ¶ x2)Æ);
val €refinement_meet_thm› = save_pop_thm "refinement_meet_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "forbidden_def_cnj");
a(rewrite_tac[refines_def, forbidden_def, abort_def, true_def] THEN REPEAT strip_tac);
a(PC_T1 "z_library_ext" asm_prove_tac[] THEN REPEAT strip_tac);
val €forbidden_def1› = save_pop_thm "forbidden_def1";
=TEX
=SML
set_goal([], get_conjecture"-" "forbidden_cnj");
a(rewrite_tac[refines_def, forbidden_def1] THEN REPEAT strip_tac THEN
	PC_T1 "z_library_ext" asm_prove_tac[]);
val €forbidden_thm› = save_pop_thm "forbidden_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "join_def_cnj");
a(rewrite_tac[join_def, forbidden_def1, refcalc_u_thm, reduce_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_sets_ext" once_rewrite_tac[] THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1.1" *** *)
a(asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(z_∂_tacÒs.1Æ THEN REPEAT strip_tac THEN asm_prove_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T Òﬁ {s : A | true∑ s.1 Ú s.2} = {s : A; x : U;  y : U | x ç s.1 ± (x, y) ç s.2∑ (x, y)}Ærewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(z_∂_tacÒ(s¶s, x¶x1, y¶x2)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "2.1.2" *** *)
a(all_var_elim_asm_tac);
a(z_∂_tacÒs.1 Ú s.2Æ THEN PC_T1 "z_library_ext" asm_prove_tac[]);
a(z_∂_tacÒsÆ THEN PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(LEMMA_TÒ ﬁ {s : A | true∑ {x : U;  y : U | x ç s.1 ± ≥ (x, y) ç s.2}} =
	{s : A; x : U;  y : U | x ç s.1 ± ≥(x, y) ç s.2∑ (x, y)}Ærewrite_thm_tac);
(* *** Goal "2.2.1" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "2.2.1.1" *** *)
a(z_∂_tacÒ(s¶s, x¶x1, y¶x2)Æ THEN asm_rewrite_tac[]);
a(z_spec_nth_asm_tac 2 Ò(x1¶x1, x2¶x2)Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.1.2" *** *)
a(all_var_elim_asm_tac);
a(z_∂_tacÒ{x : U;  y : U|x ç s.1 ± ≥ (x, y) ç s.2}Æ THEN asm_rewrite_tac[]);
a(z_∂_tacÒsÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(PC_T1 "z_sets_ext" REPEAT strip_tac);
(* *** Goal "2.2.2.1" *** *)
a(all_var_elim_asm_tac);
a(z_∂_tacÒ(s¶s, x¶x1, y¶x2)Æ THEN asm_rewrite_tac[]);
a(swap_nth_asm_concl_tac 1 THEN REPEAT strip_tac);
a(z_∂_tacÒ(s¶t, x¶x1, y¶x2)Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(all_var_elim_asm_tac);
a(z_∂_tacÒ(s¶s, x¶x1, y¶x2)Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.3" *** *)
a(contr_tac THEN all_var_elim_asm_tac);
a(all_asm_fc_tac[]);
val €join_def_thm› = save_pop_thm "join_def_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "forbidden_join_cnj");
a(rewrite_tac[join_def_thm, forbidden_def1, refcalc_u_thm] THEN REPEAT strip_tac);
a(LEMMA_TÒ ﬁ {s : A | true∑ {x : U; y : U | x ç s.1 ± ≥ (x, y) ç s.2}} =
	{s : A; x : U; y : U | x ç s.1 ± ≥(x, y) ç s.2∑ (x, y)}Ærewrite_thm_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(z_∂_tacÒ(s¶s, x¶x1, y¶x2)Æ THEN asm_rewrite_tac[]);
a(z_spec_nth_asm_tac 2 Ò(x1¶x1, x2¶x2)Æ THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(all_var_elim_asm_tac);
a(z_∂_tacÒ{x : U;  y : U|x ç s.1 ± ≥ (x, y) ç s.2}Æ THEN asm_rewrite_tac[]);
a(z_∂_tacÒsÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "2.1" *** *)
a(swap_nth_asm_concl_tac 1 THEN REPEAT strip_tac);
a(z_∂_tacÒ(s¶s, x'¶x1, y'¶x2)Æ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(swap_nth_asm_concl_tac 1 THEN REPEAT strip_tac);
a(z_∂_tacÒ(s¶s, x¶x1, y¶x2)Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a(swap_nth_asm_concl_tac 3 THEN REPEAT strip_tac);
a(z_∂_tacÒ(s¶t, x¶x1, y¶x2)Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(asm_prove_tac[]);
(* *** Goal "2.3" *** *)
a(contr_tac THEN all_var_elim_asm_tac THEN asm_prove_tac[]);
val €forbidden_join_thm› = save_pop_thm "forbidden_join_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "refinement_join_cnj");
a(rewrite_tac[forbidden_thm, forbidden_join_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[join_def] THEN PC_T1 "z_library_ext" asm_prove_tac[]);
a(z_∂_tac Òt.1Æ THEN REPEAT strip_tac);
a(z_∂_tac ÒtÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[join_def] THEN PC_T1 "z_sets_ext" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(rewrite_tac[join_def] THEN PC_T1 "z_sets_ext" REPEAT strip_tac);
a(z_spec_nth_asm_tac 2 Òx1Æ);
a(PC_T1 "z_sets_ext" all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(PC_T1 "z_sets_ext" prove_tac[]);
a(z_spec_nth_asm_tac 3 Ò(x1¶x1, x2¶x2)Æ);
a(PC_T1 "z_sets_ext" asm_prove_tac[]);
val €refinement_join_thm› = save_pop_thm "refinement_join_thm";
=TEX
=SML
set_goal([], ÒµA, B : U ∏ U∑ {x:{A, B} ∑ x.1} = {A.1, B.1} ± {x:{A, B} ∑ x.2} = {A.2, B.2}Æ);
a(PC_T1"z_sets_ext" prove_tac[] THEN all_var_elim_asm_tac1 THEN_LIST
	(map( fn t => z_∂_tac t THEN REPEAT strip_tac) [ÒAÆ, ÒBÆ, ÒAÆ, ÒBÆ]));
val meet2_join2_lemma1 = pop_thm();
=TEX
=SML
set_goal([], ÒµA, B : U ∑ •{A, B} = A ° B ± ﬁ{A, B} = A ¿ BÆ);
a(PC_T1"z_sets_ext" asm_prove_tac[]);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1ÒAÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1ÒBÆ THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(contr_tac THEN z_spec_nth_asm_tac 1ÒAÆ THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(contr_tac THEN z_spec_nth_asm_tac 1ÒBÆ THEN REPEAT strip_tac);
val meet2_join2_lemma2 = pop_thm();
=TEX
=SML
set_goal([], Òµf: U ; A, B : U ∑
		{x:{A, B} ∑ ((f x) ∫ (U ∏ U)).1} = {(f A).1, (f B).1} 
	±	{x:{A, B} ∑ (f x).2} = {(f A).2, (f B).2}Æ);
a(PC_T1"z_sets_ext" prove_tac[] THEN all_var_elim_asm_tac1 THEN REPEAT strip_tac THEN_LIST
	(map( fn t => z_∂_tac t THEN REPEAT strip_tac) [ÒAÆ, ÒBÆ, ÒAÆ, ÒBÆ]));
val meet2_join2_lemma3 = pop_thm();
=TEX
=SML
set_goal([], Òµf: U ; A, B : U ∑ {x:{A, B} ∑ (f x)} = {(f A), (f B)} Æ);
a(PC_T1"z_sets_ext" prove_tac[] THEN all_var_elim_asm_tac1 THEN REPEAT strip_tac THEN_LIST
	(map( fn t => z_∂_tac t THEN REPEAT strip_tac) [ÒAÆ, ÒBÆ]));
val meet2_join2_lemma4 = pop_thm();
=TEX
=SML
set_goal([], get_conjecture"-" "meet2_cnj");
a(rewrite_tac[meet2_def, meet_def, meet2_join2_lemma1, meet2_join2_lemma2]);
val €meet2_thm› = save_pop_thm "meet2_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "join2_cnj");
a(rewrite_tac[join2_def, join_def, meet2_join2_lemma1, meet2_join2_lemma2,
	meet2_join2_lemma3, meet2_join2_lemma4]);
a(rewrite_tac[reduce_def, forbidden_def1, refcalc_u_thm]);
a(PC_T1"z_library_ext" prove_tac[]);
val €join2_thm› = save_pop_thm "join2_thm";
=TEX
The proofs concerned with lifting are a bit fiddly. Life would be much easier if Z did support
generic free types. Unfortunately (and inevitably) with Z as it is, the set theoretic representation
of the augmented sets means that the proof contexts which use extensionality will cut
too deep.
=SML
set_goal([], Ò
	(µx: U∑ ≥ … x  = ‚  ± ≥ ‚ = … x) 
±	(µx, y: U∑ … x  = … y § x = y) 
Æ);
a(rewrite_tac[z_get_u_specÒ…Æ]);
a(PC_T1 "z_library_ext"prove_tac[]);
val …_clauses = save_pop_thm "…_clauses";
=TEX
=SML
set_goal([], Ò
	(µx: U∑  … x  ç (_Á‚Í)) 
±	‚ ç (_Á‚Í)
Æ);
a(rewrite_tac[z_get_u_specÒ…Æ, z_get_u_specÒ(_Á‚Í)Æ]);
a(PC_T1 "z_library_ext"prove_tac[]);
val …_ç_clauses = save_pop_thm "…_ç_clauses";
=TEX
=SML
set_goal([], Ò
	(µt: X Á‚Í∑ t = ‚ ≤ (∂x:X∑t = … x)) 
Æ);
a(rewrite_tac[z_get_specÒ(_Á‚Í)Æ, z_get_u_specÒ…Æ, z_get_u_specÒ‚Æ]);
a(PC_T1 "z_library_ext" REPEAT strip_tac);
a(z_∂_tacÒx1Æ THEN PC_T1 "z_library_ext" asm_prove_tac[]);
val augmented_cases_thm = save_pop_thm "augmented_cases_thm";
=TEX
=SML
set_goal([], Ò
	(µt: (_ Á‚Í)∑ t = ‚ ≤ (∂x:U∑t = … x)) 
Æ);
a(rewrite_tac[z_get_specÒ(_Á‚Í)Æ, z_get_u_specÒ…Æ, z_get_u_specÒ‚Æ]);
a(PC_T1 "z_library_ext" REPEAT strip_tac);
a(z_∂_tacÒx1Æ THEN PC_T1 "z_library_ext" asm_prove_tac[]);
val augmented_u_cases_thm = save_pop_thm "augmented_u_cases_thm";
=TEX
=SML
set_goal([], Ò 
µs: SPEC∑
	lift s =
	{ xa : (_Á‚Í); ya : (_Á‚Í)
	|	xa = ‚
	≤	(∂x : U∑ ≥x ç s.1 ± xa = … x)
	≤	(∂x : U; y : U∑ x ç s.1 ± (x, y) ç s.2 ± xa = … x± ya = … y) }
Æ);
a(REPEAT strip_tac);
a(LEMMA_T Òs = (s.1, s.2)Æ once_rewrite_thm_tac THEN1 PC_T1 "z_library_ext" prove_tac[]);
a(rewrite_tac[z_get_u_specÒliftÆ]);
val lift_u_def_thm = save_pop_thm "lift_u_def_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "refinement_lift_cnj");
a(rewrite_tac[refines_def, lift_u_def_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(i_contr_tac THEN POP_ASM_T ante_tac THEN rewrite_tac[] THEN REPEAT strip_tac);
a(z_∂_tacÒxÆ THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [3, 7] (MAP_EVERY ante_tac) THEN PC_T1 "z_sets_ext" prove_tac[]);
(* *** Goal "1.2" *** *)
a(z_spec_nth_asm_tac 1 ÒxÆ);
a(z_∂_tacÒ(x ¶ x, y ¶ y)Æ THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [1, 6, 10] (MAP_EVERY ante_tac) THEN PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T (PC_T1 "z_library_ext" strip_asm_tac));
a(PC_T "z_sets_ext" strip_tac THEN REPEAT strip_tac);
a(contr_tac);
a(DROP_NTH_ASM_T 3 (ante_tac o z_µ_elimÒ(x1 ¶ …  x1, x2 ¶ (‚ ∫ (ran (sâ1.2) Á‚Í)))Æ));
a(asm_rewrite_tac[…_ç_clauses] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(z_spec_nth_asm_tac 1 Òx1Æ);
(* *** Goal "2.2" *** *)
a(rewrite_tac[…_clauses]);
(* *** Goal "2.3" *** *)
a(all_fc_tac[…_clauses] THEN all_var_elim_asm_tac1);
(* *** Goal "2.4" *** *)
a(all_fc_tac[…_clauses]);
(* *** Goal "3" *** *)
a(POP_ASM_T (PC_T1 "z_library_ext" strip_asm_tac));
a(PC_T "z_sets_ext" strip_tac THEN REPEAT strip_tac);
a(contr_tac);
a(DROP_NTH_ASM_T 3 (ante_tac o z_µ_elimÒ(x1 ¶ …  x1, x2 ¶  … x2)Æ));
a(asm_rewrite_tac[…_clauses, …_ç_clauses] THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(z_spec_nth_asm_tac 1 Òx1Æ);
a(z_∂_tacÒ(x ¶  x1, y ¶  x2)Æ THEN PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "3.2" *** *)
a(all_var_elim_asm_tac THEN PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "3.3" *** *)
a(all_var_elim_asm_tac THEN PC_T1 "z_library_ext" asm_prove_tac[]);
val refinement_lift_thm = save_pop_thm"refinement_lift_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "ran_lift_cnj");
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (PC_T1 "z_library_ext" strip_asm_tac));
a(asm_tac (prove_rule[]Òx ç SPECÆ));
a(strip_asm_tac(±_left_elim(z_get_u_specÒliftÆ)));
a(all_fc_tac[z_fun_ç_clauses]);
a(all_fc_tac[z_fun_app_clauses] THEN all_var_elim_asm_tac1);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 3 (PC_T1 "z_library_ext" strip_asm_tac));
a(asm_tac (prove_rule[]Òx' ç SPECÆ));
a(strip_asm_tac(±_left_elim(z_get_u_specÒliftÆ)));
a(all_fc_tac[z_fun_app_clauses] THEN all_var_elim_asm_tac1);
a(all_asm_ante_tac THEN rewrite_tac[lift_u_def_thm, …_ç_clauses] THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(DROP_NTH_ASM_T 4 (PC_T1 "z_library_ext" strip_asm_tac));
a(asm_tac (prove_rule[]Òx' ç SPECÆ));
a(strip_asm_tac(±_left_elim(z_get_u_specÒliftÆ)));
a(all_fc_tac[z_fun_app_clauses] THEN all_var_elim_asm_tac1);
a(all_asm_ante_tac THEN rewrite_tac[lift_u_def_thm] THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(DROP_NTH_ASM_T 4 discard_tac THEN all_var_elim_asm_tac1);
a(z_spec_nth_asm_tac 1 Òx''Æ);
(* *** Goal "3.2" *** *)
a(all_fc_tac[…_clauses]);
(* *** Goal "4" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN REPEAT strip_tac);
a(z_∂_tacÒ
	({I:U | ≥(… I, ‚)ç x1}, {I:U; O:U | (… I, … O) ç x1})
Æ THEN REPEAT strip_tac);
a(asm_tac (prove_rule[]Ò({I:U | ≥(… I, ‚)ç x1}, {I:U; O:U | (… I, … O) ç x1}) ç SPECÆ));
a(strip_asm_tac(±_left_elim(z_get_u_specÒliftÆ)));
a(ALL_FC_T1 fc_§_canon rewrite_tac[z_≠_ç_rel_§_app_eq_thm]);
a(rewrite_tac[lift_u_def_thm] THEN REPEAT strip_tac);
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(all_var_elim_asm_tac1 THEN ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "4.2" *** *)
a(all_var_elim_asm_tac1 THEN ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "4.3" *** *)
a(all_var_elim_asm_tac1 THEN ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "4.4" *** *)
a(LIST_GET_NTH_ASM_T [1, 5] (MAP_EVERY ante_tac) THEN PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "4.5" *** *)
a(LIST_GET_NTH_ASM_T [1, 5] (MAP_EVERY ante_tac) THEN PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "4.6" *** *)
a(lemma_tacÒx2 ç (_Á‚Í) ± x3 ç (_Á‚Í)Æ THEN1
	(LIST_GET_NTH_ASM_T [3, 7] (MAP_EVERY ante_tac) THEN PC_T1 "z_library_ext" prove_tac[]));
a(all_fc_tac[augmented_u_cases_thm] THEN all_var_elim_asm_tac1);
a(z_spec_nth_asm_tac 3 ÒxÆ);
a(cases_tacÒx3 = ‚Æ THEN1 all_var_elim_asm_tac1);
a(all_fc_tac[augmented_u_cases_thm] THEN all_var_elim_asm_tac1);
a(z_∂_tacÒ(x'' ¶ x, y ¶ x')Æ THEN REPEAT strip_tac);
val ran_lift_thm = save_pop_thm"ran_lift_thm";
=TEX
\section{Epilogue}
=SML
z_output_theory{out_file="refcalc.th.doc", theory="-"};
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
=TEX
\end{document}
