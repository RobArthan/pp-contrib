=IGN
# N.B. This document was prepared in ProofPower V2.5.4 but should work on 2.5.1 or later
# and probably earlier as well.
#
# To process the document in batch:
pp_make_database -f -p zed refcalc
docsml refcalc
pp -i refcalc -d refcalc </dev/null >refcalc.run.log
doctex refcalc refcalc.th
texdvi refcalc
texdvi refcalc
# That will give you a document "refcalc.dvi" to print off and read.
# To process the document interactively:
pp_make_database -f -p zed refcalc
xpp -f refcalc.doc -c pp -d refcalc &
# then either do use_file"refcalc" to load the lot and start interacting with
# the results, or, select-and-execute your way through a chunk at a time.
=TEX
\documentclass[12pt]{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\def\Hide#1{\relax}
%Macros for references (to be converted to bibtex presently).
\def\Unifying{{\it Hoare \& He}}
\def\Methods{{\it Jones}}
\title{On Refinement Calculus and Partial Correctness \\ (DRAFT)}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\section{Introduction}\label{Intro}
\subsection{Background and Motivation}

This note is the first of a series concerned with a style of system specification in which
the claims that can be verified have the form ``system $p$
satisfies specification $s$ under normal circumstances''.
This notion of correctness is traditionally referred to as partial correctness,
although a more impartial term such as ``algorithmic correctness'' is
preferred by some.
A total correctness claim has the form ``system $p$
always satisfies specification $s$''.

I should explain what is meant by ``normal circumstances'':
we have in a mind some notion of mathematically rigorous system
specification. Such a notion will always be relative to some conventions
and assumptions about the relationship between the mathematical model
and the physical systems under consideration. For example, in
program specification, the modelling conventions might be the abstractions
involved in a formal semantics for the programming language and the modelling
assumptions might include an assumption that  no exceptions are raised causing control to pass
from the programming language execution environment to the operating
system under which it runs. We take normal circumstances to be those
in which the modelling assumptions hold --- abnormal circumstances are those
in which the model breaks down and something external to the model is required
to deal with the situation.


For many practical purposes, partial correctness is
a much more useful notion than total correctness.
For example, in program analysis, tools other than formal specification and proof may be
better suited to automatic analysis of normal termination.
Furthermore, partial correctness claims have the clear advantage
of sometimes being true in physical reality, whereas total
correctness claims never are (e.g., consider what happens when a
power supply fails). We believe the partial correctness approach
is much closer in spirit to normal engineering practice: no engineered
artefact is perfect. Much of the work in any engineering task is
in combining potentially faulty subsystems so as to
produce a system that is adequately resilient for its intended
purpose. 

Some technologies, such as programming languages, apparently offer
the possibility of formal proof of total correctness. However, such a proof
is always relative to some mathematical model which is invariably an idealisation
of the physical reality of the delivered artefact. While this possibility is
of considerable theoretical importance, we believe that there is considerable
practical value in having a mathematically rigorous theory that reflects the
potential for failure in any engineered component.

The original motivation for this work lay in program specification.
However, it became clear that with just a little additional abstraction,
much of the theory has a much wider domain of application.
In this first note, we look at a very general class of systems and system
specifications. 

The most general notion of the act of specifying a system is first to identify some
set $P$ of possible systems and then to identify a subset $A \subseteq P$
of acceptable systems. We may call this the {\it property-based} approach.
It is advocated in {\Methods}
as a general method for specifying and verifying critical system properties.
The advantages and disadvantages of this view both lie in its
generality: on the one hand, it is clearly adequate to deal with any system property
that is amenable to any form of mathematical specification, on the other hand
it gives no guidance whatsoever as to how to proceed: the modelling conventions
and assumptions in any given situation need to be carefully designed and inspected
to ensure they are fit for their intended purpose.

An approach that has a very long tradition, particularly in program verification,
is to observe that almost any system can be viewed as some kind of binary
relation, say between inputs and outputs, or between successive states
of a state transition machine. This {\it relational} approach leads to a notion
of {\em refinement} whereby implementations are viewed as
binary relations of the same kind  as are used for specifications and refinement
rules are given defining what a valid implementation of a specification is.
(The corresponding notion for the property-based approach is just set-theoretic
inclusion or membership. The refinement rules give more useful insights
in the relational approach.)


In a relatively recent work, {\Unifying}, this approach is advocated
as providing a unifying framework for dealing with a wide class of programming
languages and programs. However, the approach as described in {\Unifying} is
heavily biased towards the total correctness viewpoint. This actually leads to
considerable technical complications and the solutions taken in {\Unifying}
lead to counter-intuitive results: for example,  they preclude the design of
a system which can create order from chaos --- a very common engineering
requirement.

It is certainly possible to adapt the relational approach to give a notion
of partial correctness. Indeed, the approach we will take in this note
embraces this as a special case. However, viewing specifications as
binary relations leads to a significant loss of expressiveness in
the partial correctness version. The problem is that when dealing with
the possibility of failure, the specifier may need to
demand failure under certain circumstances. Unfortunately, the relational approach
gives no way of distinguishing between cases where failure is required
and cases where the behaviour is unspecified.
Our approach is to augment the binary relation with a set indicating
the domain in which the specifier has a definite interest in behaviour.
This is, essentially just the pre- and post-condition style of
specification that is familiar from Floyd-Hoare logic and notations like
VDM. However, the partial correctness interpretation of the pre-condition
makes it play a much more important role than it does in a total
correctness approach (which is why {\Unifying} is able to do without it,
except as a syntactic convention).


Please note this is work-in-progress and the current version of
this note lacks any serious attempt to cite the literature or
compare the results with other work.


\subsection{Notation}

We will develop our theory using the Z notation. We will give definitions in Z and
state our theorems as Z conjectures. The Z definitions have all been type-checked 
and the conjectures have all been proved using the {\Product} system. The master
of this document is in fact a {\Product} literate script which can be processed
automatically to check the definitions and replay the proofs. For brevity, the
proof commands are suppressed from the printed form of the document.


\Hide{
The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"z_library";
set_pc"z_library1";
force_delete_theory"refinement" handle Fail _ => ();
new_theory"refinement";
ReaderWriterSupport.PrettyNames.add_new_symbols[
	(["refinedby"], Value "Ã", ReaderWriterSupport.PrettyNames.Simple), 
	(["ident"], Value "é", ReaderWriterSupport.PrettyNames.Simple)
] handle Fail _ => ();
=TEX
}

We use infix notation for the following relation
and function symbols:
¹Z
Ü rel _ Ã _, _ %models% _, _ é_, _ â _
°
¹Z
Ü fun 7 _ %sqcap% _, _ %sqcup% _, _ ç$ê
°
We use postfix notation for the following function symbol:
¹Z
Ü fun 7 _ ç$ê
°





\section{States , Pre-conditions, Post-conditions}\label{STATE}

[TBD: in the following the term ``state'' needs to be replaced by a more neutral term. ]

We wish to construct a semantic model of specification of state transformations
via pre- and post-conditions.
The internal structure of states is not relevant to our purposes for the time being
--- our definitions will be generic with respect to the set, $S$, of all states.
For a conventional imperative programming language, the states will be
assignments of values to program variables.

In our model, a predicate on states is just a set of states, i.e., the denotation of the
usual syntactic notion of a predicate.

¹Z
Ü ÛPREDÝ[X] ¦ ðX
°

Syntactically, a pre-condition is a predicate whose free variables are program variables and a post-condition is a predicate whose free variables are
program variables with optional decoration to distinguish values in the before-state
from values in the after-state.
A pre-condition denotes the set of assignments, $\alpha$, in which the program
variables satisfy the pre-condition and a post-condition denotes
the relation, $\rho$, which holds between two states $s$ and $s'$ when $s \times s'$
satisfies the post-condition after makihng the appropriate binding of before- and after-values
to the variables in the post-condition.

Taken together, we can often think of the pre- and post-condition as denoting the state transformer
=INLINEFT
Á ò Ò
=TEX
.
However,as we will be making
formal presently, our reading of a specification requires the program
not to terminate in before-states that satisfy the pre-condition but to
which the post-condition cannot respond.
Consequently we lose some expressiveness if we throw away the pre-condition,
for example, if the post-condition is unsatisfiable, the pre-condition
defines a set of states in which the program must not terminate.
We therefore keep a separate record of the pre-condition. 
So a specification is a pair comprising a predicate giving the pre-condition
and a binary relation on states giving the post-condition.
¹Z
Ü ÛPRE_CONDÝ[X] ¦ PRED[X]
°
¹Z
Ü ÛPOST_CONDÝ[X, Y] ¦ X ª Y
°
¹Z
Ü ÛSPECÝ[X, Y] ¦ PRE_COND[X] ¸ POST_COND[X, Y]
°

To give examples in the sequel, we will borrow some syntax from the Compliance Notation, in 
which states comprise assignments of values to program variables representing the execution
state of an Ada program.
In the Compliance Notation, specifications using {\em specification statements}
which have the following general form:
{
\vertbarfalse

=GFT
	 %calW% [%calP%, %calQ% ]
=TEX
where $\cal W$ is a list of program variables called the {\it frame} and
$\cal P$ and $\cal Q$ are syntactic predicates giving the pre-condition and post-condition respectively.
In the post-condition a subscript 0 may be used
to distinguish variables that refer to the before-state from variables that refer to the after-state.
The frame lists the program variables that may be changed by the code being specified.
For example, here are specification statements for {\em(a)} a fragment of code
that exchanges the value of two program variables, $X$ and $Y$, possibly with a side-effect on a third
variable, $T$; and, {\em(b)} a fragment of code that divides one variable, $Y$, by
another, $X$, subject to the pre-condition that $X$ be positive.

=GFT
	 X, Y , T [true, X = Y0 ± Y = X0]			(a)
	 Y [X > 0, Y = Y0 / X ]				(b)
=TEX

In our semantic view, a syntactic specification statement of this sort denotes a specification
in the above semantic sense whose pre-condition
is the denotation of the given syntactic pre-condition and whose post-condition is
the relation denoted by the given post-condition conjoined with the requirement that any variable
not listed in the frame must be unchanged.

}
\section{Refinement}\label{refines}
Refinement is a notion that is fundamental to this work.
Refinement is the relation that obtains between a specification and a satisfactory implementation
of that specification, where, in
the present context an ``implementation'' is simply a specification, typically more
definite than the specification it refines. Since we are only concerned with partial
correctness, we consider an implementation to be satisfactory even if it fails to respond
in some situations where the specification appears to require a response.
More formally, we will say that one specification, 
=INLINEFT
s2 = (prec2, postc2)
=TEX
\ refines another
=INLINEFT
s1 = (prec1, postc1)
=TEX
\ iff:
\begin{itemize}
\item
=INLINEFT
prec2
=TEX
\ includes
=INLINEFT
prec1
=TEX
; and:
\item the restriction of
=INLINEFT
postc2
=TEX
\ to
=INLINEFT
prec1
=TEX
\ is contained in
=INLINEFT
postc1
=TEX
.
\end{itemize}
The first of these conditions is a vestigial analogue of liveness in our partial
correctness view of refinement.
The traditional notion of liveness allows the pre-condition to be weakened
but requires
=INLINEFT
postc2
=TEX
\ to be at least as responsive as
=INLINEFT
postc1
=TEX
\ in states where
=INLINEFT
prec1
=TEX
\ holds.
Here, we do not impose the latter requirement.
We just say is that $s_2$ may not strengthen the
pre-condition of $s_1$: this amounts to saying that $s_2$ must not be
less specific than $s_1$ in its requirements for non-termination.

The second condition is the traditional notion of safety --- it says that any response
made by $s_2$ in a state satisfying the pre-condition of $s_1$
is a response that could also be made by $s_1$. This
includes the possibility that $s_2$ may be unable to respond where $s_1$ can.

[ X, Y ]
Ü Û_ Ã _Ý : SPEC[X, Y] ª SPEC[X, Y]
÷üüüüüü
Ü µprec1, prec2 : PRE_COND[X]; postc1, postc2 : POST_COND[X, Y]·
Ü	(prec1, postc1) Ã (prec2, postc2)
Ü ¤	prec1  prec2
Ü ±	prec1 ò postc2  postc1
üüüüüüüüüüüüüü

We now explore the properties of the refinement relation. First of all, we note that
refinement is a pre-order (i.e., it is reflexive and transitive):
¹Z
Ü refinement_pre_order_cnj ?ô 
Ü	µ s1, s2 , s3: SPEC·
Ü		s1 Ã s1
Ü±		(s1 Ã s2 ± s2 Ã s3 ´ s1 Ã s3)
°

However, refinement is not antisymmetric, i.e., it is possible to have
$s_1 \sqsubseteq s_2$ and $s_2 \sqsubseteq s_1$ without having $s_1 = s_2$.
This happens because two specifications with the same post-condition may differ only
with respect to responses to before-states that do not satisfy the pre-condition
and are therefore irrelevant in our definition of refinement%
\footnote{
We could require all our specifications to be such that the
pre-condition contains the domain of the post-condition. We prefer not to impose this
restriction except where necessary. This is technically more convenient and is also
more faithful to actual examples, e.g, in the example,
=INLINEFT
 Y [X > 0, Y = Y0 / X ]
=TEX
\ that we have already discussed, the denotation of the post-condition considered
in isolation includes the possibility that $X$ be negative in the before-state.
}.
To remedy this, where necessary, let us say that two specifications are equivalent if they refine one another:

[X, Y]
Ü Û_ é _Ý : SPEC[X, Y] ª SPEC[X, Y]
÷üüüüüü
Ü µs1, s2 : SPEC[X, Y]·
Ü	s1 é s2 ¤ s1 Ã s2 ± s2 Ã s1
üüüüüüüüüüüüüü

That $\equiv$ is an equivalence relation follows from the fact that $\sqsubseteq$ is a pre-order.
The pre-order induces a pre-order on the equivalence classes which will necessarily also
be a partial order, i.e., it will also be antisymmetric.
Rather than work with equivalence classes in the sequel, we will work with canonical
representatives when necessary.
These canonical representatives are defined by the following which reduces a specification
to a normal form in which the post-condition is empty outside the pre-condition.
[X, Y]
Ü Û_ ç$êÝ : SPEC[X, Y] ­ SPEC[X, Y]
÷üüüüüü
Ü µprec : PRE_COND[X]; postc : POST_COND[X, Y]·
Ü	(prec, postc)ç$ê = (prec, prec ò postc)
üüüüüüüüüüüüüü

The reduction operator (which is useful enough to be worth the dollar in its name!) is
idempotent:
¹Z
Ü reduce_reduce_cnj ?ô µ s : SPEC· (sç$ê)ç$ê = sç$ê
°
The following theorem shows that the reduction operator does indeed pick
a canonical representative from each $\equiv$-equivalence class: 
¹Z
Ü equiv_cnj ?ô µ s1, s2 : SPEC· s1 é s2 ¤ s1ç$ê = s2ç$ê
°

Our next theorem says that
refinement is independent of choice of representative in each equivalence class:
=GFT
¹Z
Ü refinement_reduce_cnj ?ô µ s1, s2 : SPEC· s1 Ã s1 ¤ s1ç$ê Ã s1ç$ê
°
Let use define the {\em reduced} specifications to be those in the range of the reduction operator:
[X, Y]
Ü ÛREDUCEDÝ : ðSPEC[X, Y] 
÷üüüüüü
Ü 	REDUCED  = {s : SPEC· sç$ê}
üüüüüüüüüüüüüü

When restricted to reduced specifications, refinement does indeed become antisymmetric:
¹Z
Ü refinement_antisym_cnj ?ô µ s1, s2 : REDUCED· s1 Ã s2 ± s2 Ã s1 ´ s1 = s2
°
We now want to show that refinement of reduced specifications is a complete lattice.
We now define constants that help us state this and other results. First of all constants
relating to tops, bottoms etc. We use upper-case namesfor the contituents of specifications
and mixed upper-lower case names for specifications. 
[X]
Ü ÛTRUEÝ, ÛFALSEÝ : PRE_COND[X]
÷üüüüüü
Ü 	TRUE = X;
Ü	FALSE = 
üüüüüüüüüüüüüü

[X, Y]
Ü ÛABORTÝ : POST_COND[X, Y];
Ü ÛCHAOSÝ : PRE_COND[X] ­ POST_COND[X, Y];
Ü ÛAbortÝ, ÛChaosÝ : PRE_COND[X] ­ SPEC[X, Y];
Ü ÛBottomÝ , ÛTopÝ: SPEC[X, Y]
÷üüüüüü
Ü	ABORT = ;
Ü	µ prec : PRE_COND[X]·
Ü		CHAOS prec = prec ¸ Y
Ü	±	Abort prec = (prec, ABORT)
Ü	±	Chaos prec = (prec, CHAOS prec);
Ü	Bottom = Chaos ;
Ü	Top = Abort TRUE 
üüüüüüüüüüüüüü

Bottom and top are indeed the bottom and top elements of the pre-order:
¹Z
Ü bottom_top_cnj ?ô µ s : SPEC· Bottom Ã s Ã Top
°

Meets (greatest lower bounds) turn out to be straightforward to define and verify:
[X, Y]
Ü ÛMeetÝ : ðSPEC[X, Y] ­ SPEC[X, Y]
÷üüüü
ÜµA : ð SPEC[X, Y]· Meet A = (¥{s : A· s.1}, Þ{s : A· s.2})
üüüüüüüüüüüüüü
Now we can state the conjecture that meets are indeed greatest lower bounds.

¹Z
Ü refinement_meet_cnj ?ô 
Ü	µ A : ðSPEC· µt : A· Meet A Ã t;
Ü	µ A : ðSPEC; s : SPEC· (µt : A· s Ã t) ´ s Ã Meet A
°

Joins turn out to be trickier. We first define a function that maps
a specification, $s$ say to the post-condition that allows precisely those
state transitions that $s$ forbids forbids:
[X, Y]
Ü ÛForbiddenÝ : SPEC[X, Y] ­ POST_COND[X, Y]
÷üüüü
Üµs : SPEC[X, Y]·
Ü	Forbidden s = CHAOS (s.1) \ s.2
üüüüüüüüüüüüüü
A more explicit equation for fobidden sets is useful:
¹Z
Ü forbidden_def_cnj ?ô 
Ü	µ s : SPEC· 
Ü		Forbidden s = { x : U; y : U | x  s.1 ± ³(x, y)  s.2}
°
The following conjecture is useful to check the definition of the forbiden function and in proving
later results.
¹Z
Ü forbidden_cnj ?ô 
Ü	µ s1, s2 : SPEC· 
Ü		s1 Ã s2 ¤ s1.1  s2.1 ± s2.2 ¡ (Forbidden s1) = 
°

Now we can define joins. The pre-condition of the join of a set of
specifications is just the union of the individual pre-conditions.
The post-condition is obtained from  the union of the post-conditions by
removing all transitions that are forbidden by some specification in the set.
[X, Y]
Ü ÛJoinÝ : ðSPEC[X, Y] ­ SPEC[X, Y]
÷üüüü
ÜµA : ð SPEC[X, Y]·
Ü	Join A = (Þ{s : A· s.1}, (Þ{s : A·(sç$ê).2}) \ (Þ{s : A·Forbidden s}))
üüüüüüüüüüüüüü
In elementary working with join it is often more convenient to
have more explicit set comprehensions:
¹Z
Ü join_def_cnj ?ô 
Ü	µ A : ðSPEC· Join A = 
Ü		({s : A; x : U | x  s.1· x},
Ü		{s : A; x : U;  y : U
Ü		| x  s.1 ± (x, y)  s.2 ± (µt : A· x  t.1 ´ (x, y)  t.2)
Ü		· (x, y)})
°
It is useful to be able to calculate the forbidden set of a join
¹Z
Ü forbidden_join_cnj ?ô 
Ü	µ A : ðSPEC· 
Ü		Forbidden(Join A) = Þ{s : A· Forbidden s}
°
Now we can state the theorem that our joins are indeed least upper bounds.
¹Z
Ü refinement_join_cnj ?ô  
Ü	µ A : ðSPEC· µt : A· t Ã Join A;
Ü	µ A : ðSPEC; s : SPEC· (µt : A· t Ã s) ´ Join A Ã s
°

Given that arbitrary meets and joins exist, we can now define binary meets and joins in terms of them.
At this point, the observant reader who is not familiar with the traditions of our style of
specification will note that the passage from the language of set-theoretic inclusion, union and
intersection, to the language of refinement, meets and joins involves not only squaring off
the corners of the symbols but also looking at them upside down in a mirror. This is perhaps
unfortunate, but it is the tradition and we feel obliged to follow it.
[X, Y]
Ü Û_%sqcap%_Ý, Û_%sqcup%_Ý: SPEC[X, Y] ¸ SPEC[X, Y] ­ SPEC[X, Y]
÷üüüü
Üµs1, s2 : SPEC[X, Y]·
Ü	s1 %sqcap% s2 = Meet{s1, s2}
Ü±	s1 %sqcup% s2 = Join{s1, s2}
üüüüüüüüüüüüüü

The following formulae for binary meets and joins are often simpler to use
(and probably easier to understand) than the general definitions:
¹Z
Ü meet2_cnj ?ô µs1, s2 : SPEC· s1 %sqcap% s2 = (s1.1 ¡ s2.1, s1.2 À s2.2)
°
¹Z
Ü join2_cnj ?ô µs1, s2 : SPEC·
Ü	s1 %sqcup% s2 =
Ü	 (	s1.1 À s2.1, 
Ü		((s1.1 ¡ s1.1) ò (s1.2 ¡ s2.2))
Ü	 À	((s1.1 \ s2.1) ò s1.2)
Ü	 À	((s2.1 \ s1.1) ò s2.2))
°

\newpage
\appendix
=TEX
{\HOLindexOff\small
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{refcalc.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%
%% Comment out next line to include the proofs in the printed document:
\end{document}

\section{Proofs}
=TEX
\ftlinepenalty=999
=SML
delete_pc"'refcalc" handle Fail _ => ();
new_pc "'refcalc";
set_pc"z_library1";
set_goal([], ñ
	PRED = U
±	PRE_COND = U
±	POST_COND = U
±	SPEC = U
®);
a(rewrite_tac(map z_get_spec[
	ñPRED®,
	ñPRE_COND®,
	ñPOST_COND®,
	ñSPEC®
]));
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûrefcalc_u_thmÝ = save_pop_thm "refcalc_u_thm";
set_u_simp_eqn_cxt (u_simp_eqn_cxt [refcalc_u_thm]) "'refcalc";
set_merge_pcs["'refcalc", "z_library1"];
=TEX
=SML
fun  z_get_u_spec tm = (
	(z_gen_pred_elim(dest_z_tupleñ(U, U)®) o z_get_spec) tm
	handle Fail _ => (z_gen_pred_elim[ñU®] o z_get_spec) tm
);
=TEX
=SML
set_goal([], ñµ s1, s2 : U·
	s1 Ã s2
	¤ s1.1  s2.1
	± s1.1 ò s2.2  s1.2®);
a(z_µ_tac);
a(LEMMA_Tñs1 = (s1.1, s1.2) ± s2 = (s2.1, s2.2)® pure_once_rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" REPEAT strip_tac);
a(pure_rewrite_tac[z_get_u_spec ñ(_Ã_)®]);
a(rewrite_tac[]);
val Ûrefines_defÝ = save_pop_thm "refines_def";
=TEX
=SML
set_goal([], ñµ s: U·
	sç$ê = (s.1, s.1 ò s.2)
®);
a(z_µ_tac);
a(LEMMA_Tñs = (s.1, s.2) ® pure_once_rewrite_thm_tac
	THEN1 PC_T1 "z_library_ext" REPEAT strip_tac);
a(rewrite_tac[z_get_u_spec ñ(_ç$ê)®]);
val Ûreduce_defÝ = save_pop_thm "reduce_def";
=TEX
=SML
val Ûequiv_defÝ = save_thm( "equiv_def" , ±_right_elim (z_get_u_specñ(_é_)®));
val Ûtrue_defÝ = save_thm( "true_def" , ±_right_elim (z_get_u_specñTRUE®));
val Ûabort_defÝ = save_thm( "abort_def" , ±_right_elim (z_get_u_specñABORT®));
val Ûforbidden_defÝ = save_thm( "forbidden_def" , ±_right_elim (z_get_u_specñForbidden®));
val Ûmeet_defÝ = save_thm( "meet_def" , ±_right_elim (z_get_u_specñMeet®));
val Ûjoin_defÝ = save_thm( "join_def" , ±_right_elim (z_get_u_specñJoin®));
val Ûreduced_defÝ = save_thm( "reduced_def" , z_get_u_specñREDUCED®);
val Ûmeet2_defÝ = save_thm( "meet2_def" , ±_right_elim (z_get_u_specñ(_%sqcap%_)®));
val Ûjoin2_defÝ = save_thm( "join2_def" , ±_right_elim (z_get_u_specñ(_%sqcup%_)®));
=TEX
=SML
set_goal([], get_conjecture"-" "reduce_reduce_cnj");
a(rewrite_tac[reduce_def, equiv_def] THEN
	PC_T1 "z_library_ext" asm_prove_tac[]);
val Ûreduce_reduce_thmÝ = save_pop_thm "reduce_reduce_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "equiv_cnj");
a(rewrite_tac[refines_def, reduce_def, equiv_def,
	pc_rule1 "z_sets_ext" prove_rule[] ñµA, B : U· A = B ¤ A  B ± B  A®]);
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûequiv_thmÝ = save_pop_thm "equiv_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "refinement_pre_order_cnj");
a(rewrite_tac[refines_def] THEN PC_T1 "z_library_ext" prove_tac[]);
a(REPEAT (all_asm_fc_tac[]));
val Ûrefinement_pre_order_thmÝ = save_pop_thm "refinement_pre_order_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "refinement_reduce_cnj");
a(rewrite_tac[refines_def, reduce_def] THEN PC_T1 "z_library_ext" prove_tac[]);
val Ûrefinement_reduce_thmÝ = save_pop_thm "refinement_reduce_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "refinement_antisym_cnj");
a(rewrite_tac[rewrite_rule[equiv_def] equiv_thm, z_get_specñREDUCED®] THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN POP_ASM_T ante_tac);
a(rewrite_tac[reduce_reduce_thm]);
val Ûrefinement_antisym_thmÝ = save_pop_thm "refinement_antisym_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "bottom_top_cnj");
a(rewrite_tac[abort_def, true_def, refines_def] THEN REPEAT strip_tac);
val Ûbottom_top_thmÝ = save_pop_thm "bottom_top_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "refinement_meet_cnj");
a(rewrite_tac[refines_def, meet_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" asm_prove_tac[]);
a(z_spec_nth_asm_tac 1 ñt.1®);
a(z_spec_nth_asm_tac 1 ñt®);
(* *** Goal "2" *** *)
a(PC_T1 "z_library_ext" asm_prove_tac[]);
a(z_¶_tac ñt.2® THEN REPEAT strip_tac);
a(z_¶_tac ñt® THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "4" *** *)
a(POP_ASM_T ante_tac THEN PC_T1 "z_library_ext" rewrite_tac[] THEN REPEAT strip_tac);
a(z_spec_nth_asm_tac 5 ñs'®);
a(z_spec_nth_asm_tac 1 ñ(x1 ¦ x1, x2 ¦ x2)®);
a(z_spec_nth_asm_tac 5 ñ(x1 ¦ x1, x2 ¦ x2)®);
val Ûrefinement_meet_thmÝ = save_pop_thm "refinement_meet_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "forbidden_def_cnj");
a(rewrite_tac[refines_def, forbidden_def, abort_def, true_def] THEN REPEAT strip_tac);
a(PC_T1 "z_library_ext" asm_prove_tac[] THEN REPEAT strip_tac);
val Ûforbidden_def1Ý = save_pop_thm "forbidden_def1";
=TEX
=SML
set_goal([], get_conjecture"-" "forbidden_cnj");
a(rewrite_tac[refines_def, forbidden_def1] THEN REPEAT strip_tac THEN
	PC_T1 "z_library_ext" asm_prove_tac[]);
val Ûforbidden_thmÝ = save_pop_thm "forbidden_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "join_def_cnj");
a(rewrite_tac[join_def, forbidden_def1, refcalc_u_thm, reduce_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_sets_ext" once_rewrite_tac[] THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1.1" *** *)
a(asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(z_¶_tacñs.1® THEN REPEAT strip_tac THEN asm_prove_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T ñÞ {s : A | true· s.1 ò s.2} = {s : A; x : U;  y : U | x  s.1 ± (x, y)  s.2· (x, y)}®rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(z_¶_tacñ(s¦s, x¦x1, y¦x2)® THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "2.1.2" *** *)
a(all_var_elim_asm_tac);
a(z_¶_tacñs.1 ò s.2® THEN PC_T1 "z_library_ext" asm_prove_tac[]);
a(z_¶_tacñs® THEN PC_T1 "z_library_ext" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(LEMMA_Tñ Þ {s : A | true· {x : U;  y : U | x  s.1 ± ³ (x, y)  s.2}} =
	{s : A; x : U;  y : U | x  s.1 ± ³(x, y)  s.2· (x, y)}®rewrite_thm_tac);
(* *** Goal "2.2.1" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "2.2.1.1" *** *)
a(z_¶_tacñ(s¦s, x¦x1, y¦x2)® THEN asm_rewrite_tac[]);
a(z_spec_nth_asm_tac 2 ñ(x1¦x1, x2¦x2)® THEN REPEAT strip_tac);
(* *** Goal "2.2.1.2" *** *)
a(all_var_elim_asm_tac);
a(z_¶_tacñ{x : U;  y : U|x  s.1 ± ³ (x, y)  s.2}® THEN asm_rewrite_tac[]);
a(z_¶_tacñs® THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(PC_T1 "z_sets_ext" REPEAT strip_tac);
(* *** Goal "2.2.2.1" *** *)
a(all_var_elim_asm_tac);
a(z_¶_tacñ(s¦s, x¦x1, y¦x2)® THEN asm_rewrite_tac[]);
a(swap_nth_asm_concl_tac 1 THEN REPEAT strip_tac);
a(z_¶_tacñ(s¦t, x¦x1, y¦x2)® THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(all_var_elim_asm_tac);
a(z_¶_tacñ(s¦s, x¦x1, y¦x2)® THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.3" *** *)
a(contr_tac THEN all_var_elim_asm_tac);
a(all_asm_fc_tac[]);
val Ûjoin_def_thmÝ = save_pop_thm "join_def_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "forbidden_join_cnj");
a(rewrite_tac[join_def_thm, forbidden_def1, refcalc_u_thm] THEN REPEAT strip_tac);
a(LEMMA_Tñ Þ {s : A | true· {x : U; y : U | x  s.1 ± ³ (x, y)  s.2}} =
	{s : A; x : U; y : U | x  s.1 ± ³(x, y)  s.2· (x, y)}®rewrite_thm_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(z_¶_tacñ(s¦s, x¦x1, y¦x2)® THEN asm_rewrite_tac[]);
a(z_spec_nth_asm_tac 2 ñ(x1¦x1, x2¦x2)® THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(all_var_elim_asm_tac);
a(z_¶_tacñ{x : U;  y : U|x  s.1 ± ³ (x, y)  s.2}® THEN asm_rewrite_tac[]);
a(z_¶_tacñs® THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "2.1" *** *)
a(swap_nth_asm_concl_tac 1 THEN REPEAT strip_tac);
a(z_¶_tacñ(s¦s, x'¦x1, y'¦x2)® THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(swap_nth_asm_concl_tac 1 THEN REPEAT strip_tac);
a(z_¶_tacñ(s¦s, x¦x1, y¦x2)® THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a(swap_nth_asm_concl_tac 3 THEN REPEAT strip_tac);
a(z_¶_tacñ(s¦t, x¦x1, y¦x2)® THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(asm_prove_tac[]);
(* *** Goal "2.3" *** *)
a(contr_tac THEN all_var_elim_asm_tac THEN asm_prove_tac[]);
val Ûforbidden_join_thmÝ = save_pop_thm "forbidden_join_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "refinement_join_cnj");
a(rewrite_tac[forbidden_thm, forbidden_join_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[join_def] THEN PC_T1 "z_library_ext" asm_prove_tac[]);
a(z_¶_tac ñt.1® THEN REPEAT strip_tac);
a(z_¶_tac ñt® THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[join_def] THEN PC_T1 "z_sets_ext" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(rewrite_tac[join_def] THEN PC_T1 "z_sets_ext" REPEAT strip_tac);
a(z_spec_nth_asm_tac 2 ñx1®);
a(PC_T1 "z_sets_ext" all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(PC_T1 "z_sets_ext" prove_tac[]);
a(z_spec_nth_asm_tac 3 ñ(x1¦x1, x2¦x2)®);
a(PC_T1 "z_sets_ext" asm_prove_tac[]);
val Ûrefinement_join_thmÝ = save_pop_thm "refinement_join_thm";
=TEX
=SML
set_goal([], ñµA, B : U ¸ U· {x:{A, B} · x.1} = {A.1, B.1} ± {x:{A, B} · x.2} = {A.2, B.2}®);
a(PC_T1"z_sets_ext" prove_tac[] THEN all_var_elim_asm_tac1 THEN_LIST
	(map( fn t => z_¶_tac t THEN REPEAT strip_tac) [ñA®, ñB®, ñA®, ñB®]));
val meet2_join2_lemma1 = pop_thm();
=TEX
=SML
set_goal([], ñµA, B : U · ¥{A, B} = A ¡ B ± Þ{A, B} = A À B®);
a(PC_T1"z_sets_ext" asm_prove_tac[]);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1ñA® THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1ñB® THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(contr_tac THEN z_spec_nth_asm_tac 1ñA® THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(contr_tac THEN z_spec_nth_asm_tac 1ñB® THEN REPEAT strip_tac);
val meet2_join2_lemma2 = pop_thm();
=TEX
=SML
set_goal([], ñµf: U ; A, B : U ·
		{x:{A, B} · ((f x) º (U ¸ U)).1} = {(f A).1, (f B).1} 
	±	{x:{A, B} · (f x).2} = {(f A).2, (f B).2}®);
a(PC_T1"z_sets_ext" prove_tac[] THEN all_var_elim_asm_tac1 THEN REPEAT strip_tac THEN_LIST
	(map( fn t => z_¶_tac t THEN REPEAT strip_tac) [ñA®, ñB®, ñA®, ñB®]));
val meet2_join2_lemma3 = pop_thm();
=TEX
=SML
set_goal([], ñµf: U ; A, B : U · {x:{A, B} · (f x)} = {(f A), (f B)} ®);
a(PC_T1"z_sets_ext" prove_tac[] THEN all_var_elim_asm_tac1 THEN REPEAT strip_tac THEN_LIST
	(map( fn t => z_¶_tac t THEN REPEAT strip_tac) [ñA®, ñB®]));
val meet2_join2_lemma4 = pop_thm();
=TEX
=SML
set_goal([], get_conjecture"-" "meet2_cnj");
a(rewrite_tac[meet2_def, meet_def, meet2_join2_lemma1, meet2_join2_lemma2]);
val Ûmeet2_thmÝ = save_pop_thm "meet2_thm";
=TEX
=SML
set_goal([], get_conjecture"-" "join2_cnj");
a(rewrite_tac[join2_def, join_def, meet2_join2_lemma1, meet2_join2_lemma2,
	meet2_join2_lemma3, meet2_join2_lemma4]);
a(rewrite_tac[reduce_def, forbidden_def1, refcalc_u_thm]);
a(PC_T1"z_library_ext" prove_tac[]);
val Ûjoin2_thmÝ = save_pop_thm "join2_thm";
=TEX
\section{Epilogue}
=SML
z_output_theory{out_file="refcalc.th.doc", theory="-"};
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
=TEX
\end{document}
=IGN
val tm = concl (z_get_specñ(_Ã_)®);
term_vars tm;

val tm2 = concl refines_def;
term_tyvars tm2;

term_vars tm2;
term_consts tm2;
val it =
   [("Z'\181", BOOL ­ BOOL®),
      ("\181", (('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" ­ BOOL) ­ BOOL®),
      ("Z'\181Body", BOOL ­ BOOL ­ BOOL ­ BOOL®),
      ("Z'Decl", BOOL LIST ­ BOOL®),
      ("Cons", BOOL ­ BOOL LIST ­ BOOL LIST®),
      ("Z'Dec",
         ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" LIST
             ¸ ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" SET
           ­ BOOL®),
      (",",
         ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" LIST
           ­ ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" SET
           ­ ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" LIST
             ¸ ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" SET®),
      ("Cons",
         ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]"
           ­ ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" LIST
           ­ ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" LIST®),
      ("Nil", ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" LIST®),
      ("z'U",
         ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" SET $"Z'T[1]"
           ­ ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" SET®),
      ("Z'Mk_T[1]",
         ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" SET
           ­ ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" SET $"Z'T[1]"®),
      ("Totality", ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" SET®),
      ("Nil", BOOL LIST®), ("T", BOOL®), ("=", BOOL ­ BOOL ­ BOOL®),
      ("\141",
         (('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]",
             ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]") $"Z'T[2]"
           ­ (('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]",
               ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]") $"Z'T[2]" SET
           ­ BOOL®),
      ("Z'Mk_T[2]",
         ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]"
           ­ ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]"
           ­ (('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]",
             ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]") $"Z'T[2]"®),
      ("z'_ \195 _",
         'b SET $"Z'T[1]"
           ­ (('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]",
               ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]") $"Z'T[2]" SET®),
      ("z'U", 'b SET $"Z'T[1]" ­ 'b SET®),
      ("Z'Mk_T[1]", 'b SET ­ 'b SET $"Z'T[1]"®), ("Totality", 'b SET®),
      ("\177", BOOL ­ BOOL ­ BOOL®),
      ("\141",
         ('a SET, 'a SET) $"Z'T[2]"
           ­ ('a SET, 'a SET) $"Z'T[2]" SET
           ­ BOOL®),
      ("z'_ \128 _", 'a SET $"Z'T[1]" ­ ('a SET, 'a SET) $"Z'T[2]" SET®),
      ("\141",
         (('a, 'a) $"Z'T[2]" SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]"
           ­ (('a, 'a) $"Z'T[2]" SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" SET
           ­ BOOL®),
      ("Z'Mk_T[2]",
         ('a, 'a) $"Z'T[2]" SET
           ­ ('a, 'a) $"Z'T[2]" SET
           ­ (('a, 'a) $"Z'T[2]" SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]"®),
      ("Z'App",
         (('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]",
               ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" SET
           ­ ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]"
           ­ ('a, 'a) $"Z'T[2]" SET®),
      ("z'_ \242 _",
         ('a SET, 'a SET) $"Z'T[2]"
           ­ (('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]",
               ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" SET®),
      ("Z'Mk_T[2]", 'a SET ­ 'a SET ­ ('a SET, 'a SET) $"Z'T[2]"®),
      ("z'U", 'a SET $"Z'T[1]" ­ 'a SET®),
      ("Z'Mk_T[1]", 'a SET ­ 'a SET $"Z'T[1]"®), ("Totality", 'a SET®),
      ("Z'Mk_T[2]",
         'a SET
           ­ ('a, 'a) $"Z'T[2]" SET
           ­ ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]"®),
      ("Z'T[2]1", ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]" ­ 'a SET®),
      ("Z'T[2]2",
         ('a SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]"
           ­ ('a, 'a) $"Z'T[2]" SET®),
      ("z'_ \128 _",
         ('a, 'a) $"Z'T[2]" SET $"Z'T[1]"
           ­ (('a, 'a) $"Z'T[2]" SET, ('a, 'a) $"Z'T[2]" SET) $"Z'T[2]"
           SET®),
      ("z'U", ('a, 'a) $"Z'T[2]" SET $"Z'T[1]" ­ ('a, 'a) $"Z'T[2]" SET®),
      ("Z'Mk_T[1]",
         ('a, 'a) $"Z'T[2]" SET ­ ('a, 'a) $"Z'T[2]" SET $"Z'T[1]"®),
      ("Totality", ('a, 'a) $"Z'T[2]" SET®)]
: (string * icl'TypesAndTerms.TYPE) list
:) 
