=IGN
********************************************************************************
wrk075.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[12pt]{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\def\Hide#1{\relax}
\title{On Precondition Calculation in a Traced Monoidal Category \\ (DRAFT)}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\section{Introduction}\label{Intro}

This note is the third in a nseries concerned with specification via
pre- and post-conditions.
It applies the general notion of specification and refinement given in the first note in the series
\cite{LEMMA1/ZED/WRK069} to systems formed by wiring together primitive building blocks.

\Hide{
The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"refcalc";
set_pc"z_library1";
force_delete_theory"ctssys" handle Fail _ => ();
new_theory"ctssys";
new_parent"z_reals";
ReaderWriterSupport.PrettyNames.add_new_symbols[
	(["refinedby"], Value "Ã", ReaderWriterSupport.PrettyNames.Simple), 
	(["ident"], Value "é", ReaderWriterSupport.PrettyNames.Simple)
] handle Fail _ => ();
=TEX
}

The Z specification uses infix or postfix notation for the following relation
and function symbols (in addition to those defined in the first note).
¹Z
Ü function 40  _**_
°

¹Z
Ü function 50  _ ^ _
°


%\newpage
\section{A CATEGORY OF RELATIONS}

We are going to work with systems of relations that can naturally be expressed diagrammatically.
The elements of the diagrams are called {\em boxes} and {\em wires}.
A box with $m$ inputs and $n$ outputs represents a relation between $V^m$ and $V^n$ for some suitable value domain $V$.
The produce new relations from old by adding equational constraints.
The diagrams need not form directed graphs: feedback loops are allowed and correspond to existential quantification.


Our approach to the syntax and semantics of diagrams is informed by the idea of a traced monoidal category.
The idea is that diagrams correspond to functor expressions in such a category.  Composition in the category corresponds to wiring diagrams in series.
The monoid operator corresponds to putting two diagrams together without adding any wiring.
Finally the trace operator corresponds to adding feedback loops to diagram.


If $V$ is any set, $V^m$ gives the set of all $m$-tuples with values ranging over $V$.
Typically $V^m$ represents the vector of inputs or outputs of a box in a diagram.

[ U ]œœœœœœœœœœœ
Ü Û_ ^ _Ý : ðU ¸ î ­ ð(seq U)
÷üüüüüü
Ü µV : ðU; m:î· V ^ m =  {s : seq V | #s = m}
ˆüüüüüüüüüüüüüü

For each set $V$, there is a category, which we shall call $Rel[V]$, whose objects are the natural numbers and whose morphisms (a.k.a. arrows) from $m$ to $n$ are the relations between $V^m$ and $V^n$ composed via ordinary relational composition\footnote{
We take the objects to be the natural numbers, $m$, rather than the sets $V^m$ for technical convenience to avoid having the category collapse when $V = \{\}$.
}.
We represent the category in Z by defining its set of morphisms.
A morphism is given as labelled triple whose components give the domain ($d$), codomain ($c$), and the relation ($r$).

¹Z
Ü ÛRelÝ[V] ¦ Þ{m, n : î · {R : V^m ª V^n· (d ¦ m, c ¦ n, r ¦ R)}}
°

The composition of morphisms that makes $Rel[V]$ into a category is the ``horizontal'' composition defined below.

[V]œœœœœœœœœœœ
Ü ÛHComposeÝ : Rel[V] ¸ Rel[V] ß Rel[V]
÷üüüüüü
Ü dom HCompose = {R, S : Rel[V] | R.c = S.d} ;
Ü µR, S : Rel[V] | R.c = S.d ·
Ü	HCompose(R, S) = (d ¦ R.d, c ¦ S.c, r ¦ R.r » S.r)
ˆüüüüüüüüüüüüüü


The following function gives the identity arrows in the category.

[V]œœœœœœœœœœœ
Ü ÛHIdÝ : î ­ Rel[V]
÷üüüüüü
Ü µ m : î · HId m = (d ¦ m, c ¦ m, r ¦ id(V^m))
ˆüüüüüüüüüüüüüü

The category becomes a monoidal category under a product given by addition on objects and by the following ``vertical composition'' on morphisms.

 
[V]œœœœœœœœœœœ
Ü ÛVComposeÝ : Rel[V] ¸ Rel[V] ­ Rel[V]
÷üüüüüü
Ü µR, S : Rel[V] ·
Ü	VCompose(R, S) = (d ¦ R.d + S.d, c ¦ R.c + S.c,
Ü		r ¦ {a, b, c, d : seq V | (a, c)  R.r ± (b, d)  S.r· (a ë b, c ë d)})
ˆüüüüüüüüüüüüüü

Finally, we get a traced monoidal category by defining the following operator that corresponds to adding $k$ feedback loops into a diagram.
 
[V]œœœœœœœœœœœ
Ü ÛTraceÝ : (î ¸ î ¸ î) ­ Rel[V] ß Rel[V]
÷üüüüüü
Ü µm, n, k : î·
Ü dom (Trace(m, n, k)) = {R : Rel[V] | R.d = m + k ± R.c = n + k} ;
Ü µm, n, k : î; R : Rel[V] | R.d = m + k ± R.c = n + k ·
Ü	Trace (m, n, k) R = (d ¦ m, c ¦ n,
Ü		r ¦ {a: V^m; b : V^n | ¶c:V^k· (a ë c, b ë c)  R.r})
ˆüüüüüüüüüüüüüü

To use the relation category, we will generally need to know something about the value domain, $V$.
However, we can describe some generic constructions that just impose equational constraints.
The first of these is the operator that makes the monoidal category into a symmetric monoidal category:

[V]œœœœœœœœœœœ
Ü ÛSwitchÝ : î ¸ î ­ Rel[V]
÷üüüüüü
Ü µm, n : î·
Ü	Switch(m, n) = (d ¦ m + n, c ¦ n + m,
Ü		r ¦ {a : V^m; b : V^n · (a ë b, b ë a)})
ˆüüüüüüüüüüüüüü

However, we can define at least one generic construction corresponding to patching inputs to outputs according to a wiring diagram (given as a relation between input port numbers and output port numbers):


[V]œœœœœœœœœœœ
Ü ÛPatchÝ : î ¸ î ¸ (î ª î) ­ Rel[V]
÷üüüüüü
Ü µm, n : î; d : î ª î·
Ü	Patch(m, n, d) = (d ¦ m, c ¦ n,
Ü		r ¦ {a : V^m; b : V^n | µi : 1..m; j : 1..n |(i, j)  d· b j = a i})
ˆüüüüüüüüüüüüüü

\section{SIGNAL FLOW GRAPHS}

A {\em signal} will be a real-valued function of a real variable.

¹Z
Ü ÛSIGNALÝ ¦ ¯ ­ ¯
°

The category of signal flow graphs is then the relational category with the value domain given by signals.


¹Z
Ü ÛSFGÝ ¦ Rel[SIGNAL]
°

We instantiate the notions of predicates, pre- post-conditions
and specifications from \cite{LEMMA1/ZED/WRK069} so that we can use them to express properties of signals:

¹Z
Ü ÛS_PREDÝ ¦ PRED[SIGNAL]
°
¹Z
Ü ÛS_PRE_CONDÝ ¦ PRE_COND[SIGNAL]
°
¹Z
Ü ÛS_POST_CONDÝ ¦ POST_COND[SIGNAL, SIGNAL]
°
¹Z
Ü ÛS_SPECÝ ¦ SPEC[SIGNAL, SIGNAL]
°
We now have a notion of diagram which is in quite close analogy with the notion of imperative program considered in \cite{LEMMA1/ZED/WRK070}.

¹Z
Ü ÛDIAGRAMÝ ::=
Ü	ÛAtomÝ (SFG)
Ü |	ÛSeqÝ (DIAGRAM ¸ DIAGRAM)
Ü |	ÛParÝ (DIAGRAM ¸ DIAGRAM)
Ü |	ÛLoopÝ (DIAGRAM ¸ î)
Ü |	ÛSpecÝ (S_SPEC ¸ DIAGRAM)
°
 
[V]œœœœœœœœœœœ
Ü ÛFeedbackÝ : Rel[V] ¸ î ß Rel[V]
÷üüüüüü
Ü dom Feedback = {R : Rel[V]; k : î | ¶m, n : î·R.d = m + k ± R.c = n + k} ;
Ü µR : Rel[V]; k, m, n : î | R.d = m + k ± R.c = n + k ·
Ü	Feedback(R, k) = Trace(m, n, k) R
ˆüüüüüüüüüüüüüü

¹ZAX
Ü ÛsemanticsÝ : DIAGRAM ­ SFG
÷üüüüüü
Ü µt : SFG; d‰1, d‰2 : DIAGRAM; n : î; s : S_SPEC·
Ü	semantics (Atom t) = t
Ü ±	semantics (Seq(d‰1, d‰2)) = HCompose(semantics d‰1, semantics d‰2)
Ü ±	semantics (Par(d‰1, d‰2)) = VCompose(semantics d‰1, semantics d‰2)
Ü ±	semantics (Loop(d‰1, n)) = Feedback(semantics d‰1, n)
Ü ±	semantics (Spec(s, d‰1)) = semantics d‰1
°

\bibliographystyle{fmu}
\bibliography{fmu}

\newpage
\appendix
% \newpage
\section{WEAKEST PRE-CONDITIONS FOR RELATIONS}

In \cite{LEMMA1/ZED/WRK070}, we give an account of precondition calculation for a small programming language.
In this note, we will be exploring weakest precondition calculation in a less familiar situation.
It is therefore helpful to formalise the abstract concept.
In this section we do this (implicitly) in the category of arbitrary relations in Z.
This category becomes a monoidal category under a ``vertical'' composition operator and then becomes a traced monoidal category under a trace operator defined by existential quantification.
We show how the weakest pre-condition behaves with respect to these operators.

The simplest notion of weakest precondition pulls a simple predicate back through a relation.
Representing predicates as sets, this notion is defined as follows:

[ Y, Z ]œœœœœœœœœœœ
Ü ÛWPSÝ : (Y ª Z) ¸ ðZ ­ ðY
÷üüüüüü
Ü µS : Y ª Z; C : ðZ·
Ü	WPS(S, C) = {y : Y | S ¨{y}© € C}
ˆüüüüüüüüüüüüüü


The following theorem shows that our explicit definition for $WP(S, C)$ is indeed the weakests $R$ such that $R\;»\;S \subseteq P$.

¹Z
Ü wps_correct_thm ?ô
Ü	µS : ƒ; C : ƒ· S¨WPS(S, C)© € C;
Ü	µS : ƒ; B : ƒ; C : ƒ | S¨B© € C · B € WPS(S, C)
°
(Note: ƒ is defined in the {\Product} Z library to be the generic object which gives the universe of all elements of a type. In declarations, it gives a similar effect to a type variable in HOL or ML).

The weakest pre-condition of a conjunction (intersection) is a conjunction:

¹Z
Ü wps_cap_thm ?ô
Ü	µR : ƒ; B, C : ƒ· WPS(R, B ¡ C) = WPS(R, B) ¡ WPS(R, C)
°
The weakest pre-condition for a relational composition is given by an appropriate form of functional composition.

¹Z
Ü wps_comp_thm ?ô
Ü	µR : ƒ; S : ƒ; A : ƒ· WPS(R » S, A) = WPS(R, WPS(S, A))
°

The following theorem may be helpful in understanding some of the
results which follow.
It shows that any point not in the domain of the relation $S$ satisfies any weakest pre-condition through $S$.


¹Z
Ü wps_compl_dom_thm ?ô
Ü	µS : ƒ; C : ƒ ·
Ü		ƒ \ dom S € WPS(S, C)
°

(Here ƒ in
=INLINEFT
ƒ \ dom S
=TEX
\ is acting as the total relation at the appropriate type).

We now define the ``vertical'' composition of two arbitrary relations.

[ X, Y, V, W ]œœœœœœœœœœœ
Ü Û_**_Ý : (X ª Y) ¸ (V ª W) ­ (X ¸ V ª Y ¸ W)
÷üüüüüü
Ü µR : X ª Y; S : V ª W·
Ü	R ** S =
Ü	{x : X; y : Y; v : V; w : W
Ü	| (x, y)  R ± (v, w)  S · ( (x, v), (y, w) )}
ˆüüüüüüüüüüüüüü

The weakest pre-condition through a vertical composite is as follows:

¹Z
Ü wps_prod_thm ?ô
Ü	µR : ƒ; S : ƒ; B : ƒ; C : ƒ ·
Ü		WPS(R ** S, B ¸ C) =
Ü		(WPS(R, B) ¸ WPS(S, C)) À (ƒ \ (dom R ¸ dom S))
°

[ X, Y, V ]œœœœœœœœœœœ
Ü ÛProj‰¶Ý : (X ¸ V ª Y ¸ V) ­ (X ª Y)
÷üüüüüü
Ü µR : (X ¸ V ª Y ¸ V)·
Ü	Proj‰¶ R =
Ü	{x : X; y : Y | ¶v : V· ((x, v), (y, v))  R}
ˆüüüüüüüüüüüüüü

¹Z
Ü wps_proj_exists_thm ?ô
Ü	µR : ƒ;  C : ƒ ·
Ü		WPS(Proj‰¶ R, C) =
Ü		{x: ƒ | µv:ƒ· (x, v)  WPS(R ¡ (ƒ ** (id _)), C ¸ ƒ)· x}
°

As noted in \cite{LEMMA1/ZED/WRK070}, a more general notion of weakest precondition calculation deals with relations.
In general, if $S$ and $P$ are binary relations,
we want to specify  $WP(S, P)$ so that it is the weakest (i.e., largest) relation $R$ such that $R\;»\;S \subseteq P$.
We use an explicit formula for $WP$ (cf. the clause for atoms in the function {\em prec\_calc} in \cite{LEMMA1/ZED/WRK070}).

[ X, Y, Z ]œœœœœœœœœœœ
Ü ÛWPÝ : (Y ª Z) ¸ (X ª Z) ­ (X ª Y)
÷üüüüüü
Ü µS : Y ª Z; P : X ª Z·
Ü	WP(S, P) = {x : X; y : Y | S ¨{y}© € P¨{x}©}
ˆüüüüüüüüüüüüüü

The following theorem shows that our explicit definition for $WP(S, P)$ is indeed the weakests $R$ such that $R\;»\;S \subseteq P$.

¹Z
Ü wp_correct_thm ?ô
Ü	µS : ƒ; P : ƒ· WP(S, P) » S € P;
Ü	µR : ƒ; S : ƒ; P : ƒ | R » S € P · R € WP(S, P)
°

The relational formulation of weakest precondition may be defined in terms of the set formulation:

¹Z
Ü wp_wps_thm ?ô
Ü	µS : ƒ; P : ƒ· WP(S, P) = {x : ƒ; y : ƒ | y  WPS(S, P¨{x}©)}
°

From the above, one can calculate relational weakest pre-conditions for intersections, compositions etc. using the
corresponding theorems for predicate weakest pre-conditions.

\newpage
\section{SOME CATEGORY THEORY}
A category with the set of objects $O$ and the set of arrows $A$ is represented by a member of the following generic schema,
in which we agree to write composition in the category left to right.


¹Z
Ü function 40 leftassoc  _ »‰c _, _ «‰o _, _ «‰a_
°


ÿ ÛCATÝ[O, A] üüüüüüüüüüü
Ü _ »‰c _ : A ¸ A ß A ;
Ü dom‰c, cod‰c : A ­ O ;
Ü id‰c : O ­ A
÷üüüüüü
Ü dom (_ »‰c _) = {f, g : A | cod‰c f = dom‰c g} ;
Ü µf, g, h : A | cod‰c f = dom‰c g ± cod‰c g = dom‰c h ·
Ü	(f »‰c g) »‰c h = f »‰c (g »‰c h) ;
Ü µf, g :  A | cod‰c f = dom‰c g ·
Ü	dom‰c (f »‰c g) = dom‰c f ± cod‰c (f »‰c g) = cod‰c g ;
Ü µ X : O ·
Ü	dom‰c (id‰c X) = cod‰c (id‰c X) = X ;
Ü µ f : A ·
Ü	id‰c(dom‰c f) »‰c f = f »‰c id‰c(cod‰c f) = f
ˆüüüüüüüüüüüüüü

We can now state the theorem that $Rel[V]$ with the appropriate structure is indeed a category.

¹Z
Ü ÛRelCatÝ [V] ¦
Ü	(_ »‰c _ ¦ HCompose[V],
Ü	dom‰c ¦ (ÌR:Rel[V]· R.d),
Ü	cod‰c ¦ (ÌR:Rel[V]· R.c),
Ü	id‰c ¦ HId[V])
°
¹Z
Ü rel_cat_thm ?ô [V](RelCat[V]  CAT[î, Rel[V]])
°


A (strict) monoidal category is a category equipped with an associative bifunctor « with unit, $e$:
ÿ ÛMON_CATÝ[O, A] üüüüüüüüüüü
Ü CAT[O, A] ;
Ü _ «‰o _ : O ¸ O ­ O;
Ü _ «‰a _ : A ¸ A ­ A;
Ü I‰« : A
÷üüüüüü
Ü µf, g, h : A· (f «‰a g) «‰a h = f «‰a (g «‰a h) ;
Ü µf : A· (f «‰a I‰«) = (I‰« «‰a f) = f ;
Ü µ X, Y : O· X «‰o Y = dom‰c (id‰c X «‰a id‰c Y)
ˆüüüüüüüüüüüüüü

¹Z
Ü ÛRelMonCatÝ [V] ¦
Ü	(_ »‰c _ ¦ HCompose[V],
Ü	dom‰c ¦ (ÌR:Rel[V]· R.d),
Ü	cod‰c ¦ (ÌR:Rel[V]· R.c),
Ü	id‰c ¦ HId[V],
Ü	_ «‰o _ ¦ (Ìm, n:î· m + n),
Ü	_ «‰a _ ¦ VCompose[V],
Ü	I‰« ¦ HId[V](0))
°

¹Z
Ü rel_mon_cat_thm ?ô [V](RelMonCat[V]  MON_CAT[î, Rel[V]])
°


ÿ ÛSYM_MON_CATÝ[O, A] üüüüüüüüüüü
Ü MON_CAT[O, A] ;
Ü Sym : O ¸ O ­ A
÷üüüüüü
Ü µ X, Y : O · dom‰c(Sym(X, Y)) = X «‰o Y ± cod‰c(Sym(X, Y)) = Y «‰o  X ;
Ü µ X, Y : O · Sym(X, Y) »‰c Sym(Y, X) = id‰c (X «‰o Y) ;
Ü µ X, Y, Z : O ·
Ü	Sym(X «‰o Y, Z) =
Ü	(id‰c X «‰a Sym(Y, Z)) »‰c (Sym(X, Z) «‰a id‰c Y)
ˆüüüüüüüüüüüüüü
¹Z
Ü ÛRelSymMonCatÝ [V] ¦
Ü	(_ »‰c _ ¦ HCompose[V],
Ü	dom‰c ¦ (ÌR:Rel[V]· R.d),
Ü	cod‰c ¦ (ÌR:Rel[V]· R.c),
Ü	id‰c ¦ HId[V],
Ü	_ «‰o _ ¦ (Ìm, n:î· m + n),
Ü	_ «‰a _ ¦ VCompose[V],
Ü	I‰« ¦ HId[V](0),
Ü	Sym ¦ Switch[V])
°

¹Z
Ü rel_sym_mon_cat_thm ?ô [V](RelSymMonCat[V]  SYM_MON_CAT[î, Rel[V]])
°

ÿ ÛTRA_MON_CAT_SIGÝ[O, A] üüüüüüüüüüü
Ü SYM_MON_CAT[O, A] ;
Ü Trc : O ¸ O ¸ O ­ A ß A
ˆüüüüüüüüüüüüüü
ÿ ÛTRA_MON_CAT_DOMÝ[O, A] üüüüüüüüüüü
Ü TRA_MON_CAT_SIG[O, A]
÷üüüüüü
Ü µ X, Y, Z : O ·
Ü	dom (Trc(X, Y, Z)) = {f : A | dom‰c f = X «‰o Z ± cod‰c f = Y «‰o Z} ;
Ü µ X, Y, Z : O; f : A |
Ü	dom‰c f = X «‰o Z ± cod‰c f = Y «‰o Z ·
Ü	dom‰c (Trc(X, Y, Z) f) = X ± cod‰c (Trc(X, Y, Z) f) = Y
ˆüüüüüüüüüüüüüü
ÿ ÛTRA_MON_CAT_NATÝ[O, A] üüüüüüüüüüü
Ü TRA_MON_CAT_SIG[O, A]
÷üüüüüü
Ü µ X, W, Y, Z : O; f, h : A |
Ü	dom‰c f = W «‰o Z ± cod‰c f = Y «‰o Z ;
Ü	dom‰c h = X ± cod‰c h = W ·
Ü	Trc(X, Y, Z) ((h «‰a id‰c Z) »‰c f) =
Ü	h »‰c Trc(W, Y, Z) f ;
Ü µ X, W, Y, Z : O; f, h : A |
Ü	dom‰c f = X «‰o Z ± cod‰c f = W «‰o Z ;
Ü	dom‰c h = W ± cod‰c h = X ·
Ü	Trc(X, Y, Z) (f »‰c (h «‰a id‰c Z)) =
Ü	h »‰c Trc(X, W, Z) f ;
Ü µ X, Y, W, Z : O; f, h : A |
Ü	dom‰c f = X «‰o W ± cod‰c f = Y «‰o Z ;
Ü	dom‰c h = Z ± cod‰c h = W ·
Ü	Trc(X, Y, Z) ((id‰c X «‰a h) »‰c f) =
Ü	Trc(X, Y, W) (f »‰c (id‰c Y «‰a h))
ˆüüüüüüüüüüüüüü
ÿ ÛTRA_MON_CAT_VANÝ[O, A] üüüüüüüüüüü
Ü TRA_MON_CAT_SIG[O, A]
÷üüüüüü
Ü µ X, Y : O; f : A |
Ü	dom‰c f = X  ± cod‰c f = Y ·
Ü	Trc(X, Y, dom‰c I‰«) (f «‰a I‰«) = f ;
Ü µ X, Y, W, Z : O; f : A |
Ü	dom‰c f = X «‰o W «‰o Z ± cod‰c f = Y «‰o W «‰o Z ·
Ü	Trc(X, Y, W «‰o Z) f =
Ü	Trc(X, Y, W) (Trc(X «‰o W, Y «‰o W, Z) f)
ˆüüüüüüüüüüüüüü
ÿ ÛTRA_MON_CAT_SUPÝ[O, A] üüüüüüüüüüü
Ü TRA_MON_CAT_SIG[O, A]
÷üüüüüü
Ü µ W, X, Y, Z : O; f : A |
Ü	dom‰c f = W «‰o Z ± cod‰c f = Y «‰o Z ·
Ü	Trc(W «‰o X, W «‰o Y, Z) (id‰c W «‰a f) =
Ü	id‰c W «‰a Trc(X, Y, Z) f
ˆüüüüüüüüüüüüüü
ÿ ÛTRA_MON_CAT_YANÝ[O, A] üüüüüüüüüüü
Ü TRA_MON_CAT_SIG[O, A]
÷üüüüüü
Ü µ X : O ·
Ü	Trc (X, X, X) (Sym (X, X)) = id‰c X
ˆüüüüüüüüüüüüüü

ÿ ÛTRA_MON_CATÝ[O, A] üüüüüüüüüüü
Ü TRA_MON_CAT_SIG[O, A] 
÷üüüüüü
Ü TRA_MON_CAT_DOM[O, A] ;
Ü TRA_MON_CAT_NAT[O, A] ;
Ü TRA_MON_CAT_VAN[O, A] ;
Ü TRA_MON_CAT_SUP[O, A] ;
Ü TRA_MON_CAT_YAN[O, A]
ˆüüüüüüüüüüüüüü

¹Z
Ü ÛRelTraMonCatÝ [V] ¦
Ü	(_ »‰c _ ¦ HCompose[V],
Ü	dom‰c ¦ (ÌR:Rel[V]· R.d),
Ü	cod‰c ¦ (ÌR:Rel[V]· R.c),
Ü	id‰c ¦ HId[V],
Ü	_ «‰o _ ¦ (Ìm, n:î· m + n),
Ü	_ «‰a _ ¦ VCompose[V],
Ü	I‰« ¦ HId[V](0),
Ü	Sym ¦ Switch[V],
Ü	Trc ¦ Trace[V])
°


¹Z
Ü rel_tra_mon_cat_thm ?ô [V](RelTraMonCat[V]  TRA_MON_CAT[î, Rel[V]])
°
=TEX
\newpage
\appendix
=TEX
{\HOLindexOff\small
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{wrk075.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%
%% Comment out next line to include the proofs in the printed document:
\end{document}

\section{Proofs}
=TEX
\ftlinepenalty=999
=SML
val Ûwps_defÝ = z_get_specñWPS®;
val Ûwp_defÝ = z_get_specñWP®;
val Ûset_exp_defÝ = z_get_specñ(_^_)®;
val Ûrel_prod_defÝ = z_get_specñ(_**_)®;
val Ûproj_¶_defÝ = z_get_specñProj‰¶®;
val Ûrel_defÝ = z_get_specñRel[V]®;
val Ûh_compose_defÝ = z_get_specñHCompose®;
val Ûh_id_defÝ = z_get_specñHId®;
val Ûv_compose_defÝ = z_get_specñVCompose®;
val Ûtrace_defÝ = z_get_specñTrace®;
val Ûswitch_defÝ = z_get_specñSwitch®;
val Ûpatch_defÝ = z_get_specñPatch®;
val Ûcat_defÝ = z_get_specñCAT®;
val Ûrel_cat_defÝ = z_get_specñRelCat®;
val Ûmon_cat_defÝ = z_get_specñMON_CAT®;
val Ûrel_mon_cat_defÝ = z_get_specñRelMonCat®;
val Ûsym_mon_cat_defÝ = z_get_specñSYM_MON_CAT®;
val Ûrel_sym_mon_cat_defÝ = z_get_specñRelSymMonCat®;
val Ûtra_mon_cat_sig_defÝ = z_get_specñTRA_MON_CAT_SIG®;
val Ûtra_mon_cat_dom_defÝ = z_get_specñTRA_MON_CAT_DOM®;
val Ûtra_mon_cat_nat_defÝ = z_get_specñTRA_MON_CAT_NAT®;
val Ûtra_mon_cat_van_defÝ = z_get_specñTRA_MON_CAT_VAN®;
val Ûtra_mon_cat_sup_defÝ = z_get_specñTRA_MON_CAT_SUP®;
val Ûtra_mon_cat_yan_defÝ = z_get_specñTRA_MON_CAT_YAN®;
val Ûtra_mon_cat_defÝ = z_get_specñTRA_MON_CAT®;
val Ûrel_tra_mon_cat_defÝ = z_get_specñRelTraMonCat®;
=TEX
%%%%
%%%%
=SML
set_goal([], ñµR:ƒ; x : ƒ·R¨{x}© = {z : ƒ | (x, z)  R}®);
a(PC_T1 "z_library_ext" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
a(z_¶_tacñx® THEN asm_rewrite_tac[]);
val Ûz_image_singleton_thmÝ = save_pop_thm "z_image_singleton_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ñµS:ƒ;C: ƒ·
	WPS (S, C) = {y:ƒ| µz:ƒ·(y, z)  S ´ z  C}®);
a(rewrite_tac[z_image_singleton_thm, z_gen_pred_u_elim wps_def]);
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûwps_rw_thmÝ = save_pop_thm "wps_rw_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_correct_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûwps_correct_thmÝ = save_pop_thm "wps_correct_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_cap_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûwps_cap_thmÝ = save_pop_thm "wps_cap_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_comp_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûwps_comp_thmÝ = save_pop_thm "wps_comp_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñµC:ƒ·WPS({}, C) = ƒ®);
a(rewrite_tac[wps_rw_thm]);
val Ûwps_empty_thmÝ = save_pop_thm "wps_empty_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_compl_dom_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûwps_compl_dom_thmÝ = save_pop_thm "wps_compl_dom_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ
	µR : ƒ; S : ƒ; x1 : ƒ; y1 : ƒ; v1 : ƒ; w1 : ƒ·
	(¶ x : ƒ; y : ƒ; v : ƒ; w : ƒ
	| (x, y)  R ± (v, w)  S
 	· (x = x1 ± v = v1) ± y = y1 ± w = w1)
¤	(x1, y1)  R ± (v1, w1)  S
®);
a(PC_T1 "z_library_ext" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
a(z_¶_tacñ(x ¦ x1, v ¦ v1, y ¦ y1, w ¦ w1)® THEN asm_rewrite_tac[]);
val Ûrel_prod_rw_thmÝ = save_pop_thm "rel_prod_rw_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñµR : ƒ; S : ƒ· dom (R ** S) = dom R ¸ dom S®);
a(PC_T1 "z_library_ext" rewrite_tac[
	z_gen_pred_u_elim rel_prod_def,
	rel_prod_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
a(z_¶_tacñ(y, y')® THEN asm_rewrite_tac[]);
val Ûdom_rel_prod_thmÝ = save_pop_thm "dom_rel_prod_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_prod_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm,
	rel_prod_rw_thm,
	z_gen_pred_u_elim rel_prod_def]);
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 (ante_tac o z_µ_elim ñ(z, y')®));
a(asm_rewrite_tac[] THEN taut_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 (ante_tac o z_µ_elim ñ(y, z)®));
a(asm_rewrite_tac[] THEN taut_tac);
val Ûwps_prod_thmÝ = save_pop_thm "wps_prod_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_proj_exists_thm");
a(PC_T1 "z_library_ext" rewrite_tac[
	z_gen_pred_u_elim rel_prod_def,
	wps_rw_thm,
	z_gen_pred_u_elim proj_¶_def]);
a(PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o z_µ_elimñz.1®));
a(DROP_NTH_ASM_T 1 (ante_tac o z_µ_elimñz.2®));
a(conv_tac(ONCE_MAP_C z_tuple_lang_intro_conv));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 2 (fn th => fc_tac[th]));
a(DROP_NTH_ASM_T 1 (ante_tac o list_µ_elim[¬v®, ¬v®, ¬x1®, ¬z®]));
a(rewrite_tac[]);
val Ûwps_proj_exists_thmÝ = save_pop_thm "wps_proj_exists_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ñµS:ƒ;P: ƒ·
	WP (S, P) = {x:ƒ; y:ƒ| µz:ƒ·(y, z)  S ´ (x, z)  P}®);
a(rewrite_tac[z_image_singleton_thm, z_gen_pred_u_elim wp_def]);
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûwp_rw_thmÝ = save_pop_thm "wp_rw_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wp_correct_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wp_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûwp_correct_thmÝ = save_pop_thm "wp_correct_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wp_wps_thm");
a(rewrite_tac[z_image_singleton_thm]);
a(PC_T1 "z_library_ext" rewrite_tac[wp_rw_thm, wps_rw_thm]);
val Ûwp_wps_thmÝ = save_pop_thm "wp_wps_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[V] 
	(Rel[V] = {m, n:î; R : ƒ | R  V^m ª V^n· (d ¦ m, c ¦ n, r ¦ R)})®);
a(rewrite_tac[rel_def] THEN REPEAT strip_tac);
a(PC_T "z_sets_ext" strip_tac THEN REPEAT strip_tac
	THEN REPEAT all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(z_¶_tacñ(m ¦ x2, n ¦ x1, R ¦ x3)® THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(z_¶_tacñ{R : V ^ x2 ª V ^ x1 · (c ¦ x1, d ¦ x2, r ¦ R)}®
	THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(z_¶_tacñ(m ¦ x2, n ¦ x1)® THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(z_¶_tacñx3® THEN asm_rewrite_tac[]);
val Ûrel_rw_thmÝ = save_pop_thm "rel_rw_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[V] 
	(µA:ƒ·A  Rel[V] ¤ A.c  î ± A.d  î ± A.r  V^(A.d) ª V^(A.c))®);
a(rewrite_tac[rel_rw_thm] THEN REPEAT strip_tac
	THEN REPEAT all_var_elim_asm_tac1
	THEN_TRY asm_rewrite_tac[]);
a(z_¶_tacñ(m ¦ A.d, n ¦ A.c, R ¦ A.r)® THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" asm_rewrite_tac[]);
val Û_rel_thmÝ = save_pop_thm "_rel_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µf X Y·
	ñ(Ìm:X· ¬f m®)  X ­ Y ¤ (µx:X · ¬f x®  Y)®®);
a(PC_T1 "z_fun_ext" prove_tac[]);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
a(all_var_elim_asm_tac1 THEN strip_tac);
val ÛÌ__­_thmÝ = save_pop_thm "Ì__­_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[V](µm : î· HId[V] m  Rel[V])®);
a(REPEAT strip_tac THEN ALL_FC_T rewrite_tac[h_id_def]);
a(asm_rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ñµA:ƒ· id A  A ª A®,
		_rel_thm]);
val Ûh_id__rel_thmÝ = save_pop_thm "h_id__rel_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "rel_cat_thm");
a(rewrite_tac[cat_def, rel_cat_def, h_compose_def, h_id_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[
	conv_rule(ONCE_MAP_C Â_conv)
	(µ_elim¬ÌR·ñ(R º Rel[V]).d®® Ì__­_thm)]);
a(z_strip_tac THEN PC_T1 "z_library_ext" rewrite_tac [_rel_thm]
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[
	conv_rule(ONCE_MAP_C Â_conv)
	(µ_elim¬ÌR·ñ(R º Rel[V]).c®® Ì__­_thm)]);
a(z_strip_tac THEN PC_T1 "z_library_ext" rewrite_tac [_rel_thm]
	THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(PC_T1 "z_library_ext" rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(POP_ASM_T ante_tac THEN conv_tac(ONCE_MAP_C z_Â_conv));
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac);
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(REPEAT strip_tac);
a(lemma_tacñ(f, g)  dom HCompose[V] ± (g, h)  dom HCompose[V]®
	THEN1  PC_T1 "z_sets_ext" asm_rewrite_tac[h_compose_def]);
a(strip_asm_tac (±_left_elim (µ_elim¬V®h_compose_def)));
a(ALL_FC_T (MAP_EVERY ante_tac)[z_fun__clauses]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(REPEAT strip_tac THEN lemma_tac ñ
	(c ¦ g.c, d ¦ f.d, r ¦ f.r » g.r).c = h.d
	± f.c = (c ¦ h.c, d ¦ g.d, r ¦ g.r » h.r).d®
	THEN1 asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
	ñµf, g, h:ƒ· f » g » h = f » (g » h)®]);
(* *** Goal "5" *** *)
a(POP_ASM_T ante_tac);
a(conv_tac(LEFT_C(ONCE_MAP_C z_Â_conv)));
a(REPEAT strip_tac);
a(lemma_tacñ(f, g)  dom HCompose[V]®
	THEN1 PC_T1 "z_sets_ext" asm_rewrite_tac[h_compose_def]);
a(strip_asm_tac (±_left_elim (µ_elim¬V®h_compose_def)));
a(ALL_FC_T (MAP_EVERY ante_tac)[z_fun__clauses]);
a(strip_tac);
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(ALL_FC_T rewrite_tac[h_compose_def]);
(* *** Goal "6" *** *)
a(POP_ASM_T ante_tac);
a(conv_tac(LEFT_C(ONCE_MAP_C z_Â_conv)));
a(REPEAT strip_tac);
a(lemma_tacñ(f, g)  dom HCompose[V]®
	THEN1 PC_T1 "z_sets_ext" asm_rewrite_tac[h_compose_def]);
a(strip_asm_tac (±_left_elim (µ_elim¬V®h_compose_def)));
a(ALL_FC_T (MAP_EVERY ante_tac)[z_fun__clauses]);
a(strip_tac);
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(ALL_FC_T rewrite_tac[h_compose_def]);
(* *** Goal "7" *** *)
a(lemma_tacñHId[V] X  Rel[V]®
	THEN1 ALL_FC_T rewrite_tac[h_id__rel_thm]);
a(conv_tac (MAP_C z_Â_conv));
a(ALL_FC_T rewrite_tac[h_id_def]);
(* *** Goal "8" *** *)
a(lemma_tacñHId[V] X  Rel[V]®
	THEN1 ALL_FC_T rewrite_tac[h_id__rel_thm]);
a(conv_tac (MAP_C z_Â_conv));
a(ALL_FC_T rewrite_tac[h_id_def]);
(* *** Goal "9" *** *)
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[_rel_thm]));
a(LEMMA_T ñf.c  î® asm_tac THEN REPEAT strip_tac);
a(LEMMA_T ñf.d  î® asm_tac THEN REPEAT strip_tac);
a(conv_tac(MAP_C z_Â_conv));
a(lemma_tacñHId[V] f.d  Rel[V]
	± HId[V] f.c  Rel[V]®
	THEN1 ALL_FC_T rewrite_tac[h_id__rel_thm]);
a(lemma_tacñ(HId[V] f.d).c = f.d
	± f.c = (HId[V] f.c).d®
	THEN1 ALL_FC_T rewrite_tac[h_id_def]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(ALL_FC_T rewrite_tac[h_id_def]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ñµA:ƒ; B:ƒ; R:ƒ· R  A ª B ´
			R » id B = id A » R = R®]);
(* *** Goal "10" *** *)
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[_rel_thm]));
a(LEMMA_T ñf.c  î® asm_tac THEN REPEAT strip_tac);
a(conv_tac(MAP_C z_Â_conv));
a(lemma_tacñHId[V] f.c  Rel[V]®
	THEN1 ALL_FC_T rewrite_tac[h_id__rel_thm]);
a(lemma_tacñf.c = (HId[V] f.c).d®
	THEN1 ALL_FC_T rewrite_tac[h_id_def]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(ALL_FC_T rewrite_tac[h_id_def]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ñµA:ƒ; B:ƒ; R:ƒ· R  A ª B ´
			R » id B = id A » R = R®]);
a(PC_T1 "z_library_ext" rewrite_tac[]);
val Ûrel_cat_thmÝ = save_pop_thm "rel_cat_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[V](V^0 = {§¢})®);
a(REPEAT strip_tac);
a(LEMMA_T ñ0  î® asm_tac THEN1 rewrite_tac[]);
a(PC_T1 "z_predicates" (ALL_FC_T rewrite_tac)[z_gen_pred_u_elim set_exp_def]);
a(PC_T "z_library_ext" strip_tac
	THEN z_strip_tac
	THEN rewrite_tac[z_§¢_seq_thm]);
a(rewrite_tac[rewrite_rule[]
	(z_µ_elimñ(X ¦ V, s ¦ x1, n ¦ 0)® z_size_seq_thm1)]);
a(rewrite_tac[z_§¢_thm]);
val Ûset_exp_0_thmÝ = save_pop_thm "set_exp_0_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñµx:ƒ· id{x} = {(x, x)}®);
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûid_singleton_thmÝ = save_pop_thm "id_singleton_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[V](µf:Rel[V]; x, y: ƒ | (x, y)  f.r · x  seq V ± y  seq V)®);
a(REPEAT_UNTIL is_´ strip_tac);
a(rewrite_tac[_rel_thm] THEN REPEAT_UNTIL is_± strip_tac);
a(DROP_NTH_ASM_T 2 ante_tac);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(PC_T1 "z_library_ext" asm_prove_tac[]);
val Ûrel_seq_thmÝ = save_pop_thm "rel_seq_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñµM, N : î·(Ìm, n:î· m + n) (M, N) = M + N®);
a(PC_T1 "z_predicates" REPEAT strip_tac);
a(LEMMA_Tñ(M, N)  î ¸ î® asm_tac THEN1 asm_rewrite_tac[]);
a(lemma_tacñ(Ìm, n:î· m + n)  î ¸ î ­ î®);
(* *** Goal "1" *** *)
a(conv_tac(ONCE_MAP_C z_Ì_conv));
a(PC_T1 "z_library_ext" asm_prove_tac[]
	THEN_TRY (all_var_elim_asm_tac1 THEN PC_T1 "z_lin_arith" asm_prove_tac[]));
a(z_¶_tacñx1 + x2® THEN rewrite_tac[]);
a(z_¶_tacñ(m ¦ x1, n ¦ x2)® THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_Tñ((M, N), (M + N))  (Ìm, n:î· m + n)® asm_tac);
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac);
a(DROP_NTH_ASM_T 3 ante_tac);
a(PC_T1 "z_library_ext" prove_tac[]);
a(z_¶_tacñ(m ¦ M, n ¦ N)® THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(ALL_FC_T rewrite_tac[z_fun_app_clauses]);
val Ûz_plus_î_thmÝ = save_pop_thm "z_plus_î_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "rel_mon_cat_thm");
a(rewrite_tac[mon_cat_def, rel_mon_cat_def,
	rewrite_rule[rel_cat_def] rel_cat_thm, v_compose_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" prove_tac[]
	THEN_TRY all_var_elim_asm_tac1
	THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(z_¶_tacñx1 + x2® THEN rewrite_tac[]);
a(z_¶_tacñ(m ¦ x1, n ¦ x2)® THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_Tñ0 ¼ 0® asm_tac THEN1 REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[h_id__rel_thm]);
(* *** Goal "3" *** *)
a(strip_asm_tac (±_left_elim (µ_elim¬V®v_compose_def)));
a(LEMMA_Tñ(f, g)  Rel[V] ¸ Rel[V]® asm_tac THEN1 REPEAT strip_tac);
a(LEMMA_Tñ(g, h)  Rel[V] ¸ Rel[V]® asm_tac THEN1 REPEAT strip_tac);
a(all_fc_tac[z_fun__clauses]);
a(ALL_FC_T once_rewrite_tac[v_compose_def]);
a(ALL_FC_T rewrite_tac[v_compose_def]);
a(rewrite_tac[z_plus_assoc_thm]);
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.1" *** *)
a(z_¶_tacñ(a ¦ a', b'' ¦ b' ë b, c ¦ c', d'' ¦ d' ë d)®
	THEN asm_rewrite_tac[]);
a(all_fc_tac[z_seq_u_thm]);
a(conv_tac(LEFT_C (PC_C1 "z_sets_ext" rewrite_conv[])));
a(ALL_FC_T1 fc_¤_canon asm_rewrite_tac[z_ë_seq_x_thm,
	z_ë_assoc_thm]);
a(z_¶_tacñ(a ¦ b', b'' ¦ b, c ¦ d', d'' ¦ d)®
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "3.2" *** *)
a(z_¶_tacñ(a'' ¦ a ë a', b ¦ b', c'' ¦ c ë c', d ¦ d')®
	THEN asm_rewrite_tac[]);
a(all_fc_tac[z_seq_u_thm]);
a(conv_tac(LEFT_C (PC_C1 "z_sets_ext" rewrite_conv[])));
a(ALL_FC_T1 fc_¤_canon asm_rewrite_tac[z_ë_seq_x_thm,
	z_ë_assoc_thm]);
a(z_¶_tacñ(a'' ¦ a, b ¦ a', c'' ¦ c, d ¦ c')®
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(LEMMA_Tñ 0 ¼ 0® asm_tac THEN1 REPEAT strip_tac);
a(lemma_tacñHId[V] 0  Rel[V]®
	THEN1 ALL_FC_T rewrite_tac[h_id__rel_thm]);
a(LEMMA_Tñ(f, HId[V]0)  Rel[V] ¸ Rel[V]® asm_tac
	THEN1 REPEAT strip_tac);
a(LEMMA_Tñ(HId[V]0, f)  Rel[V] ¸ Rel[V]® asm_tac
	THEN1 REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[v_compose_def]);
a(ALL_FC_T rewrite_tac[h_id_def]);
a(rewrite_tac[set_exp_0_thm, id_singleton_thm]);
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "4.1" *** *)
a(z_¶_tacñ(a' ¦ §¢, b ¦ a, c' ¦ §¢, d ¦ c)®
	THEN asm_rewrite_tac[]);
a(conv_tac(LEFT_C (PC_C1 "z_sets_ext" rewrite_conv[])));
a(asm_rewrite_tac[z_§¢_seq_thm]);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_ë_§¢_thm, z_§¢_ë_thm]);
(* *** Goal "4.2" *** *)
a(z_¶_tacñ(a ¦ b, b' ¦ §¢, c ¦ d, d' ¦ §¢)®
	THEN asm_rewrite_tac[]);
a(conv_tac(LEFT_C (PC_C1 "z_sets_ext" rewrite_conv[])));
a(asm_rewrite_tac[z_§¢_seq_thm]);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_ë_§¢_thm, z_§¢_ë_thm]);
(* *** Goal "5" *** *)
a(LEMMA_Tñ 0 ¼ 0® asm_tac THEN1 REPEAT strip_tac);
a(lemma_tacñHId[V] 0  Rel[V]®
	THEN1 ALL_FC_T rewrite_tac[h_id__rel_thm]);
a(LEMMA_Tñ(HId[V]0, f)  Rel[V] ¸ Rel[V]® asm_tac
	THEN1 REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[v_compose_def]);
a(ALL_FC_T rewrite_tac[h_id_def]);
a(rewrite_tac[set_exp_0_thm, id_singleton_thm]);
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac);
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac
	THEN1 all_var_elim_asm_tac1);
(* *** Goal "5.1" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T asm_rewrite_tac[z_ë_§¢_thm, z_§¢_ë_thm]);
(* *** Goal "5.2" *** *)
a(z_¶_tacñ(a ¦ §¢, b ¦ x1, c ¦ §¢, d ¦ x2)®
	THEN asm_rewrite_tac[]);
a(conv_tac(LEFT_C (PC_C1 "z_sets_ext" rewrite_conv[])));
a(asm_rewrite_tac[z_§¢_seq_thm]);
a(all_fc_tac[rel_seq_thm]);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T asm_rewrite_tac[z_ë_§¢_thm, z_§¢_ë_thm]);
(* *** Goal "6" *** *)
a(ALL_FC_T rewrite_tac[z_plus_î_thm]);
a(lemma_tacñHId[V] X  Rel[V] ± HId[V] Y  Rel[V]®
	THEN1 ALL_FC_T rewrite_tac[h_id__rel_thm]);
a(LEMMA_Tñ(HId[V] X, HId[V] Y)  Rel[V] ¸ Rel[V]® asm_tac
	THEN1 REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¬V®v_compose_def)));
a(all_fc_tac[z_fun__clauses]);
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(ALL_FC_T rewrite_tac[v_compose_def]);
a(ALL_FC_T rewrite_tac[h_id_def]);
val Ûrel_mon_cat_thmÝ = save_pop_thm "rel_mon_cat_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[V](µm, n : î· µa : V^m; b : V^n· a ë b  V^(m+n))®);
a(REPEAT strip_tac);
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(lemma_tacñ0 ¼ m + n® THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T1 fc_¤_canon asm_rewrite_tac[z_ë_seq_x_thm]);
(* *** Goal "2" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_size_ë_thm]);
val Ûë_seq_exp_thmÝ = save_pop_thm "ë_seq_exp_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[X](
	µs : seq X · s = §¢ ²
	(¶s1 : seq X; x : X· s = s1 ë §x¢))®);
a(REPEAT_UNTIL is_² strip_tac);
a(z_seq_induction_tacñs® THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(z_¶_tacñ(s1¦s, x'¦x)® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(z_¶_tacñ(s1¦s, x'¦x)® THEN asm_rewrite_tac[]);
val Ûz_seq_cases_thm1Ý = save_pop_thm "z_seq_cases_thm1";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[X](
	µs : seq X | #s = 0 · s = §¢;
	µs : seq X; i : î | #s = i + 1 · ¶s1 : seq X; x : X· #s1 = i ± s = s1 ë §x¢)®);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(strip_asm_tac(z_µ_elimñs® z_seq_cases_thm));
a(all_var_elim_asm_tac1);
a(i_contr_tac THEN swap_nth_asm_concl_tac 3);
a(lemma_tacñ§x¢  (seq_)® THEN1 rewrite_tac[z_singleton_seq_thm]);
a(ALL_FC_T rewrite_tac[z_size_ë_thm]);
a(rewrite_tac[z_size_singleton_seq_thm]);
a(lemma_tacñ#s1  î® THEN1 ALL_FC_T rewrite_tac[z_size_seq_î_thm]);
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tacñ³s = §¢®
	THEN1 (swap_nth_asm_concl_tac 1
		THEN asm_rewrite_tac[z_size_seqd_thm]
		THEN PC_T1 "z_lin_arith" asm_prove_tac[]));
a(all_fc_tac[z_seq_cases_thm1]);
a(z_¶_tacñ(s1 ¦ s1, x ¦ x)® THEN asm_rewrite_tac[]);
a(swap_nth_asm_concl_tac 5 THEN all_var_elim_asm_tac1);
a(lemma_tacñ§x¢  (seq_)® THEN1 rewrite_tac[z_singleton_seq_thm]);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_size_ë_thm]);
a(asm_rewrite_tac[z_size_singleton_seq_thm]);
val Ûz_size_seq_cases_thmÝ = save_pop_thm "z_size_seq_cases_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñµs1, t1, s2, t2 : (seq _) |
	#s2 = #t2 ± s1 ë s2 = t1 ë t2 · s1 = t1 ± s2 = t2®);
a(REPEAT_UNTIL is_± strip_tac);
a(lemma_tacñ¶m:î·#t2 = m® THEN1
	(z_¶_tacñ#t2® THEN REPEAT strip_tac
		THEN all_fc_tac[z_size_seq_î_thm]));
a(LIST_DROP_NTH_ASM_T [1, 3, 4, 5, 6, 7, 8] (MAP_EVERY ante_tac));
a(z_intro_µ_tacñ(s1¦s1, s2¦s2, t1¦t1, t2¦t2)®);
a(z_¼_induction_tac ñm®);
(* *** Goal "1" *** *)
a(REPEAT_UNTIL is_± strip_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
a(strip_tac);
a(all_fc_tac[z_size_seq_cases_thm] THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 2 ante_tac);
a(ALL_FC_T rewrite_tac[z_ë_§¢_thm]);
(* *** Goal "2" *** *)
a(REPEAT_UNTIL is_± strip_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
a(strip_tac);
a(all_fc_tac[z_size_seq_cases_thm] THEN all_var_elim_asm_tac1);
a(rename_tac[(ñs1'®, "s2"), (ñs1''®, "t2")]
	THEN DROP_NTH_ASM_T 6 ante_tac);
a(lemma_tacñ§x¢  (seq_) ± §x'¢  (seq_)® THEN1 rewrite_tac[z_singleton_seq_thm]);
a(ALL_FC_T rewrite_tac[z_ë_assoc_thm1]);
a(lemma_tacñs1 ë s2  (seq_) ± t1 ë t2  (seq_)®
	THEN1 ALL_FC_T1 fc_¤_canon asm_rewrite_tac[z_ë_seq_x_thm]);
a(ALL_FC_T1 fc_¤_canon rewrite_tac[z_ë_one_one_thm]);
a(strip_tac THEN asm_rewrite_tac[]);
a(lemma_tacñ#s2 = #t2® THEN1 asm_rewrite_tac[]);
a(z_spec_nth_asm_tac 17 ñ(s1'¦s1, s2'¦s2, t1'¦t1, t2'¦t2)®);
a(REPEAT strip_tac);
val Ûz_ë_one_one_thm1Ý = save_pop_thm "z_ë_one_one_thm1";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[X](µs : seq X; m, n : î | #s = m + n ·
	¶s1, s2 : seq X · #s1 = m ± #s2 = n ± s = s1 ë s2)®);
a(REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [1, 3, 4] (MAP_EVERY ante_tac));
a(z_intro_µ_tacñ(s¦s, m¦m)®);
a(z_¼_induction_tac ñn®);
(* *** Goal "1" *** *)
a(rewrite_tac[] THEN REPEAT strip_tac);
a(z_¶_tacñ(s1¦s, s2¦§¢)® THEN asm_rewrite_tac[z_size_seqd_thm]);
a(ALL_FC_T rewrite_tac[z_ë_§¢_thm] THEN REPEAT strip_tac);
a(rewrite_tac[z_§¢_seq_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[pc_rule1 "z_lin_arith" prove_rule[]
	ñµn:ƒ·n + (i + 1) = (n + i) + 1®]
	THEN REPEAT strip_tac);
a(lemma_tacñ0 ¼ n + i® THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(all_fc_tac[z_size_seq_cases_thm]);
a(LIST_DROP_NTH_ASM_T [9] all_fc_tac);
a(z_¶_tacñ(s1¦s1', s2¦s2 ë §x¢)®);
a(lemma_tacñ§x¢  (seq _)® THEN1 rewrite_tac[z_singleton_seq_thm]);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T asm_rewrite_tac[z_size_ë_thm, z_ë_assoc_thm]);
a(rewrite_tac[z_size_seqd_thm] THEN REPEAT strip_tac);
a(rename_tac[(ñs2®, "ss2")]
	THEN ALL_FC_T1 fc_¤_canon asm_rewrite_tac[z_ë_seq_x_thm]);
a(asm_rewrite_tac[z_singleton_seq_x_thm]);
val Ûz_ë_onto_thmÝ = save_pop_thm "z_ë_onto_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[V](µm, n : î·
	HCompose[V] (Switch[V] (m, n), Switch[V] (n, m)) =
	(c ¦ m + n, d ¦ m + n, r ¦ id (V ^ (m + n))))®);
a(REPEAT strip_tac THEN
	rename_tac[(¬m:ú®, "M"), (¬n:ú®, "N")]);
a(LEMMA_Tñ(M, N)  î ¸ î® asm_tac THEN1 REPEAT strip_tac);
a(LEMMA_Tñ(N, M)  î ¸ î® asm_tac THEN1 REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¬V®switch_def)));
a(all_fc_tac[z_fun__clauses]);
a(lemma_tacñ(Switch[V] (M, N)).c = (Switch[V] (N, M)).d®
	THEN1 ALL_FC_T rewrite_tac[switch_def]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(ALL_FC_T rewrite_tac[switch_def]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(REPEAT_UNTIL is_¤ strip_tac);
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(all_fc_tac[ë_seq_exp_thm]);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T [2, 3, 4, 5] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_ë_one_one_thm1]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac);
a(lemma_tacñ0 ¼ M + N® THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT strip_tac);
a(all_fc_tac[z_ë_onto_thm]);
a(z_¶_tacñs2 ë s1® THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(z_¶_tacñ(a ¦ s1, b ¦ s2)® THEN asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(z_¶_tacñ(a ¦ s2, b ¦ s1)® THEN asm_rewrite_tac[]);
val Ûswitch_switch_thmÝ = save_pop_thm "switch_switch_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[V](µm, n, k  : î·
	Switch[V] (m + n, k) =
	HCompose[V] (
		VCompose[V](HId[V] m, Switch[V] (n, k)),
		VCompose[V] (Switch[V] (m, k), HId[V] n))
)®);
a(REPEAT strip_tac THEN
	rename_tac[(¬m:ú®, "X"), (¬n:ú®, "Y"), (¬k:ú®, "Z")]);
a(LEMMA_TñX  î ± Y  î® (±_THEN asm_tac) THEN1 REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¬V®switch_def)));
a(lemma_tacñX + Y  î® THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(LEMMA_Tñ(X + Y, Z)  î ¸ î® asm_tac THEN1 REPEAT strip_tac);
a(LEMMA_Tñ(Y, Z)  î ¸ î® asm_tac THEN1 REPEAT strip_tac);
a(LEMMA_Tñ(X, Z)  î ¸ î® asm_tac THEN1 REPEAT strip_tac);
a(all_fc_tac[z_fun__clauses]);
a(DROP_NTH_ASM_T 8 discard_tac);
a(lemma_tacñHId[V] X  Rel[V]
	± HId[V] Y  Rel[V]®
	THEN1 ALL_FC_T rewrite_tac[h_id__rel_thm]);
a(strip_asm_tac (±_left_elim (µ_elim¬V®v_compose_def)));
a(LEMMA_Tñ(HId[V] X, Switch[V] (Y, Z))  Rel[V] ¸ Rel[V]® asm_tac THEN1 REPEAT strip_tac);
a(LEMMA_Tñ(Switch[V] (X, Z), HId[V] Y)  Rel[V] ¸ Rel[V]® asm_tac THEN1 REPEAT strip_tac);
a(all_fc_tac[z_fun__clauses]);
a(LEMMA_Tñ(VCompose[V] (HId[V] X, Switch[V] (Y, Z))).c =
	(VCompose[V] (Switch[V] (X, Z), HId[V] Y)).d® asm_tac THEN1 
	(ALL_FC_T rewrite_tac[v_compose_def]
		THEN ALL_FC_T rewrite_tac[h_id_def, switch_def]
		THEN PC_T1 "z_lin_arith" prove_tac[]));
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(ALL_FC_T rewrite_tac[v_compose_def]);
a(ALL_FC_T rewrite_tac[switch_def, h_id_def]);
a(REPEAT strip_tac
	THEN1 PC_T1 "z_lin_arith" prove_tac[]
	THEN1 PC_T1 "z_lin_arith" prove_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN rewrite_tac[z_id_def]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(LIST_DROP_NTH_ASM_T (interval 1 14) discard_tac);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def] THEN REPEAT strip_tac);
a(all_fc_tac[z_ë_onto_thm]);
a(rename_tac[(ñs1®, "A"), (ñs2®, "B"), (ñb®, "C")]
	THEN all_var_elim_asm_tac1);
a(z_¶_tacñ(A ë C) ë B® THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(z_¶_tacñ(a' ¦ A, b' ¦ B ë C, c ¦ A, d ¦ C ë B)®);
a(conv_tac(LEFT_C(PC_C1 "z_sets_ext" rewrite_conv[])));
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T1 fc_¤_canon asm_rewrite_tac[z_ë_seq_x_thm, z_ë_assoc_thm]);
a(REPEAT strip_tac);
(* *** Goal "1.1.1" *** *)
a(z_¶_tacñ(x ¦ A)® THEN REPEAT strip_tac);
(* *** Goal "1.1.2" *** *)
a(z_¶_tacñ(a'' ¦ B, b'' ¦ C)® THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(z_¶_tacñ(a' ¦ A ë C, b' ¦ B, c ¦ C ë A, d ¦ B)®);
a(conv_tac(LEFT_C(PC_C1 "z_sets_ext" rewrite_conv[])));
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T1 fc_¤_canon asm_rewrite_tac[z_ë_seq_x_thm, z_ë_assoc_thm]);
a(REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(z_¶_tacñ(a'' ¦ A, C' ¦ C)® THEN REPEAT strip_tac);
(* *** Goal "1.2.2" *** *)
a(z_¶_tacñ(x ¦ B)® THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T [1, 2, 3, 4, 8, 9, 10] (MAP_EVERY ante_tac));
a(LIST_DROP_NTH_ASM_T (22::23::interval 1 20) discard_tac);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN REPEAT_N 6 strip_tac);
a(all_var_elim_asm_tac1);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_ë_assoc_thm1] THEN strip_tac);
a(lemma_tacña''' ë b'''  (seq _) ± c ë b'  (seq _)®
	THEN1 ALL_FC_T rewrite_tac[z_ë__seq_thm]);
a(LIST_DROP_NTH_ASM_T (interval 1 22 diff [1, 2, 3, 5, 9, 10])
	(fn ths=> 
		all_fc_tac[z_ë_one_one_thm1]
	THEN MAP_EVERY asm_tac ths));
a(LIST_DROP_NTH_ASM_T (interval 1 24 diff [11, 13, 14, 15, 16, 18])
	(fn ths=> 
		all_fc_tac[z_ë_one_one_thm1]
	THEN MAP_EVERY asm_tac ths));
a(all_var_elim_asm_tac1);
a(z_¶_tacñ(a ¦ c ë a', b ¦ b')®
	THEN ALL_FC_T1
		fc_¤_canon asm_rewrite_tac[
			z_ë_assoc_thm, z_size_ë_thm, z_ë_seq_x_thm]);
val Ûswitch_v_compose_thmÝ = save_pop_thm "switch_v_compose_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "rel_sym_mon_cat_thm");
a(rewrite_tac[sym_mon_cat_def,
	rel_sym_mon_cat_def,
	rewrite_rule[rel_mon_cat_def] rel_mon_cat_thm,
	switch_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[z_plus_î_thm]);
a(LEMMA_Tñ(X, Y)  î ¸ î® asm_tac THEN1 REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¬V®switch_def)));
a(all_fc_tac[z_fun__clauses]);
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(ALL_FC_T rewrite_tac[switch_def]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac[z_plus_î_thm]);
a(LEMMA_Tñ(X, Y)  î ¸ î® asm_tac THEN1 REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¬V®switch_def)));
a(all_fc_tac[z_fun__clauses]);
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(ALL_FC_T rewrite_tac[switch_def]);
(* *** Goal "3" *** *)
a(ALL_FC_T rewrite_tac[z_plus_î_thm, switch_switch_thm]);
a(lemma_tacñX + Y  î® THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[h_id_def]);
(* *** Goal "4" *** *)
a(ALL_FC_T rewrite_tac[z_plus_î_thm, switch_v_compose_thm]);
val Ûrel_sym_mon_cat_thmÝ = save_pop_thm "rel_sym_mon_cat_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[V](RelTraMonCat[V]  TRA_MON_CAT_SIG[î, Rel[V]])®);
a(rewrite_tac[rel_tra_mon_cat_def,
	rewrite_rule[rel_sym_mon_cat_def]
		rel_sym_mon_cat_thm,
	tra_mon_cat_sig_def,
	trace_def]);
val Ûrel_tra_mon_cat_sig_thmÝ = save_pop_thm "rel_tra_mon_cat_sig_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[V](RelTraMonCat[V]  TRA_MON_CAT_DOM[î, Rel[V]])®);
a(rewrite_tac[tra_mon_cat_dom_def,
	rel_tra_mon_cat_def,
	rewrite_rule[rel_tra_mon_cat_def]
		rel_tra_mon_cat_sig_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[trace_def]);
a(PC_T "z_library_ext" strip_tac
	THEN REPEAT_UNTIL is_¤ strip_tac);
a(rewrite_tac[]);
a(cases_tacñ(c ¦ x1, d ¦ x2, r ¦ x3)  Rel[V]®
	THEN asm_rewrite_tac[]);
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(ALL_FC_T rewrite_tac[z_plus_î_thm]);
(* *** Goal "2" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(ALL_FC_T rewrite_tac[z_plus_î_thm]);
a(STRIP_T (strip_asm_tac o conv_rule(ONCE_MAP_C z_Â_conv)));
a(STRIP_T (strip_asm_tac o conv_rule(ONCE_MAP_C z_Â_conv)));
a(lemma_tacñf  dom (Trace[V](X, Y, Z))®
	THEN1 ALL_FC_T asm_rewrite_tac[trace_def]);
a(strip_asm_tac (±_left_elim (µ_elim¬V®trace_def)));
a(LEMMA_Tñ(X, Y, Z)  î ¸ î ¸ î® asm_tac THEN REPEAT strip_tac);
a(all_fc_tac[z_fun__clauses]);
a(DROP_NTH_ASM_T 2 discard_tac THEN all_fc_tac[z_fun__clauses]);
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(ALL_FC_T rewrite_tac[trace_def]);
(* *** Goal "3" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(ALL_FC_T rewrite_tac[z_plus_î_thm]);
a(STRIP_T (strip_asm_tac o conv_rule(ONCE_MAP_C z_Â_conv)));
a(STRIP_T (strip_asm_tac o conv_rule(ONCE_MAP_C z_Â_conv)));
a(lemma_tacñf  dom (Trace[V](X, Y, Z))®
	THEN1 ALL_FC_T asm_rewrite_tac[trace_def]);
a(strip_asm_tac (±_left_elim (µ_elim¬V®trace_def)));
a(LEMMA_Tñ(X, Y, Z)  î ¸ î ¸ î® asm_tac THEN REPEAT strip_tac);
a(all_fc_tac[z_fun__clauses]);
a(DROP_NTH_ASM_T 2 discard_tac THEN all_fc_tac[z_fun__clauses]);
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(ALL_FC_T rewrite_tac[trace_def]);
val Ûrel_tra_mon_cat_dom_thmÝ = save_pop_thm "rel_tra_mon_cat_dom_thm";
=TEX
%%%%
%%%%

=SML
(*
set_goal([], ñ[V](RelTraMonCat[V]  TRA_MON_CAT_NAT[î, Rel[V]])®);
a(rewrite_tac[tra_mon_cat_nat_def,
	rel_tra_mon_cat_def,
	rewrite_rule[rel_tra_mon_cat_def]
		rel_tra_mon_cat_sig_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)


val Ûrel_tra_mon_cat_nat_thmÝ = save_pop_thm "rel_tra_mon_cat_nat_thm";
*)
=TEX
%%%%
%%%%

=SML
(*
set_goal([], ñ[V](RelTraMonCat[V]  TRA_MON_CAT_VAN[î, Rel[V]])®);
a(rewrite_tac[tra_mon_cat_van_def,
	rel_tra_mon_cat_def,
	rewrite_rule[rel_tra_mon_cat_def]
		rel_tra_mon_cat_sig_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)


val Ûrel_tra_mon_cat_van_thmÝ = save_pop_thm "rel_tra_mon_cat_van_thm";
*)
=TEX
%%%%
%%%%

=SML
(*
set_goal([], ñ[V](RelTraMonCat[V]  TRA_MON_CAT_SUP[î, Rel[V]])®);
a(rewrite_tac[tra_mon_cat_sup_def,
	rel_tra_mon_cat_def,
	rewrite_rule[rel_tra_mon_cat_def]
		rel_tra_mon_cat_sig_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)


val Ûrel_tra_mon_cat_sup_thmÝ = save_pop_thm "rel_tra_mon_cat_sup_thm";
*)
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[V](RelTraMonCat[V]  TRA_MON_CAT_YAN[î, Rel[V]])®);
a(rewrite_tac[tra_mon_cat_yan_def,
	rel_tra_mon_cat_def,
	rewrite_rule[rel_tra_mon_cat_def]
		rel_tra_mon_cat_sig_thm]
	THEN REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¬V®switch_def)));
a(LEMMA_Tñ(X, X)  î ¸ î® asm_tac THEN REPEAT strip_tac);
a(all_fc_tac[z_fun__clauses]);
a(LIST_DROP_NTH_ASM_T[2, 3] discard_tac);
a(LEMMA_TñSwitch[V] (X, X)  dom (Trace[V](X, X, X))®ante_tac
	THEN ALL_FC_T asm_rewrite_tac[trace_def]
	THEN1 ALL_FC_T rewrite_tac[switch_def]);
a(strip_tac THEN ALL_FC_T asm_rewrite_tac[trace_def]);
a(ALL_FC_T rewrite_tac[switch_def, h_id_def]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(lemma_tacñ#b' = #c ± #a' = #c® THEN1 asm_rewrite_tac[]);
a(LIST_DROP_NTH_ASM_T (interval 10 22)
	(fn ths=> 
		all_fc_tac[z_ë_one_one_thm1]
	THEN MAP_EVERY asm_tac ths));
a(all_var_elim_asm_tac1 THEN strip_tac);
(* *** Goal "2" *** *)
a(z_¶_tacñ(c ¦ x2)® THEN asm_rewrite_tac[]);
a(z_¶_tacñ(a' ¦ x2, b' ¦ x2)® THEN asm_rewrite_tac[]);
val Ûrel_tra_mon_cat_yan_thmÝ = save_pop_thm "rel_tra_mon_cat_yan_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[V](
	TRA_MON_CAT[î, Rel[V]] = 
	TRA_MON_CAT_SIG[î, Rel[V]]
¡	TRA_MON_CAT_DOM[î, Rel[V]]
¡	TRA_MON_CAT_NAT[î, Rel[V]]
¡	TRA_MON_CAT_VAN[î, Rel[V]]
¡	TRA_MON_CAT_SUP[î, Rel[V]]
¡	TRA_MON_CAT_YAN[î, Rel[V]])
®);
a(rewrite_tac[tra_mon_cat_def]);
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûtra_mon_cat_rw_thmÝ = save_pop_thm "tra_mon_cat_rw_thm";

=TEX
%%%%
%%%%

=SML
(*
set_goal([], get_conjecture"-" "rel_tra_mon_cat_thm");
a(rewrite_tac[tra_mon_cat_rw_thm]);
a(rewrite_tac[rel_tra_mon_cat_sig_thm,
	rel_tra_mon_cat_dom_thm,
	rel_tra_mon_cat_yan_thm]);

(* *** Goal "1" *** *)
(* *** Goal "4" *** *)
a(REPEAT_N 4 (POP_ASM_T ante_tac));
a(ALL_FC_T rewrite_tac[z_plus_î_thm]);
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(REPEAT strip_tac);



set_labelled_goal "10" ;

val Ûrel_tra_mon_cat_thmÝ = save_pop_thm "rel_tra_mon_cat_thm";
*)
=TEX
\section{Epilogue}
=SML
z_output_theory{out_file="wrk075.th.doc", theory="-"};
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
=TEX
\end{document}
=IGN
