=IGN
********************************************************************************
wrk075.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[12pt]{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\def\Hide#1{\relax}
\title{On Refinement of Continuous Systems \\ (DRAFT)}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\section{Introduction}\label{Intro}

This note is the third in a planned series concerned with specification via
pre- and post-conditions in a partial correctness setting.
It applies the general notion of specification and refinement given in the first note in the series
\cite{LEMMA1/ZED/WRK069} to continuous systems.

\Hide{
The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"refcalc";
set_pc"z_library1";
force_delete_theory"ctssys" handle Fail _ => ();
new_theory"ctssys";
new_parent"z_reals";
ReaderWriterSupport.PrettyNames.add_new_symbols[
	(["refinedby"], Value "Ã", ReaderWriterSupport.PrettyNames.Simple), 
	(["ident"], Value "é", ReaderWriterSupport.PrettyNames.Simple)
] handle Fail _ => ();
=TEX
}

The Z specification uses infix or postfix notation for the following relation
and function symbols (in addition to those defined in the first note).
¹Z
Ü function 40  _**_
°

¹Z
Ü function 50  _ ^ _
°

\newpage
\section{WEAKEST PRE-CONDITIONS}
In \cite{LEMMA1/ZED/WRK070}, we give an account of precondition calculation for a small programming language.
In this note, we will be exploring weakest precondition calculation in a less familiar situation.
It is therefore helpful to formalise the abstract concept.

The simplest notion of weakest precondition pulls a post-condition represented as a set back through a relation:

[ Y, Z ]œœœœœœœœœœœ
Ü ÛWPSİ : (Y ª Z) ¸ ğZ ­ ğY
÷üüüüüü
Ü µS : Y ª Z; C : ğZ·
Ü	WPS(S, C) = {y : Y | S ¨{y}© € C}
ˆüüüüüüüüüüüüüü

As noted in \cite{LEMMA1/ZED/WRK070}, a more general notion of weakest precondition calculation deals with relations.
In general, if $S$ and $P$ are binary relations,
we want to specify  $WP(S, P)$ so that it is the weakest (i.e., largest) relation $R$ such that $R\;»\;S \subseteq P$.
We use an explicit formula for $WP$ (cf. the clause for atoms in the function {\em prec\_calc} in \cite{LEMMA1/ZED/WRK070}).

[ X, Y, Z ]œœœœœœœœœœœ
Ü ÛWPİ : (Y ª Z) ¸ (X ª Z) ­ (X ª Y)
÷üüüüüü
Ü µS : Y ª Z; P : X ª Z·
Ü	WP(S, P) = {x : X; y : Y | S ¨{y}© € P¨{x}©}
ˆüüüüüüüüüüüüüü

The following theorem shows that our explicit definition for $WP(S, P)$ is indeed the weakests $R$ such that $R\;»\;S \subseteq P$.

¹Z
Ü wp_correct_thm ?ô
Ü	µS : ƒ; P : ƒ· WP(S, P) » S € P;
Ü	µR : ƒ; S : ƒ; P : ƒ | R » S € P · R € WP(S, P)
°

The relationalal formulation of weakest precondition may be defined in terms of the set formulation:


¹Z
Ü wp_wps_thm ?ô
Ü	µS : ƒ; P : ƒ· WP(S, P) = {x : ƒ; y : ƒ | y  WPS(S, P¨{x}©)}
°

The weakest pre-condition of a conjunction (intersection) is a conjunction:

¹Z
Ü wp_cap_thm ?ô
Ü	µR : ƒ; P, Q : ƒ· WP(R, P ¡ Q) = WP(R, P) ¡ WP(R, Q)
°

The weakest precondition for a relational composition is given by the following theorem.

¹Z
Ü wp_comp_thm ?ô
Ü	µR : ƒ; S : ƒ; P : ƒ· WP(R » S, P) = WP(R, WP(S, P))
°

¹Z
Ü wps_compl_dom_thm ?ô
Ü	µS : ƒ; C : ƒ ·
Ü		ƒ \ dom S € WPS(S, C)
°


[ X, Y, V, W ]œœœœœœœœœœœ
Ü Û_**_İ : (X ª Y) ¸ (V ª W) ­ (X ¸ V ª Y ¸ W)
÷üüüüüü
Ü µR : X ª Y; S : V ª W·
Ü	R ** S =
Ü	{x : X; y : Y; v : V; w : W
Ü	| (x, y)  R ± (v, w)  S · ( (x, v), (y, w) )}
ˆüüüüüüüüüüüüüü

¹Z
Ü wps_prod_thm ?ô
Ü	µR : ƒ; S : ƒ; B : ƒ; C : ƒ ·
Ü		WPS(R ** S, B ¸ C) = (WPS(R, B) ¸ WPS(S, C)) À (ƒ \ (dom R ¸ dom S))
°

[ X, Y, V ]œœœœœœœœœœœ
Ü ÛProj‰¶İ : (X ¸ V ª Y ¸ V) ­ (X ª Y)
÷üüüüüü
Ü µR : (X ¸ V ª Y ¸ V)·
Ü	Proj‰¶ R =
Ü	{x : X; y : Y | ¶v : V· ((x, v), (y, v))  R}
ˆüüüüüüüüüüüüüü

¹Z
Ü wps_proj_exists_thm ?ô
Ü	µR : ƒ;  C : ƒ ·
Ü	{x: ƒ; v: ƒ | (x, v)  WPS(R ¡ (ƒ ** (id _)), C ¸ ƒ)· x} € WPS(Proj‰¶ R, C)
°

\newpage
\section{A CATEGORY OF RELATIONS}

We are going to work with systems of relations that can naturally be expressed diagrammatically.
The elements of the diagrams are called {\em boxes} and {\em wires}.
A box with $m$ inputs and $n$ outputs represents a relation between $V^m$ and $V^n$ for some suitable value domain $V$.
The produce new relations from old by adding equational constraints.
The diagrams need not form directed graphs: feedback loops are allowed and correspond to existential quantification.


Our approach to the syntax and semantics of diagrams is informed by the idea of a traced monoidal category.
The idea is that diagrams correspond to functor expressions in such a category.  Composition in the category corresponds to wiring diagrams in series.
The monoid operator corresponds to putting two diagrams together without adding any wiring.
Finally the trace operator corresponds to adding feedback loops to diagram.


If $V$ is any set, $V^m$ gives the set of all $m$-tuples with values ranging over $V$.
Typically $V^m$ represents the vector of inputs or outputs of a box in a diagram.

[ U ]œœœœœœœœœœœ
Ü Û_ ^ _İ : ğU ¸ î ­ ğ(seq U)
÷üüüüüü
Ü µV : ğU; m:î· V ^ m =  {s : seq V | #s = m}
ˆüüüüüüüüüüüüüü

For each set $V$, there is a category, which we shall call $Rel[V]$, whose objects are the natural numbers and whose morphisms (a.k.a. arrows) from $m$ to $n$ are the relations between $V^m$ and $V^n$ composed via ordinary relational composition\footnote{
We take the objects to be the natural numbers, $m$, rather than the sets $V^m$ for technical convenience to avoid having the category collapse when $V = \{\}$.
}.
We represent the category in Z by defining its set of morphisms.
A morphism is given as labelled triple whose components give the domain ($d$), codomain ($c$), and the relation ($r$).

¹Z
Ü ÛRelİ[V] ¦ Ş{m, n : î · {R : V^m ª V^n· (d ¦ m, c ¦ n, r ¦ R)}}
°

The composition of morphisms that makes $Rel[V]$ into a category is the ``horizontal'' composition defined below.

[V]œœœœœœœœœœœ
Ü ÛHComposeİ : Rel[V] ¸ Rel[V] ß Rel[V]
÷üüüüüü
Ü dom HCompose = {R, S : Rel[V] | R.c = S.d} ;
Ü µR, S : Rel[V] | R.c = S.d ·
Ü	HCompose(R, S) = (d ¦ R.d, c ¦ S.c, r ¦ R.r » S.r)
ˆüüüüüüüüüüüüüü

The category becomes a monoidal category under a product given by addition on objects and by the following ``vertical composition'' on morphisms.

 
[V]œœœœœœœœœœœ
Ü ÛVComposeİ : Rel[V] ¸ Rel[V] ­ Rel[V]
÷üüüüüü
Ü µR, S : Rel[V] ·
Ü	VCompose(R, S) = (d ¦ R.d + S.d, c ¦ R.c + S.c,
Ü		r ¦ {a, b, c, d : seq V | (a, c)  R.r ± (b, d)  S.r· (a ë b, c ë d)})
ˆüüüüüüüüüüüüüü

Finally, we get a traced monoidal category by defining the following operator that corresponds to adding $k$ feedback loops into a diagram.
 
[V]œœœœœœœœœœœ
Ü ÛFeedbackİ : Rel[V] ¸ î ß Rel[V]
÷üüüüüü
Ü dom Feedback = {R : Rel[V]; k : î | ¶m, n : î·R.d = m + k ± R.c = n + k} ;
Ü µR : Rel[V]; k, m, n : î | R.d = m + k ± R.c = n + k ·
Ü	Feedback(R, k) = (d ¦ m, c ¦ n,
Ü		r ¦ {a, b : seq V | ¶c:V^k· (a ë c, b ë c)  R.r})
ˆüüüüüüüüüüüüüü

To use the relation category, we will generally need to know something about the value domain, $V$.
However, we can define at least one generic construction corresponding to patching inputs to outputs according to a wiring diagram (given as a relation between input port numbers and output port numbers):


[V]œœœœœœœœœœœ
Ü ÛPatchİ : î ¸ î ¸ (î ª î) ­ Rel[V]
÷üüüüüü
Ü µm, n : î; d : î ª î·
Ü	Patch(m, n, d) = (d ¦ m, c ¦ n,
Ü		r ¦ {a : V^m; b : V^n | µi : 1..m; j : 1..n |(i, j)  d· b j = a i})
ˆüüüüüüüüüüüüüü

\section{SIGNAL FLOW GRAPHS}

A {\em signal} will be a real-valued function of a real variable.

¹Z
Ü ÛSIGNALİ ¦ ¯ ­ ¯
°

The category of signal flow graphs is then the relational category with the value domain given by signals.


¹Z
Ü ÛSFGİ ¦ Rel[SIGNAL]
°

We instantiate the notions of predicates, pre- post-conditions
and specifications from \cite{LEMMA1/ZED/WRK069} so that we can use them to express properties of signals:

¹Z
Ü ÛS_PREDİ ¦ PRED[SIGNAL]
°
¹Z
Ü ÛS_PRE_CONDİ ¦ PRE_COND[SIGNAL]
°
¹Z
Ü ÛS_POST_CONDİ ¦ POST_COND[SIGNAL, SIGNAL]
°
¹Z
Ü ÛS_SPECİ ¦ SPEC[SIGNAL, SIGNAL]
°
We now have a notion of diagram which is in quite close analogy with the notion of imperative program considered in \cite{LEMMA1/ZED/WRK070}.

¹Z
Ü ÛDIAGRAMİ ::=
Ü	ÛAtomİ (SFG)
Ü |	ÛSeqİ (DIAGRAM ¸ DIAGRAM)
Ü |	ÛParİ (DIAGRAM ¸ DIAGRAM)
Ü |	ÛLoopİ (DIAGRAM ¸ î)
Ü |	ÛSpecİ (S_SPEC ¸ DIAGRAM)
°


\bibliographystyle{fmu}
\bibliography{fmu}


\newpage
\appendix
\section{SOME CATEGORY THEORY}
A category with the set of objects $O$ and the set of arrows $A$ is represented by a member of the following generic schema,
in which we agree to write composition in the category left to right.


¹Z
Ü function 40 leftassoc  _ »‰c _
°


ÿ CAT[O, A] üüüüüüüüüüü
Ü Û_ »‰c _İ : A ¸ A ß A ;
Ü Ûdom‰cİ, Ûcod‰cİ : A ­ O ;
Ü Ûid‰cİ : O ­ A
÷üüüüüü
Ü dom (_ »‰c _) = {f, g : A | cod‰c f = dom‰c g} ;
Ü µf, g, h : A | cod‰c f = dom‰c g ± cod‰c g = dom‰c h ·
Ü	(f »‰c g) »‰c h = f »‰c (g »‰c h) ;
Ü µf, g :  A | cod‰c f = dom‰c g ·
Ü	dom‰c (f »‰c g) = dom‰c f ± cod‰c (f »‰c g) = cod‰c g ;
Ü µ X : O ·
Ü	dom‰c (id‰c X) = cod‰c (id‰c X) = X ;
Ü µ f : A ·
Ü	id‰c(dom‰c f) »‰c f = f »‰c id‰c(cod‰c f) = f
ˆüüüüüüüüüüüüüü

We can now state the theorem that $Rel[V]$ with the appropriate structure is indeed a category.

¹Z
Ü rel_cat_thm ?ô [V](
Ü	(_ »‰c _ ¦ HCompose[V],
Ü	dom‰c ¦ (ÌR:Rel[V]·R.d),
Ü	cod‰c ¦ (ÌR:Rel[V]·R.c),
Ü	id‰c ¦ (Ìm:î·(d ¦ m, c ¦ m, r ¦ id(V^m))))  CAT[î, Rel[V]])
°


\newpage
\appendix
=TEX
{\HOLindexOff\small
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{wrk075.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%
%% Comment out next line to include the proofs in the printed document:
\end{document}

\section{Proofs}
=TEX
\ftlinepenalty=999
=SML
val Ûwps_defİ = z_get_specñWPS®;
val Ûwp_defİ = z_get_specñWP®;
val Ûset_exp_defİ = z_get_specñ(_^_)®;
val Ûrel_prod_defİ = z_get_specñ(_**_)®;
val Ûproj_¶_defİ = z_get_specñProj‰¶®;
val Ûrel_defİ = z_get_specñRel[V]®;
val Ûh_compose_defİ = z_get_specñHCompose®;
val Ûv_compose_defİ = z_get_specñVCompose®;
val Ûfeedback_defİ = z_get_specñFeedback®;
val Ûcat_defİ = z_get_specñCAT®;
=TEX
%%%%
%%%%
=SML
set_goal([], ñµR:ƒ; x : ƒ·R¨{x}© = {z : ƒ | (x, z)  R}®);
a(PC_T1 "z_library_ext" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
a(z_¶_tacñx® THEN asm_rewrite_tac[]);
val Ûz_image_singleton_thmİ = save_pop_thm "z_image_singleton_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ñµS:ƒ;C: ƒ·
	WPS (S, C) = {y:ƒ| µz:ƒ·(y, z)  S ´ z  C}®);
a(rewrite_tac[z_image_singleton_thm, z_gen_pred_u_elim wps_def]);
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûwps_rw_thmİ = save_pop_thm "wps_rw_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ñµS:ƒ;P: ƒ·
	WP (S, P) = {x:ƒ; y:ƒ| µz:ƒ·(y, z)  S ´ (x, z)  P}®);
a(rewrite_tac[z_image_singleton_thm, z_gen_pred_u_elim wp_def]);
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûwp_rw_thmİ = save_pop_thm "wp_rw_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wp_correct_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wp_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûwp_correct_thmİ = save_pop_thm "wp_correct_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wp_wps_thm");
a(rewrite_tac[z_image_singleton_thm]);
a(PC_T1 "z_library_ext" rewrite_tac[wp_rw_thm, wps_rw_thm]);
val Ûwp_wps_thmİ = save_pop_thm "wp_wps_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wp_cap_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wp_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûwp_cap_thmİ = save_pop_thm "wp_cap_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wp_comp_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wp_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûwp_comp_thmİ = save_pop_thm "wp_comp_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñµC:ƒ·WPS({}, C) = ƒ®);
a(rewrite_tac[wps_rw_thm]);
val Ûwps_empty_thmİ = save_pop_thm "wps_empty_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_compl_dom_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val Ûwps_compl_dom_thmİ = save_pop_thm "wps_compl_dom_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ
	µR : ƒ; S : ƒ; x1 : ƒ; y1 : ƒ; v1 : ƒ; w1 : ƒ·
	(¶ x : ƒ; y : ƒ; v : ƒ; w : ƒ
	| (x, y)  R ± (v, w)  S
 	· (x = x1 ± v = v1) ± y = y1 ± w = w1)
¤	(x1, y1)  R ± (v1, w1)  S
®);
a(PC_T1 "z_library_ext" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
a(z_¶_tacñ(x ¦ x1, v ¦ v1, y ¦ y1, w ¦ w1)® THEN asm_rewrite_tac[]);
val Ûrel_prod_rw_thmİ = save_pop_thm "rel_prod_rw_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñµR : ƒ; S : ƒ· dom (R ** S) = dom R ¸ dom S®);
a(PC_T1 "z_library_ext" rewrite_tac[
	z_gen_pred_u_elim rel_prod_def,
	rel_prod_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
a(z_¶_tacñ(y, y')® THEN asm_rewrite_tac[]);
val Ûdom_rel_prod_thmİ = save_pop_thm "dom_rel_prod_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_prod_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm,
	rel_prod_rw_thm,
	z_gen_pred_u_elim rel_prod_def]);
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 (ante_tac o z_µ_elim ñ(z, y')®));
a(asm_rewrite_tac[] THEN taut_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 (ante_tac o z_µ_elim ñ(y, z)®));
a(asm_rewrite_tac[] THEN taut_tac);
val Ûwps_prod_thmİ = save_pop_thm "wps_prod_thm";
=TEX
%%%%
%%%%

=SML
(*
set_goal([], get_conjecture"-" "wps_proj_exists_thm");
a(PC_T1 "z_library_ext" rewrite_tac[
	z_gen_pred_u_elim rel_prod_def,
	wps_rw_thm,
	z_gen_pred_u_elim proj_¶_def]);
a(PC_T1 "z_library_ext" REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 2 (ante_tac o z_µ_elimñ(z, v')®));
a(asm_rewrite_tac[]);
a(STRIP_T bc_thm_tac);

val Ûwps_proj_exists_thmİ = save_pop_thm "wps_proj_exists_thm";
*)
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[V] 
	(Rel[V] = {m, n:î; R : ƒ | R  V^m ª V^n· (d ¦ m, c ¦ n, r ¦ R)})®);
a(rewrite_tac[rel_def] THEN REPEAT strip_tac);
a(PC_T "z_sets_ext" strip_tac THEN REPEAT strip_tac
	THEN REPEAT all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(z_¶_tacñ(m ¦ x2, n ¦ x1, R ¦ x3)® THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(z_¶_tacñ{R : V ^ x2 ª V ^ x1 · (c ¦ x1, d ¦ x2, r ¦ R)}®
	THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(z_¶_tacñ(m ¦ x2, n ¦ x1)® THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(z_¶_tacñx3® THEN asm_rewrite_tac[]);
val Ûrel_rw_thmİ = save_pop_thm "rel_rw_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ñ[V] 
	(µA:ƒ·A  Rel[V] ¤ A.c  î ± A.d  î ± A.r  V^(A.d) ª V^(A.c))®);
a(rewrite_tac[rel_rw_thm] THEN REPEAT strip_tac
	THEN REPEAT all_var_elim_asm_tac1
	THEN_TRY asm_rewrite_tac[]);
a(z_¶_tacñ(m ¦ A.d, n ¦ A.c, R ¦ A.r)® THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" asm_rewrite_tac[]);
val Û_rel_thmİ = save_pop_thm "_rel_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¬µf X Y·
	ñ(Ìm:X· ¬f m®)  X ­ Y ¤ (µx:X · ¬f x®  Y)®®);
a(PC_T1 "z_fun_ext" prove_tac[]);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
a(all_var_elim_asm_tac1 THEN strip_tac);
val ÛÌ__­_thmİ = save_pop_thm "Ì__­_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], get_conjecture"-" "rel_cat_thm");
a(rewrite_tac[cat_def, h_compose_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[
	conv_rule(ONCE_MAP_C Â_conv)
	(µ_elim¬ÌR·ñ(R º Rel[V]).d®® Ì__­_thm)]);
a(z_strip_tac THEN PC_T1 "z_library_ext" rewrite_tac [_rel_thm]
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[
	conv_rule(ONCE_MAP_C Â_conv)
	(µ_elim¬ÌR·ñ(R º Rel[V]).c®® Ì__­_thm)]);
a(z_strip_tac THEN PC_T1 "z_library_ext" rewrite_tac [_rel_thm]
	THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(rewrite_tac[
	conv_rule(ONCE_MAP_C Â_conv)
	(µ_elim¬Ìm·ñ(c ¦ m, d ¦ m, r ¦ id (V ^ m))®® Ì__­_thm)]);
a(rewrite_tac[_rel_thm]);
a(REPEAT strip_tac);
a(rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[] ñµA:ƒ· id A  A ª A®]);
(* *** Goal "4" *** *)
a(PC_T1 "z_library_ext" rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(asm_rewrite_tac[]);
(* *** Goal "4.2" *** *)
a(POP_ASM_T ante_tac THEN conv_tac(ONCE_MAP_C z_Â_conv));
a(asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac);
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(REPEAT strip_tac);
a(lemma_tacñ(f, g)  dom HCompose[V] ± (g, h)  dom HCompose[V]®
	THEN1  PC_T1 "z_sets_ext" asm_rewrite_tac[h_compose_def]);
a(strip_asm_tac (±_left_elim (µ_elim¬V®h_compose_def)));
a(ALL_FC_T (MAP_EVERY ante_tac)[z_fun__clauses]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(REPEAT strip_tac THEN lemma_tac ñ
	(c ¦ g.c, d ¦ f.d, r ¦ f.r » g.r).c = h.d
	± f.c = (c ¦ h.c, d ¦ g.d, r ¦ g.r » h.r).d®
	THEN1 asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
	ñµf, g, h:ƒ· f » g » h = f » (g » h)®]);
(* *** Goal "6" *** *)
a(POP_ASM_T ante_tac);
a(conv_tac(LEFT_C(ONCE_MAP_C z_Â_conv)));
a(REPEAT strip_tac);
a(lemma_tacñ(f, g)  dom HCompose[V]®
	THEN1 PC_T1 "z_sets_ext" asm_rewrite_tac[h_compose_def]);
a(strip_asm_tac (±_left_elim (µ_elim¬V®h_compose_def)));
a(ALL_FC_T (MAP_EVERY ante_tac)[z_fun__clauses]);
a(strip_tac);
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(ALL_FC_T rewrite_tac[h_compose_def]);
(* *** Goal "7" *** *)
a(POP_ASM_T ante_tac);
a(conv_tac(LEFT_C(ONCE_MAP_C z_Â_conv)));
a(REPEAT strip_tac);
a(lemma_tacñ(f, g)  dom HCompose[V]®
	THEN1 PC_T1 "z_sets_ext" asm_rewrite_tac[h_compose_def]);
a(strip_asm_tac (±_left_elim (µ_elim¬V®h_compose_def)));
a(ALL_FC_T (MAP_EVERY ante_tac)[z_fun__clauses]);
a(strip_tac);
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(ALL_FC_T rewrite_tac[h_compose_def]);
(* *** Goal "8" *** *)
a(LEMMA_T ñX  î® asm_tac THEN REPEAT strip_tac);
a(conv_tac (RANDS_C(RAND_C z_Â_conv)));
a(lemma_tacñ(c ¦ X, d ¦ X, r ¦ id(V ^ X))  Rel[V]®
	THEN1 asm_rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ñµA:ƒ· id A  A ª A®,
		_rel_thm]);
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(rewrite_tac[]);
(* *** Goal "9" *** *)
a(LEMMA_T ñX  î® asm_tac THEN REPEAT strip_tac);
a(conv_tac (LEFT_C(RAND_C z_Â_conv)));
a(lemma_tacñ(c ¦ X, d ¦ X, r ¦ id(V ^ X))  Rel[V]®
	THEN1 asm_rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ñµA:ƒ· id A  A ª A®,
		_rel_thm]);
a(conv_tac(ONCE_MAP_C z_Â_conv));
a(rewrite_tac[]);
(* *** Goal "10" *** *)
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[_rel_thm]));
a(LEMMA_T ñf.c  î® asm_tac THEN REPEAT strip_tac);
a(LEMMA_T ñf.d  î® asm_tac THEN REPEAT strip_tac);
a(conv_tac(MAP_C z_Â_conv));
a(lemma_tacñ(c ¦ f.d, d ¦ f.d, r ¦ id(V ^ f.d))  Rel[V]
	± (c ¦ f.d, d ¦ f.d, r ¦ id(V ^ f.d)).c = f.d
	± (c ¦ f.c, d ¦ f.c, r ¦ id(V ^ f.c))  Rel[V]
	± f.c = (c ¦ f.c, d ¦ f.c, r ¦ id(V ^ f.c)).d®
	THEN1 asm_rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ñµA:ƒ· id A  A ª A®,
		_rel_thm]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ñµA:ƒ; B:ƒ; R:ƒ· R  A ª B ´
			R » id B = id A » R = R®]);
(* *** Goal "11" *** *)
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[_rel_thm]));
a(LEMMA_T ñf.c  î® asm_tac THEN REPEAT strip_tac);
a(conv_tac(MAP_C z_Â_conv));
a(lemma_tacñ(c ¦ f.c, d ¦ f.c, r ¦ id(V ^ f.c))  Rel[V]
	± f.c = (c ¦ f.c, d ¦ f.c, r ¦ id(V ^ f.c)).d®
	THEN1 asm_rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ñµA:ƒ· id A  A ª A®,
		_rel_thm]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ñµA:ƒ; B:ƒ; R:ƒ· R  A ª B ´
			R » id B = id A » R = R®]);
a(PC_T1 "z_library_ext" rewrite_tac[]);
val Ûrel_cat_thmİ = save_pop_thm "rel_cat_thm";

=TEX
\section{Epilogue}
=SML
z_output_theory{out_file="wrk075.th.doc", theory="-"};
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
=TEX
\end{document}
=IGN
