=IGN
********************************************************************************
wrk075.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
$Id: wrk075.doc,v 1.22 2010/03/03 11:35:32 rda Exp rda $
********************************************************************************
=TEX
\documentclass[12pt]{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\usepackage{epsf}
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\def\Hide#1{\relax}
\title{A Traced Monoidal Category of Relations\\ (DRAFT)\thanks{Copyright {\copyright} Lemma 1 Ltd. \number\year; filed in the {\Product} source code repository as {\tt wrk075.doc}; $Revision: 1.22 $.}}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\section{Introduction}\label{Intro}

This note is the third in a series concerned with specification via
pre- and post-conditions.
It sets up a generic framework for systems formed by wiring together primitive building blocks.
Such systems will be modelled as relations using existentially quantified equations for the fixed points that correspond to feedback loops in the wiring diagram.
The approach is based on the notion of traced monoidal categories, e.g., see~\cite{Hasegawa03}.
The category-phobic reader should not despair as the discussion here is self-contained, and the relatively simple ideas that fall under this fancy name do provide a very nice general algebraic way of thinking about diagrammatic models.

\Hide{
The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"refcalc";
set_pc"z_library1";
force_delete_theory"ctssys" handle Fail _ => ();
new_theory"ctssys";
new_parent"z_reals";
ReaderWriterSupport.PrettyNames.add_new_symbols[
	(["refinedby"], Value "√", ReaderWriterSupport.PrettyNames.Simple), 
	(["ident"], Value "È", ReaderWriterSupport.PrettyNames.Simple)
] handle Fail _ => ();
=TEX
}

\section{TRACED MONOIDAL CATEGORIES}
In this section we formalise the notion of a traced monoidal category.
The reader can think of this as just providing a convenient syntax for expressing diagrams of components connected by ``wires'' of some sort, together with a set of algebraic relations expressing some evident identities that ought to hold in such diagrams.

As an example, consider what one might call the {\em Kirchhoff category} which models a class of electrical circuits.
Some building blocks for these circuits are shown in figure~\ref{kir_blks} on page~\pageref{kir_blks}.
Here one should think of the nodes labelled $X_i$ as inputs and of those labelled $Y_j$ as outputs.
The values of these labels range over some set of names.
Circuits are constructed by wiring together inputs and outputs (and deleting the labels on the resulting internal nodes).
The resistor building block is labelled with a non-negative real number $R$ giving its resistance in ohms.



\begin{figure}
\begin{center}
\epsffile{wrk075f.eps}
\end{center}
\caption{Kirchhoff Category: Some Building Blocks}
\label{kir_blks}
\end{figure}

The laws of Kirchhoff and Ohm imply relationships that must hold between the voltages, $V_{X_i}$, $V_{Y_j}$, and currents, $I_{X_i}$, $I_{Y_j}$,  that obtain at the labelled nodes in a physical realisation of a circuit. Taking the sense of current flow so that the nodes labelled $X_i$ act as positive current sources, the four building blocks of figure~\ref{kir_blks} impose the following constraints:

\begin{center}
\begin{tabular}{ll|ll}
Fan-out: & 
$\begin{array}[c]{l}
V_{Y_1} = V_{Y_2} = V_{X_1}\\
I_{Y_1} + I_{Y_2} = I_{X_1}
\end{array}$
&
Fan-in: & 
$\begin{array}[c]{l}
V_{Y_1} = V_{X_1} = V_{X_2}\\
I_{Y_1} = I_{X_1} + I_{X_2}
\end{array}$
\\\hline
Cross-over: & 
$\begin{array}[c]{ll}
V_{Y_i} = V_{X_{3-i}}\\
I_{Y_i} = I_{X_{3-i}}
\end{array}$
&
Resistor: & 
$\begin{array}[c]{ll}
V_{Y_1} = V_{X_1} - RI_{X_1}\\
I_{Y_1} = I_{X_1}
\end{array}$
\end{tabular}
\end{center}

On solving these equations for the circuits in figure~\ref{kir_eq} on page~\ref{kir_eq}, one finds that the three circuits are equivalent.
The idea of a traced monoidal category will formalise the process of building up the overall input-output relationship of a circuit from its constituent parts.
The algebraic laws satisfied by a traced monoidal category capture equivalences like that of the first two circuits in figure~\ref{kir_eq} which are essentially independent of the semantics of the basic building blocks.
The laws also provide a way of structuring proofs that do depend on the semantics (like the other equivalence in figure~\ref{kir_eq}).


\begin{figure}
\begin{center}
\epsffile{wrk075g.eps}
\end{center}
\caption{Kirchoff Category: Some Equivalent Circuits}
\label{kir_eq}
\end{figure}

The operators that we are using to build diagrams are shown in figure~\ref{building_ops} on page~\pageref{building_ops}.
The notion of traced monoidal category that we are now going to define may be viewed as an algevraic theory of these operators.
The formalisation of this notion deals with the operators in turn.

\begin{figure}
\begin{center}
\epsffile{wrk075h.eps}
\end{center}
\caption{Building Diagrams}
\label{building_ops}
\end{figure}

The first stage in the formalisation deals with horizontal composition.
Horizontal composition is a partial operation: in the Kirchoff category, two circuits $f$ and $g$ can only be composed horizontally if $f$ has the same number of outputs as $g$ has of inputs.
The composition is associative in the sense that
=INLINEFT
fª(gªh) = (fªg)ªh
=TEX
\ whenever these composites are defined.
In the Kirchoff category, a vertical stack of an appropriate number of resistors with $R = 0$ provides a unit for the composition.
All this means that horizontal composition is the composition operator of a {\em category} whose morphisms or {\em arrows} are the diagrams and whose objects are the vectors of inputs or outputs of a circuit.

Formally, we specify a category in Z to be a member of the generic schema $CAT$ defined below. The generic parameters $O$ and $A$ give the sets of objects and arrows of the category respectively. In the Kirchhoff category, the domain and codomain operators correspond to the operations of reading off the vector of inputs or outputs of a circuit and the identity operator corresponds to
the operation of constructing a vertical stacks of resistors with $R = 0$.

πZ
‹ function 40 leftassoc  _ ªâc _
∞


ˇ €CAT›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ _ ªâc _ : A ∏ A ﬂ A ;
‹ domâc, codâc : A ≠ O ;
‹ idâc : O ≠ A
˜¸¸¸¸¸¸
‹ dom (_ ªâc _) = {f, g : A | codâc f = domâc g} ;
‹ µf, g, h : A | codâc f = domâc g ± codâc g = domâc h ∑
‹	(f ªâc g) ªâc h = f ªâc (g ªâc h) ;
‹ µf, g :  A | codâc f = domâc g ∑
‹	domâc (f ªâc g) = domâc f ± codâc (f ªâc g) = codâc g ;
‹ µ X : O ∑
‹	domâc (idâc X) = codâc (idâc X) = X ;
‹ µ f : A ∑
‹	idâc(domâc f) ªâc f = f ªâc idâc(codâc f) = f
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

We now look at vertical composition: in the Kirchhoff category, vertical composition is associative, has a unit given by an empty diagram, preserves identities and commutes with horizontal composition in the senses illustrated in  figure~\ref{bifunc} on page~\pageref{bifunc}.
In categorical terminology, the vertical composition is an associative bifunctor from the category to itself with a unit, and a category possessing this additional structure is called a monoidal category.

Formally, we specify a monoidal category by the following generic schema {\em MON\_CAT}. In which $´_o$ and $´_a$ give the vertical composition operations for objects and arrows respectively and $Iâ´$ gives the unit. (One could do without $´_o$ here, but it helps to make the definition succinct).
In informal narrative, we will often omit the subscripts from $´_o$ and $´_a$.

πZ
‹ function 40 leftassoc _ ´âo _, _ ´âa _
∞


ˇ €MON_CAT›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ CAT[O, A] ;
‹ _ ´âo _ : O ∏ O ≠ O;
‹ _ ´âa _ : A ∏ A ≠ A;
‹ Iâ´ : A
˜¸¸¸¸¸¸
‹ µf, g, h : A∑ (f ´âa g) ´âa h = f ´âa (g ´âa h) ;
‹ µf : A∑ (f ´âa Iâ´) = (Iâ´ ´âa f) = f ;
‹ µ X, Y : O∑ X ´âo Y = domâc (idâc X ´âa idâc Y);
‹ µ X, Y : O∑ idâc X ´âa idâc Y = idâc (X ´âo Y) ;
‹ µ f, g, p, q : A |
‹	codâc f = domâc g ± codâc p = domâc q ∑
‹	(f ªâc g) ´âa (p ªâc q) = (f ´âa p) ªâc (g ´âa q)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸


\begin{figure}
\begin{center}
\epsffile{wrk075a.eps}
\end{center}
\caption{Monoidal Categories: Bifunctoriality}
\label{bifunc}
\end{figure}

In the Kirchoff category, we included a cross-over for two wires as a basic building block.
Since any permutation of a vector of elements can be written as a product of permutations that exchange adjacent elements, this can be used to implement any permutation of the inputs.
Any such permutation is an isomorphism in the category, i.e., an arrow with an inverse with respect to horizontal composition.
In particular, if $X$ and $Y$ are objects in the category (vectors of voltage-current pairs), one has an isomorphism or {\em symmetry} between the vertical compositions
=INLINEFT
X ´ Y
=TEX
\ and
=INLINEFT
Y ´ X
=TEX
.
Subject to a condition which ensures that symmetries compose just like transpositions of elements in a vector, this means that our category is what is called a {\em symmetric monoidal category}.

Formally, a symmetric monoidal category is to be a member of the following generic schema. Here, for objects $X$ and $X$, the arrow $Sym(X, Y)$ is the isomorphism between
=INLINEFT
X ´ Y
=TEX
\ and
=INLINEFT
Y ´ X
=TEX
.

ˇ €SYM_MON_CAT›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ MON_CAT[O, A] ;
‹ Sym : O ∏ O ≠ A
˜¸¸¸¸¸¸
‹ µ X, Y : O ∑ domâc(Sym(X, Y)) = X ´âo Y ± codâc(Sym(X, Y)) = Y ´âo  X ;
‹ µ X, Y : O ∑ Sym(X, Y) ªâc Sym(Y, X) = idâc (X ´âo Y) ;
‹ µ X, Y, Z : O ∑
‹	Sym(X ´âo Y, Z) =
‹	(idâc X ´âa Sym(Y, Z)) ªâc (Sym(X, Z) ´âa idâc Y)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Finally, we deal with the feeback or {\em trace} operator.

We now give the definition of a traced monoidal category in stages.
A traced monoidal category will be a symmetric monoidal category equipped with a trace operator which comprises a partial function from arrows to arrows parameterised by three objects:

ˇ €TRA_MON_CAT_SIG›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ SYM_MON_CAT[O, A] ;
‹ Trc : O ∏ O ∏ O ≠ A ﬂ A
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Our first requirement on the trace operator says that $Trc(X, Y, Z)$ maps an arrow from $X \oplus Z$ to $Y \oplus Z$  
to an arrow from $X$ to $Y$.
Typically one thinks of the trace operator as taking a fixed point with respect to to the part of an arrow from
$X \oplus Z$ to $Y \oplus Z$ that lies over $Z$.

ˇ €TRA_MON_CAT_DOM›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ TRA_MON_CAT_SIG[O, A]
˜¸¸¸¸¸¸
‹ µ X, Y, Z : O ∑
‹	dom (Trc(X, Y, Z)) = {f : A | domâc f = X ´âo Z ± codâc f = Y ´âo Z} ;
‹ µ X, Y, Z : O; f : A |
‹	domâc f = X ´âo Z ± codâc f = Y ´âo Z ∑
‹	domâc (Trc(X, Y, Z) f) = X ± codâc (Trc(X, Y, Z) f) = Y
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

The following are the naturality properties required of $Trc(X, Y, Z)$. Hasegawa calls these three properties {\em left tightening},  {\em right tightening} and {\em sliding}.
The properties are illustrated in figure~\ref{tmc_nat} on page~\pageref{tmc_nat}.

ˇ €TRA_MON_CAT_NAT›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ TRA_MON_CAT_SIG[O, A]
˜¸¸¸¸¸¸
‹ µ W, X, Y, Z : O; f, h : A |
‹	domâc f = W ´âo Z ± codâc f = Y ´âo Z ;
‹	domâc h = X ± codâc h = W ∑
‹	Trc(X, Y, Z) ((h ´âa idâc Z) ªâc f) =
‹	h ªâc Trc(W, Y, Z) f ;
‹ µ W, X, Y, Z : O; f, h : A |
‹	domâc f = X ´âo Z ± codâc f = W ´âo Z ;
‹	domâc h = W ± codâc h = Y ∑ (* Y not X! *)
‹	Trc(X, Y, Z) (f ªâc (h ´âa idâc Z)) =
‹	Trc(X, W, Z) f ªâc h; (* in that order! *)
‹ µ W, X, Y, Z : O; f, h : A |
‹	domâc f = X ´âo W ± codâc f = Y ´âo Z ;
‹	domâc h = Z ± codâc h = W ∑
‹	Trc(X, Y, Z) ((idâc X ´âa h) ªâc f) =
‹	Trc(X, Y, W) (f ªâc (idâc Y ´âa h))
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

\begin{figure}
\begin{center}
\epsffile{wrk075b.eps}
\end{center}
\caption{Traced Monoidal Categories: Naturality}
\label{tmc_nat}
\end{figure}

The following property is called {\em vanishing} by Hasegawa. It captures the idea that taking a fixed point with respect to an identity arrow does nothing and that fixed points over a vertical product
=INLINEFT
W £ Z
=TEX
\ can be taken by taking fixed points over $Z$ then $W$ in turn.
This property is illustrated in figure~\ref{tmc_van} on page~\pageref{tmc_van}.

\begin{figure}
\begin{center}
\epsffile{wrk075c.eps}
\end{center}
\caption{Traced Monoidal Categories: Vanishing}
\label{tmc_van}
\end{figure}

ˇ €TRA_MON_CAT_VAN›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ TRA_MON_CAT_SIG[O, A]
˜¸¸¸¸¸¸
‹ µ X, Y : O; f : A |
‹	domâc f = X  ± codâc f = Y ∑
‹	Trc(X, Y, domâc Iâ´) (f ´âa Iâ´) = f ;
‹ µ X, Y, W, Z : O; f : A |
‹	domâc f = X ´âo W ´âo Z ± codâc f = Y ´âo W ´âo Z ∑
‹	Trc(X, Y, W ´âo Z) f =
‹	Trc(X, Y, W) (Trc(X ´âo W, Y ´âo W, Z) f)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

The following property says that traces commute with the operation of vertical composition with an identity arrow.
This is called {\em superposing} by Hasegawa.
This property is illustrated in figure~\ref{tmc_sup} on page~\pageref{tmc_sup}.

ˇ €TRA_MON_CAT_SUP›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ TRA_MON_CAT_SIG[O, A]
˜¸¸¸¸¸¸
‹ µ W, X, Y, Z : O; f : A |
‹	domâc f = X ´âo Z ± codâc f = Y ´âo Z ∑
‹	Trc(W ´âo X, W ´âo Y, Z) (idâc W ´âa f) =
‹	idâc W ´âa Trc(X, Y, Z) f
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸


\begin{figure}
\begin{center}
\epsffile{wrk075d.eps}
\end{center}
\caption{Traced Monoidal Categories: Superposing}
\label{tmc_sup}
\end{figure}

The final property says that the trace of the symmetry on $X \oplus X$ is the identity arrow on $X$.
This is called {\em yanking} by Hasegawa.
This property is illustrated in figure~\ref{tmc_yan} on page~\pageref{tmc_yan}.
ˇ €TRA_MON_CAT_YAN›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ TRA_MON_CAT_SIG[O, A]
˜¸¸¸¸¸¸
‹ µ X : O ∑
‹	Trc (X, X, X) (Sym (X, X)) = idâc X
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

\begin{figure}
\begin{center}
\epsffile{wrk075e.eps}
\end{center}
\caption{Traced Monoidal Categories: Yanking}
\label{tmc_yan}
\end{figure}

Finally, we put all these pieces together to complete the definition of a traced monoidal category:
ˇ €TRA_MON_CAT›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ TRA_MON_CAT_SIG[O, A] 
˜¸¸¸¸¸¸
‹ TRA_MON_CAT_DOM[O, A] ;
‹ TRA_MON_CAT_NAT[O, A] ;
‹ TRA_MON_CAT_VAN[O, A] ;
‹ TRA_MON_CAT_SUP[O, A] ;
‹ TRA_MON_CAT_YAN[O, A]
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸



%\newpage
\section{A CATEGORY OF RELATIONS}

We will now formalise a generic category of relations in Z.
The Kirchhoff category discussed informally in the previous section may be formalised as an instance of this category.
As we go we state theorems which build up to the assertion that the generic category is in fact a traced monoidal category.

If $V$ is any set, $V^m$ gives the set of all $m$-tuples with values ranging over $V$.
πZ
‹ function 50  _ ^ _
∞

ù[ U ]úúúúúúúúúúú
‹ €_ ^ _› : U ∏ Ó ≠ (seq U)
˜¸¸¸¸¸¸
‹ µV : U; m:Ó∑ V ^ m =  {s : seq V | #s = m}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

For each set $V$, there is a category, which we shall call $RelCat[V]$, whose objects are the natural numbers and whose morphisms (a.k.a. arrows) from $m$ to $n$ are the relations between $V^m$ and $V^n$ composed via ordinary relational composition\footnote{
We take the objects to be the natural numbers, $m$, rather than the sets $V^m$ for technical convenience to avoid having the category collapse when $V = \{\}$.
}.
An arrow in the category is given as labelled triple whose components give the domain ($d$), codomain ($c$), and the relation ($r$).

πZ
‹ €Rel›[V] ¶ ﬁ{m, n : Ó ∑ {R : V^m ™ V^n∑ (d ¶ m, c ¶ n, r ¶ R)}}
∞

The composition of arrows that makes $Rel[V]$ into a category is the ``horizontal'' composition defined below.

ù[V]úúúúúúúúúúú
‹ €HCompose› : Rel[V] ∏ Rel[V] ﬂ Rel[V]
˜¸¸¸¸¸¸
‹ dom HCompose = {R, S : Rel[V] | R.c = S.d} ;
‹ µR, S : Rel[V] | R.c = S.d ∑
‹	HCompose(R, S) = (d ¶ R.d, c ¶ S.c, r ¶ R.r ª S.r)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸



The following function gives the identity arrows in the category.

ù[V]úúúúúúúúúúú
‹ €HId› : Ó ≠ Rel[V]
˜¸¸¸¸¸¸
‹ µ m : Ó ∑ HId m = (d ¶ m, c ¶ m, r ¶ id(V^m))
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

We can now define $RelCat[V]$ and state the theorem that it is indeed a category.

πZ
‹ €RelCat› [V] ¶
‹	(_ ªâc _ ¶ HCompose[V],
‹	domâc ¶ (ÃR:Rel[V]∑ R.d),
‹	codâc ¶ (ÃR:Rel[V]∑ R.c),
‹	idâc ¶ HId[V])
∞
πZ
‹ rel_cat_thm ?Ù [V](RelCat[V] ç CAT[Ó, Rel[V]])
∞


The category becomes a monoidal category under a product given by addition on objects and by the following ``vertical composition'' on morphisms.

 
ù[V]úúúúúúúúúúú
‹ €VCompose› : Rel[V] ∏ Rel[V] ≠ Rel[V]
˜¸¸¸¸¸¸
‹ µR, S : Rel[V] ∑
‹	VCompose(R, S) = (d ¶ R.d + S.d, c ¶ R.c + S.c,
‹		r ¶ {a, b, c, d : seq V | (a, c) ç R.r ± (b, d) ç S.r∑ (a Î b, c Î d)})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

Adding in the necessary structure we get the monoidal category $RelMonCat[V]$.

πZ
‹ €RelMonCat› [V] ¶
‹	(_ ªâc _ ¶ HCompose[V],
‹	domâc ¶ (ÃR:Rel[V]∑ R.d),
‹	codâc ¶ (ÃR:Rel[V]∑ R.c),
‹	idâc ¶ HId[V],
‹	_ ´âo _ ¶ (Ãm, n:Ó∑ m + n),
‹	_ ´âa _ ¶ VCompose[V],
‹	Iâ´ ¶ HId[V](0))
∞

πZ
‹ rel_mon_cat_thm ?Ù [V](RelMonCat[V] ç MON_CAT[Ó, Rel[V]])
∞
To use the relation category, we will generally need to know something about the value domain, $V$.
However, one can describe some generic constructions that just impose equational constraints.
The most important is the following operator that makes the monoidal category into a symmetric monoidal category:

ù[V]úúúúúúúúúúú
‹ €Transpose› : Ó ∏ Ó ≠ Rel[V]
˜¸¸¸¸¸¸
‹ µm, n : Ó∑
‹	Transpose(m, n) = (d ¶ m + n, c ¶ n + m,
‹		r ¶ {a : V^m; b : V^n ∑ (a Î b, b Î a)})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

We continue to add in the new structure and prove that it gives a symmetric monoidal category.

πZ
‹ €RelSymMonCat› [V] ¶
‹	(_ ªâc _ ¶ HCompose[V],
‹	domâc ¶ (ÃR:Rel[V]∑ R.d),
‹	codâc ¶ (ÃR:Rel[V]∑ R.c),
‹	idâc ¶ HId[V],
‹	_ ´âo _ ¶ (Ãm, n:Ó∑ m + n),
‹	_ ´âa _ ¶ VCompose[V],
‹	Iâ´ ¶ HId[V](0),
‹	Sym ¶ Transpose[V])
∞

πZ
‹ rel_sym_mon_cat_thm ?Ù [V](RelSymMonCat[V] ç SYM_MON_CAT[Ó, Rel[V]])
∞

Finally, we get a traced monoidal category by defining the following operator that corresponds to adding $k$ feedback loops into a diagram.
 
ù[V]úúúúúúúúúúú
‹ €Trace› : (Ó ∏ Ó ∏ Ó) ≠ Rel[V] ﬂ Rel[V]
˜¸¸¸¸¸¸
‹ µm, n, k : Ó∑
‹ dom (Trace(m, n, k)) = {R : Rel[V] | R.d = m + k ± R.c = n + k} ;
‹ µm, n, k : Ó; R : Rel[V] | R.d = m + k ± R.c = n + k ∑
‹	Trace (m, n, k) R = (d ¶ m, c ¶ n,
‹		r ¶ {a: V^m; b : V^n | ∂c:V^k∑ (a Î c, b Î c) ç R.r})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

This enables us to complete the specification of our relational traced monoidal category $RelTraMonCat[V]$:

πZ
‹ €RelTraMonCat› [V] ¶
‹	(_ ªâc _ ¶ HCompose[V],
‹	domâc ¶ (ÃR:Rel[V]∑ R.d),
‹	codâc ¶ (ÃR:Rel[V]∑ R.c),
‹	idâc ¶ HId[V],
‹	_ ´âo _ ¶ (Ãm, n:Ó∑ m + n),
‹	_ ´âa _ ¶ VCompose[V],
‹	Iâ´ ¶ HId[V](0),
‹	Sym ¶ Transpose[V],
‹	Trc ¶ Trace[V])
∞


πZ
‹ rel_tra_mon_cat_thm ?Ù [V](RelTraMonCat[V] ç TRA_MON_CAT[Ó, Rel[V]])
∞

Finally, just for completeness let us instantiate the definition to give the Kirchhoff category (whose objects are voltage-current) pairs):

ˇ €VI› ¸¸¸¸¸¸¸¸¸¸¸
‹ V, I : Ø
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

πZ
‹ €KirchhoffCategory› ¶ RelTraMonCat [VI]
∞

\bibliographystyle{fmu}
\bibliography{fmu}

%%
%% Comment out next line to include the theory listing in the printed document:
\end{document}
=TEX
\newpage
\appendix
=TEX
{\HOLindexOff\small
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{wrk075.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%
%% Comment out next line to include the proofs in the printed document:
\end{document}

\section{Proofs}
=TEX
\ftlinepenalty=999
=SML
val €set_exp_def› = z_get_specÒ(_ ^ _)Æ;
val €rel_def› = z_get_specÒRel[V]Æ;
val €h_compose_def› = z_get_specÒHComposeÆ;
val €h_id_def› = z_get_specÒHIdÆ;
val €v_compose_def› = z_get_specÒVComposeÆ;
val €trace_def› = z_get_specÒTraceÆ;
val €switch_def› = z_get_specÒTransposeÆ;
val €cat_def› = z_get_specÒCATÆ;
val €rel_cat_def› = z_get_specÒRelCatÆ;
val €mon_cat_def› = z_get_specÒMON_CATÆ;
val €rel_mon_cat_def› = z_get_specÒRelMonCatÆ;
val €sym_mon_cat_def› = z_get_specÒSYM_MON_CATÆ;
val €rel_sym_mon_cat_def› = z_get_specÒRelSymMonCatÆ;
val €tra_mon_cat_sig_def› = z_get_specÒTRA_MON_CAT_SIGÆ;
val €tra_mon_cat_dom_def› = z_get_specÒTRA_MON_CAT_DOMÆ;
val €tra_mon_cat_nat_def› = z_get_specÒTRA_MON_CAT_NATÆ;
val €tra_mon_cat_van_def› = z_get_specÒTRA_MON_CAT_VANÆ;
val €tra_mon_cat_sup_def› = z_get_specÒTRA_MON_CAT_SUPÆ;
val €tra_mon_cat_yan_def› = z_get_specÒTRA_MON_CAT_YANÆ;
val €tra_mon_cat_def› = z_get_specÒTRA_MON_CATÆ;
val €rel_tra_mon_cat_def› = z_get_specÒRelTraMonCatÆ;
=TEX
Later proofs use the following prototype implementation of a simple conditional rewriting facility.
The code begins with some derived rules and conversions:
=SML
fun €all_undisch_rule› (thm : THM) : THM = (
	let	val thm1 = undisch_rule thm;
	in	all_undisch_rule thm1
	end
	handle	Fail _ => thm
);
=TEX
The first parameter of the following is what one would need in a  more general conditional rewriter to prevent variable capture problems.
(For the moment, however, we are content to restrict to quantifier free formulae).
=SML
fun €simple_¥_eq_match_conv› (vs : TERM list) (thm : THM) : CONV  = (
	let	val thm1 = all_undisch_rule(all_µ_elim thm);
		val match_conv = simple_eq_match_conv thm1;
		fun captured a_tm = (
			any vs (fn v => v term_mem frees a_tm)
		);
	in	fn tm =>
		let val thm2 = match_conv tm;
		in	if	any (asms thm2) captured
			then	fail "simple_¥_eq_match_conv" 99999 []
			else	thm2 
		end
	end
);
=TEX
The above gives a conversion that will rewrite with an equation appearing as the antecedent of an implication, making the instantiated conditions assumptions of the theorem returned.
=SML
fun €z_cond_eq_conv› (thms : THM list) : CONV = (
	let	val thms1 = map (all_µ_intro o conv_rule z_µ_elim_conv o all_µ_elim) thms;
		val convs = map (simple_¥_eq_match_conv[]) thms1;
	in	FIRST_C convs
	end
);
val €z_cond_rw_conv› : THM list -> CONV = TOP_MAP_C o z_cond_eq_conv;
=TEX
We now give a function which turns a conversion like the above into a tactic by applying the conversion to the conclusion of the goal and then setting any new assumptions generated by the conversions as extra subgoals.
=SML
local
val ¥_¥_±_¥_thm = taut_rule¨µp1 p2 p3∑(p1 ¥ p2 ¥ p3) § (p1 ± p2) ¥ p3Æ;
in
fun €list_disch_rule› ([] : TERM list) (thm : THM) : THM = thm
|   list_disch_rule [t] thm = disch_rule t thm
|   list_disch_rule (t::ts) thm = (
	conv_rule(simple_eq_match_conv ¥_¥_±_¥_thm)
	(disch_rule t (list_disch_rule ts thm))
);
end;
=TEX
=SML
fun €cond_conv_tac› (conv_fun : THM list -> CONV) : THM list -> TACTIC = (
	fn thms =>
	let	fun accept_conv th _ = th;
		val conv = conv_fun thms;
	in	fn g as (hyps, conc) =>
		let	val thm1 = conv conc;
		in	case asms thm1 term_diff hyps of
				[] => conv_tac(accept_conv thm1)
			|	new_asms => (
				let	val thm2 = list_disch_rule new_asms thm1;
					val (hyp, _) = dest_¥(concl thm2);
				in	LEMMA_T hyp
					(fn thm3 => conv_tac(accept_conv (¥_elim thm2 thm3)))
				end
			)
		end	g
	end
);
=TEX
=SML
val €z_cond_rw_tac› : THM list -> TACTIC = REPEAT o cond_conv_tac z_cond_rw_conv;
=TEX
=SML
fun €cond_def_thms› (def_thm : THM) = (
	let	fun not_wanted th = (
			case dest_z_term (concl th) of
				Zµ(_, _, tm) => not(is_eq tm)
			|	_ => true
		);
		val thms = strip_±_rule (all_µ_elim def_thm);
	in	map all_µ_intro (thms drop not_wanted)
	end
);
=TEX
=SML
val €set_exp_rw_thm› = hd(cond_def_thms set_exp_def);
val €h_compose_rw_thm› = hd(cond_def_thms h_compose_def);
val €h_id_rw_thm› = hd(cond_def_thms h_id_def);
val €v_compose_rw_thm› = hd(cond_def_thms v_compose_def);
val €switch_rw_thm› = hd(cond_def_thms switch_def);
val €trace_rw_thm› = hd(tl(cond_def_thms trace_def));
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V] 
	(Rel[V] = {m, n:Ó; R : É | R ç V^m ™ V^n∑ (d ¶ m, c ¶ n, r ¶ R)})Æ);
a(rewrite_tac[rel_def] THEN REPEAT strip_tac);
a(PC_T "z_sets_ext" strip_tac THEN REPEAT strip_tac
	THEN REPEAT all_var_elim_asm_tac1);
a(z_∂_tacÒ{R : V ^ x2 ™ V ^ x1 ∑ (c ¶ x1, d ¶ x2, r ¶ R)}Æ
	THEN asm_rewrite_tac[]);
a(z_∂_tacÒ(m ¶ x2, n ¶ x1)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" asm_rewrite_tac[]);
val €rel_rw_thm› = save_pop_thm "rel_rw_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V] 
	(µA:É∑A ç Rel[V] § A.c ç Ó ± A.d ç Ó ± A.r ç V^(A.d) ™ V^(A.c))Æ);
a(rewrite_tac[rel_rw_thm] THEN REPEAT strip_tac
	THEN REPEAT all_var_elim_asm_tac1
	THEN_TRY asm_rewrite_tac[]);
val €ç_rel_thm› = save_pop_thm "ç_rel_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µf X Y∑
	Ò(Ãm:X∑ ¨f mÆ) ç X ≠ Y § (µx:X ∑ ¨f xÆ ç Y)ÆÆ);
a(PC_T1 "z_fun_ext" prove_tac[]);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
a(all_var_elim_asm_tac1 THEN strip_tac);
val €Ã_ç_≠_thm› = save_pop_thm "Ã_ç_≠_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](µm : Ó∑ HId[V] m ç Rel[V])Æ);
a(REPEAT strip_tac THEN ALL_FC_T rewrite_tac[h_id_def]);
a(asm_rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ÒµA:É∑ id A ç A ™ AÆ,
		ç_rel_thm]);
val €h_id_ç_rel_thm› = save_pop_thm "h_id_ç_rel_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "rel_cat_thm");
a(rewrite_tac[cat_def, rel_cat_def, h_compose_def, h_id_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[
	conv_rule(ONCE_MAP_C ¬_conv)
	(µ_elim¨ÃR∑Ò(R ∫ Rel[V]).dÆÆ Ã_ç_≠_thm)]);
a(z_strip_tac THEN PC_T1 "z_library_ext" rewrite_tac [ç_rel_thm]
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[
	conv_rule(ONCE_MAP_C ¬_conv)
	(µ_elim¨ÃR∑Ò(R ∫ Rel[V]).cÆÆ Ã_ç_≠_thm)]);
a(z_strip_tac THEN PC_T1 "z_library_ext" rewrite_tac [ç_rel_thm]
	THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(PC_T1 "z_library_ext" rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(POP_ASM_T ante_tac THEN conv_tac(ONCE_MAP_C z_¬_conv));
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(REPEAT strip_tac);
a(lemma_tacÒ(f, g) ç dom HCompose[V] ± (g, h) ç dom HCompose[V]Æ
	THEN1  PC_T1 "z_sets_ext" asm_rewrite_tac[h_compose_def]);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆh_compose_def)));
a(ALL_FC_T (MAP_EVERY ante_tac)[z_fun_ç_clauses]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(REPEAT strip_tac THEN lemma_tac Ò
	(c ¶ g.c, d ¶ f.d, r ¶ f.r ª g.r).c = h.d
	± f.c = (c ¶ h.c, d ¶ g.d, r ¶ g.r ª h.r).dÆ
	THEN1 asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
	Òµf, g, h:É∑ f ª g ª h = f ª (g ª h)Æ]);
(* *** Goal "5" *** *)
a(POP_ASM_T ante_tac);
a(conv_tac(LEFT_C(ONCE_MAP_C z_¬_conv)));
a(REPEAT strip_tac);
a(lemma_tacÒ(f, g) ç dom HCompose[V]Æ
	THEN1 PC_T1 "z_sets_ext" asm_rewrite_tac[h_compose_def]);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆh_compose_def)));
a(ALL_FC_T (MAP_EVERY ante_tac)[z_fun_ç_clauses]);
a(strip_tac);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[h_compose_def]);
(* *** Goal "6" *** *)
a(POP_ASM_T ante_tac);
a(conv_tac(LEFT_C(ONCE_MAP_C z_¬_conv)));
a(REPEAT strip_tac);
a(lemma_tacÒ(f, g) ç dom HCompose[V]Æ
	THEN1 PC_T1 "z_sets_ext" asm_rewrite_tac[h_compose_def]);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆh_compose_def)));
a(ALL_FC_T (MAP_EVERY ante_tac)[z_fun_ç_clauses]);
a(strip_tac);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[h_compose_def]);
(* *** Goal "7" *** *)
a(lemma_tacÒHId[V] X ç Rel[V]Æ
	THEN1 ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
a(conv_tac (MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[h_id_def]);
(* *** Goal "8" *** *)
a(lemma_tacÒHId[V] X ç Rel[V]Æ
	THEN1 ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
a(conv_tac (MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[h_id_def]);
(* *** Goal "9" *** *)
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(LEMMA_T Òf.c ç ÓÆ asm_tac THEN REPEAT strip_tac);
a(LEMMA_T Òf.d ç ÓÆ asm_tac THEN REPEAT strip_tac);
a(conv_tac(MAP_C z_¬_conv));
a(lemma_tacÒHId[V] f.d ç Rel[V]
	± HId[V] f.c ç Rel[V]Æ
	THEN1 ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
a(lemma_tacÒ(HId[V] f.d).c = f.d
	± f.c = (HId[V] f.c).dÆ
	THEN1 ALL_FC_T rewrite_tac[h_id_def]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(ALL_FC_T rewrite_tac[h_id_def]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ÒµA:É; B:É; R:É∑ R ç A ™ B ¥
			R ª id B = id A ª R = RÆ]);
(* *** Goal "10" *** *)
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(LEMMA_T Òf.c ç ÓÆ asm_tac THEN REPEAT strip_tac);
a(conv_tac(MAP_C z_¬_conv));
a(lemma_tacÒHId[V] f.c ç Rel[V]Æ
	THEN1 ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
a(lemma_tacÒf.c = (HId[V] f.c).dÆ
	THEN1 ALL_FC_T rewrite_tac[h_id_def]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(ALL_FC_T rewrite_tac[h_id_def]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ÒµA:É; B:É; R:É∑ R ç A ™ B ¥
			R ª id B = id A ª R = RÆ]);
a(PC_T1 "z_library_ext" rewrite_tac[]);
val €rel_cat_thm› = save_pop_thm "rel_cat_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](V^0 = {ß¢})Æ);
a(REPEAT strip_tac);
a(LEMMA_T Ò0 ç ÓÆ asm_tac THEN1 rewrite_tac[]);
a(PC_T1 "z_predicates" (ALL_FC_T rewrite_tac)[z_gen_pred_u_elim set_exp_def]);
a(PC_T "z_library_ext" strip_tac
	THEN z_strip_tac
	THEN rewrite_tac[z_ß¢_seq_thm]);
a(rewrite_tac[rewrite_rule[]
	(z_µ_elimÒ(X ¶ V, s ¶ x1, n ¶ 0)Æ z_size_seq_thm1)]);
a(rewrite_tac[z_ß¢_thm]);
val €set_exp_0_thm› = save_pop_thm "set_exp_0_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Òµx:É∑ id{x} = {(x, x)}Æ);
a(PC_T1 "z_library_ext" prove_tac[]);
val €id_singleton_thm› = save_pop_thm "id_singleton_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](µf:Rel[V]; x, y: É | (x, y) ç f.r ∑ x ç seq V ± y ç seq V)Æ);
a(REPEAT_UNTIL is_¥ strip_tac);
a(rewrite_tac[ç_rel_thm] THEN REPEAT_UNTIL is_± strip_tac);
a(DROP_NTH_ASM_T 2 ante_tac);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(PC_T1 "z_library_ext" asm_prove_tac[]);
val €rel_seq_thm› = save_pop_thm "rel_seq_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ÒµM, N : Ó∑(Ãm, n:Ó∑ m + n) (M, N) = M + NÆ);
a(PC_T1 "z_predicates" REPEAT strip_tac);
a(LEMMA_TÒ(M, N) ç Ó ∏ ÓÆ asm_tac THEN1 asm_rewrite_tac[]);
a(lemma_tacÒ(Ãm, n:Ó∑ m + n) ç Ó ∏ Ó ≠ ÓÆ);
(* *** Goal "1" *** *)
a(conv_tac(ONCE_MAP_C z_Ã_conv));
a(PC_T1 "z_library_ext" asm_prove_tac[]
	THEN_TRY (all_var_elim_asm_tac1 THEN PC_T1 "z_lin_arith" asm_prove_tac[]));
a(z_∂_tacÒx1 + x2Æ THEN rewrite_tac[]);
a(z_∂_tacÒ(m ¶ x1, n ¶ x2)Æ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_TÒ((M, N), (M + N)) ç (Ãm, n:Ó∑ m + n)Æ asm_tac);
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac);
a(DROP_NTH_ASM_T 3 ante_tac);
a(PC_T1 "z_library_ext" prove_tac[]);
a(z_∂_tacÒ(m ¶ M, n ¶ N)Æ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(ALL_FC_T rewrite_tac[z_fun_app_clauses]);
val €z_plus_Ó_thm› = save_pop_thm "z_plus_Ó_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](µm, n : Ó∑ µa : V^m; b : V^n∑ a Î b ç V^(m+n))Æ);
a(REPEAT strip_tac);
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(lemma_tacÒ0 º m + nÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T1 fc_§_canon asm_rewrite_tac[z_Î_seq_x_thm]);
(* *** Goal "2" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_size_Î_thm]);
val €Î_set_exp_thm› = save_pop_thm "Î_set_exp_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µV m n a b∑ Ò
	m ç Ó ± n ç Ó ± a ç V^m ± b ç V^n
¥	a Î b ç V^(m+n)ÆÆ);
a(REPEAT strip_tac THEN all_fc_tac[Î_set_exp_thm]);
val €Î_set_exp_bc_thm› = save_pop_thm "Î_set_exp_bc_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[X](
	µs : seq X ∑ s = ß¢ ≤
	(∂s1 : seq X; x : X∑ s = s1 Î ßx¢))Æ);
a(REPEAT_UNTIL is_≤ strip_tac);
a(z_seq_induction_tacÒsÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(z_∂_tacÒ(s1¶s, x'¶x)Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(z_∂_tacÒ(s1¶s, x'¶x)Æ THEN asm_rewrite_tac[]);
val €z_seq_cases_thm1› = save_pop_thm "z_seq_cases_thm1";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[X](
	µs : seq X | #s = 0 ∑ s = ß¢;
	µs : seq X; i : Ó | #s = i + 1 ∑ ∂s1 : seq X; x : X∑ #s1 = i ± s = s1 Î ßx¢)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(strip_asm_tac(z_µ_elimÒsÆ z_seq_cases_thm));
a(all_var_elim_asm_tac1);
a(i_contr_tac THEN swap_nth_asm_concl_tac 3);
a(lemma_tacÒßx¢ ç (seq _)Æ THEN1 rewrite_tac[z_singleton_seq_thm]);
a(ALL_FC_T rewrite_tac[z_size_Î_thm]);
a(rewrite_tac[z_size_singleton_seq_thm]);
a(lemma_tacÒ#s1 ç ÓÆ THEN1 ALL_FC_T rewrite_tac[z_size_seq_Ó_thm]);
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tacÒ≥s = ß¢Æ
	THEN1 (swap_nth_asm_concl_tac 1
		THEN asm_rewrite_tac[z_size_seqd_thm]
		THEN PC_T1 "z_lin_arith" asm_prove_tac[]));
a(all_fc_tac[z_seq_cases_thm1]);
a(z_∂_tacÒ(s1 ¶ s1, x ¶ x)Æ THEN asm_rewrite_tac[]);
a(swap_nth_asm_concl_tac 5 THEN all_var_elim_asm_tac1);
a(lemma_tacÒßx¢ ç (seq _)Æ THEN1 rewrite_tac[z_singleton_seq_thm]);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_size_Î_thm]);
a(asm_rewrite_tac[z_size_singleton_seq_thm]);
val €z_size_seq_cases_thm› = save_pop_thm "z_size_seq_cases_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Òµs1, t1, s2, t2 : (seq _) |
	#s2 = #t2 ± s1 Î s2 = t1 Î t2 ∑ s1 = t1 ± s2 = t2Æ);
a(REPEAT_UNTIL is_± strip_tac);
a(lemma_tacÒ∂m:Ó∑#t2 = mÆ THEN1
	(z_∂_tacÒ#t2Æ THEN REPEAT strip_tac
		THEN all_fc_tac[z_size_seq_Ó_thm]));
a(LIST_DROP_NTH_ASM_T [1, 3, 4, 5, 6, 7, 8] (MAP_EVERY ante_tac));
a(z_intro_µ_tacÒ(s1¶s1, s2¶s2, t1¶t1, t2¶t2)Æ);
a(z_º_induction_tac ÒmÆ);
(* *** Goal "1" *** *)
a(REPEAT_UNTIL is_± strip_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
a(strip_tac);
a(all_fc_tac[z_size_seq_cases_thm] THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 2 ante_tac);
a(ALL_FC_T rewrite_tac[z_Î_ß¢_thm]);
(* *** Goal "2" *** *)
a(REPEAT_UNTIL is_± strip_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
a(strip_tac);
a(all_fc_tac[z_size_seq_cases_thm] THEN all_var_elim_asm_tac1);
a(rename_tac[(Òs1'Æ, "s2"), (Òs1''Æ, "t2")]
	THEN DROP_NTH_ASM_T 6 ante_tac);
a(lemma_tacÒßx¢ ç (seq _) ± ßx'¢ ç (seq _)Æ THEN1 rewrite_tac[z_singleton_seq_thm]);
a(ALL_FC_T rewrite_tac[z_Î_assoc_thm1]);
a(lemma_tacÒs1 Î s2 ç (seq _) ± t1 Î t2 ç (seq _)Æ
	THEN1 ALL_FC_T1 fc_§_canon asm_rewrite_tac[z_Î_seq_x_thm]);
a(ALL_FC_T1 fc_§_canon rewrite_tac[z_Î_one_one_thm]);
a(strip_tac THEN asm_rewrite_tac[]);
a(lemma_tacÒ#s2 = #t2Æ THEN1 asm_rewrite_tac[]);
a(z_spec_nth_asm_tac 17 Ò(s1'¶s1, s2'¶s2, t1'¶t1, t2'¶t2)Æ);
a(REPEAT strip_tac);
val €z_Î_one_one_thm1› = save_pop_thm "z_Î_one_one_thm1";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[X](µs : seq X; m, n : Ó | #s = m + n ∑
	∂s1, s2 : seq X ∑ #s1 = m ± #s2 = n ± s = s1 Î s2)Æ);
a(REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [1, 3, 4] (MAP_EVERY ante_tac));
a(z_intro_µ_tacÒ(s¶s, m¶m)Æ);
a(z_º_induction_tac ÒnÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[] THEN REPEAT strip_tac);
a(z_∂_tacÒ(s1¶s, s2¶ß¢)Æ THEN asm_rewrite_tac[z_size_seqd_thm]);
a(ALL_FC_T rewrite_tac[z_Î_ß¢_thm] THEN REPEAT strip_tac);
a(rewrite_tac[z_ß¢_seq_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[pc_rule1 "z_lin_arith" prove_rule[]
	Òµn:É∑n + (i + 1) = (n + i) + 1Æ]
	THEN REPEAT strip_tac);
a(lemma_tacÒ0 º n + iÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(all_fc_tac[z_size_seq_cases_thm]);
a(LIST_DROP_NTH_ASM_T [9] all_fc_tac);
a(z_∂_tacÒ(s1¶s1', s2¶s2 Î ßx¢)Æ);
a(lemma_tacÒßx¢ ç (seq _)Æ THEN1 rewrite_tac[z_singleton_seq_thm]);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T asm_rewrite_tac[z_size_Î_thm, z_Î_assoc_thm]);
a(rewrite_tac[z_size_seqd_thm] THEN REPEAT strip_tac);
a(rename_tac[(Òs2Æ, "ss2")]
	THEN ALL_FC_T1 fc_§_canon asm_rewrite_tac[z_Î_seq_x_thm]);
a(asm_rewrite_tac[z_singleton_seq_x_thm]);
val €z_Î_onto_thm› = save_pop_thm "z_Î_onto_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "rel_mon_cat_thm");
a(rewrite_tac[mon_cat_def, rel_mon_cat_def,
	rewrite_rule[rel_cat_def] rel_cat_thm, v_compose_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" prove_tac[]
	THEN_TRY all_var_elim_asm_tac1
	THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(z_∂_tacÒx1 + x2Æ THEN rewrite_tac[]);
a(z_∂_tacÒ(m ¶ x1, n ¶ x2)Æ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_TÒ0 º 0Æ asm_tac THEN1 REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
(* *** Goal "3" *** *)
a(strip_asm_tac (±_left_elim (µ_elim¨VÆv_compose_def)));
a(LEMMA_TÒ(f, g) ç Rel[V] ∏ Rel[V]Æ asm_tac THEN1 REPEAT strip_tac);
a(LEMMA_TÒ(g, h) ç Rel[V] ∏ Rel[V]Æ asm_tac THEN1 REPEAT strip_tac);
a(all_fc_tac[z_fun_ç_clauses]);
a(ALL_FC_T once_rewrite_tac[v_compose_def]);
a(ALL_FC_T rewrite_tac[v_compose_def]);
a(rewrite_tac[z_plus_assoc_thm]);
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.1" *** *)
a(z_∂_tacÒ(a ¶ a', b'' ¶ b' Î b, c ¶ c', d'' ¶ d' Î d)Æ
	THEN asm_rewrite_tac[]);
a(all_fc_tac[z_seq_u_thm]);
a(conv_tac(LEFT_C (PC_C1 "z_sets_ext" rewrite_conv[])));
a(ALL_FC_T1 fc_§_canon asm_rewrite_tac[z_Î_seq_x_thm,
	z_Î_assoc_thm]);
a(z_∂_tacÒ(a ¶ b', b'' ¶ b, c ¶ d', d'' ¶ d)Æ
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "3.2" *** *)
a(z_∂_tacÒ(a'' ¶ a Î a', b ¶ b', c'' ¶ c Î c', d ¶ d')Æ
	THEN asm_rewrite_tac[]);
a(all_fc_tac[z_seq_u_thm]);
a(conv_tac(LEFT_C (PC_C1 "z_sets_ext" rewrite_conv[])));
a(ALL_FC_T1 fc_§_canon asm_rewrite_tac[z_Î_seq_x_thm,
	z_Î_assoc_thm]);
a(z_∂_tacÒ(a'' ¶ a, b ¶ a', c'' ¶ c, d ¶ c')Æ
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(LEMMA_TÒ 0 º 0Æ asm_tac THEN1 REPEAT strip_tac);
a(lemma_tacÒHId[V] 0 ç Rel[V]Æ
	THEN1 ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
a(LEMMA_TÒ(f, HId[V]0) ç Rel[V] ∏ Rel[V]Æ asm_tac
	THEN1 REPEAT strip_tac);
a(LEMMA_TÒ(HId[V]0, f) ç Rel[V] ∏ Rel[V]Æ asm_tac
	THEN1 REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[v_compose_def]);
a(ALL_FC_T rewrite_tac[h_id_def]);
a(rewrite_tac[set_exp_0_thm, id_singleton_thm]);
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "4.1" *** *)
a(z_∂_tacÒ(a' ¶ ß¢, b ¶ a, c' ¶ ß¢, d ¶ c)Æ
	THEN asm_rewrite_tac[]);
a(conv_tac(LEFT_C (PC_C1 "z_sets_ext" rewrite_conv[])));
a(asm_rewrite_tac[z_ß¢_seq_thm]);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_Î_ß¢_thm, z_ß¢_Î_thm]);
(* *** Goal "4.2" *** *)
a(z_∂_tacÒ(a ¶ b, b' ¶ ß¢, c ¶ d, d' ¶ ß¢)Æ
	THEN asm_rewrite_tac[]);
a(conv_tac(LEFT_C (PC_C1 "z_sets_ext" rewrite_conv[])));
a(asm_rewrite_tac[z_ß¢_seq_thm]);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_Î_ß¢_thm, z_ß¢_Î_thm]);
(* *** Goal "5" *** *)
a(LEMMA_TÒ 0 º 0Æ asm_tac THEN1 REPEAT strip_tac);
a(lemma_tacÒHId[V] 0 ç Rel[V]Æ
	THEN1 ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
a(LEMMA_TÒ(HId[V]0, f) ç Rel[V] ∏ Rel[V]Æ asm_tac
	THEN1 REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[v_compose_def]);
a(ALL_FC_T rewrite_tac[h_id_def]);
a(rewrite_tac[set_exp_0_thm, id_singleton_thm]);
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac);
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac
	THEN1 all_var_elim_asm_tac1);
(* *** Goal "5.1" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T asm_rewrite_tac[z_Î_ß¢_thm, z_ß¢_Î_thm]);
(* *** Goal "5.2" *** *)
a(z_∂_tacÒ(a ¶ ß¢, b ¶ x1, c ¶ ß¢, d ¶ x2)Æ
	THEN asm_rewrite_tac[]);
a(conv_tac(LEFT_C (PC_C1 "z_sets_ext" rewrite_conv[])));
a(asm_rewrite_tac[z_ß¢_seq_thm]);
a(all_fc_tac[rel_seq_thm]);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T asm_rewrite_tac[z_Î_ß¢_thm, z_ß¢_Î_thm]);
(* *** Goal "6" *** *)
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm]);
a(lemma_tacÒHId[V] X ç Rel[V] ± HId[V] Y ç Rel[V]Æ
	THEN1 ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
a(LEMMA_TÒ(HId[V] X, HId[V] Y) ç Rel[V] ∏ Rel[V]Æ asm_tac
	THEN1 REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆv_compose_def)));
a(all_fc_tac[z_fun_ç_clauses]);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[v_compose_def]);
a(ALL_FC_T rewrite_tac[h_id_def]);
(* *** Goal "7" *** *)
a(lemma_tacÒ0 º X + YÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[h_id_def, z_plus_Ó_thm]);
a(z_cond_rw_tac[v_compose_rw_thm] THEN rewrite_tac[]);
(* *** Goal "7.1" *** *)
a(PC_T1"z_sets_ext" once_rewrite_tac[]
	THEN asm_rewrite_tac[ç_rel_thm,
		pc_rule1 "z_rel_ext" prove_rule[]
		ÒµA:É∑ id A ç A ™ AÆ]);
(* *** Goal "7.2" *** *)
a(REPEAT_N 3(PC_T1"z_sets_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac);
(* *** Goal "7.2.1" *** *)
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É;x:É; y:É|(x, y) ç id A ∑y = xÆ]
	THEN all_var_elim_asm_tac1);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN rewrite_tac[]);
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É;x:É; y:É|(x, y) ç id A ∑x ç AÆ]);
(* *** Goal "7.2.2" *** *)
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É;x:É; y:É|(x, y) ç id A ∑y = x ± y ç AÆ]
	THEN all_var_elim_asm_tac1);
a(swap_nth_asm_concl_tac 1 THEN ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN swap_nth_asm_concl_tac 1);
a(all_fc_tac[z_Î_onto_thm] THEN all_var_elim_asm_tac1
	THEN strip_tac);
a(z_∂_tacÒ(a¶s1, b¶s2, c¶s1, d¶s2)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN asm_rewrite_tac[]);
a(ALL_FC_T asm_rewrite_tac[z_gen_pred_u_elim set_exp_def]);
(* *** Goal "8" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(conv_tac(ONCE_MAP_C z_¬_conv) THEN REPEAT strip_tac);
a(z_cond_rw_tac[v_compose_rw_thm, h_compose_rw_thm] THEN asm_rewrite_tac[]);
(* *** Goal "8.1" *** *)
a(REPEAT strip_tac);
(* *** Goal "8.2" *** *)
a(PC_T1 "z_sets_ext" asm_rewrite_tac[]);
a(all_asm_ante_tac THEN rewrite_tac[ç_rel_thm]);
a(REPEAT_UNTIL is_± strip_tac);
a(LIST_DROP_NTH_ASM_T [1, 2] (fn ths =>
	all_asm_ante_tac THEN rewrite_tac ths));
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]
	THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]
	THEN_TRY ALL_FC_T rewrite_tac[pc_rule1"z_library_ext" prove_rule[]Ò
	µr, s:É; A, B, C:É| r ç A ™ B ± s ç B ™ C∑ rªs ç A ™ CÆ]);
(* *** Goal "8.2.1" *** *)
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "8.2.1.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç A ± y ç BÆ]);
(* *** Goal "8.2.1.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç A ± y ç BÆ]);
(* *** Goal "8.2.2" *** *)
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "8.2.2.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç A ± y ç BÆ]);
(* *** Goal "8.2.2.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç A ± y ç BÆ]);
(* *** Goal "8.3" *** *)
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "8.3.1" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN REPEAT strip_tac);
a(z_∂_tacÒy Î y'Æ THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "8.3.1.1" *** *)
a(z_∂_tacÒ(a'¶a, b'¶b, c¶y, d¶y')Æ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 14 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(DROP_NTH_ASM_T 15 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T (MAP_EVERY ante_tac)[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "8.3.1.2" *** *)
a(z_∂_tacÒ(a¶y, b¶y', c'¶c, d'¶d)Æ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 14 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(DROP_NTH_ASM_T 15 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T (MAP_EVERY ante_tac)[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "8.3.2" *** *)
a(lemma_tacÒa' = c ± b' = dÆ);
a(DROP_NTH_ASM_T 17 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T (MAP_EVERY ante_tac)[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
a(LIST_DROP_NTH_ASM_T [1, 2, 3] discard_tac);
a(DROP_NTH_ASM_T 16 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T (MAP_EVERY ante_tac)[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
a(LIST_DROP_NTH_ASM_T [1, 3] discard_tac);
a(ALL_FC_T asm_rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT_N 2 strip_tac THEN lemma_tacÒ#b' = #dÆ
	THEN1 asm_rewrite_tac[]);
a(all_fc_tac[z_seq_u_thm]);
a(LIST_DROP_NTH_ASM_T [1, 2, 7, 8] discard_tac);
a(ALL_FC_T rewrite_tac[z_Î_one_one_thm1]);
(* *** Goal "8.3.2.2" *** *)
a(all_var_elim_asm_tac1);
a(z_∂_tacÒ(a'¶a, b'¶b, c¶c', d¶d')Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "8.3.2.1" *** *)
a(z_∂_tacÒcÆ THEN asm_rewrite_tac[]);
(* *** Goal "8.3.2.2" *** *)
a(z_∂_tacÒdÆ THEN asm_rewrite_tac[]);
val €rel_mon_cat_thm› = save_pop_thm "rel_mon_cat_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](µm, n : Ó∑
	HCompose[V] (Transpose[V] (m, n), Transpose[V] (n, m)) =
	(c ¶ m + n, d ¶ m + n, r ¶ id (V ^ (m + n))))Æ);
a(REPEAT strip_tac THEN
	rename_tac[(¨m:˙Æ, "M"), (¨n:˙Æ, "N")]);
a(LEMMA_TÒ(M, N) ç Ó ∏ ÓÆ asm_tac THEN1 REPEAT strip_tac);
a(LEMMA_TÒ(N, M) ç Ó ∏ ÓÆ asm_tac THEN1 REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆswitch_def)));
a(all_fc_tac[z_fun_ç_clauses]);
a(lemma_tacÒ(Transpose[V] (M, N)).c = (Transpose[V] (N, M)).dÆ
	THEN1 ALL_FC_T rewrite_tac[switch_def]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(ALL_FC_T rewrite_tac[switch_def]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(REPEAT_UNTIL is_§ strip_tac);
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(all_fc_tac[Î_set_exp_thm]);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T [2, 3, 4, 5] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_Î_one_one_thm1]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac);
a(lemma_tacÒ0 º M + NÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT strip_tac);
a(all_fc_tac[z_Î_onto_thm]);
a(z_∂_tacÒs2 Î s1Æ THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(z_∂_tacÒ(a ¶ s1, b ¶ s2)Æ THEN asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(z_∂_tacÒ(a ¶ s2, b ¶ s1)Æ THEN asm_rewrite_tac[]);
val €switch_switch_thm› = save_pop_thm "switch_switch_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](µm, n, k  : Ó∑
	Transpose[V] (m + n, k) =
	HCompose[V] (
		VCompose[V](HId[V] m, Transpose[V] (n, k)),
		VCompose[V] (Transpose[V] (m, k), HId[V] n))
)Æ);
a(REPEAT strip_tac THEN
	rename_tac[(¨m:˙Æ, "X"), (¨n:˙Æ, "Y"), (¨k:˙Æ, "Z")]);
a(LEMMA_TÒX ç Ó ± Y ç ÓÆ (±_THEN asm_tac) THEN1 REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆswitch_def)));
a(lemma_tacÒX + Y ç ÓÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(LEMMA_TÒ(X + Y, Z) ç Ó ∏ ÓÆ asm_tac THEN1 REPEAT strip_tac);
a(LEMMA_TÒ(Y, Z) ç Ó ∏ ÓÆ asm_tac THEN1 REPEAT strip_tac);
a(LEMMA_TÒ(X, Z) ç Ó ∏ ÓÆ asm_tac THEN1 REPEAT strip_tac);
a(all_fc_tac[z_fun_ç_clauses]);
a(DROP_NTH_ASM_T 8 discard_tac);
a(lemma_tacÒHId[V] X ç Rel[V]
	± HId[V] Y ç Rel[V]Æ
	THEN1 ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆv_compose_def)));
a(LEMMA_TÒ(HId[V] X, Transpose[V] (Y, Z)) ç Rel[V] ∏ Rel[V]Æ asm_tac THEN1 REPEAT strip_tac);
a(LEMMA_TÒ(Transpose[V] (X, Z), HId[V] Y) ç Rel[V] ∏ Rel[V]Æ asm_tac THEN1 REPEAT strip_tac);
a(all_fc_tac[z_fun_ç_clauses]);
a(LEMMA_TÒ(VCompose[V] (HId[V] X, Transpose[V] (Y, Z))).c =
	(VCompose[V] (Transpose[V] (X, Z), HId[V] Y)).dÆ asm_tac THEN1 
	(ALL_FC_T rewrite_tac[v_compose_def]
		THEN ALL_FC_T rewrite_tac[h_id_def, switch_def]
		THEN PC_T1 "z_lin_arith" prove_tac[]));
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(ALL_FC_T rewrite_tac[v_compose_def]);
a(ALL_FC_T rewrite_tac[switch_def, h_id_def]);
a(REPEAT strip_tac
	THEN1 PC_T1 "z_lin_arith" prove_tac[]
	THEN1 PC_T1 "z_lin_arith" prove_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN rewrite_tac[z_id_def]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(LIST_DROP_NTH_ASM_T (interval 1 14) discard_tac);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def] THEN REPEAT strip_tac);
a(all_fc_tac[z_Î_onto_thm]);
a(rename_tac[(Òs1Æ, "A"), (Òs2Æ, "B"), (ÒbÆ, "C")]
	THEN all_var_elim_asm_tac1);
a(z_∂_tacÒ(A Î C) Î BÆ THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(z_∂_tacÒ(a' ¶ A, b' ¶ B Î C, c ¶ A, d ¶ C Î B)Æ);
a(conv_tac(LEFT_C(PC_C1 "z_sets_ext" rewrite_conv[])));
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T1 fc_§_canon asm_rewrite_tac[z_Î_seq_x_thm, z_Î_assoc_thm]);
a(REPEAT strip_tac);
(* *** Goal "1.1.1" *** *)
a(z_∂_tacÒ(x ¶ A)Æ THEN REPEAT strip_tac);
(* *** Goal "1.1.2" *** *)
a(z_∂_tacÒ(a'' ¶ B, b'' ¶ C)Æ THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(z_∂_tacÒ(a' ¶ A Î C, b' ¶ B, c ¶ C Î A, d ¶ B)Æ);
a(conv_tac(LEFT_C(PC_C1 "z_sets_ext" rewrite_conv[])));
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T1 fc_§_canon asm_rewrite_tac[z_Î_seq_x_thm, z_Î_assoc_thm]);
a(REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(z_∂_tacÒ(a'' ¶ A, C' ¶ C)Æ THEN REPEAT strip_tac);
(* *** Goal "1.2.2" *** *)
a(z_∂_tacÒ(x ¶ B)Æ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T [1, 2, 3, 4, 8, 9, 10] (MAP_EVERY ante_tac));
a(LIST_DROP_NTH_ASM_T (22::23::interval 1 20) discard_tac);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN REPEAT_N 6 strip_tac);
a(all_var_elim_asm_tac1);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_Î_assoc_thm1] THEN strip_tac);
a(lemma_tacÒa''' Î b''' ç (seq _) ± c Î b' ç (seq _)Æ
	THEN1 ALL_FC_T rewrite_tac[z_Î_ç_seq_thm]);
a(LIST_DROP_NTH_ASM_T (interval 1 22 diff [1, 2, 3, 5, 9, 10])
	(fn ths=> 
		all_fc_tac[z_Î_one_one_thm1]
	THEN MAP_EVERY asm_tac ths));
a(LIST_DROP_NTH_ASM_T (interval 1 24 diff [11, 13, 14, 15, 16, 18])
	(fn ths=> 
		all_fc_tac[z_Î_one_one_thm1]
	THEN MAP_EVERY asm_tac ths));
a(all_var_elim_asm_tac1);
a(z_∂_tacÒ(a ¶ c Î a', b ¶ b')Æ
	THEN ALL_FC_T1
		fc_§_canon asm_rewrite_tac[
			z_Î_assoc_thm, z_size_Î_thm, z_Î_seq_x_thm]);
val €switch_v_compose_thm› = save_pop_thm "switch_v_compose_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "rel_sym_mon_cat_thm");
a(rewrite_tac[sym_mon_cat_def,
	rel_sym_mon_cat_def,
	rewrite_rule[rel_mon_cat_def] rel_mon_cat_thm,
	switch_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm]);
a(LEMMA_TÒ(X, Y) ç Ó ∏ ÓÆ asm_tac THEN1 REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆswitch_def)));
a(all_fc_tac[z_fun_ç_clauses]);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[switch_def]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm]);
a(LEMMA_TÒ(X, Y) ç Ó ∏ ÓÆ asm_tac THEN1 REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆswitch_def)));
a(all_fc_tac[z_fun_ç_clauses]);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[switch_def]);
(* *** Goal "3" *** *)
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm, switch_switch_thm]);
a(lemma_tacÒX + Y ç ÓÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[h_id_def]);
(* *** Goal "4" *** *)
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm, switch_v_compose_thm]);
val €rel_sym_mon_cat_thm› = save_pop_thm "rel_sym_mon_cat_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](RelTraMonCat[V] ç TRA_MON_CAT_SIG[Ó, Rel[V]])Æ);
a(rewrite_tac[rel_tra_mon_cat_def,
	rewrite_rule[rel_sym_mon_cat_def]
		rel_sym_mon_cat_thm,
	tra_mon_cat_sig_def,
	trace_def]);
val €rel_tra_mon_cat_sig_thm› = save_pop_thm "rel_tra_mon_cat_sig_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](RelTraMonCat[V] ç TRA_MON_CAT_DOM[Ó, Rel[V]])Æ);
a(rewrite_tac[tra_mon_cat_dom_def,
	rel_tra_mon_cat_def,
	rewrite_rule[rel_tra_mon_cat_def]
		rel_tra_mon_cat_sig_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[trace_def]);
a(PC_T "z_library_ext" strip_tac
	THEN REPEAT_UNTIL is_§ strip_tac);
a(rewrite_tac[]);
a(cases_tacÒ(c ¶ x1, d ¶ x2, r ¶ x3) ç Rel[V]Æ
	THEN asm_rewrite_tac[]);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm]);
(* *** Goal "2" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm]);
a(STRIP_T (strip_asm_tac o conv_rule(ONCE_MAP_C z_¬_conv)));
a(STRIP_T (strip_asm_tac o conv_rule(ONCE_MAP_C z_¬_conv)));
a(lemma_tacÒf ç dom (Trace[V](X, Y, Z))Æ
	THEN1 ALL_FC_T asm_rewrite_tac[trace_def]);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆtrace_def)));
a(LEMMA_TÒ(X, Y, Z) ç Ó ∏ Ó ∏ ÓÆ asm_tac THEN REPEAT strip_tac);
a(all_fc_tac[z_fun_ç_clauses]);
a(DROP_NTH_ASM_T 2 discard_tac THEN all_fc_tac[z_fun_ç_clauses]);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[trace_def]);
(* *** Goal "3" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm]);
a(STRIP_T (strip_asm_tac o conv_rule(ONCE_MAP_C z_¬_conv)));
a(STRIP_T (strip_asm_tac o conv_rule(ONCE_MAP_C z_¬_conv)));
a(lemma_tacÒf ç dom (Trace[V](X, Y, Z))Æ
	THEN1 ALL_FC_T asm_rewrite_tac[trace_def]);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆtrace_def)));
a(LEMMA_TÒ(X, Y, Z) ç Ó ∏ Ó ∏ ÓÆ asm_tac THEN REPEAT strip_tac);
a(all_fc_tac[z_fun_ç_clauses]);
a(DROP_NTH_ASM_T 2 discard_tac THEN all_fc_tac[z_fun_ç_clauses]);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[trace_def]);
val €rel_tra_mon_cat_dom_thm› = save_pop_thm "rel_tra_mon_cat_dom_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](RelTraMonCat[V] ç TRA_MON_CAT_NAT[Ó, Rel[V]])Æ);
a(rewrite_tac[tra_mon_cat_nat_def,
	rel_tra_mon_cat_def,
	rewrite_rule[rel_tra_mon_cat_def]
		rel_tra_mon_cat_sig_thm]
	THEN REPEAT strip_tac
	THEN REPEAT_N 4 (POP_ASM_T ante_tac)
	THEN conv_tac (ONCE_MAP_C z_¬_conv)
	THEN ALL_FC_T rewrite_tac[z_plus_Ó_thm]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[h_id_def]);
a(z_cond_rw_tac[v_compose_rw_thm, trace_rw_thm, h_compose_rw_thm]
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN REPEAT strip_tac);
a(asm_rewrite_tac[ç_rel_thm,
	pc_rule1 "z_library_ext" prove_rule[]
	Ò[X](id X ç X ™ X)Æ]);
(* *** Goal "1.2" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN REPEAT strip_tac
	THEN asm_rewrite_tac[ç_rel_thm,
	pc_rule1 "z_library_ext" prove_rule[]
	Ò[X](id X ç X ™ X)Æ]);
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN REPEAT strip_tac);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "1.2.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[ç_rel_thm]);
a(LIST_DROP_NTH_ASM_T [1, 2] (MAP_EVERY ante_tac));
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1.2.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[ç_rel_thm]);
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y ç AÆ]);
a(LIST_DROP_NTH_ASM_T [1, 3] (MAP_EVERY ante_tac));
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1.3" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN REPEAT strip_tac
	THEN asm_rewrite_tac[ç_rel_thm,
	pc_rule1 "z_library_ext" prove_rule[]
	Ò[X](id X ç X ™ X)Æ]);
(* *** Goal "1.3.1" *** *)
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN rewrite_tac[]);
a(REPEAT_UNTIL is_¥ strip_tac THEN rewrite_tac[]);
a(REPEAT_N 3 (conv_tac(LEFT_C(PC_C1 "z_library_ext" once_rewrite_conv[]))));
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1.3.1.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[ç_rel_thm]);
a(LIST_DROP_NTH_ASM_T [3] (MAP_EVERY ante_tac));
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1.3.1.2" *** *)
a(DROP_NTH_ASM_T 10 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.3.2" *** *)
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN rewrite_tac[]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1.3.2.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[ç_rel_thm]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑x ç AÆ]);
a(LIST_DROP_NTH_ASM_T [2] (MAP_EVERY ante_tac));
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1.3.2.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y ç AÆ]);
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[ç_rel_thm]);
a(LIST_DROP_NTH_ASM_T [2] (MAP_EVERY ante_tac));
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1.3.3" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1.4" *** *)
a(REPEAT_N 4 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac);
(* *** Goal "1.4.1" *** *)
a(all_var_elim_asm_tac1 THEN asm_rewrite_tac[]);
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑x ç AÆ]);
a(LIST_GET_NTH_ASM_T [1, 10, 12] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
a(all_fc_tac[z_seq_u_thm]);
a(all_fc_tac[z_Î_one_one_thm1] THEN all_var_elim_asm_tac1);
a(z_∂_tacÒc'Æ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1.4.1.1" *** *)
a(DROP_NTH_ASM_T 18 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
a(POP_ASM_T ante_tac
	THEN ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN taut_tac);
(* *** Goal "1.4.1.2" *** *)
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É;x:É; y:É|(x, y) ç id A ∑y = xÆ]
	THEN all_var_elim_asm_tac1);
a(z_∂_tacÒcÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.4.2" *** *)
a(DROP_NTH_ASM_T 8 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
(* *** Goal "1.4.3" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(z_∂_tacÒcÆ THEN asm_rewrite_tac[]);
a(z_∂_tacÒy Î cÆ THEN asm_rewrite_tac[]);
a(z_∂_tacÒ(a¶x1, b¶c, c'¶y, d¶c)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN rewrite_tac[]);
a(DROP_NTH_ASM_T 8 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
a(LIST_DROP_NTH_ASM_T [1, 4, 6] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN taut_tac);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac[h_id_def]);
a(z_cond_rw_tac[v_compose_rw_thm, trace_rw_thm, h_compose_rw_thm]
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN REPEAT strip_tac);
a(asm_rewrite_tac[ç_rel_thm,
	pc_rule1 "z_library_ext" prove_rule[]
	Ò[X](id X ç X ™ X)Æ]);
(* *** Goal "2.2" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(asm_rewrite_tac[ç_rel_thm,
	pc_rule1 "z_library_ext" prove_rule[]
	Ò[X](id X ç X ™ X)Æ]);
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[]));
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "2.2.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑x ç AÆ]);
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[ç_rel_thm]);
a(LIST_DROP_NTH_ASM_T [2] (MAP_EVERY ante_tac));
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "2.2.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y ç AÆ]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "2.3" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(asm_rewrite_tac[ç_rel_thm,
	pc_rule1 "z_library_ext" prove_rule[]
	Ò[X](id X ç X ™ X)Æ] THEN REPEAT strip_tac
	THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2.3.1" *** *)
a(REPEAT_N 5 (PC_T1 "z_library_ext" once_rewrite_tac[]));
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "2.3.1.1" *** *)
a(DROP_NTH_ASM_T 10 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.3.1.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "2.3.2" *** *)
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "2.3.2.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑x ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
(* *** Goal "2.3.2.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "2.3.3" *** *)
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac);
(* *** Goal "2.4" *** *)
a(REPEAT_N 4 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac);
(* *** Goal "2.4.1" *** *)
a(z_∂_tacÒaÆ THEN all_var_elim_asm_tac1 THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 14 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y = x ± x ç AÆ]
	THEN all_var_elim_asm_tac);
a(LIST_GET_NTH_ASM_T [1, 10, 11] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "2.4.1.1" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(all_fc_tac[z_Î_one_one_thm1] THEN all_var_elim_asm_tac1);
a(z_∂_tacÒcÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.4.1.2" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(all_fc_tac[z_Î_one_one_thm1] THEN all_var_elim_asm_tac1);
(* *** Goal "2.4.2" *** *)
a(DROP_NTH_ASM_T 8 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "2.4.3" *** *)
a(z_∂_tacÒcÆ THEN asm_rewrite_tac[]);
a(z_∂_tacÒy Î cÆ THEN asm_rewrite_tac[]);
a(z_∂_tacÒ(a¶y, b¶c, c'¶x2, d¶c)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 8 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
a(LIST_DROP_NTH_ASM_T [1, 5, 6] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN taut_tac);
(* *** Goal "3" *** *)
a(ALL_FC_T rewrite_tac[h_id_def]);
a(z_cond_rw_tac[v_compose_rw_thm, trace_rw_thm, h_compose_rw_thm]
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "3.1" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN REPEAT strip_tac
	THEN asm_rewrite_tac[ç_rel_thm,
		pc_rule1 "z_library_ext" prove_rule[]
		Ò[X](id X ç X ™ X)Æ]);
(* *** Goal "3.2" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(asm_rewrite_tac[] THEN rewrite_tac[ç_rel_thm,
	pc_rule1 "z_library_ext" prove_rule[]
	Ò[X](id X ç X ™ X)Æ]);
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.1" *** *)
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.2.1.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑x ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
(* *** Goal "3.2.1.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "3.2.2" *** *)
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.2.2.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑x ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
(* *** Goal "3.2.2.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "3.3" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN REPEAT strip_tac
	THEN asm_rewrite_tac[ç_rel_thm,
		pc_rule1 "z_library_ext" prove_rule[]
		Ò[X](id X ç X ™ X)Æ]);
(* *** Goal "3.3.1" *** *)
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(REPEAT_N 5 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.3.1.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
(* *** Goal "3.3.1.2" *** *)
a(DROP_NTH_ASM_T 10 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.3.2" *** *)
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.3.2.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑x ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
(* *** Goal "3.3.2.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "3.3.3" *** *)
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(REPEAT_N 5 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.3.3.1" *** *)
a(DROP_NTH_ASM_T 10 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.3.3.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "3.3.4" *** *)
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.3.4.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑x ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
(* *** Goal "3.3.4.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "3.4" *** *)
a(REPEAT_N 5 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.4.1" *** *)
a(z_∂_tacÒdÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 14 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç A ± y ç BÆ]
	THEN REPEAT strip_tac);
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y = x ± x ç AÆ]
	THEN all_var_elim_asm_tac);
a(LIST_GET_NTH_ASM_T [3, 12, 14] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(lemma_tacÒ#b = #cÆ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[z_seq_u_thm] THEN all_fc_tac[z_Î_one_one_thm1]
	THEN all_var_elim_asm_tac1);
a(z_∂_tacÒx2 Î cÆ THEN asm_rewrite_tac[]);
a(z_∂_tacÒ(a¶x2, b¶c, c'¶x2, d'¶d)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 14 ante_tac);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN taut_tac);
(* *** Goal "3.4.2" *** *)
a(z_∂_tacÒbÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 14 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç A ± y ç BÆ]
	THEN REPEAT strip_tac);
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y = x ± x ç AÆ]
	THEN all_var_elim_asm_tac);
a(LIST_GET_NTH_ASM_T [2, 12, 13] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(lemma_tacÒ#d = #cÆ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[z_seq_u_thm] THEN all_fc_tac[z_Î_one_one_thm1]
	THEN all_var_elim_asm_tac1);
a(z_∂_tacÒx1 Î cÆ THEN asm_rewrite_tac[]);
a(z_∂_tacÒ(a¶x1, b'¶b, c'¶x1, d¶c)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 15 ante_tac);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN taut_tac);
val €rel_tra_mon_cat_nat_thm› = save_pop_thm "rel_tra_mon_cat_nat_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](RelTraMonCat[V] ç TRA_MON_CAT_VAN[Ó, Rel[V]])Æ);
a(rewrite_tac[tra_mon_cat_van_def,
	rel_tra_mon_cat_def,
	rewrite_rule[rel_tra_mon_cat_def]
		rel_tra_mon_cat_sig_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(strip_asm_tac(z_µ_elimÒ0Æ(µ_elimÒVÆh_id_ç_rel_thm)));
a(conv_tac(ONCE_MAP_C z_¬_conv) THEN REPEAT strip_tac);
a(z_cond_rw_tac[trace_rw_thm, v_compose_rw_thm, h_id_rw_thm]
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[ç_rel_thm]);
(* *** Goal "1.1" (duplicating "1.3") *** *)
a(rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA : É∑id A ç A ™ AÆ]);
(* *** Goal "1.2" *** *)
a(REPEAT_N 3(PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT_UNTIL is_± strip_tac);
a(DROP_NTH_ASM_T 3 ante_tac);
a(rewrite_tac[set_exp_0_thm, id_singleton_thm]);
a(REPEAT_UNTIL is_± strip_tac THEN all_var_elim_asm_tac1);
a(ALL_FC_T rewrite_tac[z_Î_ß¢_thm]);
a(DROP_NTH_ASM_T 6 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç A ± y ç BÆ]);
(* *** Goal "1.4" (1.3 duplicated 1.1) *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1.4.2" *** *)
a(LIST_DROP_NTH_ASM_T [3, 9] (MAP_EVERY ante_tac));
a(rewrite_tac[id_singleton_thm, set_exp_0_thm]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [7, 8] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [5, 6] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_Î_ß¢_thm]);
a(contr_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1.4.2" *** *)
a(DROP_NTH_ASM_T 5 (ante_tac o rewrite_rule[ç_rel_thm]));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç A ± y ç BÆ]);
(* *** Goal "1.4.3" *** *)
a(DROP_NTH_ASM_T 5 (ante_tac o rewrite_rule[ç_rel_thm]));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç A ± y ç BÆ]);
(* *** Goal "1.4.4" *** *)
a(z_∂_tacÒß¢Æ THEN rewrite_tac[set_exp_0_thm]);
a(z_∂_tacÒ(a'¶x1, b'¶ß¢, c'¶x2, d¶ß¢)Æ THEN asm_rewrite_tac[id_singleton_thm]);
a(DROP_NTH_ASM_T 5 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T (MAP_EVERY ante_tac)[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç A ± y ç BÆ]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(rewrite_tac[z_ß¢_seq_thm] THEN taut_tac);
(* *** Goal "2" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(lemma_tacÒX + W ç Ó ± Y + W ç ÓÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm]);
a(conv_tac(ONCE_MAP_C z_¬_conv) THEN REPEAT strip_tac);
a(z_cond_rw_tac[trace_rw_thm, v_compose_rw_thm]
	THEN asm_rewrite_tac[ç_rel_thm]
	THEN REPEAT strip_tac
	THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2.1" *** *)
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[]));
a(REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(REPEAT_N 2 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(lemma_tacÒW + Z ç ÓÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(swap_nth_asm_concl_tac 3
	THEN LIST_GET_NTH_ASM_T [4, 5] (MAP_EVERY ante_tac)
	THEN ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN swap_nth_asm_concl_tac 1);
a(REPEAT strip_tac THEN all_fc_tac[z_Î_onto_thm]);
a(all_var_elim_asm_tac1 THEN z_∂_tacÒs1Æ THEN asm_rewrite_tac[]);
a(lemma_tacÒs1 ç V ^ # s1Æ THEN1
	ALL_FC_T asm_rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(ALL_FC_T asm_rewrite_tac[Î_set_exp_thm]);
a(z_∂_tacÒs2Æ THEN ALL_FC_T asm_rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T asm_rewrite_tac[z_Î_assoc_thm]);
(* *** Goal "2.2.2" *** *)
a(z_∂_tacÒc Î c'Æ THEN ALL_FC_T asm_rewrite_tac[Î_set_exp_thm]);
a(LIST_DROP_NTH_ASM_T [2, 5, 6, 7] (MAP_EVERY ante_tac)
	THEN ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 9 ante_tac THEN all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T asm_rewrite_tac[z_Î_assoc_thm]);
val €rel_tra_mon_cat_van_thm› = save_pop_thm "rel_tra_mon_cat_van_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](RelTraMonCat[V] ç TRA_MON_CAT_SUP[Ó, Rel[V]])Æ);
a(rewrite_tac[tra_mon_cat_sup_def,
	rel_tra_mon_cat_def,
	rewrite_rule[rel_tra_mon_cat_def]
		rel_tra_mon_cat_sig_thm]
	THEN REPEAT strip_tac);
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(lemma_tacÒW + X ç Ó ± W + Y ç ÓÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm]);
a(conv_tac(ONCE_MAP_C z_¬_conv) THEN REPEAT strip_tac);
a(z_cond_rw_tac[trace_rw_thm, v_compose_rw_thm, h_id_rw_thm]
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[ç_rel_thm,
		pc_rule1 "z_rel_ext" prove_rule[]
		ÒµA:É∑ id A ç A ™ AÆ,
		ç_rel_thm]
	THEN REPEAT strip_tac
	THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "1" *** *)
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[]));
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm);
a(strip_tac THEN1 REPEAT strip_tac);
a(strip_tac THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(strip_tac THEN1 all_fc_tac [pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É;x:É; y:É|(x, y) ç id A ∑x ç AÆ]);
a(DROP_NTH_ASM_T 11 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T (MAP_EVERY ante_tac) [pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
a(asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm);
a(strip_tac THEN1 REPEAT strip_tac);
a(strip_tac THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(strip_tac THEN1 all_fc_tac [pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É;x:É; y:É|(x, y) ç id A ∑y ç AÆ]);
a(DROP_NTH_ASM_T 11 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T (MAP_EVERY ante_tac) [pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[]));
a(REPEAT strip_tac);
(* *** Goal "3" *** *)
a(REPEAT_N 2 (PC_T1 "z_library_ext" once_rewrite_tac[]));
a(REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y = x ± y ç AÆ]
	THEN all_var_elim_asm_tac);
a(swap_nth_asm_concl_tac 1
	THEN LIST_GET_NTH_ASM_T [9, 10, 11] (MAP_EVERY ante_tac)
	THEN ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN swap_nth_asm_concl_tac 1);
a(REPEAT strip_tac THEN rewrite_tac[]
	THEN all_fc_tac[z_Î_onto_thm]
	THEN all_var_elim_asm_tac1);
a(POP_ASM_T (strip_asm_tac o eq_sym_rule));
a(lemma_tac Òa' Î b' = s1' Î (s2' Î c)Æ
	THEN1 (all_fc_tac[z_seq_u_thm]
		THEN ALL_FC_T asm_rewrite_tac[z_Î_assoc_thm]));
a(DROP_NTH_ASM_T 14 discard_tac);
a(DROP_NTH_ASM_T 26 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac [pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç A ± y ç BÆ]);
a(swap_nth_asm_concl_tac 1
	THEN DROP_NTH_ASM_T 2 ante_tac
	THEN ALL_FC_T asm_rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN swap_nth_asm_concl_tac 1);
a(lemma_tacÒ# b' = # (s2' Î c)Æ
	THEN1 (all_fc_tac[z_seq_u_thm]
		THEN ALL_FC_T asm_rewrite_tac[z_size_Î_thm]));
a(lemma_tacÒs2' ç (seq _) ± c ç (seq _)Æ
	THEN1 ALL_FC_T rewrite_tac[z_seq_u_thm]);
a(lemma_tacÒs2' Î c ç (seq _)Æ THEN1 all_fc_tac[z_Î_ç_seq_thm]);
a(LIST_DROP_NTH_ASM_T[2, 3] discard_tac);
a(lemma_tacÒa' ç (seq _) ± b' ç (seq _) ± s1' ç (seq _) Æ
	THEN1 ALL_FC_T rewrite_tac[z_seq_u_thm]);
a(lemma_tacÒa' = s1' ± b' = (s2' Î c)Æ
	THEN1 ALL_FC_T rewrite_tac[z_Î_one_one_thm1]);
a(all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T[1, 2] discard_tac);
a(REPEAT strip_tac THEN rewrite_tac[]);
a(strip_asm_tac(z_µ_elimÒ(s ¶ d, m ¶ #s2, n ¶ #c)Æ(µ_elim¨VÆ z_Î_onto_thm))
	THEN all_var_elim_asm_tac1);
a(lemma_tac Òs1' Î (s1'' Î s2'') = s1 Î (s2 Î c)Æ
	THEN1 (all_fc_tac[z_seq_u_thm]
		THEN ALL_FC_T asm_rewrite_tac[z_Î_assoc_thm]));
a(lemma_tacÒs1' ç (seq _) ± s1 ç (seq _) ± s2 ç (seq _) ± c ç (seq _)Æ
	THEN1 ALL_FC_T rewrite_tac[z_seq_u_thm]);
a(lemma_tacÒ# (s1'' Î s2'') = # (s2 Î c)Æ
	THEN1 ALL_FC_T asm_rewrite_tac[z_size_Î_thm]);
a(lemma_tacÒs1'' Î s2'' ç (seq _) ± (s2 Î c) ç (seq _)Æ THEN1 ALL_FC_T rewrite_tac[z_Î_ç_seq_thm]);
a(LIST_DROP_NTH_ASM_T [4, 5] discard_tac);
a(all_fc_tac[z_Î_one_one_thm1] THEN all_var_elim_asm_tac1);
a(LIST_DROP_NTH_ASM_T [2, 3, 4, 5] discard_tac);
a(lemma_tacÒs1'' ç (seq _) ± s2'' ç (seq _) ± s2 ç (seq _) ± c ç (seq _)Æ
	THEN1 ALL_FC_T rewrite_tac[z_seq_u_thm]);
a(rename_tac[(Òs2Æ, "e")] THEN all_fc_tac[z_Î_one_one_thm1] THEN all_var_elim_asm_tac1);
a(z_∂_tacÒ(a¶s1, b¶s2', c'¶s1, d¶e)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN ALL_FC_T asm_rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(z_∂_tacÒcÆ THEN asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(all_var_elim_asm_tac1 THEN bc_thm_tac Î_set_exp_bc_thm);
a(REPEAT strip_tac);
a(all_fc_tac [pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É;x:É; y:É|(x, y) ç id A ∑x ç AÆ]);
(* *** Goal "3.3" *** *)
a(all_var_elim_asm_tac1 THEN bc_thm_tac Î_set_exp_bc_thm);
a(REPEAT strip_tac);
a(all_fc_tac [pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É;x:É; y:É|(x, y) ç id A ∑y ç AÆ]);
(* *** Goal "3.4" *** *)
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y = x ± y ç AÆ]
	THEN all_var_elim_asm_tac);
a(z_∂_tacÒc'Æ THEN all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(z_∂_tacÒ(a'¶a, b'¶b Î c', c''¶a, d'¶d Î c')Æ THEN asm_rewrite_tac[]);
a(LEMMA_T Òb Î c' ç V^(X+Z) ± d Î c' ç V^(Y+Z)Æ ante_tac
	THEN1 (REPEAT strip_tac THEN bc_thm_tac Î_set_exp_bc_thm THEN REPEAT strip_tac));
a(DROP_NTH_ASM_T 3 ante_tac);
a(lemma_tacÒX + Z ç Ó ± Y + Z ç ÓÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT strip_tac THEN all_fc_tac[z_seq_u_thm]
	THEN ALL_FC_T rewrite_tac[z_Î_assoc_thm]);
val €rel_tra_mon_cat_sup_thm› = save_pop_thm "rel_tra_mon_cat_sup_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](RelTraMonCat[V] ç TRA_MON_CAT_YAN[Ó, Rel[V]])Æ);
a(rewrite_tac[tra_mon_cat_yan_def,
	rel_tra_mon_cat_def,
	rewrite_rule[rel_tra_mon_cat_def]
		rel_tra_mon_cat_sig_thm]
	THEN REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆswitch_def)));
a(LEMMA_TÒ(X, X) ç Ó ∏ ÓÆ asm_tac THEN REPEAT strip_tac);
a(all_fc_tac[z_fun_ç_clauses]);
a(LIST_DROP_NTH_ASM_T[2, 3] discard_tac);
a(LEMMA_TÒTranspose[V] (X, X) ç dom (Trace[V](X, X, X))Æante_tac
	THEN ALL_FC_T asm_rewrite_tac[trace_def]
	THEN1 ALL_FC_T rewrite_tac[switch_def]);
a(strip_tac THEN ALL_FC_T asm_rewrite_tac[trace_def]);
a(ALL_FC_T rewrite_tac[switch_def, h_id_def]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(lemma_tacÒ#b' = #c ± #a' = #cÆ THEN1 asm_rewrite_tac[]);
a(LIST_DROP_NTH_ASM_T (interval 10 22)
	(fn ths=> 
		all_fc_tac[z_Î_one_one_thm1]
	THEN MAP_EVERY asm_tac ths));
a(all_var_elim_asm_tac1 THEN strip_tac);
(* *** Goal "2" *** *)
a(z_∂_tacÒ(c ¶ x2)Æ THEN asm_rewrite_tac[]);
a(z_∂_tacÒ(a' ¶ x2, b' ¶ x2)Æ THEN asm_rewrite_tac[]);
val €rel_tra_mon_cat_yan_thm› = save_pop_thm "rel_tra_mon_cat_yan_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](
	TRA_MON_CAT[Ó, Rel[V]] = 
	TRA_MON_CAT_SIG[Ó, Rel[V]]
°	TRA_MON_CAT_DOM[Ó, Rel[V]]
°	TRA_MON_CAT_NAT[Ó, Rel[V]]
°	TRA_MON_CAT_VAN[Ó, Rel[V]]
°	TRA_MON_CAT_SUP[Ó, Rel[V]]
°	TRA_MON_CAT_YAN[Ó, Rel[V]])
Æ);
a(rewrite_tac[tra_mon_cat_def]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €tra_mon_cat_rw_thm› = save_pop_thm "tra_mon_cat_rw_thm";

=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "rel_tra_mon_cat_thm");
a(rewrite_tac[tra_mon_cat_rw_thm]);
a(rewrite_tac[rel_tra_mon_cat_sig_thm,
	rel_tra_mon_cat_dom_thm,
	rel_tra_mon_cat_nat_thm,
	rel_tra_mon_cat_yan_thm,
	rel_tra_mon_cat_sup_thm,
	rel_tra_mon_cat_van_thm]);
val €rel_tra_mon_cat_thm› = save_pop_thm "rel_tra_mon_cat_thm";
=TEX
\section{Epilogue}
=SML
z_output_theory{out_file="wrk075.th.doc", theory="-"};
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
=TEX
\end{document}
=IGN
