=IGN
********************************************************************************
wrk075.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[12pt]{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\def\Hide#1{\relax}
\title{On Precondition Calculation in a Traced Monoidal Category \\ (DRAFT)}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\section{Introduction}\label{Intro}

This note is the third in a planned series concerned with specification via
pre- and post-conditions.
It applies the general notion of specification and refinement given in the first note in the series
\cite{LEMMA1/ZED/WRK069} to systems formed by wiring together primitive building blocks.

\Hide{
The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"refcalc";
set_pc"z_library1";
force_delete_theory"ctssys" handle Fail _ => ();
new_theory"ctssys";
new_parent"z_reals";
ReaderWriterSupport.PrettyNames.add_new_symbols[
	(["refinedby"], Value "√", ReaderWriterSupport.PrettyNames.Simple), 
	(["ident"], Value "È", ReaderWriterSupport.PrettyNames.Simple)
] handle Fail _ => ();
=TEX
}

The Z specification uses infix or postfix notation for the following relation
and function symbols (in addition to those defined in the first note).
πZ
‹ function 40  _**_
∞

πZ
‹ function 50  _ ^ _
∞

% \newpage
\section{WEAKEST PRE-CONDITIONS}

In \cite{LEMMA1/ZED/WRK070}, we give an account of precondition calculation for a small programming language.
In this note, we will be exploring weakest precondition calculation in a less familiar situation.
It is therefore helpful to formalise the abstract concept.
In this section we do this (implicitly) in the category of arbitrary relations in Z.
This category becomes a monoidal category under a ``vertical'' composition operator and then becomes a traced monoidal category under a trace operator defined by existential quantification.
We show how the weakest pre-condition behaves with respect to these operators.

The simplest notion of weakest precondition pulls a simple predicate back through a relation.
Representing predicates as sets, this notion is defined as follows:

ù[ Y, Z ]úúúúúúúúúúú
‹ €WPS› : (Y ™ Z) ∏ Z ≠ Y
˜¸¸¸¸¸¸
‹ µS : Y ™ Z; C : Z∑
‹	WPS(S, C) = {y : Y | S ®{y}© Ä C}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸


The following theorem shows that our explicit definition for $WP(S, C)$ is indeed the weakests $R$ such that $R\;ª\;S \subseteq P$.

πZ
‹ wps_correct_thm ?Ù
‹	µS : É; C : É∑ S®WPS(S, C)© Ä C;
‹	µS : É; B : É; C : É | S®B© Ä C ∑ B Ä WPS(S, C)
∞

The weakest pre-condition of a conjunction (intersection) is a conjunction:

πZ
‹ wps_cap_thm ?Ù
‹	µR : É; B, C : É∑ WPS(R, B ° C) = WPS(R, B) ° WPS(R, C)
∞
The weakest pre-condition for a relational composition is given by an appropriate form of functional composition.

πZ
‹ wps_comp_thm ?Ù
‹	µR : É; S : É; A : É∑ WPS(R ª S, A) = WPS(R, WPS(S, A))
∞

The following theorem may be helpful in understanding some of the
results which follow.
It shows that any point not in the domain of the relation $S$ satisfies any weakest pre-condition through $S$.

πZ
‹ wps_compl_dom_thm ?Ù
‹	µS : É; C : É ∑
‹		É \ dom S Ä WPS(S, C)
∞

We now define the ``vertical'' composition of two arbitrary relations.

ù[ X, Y, V, W ]úúúúúúúúúúú
‹ €_**_› : (X ™ Y) ∏ (V ™ W) ≠ (X ∏ V ™ Y ∏ W)
˜¸¸¸¸¸¸
‹ µR : X ™ Y; S : V ™ W∑
‹	R ** S =
‹	{x : X; y : Y; v : V; w : W
‹	| (x, y) ç R ± (v, w) ç S ∑ ( (x, v), (y, w) )}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

The weakest pre-condition through a vertical composite is as follows:

πZ
‹ wps_prod_thm ?Ù
‹	µR : É; S : É; B : É; C : É ∑
‹		WPS(R ** S, B ∏ C) =
‹		(WPS(R, B) ∏ WPS(S, C)) ¿ (É \ (dom R ∏ dom S))
∞

ù[ X, Y, V ]úúúúúúúúúúú
‹ €Projâ∂› : (X ∏ V ™ Y ∏ V) ≠ (X ™ Y)
˜¸¸¸¸¸¸
‹ µR : (X ∏ V ™ Y ∏ V)∑
‹	Projâ∂ R =
‹	{x : X; y : Y | ∂v : V∑ ((x, v), (y, v)) ç R}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

πZ
‹ wps_proj_exists_thm ?Ù
‹	µR : É;  C : É ∑
‹		WPS(Projâ∂ R, C) =
‹		{x: É | µv:É∑ (x, v) ç WPS(R ° (É ** (id _)), C ∏ É)∑ x}
∞

As noted in \cite{LEMMA1/ZED/WRK070}, a more general notion of weakest precondition calculation deals with relations.
In general, if $S$ and $P$ are binary relations,
we want to specify  $WP(S, P)$ so that it is the weakest (i.e., largest) relation $R$ such that $R\;ª\;S \subseteq P$.
We use an explicit formula for $WP$ (cf. the clause for atoms in the function {\em prec\_calc} in \cite{LEMMA1/ZED/WRK070}).

ù[ X, Y, Z ]úúúúúúúúúúú
‹ €WP› : (Y ™ Z) ∏ (X ™ Z) ≠ (X ™ Y)
˜¸¸¸¸¸¸
‹ µS : Y ™ Z; P : X ™ Z∑
‹	WP(S, P) = {x : X; y : Y | S ®{y}© Ä P®{x}©}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

The following theorem shows that our explicit definition for $WP(S, P)$ is indeed the weakests $R$ such that $R\;ª\;S \subseteq P$.

πZ
‹ wp_correct_thm ?Ù
‹	µS : É; P : É∑ WP(S, P) ª S Ä P;
‹	µR : É; S : É; P : É | R ª S Ä P ∑ R Ä WP(S, P)
∞

The relational formulation of weakest precondition may be defined in terms of the set formulation:

πZ
‹ wp_wps_thm ?Ù
‹	µS : É; P : É∑ WP(S, P) = {x : É; y : É | y ç WPS(S, P®{x}©)}
∞

From the above, one can calculate relational weakest pre-conditions for intersections, compositions etc. using the
corresponding theorems for predicate weakest pre-conditions.

\newpage
\section{A CATEGORY OF RELATIONS}

We are going to work with systems of relations that can naturally be expressed diagrammatically.
The elements of the diagrams are called {\em boxes} and {\em wires}.
A box with $m$ inputs and $n$ outputs represents a relation between $V^m$ and $V^n$ for some suitable value domain $V$.
The produce new relations from old by adding equational constraints.
The diagrams need not form directed graphs: feedback loops are allowed and correspond to existential quantification.


Our approach to the syntax and semantics of diagrams is informed by the idea of a traced monoidal category.
The idea is that diagrams correspond to functor expressions in such a category.  Composition in the category corresponds to wiring diagrams in series.
The monoid operator corresponds to putting two diagrams together without adding any wiring.
Finally the trace operator corresponds to adding feedback loops to diagram.


If $V$ is any set, $V^m$ gives the set of all $m$-tuples with values ranging over $V$.
Typically $V^m$ represents the vector of inputs or outputs of a box in a diagram.

ù[ U ]úúúúúúúúúúú
‹ €_ ^ _› : U ∏ Ó ≠ (seq U)
˜¸¸¸¸¸¸
‹ µV : U; m:Ó∑ V ^ m =  {s : seq V | #s = m}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

For each set $V$, there is a category, which we shall call $Rel[V]$, whose objects are the natural numbers and whose morphisms (a.k.a. arrows) from $m$ to $n$ are the relations between $V^m$ and $V^n$ composed via ordinary relational composition\footnote{
We take the objects to be the natural numbers, $m$, rather than the sets $V^m$ for technical convenience to avoid having the category collapse when $V = \{\}$.
}.
We represent the category in Z by defining its set of morphisms.
A morphism is given as labelled triple whose components give the domain ($d$), codomain ($c$), and the relation ($r$).

πZ
‹ €Rel›[V] ¶ ﬁ{m, n : Ó ∑ {R : V^m ™ V^n∑ (d ¶ m, c ¶ n, r ¶ R)}}
∞

The composition of morphisms that makes $Rel[V]$ into a category is the ``horizontal'' composition defined below.

ù[V]úúúúúúúúúúú
‹ €HCompose› : Rel[V] ∏ Rel[V] ﬂ Rel[V]
˜¸¸¸¸¸¸
‹ dom HCompose = {R, S : Rel[V] | R.c = S.d} ;
‹ µR, S : Rel[V] | R.c = S.d ∑
‹	HCompose(R, S) = (d ¶ R.d, c ¶ S.c, r ¶ R.r ª S.r)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

The category becomes a monoidal category under a product given by addition on objects and by the following ``vertical composition'' on morphisms.

 
ù[V]úúúúúúúúúúú
‹ €VCompose› : Rel[V] ∏ Rel[V] ≠ Rel[V]
˜¸¸¸¸¸¸
‹ µR, S : Rel[V] ∑
‹	VCompose(R, S) = (d ¶ R.d + S.d, c ¶ R.c + S.c,
‹		r ¶ {a, b, c, d : seq V | (a, c) ç R.r ± (b, d) ç S.r∑ (a Î b, c Î d)})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

Finally, we get a traced monoidal category by defining the following operator that corresponds to adding $k$ feedback loops into a diagram.
 
ù[V]úúúúúúúúúúú
‹ €Feedback› : Rel[V] ∏ Ó ﬂ Rel[V]
˜¸¸¸¸¸¸
‹ dom Feedback = {R : Rel[V]; k : Ó | ∂m, n : Ó∑R.d = m + k ± R.c = n + k} ;
‹ µR : Rel[V]; k, m, n : Ó | R.d = m + k ± R.c = n + k ∑
‹	Feedback(R, k) = (d ¶ m, c ¶ n,
‹		r ¶ {a, b : seq V | ∂c:V^k∑ (a Î c, b Î c) ç R.r})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

To use the relation category, we will generally need to know something about the value domain, $V$.
However, we can define at least one generic construction corresponding to patching inputs to outputs according to a wiring diagram (given as a relation between input port numbers and output port numbers):


ù[V]úúúúúúúúúúú
‹ €Patch› : Ó ∏ Ó ∏ (Ó ™ Ó) ≠ Rel[V]
˜¸¸¸¸¸¸
‹ µm, n : Ó; d : Ó ™ Ó∑
‹	Patch(m, n, d) = (d ¶ m, c ¶ n,
‹		r ¶ {a : V^m; b : V^n | µi : 1..m; j : 1..n |(i, j) ç d∑ b j = a i})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

\section{SIGNAL FLOW GRAPHS}

A {\em signal} will be a real-valued function of a real variable.

πZ
‹ €SIGNAL› ¶ Ø ≠ Ø
∞

The category of signal flow graphs is then the relational category with the value domain given by signals.


πZ
‹ €SFG› ¶ Rel[SIGNAL]
∞

We instantiate the notions of predicates, pre- post-conditions
and specifications from \cite{LEMMA1/ZED/WRK069} so that we can use them to express properties of signals:

πZ
‹ €S_PRED› ¶ PRED[SIGNAL]
∞
πZ
‹ €S_PRE_COND› ¶ PRE_COND[SIGNAL]
∞
πZ
‹ €S_POST_COND› ¶ POST_COND[SIGNAL, SIGNAL]
∞
πZ
‹ €S_SPEC› ¶ SPEC[SIGNAL, SIGNAL]
∞
We now have a notion of diagram which is in quite close analogy with the notion of imperative program considered in \cite{LEMMA1/ZED/WRK070}.

πZ
‹ €DIAGRAM› ::=
‹	€Atom› (SFG)
‹ |	€Seq› (DIAGRAM ∏ DIAGRAM)
‹ |	€Par› (DIAGRAM ∏ DIAGRAM)
‹ |	€Loop› (DIAGRAM ∏ Ó)
‹ |	€Spec› (S_SPEC ∏ DIAGRAM)
∞

πZAX
‹ €semantics› : DIAGRAM ≠ SFG
˜¸¸¸¸¸¸
‹ µt : SFG; dâ1, dâ2 : DIAGRAM; n : Ó; s : S_SPEC∑
‹	semantics (Atom t) = t
‹ ±	semantics (Seq(dâ1, dâ2)) = HCompose(semantics dâ1, semantics dâ2)
‹ ±	semantics (Par(dâ1, dâ2)) = VCompose(semantics dâ1, semantics dâ2)
‹ ±	semantics (Loop(dâ1, n)) = Feedback(semantics dâ1, n)
‹ ±	semantics (Spec(s, dâ1)) = semantics dâ1
∞

\bibliographystyle{fmu}
\bibliography{fmu}


\newpage
\appendix
\section{SOME CATEGORY THEORY}
A category with the set of objects $O$ and the set of arrows $A$ is represented by a member of the following generic schema,
in which we agree to write composition in the category left to right.


πZ
‹ function 40 leftassoc  _ ªâc _
∞


ˇ CAT[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ €_ ªâc _› : A ∏ A ﬂ A ;
‹ €domâc›, €codâc› : A ≠ O ;
‹ €idâc› : O ≠ A
˜¸¸¸¸¸¸
‹ dom (_ ªâc _) = {f, g : A | codâc f = domâc g} ;
‹ µf, g, h : A | codâc f = domâc g ± codâc g = domâc h ∑
‹	(f ªâc g) ªâc h = f ªâc (g ªâc h) ;
‹ µf, g :  A | codâc f = domâc g ∑
‹	domâc (f ªâc g) = domâc f ± codâc (f ªâc g) = codâc g ;
‹ µ X : O ∑
‹	domâc (idâc X) = codâc (idâc X) = X ;
‹ µ f : A ∑
‹	idâc(domâc f) ªâc f = f ªâc idâc(codâc f) = f
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

We can now state the theorem that $Rel[V]$ with the appropriate structure is indeed a category.

πZ
‹ rel_cat_thm ?Ù [V](
‹	(_ ªâc _ ¶ HCompose[V],
‹	domâc ¶ (ÃR:Rel[V]∑R.d),
‹	codâc ¶ (ÃR:Rel[V]∑R.c),
‹	idâc ¶ (Ãm:Ó∑(d ¶ m, c ¶ m, r ¶ id(V^m)))) ç CAT[Ó, Rel[V]])
∞


\newpage
\appendix
=TEX
{\HOLindexOff\small
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{wrk075.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%
%% Comment out next line to include the proofs in the printed document:
\end{document}

\section{Proofs}
=TEX
\ftlinepenalty=999
=SML
val €wps_def› = z_get_specÒWPSÆ;
val €wp_def› = z_get_specÒWPÆ;
val €set_exp_def› = z_get_specÒ(_^_)Æ;
val €rel_prod_def› = z_get_specÒ(_**_)Æ;
val €proj_∂_def› = z_get_specÒProjâ∂Æ;
val €rel_def› = z_get_specÒRel[V]Æ;
val €h_compose_def› = z_get_specÒHComposeÆ;
val €v_compose_def› = z_get_specÒVComposeÆ;
val €feedback_def› = z_get_specÒFeedbackÆ;
val €cat_def› = z_get_specÒCATÆ;
=TEX
%%%%
%%%%
=SML
set_goal([], ÒµR:É; x : É∑R®{x}© = {z : É | (x, z) ç R}Æ);
a(PC_T1 "z_library_ext" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
a(z_∂_tacÒxÆ THEN asm_rewrite_tac[]);
val €z_image_singleton_thm› = save_pop_thm "z_image_singleton_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ÒµS:É;C: É∑
	WPS (S, C) = {y:É| µz:É∑(y, z) ç S ¥ z ç C}Æ);
a(rewrite_tac[z_image_singleton_thm, z_gen_pred_u_elim wps_def]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €wps_rw_thm› = save_pop_thm "wps_rw_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_correct_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €wps_correct_thm› = save_pop_thm "wps_correct_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_cap_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €wps_cap_thm› = save_pop_thm "wps_cap_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_comp_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €wps_comp_thm› = save_pop_thm "wps_comp_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ÒµC:É∑WPS({}, C) = ÉÆ);
a(rewrite_tac[wps_rw_thm]);
val €wps_empty_thm› = save_pop_thm "wps_empty_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_compl_dom_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €wps_compl_dom_thm› = save_pop_thm "wps_compl_dom_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò
	µR : É; S : É; x1 : É; y1 : É; v1 : É; w1 : É∑
	(∂ x : É; y : É; v : É; w : É
	| (x, y) ç R ± (v, w) ç S
 	∑ (x = x1 ± v = v1) ± y = y1 ± w = w1)
§	(x1, y1) ç R ± (v1, w1) ç S
Æ);
a(PC_T1 "z_library_ext" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
a(z_∂_tacÒ(x ¶ x1, v ¶ v1, y ¶ y1, w ¶ w1)Æ THEN asm_rewrite_tac[]);
val €rel_prod_rw_thm› = save_pop_thm "rel_prod_rw_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ÒµR : É; S : É∑ dom (R ** S) = dom R ∏ dom SÆ);
a(PC_T1 "z_library_ext" rewrite_tac[
	z_gen_pred_u_elim rel_prod_def,
	rel_prod_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
a(z_∂_tacÒ(y, y')Æ THEN asm_rewrite_tac[]);
val €dom_rel_prod_thm› = save_pop_thm "dom_rel_prod_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_prod_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm,
	rel_prod_rw_thm,
	z_gen_pred_u_elim rel_prod_def]);
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 (ante_tac o z_µ_elim Ò(z, y')Æ));
a(asm_rewrite_tac[] THEN taut_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 (ante_tac o z_µ_elim Ò(y, z)Æ));
a(asm_rewrite_tac[] THEN taut_tac);
val €wps_prod_thm› = save_pop_thm "wps_prod_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_proj_exists_thm");
a(PC_T1 "z_library_ext" rewrite_tac[
	z_gen_pred_u_elim rel_prod_def,
	wps_rw_thm,
	z_gen_pred_u_elim proj_∂_def]);
a(PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o z_µ_elimÒz.1Æ));
a(DROP_NTH_ASM_T 1 (ante_tac o z_µ_elimÒz.2Æ));
a(conv_tac(ONCE_MAP_C z_tuple_lang_intro_conv));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 2 (fn th => fc_tac[th]));
a(DROP_NTH_ASM_T 1 (ante_tac o list_µ_elim[¨vÆ, ¨vÆ, ¨x1Æ, ¨zÆ]));
a(rewrite_tac[]);
val €wps_proj_exists_thm› = save_pop_thm "wps_proj_exists_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ÒµS:É;P: É∑
	WP (S, P) = {x:É; y:É| µz:É∑(y, z) ç S ¥ (x, z) ç P}Æ);
a(rewrite_tac[z_image_singleton_thm, z_gen_pred_u_elim wp_def]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €wp_rw_thm› = save_pop_thm "wp_rw_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wp_correct_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wp_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €wp_correct_thm› = save_pop_thm "wp_correct_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wp_wps_thm");
a(rewrite_tac[z_image_singleton_thm]);
a(PC_T1 "z_library_ext" rewrite_tac[wp_rw_thm, wps_rw_thm]);
val €wp_wps_thm› = save_pop_thm "wp_wps_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wp_cap_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wp_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €wp_cap_thm› = save_pop_thm "wp_cap_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wp_comp_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wp_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €wp_comp_thm› = save_pop_thm "wp_comp_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V] 
	(Rel[V] = {m, n:Ó; R : É | R ç V^m ™ V^n∑ (d ¶ m, c ¶ n, r ¶ R)})Æ);
a(rewrite_tac[rel_def] THEN REPEAT strip_tac);
a(PC_T "z_sets_ext" strip_tac THEN REPEAT strip_tac
	THEN REPEAT all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(z_∂_tacÒ(m ¶ x2, n ¶ x1, R ¶ x3)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(z_∂_tacÒ{R : V ^ x2 ™ V ^ x1 ∑ (c ¶ x1, d ¶ x2, r ¶ R)}Æ
	THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(z_∂_tacÒ(m ¶ x2, n ¶ x1)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(z_∂_tacÒx3Æ THEN asm_rewrite_tac[]);
val €rel_rw_thm› = save_pop_thm "rel_rw_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V] 
	(µA:É∑A ç Rel[V] § A.c ç Ó ± A.d ç Ó ± A.r ç V^(A.d) ™ V^(A.c))Æ);
a(rewrite_tac[rel_rw_thm] THEN REPEAT strip_tac
	THEN REPEAT all_var_elim_asm_tac1
	THEN_TRY asm_rewrite_tac[]);
a(z_∂_tacÒ(m ¶ A.d, n ¶ A.c, R ¶ A.r)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" asm_rewrite_tac[]);
val €ç_rel_thm› = save_pop_thm "ç_rel_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µf X Y∑
	Ò(Ãm:X∑ ¨f mÆ) ç X ≠ Y § (µx:X ∑ ¨f xÆ ç Y)ÆÆ);
a(PC_T1 "z_fun_ext" prove_tac[]);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
a(all_var_elim_asm_tac1 THEN strip_tac);
val €Ã_ç_≠_thm› = save_pop_thm "Ã_ç_≠_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], get_conjecture"-" "rel_cat_thm");
a(rewrite_tac[cat_def, h_compose_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[
	conv_rule(ONCE_MAP_C ¬_conv)
	(µ_elim¨ÃR∑Ò(R ∫ Rel[V]).dÆÆ Ã_ç_≠_thm)]);
a(z_strip_tac THEN PC_T1 "z_library_ext" rewrite_tac [ç_rel_thm]
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[
	conv_rule(ONCE_MAP_C ¬_conv)
	(µ_elim¨ÃR∑Ò(R ∫ Rel[V]).cÆÆ Ã_ç_≠_thm)]);
a(z_strip_tac THEN PC_T1 "z_library_ext" rewrite_tac [ç_rel_thm]
	THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(rewrite_tac[
	conv_rule(ONCE_MAP_C ¬_conv)
	(µ_elim¨Ãm∑Ò(c ¶ m, d ¶ m, r ¶ id (V ^ m))ÆÆ Ã_ç_≠_thm)]);
a(rewrite_tac[ç_rel_thm]);
a(REPEAT strip_tac);
a(rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[] ÒµA:É∑ id A ç A ™ AÆ]);
(* *** Goal "4" *** *)
a(PC_T1 "z_library_ext" rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(asm_rewrite_tac[]);
(* *** Goal "4.2" *** *)
a(POP_ASM_T ante_tac THEN conv_tac(ONCE_MAP_C z_¬_conv));
a(asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(REPEAT strip_tac);
a(lemma_tacÒ(f, g) ç dom HCompose[V] ± (g, h) ç dom HCompose[V]Æ
	THEN1  PC_T1 "z_sets_ext" asm_rewrite_tac[h_compose_def]);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆh_compose_def)));
a(ALL_FC_T (MAP_EVERY ante_tac)[z_fun_ç_clauses]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(REPEAT strip_tac THEN lemma_tac Ò
	(c ¶ g.c, d ¶ f.d, r ¶ f.r ª g.r).c = h.d
	± f.c = (c ¶ h.c, d ¶ g.d, r ¶ g.r ª h.r).dÆ
	THEN1 asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
	Òµf, g, h:É∑ f ª g ª h = f ª (g ª h)Æ]);
(* *** Goal "6" *** *)
a(POP_ASM_T ante_tac);
a(conv_tac(LEFT_C(ONCE_MAP_C z_¬_conv)));
a(REPEAT strip_tac);
a(lemma_tacÒ(f, g) ç dom HCompose[V]Æ
	THEN1 PC_T1 "z_sets_ext" asm_rewrite_tac[h_compose_def]);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆh_compose_def)));
a(ALL_FC_T (MAP_EVERY ante_tac)[z_fun_ç_clauses]);
a(strip_tac);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[h_compose_def]);
(* *** Goal "7" *** *)
a(POP_ASM_T ante_tac);
a(conv_tac(LEFT_C(ONCE_MAP_C z_¬_conv)));
a(REPEAT strip_tac);
a(lemma_tacÒ(f, g) ç dom HCompose[V]Æ
	THEN1 PC_T1 "z_sets_ext" asm_rewrite_tac[h_compose_def]);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆh_compose_def)));
a(ALL_FC_T (MAP_EVERY ante_tac)[z_fun_ç_clauses]);
a(strip_tac);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[h_compose_def]);
(* *** Goal "8" *** *)
a(LEMMA_T ÒX ç ÓÆ asm_tac THEN REPEAT strip_tac);
a(conv_tac (RANDS_C(RAND_C z_¬_conv)));
a(lemma_tacÒ(c ¶ X, d ¶ X, r ¶ id(V ^ X)) ç Rel[V]Æ
	THEN1 asm_rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ÒµA:É∑ id A ç A ™ AÆ,
		ç_rel_thm]);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(rewrite_tac[]);
(* *** Goal "9" *** *)
a(LEMMA_T ÒX ç ÓÆ asm_tac THEN REPEAT strip_tac);
a(conv_tac (LEFT_C(RAND_C z_¬_conv)));
a(lemma_tacÒ(c ¶ X, d ¶ X, r ¶ id(V ^ X)) ç Rel[V]Æ
	THEN1 asm_rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ÒµA:É∑ id A ç A ™ AÆ,
		ç_rel_thm]);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(rewrite_tac[]);
(* *** Goal "10" *** *)
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(LEMMA_T Òf.c ç ÓÆ asm_tac THEN REPEAT strip_tac);
a(LEMMA_T Òf.d ç ÓÆ asm_tac THEN REPEAT strip_tac);
a(conv_tac(MAP_C z_¬_conv));
a(lemma_tacÒ(c ¶ f.d, d ¶ f.d, r ¶ id(V ^ f.d)) ç Rel[V]
	± (c ¶ f.d, d ¶ f.d, r ¶ id(V ^ f.d)).c = f.d
	± (c ¶ f.c, d ¶ f.c, r ¶ id(V ^ f.c)) ç Rel[V]
	± f.c = (c ¶ f.c, d ¶ f.c, r ¶ id(V ^ f.c)).dÆ
	THEN1 asm_rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ÒµA:É∑ id A ç A ™ AÆ,
		ç_rel_thm]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ÒµA:É; B:É; R:É∑ R ç A ™ B ¥
			R ª id B = id A ª R = RÆ]);
(* *** Goal "11" *** *)
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(LEMMA_T Òf.c ç ÓÆ asm_tac THEN REPEAT strip_tac);
a(conv_tac(MAP_C z_¬_conv));
a(lemma_tacÒ(c ¶ f.c, d ¶ f.c, r ¶ id(V ^ f.c)) ç Rel[V]
	± f.c = (c ¶ f.c, d ¶ f.c, r ¶ id(V ^ f.c)).dÆ
	THEN1 asm_rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ÒµA:É∑ id A ç A ™ AÆ,
		ç_rel_thm]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ÒµA:É; B:É; R:É∑ R ç A ™ B ¥
			R ª id B = id A ª R = RÆ]);
a(PC_T1 "z_library_ext" rewrite_tac[]);
val €rel_cat_thm› = save_pop_thm "rel_cat_thm";

=TEX
\section{Epilogue}
=SML
z_output_theory{out_file="wrk075.th.doc", theory="-"};
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
=TEX
\end{document}
=IGN
