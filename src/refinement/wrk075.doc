=IGN
********************************************************************************
wrk075.doc: this file is supplementary material for the ProofPower system

Copyright (c) 2004 Lemma 1 Ltd.

This file is supplied under the GNU General Public Licence (GPL) version 2.

See the file LICENSE supplied with ProofPower source for the terms of the GPL
or visit the OpenSource web site at http://www.opensource.org/

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[12pt]{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\def\Hide#1{\relax}
\title{On Precondition Calculation in a Traced Monoidal Category \\ (DRAFT)}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\section{Introduction}\label{Intro}

This note is the third in a nseries concerned with specification via
pre- and post-conditions.
It applies the general notion of specification and refinement given in the first note in the series
\cite{LEMMA1/ZED/WRK069} to systems formed by wiring together primitive building blocks.

\Hide{
The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"refcalc";
set_pc"z_library1";
force_delete_theory"ctssys" handle Fail _ => ();
new_theory"ctssys";
new_parent"z_reals";
ReaderWriterSupport.PrettyNames.add_new_symbols[
	(["refinedby"], Value "√", ReaderWriterSupport.PrettyNames.Simple), 
	(["ident"], Value "È", ReaderWriterSupport.PrettyNames.Simple)
] handle Fail _ => ();
=TEX
}

The Z specification uses infix or postfix notation for the following relation
and function symbols (in addition to those defined in the first note).
πZ
‹ function 40  _**_
∞

πZ
‹ function 50  _ ^ _
∞


%\newpage
\section{A CATEGORY OF RELATIONS}

We are going to work with systems of relations that can naturally be expressed diagrammatically.
The elements of the diagrams are called {\em boxes} and {\em wires}.
A box with $m$ inputs and $n$ outputs represents a relation between $V^m$ and $V^n$ for some suitable value domain $V$.
The produce new relations from old by adding equational constraints.
The diagrams need not form directed graphs: feedback loops are allowed and correspond to existential quantification.


Our approach to the syntax and semantics of diagrams is informed by the idea of a traced monoidal category.
The idea is that diagrams correspond to functor expressions in such a category.  Composition in the category corresponds to wiring diagrams in series.
The monoid operator corresponds to putting two diagrams together without adding any wiring.
Finally the trace operator corresponds to adding feedback loops to diagram.


If $V$ is any set, $V^m$ gives the set of all $m$-tuples with values ranging over $V$.
Typically $V^m$ represents the vector of inputs or outputs of a box in a diagram.

ù[ U ]úúúúúúúúúúú
‹ €_ ^ _› : U ∏ Ó ≠ (seq U)
˜¸¸¸¸¸¸
‹ µV : U; m:Ó∑ V ^ m =  {s : seq V | #s = m}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

For each set $V$, there is a category, which we shall call $Rel[V]$, whose objects are the natural numbers and whose morphisms (a.k.a. arrows) from $m$ to $n$ are the relations between $V^m$ and $V^n$ composed via ordinary relational composition\footnote{
We take the objects to be the natural numbers, $m$, rather than the sets $V^m$ for technical convenience to avoid having the category collapse when $V = \{\}$.
}.
We represent the category in Z by defining its set of morphisms.
A morphism is given as labelled triple whose components give the domain ($d$), codomain ($c$), and the relation ($r$).

πZ
‹ €Rel›[V] ¶ ﬁ{m, n : Ó ∑ {R : V^m ™ V^n∑ (d ¶ m, c ¶ n, r ¶ R)}}
∞

The composition of morphisms that makes $Rel[V]$ into a category is the ``horizontal'' composition defined below.

ù[V]úúúúúúúúúúú
‹ €HCompose› : Rel[V] ∏ Rel[V] ﬂ Rel[V]
˜¸¸¸¸¸¸
‹ dom HCompose = {R, S : Rel[V] | R.c = S.d} ;
‹ µR, S : Rel[V] | R.c = S.d ∑
‹	HCompose(R, S) = (d ¶ R.d, c ¶ S.c, r ¶ R.r ª S.r)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸


The following function gives the identity arrows in the category.

ù[V]úúúúúúúúúúú
‹ €HId› : Ó ≠ Rel[V]
˜¸¸¸¸¸¸
‹ µ m : Ó ∑ HId m = (d ¶ m, c ¶ m, r ¶ id(V^m))
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

The category becomes a monoidal category under a product given by addition on objects and by the following ``vertical composition'' on morphisms.

 
ù[V]úúúúúúúúúúú
‹ €VCompose› : Rel[V] ∏ Rel[V] ≠ Rel[V]
˜¸¸¸¸¸¸
‹ µR, S : Rel[V] ∑
‹	VCompose(R, S) = (d ¶ R.d + S.d, c ¶ R.c + S.c,
‹		r ¶ {a, b, c, d : seq V | (a, c) ç R.r ± (b, d) ç S.r∑ (a Î b, c Î d)})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

Finally, we get a traced monoidal category by defining the following operator that corresponds to adding $k$ feedback loops into a diagram.
 
ù[V]úúúúúúúúúúú
‹ €Trace› : (Ó ∏ Ó ∏ Ó) ≠ Rel[V] ﬂ Rel[V]
˜¸¸¸¸¸¸
‹ µm, n, k : Ó∑
‹ dom (Trace(m, n, k)) = {R : Rel[V] | R.d = m + k ± R.c = n + k} ;
‹ µm, n, k : Ó; R : Rel[V] | R.d = m + k ± R.c = n + k ∑
‹	Trace (m, n, k) R = (d ¶ m, c ¶ n,
‹		r ¶ {a: V^m; b : V^n | ∂c:V^k∑ (a Î c, b Î c) ç R.r})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

To use the relation category, we will generally need to know something about the value domain, $V$.
However, we can describe some generic constructions that just impose equational constraints.
The first of these is the operator that makes the monoidal category into a symmetric monoidal category:

ù[V]úúúúúúúúúúú
‹ €Switch› : Ó ∏ Ó ≠ Rel[V]
˜¸¸¸¸¸¸
‹ µm, n : Ó∑
‹	Switch(m, n) = (d ¶ m + n, c ¶ n + m,
‹		r ¶ {a : V^m; b : V^n ∑ (a Î b, b Î a)})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

However, we can define at least one generic construction corresponding to patching inputs to outputs according to a wiring diagram (given as a relation between input port numbers and output port numbers):


ù[V]úúúúúúúúúúú
‹ €Patch› : Ó ∏ Ó ∏ (Ó ™ Ó) ≠ Rel[V]
˜¸¸¸¸¸¸
‹ µm, n : Ó; d : Ó ™ Ó∑
‹	Patch(m, n, d) = (d ¶ m, c ¶ n,
‹		r ¶ {a : V^m; b : V^n | µi : 1..m; j : 1..n |(i, j) ç d∑ b j = a i})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

\section{SIGNAL FLOW GRAPHS}

A {\em signal} will be a real-valued function of a real variable.

πZ
‹ €SIGNAL› ¶ Ø ≠ Ø
∞

The category of signal flow graphs is then the relational category with the value domain given by signals.


πZ
‹ €SFG› ¶ Rel[SIGNAL]
∞

We instantiate the notions of predicates, pre- post-conditions
and specifications from \cite{LEMMA1/ZED/WRK069} so that we can use them to express properties of signals:

πZ
‹ €S_PRED› ¶ PRED[SIGNAL]
∞
πZ
‹ €S_PRE_COND› ¶ PRE_COND[SIGNAL]
∞
πZ
‹ €S_POST_COND› ¶ POST_COND[SIGNAL, SIGNAL]
∞
πZ
‹ €S_SPEC› ¶ SPEC[SIGNAL, SIGNAL]
∞
We now have a notion of diagram which is in quite close analogy with the notion of imperative program considered in \cite{LEMMA1/ZED/WRK070}.

πZ
‹ €DIAGRAM› ::=
‹	€Atom› (SFG)
‹ |	€Seq› (DIAGRAM ∏ DIAGRAM)
‹ |	€Par› (DIAGRAM ∏ DIAGRAM)
‹ |	€Loop› (DIAGRAM ∏ Ó)
‹ |	€Spec› (S_SPEC ∏ DIAGRAM)
∞
 
ù[V]úúúúúúúúúúú
‹ €Feedback› : Rel[V] ∏ Ó ﬂ Rel[V]
˜¸¸¸¸¸¸
‹ dom Feedback = {R : Rel[V]; k : Ó | ∂m, n : Ó∑R.d = m + k ± R.c = n + k} ;
‹ µR : Rel[V]; k, m, n : Ó | R.d = m + k ± R.c = n + k ∑
‹	Feedback(R, k) = Trace(m, n, k) R
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

πZAX
‹ €semantics› : DIAGRAM ≠ SFG
˜¸¸¸¸¸¸
‹ µt : SFG; dâ1, dâ2 : DIAGRAM; n : Ó; s : S_SPEC∑
‹	semantics (Atom t) = t
‹ ±	semantics (Seq(dâ1, dâ2)) = HCompose(semantics dâ1, semantics dâ2)
‹ ±	semantics (Par(dâ1, dâ2)) = VCompose(semantics dâ1, semantics dâ2)
‹ ±	semantics (Loop(dâ1, n)) = Feedback(semantics dâ1, n)
‹ ±	semantics (Spec(s, dâ1)) = semantics dâ1
∞

\bibliographystyle{fmu}
\bibliography{fmu}

\newpage
\appendix
% \newpage
\section{WEAKEST PRE-CONDITIONS FOR RELATIONS}

In \cite{LEMMA1/ZED/WRK070}, we give an account of precondition calculation for a small programming language.
In this note, we will be exploring weakest precondition calculation in a less familiar situation.
It is therefore helpful to formalise the abstract concept.
In this section we do this (implicitly) in the category of arbitrary relations in Z.
This category becomes a monoidal category under a ``vertical'' composition operator and then becomes a traced monoidal category under a trace operator defined by existential quantification.
We show how the weakest pre-condition behaves with respect to these operators.

The simplest notion of weakest precondition pulls a simple predicate back through a relation.
Representing predicates as sets, this notion is defined as follows:

ù[ Y, Z ]úúúúúúúúúúú
‹ €WPS› : (Y ™ Z) ∏ Z ≠ Y
˜¸¸¸¸¸¸
‹ µS : Y ™ Z; C : Z∑
‹	WPS(S, C) = {y : Y | S ®{y}© Ä C}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸


The following theorem shows that our explicit definition for $WP(S, C)$ is indeed the weakests $R$ such that $R\;ª\;S \subseteq P$.

πZ
‹ wps_correct_thm ?Ù
‹	µS : É; C : É∑ S®WPS(S, C)© Ä C;
‹	µS : É; B : É; C : É | S®B© Ä C ∑ B Ä WPS(S, C)
∞
(Note: É is defined in the {\Product} Z library to be the generic object which gives the universe of all elements of a type. In declarations, it gives a similar effect to a type variable in HOL or ML).

The weakest pre-condition of a conjunction (intersection) is a conjunction:

πZ
‹ wps_cap_thm ?Ù
‹	µR : É; B, C : É∑ WPS(R, B ° C) = WPS(R, B) ° WPS(R, C)
∞
The weakest pre-condition for a relational composition is given by an appropriate form of functional composition.

πZ
‹ wps_comp_thm ?Ù
‹	µR : É; S : É; A : É∑ WPS(R ª S, A) = WPS(R, WPS(S, A))
∞

The following theorem may be helpful in understanding some of the
results which follow.
It shows that any point not in the domain of the relation $S$ satisfies any weakest pre-condition through $S$.


πZ
‹ wps_compl_dom_thm ?Ù
‹	µS : É; C : É ∑
‹		É \ dom S Ä WPS(S, C)
∞

(Here É in
=INLINEFT
É \ dom S
=TEX
\ is acting as the total relation at the appropriate type).

We now define the ``vertical'' composition of two arbitrary relations.

ù[ X, Y, V, W ]úúúúúúúúúúú
‹ €_**_› : (X ™ Y) ∏ (V ™ W) ≠ (X ∏ V ™ Y ∏ W)
˜¸¸¸¸¸¸
‹ µR : X ™ Y; S : V ™ W∑
‹	R ** S =
‹	{x : X; y : Y; v : V; w : W
‹	| (x, y) ç R ± (v, w) ç S ∑ ( (x, v), (y, w) )}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

The weakest pre-condition through a vertical composite is as follows:

πZ
‹ wps_prod_thm ?Ù
‹	µR : É; S : É; B : É; C : É ∑
‹		WPS(R ** S, B ∏ C) =
‹		(WPS(R, B) ∏ WPS(S, C)) ¿ (É \ (dom R ∏ dom S))
∞

ù[ X, Y, V ]úúúúúúúúúúú
‹ €Projâ∂› : (X ∏ V ™ Y ∏ V) ≠ (X ™ Y)
˜¸¸¸¸¸¸
‹ µR : (X ∏ V ™ Y ∏ V)∑
‹	Projâ∂ R =
‹	{x : X; y : Y | ∂v : V∑ ((x, v), (y, v)) ç R}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

πZ
‹ wps_proj_exists_thm ?Ù
‹	µR : É;  C : É ∑
‹		WPS(Projâ∂ R, C) =
‹		{x: É | µv:É∑ (x, v) ç WPS(R ° (É ** (id _)), C ∏ É)∑ x}
∞

As noted in \cite{LEMMA1/ZED/WRK070}, a more general notion of weakest precondition calculation deals with relations.
In general, if $S$ and $P$ are binary relations,
we want to specify  $WP(S, P)$ so that it is the weakest (i.e., largest) relation $R$ such that $R\;ª\;S \subseteq P$.
We use an explicit formula for $WP$ (cf. the clause for atoms in the function {\em prec\_calc} in \cite{LEMMA1/ZED/WRK070}).

ù[ X, Y, Z ]úúúúúúúúúúú
‹ €WP› : (Y ™ Z) ∏ (X ™ Z) ≠ (X ™ Y)
˜¸¸¸¸¸¸
‹ µS : Y ™ Z; P : X ™ Z∑
‹	WP(S, P) = {x : X; y : Y | S ®{y}© Ä P®{x}©}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

The following theorem shows that our explicit definition for $WP(S, P)$ is indeed the weakests $R$ such that $R\;ª\;S \subseteq P$.

πZ
‹ wp_correct_thm ?Ù
‹	µS : É; P : É∑ WP(S, P) ª S Ä P;
‹	µR : É; S : É; P : É | R ª S Ä P ∑ R Ä WP(S, P)
∞

The relational formulation of weakest precondition may be defined in terms of the set formulation:

πZ
‹ wp_wps_thm ?Ù
‹	µS : É; P : É∑ WP(S, P) = {x : É; y : É | y ç WPS(S, P®{x}©)}
∞

From the above, one can calculate relational weakest pre-conditions for intersections, compositions etc. using the
corresponding theorems for predicate weakest pre-conditions.

\newpage
\section{SOME CATEGORY THEORY}
A category with the set of objects $O$ and the set of arrows $A$ is represented by a member of the following generic schema,
in which we agree to write composition in the category left to right.


πZ
‹ function 40 leftassoc  _ ªâc _, _ ´âo _, _ ´âa_
∞


ˇ €CAT›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ _ ªâc _ : A ∏ A ﬂ A ;
‹ domâc, codâc : A ≠ O ;
‹ idâc : O ≠ A
˜¸¸¸¸¸¸
‹ dom (_ ªâc _) = {f, g : A | codâc f = domâc g} ;
‹ µf, g, h : A | codâc f = domâc g ± codâc g = domâc h ∑
‹	(f ªâc g) ªâc h = f ªâc (g ªâc h) ;
‹ µf, g :  A | codâc f = domâc g ∑
‹	domâc (f ªâc g) = domâc f ± codâc (f ªâc g) = codâc g ;
‹ µ X : O ∑
‹	domâc (idâc X) = codâc (idâc X) = X ;
‹ µ f : A ∑
‹	idâc(domâc f) ªâc f = f ªâc idâc(codâc f) = f
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

We can now state the theorem that $Rel[V]$ with the appropriate structure is indeed a category.

πZ
‹ €RelCat› [V] ¶
‹	(_ ªâc _ ¶ HCompose[V],
‹	domâc ¶ (ÃR:Rel[V]∑ R.d),
‹	codâc ¶ (ÃR:Rel[V]∑ R.c),
‹	idâc ¶ HId[V])
∞
πZ
‹ rel_cat_thm ?Ù [V](RelCat[V] ç CAT[Ó, Rel[V]])
∞


A (strict) monoidal category is a category equipped with an associative bifunctor ´ with unit, $e$:
ˇ €MON_CAT›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ CAT[O, A] ;
‹ _ ´âo _ : O ∏ O ≠ O;
‹ _ ´âa _ : A ∏ A ≠ A;
‹ Iâ´ : A
˜¸¸¸¸¸¸
‹ µf, g, h : A∑ (f ´âa g) ´âa h = f ´âa (g ´âa h) ;
‹ µf : A∑ (f ´âa Iâ´) = (Iâ´ ´âa f) = f ;
‹ µ X, Y : O∑ X ´âo Y = domâc (idâc X ´âa idâc Y)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

πZ
‹ €RelMonCat› [V] ¶
‹	(_ ªâc _ ¶ HCompose[V],
‹	domâc ¶ (ÃR:Rel[V]∑ R.d),
‹	codâc ¶ (ÃR:Rel[V]∑ R.c),
‹	idâc ¶ HId[V],
‹	_ ´âo _ ¶ (Ãm, n:Ó∑ m + n),
‹	_ ´âa _ ¶ VCompose[V],
‹	Iâ´ ¶ HId[V](0))
∞

πZ
‹ rel_mon_cat_thm ?Ù [V](RelMonCat[V] ç MON_CAT[Ó, Rel[V]])
∞
A symmetric monoidal category is a monoidal category possessing a symmetry operator providing an isomorphism between
=INLINEFT
X £ Y
=TEX
\ and
=INLINEFT
Y £ X
=TEX
\ for any objects $X$ and $Y$ satisfying a condition that ensures that any diagram involving £ and the symmetry that ought to commute does commute.
ˇ €SYM_MON_CAT›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ MON_CAT[O, A] ;
‹ Sym : O ∏ O ≠ A
˜¸¸¸¸¸¸
‹ µ X, Y : O ∑ domâc(Sym(X, Y)) = X ´âo Y ± codâc(Sym(X, Y)) = Y ´âo  X ;
‹ µ X, Y : O ∑ Sym(X, Y) ªâc Sym(Y, X) = idâc (X ´âo Y) ;
‹ µ X, Y, Z : O ∑
‹	Sym(X ´âo Y, Z) =
‹	(idâc X ´âa Sym(Y, Z)) ªâc (Sym(X, Z) ´âa idâc Y)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
πZ
‹ €RelSymMonCat› [V] ¶
‹	(_ ªâc _ ¶ HCompose[V],
‹	domâc ¶ (ÃR:Rel[V]∑ R.d),
‹	codâc ¶ (ÃR:Rel[V]∑ R.c),
‹	idâc ¶ HId[V],
‹	_ ´âo _ ¶ (Ãm, n:Ó∑ m + n),
‹	_ ´âa _ ¶ VCompose[V],
‹	Iâ´ ¶ HId[V](0),
‹	Sym ¶ Switch[V])
∞

πZ
‹ rel_sym_mon_cat_thm ?Ù [V](RelSymMonCat[V] ç SYM_MON_CAT[Ó, Rel[V]])
∞
We now give the definition of a traced monoidal category in stages.
A traced monoidal category will be a symmetric monoidal category equipped with a trace operator which comprises a partial function from arrows to arrows parameterised by three objects:

ˇ €TRA_MON_CAT_SIG›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ SYM_MON_CAT[O, A] ;
‹ Trc : O ∏ O ∏ O ≠ A ﬂ A
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Our first requirement on the trace operator says that $Trc(X, Y, Z)$ maps arrows  
=INLINEFT
X £ Z ≠  Y £ Z
=TEX
\ to arrows
=INLINEFT
X ≠  Y
=TEX
\ (typically one thinks of the trace operator as taking some kind of fixed point with respect to to the part of an arrow from
=INLINEFT
X £ Z
=TEX
\ to
=INLINEFT
Y £ Z
=TEX
\ that is over $Z$).

ˇ €TRA_MON_CAT_DOM›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ TRA_MON_CAT_SIG[O, A]
˜¸¸¸¸¸¸
‹ µ X, Y, Z : O ∑
‹	dom (Trc(X, Y, Z)) = {f : A | domâc f = X ´âo Z ± codâc f = Y ´âo Z} ;
‹ µ X, Y, Z : O; f : A |
‹	domâc f = X ´âo Z ± codâc f = Y ´âo Z ∑
‹	domâc (Trc(X, Y, Z) f) = X ± codâc (Trc(X, Y, Z) f) = Y
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

The following are the naturality requirements on $Trc(X, Y, Z)$ (Hasegawa call these three properties: naturality in $X$ (or {\em left tightening}), naturality in $Y$ (or {\em right tightening}) and dinaturality in  $Z$ (or {\em sliding})).

ˇ €TRA_MON_CAT_NAT›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ TRA_MON_CAT_SIG[O, A]
˜¸¸¸¸¸¸
‹ µ W, X, Y, Z : O; f, h : A |
‹	domâc f = W ´âo Z ± codâc f = Y ´âo Z ;
‹	domâc h = X ± codâc h = W ∑
‹	Trc(X, Y, Z) ((h ´âa idâc Z) ªâc f) =
‹	h ªâc Trc(W, Y, Z) f ;
‹ µ W, X, Y, Z : O; f, h : A |
‹	domâc f = X ´âo Z ± codâc f = W ´âo Z ;
‹	domâc h = W ± codâc h = Y ∑ (* Y not X! *)
‹	Trc(X, Y, Z) (f ªâc (h ´âa idâc Z)) =
‹	Trc(X, W, Z) f ªâc h; (* in that order! *)
‹ µ W, X, Y, Z : O; f, h : A |
‹	domâc f = X ´âo W ± codâc f = Y ´âo Z ;
‹	domâc h = Z ± codâc h = W ∑
‹	Trc(X, Y, Z) ((idâc X ´âa h) ªâc f) =
‹	Trc(X, Y, W) (f ªâc (idâc Y ´âa h))
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

The following property is called {\em vanishing} by Hasegawa. It captures the idea that taking a fixed point with respect to an identity arrow does nothing and that fixed points over a vertical product
=INLINEFT
W £ Z
=TEX
\ can be taken by taking fixed points over $Z$ then $W$ in turn.

ˇ €TRA_MON_CAT_VAN›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ TRA_MON_CAT_SIG[O, A]
˜¸¸¸¸¸¸
‹ µ X, Y : O; f : A |
‹	domâc f = X  ± codâc f = Y ∑
‹	Trc(X, Y, domâc Iâ´) (f ´âa Iâ´) = f ;
‹ µ X, Y, W, Z : O; f : A |
‹	domâc f = X ´âo W ´âo Z ± codâc f = Y ´âo W ´âo Z ∑
‹	Trc(X, Y, W ´âo Z) f =
‹	Trc(X, Y, W) (Trc(X ´âo W, Y ´âo W, Z) f)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
The following property is called {\em superposing} by Hasegawa.
It says that if products with identity arrows commute with the trace operator.

ˇ €TRA_MON_CAT_SUP›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ TRA_MON_CAT_SIG[O, A]
˜¸¸¸¸¸¸
‹ µ W, X, Y, Z : O; f : A |
‹	domâc f = W ´âo Z ± codâc f = Y ´âo Z ∑
‹	Trc(W ´âo X, W ´âo Y, Z) (idâc W ´âa f) =
‹	idâc W ´âa Trc(X, Y, Z) f
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
The final property is called {\em yanking} by Hasegawa.
It says that the trace of the symmetry arrow from
=INLINEFT
X £ X
=TEX
\ to itself is the identity on $X$.
ˇ €TRA_MON_CAT_YAN›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ TRA_MON_CAT_SIG[O, A]
˜¸¸¸¸¸¸
‹ µ X : O ∑
‹	Trc (X, X, X) (Sym (X, X)) = idâc X
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Finally, we put all these pieces together to complete the definition of a traced monoidal category:
ˇ €TRA_MON_CAT›[O, A] ¸¸¸¸¸¸¸¸¸¸¸
‹ TRA_MON_CAT_SIG[O, A] 
˜¸¸¸¸¸¸
‹ TRA_MON_CAT_DOM[O, A] ;
‹ TRA_MON_CAT_NAT[O, A] ;
‹ TRA_MON_CAT_VAN[O, A] ;
‹ TRA_MON_CAT_SUP[O, A] ;
‹ TRA_MON_CAT_YAN[O, A]
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

πZ
‹ €RelTraMonCat› [V] ¶
‹	(_ ªâc _ ¶ HCompose[V],
‹	domâc ¶ (ÃR:Rel[V]∑ R.d),
‹	codâc ¶ (ÃR:Rel[V]∑ R.c),
‹	idâc ¶ HId[V],
‹	_ ´âo _ ¶ (Ãm, n:Ó∑ m + n),
‹	_ ´âa _ ¶ VCompose[V],
‹	Iâ´ ¶ HId[V](0),
‹	Sym ¶ Switch[V],
‹	Trc ¶ Trace[V])
∞


πZ
‹ rel_tra_mon_cat_thm ?Ù [V](RelTraMonCat[V] ç TRA_MON_CAT[Ó, Rel[V]])
∞
=TEX
\newpage
\appendix
=TEX
{\HOLindexOff\small
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{wrk075.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS BEGIN HERE
%%
%% Comment out next line to include the proofs in the printed document:
\end{document}

\section{Proofs}
=TEX
\ftlinepenalty=999
=SML
val €wps_def› = z_get_specÒWPSÆ;
val €wp_def› = z_get_specÒWPÆ;
val €set_exp_def› = z_get_specÒ(_^_)Æ;
val €rel_prod_def› = z_get_specÒ(_**_)Æ;
val €proj_∂_def› = z_get_specÒProjâ∂Æ;
val €rel_def› = z_get_specÒRel[V]Æ;
val €h_compose_def› = z_get_specÒHComposeÆ;
val €h_id_def› = z_get_specÒHIdÆ;
val €v_compose_def› = z_get_specÒVComposeÆ;
val €trace_def› = z_get_specÒTraceÆ;
val €switch_def› = z_get_specÒSwitchÆ;
val €patch_def› = z_get_specÒPatchÆ;
val €cat_def› = z_get_specÒCATÆ;
val €rel_cat_def› = z_get_specÒRelCatÆ;
val €mon_cat_def› = z_get_specÒMON_CATÆ;
val €rel_mon_cat_def› = z_get_specÒRelMonCatÆ;
val €sym_mon_cat_def› = z_get_specÒSYM_MON_CATÆ;
val €rel_sym_mon_cat_def› = z_get_specÒRelSymMonCatÆ;
val €tra_mon_cat_sig_def› = z_get_specÒTRA_MON_CAT_SIGÆ;
val €tra_mon_cat_dom_def› = z_get_specÒTRA_MON_CAT_DOMÆ;
val €tra_mon_cat_nat_def› = z_get_specÒTRA_MON_CAT_NATÆ;
val €tra_mon_cat_van_def› = z_get_specÒTRA_MON_CAT_VANÆ;
val €tra_mon_cat_sup_def› = z_get_specÒTRA_MON_CAT_SUPÆ;
val €tra_mon_cat_yan_def› = z_get_specÒTRA_MON_CAT_YANÆ;
val €tra_mon_cat_def› = z_get_specÒTRA_MON_CATÆ;
val €rel_tra_mon_cat_def› = z_get_specÒRelTraMonCatÆ;
=TEX
Later proofs use the following prototype implementation of a simple conditional rewriting facility.
The code begins with some derived rules and conversions:
=SML
fun €all_undisch_rule› (thm : THM) : THM = (
	let	val thm1 = undisch_rule thm;
	in	all_undisch_rule thm1
	end
	handle	Fail _ => thm
);
=TEX
The first parameter of the following is what one would need in a  more general conditional rewriter to prevent variable capture problems.
(For the moment, however, we are content to restrict to quantifier free formulae).
=SML
fun €simple_¥_eq_match_conv› (vs : TERM list) (thm : THM) : CONV  = (
	let	val thm1 = all_undisch_rule(all_µ_elim thm);
		val match_conv = simple_eq_match_conv thm1;
		fun captured a_tm = (
			any vs (fn v => v term_mem frees a_tm)
		);
	in	fn tm =>
		let val thm2 = match_conv tm;
		in	if	any (asms thm2) captured
			then	fail "simple_¥_eq_match_conv" 99999 []
			else	thm2 
		end
	end
);
=TEX
The above gives a conversion that will rewrite with an equation appearing as the antecedent of an implication, making the instantiated conditions assumptions of the theorem returned.
=SML
fun €z_cond_eq_conv› (thms : THM list) : CONV = (
	let	val thms1 = map (all_µ_intro o conv_rule z_µ_elim_conv o all_µ_elim) thms;
		val convs = map (simple_¥_eq_match_conv[]) thms1;
	in	FIRST_C convs
	end
);
val €z_cond_rw_conv› : THM list -> CONV = TOP_MAP_C o z_cond_eq_conv;
=TEX
We now give a function which turns a conversion like the above into a tactic by applying the conversion to the conclusion of the goal and then setting any new assumptions generated by the conversions as extra subgoals.
=SML
local
val ¥_¥_±_¥_thm = taut_rule¨µp1 p2 p3∑(p1 ¥ p2 ¥ p3) § (p1 ± p2) ¥ p3Æ;
in
fun €list_disch_rule› ([] : TERM list) (thm : THM) : THM = thm
|   list_disch_rule [t] thm = disch_rule t thm
|   list_disch_rule (t::ts) thm = (
	conv_rule(simple_eq_match_conv ¥_¥_±_¥_thm)
	(disch_rule t (list_disch_rule ts thm))
);
end;
=TEX
=SML
fun €cond_conv_tac› (conv_fun : THM list -> CONV) : THM list -> TACTIC = (
	fn thms =>
	let	fun accept_conv th _ = th;
		val conv = conv_fun thms;
	in	fn g as (hyps, conc) =>
		let	val thm1 = conv conc;
		in	case asms thm1 term_diff hyps of
				[] => conv_tac(accept_conv thm1)
			|	new_asms => (
				let	val thm2 = list_disch_rule new_asms thm1;
					val (hyp, _) = dest_¥(concl thm2);
				in	LEMMA_T hyp
					(fn thm3 => conv_tac(accept_conv (¥_elim thm2 thm3)))
				end
			)
		end	g
	end
);
=TEX
=SML
val €z_cond_rw_tac› : THM list -> TACTIC = REPEAT o cond_conv_tac z_cond_rw_conv;
=TEX
=SML
fun €cond_def_thms› (def_thm : THM) = (
	let	fun not_wanted th = (
			case dest_z_term (concl th) of
				Zµ(_, _, tm) => not(is_eq tm)
			|	_ => true
		);
		val thms = strip_±_rule (all_µ_elim def_thm);
	in	map all_µ_intro (thms drop not_wanted)
	end
);
=TEX
=SML
val €set_exp_rw_thm› = hd(cond_def_thms set_exp_def);
val €h_compose_rw_thm› = hd(cond_def_thms h_compose_def);
val €h_id_rw_thms› = hd(cond_def_thms h_id_def);
val €v_compose_rw_thm› = hd(cond_def_thms v_compose_def);
val €switch_rw_thm› = hd(cond_def_thms switch_def);
val €patch_rw_thm› = hd(cond_def_thms patch_def);
val €trace_rw_thm› = hd(tl(cond_def_thms trace_def));
=TEX
%%%%
%%%%
=SML
set_goal([], ÒµR:É; x : É∑R®{x}© = {z : É | (x, z) ç R}Æ);
a(PC_T1 "z_library_ext" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
a(z_∂_tacÒxÆ THEN asm_rewrite_tac[]);
val €z_image_singleton_thm› = save_pop_thm "z_image_singleton_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ÒµS:É;C: É∑
	WPS (S, C) = {y:É| µz:É∑(y, z) ç S ¥ z ç C}Æ);
a(rewrite_tac[z_image_singleton_thm, z_gen_pred_u_elim wps_def]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €wps_rw_thm› = save_pop_thm "wps_rw_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_correct_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €wps_correct_thm› = save_pop_thm "wps_correct_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_cap_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €wps_cap_thm› = save_pop_thm "wps_cap_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_comp_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €wps_comp_thm› = save_pop_thm "wps_comp_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ÒµC:É∑WPS({}, C) = ÉÆ);
a(rewrite_tac[wps_rw_thm]);
val €wps_empty_thm› = save_pop_thm "wps_empty_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_compl_dom_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €wps_compl_dom_thm› = save_pop_thm "wps_compl_dom_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò
	µR : É; S : É; x1 : É; y1 : É; v1 : É; w1 : É∑
	(∂ x : É; y : É; v : É; w : É
	| (x, y) ç R ± (v, w) ç S
 	∑ (x = x1 ± v = v1) ± y = y1 ± w = w1)
§	(x1, y1) ç R ± (v1, w1) ç S
Æ);
a(PC_T1 "z_library_ext" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
a(z_∂_tacÒ(x ¶ x1, v ¶ v1, y ¶ y1, w ¶ w1)Æ THEN asm_rewrite_tac[]);
val €rel_prod_rw_thm› = save_pop_thm "rel_prod_rw_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ÒµR : É; S : É∑ dom (R ** S) = dom R ∏ dom SÆ);
a(PC_T1 "z_library_ext" rewrite_tac[
	z_gen_pred_u_elim rel_prod_def,
	rel_prod_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
a(z_∂_tacÒ(y, y')Æ THEN asm_rewrite_tac[]);
val €dom_rel_prod_thm› = save_pop_thm "dom_rel_prod_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_prod_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wps_rw_thm,
	rel_prod_rw_thm,
	z_gen_pred_u_elim rel_prod_def]);
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 (ante_tac o z_µ_elim Ò(z, y')Æ));
a(asm_rewrite_tac[] THEN taut_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 4 (ante_tac o z_µ_elim Ò(y, z)Æ));
a(asm_rewrite_tac[] THEN taut_tac);
val €wps_prod_thm› = save_pop_thm "wps_prod_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wps_proj_exists_thm");
a(PC_T1 "z_library_ext" rewrite_tac[
	z_gen_pred_u_elim rel_prod_def,
	wps_rw_thm,
	z_gen_pred_u_elim proj_∂_def]);
a(PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o z_µ_elimÒz.1Æ));
a(DROP_NTH_ASM_T 1 (ante_tac o z_µ_elimÒz.2Æ));
a(conv_tac(ONCE_MAP_C z_tuple_lang_intro_conv));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 2 (fn th => fc_tac[th]));
a(DROP_NTH_ASM_T 1 (ante_tac o list_µ_elim[¨vÆ, ¨vÆ, ¨x1Æ, ¨zÆ]));
a(rewrite_tac[]);
val €wps_proj_exists_thm› = save_pop_thm "wps_proj_exists_thm";
=TEX
%%%%
%%%%
=SML
set_goal([], ÒµS:É;P: É∑
	WP (S, P) = {x:É; y:É| µz:É∑(y, z) ç S ¥ (x, z) ç P}Æ);
a(rewrite_tac[z_image_singleton_thm, z_gen_pred_u_elim wp_def]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €wp_rw_thm› = save_pop_thm "wp_rw_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wp_correct_thm");
a(PC_T1 "z_library_ext" rewrite_tac[wp_rw_thm]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €wp_correct_thm› = save_pop_thm "wp_correct_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "wp_wps_thm");
a(rewrite_tac[z_image_singleton_thm]);
a(PC_T1 "z_library_ext" rewrite_tac[wp_rw_thm, wps_rw_thm]);
val €wp_wps_thm› = save_pop_thm "wp_wps_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V] 
	(Rel[V] = {m, n:Ó; R : É | R ç V^m ™ V^n∑ (d ¶ m, c ¶ n, r ¶ R)})Æ);
a(rewrite_tac[rel_def] THEN REPEAT strip_tac);
a(PC_T "z_sets_ext" strip_tac THEN REPEAT strip_tac
	THEN REPEAT all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(z_∂_tacÒ(m ¶ x2, n ¶ x1, R ¶ x3)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(z_∂_tacÒ{R : V ^ x2 ™ V ^ x1 ∑ (c ¶ x1, d ¶ x2, r ¶ R)}Æ
	THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(z_∂_tacÒ(m ¶ x2, n ¶ x1)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(z_∂_tacÒx3Æ THEN asm_rewrite_tac[]);
val €rel_rw_thm› = save_pop_thm "rel_rw_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V] 
	(µA:É∑A ç Rel[V] § A.c ç Ó ± A.d ç Ó ± A.r ç V^(A.d) ™ V^(A.c))Æ);
a(rewrite_tac[rel_rw_thm] THEN REPEAT strip_tac
	THEN REPEAT all_var_elim_asm_tac1
	THEN_TRY asm_rewrite_tac[]);
a(z_∂_tacÒ(m ¶ A.d, n ¶ A.c, R ¶ A.r)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" asm_rewrite_tac[]);
val €ç_rel_thm› = save_pop_thm "ç_rel_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µf X Y∑
	Ò(Ãm:X∑ ¨f mÆ) ç X ≠ Y § (µx:X ∑ ¨f xÆ ç Y)ÆÆ);
a(PC_T1 "z_fun_ext" prove_tac[]);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
a(all_var_elim_asm_tac1 THEN strip_tac);
val €Ã_ç_≠_thm› = save_pop_thm "Ã_ç_≠_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](µm : Ó∑ HId[V] m ç Rel[V])Æ);
a(REPEAT strip_tac THEN ALL_FC_T rewrite_tac[h_id_def]);
a(asm_rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ÒµA:É∑ id A ç A ™ AÆ,
		ç_rel_thm]);
val €h_id_ç_rel_thm› = save_pop_thm "h_id_ç_rel_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "rel_cat_thm");
a(rewrite_tac[cat_def, rel_cat_def, h_compose_def, h_id_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[
	conv_rule(ONCE_MAP_C ¬_conv)
	(µ_elim¨ÃR∑Ò(R ∫ Rel[V]).dÆÆ Ã_ç_≠_thm)]);
a(z_strip_tac THEN PC_T1 "z_library_ext" rewrite_tac [ç_rel_thm]
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[
	conv_rule(ONCE_MAP_C ¬_conv)
	(µ_elim¨ÃR∑Ò(R ∫ Rel[V]).cÆÆ Ã_ç_≠_thm)]);
a(z_strip_tac THEN PC_T1 "z_library_ext" rewrite_tac [ç_rel_thm]
	THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(PC_T1 "z_library_ext" rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(POP_ASM_T ante_tac THEN conv_tac(ONCE_MAP_C z_¬_conv));
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(REPEAT strip_tac);
a(lemma_tacÒ(f, g) ç dom HCompose[V] ± (g, h) ç dom HCompose[V]Æ
	THEN1  PC_T1 "z_sets_ext" asm_rewrite_tac[h_compose_def]);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆh_compose_def)));
a(ALL_FC_T (MAP_EVERY ante_tac)[z_fun_ç_clauses]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(REPEAT strip_tac THEN lemma_tac Ò
	(c ¶ g.c, d ¶ f.d, r ¶ f.r ª g.r).c = h.d
	± f.c = (c ¶ h.c, d ¶ g.d, r ¶ g.r ª h.r).dÆ
	THEN1 asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
	Òµf, g, h:É∑ f ª g ª h = f ª (g ª h)Æ]);
(* *** Goal "5" *** *)
a(POP_ASM_T ante_tac);
a(conv_tac(LEFT_C(ONCE_MAP_C z_¬_conv)));
a(REPEAT strip_tac);
a(lemma_tacÒ(f, g) ç dom HCompose[V]Æ
	THEN1 PC_T1 "z_sets_ext" asm_rewrite_tac[h_compose_def]);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆh_compose_def)));
a(ALL_FC_T (MAP_EVERY ante_tac)[z_fun_ç_clauses]);
a(strip_tac);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[h_compose_def]);
(* *** Goal "6" *** *)
a(POP_ASM_T ante_tac);
a(conv_tac(LEFT_C(ONCE_MAP_C z_¬_conv)));
a(REPEAT strip_tac);
a(lemma_tacÒ(f, g) ç dom HCompose[V]Æ
	THEN1 PC_T1 "z_sets_ext" asm_rewrite_tac[h_compose_def]);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆh_compose_def)));
a(ALL_FC_T (MAP_EVERY ante_tac)[z_fun_ç_clauses]);
a(strip_tac);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[h_compose_def]);
(* *** Goal "7" *** *)
a(lemma_tacÒHId[V] X ç Rel[V]Æ
	THEN1 ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
a(conv_tac (MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[h_id_def]);
(* *** Goal "8" *** *)
a(lemma_tacÒHId[V] X ç Rel[V]Æ
	THEN1 ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
a(conv_tac (MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[h_id_def]);
(* *** Goal "9" *** *)
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(LEMMA_T Òf.c ç ÓÆ asm_tac THEN REPEAT strip_tac);
a(LEMMA_T Òf.d ç ÓÆ asm_tac THEN REPEAT strip_tac);
a(conv_tac(MAP_C z_¬_conv));
a(lemma_tacÒHId[V] f.d ç Rel[V]
	± HId[V] f.c ç Rel[V]Æ
	THEN1 ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
a(lemma_tacÒ(HId[V] f.d).c = f.d
	± f.c = (HId[V] f.c).dÆ
	THEN1 ALL_FC_T rewrite_tac[h_id_def]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(ALL_FC_T rewrite_tac[h_id_def]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ÒµA:É; B:É; R:É∑ R ç A ™ B ¥
			R ª id B = id A ª R = RÆ]);
(* *** Goal "10" *** *)
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(LEMMA_T Òf.c ç ÓÆ asm_tac THEN REPEAT strip_tac);
a(conv_tac(MAP_C z_¬_conv));
a(lemma_tacÒHId[V] f.c ç Rel[V]Æ
	THEN1 ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
a(lemma_tacÒf.c = (HId[V] f.c).dÆ
	THEN1 ALL_FC_T rewrite_tac[h_id_def]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(ALL_FC_T rewrite_tac[h_id_def]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_rel_ext" prove_rule[]
		ÒµA:É; B:É; R:É∑ R ç A ™ B ¥
			R ª id B = id A ª R = RÆ]);
a(PC_T1 "z_library_ext" rewrite_tac[]);
val €rel_cat_thm› = save_pop_thm "rel_cat_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](V^0 = {ß¢})Æ);
a(REPEAT strip_tac);
a(LEMMA_T Ò0 ç ÓÆ asm_tac THEN1 rewrite_tac[]);
a(PC_T1 "z_predicates" (ALL_FC_T rewrite_tac)[z_gen_pred_u_elim set_exp_def]);
a(PC_T "z_library_ext" strip_tac
	THEN z_strip_tac
	THEN rewrite_tac[z_ß¢_seq_thm]);
a(rewrite_tac[rewrite_rule[]
	(z_µ_elimÒ(X ¶ V, s ¶ x1, n ¶ 0)Æ z_size_seq_thm1)]);
a(rewrite_tac[z_ß¢_thm]);
val €set_exp_0_thm› = save_pop_thm "set_exp_0_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Òµx:É∑ id{x} = {(x, x)}Æ);
a(PC_T1 "z_library_ext" prove_tac[]);
val €id_singleton_thm› = save_pop_thm "id_singleton_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](µf:Rel[V]; x, y: É | (x, y) ç f.r ∑ x ç seq V ± y ç seq V)Æ);
a(REPEAT_UNTIL is_¥ strip_tac);
a(rewrite_tac[ç_rel_thm] THEN REPEAT_UNTIL is_± strip_tac);
a(DROP_NTH_ASM_T 2 ante_tac);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(PC_T1 "z_library_ext" asm_prove_tac[]);
val €rel_seq_thm› = save_pop_thm "rel_seq_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ÒµM, N : Ó∑(Ãm, n:Ó∑ m + n) (M, N) = M + NÆ);
a(PC_T1 "z_predicates" REPEAT strip_tac);
a(LEMMA_TÒ(M, N) ç Ó ∏ ÓÆ asm_tac THEN1 asm_rewrite_tac[]);
a(lemma_tacÒ(Ãm, n:Ó∑ m + n) ç Ó ∏ Ó ≠ ÓÆ);
(* *** Goal "1" *** *)
a(conv_tac(ONCE_MAP_C z_Ã_conv));
a(PC_T1 "z_library_ext" asm_prove_tac[]
	THEN_TRY (all_var_elim_asm_tac1 THEN PC_T1 "z_lin_arith" asm_prove_tac[]));
a(z_∂_tacÒx1 + x2Æ THEN rewrite_tac[]);
a(z_∂_tacÒ(m ¶ x1, n ¶ x2)Æ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_TÒ((M, N), (M + N)) ç (Ãm, n:Ó∑ m + n)Æ asm_tac);
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac);
a(DROP_NTH_ASM_T 3 ante_tac);
a(PC_T1 "z_library_ext" prove_tac[]);
a(z_∂_tacÒ(m ¶ M, n ¶ N)Æ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(ALL_FC_T rewrite_tac[z_fun_app_clauses]);
val €z_plus_Ó_thm› = save_pop_thm "z_plus_Ó_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "rel_mon_cat_thm");
a(rewrite_tac[mon_cat_def, rel_mon_cat_def,
	rewrite_rule[rel_cat_def] rel_cat_thm, v_compose_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_library_ext" prove_tac[]
	THEN_TRY all_var_elim_asm_tac1
	THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(z_∂_tacÒx1 + x2Æ THEN rewrite_tac[]);
a(z_∂_tacÒ(m ¶ x1, n ¶ x2)Æ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_TÒ0 º 0Æ asm_tac THEN1 REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
(* *** Goal "3" *** *)
a(strip_asm_tac (±_left_elim (µ_elim¨VÆv_compose_def)));
a(LEMMA_TÒ(f, g) ç Rel[V] ∏ Rel[V]Æ asm_tac THEN1 REPEAT strip_tac);
a(LEMMA_TÒ(g, h) ç Rel[V] ∏ Rel[V]Æ asm_tac THEN1 REPEAT strip_tac);
a(all_fc_tac[z_fun_ç_clauses]);
a(ALL_FC_T once_rewrite_tac[v_compose_def]);
a(ALL_FC_T rewrite_tac[v_compose_def]);
a(rewrite_tac[z_plus_assoc_thm]);
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.1" *** *)
a(z_∂_tacÒ(a ¶ a', b'' ¶ b' Î b, c ¶ c', d'' ¶ d' Î d)Æ
	THEN asm_rewrite_tac[]);
a(all_fc_tac[z_seq_u_thm]);
a(conv_tac(LEFT_C (PC_C1 "z_sets_ext" rewrite_conv[])));
a(ALL_FC_T1 fc_§_canon asm_rewrite_tac[z_Î_seq_x_thm,
	z_Î_assoc_thm]);
a(z_∂_tacÒ(a ¶ b', b'' ¶ b, c ¶ d', d'' ¶ d)Æ
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "3.2" *** *)
a(z_∂_tacÒ(a'' ¶ a Î a', b ¶ b', c'' ¶ c Î c', d ¶ d')Æ
	THEN asm_rewrite_tac[]);
a(all_fc_tac[z_seq_u_thm]);
a(conv_tac(LEFT_C (PC_C1 "z_sets_ext" rewrite_conv[])));
a(ALL_FC_T1 fc_§_canon asm_rewrite_tac[z_Î_seq_x_thm,
	z_Î_assoc_thm]);
a(z_∂_tacÒ(a'' ¶ a, b ¶ a', c'' ¶ c, d ¶ c')Æ
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(LEMMA_TÒ 0 º 0Æ asm_tac THEN1 REPEAT strip_tac);
a(lemma_tacÒHId[V] 0 ç Rel[V]Æ
	THEN1 ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
a(LEMMA_TÒ(f, HId[V]0) ç Rel[V] ∏ Rel[V]Æ asm_tac
	THEN1 REPEAT strip_tac);
a(LEMMA_TÒ(HId[V]0, f) ç Rel[V] ∏ Rel[V]Æ asm_tac
	THEN1 REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[v_compose_def]);
a(ALL_FC_T rewrite_tac[h_id_def]);
a(rewrite_tac[set_exp_0_thm, id_singleton_thm]);
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "4.1" *** *)
a(z_∂_tacÒ(a' ¶ ß¢, b ¶ a, c' ¶ ß¢, d ¶ c)Æ
	THEN asm_rewrite_tac[]);
a(conv_tac(LEFT_C (PC_C1 "z_sets_ext" rewrite_conv[])));
a(asm_rewrite_tac[z_ß¢_seq_thm]);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_Î_ß¢_thm, z_ß¢_Î_thm]);
(* *** Goal "4.2" *** *)
a(z_∂_tacÒ(a ¶ b, b' ¶ ß¢, c ¶ d, d' ¶ ß¢)Æ
	THEN asm_rewrite_tac[]);
a(conv_tac(LEFT_C (PC_C1 "z_sets_ext" rewrite_conv[])));
a(asm_rewrite_tac[z_ß¢_seq_thm]);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_Î_ß¢_thm, z_ß¢_Î_thm]);
(* *** Goal "5" *** *)
a(LEMMA_TÒ 0 º 0Æ asm_tac THEN1 REPEAT strip_tac);
a(lemma_tacÒHId[V] 0 ç Rel[V]Æ
	THEN1 ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
a(LEMMA_TÒ(HId[V]0, f) ç Rel[V] ∏ Rel[V]Æ asm_tac
	THEN1 REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[v_compose_def]);
a(ALL_FC_T rewrite_tac[h_id_def]);
a(rewrite_tac[set_exp_0_thm, id_singleton_thm]);
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac);
a(PC_T "z_library_ext" strip_tac THEN REPEAT strip_tac
	THEN1 all_var_elim_asm_tac1);
(* *** Goal "5.1" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T asm_rewrite_tac[z_Î_ß¢_thm, z_ß¢_Î_thm]);
(* *** Goal "5.2" *** *)
a(z_∂_tacÒ(a ¶ ß¢, b ¶ x1, c ¶ ß¢, d ¶ x2)Æ
	THEN asm_rewrite_tac[]);
a(conv_tac(LEFT_C (PC_C1 "z_sets_ext" rewrite_conv[])));
a(asm_rewrite_tac[z_ß¢_seq_thm]);
a(all_fc_tac[rel_seq_thm]);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T asm_rewrite_tac[z_Î_ß¢_thm, z_ß¢_Î_thm]);
(* *** Goal "6" *** *)
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm]);
a(lemma_tacÒHId[V] X ç Rel[V] ± HId[V] Y ç Rel[V]Æ
	THEN1 ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
a(LEMMA_TÒ(HId[V] X, HId[V] Y) ç Rel[V] ∏ Rel[V]Æ asm_tac
	THEN1 REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆv_compose_def)));
a(all_fc_tac[z_fun_ç_clauses]);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[v_compose_def]);
a(ALL_FC_T rewrite_tac[h_id_def]);
val €rel_mon_cat_thm› = save_pop_thm "rel_mon_cat_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](µm, n : Ó∑ µa : V^m; b : V^n∑ a Î b ç V^(m+n))Æ);
a(REPEAT strip_tac);
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(lemma_tacÒ0 º m + nÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T1 fc_§_canon asm_rewrite_tac[z_Î_seq_x_thm]);
(* *** Goal "2" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_size_Î_thm]);
val €Î_set_exp_thm› = save_pop_thm "Î_set_exp_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], ¨µV m n a b∑ Ò
	m ç Ó ± n ç Ó ± a ç V^m ± b ç V^n
¥	a Î b ç V^(m+n)ÆÆ);
a(REPEAT strip_tac THEN all_fc_tac[Î_set_exp_thm]);
val €Î_set_exp_bc_thm› = save_pop_thm "Î_set_exp_bc_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[X](
	µs : seq X ∑ s = ß¢ ≤
	(∂s1 : seq X; x : X∑ s = s1 Î ßx¢))Æ);
a(REPEAT_UNTIL is_≤ strip_tac);
a(z_seq_induction_tacÒsÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(z_∂_tacÒ(s1¶s, x'¶x)Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(z_∂_tacÒ(s1¶s, x'¶x)Æ THEN asm_rewrite_tac[]);
val €z_seq_cases_thm1› = save_pop_thm "z_seq_cases_thm1";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[X](
	µs : seq X | #s = 0 ∑ s = ß¢;
	µs : seq X; i : Ó | #s = i + 1 ∑ ∂s1 : seq X; x : X∑ #s1 = i ± s = s1 Î ßx¢)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(strip_asm_tac(z_µ_elimÒsÆ z_seq_cases_thm));
a(all_var_elim_asm_tac1);
a(i_contr_tac THEN swap_nth_asm_concl_tac 3);
a(lemma_tacÒßx¢ ç (seq_)Æ THEN1 rewrite_tac[z_singleton_seq_thm]);
a(ALL_FC_T rewrite_tac[z_size_Î_thm]);
a(rewrite_tac[z_size_singleton_seq_thm]);
a(lemma_tacÒ#s1 ç ÓÆ THEN1 ALL_FC_T rewrite_tac[z_size_seq_Ó_thm]);
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tacÒ≥s = ß¢Æ
	THEN1 (swap_nth_asm_concl_tac 1
		THEN asm_rewrite_tac[z_size_seqd_thm]
		THEN PC_T1 "z_lin_arith" asm_prove_tac[]));
a(all_fc_tac[z_seq_cases_thm1]);
a(z_∂_tacÒ(s1 ¶ s1, x ¶ x)Æ THEN asm_rewrite_tac[]);
a(swap_nth_asm_concl_tac 5 THEN all_var_elim_asm_tac1);
a(lemma_tacÒßx¢ ç (seq_)Æ THEN1 rewrite_tac[z_singleton_seq_thm]);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_size_Î_thm]);
a(asm_rewrite_tac[z_size_singleton_seq_thm]);
val €z_size_seq_cases_thm› = save_pop_thm "z_size_seq_cases_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Òµs1, t1, s2, t2 : (seq _) |
	#s2 = #t2 ± s1 Î s2 = t1 Î t2 ∑ s1 = t1 ± s2 = t2Æ);
a(REPEAT_UNTIL is_± strip_tac);
a(lemma_tacÒ∂m:Ó∑#t2 = mÆ THEN1
	(z_∂_tacÒ#t2Æ THEN REPEAT strip_tac
		THEN all_fc_tac[z_size_seq_Ó_thm]));
a(LIST_DROP_NTH_ASM_T [1, 3, 4, 5, 6, 7, 8] (MAP_EVERY ante_tac));
a(z_intro_µ_tacÒ(s1¶s1, s2¶s2, t1¶t1, t2¶t2)Æ);
a(z_º_induction_tac ÒmÆ);
(* *** Goal "1" *** *)
a(REPEAT_UNTIL is_± strip_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
a(strip_tac);
a(all_fc_tac[z_size_seq_cases_thm] THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 2 ante_tac);
a(ALL_FC_T rewrite_tac[z_Î_ß¢_thm]);
(* *** Goal "2" *** *)
a(REPEAT_UNTIL is_± strip_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
a(strip_tac);
a(all_fc_tac[z_size_seq_cases_thm] THEN all_var_elim_asm_tac1);
a(rename_tac[(Òs1'Æ, "s2"), (Òs1''Æ, "t2")]
	THEN DROP_NTH_ASM_T 6 ante_tac);
a(lemma_tacÒßx¢ ç (seq_) ± ßx'¢ ç (seq_)Æ THEN1 rewrite_tac[z_singleton_seq_thm]);
a(ALL_FC_T rewrite_tac[z_Î_assoc_thm1]);
a(lemma_tacÒs1 Î s2 ç (seq_) ± t1 Î t2 ç (seq_)Æ
	THEN1 ALL_FC_T1 fc_§_canon asm_rewrite_tac[z_Î_seq_x_thm]);
a(ALL_FC_T1 fc_§_canon rewrite_tac[z_Î_one_one_thm]);
a(strip_tac THEN asm_rewrite_tac[]);
a(lemma_tacÒ#s2 = #t2Æ THEN1 asm_rewrite_tac[]);
a(z_spec_nth_asm_tac 17 Ò(s1'¶s1, s2'¶s2, t1'¶t1, t2'¶t2)Æ);
a(REPEAT strip_tac);
val €z_Î_one_one_thm1› = save_pop_thm "z_Î_one_one_thm1";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[X](µs : seq X; m, n : Ó | #s = m + n ∑
	∂s1, s2 : seq X ∑ #s1 = m ± #s2 = n ± s = s1 Î s2)Æ);
a(REPEAT strip_tac);
a(LIST_DROP_NTH_ASM_T [1, 3, 4] (MAP_EVERY ante_tac));
a(z_intro_µ_tacÒ(s¶s, m¶m)Æ);
a(z_º_induction_tac ÒnÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[] THEN REPEAT strip_tac);
a(z_∂_tacÒ(s1¶s, s2¶ß¢)Æ THEN asm_rewrite_tac[z_size_seqd_thm]);
a(ALL_FC_T rewrite_tac[z_Î_ß¢_thm] THEN REPEAT strip_tac);
a(rewrite_tac[z_ß¢_seq_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[pc_rule1 "z_lin_arith" prove_rule[]
	Òµn:É∑n + (i + 1) = (n + i) + 1Æ]
	THEN REPEAT strip_tac);
a(lemma_tacÒ0 º n + iÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(all_fc_tac[z_size_seq_cases_thm]);
a(LIST_DROP_NTH_ASM_T [9] all_fc_tac);
a(z_∂_tacÒ(s1¶s1', s2¶s2 Î ßx¢)Æ);
a(lemma_tacÒßx¢ ç (seq _)Æ THEN1 rewrite_tac[z_singleton_seq_thm]);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T asm_rewrite_tac[z_size_Î_thm, z_Î_assoc_thm]);
a(rewrite_tac[z_size_seqd_thm] THEN REPEAT strip_tac);
a(rename_tac[(Òs2Æ, "ss2")]
	THEN ALL_FC_T1 fc_§_canon asm_rewrite_tac[z_Î_seq_x_thm]);
a(asm_rewrite_tac[z_singleton_seq_x_thm]);
val €z_Î_onto_thm› = save_pop_thm "z_Î_onto_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](µm, n : Ó∑
	HCompose[V] (Switch[V] (m, n), Switch[V] (n, m)) =
	(c ¶ m + n, d ¶ m + n, r ¶ id (V ^ (m + n))))Æ);
a(REPEAT strip_tac THEN
	rename_tac[(¨m:˙Æ, "M"), (¨n:˙Æ, "N")]);
a(LEMMA_TÒ(M, N) ç Ó ∏ ÓÆ asm_tac THEN1 REPEAT strip_tac);
a(LEMMA_TÒ(N, M) ç Ó ∏ ÓÆ asm_tac THEN1 REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆswitch_def)));
a(all_fc_tac[z_fun_ç_clauses]);
a(lemma_tacÒ(Switch[V] (M, N)).c = (Switch[V] (N, M)).dÆ
	THEN1 ALL_FC_T rewrite_tac[switch_def]);
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(ALL_FC_T rewrite_tac[switch_def]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(REPEAT_UNTIL is_§ strip_tac);
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(all_fc_tac[Î_set_exp_thm]);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T [2, 3, 4, 5] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_Î_one_one_thm1]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac);
a(lemma_tacÒ0 º M + NÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT strip_tac);
a(all_fc_tac[z_Î_onto_thm]);
a(z_∂_tacÒs2 Î s1Æ THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(z_∂_tacÒ(a ¶ s1, b ¶ s2)Æ THEN asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(z_∂_tacÒ(a ¶ s2, b ¶ s1)Æ THEN asm_rewrite_tac[]);
val €switch_switch_thm› = save_pop_thm "switch_switch_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](µm, n, k  : Ó∑
	Switch[V] (m + n, k) =
	HCompose[V] (
		VCompose[V](HId[V] m, Switch[V] (n, k)),
		VCompose[V] (Switch[V] (m, k), HId[V] n))
)Æ);
a(REPEAT strip_tac THEN
	rename_tac[(¨m:˙Æ, "X"), (¨n:˙Æ, "Y"), (¨k:˙Æ, "Z")]);
a(LEMMA_TÒX ç Ó ± Y ç ÓÆ (±_THEN asm_tac) THEN1 REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆswitch_def)));
a(lemma_tacÒX + Y ç ÓÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(LEMMA_TÒ(X + Y, Z) ç Ó ∏ ÓÆ asm_tac THEN1 REPEAT strip_tac);
a(LEMMA_TÒ(Y, Z) ç Ó ∏ ÓÆ asm_tac THEN1 REPEAT strip_tac);
a(LEMMA_TÒ(X, Z) ç Ó ∏ ÓÆ asm_tac THEN1 REPEAT strip_tac);
a(all_fc_tac[z_fun_ç_clauses]);
a(DROP_NTH_ASM_T 8 discard_tac);
a(lemma_tacÒHId[V] X ç Rel[V]
	± HId[V] Y ç Rel[V]Æ
	THEN1 ALL_FC_T rewrite_tac[h_id_ç_rel_thm]);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆv_compose_def)));
a(LEMMA_TÒ(HId[V] X, Switch[V] (Y, Z)) ç Rel[V] ∏ Rel[V]Æ asm_tac THEN1 REPEAT strip_tac);
a(LEMMA_TÒ(Switch[V] (X, Z), HId[V] Y) ç Rel[V] ∏ Rel[V]Æ asm_tac THEN1 REPEAT strip_tac);
a(all_fc_tac[z_fun_ç_clauses]);
a(LEMMA_TÒ(VCompose[V] (HId[V] X, Switch[V] (Y, Z))).c =
	(VCompose[V] (Switch[V] (X, Z), HId[V] Y)).dÆ asm_tac THEN1 
	(ALL_FC_T rewrite_tac[v_compose_def]
		THEN ALL_FC_T rewrite_tac[h_id_def, switch_def]
		THEN PC_T1 "z_lin_arith" prove_tac[]));
a(ALL_FC_T rewrite_tac[h_compose_def]);
a(ALL_FC_T rewrite_tac[v_compose_def]);
a(ALL_FC_T rewrite_tac[switch_def, h_id_def]);
a(REPEAT strip_tac
	THEN1 PC_T1 "z_lin_arith" prove_tac[]
	THEN1 PC_T1 "z_lin_arith" prove_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN rewrite_tac[z_id_def]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(LIST_DROP_NTH_ASM_T (interval 1 14) discard_tac);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def] THEN REPEAT strip_tac);
a(all_fc_tac[z_Î_onto_thm]);
a(rename_tac[(Òs1Æ, "A"), (Òs2Æ, "B"), (ÒbÆ, "C")]
	THEN all_var_elim_asm_tac1);
a(z_∂_tacÒ(A Î C) Î BÆ THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(z_∂_tacÒ(a' ¶ A, b' ¶ B Î C, c ¶ A, d ¶ C Î B)Æ);
a(conv_tac(LEFT_C(PC_C1 "z_sets_ext" rewrite_conv[])));
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T1 fc_§_canon asm_rewrite_tac[z_Î_seq_x_thm, z_Î_assoc_thm]);
a(REPEAT strip_tac);
(* *** Goal "1.1.1" *** *)
a(z_∂_tacÒ(x ¶ A)Æ THEN REPEAT strip_tac);
(* *** Goal "1.1.2" *** *)
a(z_∂_tacÒ(a'' ¶ B, b'' ¶ C)Æ THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(z_∂_tacÒ(a' ¶ A Î C, b' ¶ B, c ¶ C Î A, d ¶ B)Æ);
a(conv_tac(LEFT_C(PC_C1 "z_sets_ext" rewrite_conv[])));
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T1 fc_§_canon asm_rewrite_tac[z_Î_seq_x_thm, z_Î_assoc_thm]);
a(REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(z_∂_tacÒ(a'' ¶ A, C' ¶ C)Æ THEN REPEAT strip_tac);
(* *** Goal "1.2.2" *** *)
a(z_∂_tacÒ(x ¶ B)Æ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LIST_DROP_NTH_ASM_T [1, 2, 3, 4, 8, 9, 10] (MAP_EVERY ante_tac));
a(LIST_DROP_NTH_ASM_T (22::23::interval 1 20) discard_tac);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN REPEAT_N 6 strip_tac);
a(all_var_elim_asm_tac1);
a(all_fc_tac[z_seq_u_thm]);
a(ALL_FC_T rewrite_tac[z_Î_assoc_thm1] THEN strip_tac);
a(lemma_tacÒa''' Î b''' ç (seq _) ± c Î b' ç (seq _)Æ
	THEN1 ALL_FC_T rewrite_tac[z_Î_ç_seq_thm]);
a(LIST_DROP_NTH_ASM_T (interval 1 22 diff [1, 2, 3, 5, 9, 10])
	(fn ths=> 
		all_fc_tac[z_Î_one_one_thm1]
	THEN MAP_EVERY asm_tac ths));
a(LIST_DROP_NTH_ASM_T (interval 1 24 diff [11, 13, 14, 15, 16, 18])
	(fn ths=> 
		all_fc_tac[z_Î_one_one_thm1]
	THEN MAP_EVERY asm_tac ths));
a(all_var_elim_asm_tac1);
a(z_∂_tacÒ(a ¶ c Î a', b ¶ b')Æ
	THEN ALL_FC_T1
		fc_§_canon asm_rewrite_tac[
			z_Î_assoc_thm, z_size_Î_thm, z_Î_seq_x_thm]);
val €switch_v_compose_thm› = save_pop_thm "switch_v_compose_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], get_conjecture"-" "rel_sym_mon_cat_thm");
a(rewrite_tac[sym_mon_cat_def,
	rel_sym_mon_cat_def,
	rewrite_rule[rel_mon_cat_def] rel_mon_cat_thm,
	switch_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm]);
a(LEMMA_TÒ(X, Y) ç Ó ∏ ÓÆ asm_tac THEN1 REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆswitch_def)));
a(all_fc_tac[z_fun_ç_clauses]);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[switch_def]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm]);
a(LEMMA_TÒ(X, Y) ç Ó ∏ ÓÆ asm_tac THEN1 REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆswitch_def)));
a(all_fc_tac[z_fun_ç_clauses]);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[switch_def]);
(* *** Goal "3" *** *)
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm, switch_switch_thm]);
a(lemma_tacÒX + Y ç ÓÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[h_id_def]);
(* *** Goal "4" *** *)
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm, switch_v_compose_thm]);
val €rel_sym_mon_cat_thm› = save_pop_thm "rel_sym_mon_cat_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](RelTraMonCat[V] ç TRA_MON_CAT_SIG[Ó, Rel[V]])Æ);
a(rewrite_tac[rel_tra_mon_cat_def,
	rewrite_rule[rel_sym_mon_cat_def]
		rel_sym_mon_cat_thm,
	tra_mon_cat_sig_def,
	trace_def]);
val €rel_tra_mon_cat_sig_thm› = save_pop_thm "rel_tra_mon_cat_sig_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](RelTraMonCat[V] ç TRA_MON_CAT_DOM[Ó, Rel[V]])Æ);
a(rewrite_tac[tra_mon_cat_dom_def,
	rel_tra_mon_cat_def,
	rewrite_rule[rel_tra_mon_cat_def]
		rel_tra_mon_cat_sig_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[trace_def]);
a(PC_T "z_library_ext" strip_tac
	THEN REPEAT_UNTIL is_§ strip_tac);
a(rewrite_tac[]);
a(cases_tacÒ(c ¶ x1, d ¶ x2, r ¶ x3) ç Rel[V]Æ
	THEN asm_rewrite_tac[]);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm]);
(* *** Goal "2" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm]);
a(STRIP_T (strip_asm_tac o conv_rule(ONCE_MAP_C z_¬_conv)));
a(STRIP_T (strip_asm_tac o conv_rule(ONCE_MAP_C z_¬_conv)));
a(lemma_tacÒf ç dom (Trace[V](X, Y, Z))Æ
	THEN1 ALL_FC_T asm_rewrite_tac[trace_def]);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆtrace_def)));
a(LEMMA_TÒ(X, Y, Z) ç Ó ∏ Ó ∏ ÓÆ asm_tac THEN REPEAT strip_tac);
a(all_fc_tac[z_fun_ç_clauses]);
a(DROP_NTH_ASM_T 2 discard_tac THEN all_fc_tac[z_fun_ç_clauses]);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[trace_def]);
(* *** Goal "3" *** *)
a(REPEAT_N 2 (POP_ASM_T ante_tac));
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm]);
a(STRIP_T (strip_asm_tac o conv_rule(ONCE_MAP_C z_¬_conv)));
a(STRIP_T (strip_asm_tac o conv_rule(ONCE_MAP_C z_¬_conv)));
a(lemma_tacÒf ç dom (Trace[V](X, Y, Z))Æ
	THEN1 ALL_FC_T asm_rewrite_tac[trace_def]);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆtrace_def)));
a(LEMMA_TÒ(X, Y, Z) ç Ó ∏ Ó ∏ ÓÆ asm_tac THEN REPEAT strip_tac);
a(all_fc_tac[z_fun_ç_clauses]);
a(DROP_NTH_ASM_T 2 discard_tac THEN all_fc_tac[z_fun_ç_clauses]);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(ALL_FC_T rewrite_tac[trace_def]);
val €rel_tra_mon_cat_dom_thm› = save_pop_thm "rel_tra_mon_cat_dom_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](RelTraMonCat[V] ç TRA_MON_CAT_NAT[Ó, Rel[V]])Æ);
a(rewrite_tac[tra_mon_cat_nat_def,
	rel_tra_mon_cat_def,
	rewrite_rule[rel_tra_mon_cat_def]
		rel_tra_mon_cat_sig_thm]
	THEN REPEAT strip_tac
	THEN REPEAT_N 4 (POP_ASM_T ante_tac)
	THEN conv_tac (ONCE_MAP_C z_¬_conv)
	THEN ALL_FC_T rewrite_tac[z_plus_Ó_thm]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[h_id_def]);
a(z_cond_rw_tac[v_compose_rw_thm, trace_rw_thm, h_compose_rw_thm]
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN REPEAT strip_tac);
a(asm_rewrite_tac[ç_rel_thm,
	pc_rule1 "z_library_ext" prove_rule[]
	Ò[X](id X ç X ™ X)Æ]);
(* *** Goal "1.2" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN REPEAT strip_tac
	THEN asm_rewrite_tac[ç_rel_thm,
	pc_rule1 "z_library_ext" prove_rule[]
	Ò[X](id X ç X ™ X)Æ]);
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN REPEAT strip_tac);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "1.2.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[ç_rel_thm]);
a(LIST_DROP_NTH_ASM_T [1, 2] (MAP_EVERY ante_tac));
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1.2.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[ç_rel_thm]);
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y ç AÆ]);
a(LIST_DROP_NTH_ASM_T [1, 3] (MAP_EVERY ante_tac));
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1.3" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN REPEAT strip_tac
	THEN asm_rewrite_tac[ç_rel_thm,
	pc_rule1 "z_library_ext" prove_rule[]
	Ò[X](id X ç X ™ X)Æ]);
(* *** Goal "1.3.1" *** *)
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN rewrite_tac[]);
a(REPEAT_UNTIL is_¥ strip_tac THEN rewrite_tac[]);
a(REPEAT_N 3 (conv_tac(LEFT_C(PC_C1 "z_library_ext" once_rewrite_conv[]))));
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1.3.1.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[ç_rel_thm]);
a(LIST_DROP_NTH_ASM_T [3] (MAP_EVERY ante_tac));
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1.3.1.2" *** *)
a(DROP_NTH_ASM_T 10 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.3.2" *** *)
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN rewrite_tac[]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1.3.2.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[ç_rel_thm]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑x ç AÆ]);
a(LIST_DROP_NTH_ASM_T [2] (MAP_EVERY ante_tac));
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1.3.2.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y ç AÆ]);
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[ç_rel_thm]);
a(LIST_DROP_NTH_ASM_T [2] (MAP_EVERY ante_tac));
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1.3.3" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1.4" *** *)
a(REPEAT_N 4 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac);
(* *** Goal "1.4.1" *** *)
a(all_var_elim_asm_tac1 THEN asm_rewrite_tac[]);
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑x ç AÆ]);
a(LIST_GET_NTH_ASM_T [1, 10, 12] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
a(all_fc_tac[z_seq_u_thm]);
a(all_fc_tac[z_Î_one_one_thm1] THEN all_var_elim_asm_tac1);
a(z_∂_tacÒc'Æ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1.4.1.1" *** *)
a(DROP_NTH_ASM_T 18 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
a(POP_ASM_T ante_tac
	THEN ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN taut_tac);
(* *** Goal "1.4.1.2" *** *)
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É;x:É; y:É|(x, y) ç id A ∑y = xÆ]
	THEN all_var_elim_asm_tac1);
a(z_∂_tacÒcÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.4.2" *** *)
a(DROP_NTH_ASM_T 8 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
(* *** Goal "1.4.3" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(z_∂_tacÒcÆ THEN asm_rewrite_tac[]);
a(z_∂_tacÒy Î cÆ THEN asm_rewrite_tac[]);
a(z_∂_tacÒ(a¶x1, b¶c, c'¶y, d¶c)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN rewrite_tac[]);
a(DROP_NTH_ASM_T 8 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
a(LIST_DROP_NTH_ASM_T [1, 4, 6] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN taut_tac);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac[h_id_def]);
a(z_cond_rw_tac[v_compose_rw_thm, trace_rw_thm, h_compose_rw_thm]
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN REPEAT strip_tac);
a(asm_rewrite_tac[ç_rel_thm,
	pc_rule1 "z_library_ext" prove_rule[]
	Ò[X](id X ç X ™ X)Æ]);
(* *** Goal "2.2" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(asm_rewrite_tac[ç_rel_thm,
	pc_rule1 "z_library_ext" prove_rule[]
	Ò[X](id X ç X ™ X)Æ]);
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[]));
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "2.2.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑x ç AÆ]);
a(DROP_NTH_ASM_T 9 ante_tac THEN asm_rewrite_tac[ç_rel_thm]);
a(LIST_DROP_NTH_ASM_T [2] (MAP_EVERY ante_tac));
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "2.2.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y ç AÆ]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "2.3" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(asm_rewrite_tac[ç_rel_thm,
	pc_rule1 "z_library_ext" prove_rule[]
	Ò[X](id X ç X ™ X)Æ] THEN REPEAT strip_tac
	THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2.3.1" *** *)
a(REPEAT_N 5 (PC_T1 "z_library_ext" once_rewrite_tac[]));
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "2.3.1.1" *** *)
a(DROP_NTH_ASM_T 10 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.3.1.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "2.3.2" *** *)
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "2.3.2.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑x ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
(* *** Goal "2.3.2.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "2.3.3" *** *)
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac);
(* *** Goal "2.4" *** *)
a(REPEAT_N 4 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac);
(* *** Goal "2.4.1" *** *)
a(z_∂_tacÒaÆ THEN all_var_elim_asm_tac1 THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 14 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y = x ± x ç AÆ]
	THEN all_var_elim_asm_tac);
a(LIST_GET_NTH_ASM_T [1, 10, 11] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "2.4.1.1" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(all_fc_tac[z_Î_one_one_thm1] THEN all_var_elim_asm_tac1);
a(z_∂_tacÒcÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.4.1.2" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(all_fc_tac[z_Î_one_one_thm1] THEN all_var_elim_asm_tac1);
(* *** Goal "2.4.2" *** *)
a(DROP_NTH_ASM_T 8 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "2.4.3" *** *)
a(z_∂_tacÒcÆ THEN asm_rewrite_tac[]);
a(z_∂_tacÒy Î cÆ THEN asm_rewrite_tac[]);
a(z_∂_tacÒ(a¶y, b¶c, c'¶x2, d¶c)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 8 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
a(LIST_DROP_NTH_ASM_T [1, 5, 6] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN taut_tac);
(* *** Goal "3" *** *)
a(ALL_FC_T rewrite_tac[h_id_def]);
a(z_cond_rw_tac[v_compose_rw_thm, trace_rw_thm, h_compose_rw_thm]
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "3.1" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN REPEAT strip_tac
	THEN asm_rewrite_tac[ç_rel_thm,
		pc_rule1 "z_library_ext" prove_rule[]
		Ò[X](id X ç X ™ X)Æ]);
(* *** Goal "3.2" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(asm_rewrite_tac[] THEN rewrite_tac[ç_rel_thm,
	pc_rule1 "z_library_ext" prove_rule[]
	Ò[X](id X ç X ™ X)Æ]);
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.1" *** *)
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.2.1.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑x ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
(* *** Goal "3.2.1.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "3.2.2" *** *)
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.2.2.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑x ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
(* *** Goal "3.2.2.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "3.3" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[] THEN REPEAT strip_tac
	THEN asm_rewrite_tac[ç_rel_thm,
		pc_rule1 "z_library_ext" prove_rule[]
		Ò[X](id X ç X ™ X)Æ]);
(* *** Goal "3.3.1" *** *)
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(REPEAT_N 5 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.3.1.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
(* *** Goal "3.3.1.2" *** *)
a(DROP_NTH_ASM_T 10 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.3.2" *** *)
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.3.2.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑x ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
(* *** Goal "3.3.2.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "3.3.3" *** *)
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(REPEAT_N 5 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.3.3.1" *** *)
a(DROP_NTH_ASM_T 10 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.3.3.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "3.3.4" *** *)
a(REPEAT strip_tac THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]);
a(REPEAT_N 3 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.3.4.1" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑x ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç AÆ]);
(* *** Goal "3.3.4.2" *** *)
a(bc_thm_tac Î_set_exp_bc_thm THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(ALL_FC_T rewrite_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y ç AÆ,
	pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑y ç BÆ]);
(* *** Goal "3.4" *** *)
a(REPEAT_N 5 (PC_T1 "z_library_ext" once_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.4.1" *** *)
a(z_∂_tacÒdÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 14 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç A ± y ç BÆ]
	THEN REPEAT strip_tac);
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y = x ± x ç AÆ]
	THEN all_var_elim_asm_tac);
a(LIST_GET_NTH_ASM_T [3, 12, 14] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(lemma_tacÒ#b = #cÆ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[z_seq_u_thm] THEN all_fc_tac[z_Î_one_one_thm1]
	THEN all_var_elim_asm_tac1);
a(z_∂_tacÒx2 Î cÆ THEN asm_rewrite_tac[]);
a(z_∂_tacÒ(a¶x2, b¶c, c'¶x2, d'¶d)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 14 ante_tac);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN taut_tac);
(* *** Goal "3.4.2" *** *)
a(z_∂_tacÒbÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 14 (strip_asm_tac o rewrite_rule[ç_rel_thm]));
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; B:É; r:É;x:É; y:É|(x, y) ç r ± r ç A ™ B∑x ç A ± y ç BÆ]
	THEN REPEAT strip_tac);
a(all_fc_tac[pc_rule1 "z_library_ext" prove_rule[]Ò
	µA:É; x, y:É|(x, y) ç id A∑y = x ± x ç AÆ]
	THEN all_var_elim_asm_tac);
a(LIST_GET_NTH_ASM_T [2, 12, 13] (MAP_EVERY ante_tac));
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(lemma_tacÒ#d = #cÆ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[z_seq_u_thm] THEN all_fc_tac[z_Î_one_one_thm1]
	THEN all_var_elim_asm_tac1);
a(z_∂_tacÒx1 Î cÆ THEN asm_rewrite_tac[]);
a(z_∂_tacÒ(a¶x1, b'¶b, c'¶x1, d¶c)Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]
	THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 15 ante_tac);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN taut_tac);
val €rel_tra_mon_cat_nat_thm› = save_pop_thm "rel_tra_mon_cat_nat_thm";
=TEX
%%%%
%%%%

=SML
(*
set_goal([], Ò[V](RelTraMonCat[V] ç TRA_MON_CAT_VAN[Ó, Rel[V]])Æ);
a(rewrite_tac[tra_mon_cat_van_def,
	rel_tra_mon_cat_def,
	rewrite_rule[rel_tra_mon_cat_def]
		rel_tra_mon_cat_sig_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)


val €rel_tra_mon_cat_van_thm› = save_pop_thm "rel_tra_mon_cat_van_thm";
*)
=TEX
%%%%
%%%%

=SML
(*
set_goal([], Ò[V](RelTraMonCat[V] ç TRA_MON_CAT_SUP[Ó, Rel[V]])Æ);
a(rewrite_tac[tra_mon_cat_sup_def,
	rel_tra_mon_cat_def,
	rewrite_rule[rel_tra_mon_cat_def]
		rel_tra_mon_cat_sig_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)


val €rel_tra_mon_cat_sup_thm› = save_pop_thm "rel_tra_mon_cat_sup_thm";
*)
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](RelTraMonCat[V] ç TRA_MON_CAT_YAN[Ó, Rel[V]])Æ);
a(rewrite_tac[tra_mon_cat_yan_def,
	rel_tra_mon_cat_def,
	rewrite_rule[rel_tra_mon_cat_def]
		rel_tra_mon_cat_sig_thm]
	THEN REPEAT strip_tac);
a(strip_asm_tac (±_left_elim (µ_elim¨VÆswitch_def)));
a(LEMMA_TÒ(X, X) ç Ó ∏ ÓÆ asm_tac THEN REPEAT strip_tac);
a(all_fc_tac[z_fun_ç_clauses]);
a(LIST_DROP_NTH_ASM_T[2, 3] discard_tac);
a(LEMMA_TÒSwitch[V] (X, X) ç dom (Trace[V](X, X, X))Æante_tac
	THEN ALL_FC_T asm_rewrite_tac[trace_def]
	THEN1 ALL_FC_T rewrite_tac[switch_def]);
a(strip_tac THEN ALL_FC_T asm_rewrite_tac[trace_def]);
a(ALL_FC_T rewrite_tac[switch_def, h_id_def]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[z_gen_pred_u_elim set_exp_def]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[z_seq_u_thm]);
a(lemma_tacÒ#b' = #c ± #a' = #cÆ THEN1 asm_rewrite_tac[]);
a(LIST_DROP_NTH_ASM_T (interval 10 22)
	(fn ths=> 
		all_fc_tac[z_Î_one_one_thm1]
	THEN MAP_EVERY asm_tac ths));
a(all_var_elim_asm_tac1 THEN strip_tac);
(* *** Goal "2" *** *)
a(z_∂_tacÒ(c ¶ x2)Æ THEN asm_rewrite_tac[]);
a(z_∂_tacÒ(a' ¶ x2, b' ¶ x2)Æ THEN asm_rewrite_tac[]);
val €rel_tra_mon_cat_yan_thm› = save_pop_thm "rel_tra_mon_cat_yan_thm";
=TEX
%%%%
%%%%

=SML
set_goal([], Ò[V](
	TRA_MON_CAT[Ó, Rel[V]] = 
	TRA_MON_CAT_SIG[Ó, Rel[V]]
°	TRA_MON_CAT_DOM[Ó, Rel[V]]
°	TRA_MON_CAT_NAT[Ó, Rel[V]]
°	TRA_MON_CAT_VAN[Ó, Rel[V]]
°	TRA_MON_CAT_SUP[Ó, Rel[V]]
°	TRA_MON_CAT_YAN[Ó, Rel[V]])
Æ);
a(rewrite_tac[tra_mon_cat_def]);
a(PC_T1 "z_library_ext" prove_tac[]);
val €tra_mon_cat_rw_thm› = save_pop_thm "tra_mon_cat_rw_thm";

=TEX
%%%%
%%%%

=SML
(*
set_goal([], get_conjecture"-" "rel_tra_mon_cat_thm");
a(rewrite_tac[tra_mon_cat_rw_thm]);
a(rewrite_tac[rel_tra_mon_cat_sig_thm,
	rel_tra_mon_cat_dom_thm,
	rel_tra_mon_cat_nat_thm,
	rel_tra_mon_cat_yan_thm]);

(* *** Goal "1" *** *)
(* *** Goal "4" *** *)
a(REPEAT_N 4 (POP_ASM_T ante_tac));
a(ALL_FC_T rewrite_tac[z_plus_Ó_thm]);
a(conv_tac(ONCE_MAP_C z_¬_conv));
a(REPEAT strip_tac);



set_labelled_goal "10" ;

val €rel_tra_mon_cat_thm› = save_pop_thm "rel_tra_mon_cat_thm";
*)
=TEX
\section{Epilogue}
=SML
z_output_theory{out_file="wrk075.th.doc", theory="-"};
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
=TEX
\end{document}
=IGN
