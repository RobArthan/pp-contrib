=IGN
=TEX
\documentclass[12pt]{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\def\Hide#1{\relax}
\title{Mutilated Chessboard \\ (DRAFT)}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\begin{abstract}
John McCarthy's Mutilated Chessboard problem in set theory, more specifically Z.
\end{abstract}
\section{INTRODUCTION}\label{Intro}

\Hide{
The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"z_library";
set_pc"z_library1";
force_delete_theory"mutcb" handle Fail _ => ();
new_theory"mutcb";
=TEX
}
\section{THE SPECIFICATION}
πZAX
‹ €Abs› : ˙ ≠ ˙
˜¸¸¸¸¸¸
‹ Abs = {i, a:˙ | i æ 0 ± a = i ≤ i < 0 ± a = ~i}
∞
πZ
‹ €Board› ¶ (0 .. 7) ∏ (0 .. 7)
∞
πZ
‹ €MutilatedBoard› ¶ Board \ {(0,0), (7,7)}
∞
πZ
‹ €SQUARE› ¶ ˙ ∏ ˙
∞

πZAX
‹ €Adjacent› : (SQUARE ∏ SQUARE)
˜¸¸¸¸¸¸
‹ µx1, x2:SQUARE∑
‹	(x1, x2) ç Adjacent
‹ §	Abs(x1.1 - x2.1) = 1 ± x1.2 = x2.2
‹ ≤	Abs(x1.2 - x2.2) = 1 ± x1.1 = x2.1
∞
πZAX
‹ €Domino› : ( SQUARE)
˜¸¸¸¸¸¸
‹ µx: SQUARE∑
‹	x ç Domino
‹ §	x ç Ê SQUARE ± #x = 2
‹ ±	(µx1, x2:SQUARE∑x1 Ω x2 ± x1 ç x ± x2 ç x ¥ (x1, x2) ç Adjacent)
∞
πZAX
‹ €DominoOnBoard› : ( SQUARE)
˜¸¸¸¸¸¸
‹ µx: SQUARE∑
‹	x ç DominoOnBoard
‹ §	x Ä Board ± x ç Domino
∞
πZAX
‹ €PartialCovering› : (( SQUARE))
˜¸¸¸¸¸¸
‹ µz:( SQUARE)∑
‹	z ç PartialCovering
‹ §	z Ä DominoOnBoard
‹ ±	(µx, y:z∑x = y ≤ x ° y = {})
∞
The following definition is used in the proof.
πZAX
‹ €Colour› : SQUARE ≠ {0, 1}
˜¸¸¸¸¸¸
‹ µx: SQUARE∑ Colour x = (x.1 + x.2) mod 2
∞
\section{THEOREMS}
\subsection{Main Proof}
πZ
‹ €domino_colour_thm› ?Ù 
‹ 	µx:Domino∑∂u, v:x∑x = {u, v} ± Colour u = 0 ± Colour v = 1
∞
πZ
‹ €board_finite_thm› ?Ù
‹	Board ç (Ê_)
∞
πZ
‹ €domino_on_board_finite_thm› ?Ù
‹	DominoOnBoard ç (Ê_)
∞
πZ
‹ €partial_coverings_finite_thm› ?Ù
‹	PartialCovering Ä (Ê_)
∞
πZ
‹ €partial_coverings_union_finite_thm› ?Ù
‹	PartialCovering Ä Ê(Ê_)
∞
πZ
‹ €partial_covering_subset_thm› ?Ù
‹ µz1, z2:( SQUARE)| z1 Ä z2 ± z2 ç PartialCovering ∑ z1 ç PartialCovering 
∞
πZ
‹ €partial_covering_colour_thm› ?Ù
‹ µz:PartialCovering∑
‹	#{u:ﬁz|Colour u = 0} = #{u:ﬁz|Colour u = 1}
∞
πZ
‹ €total_covering_exists_thm› ?Ù
‹ ∂z:PartialCovering∑ ﬁz = Board
∞

\subsection{Extras}
πZ
‹ €adjacent_trick_thm› ?Ù
‹ µx1, x2:SQUARE∑ 
‹	(x1, x2) ç Adjacent
‹ §	Abs(x1.1 - x2.1) + Abs(x1.2 - x2.2) = 1
∞

πZ
‹ €domino_on_board_eq_thm› ?Ù
‹ DominoOnBoard = Board ° Domino
∞


\subsection{Supporting Theory}
πZ
‹ €z_abs_eq_thm› ?Ù µi, j:˙∑ Abs i = j § (i, j) ç Abs
∞
πZ
‹ €z_abs_clauses› ?Ù
‹	Abs 0 = 0
‹ ±	(µm:Ó∑ Abs m = m ± Abs (~m) = m)
∞
πZ
‹ €z_abs_nat_thm› ?Ù (µi:˙∑Abs i ç Ó)
∞
πZ
‹ €z_abs_eq_0_thm› ?Ù
‹ µi, j:˙∑
‹	Abs (i - j) = 0
‹ §	i = j
∞
πZ
‹ €z_abs_eq_1_thm› ?Ù
‹ µi, j:˙∑
‹	Abs (i - j) = 1
‹ §	i < j ± j = i + 1 ≤ j < i ± i = j + 1
∞
πZ
‹ €z_mod_2_thm› ?Ù
‹ µi, j:˙∑ i mod 2 = j § j ç {0, 1} ± (∂d:É∑ i = 2*d + j)
∞
πZ
‹ €z_mod_2_thm1› ?Ù
‹ µi:˙∑ (2*i) mod 2 = 0 ± (2*i + 1) mod 2 = 1
∞
πZ
‹ €z_ran_mod_2_thm› ?Ù µi:˙∑i mod 2 ç {0, 1}
∞
πZ
‹ €z_plus_1_mod_2_thm› ?Ù µi:˙∑ ≥i mod 2 = (i + 1) mod 2
∞
πZ
‹ €z_size_pair_thm› ?Ù µx, y:É | ≥x = y ∑{x, y} ç (Ê_) ± #{x, y} = 2
∞
πZ
‹ €z_size_eq_thm› ?Ù µa, b:(Ê_) | a Ä b ± #a = #b ∑ a = b 
∞
πZ
‹ €z_size_2_thm› ?Ù µa:(Ê_)∑ #a = 2 § (∂x, y:É∑≥x = y ± a = {x, y})
∞
πZ
‹ €z_size_product_thm› ?Ù µa : (Ê_); b:(Ê_)∑ a ∏ b ç (Ê_) ± #(a ∏ b) = #a * #b
∞
πZ
‹ €z_ran_finite_thm› ?Ù µf: (_≠_); a:(Ê_)∑ {x:a; y:É|(x, y) ç f∑y} ç (Ê_)
∞
πZ
‹ €z_finite_powerset_thm› ?Ù µa:(Ê_)∑ a ç (Ê_)
∞
πZ
‹ €z_finite_subset_thm› ?Ù µa:(Ê_); b: É | b Ä a ∑b ç (Ê_)
∞
πZ
‹ €adjacent_colour_thm› ?Ù µu, v:SQUARE∑(u, v) ç Adjacent ¥ Colour u Ω Colour v
∞
πZ
‹ €ran_colour_thm› ?Ù µu:SQUARE∑ Colour u ç {0, 1}
∞
=TEX
\newpage
\appendix
=TEX
{\HOLindexOff\small
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{mutcb.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
\printindex
=TEX
\end{document}
=SML
val €square_def› = z_get_specÒSQUAREÆ;
val €square_u_thm› = pc_rule1 "z_sets_ext" prove_rule[get_specÒ˙Æ, square_def]ÒSQUARE = ÉÆ;
=TEX
=SML
val €z_abs_def› = z_get_specÒAbsÆ;
val €adjacent_def› = z_get_specÒAdjacentÆ;
val €board_def› = z_get_specÒBoardÆ;
val €mutilated_board_def› = z_get_specÒMutilatedBoardÆ;
val €domino_def› =
	rewrite_rule[square_u_thm](z_get_specÒDominoÆ);
val €domino_on_board_def› =
	rewrite_rule[square_u_thm](z_get_specÒDominoOnBoardÆ);
val €partial_covering_def› =
	rewrite_rule[square_u_thm](z_get_specÒPartialCoveringÆ);
val €colour_def› = z_get_specÒColourÆ;
=TEX
=SML
delete_pc"'mutcb" handle Fail _ => ();
new_pc "'mutcb";
set_u_simp_eqn_cxt (u_simp_eqn_cxt [square_u_thm]) "'mutcb";
set_merge_pcs["'mutcb", "z_library1"];
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_eq_thm");
a(z_µ_tac THEN strip_tac);
a(bc_thm_tac
	(rewrite_rule[](conv_rule (MAP_C z_µ_elim_conv) (z_≠_app_eq_§_ç_rel_thm))));
a(∂_tacÒ˙Æ THEN ∂_tacÒ˙Æ THEN rewrite_tac[z_abs_def]);
val €z_abs_eq_thm› = save_pop_thm "z_abs_eq_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_clauses");
a(rewrite_tac[z_abs_eq_thm]);
a(rewrite_tac[z_abs_def]);
a(PC_T1 "z_lin_arith" prove_tac[]);
val €z_abs_clauses› = save_pop_thm "z_abs_clauses";
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_nat_thm");
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elimÒiÆ z_˙_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN ALL_FC_T asm_rewrite_tac [z_abs_clauses]);
val €z_abs_nat_thm› = save_pop_thm "z_abs_nat_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_eq_0_thm");
a(z_µ_tac THEN strip_tac);
a(strip_asm_tac(z_µ_elim Òi + ~jÆ z_˙_cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[z_abs_clauses]
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val €z_abs_eq_0_thm› = save_pop_thm "z_abs_eq_0_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_eq_1_thm");
a(z_µ_tac THEN strip_tac);
a(strip_asm_tac(z_µ_elim Òi + ~jÆ z_˙_cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[z_abs_clauses]
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val €z_abs_eq_1_thm› = save_pop_thm "z_abs_eq_1_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_mod_2_thm");
a(z_µ_tac THEN strip_tac);
a(LEMMA_T Ò≥2 = 0Æ asm_tac THEN1 REPEAT strip_tac);
a(ALL_FC_T1 fc_§_canon rewrite_tac
	[rewrite_rule[](conv_rule (MAP_C z_µ_elim_conv) (z_mod_thm))]);
a(REPEAT strip_tac THEN_TRY
	z_∂_tac Òd ∫ ˙Æ THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val €z_mod_2_thm› = save_pop_thm "z_mod_2_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_mod_2_thm1");
a(z_µ_tac THEN strip_tac);
a(rewrite_tac[z_mod_2_thm]);
a(z_∂_tacÒiÆ THEN REPEAT strip_tac);
val €z_mod_2_thm1› = save_pop_thm "z_mod_2_thm1";
=TEX
=SML
set_goal([], get_conjecture "-" "z_ran_mod_2_thm");
a(contr_tac);
a(fc_tac[
	inst_term_rule [(Òi mod 2Æ, Òj ∫ ˙Æ)]
		(all_µ_elim (hd (fc_canon z_mod_2_thm)))]);
val €z_ran_mod_2_thm› = save_pop_thm "z_ran_mod_2_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_plus_1_mod_2_thm");
a(REPEAT strip_tac);
a(lemma_tac¨∂j∑Ò(i + 1) mod 2 = jÆÆ THEN1 prove_∂_tac);
a(asm_rewrite_tac[] THEN POP_ASM_T ante_tac);
a(rewrite_tac[z_mod_2_thm] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN all_asm_ante_tac THEN rewrite_tac[] THEN contr_tac);
(* *** Goal "1" duplicates "2" *** *)
a(lemma_tacÒ0 < d - d' < 1 Æ THEN
	PC_T1 "z_lin_arith" asm_prove_tac[]);
val €z_plus_1_mod_2_thm› = save_pop_thm "z_plus_1_mod_2_thm";
val €z_plus_1_mod_2_thm› =
	conv_rule (ONCE_MAP_C z_anf_conv) z_plus_1_mod_2_thm;
=TEX
=SML
val €z_Ê_¿_singleton_thm1› = z_gen_pred_elim[ÒÉÆ] z_Ê_¿_singleton_thm;
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_pair_thm");
a(z_µ_tac THEN strip_tac);
a(lemma_tacÒ{y} ç (Ê_) ± #{y} = 1Æ THEN1 rewrite_tac[z_size_singleton_thm]);
a(ante_tac (z_µ_elimÒ(x ¶ x, a ¶ {y})Æ z_size_¿_singleton_thm));
a(ante_tac (z_µ_elimÒ(x ¶ x, a ¶ {y})Æ z_Ê_¿_singleton_thm1));
a(asm_rewrite_tac[z_size_singleton_thm]);
a(LEMMA_T Ò{x, y} = {y} ¿ {x}Æ rewrite_thm_tac
	THEN PC_T1 "z_sets_ext" prove_tac[]);
val €z_size_pair_thm› = save_pop_thm "z_size_pair_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_eq_thm");
a(PC_T "z_sets_ext" contr_tac
	THEN1 all_asm_fc_tac[]);
a(lemma_tacÒa Ä a ¿ {x1} ± a ¿ {x1} Ä bÆ THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(strip_asm_tac (z_µ_elimÒ(x ¶ x1, a ¶ a)Æ z_size_¿_singleton_thm));
a(strip_asm_tac (z_µ_elimÒ(x ¶ x1, a ¶ a)Æ z_Ê_¿_singleton_thm1));
a(strip_asm_tac (z_µ_elimÒ(a ¶ b, b ¶ a ¿ {x1})Æ z_size_mono_thm));
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
val €z_size_eq_thm› = save_pop_thm "z_size_eq_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_2_thm");
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_sets_ext" lemma_tac Ò≥a = {}Æ
	THEN1 (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[z_size_empty_thm]));
a(PC_T1 "z_sets_ext" lemma_tac Ò≥a = {x1}Æ
	THEN1 (swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[z_size_singleton_thm])
	THEN_TRY all_var_elim_asm_tac1);
a(lemma_tacÒ{x2, x1} ç (Ê_) ± #{x2, x1} = 2Æ THEN1
	ALL_FC_T rewrite_tac[z_size_pair_thm]);
a(LEMMA_TÒ{x2, x1} Ä aÆ asm_tac THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(ante_tac (z_µ_elimÒ(a ¶ {x2, x1}, b ¶ a)Æ z_size_eq_thm));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(z_∂_tacÒ(x ¶ x2, y ¶ x1)Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(ALL_FC_T asm_rewrite_tac[z_size_pair_thm]);
val €z_size_2_thm› = save_pop_thm "z_size_2_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_product_thm");
a(z_µ_tac THEN strip_tac);
a(z_Ê_induction_tacÒaÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[z_size_empty_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[
	pc_rule1 "z_library_ext"
		prove_rule[] Ò(a ¿ {x}) ∏ b = (a ∏ b) ¿ ({x} ∏ b)Æ]);
a(lemma_tacÒ(a ∏ b) ° ({x} ∏ b) = {}Æ THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(lemma_tacÒ({x} ∏ b) ç (Ê_) ± #({x} ∏ b) = #bÆ);
(* *** Goal "2.1" *** *)
a(LIST_DROP_NTH_ASM_T [1, 2, 3, 4, 5] discard_tac);
a(z_Ê_induction_tacÒbÆ
	THEN1 rewrite_tac[z_size_empty_thm]);
a(rewrite_tac[
	pc_rule1 "z_library_ext"
		prove_rule[] Ò{x} ∏ (b ¿ {x'}) = ({x} ∏ b) ¿ {(x, x')}Æ]);
a(LEMMA_TÒ≥(x, x') ç ({x} ∏ b)Æ asm_tac THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(ante_tac (z_µ_elimÒ(x ¶ (x, x'), a ¶ {x} ∏ b)Æ z_size_¿_singleton_thm));
a(ante_tac (z_µ_elimÒ(x ¶ x', a ¶ b)Æ z_size_¿_singleton_thm));
a(ante_tac (z_µ_elimÒ(x ¶ (x, x'), a ¶ {x} ∏ b)Æ z_Ê_¿_singleton_thm1));
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(ante_tac (z_µ_elimÒ(a ¶ a ∏ b, b ¶ {x} ∏ b)Æ z_size_¿_thm));
a(asm_rewrite_tac[z_size_empty_thm]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[z_size_¿_singleton_thm]);
a(PC_T1 "z_lin_arith" prove_tac[]);
val €z_size_product_thm› = save_pop_thm "z_size_product_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_ran_finite_thm");
a(REPEAT strip_tac);
a(z_Ê_induction_tacÒaÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[
	z_size_empty_thm,
	pc_rule1 "z_library_ext"
prove_rule[] Ò{x : {}; y : É | (x, y) ç f ∑ y} = {}Æ]);
(* *** Goal "2" *** *)
a(LEMMA_T Òx ç ÉÆ asm_tac THEN REPEAT strip_tac);
a(LEMMA_T Ò{x' : a ¿ {x}; y : É | (x', y) ç f ∑ y} = {x' : a; y : É | (x', y) ç f ∑ y} ¿ {f x}Æ
	rewrite_thm_tac THEN1
	PC_T1 "z_sets_ext" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
(* *** Goal "2.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(ALL_FC_T rewrite_tac [z_≠_ç_rel_§_app_eq_thm]);
(* *** Goal "2.3" *** *)
a(z_∂_tacÒ(x'¶x', y¶x1)Æ THEN REPEAT strip_tac);
(* *** Goal "2.4" *** *)
a(z_∂_tacÒ(x'¶x, y¶f x)Æ THEN REPEAT strip_tac);
a(all_fc_tac[z_≠_app_thm]);
(* *** Goal "2.5" *** *)
a(ALL_FC_T rewrite_tac [z_Ê_¿_singleton_thm1]);
val €z_ran_finite_thm› = save_pop_thm "z_ran_finite_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_finite_powerset_thm");
a(REPEAT strip_tac);
a(z_Ê_induction_tacÒaÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[
	z_size_singleton_thm,
	pc_rule1 "z_sets_ext"
		prove_rule[] Ò{} = {{}}Æ]);
(* *** Goal "2" *** *)
a(lemma_tacÒ
	∂f:(_≠_)∑(a ¿ {x})={x:{0, 1} ∏ a; y:É|(x, y) ç f∑y}
Æ);
(* *** Goal "2.1" *** *)
a(z_∂_tacÒ{p:É ∏ É; b:É | p.1 = 0 ± b = p.2 ≤ ≥p.1 = 0 ± b = p.2 ¿ {x}∑(p, b)}Æ);
a(REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac
	THEN_TRY SOLVED_T(POP_ASM_T ante_tac THEN asm_rewrite_tac[]));
a(PC_T1 "z_sets_ext" once_rewrite_tac[]);
a(cases_tacÒx1 = 0Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.1.1.1" *** *)
a(z_∂_tacÒx2Æ THEN rewrite_tac[]);
(* *** Goal "2.1.1.2" *** *)
a(z_∂_tacÒx2 ¿ {x}Æ THEN rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a(PC_T1 "z_sets_ext" once_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.1.2.1" *** *)
a(lemma_tacÒx1 \ {x} Ä aÆ THEN1 PC_T1 "z_sets_ext" asm_prove_tac[]);
a(cases_tacÒx ç x1Æ);
(* *** Goal "2.1.2.1.1" *** *)
a(z_∂_tacÒ(x'¶(1, x1 \ {x}), y¶x1)Æ
	THEN asm_rewrite_tac[]);
a(PC_T1 "z_sets_ext" asm_prove_tac[]);
(* *** Goal "2.1.2.1.2" *** *)
a(z_∂_tacÒ(x'¶(0, x1 \ {x}), y¶x1)Æ
	THEN asm_rewrite_tac[]);
a(PC_T1 "z_sets_ext" asm_prove_tac[]);
a(contr_tac THEN all_var_elim_asm_tac1);
(* *** Goal "2.1.2.2" *** *)
a(all_var_elim_asm_tac1);
a(PC_T1 "z_sets_ext" asm_prove_tac[]);
(* *** Goal "2.1.2.3" *** *)
a(all_var_elim_asm_tac1);
a(PC_T1 "z_sets_ext" asm_prove_tac[]);
(* *** Goal "2.1.2.4" *** *)
a(all_var_elim_asm_tac1);
a(PC_T1 "z_sets_ext" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(LEMMA_T Ò≥0 = 1Æ asm_tac THEN REPEAT strip_tac);
a(lemma_tacÒ{0, 1} ç (Ê_)Æ THEN1
	all_fc_tac[z_size_pair_thm]);
a(lemma_tacÒ{0, 1} ∏ a ç (Ê_)Æ THEN1
	all_fc_tac[z_size_product_thm]);
a(all_fc_tac[z_ran_finite_thm]);
val €z_finite_powerset_thm› = save_pop_thm "z_finite_powerset_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_finite_subset_thm");
a(REPEAT strip_tac);
a(LEMMA_TÒb = a \ {x:a|≥x ç b}Æ once_rewrite_thm_tac
	THEN1 PC_T1 "z_sets_ext" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[z_Ê_diff_thm]);
val €z_finite_subset_thm› = save_pop_thm "z_finite_subset_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "ran_colour_thm");
a(rewrite_tac[colour_def,
	rewrite_rule[]z_ran_mod_2_thm]);
val €ran_colour_thm› = save_pop_thm "ran_colour_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "adjacent_colour_thm");
a(rewrite_tac[adjacent_def, colour_def, z_abs_eq_1_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (asm_tac o eq_sym_rule) 
	THEN asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN conv_tac (RAND_C eq_sym_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm]);
(* *** Goal "3" *** *)
a(POP_ASM_T (asm_tac o eq_sym_rule) 
	THEN asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm]);
(* *** Goal "4" *** *)
a(asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN conv_tac (RAND_C eq_sym_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm]);
val €adjacent_colour_thm› = save_pop_thm "adjacent_colour_thm";

=TEX
=SML
set_goal([], get_conjecture "-" "domino_colour_thm");
a(z_µ_tac THEN rewrite_tac[domino_def]
	THEN REPEAT strip_tac);
a(all_fc_tac[z_size_2_thm] THEN1 all_var_elim_asm_tac1);
a(z_spec_nth_asm_tac 2 Ò(x1 ¶ x', x2 ¶ y)Æ);
a(all_fc_tac[adjacent_colour_thm]);
a(strip_asm_tac (z_µ_elimÒx'Æ ran_colour_thm));
(* *** Goal "1" *** *)
a(z_∂_tacÒ(u¶x', v¶y)Æ THEN asm_rewrite_tac[]);
a(strip_asm_tac (z_µ_elimÒyÆ ran_colour_thm));
a(swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(z_∂_tacÒ(u¶y, v¶x')Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_sets_ext" REPEAT strip_tac);
a(strip_asm_tac (z_µ_elimÒyÆ ran_colour_thm));
a(swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[]);
val €domino_colour_thm› = save_pop_thm "domino_colour_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "board_finite_thm");
a(rewrite_tac[board_def]);
a(lemma_tacÒ0 .. 7 ç (Ê_)Æ
	THEN1 rewrite_tac[z_size_dot_dot_thm1]);
a(all_fc_tac[z_size_product_thm]);
val €board_finite_thm› = save_pop_thm "board_finite_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "domino_on_board_finite_thm");
a(lemma_tacÒDominoOnBoard Ä BoardÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[pc_rule1 "z_sets_ext" prove_rule[]
	Òµa:É; b:É∑ a Ä b § (µx:a∑x Ä b)Æ]);
a(REPEAT strip_tac THEN all_fc_tac[domino_on_board_def]);
(* *** Goal "2" *** *)
a(strip_asm_tac board_finite_thm THEN all_fc_tac[z_finite_powerset_thm]);
a(all_fc_tac[z_finite_subset_thm]);
val €domino_on_board_finite_thm› = save_pop_thm "domino_on_board_finite_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "partial_coverings_finite_thm");
a(PC_T "z_sets_ext"strip_tac
	THEN rewrite_tac[partial_covering_def]);
a(REPEAT strip_tac);
a(strip_asm_tac domino_on_board_finite_thm THEN all_fc_tac[z_finite_subset_thm]);
val €partial_coverings_finite_thm› = save_pop_thm "partial_coverings_finite_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "partial_coverings_union_finite_thm");
a(once_rewrite_tac[z_Ê__thm]);
a(rewrite_tac[
	pc_rule1 "z_sets_ext" prove_rule []
	Òµa, b, c : É∑
		a Ä b ° c § (µx:É∑x ç a ¥ x ç b) ± a Ä cÆ,
	partial_covering_def,
	partial_coverings_finite_thm]);
a(PC_T1 "z_sets_ext" once_rewrite_tac[]);
a(rewrite_tac[domino_on_board_def, domino_def]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
val €partial_coverings_union_finite_thm› = save_pop_thm "partial_coverings_union_finite_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "partial_covering_subset_thm");
a(rewrite_tac[partial_covering_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_sets_ext" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "z_sets_ext" all_asm_fc_tac[]);
a(all_asm_fc_tac[]);
val €partial_covering_subset_thm› = save_pop_thm "partial_covering_subset_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "partial_covering_colour_thm");
a(REPEAT strip_tac);
a(PC_T1 "z_sets_ext" all_fc_tac[partial_coverings_finite_thm]);
a(DROP_NTH_ASM_T 2 ante_tac THEN
	z_Ê_induction_tacÒzÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[
	pc_rule1"z_sets_ext" prove_rule[]
		Òµi:˙∑{u : ﬁ{} | Colour u = i} = {}Æ
]);
(* *** Goal "2" *** *)
a(lemma_tacÒz Ä z ¿ {x}Æ THEN1 PC_T1 "z_sets_ext" prove_tac[]);
a(all_fc_tac[partial_covering_subset_thm]);
(* *** Goal "3" *** *)
a(LEMMA_T
	Òµi:˙∑{u : ﬁ(z ¿ {x}) | Colour u = i}
	= {u : ﬁz | Colour u = i} ¿ {v : x | Colour v = i}Æ
	rewrite_thm_tac);
(* *** Goal "3.1" *** *)
a(PC_T1 "z_sets_ext" REPEAT strip_tac
	THEN contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(LEMMA_T
	Òµi:{0, 1}∑#({u : ﬁz | Colour u = i} ¿ {v : x | Colour v = i})
	= #{u : ﬁz | Colour u = i} + 1Æ
	(fn th =>
	let	val th1 = rewrite_rule[](z_µ_elimÒ0Æ th);
		val th2 = rewrite_rule[](z_µ_elimÒ1Æ th);
	in	asm_rewrite_tac[th1, th2]
	end));
a(lemma_tacÒx ç DominoÆ THEN1
	(POP_ASM_T ante_tac
	THEN rewrite_tac[partial_covering_def,
	pc_rule1"z_sets_ext" prove_rule[]
		ÒµZ:É;X:É;D:É∑ Z ¿ {X} Ä D § Z Ä D ± X ç DÆ,
	domino_on_board_def]
	THEN taut_tac));
a(PC_T1 "z_predicates" REPEAT strip_tac);
a(lemma_tacÒ∂w:x∑{v : x | Colour v = i} = {w}Æ);
(* *** Goal "3.2.1" *** *)
a(all_fc_tac[domino_colour_thm]);
a(LIST_DROP_NTH_ASM_T [4, 5] discard_tac
	THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 3 strip_asm_tac);
(* *** Goal "3.2.1.1" *** *)
a(z_∂_tacÒuÆ THEN rewrite_tac[
	pc_rule1"z_sets_ext" prove_rule[]
		ÒµX, Y:É∑ X = Y § (µv:É∑v ç X § v ç Y)Æ
]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.2.1.2" *** *)
a(z_∂_tacÒvÆ THEN rewrite_tac[
	pc_rule1"z_sets_ext" prove_rule[]
		ÒµX, Y:É∑ X = Y § (µv:É∑v ç X § v ç Y)Æ
]);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.2.2" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(lemma_tacÒ
	{u : ﬁ z | Colour u = i} Ä ﬁz
Æ THEN1 PC_T1 "z_sets_ext" prove_tac[]);
a(lemma_tac Òz ç Ê(Ê_)Æ);
(* *** Goal "3.2.2.1" *** *)
a(lemma_tacÒz Ä z ¿ {x}Æ THEN1 PC_T1 "z_sets_ext" prove_tac[]);
a(all_fc_tac[partial_covering_subset_thm]);
a(PC_T1 "z_sets_ext" all_fc_tac 
	[partial_coverings_union_finite_thm]);
(* *** Goal "3.2.2.2" *** *)
a(all_fc_tac[z_ﬁ_Ê_thm]);
a(all_fc_tac[z_finite_subset_thm]);
a(LEMMA_TÒ≥w ç {u : ﬁ z | Colour u = i}Æ asm_tac);
(* *** Goal "3.2.2.2.1" *** *)
a(PC_T "z_sets_ext"  contr_tac);
a(DROP_NTH_ASM_T 11 (strip_asm_tac o rewrite_rule[partial_covering_def]));
a(POP_ASM_T ante_tac THEN rewrite_tac[]
	THEN strip_tac);
a(z_∂_tacÒ(x'¶x, y¶S)Æ THEN asm_rewrite_tac[]);
a(cases_tac Òx = SÆ THEN1 all_var_elim_asm_tac);
a(POP_ASM_T rewrite_thm_tac);
a(strip_tac THEN1 
	PC_T1 "z_sets_ext" once_rewrite_tac[]
	THEN REPEAT strip_tac);
a(rewrite_tac[
	pc_rule1"z_sets_ext" prove_rule[]
		ÒµX, Y:É∑ ≥X ° Y = {}§ (∂v:É∑v ç X ± v ç Y)Æ
]);
a(z_∂_tacÒwÆ THEN  REPEAT strip_tac);
(* *** Goal "3.2.2.2.2" *** *)
a(ALL_FC_T rewrite_tac[z_size_¿_singleton_thm]);
val €partial_covering_colour_thm› = save_pop_thm "partial_covering_colour_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "adjacent_trick_thm");
a(z_µ_tac THEN strip_tac THEN rewrite_tac[adjacent_def]);
a(lemma_tacÒAbs (x1.1 + ~ x2.1) ç Ó ± Abs (x1.2 + ~ x2.2) ç ÓÆ
	THEN1 rewrite_tac[z_abs_nat_thm]);
a(LEMMA_TÒµi, j:Ó∑
	i + j = 1 § i = 1 ± j = 0 ≤ i = 0 ± j = 1Æ
	(fn th => ALL_FC_T1 fc_§_canon rewrite_tac[th])
	THEN1 PC_T1 "z_lin_arith" prove_tac[]);
a(rewrite_tac[rewrite_rule[] z_abs_eq_0_thm] THEN PC_T1 "z_lin_arith" prove_tac[]);
val €adjacent_trick_thm› = save_pop_thm "adjacent_trick_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "domino_on_board_eq_thm");
a(PC_T "z_sets_ext" strip_tac);
a(rewrite_tac[domino_on_board_def]);
val €domino_on_board_eq_thm› = save_pop_thm "domino_on_board_eq_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "total_covering_exists_thm");
a(lemma_tacÒµi, j:É∑≥2*i = 2*j + 1Æ THEN1
	(contr_tac THEN LEMMA_T
	Ò(2 * i) mod 2 = (2 * j + 1) mod 2Æ ante_tac
	THEN1 asm_rewrite_tac[]
	THEN rewrite_tac[z_mod_2_thm1]));
a(TOP_ASM_T (strip_asm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
a(z_∂_tacÒ
	{ i, j : ˙ | i ç 0 .. 7 ± j ç 0 .. 3 ∑
		{(i, 2*j), (i, 2*j+1)} }Æ);
a(rewrite_tac[partial_covering_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[domino_on_board_eq_thm]);
a(rewrite_tac[board_def] THEN REPEAT strip_tac);
a(rewrite_tac[
	pc_rule1 "z_sets_ext" prove_rule []
	Òµa, b, c : É∑
		a Ä b ° c § (a Ä b) ± a Ä cÆ]);
a(strip_tac THEN PC_T "z_sets_ext" strip_tac
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "1.1" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(LEMMA_TÒ≥(i, 2 * j) = (i, 2 * j + 1)Æ asm_tac
	THEN1 rewrite_tac[]);
a(rewrite_tac[domino_def, adjacent_def,
	rewrite_rule[]z_abs_eq_1_thm]);
a(ALL_FC_T rewrite_tac[z_size_pair_thm]);
a(REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1
	THEN_TRY asm_rewrite_tac[]
	THEN all_asm_ante_tac
	THEN_TRY rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN
	LIST_DROP_NTH_ASM_T [9, 10]
	(fn ths => 
	PC_T1 "z_library_ext" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1
	THEN_TRY asm_rewrite_tac[]
	THEN all_asm_ante_tac
	THEN_TRY rewrite_tac ths
	THEN MAP_EVERY asm_tac ths
	THEN REPEAT strip_tac
	THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]));
(* *** Goal "3" *** *)
a(PC_T "z_sets_ext" strip_tac
	THEN rewrite_tac[board_def]
	THEN REPEAT_UNTIL is_± strip_tac
	THEN strip_tac);
(* *** Goal "3.1" *** *)
a(strip_tac THEN all_var_elim_asm_tac1
	THEN all_var_elim_asm_tac1
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2" *** *)
a(strip_tac THEN
	LEMMA_T Òx2 mod 2 = x2 mod 2Æ ante_tac
	THEN1 REPEAT strip_tac);
a(pure_rewrite_tac[z_mod_2_thm]);
a(REPEAT strip_tac
	THEN POP_ASM_T ante_tac
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.2.1" *** *)
a(z_∂_tacÒ{(x1, 2 * d), (x1, 2 * d + 1)}Æ
	THEN rewrite_tac[]);
a(z_∂_tacÒ(i¶x1, j¶d)Æ
	THEN PC_T1 "z_library_ext" asm_rewrite_tac[]);
a(REPEAT strip_tac THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.2" *** *)
a(z_∂_tacÒ{(x1, 2 * d), (x1, 2 * d + 1)}Æ
	THEN rewrite_tac[]);
a(z_∂_tacÒ(i¶x1, j¶d)Æ
	THEN PC_T1 "z_library_ext" asm_rewrite_tac[]);
a(REPEAT strip_tac THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val €total_covering_exists_thm› = save_pop_thm "total_covering_exists_thm";
=TEX
\ftlinepenalty=999
=SML

=TEX
\section{Epilogue}
=TEX
=SML
fun check_conjecture name = (
	if	let	val tm = get_conjecture "-" name;
			val thm = get_thm "-" name;
		in	is_nil (asms thm)
		andalso	tm =$ concl thm
		end	handle Fail _ => false
	then	(delete_conjecture name;
		true)
	else	(diag_line ("Conjecture " ^ name ^ " has not been proved");
		false)
);
if all (map (check_conjecture)
	(map (hd o fst) (get_conjectures "-")))
	(fn x => x)
then	diag_line "All conjectures have been proved."
else	();
=SML
z_output_theory{out_file="mutcb.th.doc", theory="-"};
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
=TEX
\end{document}
=IGN
