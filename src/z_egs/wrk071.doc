=IGN
=TEX
\documentclass[12pt]{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\def\Hide#1{\relax}
\title{Mutilated Chessboard \\ (DRAFT)}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\section{Introduction}\label{Intro}

\Hide{
The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"z_library";
set_pc"z_library1";
force_delete_theory"mutcb" handle Fail _ => ();
new_theory"mutcb";
=TEX
}

ZAX
 Abs :   

 Abs = {i, a: | i  0  a = i  i < 0  a = ~i}

Z
 Board  (0 .. 7)  (0 .. 7)

Z
 MutilatedBoard  Board \ {(0,0), (7,7)}


ZAX
 Adjacent : ((  )  (  ))

 x1, x2:  
	(x1, x2)  Adjacent
 	Abs(x1.1 - x2.1) = 1  x1.2 = x2.2
 	Abs(x1.2 - x2.2) = 1  x1.1 = x2.1

ZAX
 Domino : ((  ))

 x:(  )
	x  Domino
 	#x = 2
 	(x1, x2:  x1  x2  x1  x  x2  x  (x1, x2)  Adjacent)

ZAX
 DominoOnBoard : ((  ))

 x:(  )
	x  DominoOnBoard
 	x  Board  x  Domino

ZAX
 PartialCovering : (((  )))

 z:((  ))
	z  PartialCovering
 	(x:z x  DominoOnBoard)
 	(x, y:zx = y  x  y = {})


ZAX
 Colour :     {0, 1}

 x:    Colour x = (x.1 + x.2) mod 2

=TEX
=SML

val z_abs_def = z_get_specAbs;
val adjacent_def = z_get_specAdjacent;
val board_def = z_get_specBoard;
val mutilated_board_def = z_get_specMutilatedBoard;
val domino_def = z_get_specDomino;
val domino_on_board_def = z_get_specDominoOnBoard;
val partial_covering_def = z_get_specPartialCovering;
val colour_def = z_get_specColour;
=TEX
=SML
set_goal([], 
i, j: Abs i = j  (i, j)  Abs
);
a(z__tac THEN strip_tac);
a(bc_thm_tac
	(rewrite_rule[](conv_rule (MAP_C z__elim_conv) (z__app_eq___rel_thm))));
a(_tac THEN _tac THEN rewrite_tac[z_abs_def]);
val z_abs_eq_thm = save_pop_thm "z_abs_eq_thm";
=TEX
=SML
set_goal([], 
	Abs 0 = 0
	(m: Abs m = m  Abs (~m) = m)
);
a(rewrite_tac[z_abs_eq_thm]);
a(rewrite_tac[z_abs_def]);
a(PC_T1 "z_lin_arith" prove_tac[]);
val z_abs_clauses = save_pop_thm "z_abs_clauses";
=TEX
=SML
set_goal([], 
i, j:
	Abs (i - j) = 0
	i = j
);
a(z__tac THEN strip_tac);
a(strip_asm_tac(z__elim i + ~j z__cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[z_abs_clauses]
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val z_abs_eq_0_thm = save_pop_thm "z_abs_eq_0_thm";
=TEX
=SML
set_goal([], 
i, j:
	Abs (i - j) = 1
	i < j  j = i + 1  j < i  i = j + 1
);
a(z__tac THEN strip_tac);
a(strip_asm_tac(z__elim i + ~j z__cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[z_abs_clauses]
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val z_abs_eq_1_thm = save_pop_thm "z_abs_eq_1_thm";
=TEX
=SML
set_goal([], 
i, j:	i mod 2 = j  j  {0, 1}  (d: i = 2*d + j)
);
a(z__tac THEN strip_tac);
a(LEMMA_T 2 = 0 asm_tac THEN1 REPEAT strip_tac);
a(ALL_FC_T1 fc__canon rewrite_tac
	[rewrite_rule[](conv_rule (MAP_C z__elim_conv) (z_mod_thm))]);
a(REPEAT strip_tac THEN_TRY
	z__tac d   THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val z_mod_2_thm = save_pop_thm "z_mod_2_thm";
=TEX
=SML
set_goal([], 
i:	i mod 2 = (i + 1) mod 2
);
a(REPEAT strip_tac);
a(lemma_tacj(i + 1) mod 2 = j THEN1 prove__tac);
a(asm_rewrite_tac[] THEN POP_ASM_T ante_tac);
a(rewrite_tac[z_mod_2_thm] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN all_asm_ante_tac THEN rewrite_tac[] THEN contr_tac);
(* *** Goal "1" duplicates "2" *** *)
a(lemma_tac0 < d - d' < 1  THEN
	PC_T1 "z_lin_arith" asm_prove_tac[]);
val z_plus_1_mod_2_thm = save_pop_thm "z_plus_1_mod_2_thm";
val z_plus_1_mod_2_thm =
	conv_rule (ONCE_MAP_C z_anf_conv) z_plus_1_mod_2_thm;
=TEX
=SML
set_goal([], 
	u, v:U(u, v)  Adjacent  Colour u  Colour v
);
a(rewrite_tac[adjacent_def, colour_def, z_abs_eq_1_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (asm_tac o eq_sym_rule) 
	THEN asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN conv_tac (RAND_C eq_sym_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm]);
(* *** Goal "3" *** *)
a(POP_ASM_T (asm_tac o eq_sym_rule) 
	THEN asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm]);
(* *** Goal "4" *** *)
a(asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN conv_tac (RAND_C eq_sym_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm]);
val adjacent_colout_thm = save_pop_thm "adjacent_colour_thm";
=TEX
=SML
(*
set_goal([], 
	x:Dominou, v:xx = {u, v}  Colour u = 0  Colour v = 1
);
*)
=TEX
\newpage
\appendix
=TEX
{\HOLindexOff\small
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{mutcb.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
=TEX
\ftlinepenalty=999
=SML

=TEX
\section{Epilogue}
=SML
z_output_theory{out_file="mutcb.th.doc", theory="-"};
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
=TEX
\end{document}
=IGN
