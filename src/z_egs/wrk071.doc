=IGN
=TEX
\documentclass[12pt]{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\def\Hide#1{\relax}
\title{Mutilated Chessboard \\ (DRAFT)}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\begin{abstract}
John McCarthy's Mutilated Chessboard problem in set theory, more specifically Z.
\end{abstract}

\Hide{
The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"z_library";
set_pc"z_library1";
force_delete_theory"mutcb" handle Fail _ => ();
new_theory"mutcb";
=TEX
}
\section{THE SPECIFICATION}
¹ZAX
Ü ÛAbsİ : ú ­ ú
÷üüüüüü
Ü µm:î · Abs (~m) = Abs m = m
°
¹ZAX
Ü ÛColourİ : ú ¸ ú ­ ú
÷üüüüüü
Ü µx:ú ¸ ú · Colour x = (x.1 + x.2) mod 2
°

¹Z
Ü ÛAdjacentİ ¦ {x1, x2 : ú ¸ ú | Abs(x1.1 - x2.1) + Abs(x1.2 - x2.2) = 1}
°
¹Z
Ü ÛDominoİ ¦ {x:æ(ú ¸ ú) | #x = 2 ± (µx1, x2:x | x1 ½ x2 · (x1, x2)  Adjacent)}
°
¹Z
Ü ÛTilingİ ¦ {z:ğ(ğ(ú ¸ ú)) | z € Domino ± (µx, y:z · x = y ² x ¡ y = {})}
°
¹Z
Ü ÛBoardİ ¦ (0 .. 7) ¸ (0 .. 7)
°
¹Z
Ü ÛMutilatedBoardİ ¦ Board \ {(0,0), (7,7)}
°
¹Z
Ü ÛBoardTilingİ ¦ ğBoard ¡ {i, j : ú · {(i, 2*j), (i, 2*j+1)}}
°
\section{THE THEOREM}
¹Z
Ü Ûran_colour_thmİ ?ô µu:ú ¸ ú · Colour u  {0, 1}
°
¹Z
Ü Ûadjacent_thmİ ?ô
Ü 	µx1, x2:ú ¸ ú · 
Ü		(x1, x2)  Adjacent
Ü 	¤	Abs(x1.1 - x2.1) = 1 ± x1.2 = x2.2
Ü	²	Abs(x1.2 - x2.2) = 1 ± x1.1 = x2.1
°
¹Z
Ü Ûadjacent_colour_thmİ ?ô µu, v:ú ¸ ú | (u, v)  Adjacent · Colour u ½ Colour v
°
¹Z
Ü Ûdomino_colour_thmİ ?ô 
Ü 	µx:Domino · ¶u, v:x · x = {u, v} ± Colour u = 0 ± Colour v = 1
°
¹Z
Ü Ûtiling_colour_thmİ ?ô
Ü	µz:Tiling · ¶f:{u:Şz | Colour u = 0}  {u:Şz|Colour u = 1} · true
°
¹Z
Ü Ûtiling_colour_size_thmİ ?ô
Ü	µz:Tiling | Şz  (æ_) · #{u:Şz | Colour u = 0} = #{u:Şz | Colour u = 1}
°

¹Z
Ü Ûboard_finite_thmİ ?ô Board  (æ_)
°

¹Z
Ü Ûboard_tiling_thmİ ?ô BoardTiling  Tiling ± ŞBoardTiling = Board
°
¹Z
Ü Ûcolours_on_board_thmİ ?ô
Ü	#{u:Board | Colour u = 0} = #{u:Board | Colour u = 1}
°
¹Z
Ü Ûcolours_on_mutilated_board_thmİ ?ô
Ü	#{u:MutilatedBoard|Colour u = 0} = #{u:Board | Colour u = 0} - 2
Ü ±	#{u:MutilatedBoard|Colour u = 1} = #{u:Board | Colour u = 1}
°
¹Z
Ü Ûmutilated_chessboard_thmİ ?ô ³(¶z: Tiling · MutilatedBoard = Şz)
°

\section{SUPPORTING THEORY}
\subsection{Absolute Values}

¹Z
Ü Ûz_abs_nat_thmİ ?ô (µi:ú · Abs i  î)
°
¹Z
Ü Ûz_abs_eq_0_thmİ ?ô µi, j:ú · Abs (i - j) = 0  ¤ i = j
°
¹Z
Ü Ûz_abs_eq_1_thmİ ?ô
Ü µi, j:ú ·
Ü	Abs (i - j) = 1
Ü ¤	i < j ± j = i + 1 ² j < i ± i = j + 1
°
\subsection{Remainders {\it modulo} 2}

¹Z
Ü Ûz_mod_2_thmİ ?ô µi, j:ú · i mod 2 = j ¤ j  {0, 1} ± (¶d:ƒ· i = 2*d + j)
°
¹Z
Ü Ûz_mod_2_thm1İ ?ô µi:ú · (2*i) mod 2 = 0 ± (2*i + 1) mod 2 = 1
°
¹Z
Ü Ûz_ran_mod_2_thmİ ?ô µi:ú · i mod 2  {0, 1}
°
¹Z
Ü Ûz_plus_1_mod_2_thmİ ?ô µi:ú · ³i mod 2 = (i + 1) mod 2
°
\subsection{Finite Cardinalities}

¹Z
Ü Ûz_size_pair_thmİ ?ô µx, y:ƒ | ³x = y · {x, y}  (æ_) ± #{x, y} = 2
°
¹Z
Ü Ûz_size_eq_thmİ ?ô µa, b:(æ_) | a € b ± #a = #b · a = b 
°
¹Z
Ü Ûz_size_2_thmİ ?ô µa:(æ_) · #a = 2 ¤ (¶x, y:ƒ·³x = y ± a = {x, y})
°
¹Z
Ü Ûz_size_product_thmİ ?ô µa : (æ_); b:(æ_) · a ¸ b  (æ_) ± #(a ¸ b) = #a * #b
°
¹Z
Ü Ûz_finite_subset_thmİ ?ô µa:(æ_); b: ƒ | b € a · b  (æ_)
°
¹Z
Ü Ûz_finite_size_thm1İ ?ô µa: (æ_) · (¶f:1 .. #a  a ·true)
°
=TEX
\end{document}
\newpage
\appendix
=TEX
{\HOLindexOff\small
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{mutcb.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
\printindex
=TEX
=SML
val Ûsquare_u_thmİ = pc_rule1 "z_sets_ext" prove_rule[get_specñú®]ñú ¸ ú = ƒ®;
=TEX
=SML
val Ûz_abs_defİ = z_get_specñAbs®;
val Ûadjacent_defİ = z_get_specñAdjacent®;
val Ûboard_defİ = z_get_specñBoard®;
val Ûmutilated_board_defİ = z_get_specñMutilatedBoard®;
val Ûdomino_defİ =
	rewrite_rule[square_u_thm](z_get_specñDomino®);

val Ûtiling_defİ =
	rewrite_rule[square_u_thm](z_get_specñTiling®);
val Ûcolour_defİ = z_get_specñColour®;
val Ûboard_tiling_defİ = z_get_specñBoardTiling®;
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_nat_thm");
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elimñi® z_ú_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN ALL_FC_T asm_rewrite_tac [z_abs_def]);
val Ûz_abs_nat_thmİ = save_pop_thm "z_abs_nat_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_eq_0_thm");
a(z_µ_tac THEN strip_tac);
a(strip_asm_tac(z_µ_elim ñi + ~j® z_ú_cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[z_abs_def]
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val Ûz_abs_eq_0_thmİ = save_pop_thm "z_abs_eq_0_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_eq_1_thm");
a(z_µ_tac THEN strip_tac);
a(strip_asm_tac(z_µ_elim ñi + ~j® z_ú_cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[z_abs_def]
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val Ûz_abs_eq_1_thmİ = save_pop_thm "z_abs_eq_1_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_mod_2_thm");
a(z_µ_tac THEN strip_tac);
a(LEMMA_T ñ³2 = 0® asm_tac THEN1 REPEAT strip_tac);
a(ALL_FC_T1 fc_¤_canon rewrite_tac
	[rewrite_rule[](conv_rule (MAP_C z_µ_elim_conv) (z_mod_thm))]);
a(REPEAT strip_tac THEN_TRY
	z_¶_tac ñd º ú® THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val Ûz_mod_2_thmİ = save_pop_thm "z_mod_2_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_mod_2_thm1");
a(z_µ_tac THEN strip_tac);
a(rewrite_tac[z_mod_2_thm]);
a(z_¶_tacñi® THEN REPEAT strip_tac);
val Ûz_mod_2_thm1İ = save_pop_thm "z_mod_2_thm1";
=TEX
=SML
set_goal([], get_conjecture "-" "z_ran_mod_2_thm");
a(contr_tac);
a(fc_tac[
	inst_term_rule [(ñi mod 2®, ñj º ú®)]
		(all_µ_elim (hd (fc_canon z_mod_2_thm)))]);
val Ûz_ran_mod_2_thmİ = save_pop_thm "z_ran_mod_2_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_plus_1_mod_2_thm");
a(REPEAT strip_tac);
a(lemma_tac¬¶j·ñ(i + 1) mod 2 = j®® THEN1 prove_¶_tac);
a(asm_rewrite_tac[] THEN POP_ASM_T ante_tac);
a(rewrite_tac[z_mod_2_thm] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN all_asm_ante_tac THEN rewrite_tac[] THEN contr_tac);
(* *** Goal "1" duplicates "2" *** *)
a(lemma_tacñ0 < d - d' < 1 ® THEN
	PC_T1 "z_lin_arith" asm_prove_tac[]);
val Ûz_plus_1_mod_2_thmİ = save_pop_thm "z_plus_1_mod_2_thm";
val Ûz_plus_1_mod_2_thm1İ =
	conv_rule (ONCE_MAP_C z_anf_conv) z_plus_1_mod_2_thm;
=TEX
=SML
val Ûz_æ_À_singleton_thm1İ = z_gen_pred_elim[ñƒ®] z_æ_À_singleton_thm;
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_pair_thm");
a(z_µ_tac THEN strip_tac);
a(lemma_tacñ{y}  (æ_) ± #{y} = 1® THEN1 rewrite_tac[z_size_singleton_thm]);
a(ante_tac (z_µ_elimñ(x ¦ x, a ¦ {y})® z_size_À_singleton_thm));
a(ante_tac (z_µ_elimñ(x ¦ x, a ¦ {y})® z_æ_À_singleton_thm1));
a(asm_rewrite_tac[z_size_singleton_thm]);
a(LEMMA_T ñ{x, y} = {y} À {x}® rewrite_thm_tac
	THEN PC_T1 "z_sets_ext" prove_tac[]);
val Ûz_size_pair_thmİ = save_pop_thm "z_size_pair_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_eq_thm");
a(PC_T "z_sets_ext" contr_tac
	THEN1 all_asm_fc_tac[]);
a(lemma_tacña € a À {x1} ± a À {x1} € b® THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(strip_asm_tac (z_µ_elimñ(x ¦ x1, a ¦ a)® z_size_À_singleton_thm));
a(strip_asm_tac (z_µ_elimñ(x ¦ x1, a ¦ a)® z_æ_À_singleton_thm1));
a(strip_asm_tac (z_µ_elimñ(a ¦ b, b ¦ a À {x1})® z_size_mono_thm));
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
val Ûz_size_eq_thmİ = save_pop_thm "z_size_eq_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_2_thm");
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_sets_ext" lemma_tac ñ³a = {}®
	THEN1 (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[z_size_empty_thm]));
a(PC_T1 "z_sets_ext" lemma_tac ñ³a = {x1}®
	THEN1 (swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[z_size_singleton_thm])
	THEN_TRY all_var_elim_asm_tac1);
a(lemma_tacñ{x2, x1}  (æ_) ± #{x2, x1} = 2® THEN1
	ALL_FC_T rewrite_tac[z_size_pair_thm]);
a(LEMMA_Tñ{x2, x1} € a® asm_tac THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(ante_tac (z_µ_elimñ(a ¦ {x2, x1}, b ¦ a)® z_size_eq_thm));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(z_¶_tacñ(x ¦ x2, y ¦ x1)® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(ALL_FC_T asm_rewrite_tac[z_size_pair_thm]);
val Ûz_size_2_thmİ = save_pop_thm "z_size_2_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_product_thm");
a(z_µ_tac THEN strip_tac);
a(z_æ_induction_tacña®);
(* *** Goal "1" *** *)
a(rewrite_tac[z_size_empty_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[
	pc_rule1 "z_library_ext"
		prove_rule[] ñ(a À {x}) ¸ b = (a ¸ b) À ({x} ¸ b)®]);
a(lemma_tacñ(a ¸ b) ¡ ({x} ¸ b) = {}® THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(lemma_tacñ({x} ¸ b)  (æ_) ± #({x} ¸ b) = #b®);
(* *** Goal "2.1" *** *)
a(LIST_DROP_NTH_ASM_T [1, 2, 3, 4, 5] discard_tac);
a(z_æ_induction_tacñb®
	THEN1 rewrite_tac[z_size_empty_thm]);
a(rewrite_tac[
	pc_rule1 "z_library_ext"
		prove_rule[] ñ{x} ¸ (b À {x'}) = ({x} ¸ b) À {(x, x')}®]);
a(LEMMA_Tñ³(x, x')  ({x} ¸ b)® asm_tac THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(ante_tac (z_µ_elimñ(x ¦ (x, x'), a ¦ {x} ¸ b)® z_size_À_singleton_thm));
a(ante_tac (z_µ_elimñ(x ¦ x', a ¦ b)® z_size_À_singleton_thm));
a(ante_tac (z_µ_elimñ(x ¦ (x, x'), a ¦ {x} ¸ b)® z_æ_À_singleton_thm1));
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(ante_tac (z_µ_elimñ(a ¦ a ¸ b, b ¦ {x} ¸ b)® z_size_À_thm));
a(asm_rewrite_tac[z_size_empty_thm]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[z_size_À_singleton_thm]);
a(PC_T1 "z_lin_arith" prove_tac[]);
val Ûz_size_product_thmİ = save_pop_thm "z_size_product_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_finite_subset_thm");
a(REPEAT strip_tac);
a(LEMMA_Tñb = a \ {x:a|³x  b}® once_rewrite_thm_tac
	THEN1 PC_T1 "z_sets_ext" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[z_æ_diff_thm]);
val Ûz_finite_subset_thmİ = save_pop_thm "z_finite_subset_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_finite_size_thm1");
a(REPEAT strip_tac);
a(z_æ_induction_tac ña®);
(* *** Goal "1" *** *)
a(rewrite_tac[z_size_empty_thm] THEN REPEAT strip_tac);
a(z_¶_tacñ{}® THEN PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "2" *** *)
a(all_fc_tac[z_size_À_singleton_thm, z_size_î_thm]);
a(asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) z_dot_dot_À_thm]);
a(z_¶_tacñf À {(#a + 1, x)}® THEN rewrite_tac[]);
a(bc_thm_tac
	(rewrite_rule[](conv_rule (MAP_C z_µ_elim_conv) (z_À__thm))));
a(asm_rewrite_tac[
	pc_rule1 "z_library_ext" prove_rule[]
		ñµx:ƒ; y:ƒ·{(x, y)}  {x}  {y}®]);
a(PC_T1 "z_library_ext" REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
val Ûz_finite_size_thm1İ = save_pop_thm "z_finite_size_thm1";
=TEX
=SML
set_goal([], get_conjecture "-" "ran_colour_thm");
a(rewrite_tac[colour_def,
	rewrite_rule[]z_ran_mod_2_thm]);
val Ûran_colour_thmİ = save_pop_thm "ran_colour_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "adjacent_thm");
a(z_µ_tac THEN strip_tac THEN rewrite_tac[adjacent_def]);
a(lemma_tacñAbs (x1.1 + ~ x2.1)  î ± Abs (x1.2 + ~ x2.2)  î®
	THEN1 rewrite_tac[z_abs_nat_thm]);
a(LEMMA_Tñµi, j:î·
	i + j = 1 ¤ i = 1 ± j = 0 ² i = 0 ± j = 1®
	(fn th => ALL_FC_T1 fc_¤_canon rewrite_tac[th])
	THEN1 PC_T1 "z_lin_arith" prove_tac[]);
a(rewrite_tac[rewrite_rule[] z_abs_eq_0_thm] THEN PC_T1 "z_lin_arith" prove_tac[]);
val Ûadjacent_thmİ = save_pop_thm "adjacent_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "adjacent_colour_thm");
a(rewrite_tac[adjacent_thm, colour_def, z_abs_eq_1_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (asm_tac o eq_sym_rule) 
	THEN asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm1]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN conv_tac (RAND_C eq_sym_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm1]);
(* *** Goal "3" *** *)
a(POP_ASM_T (asm_tac o eq_sym_rule) 
	THEN asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm1]);
(* *** Goal "4" *** *)
a(asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN conv_tac (RAND_C eq_sym_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm1]);
val Ûadjacent_colour_thmİ = save_pop_thm "adjacent_colour_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "domino_colour_thm");
a(z_µ_tac THEN rewrite_tac[domino_def]
	THEN REPEAT strip_tac);
a(all_fc_tac[z_size_2_thm] THEN1 all_var_elim_asm_tac1);
a(z_spec_nth_asm_tac 2 ñ(x1 ¦ x', x2 ¦ y)®);
a(all_fc_tac[adjacent_colour_thm]);
a(strip_asm_tac (z_µ_elimñx'® ran_colour_thm));
(* *** Goal "1" *** *)
a(z_¶_tacñ(u¦x', v¦y)® THEN asm_rewrite_tac[]);
a(strip_asm_tac (z_µ_elimñy® ran_colour_thm));
a(swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(z_¶_tacñ(u¦y, v¦x')® THEN asm_rewrite_tac[]);
a(PC_T1 "z_sets_ext" REPEAT strip_tac);
a(strip_asm_tac (z_µ_elimñy® ran_colour_thm));
a(swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[]);
val Ûdomino_colour_thmİ = save_pop_thm "domino_colour_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "board_finite_thm");
a(rewrite_tac[board_def]);
a(lemma_tacñ0 .. 7  (æ_)®
	THEN1 rewrite_tac[z_size_dot_dot_thm1]);
a(all_fc_tac[z_size_product_thm]);
val Ûboard_finite_thmİ = save_pop_thm "board_finite_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "tiling_colour_thm");
a(REPEAT strip_tac);
a(z_¶_tacñ
	{	d:z; u, v:ú ¸ ú
	|	d = {u, v};
		Colour u = 0;
		Colour v = 1
	·	(u, v) } ®);
a(rewrite_tac[z_à_thm1, z_ï_thm, z__def,
	z_­_thm, z_ß_thm, z_ª_thm]);
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[tiling_def]));
a(REPEAT strip_tac);
(* *** Goal "1" duplicates "5" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(z_¶_tacñ{(x1, x2), (x3, x4)}® THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(z_¶_tacñ{(x1, x2), (x3, x4)}® THEN asm_rewrite_tac[]);
(* *** Goal "2" duplicates "6" *** *)
a(lemma_tacñ³{x, y1} ¡ {x, y2} = {}®
	THEN1 PC_T1 "z_sets_ext" prove_tac[]);
a(z_spec_nth_asm_tac 13 ñ(x¦{x, y1}, y¦{x, y2})®);
a(POP_ASM_T ante_tac THEN rewrite_tac[
	pc_rule1 "z_sets_ext" prove_rule[]
	ñµa, b:ƒ·a = b ¤ (µx:ƒ·x  a ¤ x  b)®]);
a(STRIP_T (ante_tac o z_µ_elimñy1®));
a(LEMMA_T ñ³y1 = x® rewrite_thm_tac
	THEN1 (contr_tac THEN all_var_elim_asm_tac));
a(DROP_NTH_ASM_T 7 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(z_¶_tacñ{(x1, x2), y}® THEN asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(PC_T1 "z_sets_ext" all_asm_fc_tac[]);
a(all_fc_tac[domino_colour_thm]);
a(z_¶_tacñv® THEN asm_rewrite_tac[]);
a(lemma_tacñ³(x1, x2) = v® 
	THEN1 (contr_tac
	THEN all_var_elim_asm_tac1
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]));
a(PC_T "z_predicates" all_var_elim_asm_tac1);
a(LEMMA_Tñ(x1, x2) = u® asm_rewrite_thm_tac);
a(DROP_NTH_ASM_T 8 strip_asm_tac);
(* *** Goal "4" duplicates "7" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(z_¶_tacñ{x, (x1, x2)}® THEN asm_rewrite_tac[]);
(* *** Goal "4.2" *** *)
a(PC_T1 "z_sets_ext" all_asm_fc_tac[]);
a(all_fc_tac[domino_colour_thm]);
a(z_¶_tacñu® THEN asm_rewrite_tac[]);
a(lemma_tacñ³(x1, x2) = u® 
	THEN1 (contr_tac
	THEN all_var_elim_asm_tac1
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]));
a(PC_T "z_predicates" all_var_elim_asm_tac1);
a(LEMMA_Tñ(x1, x2) = v® asm_rewrite_thm_tac);
a(DROP_NTH_ASM_T 8 strip_asm_tac);
(* *** Goal "8" ("5", "6", "7" were duplicates) *** *)
a(lemma_tacñ³{x, z'} ¡ {y, z'} = {}®
	THEN1 PC_T1 "z_sets_ext" prove_tac[]);
a(z_spec_nth_asm_tac 7 ñ(x¦{x, z'}, y¦{y, z'})®);
a(POP_ASM_T ante_tac THEN rewrite_tac[
	pc_rule1 "z_sets_ext" prove_rule[]
	ñµa, b:ƒ·a = b ¤ (µx:ƒ·x  a ¤ x  b)®]);
a(STRIP_T (ante_tac o z_µ_elimñx®));
a(rewrite_tac[]);
a(LEMMA_T ñ³x = z'® rewrite_thm_tac
	THEN1 (contr_tac THEN all_var_elim_asm_tac));
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
val Ûtiling_colour_thmİ = save_pop_thm "tiling_colour_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "tiling_colour_size_thm");
a(REPEAT strip_tac);
a(all_fc_tac[tiling_colour_thm]);
a(lemma_tacñ{u : Ş z | Colour u = 0} € Şz®
	THEN1 PC_T1 "z_sets_ext" prove_tac[]);
a(all_fc_tac[z_finite_subset_thm]);
a(LIST_DROP_NTH_ASM_T [2, 4, 5] discard_tac);
a(all_fc_tac[z_finite_size_thm1, z_size_î_thm]);
a(all_fc_tac[z_o__thm]);
a(all_fc_tac[z_æ_size_thm] THEN asm_rewrite_tac[]);
val Ûtiling_colour_size_thmİ = save_pop_thm "tiling_colour_size_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "board_tiling_thm");
a(lemma_tacñµi, j:ƒ·³2*i = 2*j + 1® THEN1
	(contr_tac THEN LEMMA_T
	ñ(2 * i) mod 2 = (2 * j + 1) mod 2® ante_tac
	THEN1 asm_rewrite_tac[]
	THEN rewrite_tac[z_mod_2_thm1]));
a(TOP_ASM_T (strip_asm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
a(rewrite_tac[board_tiling_def, tiling_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T "z_sets_ext" strip_tac
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
a(rewrite_tac[domino_def, adjacent_thm,
	rewrite_rule[]z_abs_eq_1_thm]);
a(LEMMA_Tñ³(i, 2 * j) = (i, 2 * j + 1)® asm_tac
	THEN1 rewrite_tac[]);
a(ALL_FC_T rewrite_tac[z_size_pair_thm]);
a(REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1
	THEN_TRY asm_rewrite_tac[]
	THEN all_asm_ante_tac
	THEN_TRY rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
(* Just stripping gives 64 subgoals here *)
a(POP_ASM_T ante_tac THEN
	LIST_DROP_NTH_ASM_T [5, 6]
	(fn ths => 
	PC_T1 "z_library_ext" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1
	THEN_TRY asm_rewrite_tac[]
	THEN all_asm_ante_tac
	THEN_TRY rewrite_tac ths
	THEN MAP_EVERY asm_tac ths
	THEN REPEAT strip_tac
	THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]));
(* *** Goal "3" *** *)
a(rewrite_tac[
	pc_rule1 "z_sets_ext" prove_rule[]
		ñ(µa:ƒ; b:ƒ· Ş(ğa ¡ b) € a)
		± (µa:ƒ; b:ƒ· a = b ¤ a € b ± b € a)®]);
a(PC_T "z_sets_ext" strip_tac
	THEN rewrite_tac[board_def]
	THEN REPEAT strip_tac);
a(LEMMA_T ñx2 mod 2 = x2 mod 2® ante_tac
	THEN1 REPEAT strip_tac);
a(pure_rewrite_tac[z_mod_2_thm]);
a(REPEAT strip_tac
	THEN POP_ASM_T ante_tac
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.1" *** *)
a(z_¶_tacñ{(x1, 2 * d), (x1, 2 * d + 1)}®
	THEN rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "3.1.1" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3.1.2" *** *)
a(LEMMA_Tñ³2*d = 2*3+1® (strip_asm_tac o rewrite_rule[])
	THEN1 (pure_asm_rewrite_tac[] THEN REPEAT strip_tac));
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3.1.3" *** *)
a(z_¶_tacñ(i¦x1, j¦d)®
	THEN PC_T1 "z_library_ext" asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(z_¶_tacñ{(x1, 2 * d), (x1, 2 * d + 1)}®
	THEN rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "3.2.1" *** *)
a(LEMMA_Tñ³2*d + 1 = 2*0® (strip_asm_tac o rewrite_rule[])
	THEN1 (pure_asm_rewrite_tac[] THEN REPEAT strip_tac));
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.2" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.3" *** *)
a(z_¶_tacñ(i¦x1, j¦d)®
	THEN PC_T1 "z_library_ext" asm_rewrite_tac[]);
val Ûboard_tiling_thmİ = save_pop_thm "board_tiling_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "colours_on_board_thm");
a(strip_asm_tac board_tiling_thm);
a(lemma_tacñŞ BoardTiling  (æ_)® THEN1
	asm_rewrite_tac[board_finite_thm]);
a(ALL_FC_T (MAP_EVERY ante_tac) [tiling_colour_size_thm]);
a(asm_rewrite_tac[]);
val Ûcolours_on_board_thmİ = save_pop_thm "colours_on_board_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "colours_on_mutilated_board_thm");
a(LEMMA_T ñ
	{u : MutilatedBoard | Colour u = 0} =
	{u : Board | Colour u = 0} \ {(0, 0), (7, 7)}
±	{u : MutilatedBoard | Colour u = 1} =
	{u : Board | Colour u = 1}®
	rewrite_thm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[board_def, mutilated_board_def]
	THEN PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(swap_nth_asm_concl_tac 2 THEN
	asm_rewrite_tac[colour_def]);
(* *** Goal "1.2" *** *)
a(swap_nth_asm_concl_tac 2 THEN
	asm_rewrite_tac[colour_def]);
(* *** Goal "2" *** *)
a(LEMMA_T ñ{(0, 0), (7, 7)} € {u : Board | Colour u = 0}® asm_tac);
(* *** Goal "2.1" *** *)
a(PC_T1 "z_sets_ext" rewrite_tac[board_def]);
a(rewrite_tac[colour_def]);
(* *** Goal "2.2" *** *)
a(lemma_tac ñ{u : Board | Colour u = 0} € Board®
	THEN1 PC_T1 "z_sets_ext" prove_tac[]);
a(strip_asm_tac board_finite_thm);
a(all_fc_tac[z_finite_subset_thm]);
a(LEMMA_Tñ³(0, 0) = (7, 7)® asm_tac
	THEN1 REPEAT strip_tac);
a(all_fc_tac[z_size_pair_thm]);
a(ante_tac (
	z_µ_elim ñ(a¦{u : Board | Colour u = 0}, b¦{(0, 0), (7, 7)})® z_size_diff_thm
)
	THEN asm_rewrite_tac[]);
a(ALL_FC_T asm_rewrite_tac[
	pc_rule1 "z_sets_ext" prove_rule[]
	ñµa, b: ƒ· b € a ´ a ¡ b = b®]);
a(PC_T1 "z_lin_arith" prove_tac[]);
val Ûcolours_on_mutilated_board_thmİ = save_pop_thm "colours_on_mutilated_board_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "mutilated_chessboard_thm");
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN contr_tac);
a(lemma_tacñŞz € Board® THEN1
	(asm_rewrite_tac[mutilated_board_def]
	THEN PC_T1 "z_sets_ext" prove_tac[]));
a(strip_asm_tac board_finite_thm);
a(all_fc_tac[z_finite_subset_thm]);
a(ALL_FC_T (MAP_EVERY ante_tac) [tiling_colour_size_thm]);
a(ante_tac colours_on_mutilated_board_thm
	THEN asm_rewrite_tac[colours_on_board_thm]);
a(PC_T1 "z_lin_arith" prove_tac[]);
val Ûmutilated_chessboard_thmİ = save_pop_thm "mutilated_chessboard_thm";
=TEX
=SML

=TEX
\section{Epilogue}
=TEX
=SML
fun check_conjecture name = (
	if	let	val tm = get_conjecture "-" name;
			val thm = get_thm "-" name;
		in	is_nil (asms thm)
		andalso	tm =$ concl thm
		end	handle Fail _ => false
	then	(delete_conjecture name;
		true)
	else	(diag_line ("Conjecture " ^ name ^ " has not been proved");
		false)
);
if all (map (check_conjecture)
	(map (hd o fst) (get_conjectures "-")))
	(fn x => x)
then	diag_line "All conjectures have been proved."
else	();
=SML
z_output_theory{out_file="mutcb.th.doc", theory="-"};
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
=TEX
\end{document}
=IGN
