=IGN
=TEX
\documentclass[12pt]{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\def\Hide#1{\relax}
\title{Mutilated Chessboard \\ (DRAFT)}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\begin{abstract}
John McCarthy's Mutilated Chessboard problem in set theory, more specifically Z.
\end{abstract}
\section{INTRODUCTION}\label{Intro}

\Hide{
The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"z_library";
set_pc"z_library1";
force_delete_theory"mutcb" handle Fail _ => ();
new_theory"mutcb";
=TEX
}
\newpage
\section{THE SPECIFICATION}
πZAX
‹ €Abs› : ˙ ≠ ˙
˜¸¸¸¸¸¸
‹ Abs = {i, a:˙ | i æ 0 ± a = i ≤ i < 0 ± a = ~i}
∞
πZ
‹ €Square› ¶ ˙ ∏ ˙
∞

πZAX
‹ €Adjacent› : (Square ∏ Square)
˜¸¸¸¸¸¸
‹ µx1, x2:Square ∑
‹	(x1, x2) ç Adjacent
‹ §	Abs(x1.1 - x2.1) = 1 ± x1.2 = x2.2
‹ ≤	Abs(x1.2 - x2.2) = 1 ± x1.1 = x2.1
∞
πZAX
‹ €Domino› : ( Square)
˜¸¸¸¸¸¸
‹ µx: Square ∑
‹	x ç Domino
‹ §	x ç Ê Square ± #x = 2
‹ ±	(µx1, x2:Square∑x1 Ω x2 ± x1 ç x ± x2 ç x ¥ (x1, x2) ç Adjacent)
∞
πZAX
‹ €Tiling› : (( Square))
˜¸¸¸¸¸¸
‹ µz:( Square) ∑ z ç Tiling § z Ä Domino ± (µx, y:z ∑ x = y ≤ x ° y = {})
∞
πZAX
‹ €Colour› : Square ≠ ˙
˜¸¸¸¸¸¸
‹ µx: Square ∑ Colour x = (x.1 + x.2) mod 2
∞
πZ
‹ €Board› ¶ (0 .. 7) ∏ (0 .. 7)
∞
πZ
‹ €MutilatedBoard› ¶ Board \ {(0,0), (7,7)}
∞
πZ
‹ €BoardTiling› ¶ {i, j : ˙ | i ç 0 .. 7 ± j ç 0 .. 3 ∑ {(i, 2*j), (i, 2*j+1)}}
∞
\section{THEOREMS}
\subsection{Main Proof}
πZ
‹ €domino_colour_thm› ?Ù 
‹ 	µx:Domino ∑ ∂u, v:x ∑ x = {u, v} ± Colour u = 0 ± Colour v = 1
∞
πZ
‹ €tiling_colour_thm› ?Ù
‹	µz:Tiling ∑ ∂f:{u:ﬁz | Colour u = 0} è {u:ﬁz|Colour u = 1} ∑ true
∞
πZ
‹ €tiling_colour_size_thm› ?Ù
‹	µz:Tiling | ﬁz ç (Ê_) ∑ #{u:ﬁz | Colour u = 0} = #{u:ﬁz | Colour u = 1}
∞
πZ
‹ €board_tiling_thm› ?Ù
‹ 	BoardTiling ç Tiling ± ﬁBoardTiling = Board
∞
πZ
‹ €colours_on_board_thm› ?Ù
‹	#{u:Board | Colour u = 0} = #{u:Board | Colour u = 1}
∞
πZ
‹ €colours_on_mutilated_board_thm› ?Ù
‹	#{u:MutilatedBoard|Colour u = 0} = #{u:Board | Colour u = 0} - 2
‹ ±	#{u:MutilatedBoard|Colour u = 1} = #{u:Board | Colour u = 1}
∞
πZ
‹ €mutilated_chessboard_thm› ?Ù
‹ ≥(∂z:( Square) ∑ z ç Tiling ±  MutilatedBoard = ﬁz)
∞

\subsection{Extras}
πZ
‹ €adjacent_trick_thm› ?Ù
‹ 	µx1, x2:Square ∑ 
‹		(x1, x2) ç Adjacent
‹ 	§	Abs(x1.1 - x2.1) + Abs(x1.2 - x2.2) = 1
∞

πZ
‹ €board_finite_thm› ?Ù Board ç (Ê_)
∞
πZ
‹ €adjacent_colour_thm› ?Ù µu, v:Square ∑(u, v) ç Adjacent ¥ Colour u Ω Colour v
∞
πZ
‹ €ran_colour_thm› ?Ù µu:Square ∑ Colour u ç {0, 1}
∞

\subsection{Supporting Theory}
πZ
‹ €z_abs_eq_thm› ?Ù µi, j:˙ ∑ Abs i = j § (i, j) ç Abs
∞
πZ
‹ €z_abs_clauses› ?Ù
‹	Abs 0 = 0
‹ ±	(µm:Ó ∑ Abs m = m ± Abs (~m) = m)
∞
πZ
‹ €z_abs_nat_thm› ?Ù (µi:˙ ∑ Abs i ç Ó)
∞
πZ
‹ €z_abs_eq_0_thm› ?Ù µi, j:˙ ∑ Abs (i - j) = 0  § i = j
∞
πZ
‹ €z_abs_eq_1_thm› ?Ù
‹ µi, j:˙ ∑
‹	Abs (i - j) = 1
‹ §	i < j ± j = i + 1 ≤ j < i ± i = j + 1
∞
πZ
‹ €z_mod_2_thm› ?Ù
‹ µi, j:˙ ∑ i mod 2 = j § j ç {0, 1} ± (∂d:É∑ i = 2*d + j)
∞
πZ
‹ €z_mod_2_thm1› ?Ù
‹ µi:˙ ∑ (2*i) mod 2 = 0 ± (2*i + 1) mod 2 = 1
∞
πZ
‹ €z_ran_mod_2_thm› ?Ù µi:˙ ∑ i mod 2 ç {0, 1}
∞
πZ
‹ €z_plus_1_mod_2_thm› ?Ù µi:˙ ∑ ≥i mod 2 = (i + 1) mod 2
∞
πZ
‹ €z_size_pair_thm› ?Ù µx, y:É | ≥x = y ∑ {x, y} ç (Ê_) ± #{x, y} = 2
∞
πZ
‹ €z_size_eq_thm› ?Ù µa, b:(Ê_) | a Ä b ± #a = #b ∑ a = b 
∞
πZ
‹ €z_size_2_thm› ?Ù µa:(Ê_) ∑ #a = 2 § (∂x, y:É∑≥x = y ± a = {x, y})
∞
πZ
‹ €z_size_product_thm› ?Ù µa : (Ê_); b:(Ê_) ∑ a ∏ b ç (Ê_) ± #(a ∏ b) = #a * #b
∞
πZ
‹ €z_finite_subset_thm› ?Ù µa:(Ê_); b: É | b Ä a ∑ b ç (Ê_)
∞
πZ
‹ €z_finite_size_thm1› ?Ù µa: (Ê_) ∑ (∂f:1 .. #a è a ∑true)
∞
=TEX
\newpage
\appendix
=TEX
{\HOLindexOff\small
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{mutcb.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
\printindex
=TEX
\end{document}
=SML
val €square_def› = z_get_specÒSquareÆ;
val €square_u_thm› = pc_rule1 "z_sets_ext" prove_rule[get_specÒ˙Æ, square_def]ÒSquare = ÉÆ;
=TEX
=SML
val €z_abs_def› = z_get_specÒAbsÆ;
val €adjacent_def› = z_get_specÒAdjacentÆ;
val €board_def› = z_get_specÒBoardÆ;
val €mutilated_board_def› = z_get_specÒMutilatedBoardÆ;
val €domino_def› =
	rewrite_rule[square_u_thm](z_get_specÒDominoÆ);

val €tiling_def› =
	rewrite_rule[square_u_thm](z_get_specÒTilingÆ);
val €colour_def› = z_get_specÒColourÆ;
val €board_tiling_def› = z_get_specÒBoardTilingÆ;
=TEX
=SML
delete_pc"'mutcb" handle Fail _ => ();
new_pc "'mutcb";
set_u_simp_eqn_cxt (u_simp_eqn_cxt [square_u_thm]) "'mutcb";
set_merge_pcs["'mutcb", "z_library1"];
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_eq_thm");
a(z_µ_tac THEN strip_tac);
a(bc_thm_tac
	(rewrite_rule[](conv_rule (MAP_C z_µ_elim_conv) (z_≠_app_eq_§_ç_rel_thm))));
a(∂_tacÒ˙Æ THEN ∂_tacÒ˙Æ THEN rewrite_tac[z_abs_def]);
val €z_abs_eq_thm› = save_pop_thm "z_abs_eq_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_clauses");
a(rewrite_tac[z_abs_eq_thm]);
a(rewrite_tac[z_abs_def]);
a(PC_T1 "z_lin_arith" prove_tac[]);
val €z_abs_clauses› = save_pop_thm "z_abs_clauses";
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_nat_thm");
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elimÒiÆ z_˙_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN ALL_FC_T asm_rewrite_tac [z_abs_clauses]);
val €z_abs_nat_thm› = save_pop_thm "z_abs_nat_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_eq_0_thm");
a(z_µ_tac THEN strip_tac);
a(strip_asm_tac(z_µ_elim Òi + ~jÆ z_˙_cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[z_abs_clauses]
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val €z_abs_eq_0_thm› = save_pop_thm "z_abs_eq_0_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_eq_1_thm");
a(z_µ_tac THEN strip_tac);
a(strip_asm_tac(z_µ_elim Òi + ~jÆ z_˙_cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[z_abs_clauses]
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val €z_abs_eq_1_thm› = save_pop_thm "z_abs_eq_1_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_mod_2_thm");
a(z_µ_tac THEN strip_tac);
a(LEMMA_T Ò≥2 = 0Æ asm_tac THEN1 REPEAT strip_tac);
a(ALL_FC_T1 fc_§_canon rewrite_tac
	[rewrite_rule[](conv_rule (MAP_C z_µ_elim_conv) (z_mod_thm))]);
a(REPEAT strip_tac THEN_TRY
	z_∂_tac Òd ∫ ˙Æ THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val €z_mod_2_thm› = save_pop_thm "z_mod_2_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_mod_2_thm1");
a(z_µ_tac THEN strip_tac);
a(rewrite_tac[z_mod_2_thm]);
a(z_∂_tacÒiÆ THEN REPEAT strip_tac);
val €z_mod_2_thm1› = save_pop_thm "z_mod_2_thm1";
=TEX
=SML
set_goal([], get_conjecture "-" "z_ran_mod_2_thm");
a(contr_tac);
a(fc_tac[
	inst_term_rule [(Òi mod 2Æ, Òj ∫ ˙Æ)]
		(all_µ_elim (hd (fc_canon z_mod_2_thm)))]);
val €z_ran_mod_2_thm› = save_pop_thm "z_ran_mod_2_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_plus_1_mod_2_thm");
a(REPEAT strip_tac);
a(lemma_tac¨∂j∑Ò(i + 1) mod 2 = jÆÆ THEN1 prove_∂_tac);
a(asm_rewrite_tac[] THEN POP_ASM_T ante_tac);
a(rewrite_tac[z_mod_2_thm] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN all_asm_ante_tac THEN rewrite_tac[] THEN contr_tac);
(* *** Goal "1" duplicates "2" *** *)
a(lemma_tacÒ0 < d - d' < 1 Æ THEN
	PC_T1 "z_lin_arith" asm_prove_tac[]);
val €z_plus_1_mod_2_thm› = save_pop_thm "z_plus_1_mod_2_thm";
val €z_plus_1_mod_2_thm1› =
	conv_rule (ONCE_MAP_C z_anf_conv) z_plus_1_mod_2_thm;
=TEX
=SML
val €z_Ê_¿_singleton_thm1› = z_gen_pred_elim[ÒÉÆ] z_Ê_¿_singleton_thm;
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_pair_thm");
a(z_µ_tac THEN strip_tac);
a(lemma_tacÒ{y} ç (Ê_) ± #{y} = 1Æ THEN1 rewrite_tac[z_size_singleton_thm]);
a(ante_tac (z_µ_elimÒ(x ¶ x, a ¶ {y})Æ z_size_¿_singleton_thm));
a(ante_tac (z_µ_elimÒ(x ¶ x, a ¶ {y})Æ z_Ê_¿_singleton_thm1));
a(asm_rewrite_tac[z_size_singleton_thm]);
a(LEMMA_T Ò{x, y} = {y} ¿ {x}Æ rewrite_thm_tac
	THEN PC_T1 "z_sets_ext" prove_tac[]);
val €z_size_pair_thm› = save_pop_thm "z_size_pair_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_eq_thm");
a(PC_T "z_sets_ext" contr_tac
	THEN1 all_asm_fc_tac[]);
a(lemma_tacÒa Ä a ¿ {x1} ± a ¿ {x1} Ä bÆ THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(strip_asm_tac (z_µ_elimÒ(x ¶ x1, a ¶ a)Æ z_size_¿_singleton_thm));
a(strip_asm_tac (z_µ_elimÒ(x ¶ x1, a ¶ a)Æ z_Ê_¿_singleton_thm1));
a(strip_asm_tac (z_µ_elimÒ(a ¶ b, b ¶ a ¿ {x1})Æ z_size_mono_thm));
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
val €z_size_eq_thm› = save_pop_thm "z_size_eq_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_2_thm");
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_sets_ext" lemma_tac Ò≥a = {}Æ
	THEN1 (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[z_size_empty_thm]));
a(PC_T1 "z_sets_ext" lemma_tac Ò≥a = {x1}Æ
	THEN1 (swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[z_size_singleton_thm])
	THEN_TRY all_var_elim_asm_tac1);
a(lemma_tacÒ{x2, x1} ç (Ê_) ± #{x2, x1} = 2Æ THEN1
	ALL_FC_T rewrite_tac[z_size_pair_thm]);
a(LEMMA_TÒ{x2, x1} Ä aÆ asm_tac THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(ante_tac (z_µ_elimÒ(a ¶ {x2, x1}, b ¶ a)Æ z_size_eq_thm));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(z_∂_tacÒ(x ¶ x2, y ¶ x1)Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(ALL_FC_T asm_rewrite_tac[z_size_pair_thm]);
val €z_size_2_thm› = save_pop_thm "z_size_2_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_product_thm");
a(z_µ_tac THEN strip_tac);
a(z_Ê_induction_tacÒaÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[z_size_empty_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[
	pc_rule1 "z_library_ext"
		prove_rule[] Ò(a ¿ {x}) ∏ b = (a ∏ b) ¿ ({x} ∏ b)Æ]);
a(lemma_tacÒ(a ∏ b) ° ({x} ∏ b) = {}Æ THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(lemma_tacÒ({x} ∏ b) ç (Ê_) ± #({x} ∏ b) = #bÆ);
(* *** Goal "2.1" *** *)
a(LIST_DROP_NTH_ASM_T [1, 2, 3, 4, 5] discard_tac);
a(z_Ê_induction_tacÒbÆ
	THEN1 rewrite_tac[z_size_empty_thm]);
a(rewrite_tac[
	pc_rule1 "z_library_ext"
		prove_rule[] Ò{x} ∏ (b ¿ {x'}) = ({x} ∏ b) ¿ {(x, x')}Æ]);
a(LEMMA_TÒ≥(x, x') ç ({x} ∏ b)Æ asm_tac THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(ante_tac (z_µ_elimÒ(x ¶ (x, x'), a ¶ {x} ∏ b)Æ z_size_¿_singleton_thm));
a(ante_tac (z_µ_elimÒ(x ¶ x', a ¶ b)Æ z_size_¿_singleton_thm));
a(ante_tac (z_µ_elimÒ(x ¶ (x, x'), a ¶ {x} ∏ b)Æ z_Ê_¿_singleton_thm1));
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(ante_tac (z_µ_elimÒ(a ¶ a ∏ b, b ¶ {x} ∏ b)Æ z_size_¿_thm));
a(asm_rewrite_tac[z_size_empty_thm]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[z_size_¿_singleton_thm]);
a(PC_T1 "z_lin_arith" prove_tac[]);
val €z_size_product_thm› = save_pop_thm "z_size_product_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_finite_subset_thm");
a(REPEAT strip_tac);
a(LEMMA_TÒb = a \ {x:a|≥x ç b}Æ once_rewrite_thm_tac
	THEN1 PC_T1 "z_sets_ext" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[z_Ê_diff_thm]);
val €z_finite_subset_thm› = save_pop_thm "z_finite_subset_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_finite_size_thm1");
a(REPEAT strip_tac);
a(z_Ê_induction_tac ÒaÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[z_size_empty_thm] THEN REPEAT strip_tac);
a(z_∂_tacÒ{}Æ THEN PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "2" *** *)
a(all_fc_tac[z_size_¿_singleton_thm, z_size_Ó_thm]);
a(asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) z_dot_dot_¿_thm]);
a(z_∂_tacÒf ¿ {(#a + 1, x)}Æ THEN rewrite_tac[]);
a(bc_thm_tac
	(rewrite_rule[](conv_rule (MAP_C z_µ_elim_conv) (z_¿_è_thm))));
a(asm_rewrite_tac[
	pc_rule1 "z_library_ext" prove_rule[]
		Òµx:É; y:É∑{(x, y)} ç {x} è {y}Æ]);
a(PC_T1 "z_library_ext" REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
val €z_finite_size_thm1› = save_pop_thm "z_finite_size_thm1";
=TEX
=SML
set_goal([], get_conjecture "-" "ran_colour_thm");
a(rewrite_tac[colour_def,
	rewrite_rule[]z_ran_mod_2_thm]);
val €ran_colour_thm› = save_pop_thm "ran_colour_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "adjacent_colour_thm");
a(rewrite_tac[adjacent_def, colour_def, z_abs_eq_1_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (asm_tac o eq_sym_rule) 
	THEN asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm1]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN conv_tac (RAND_C eq_sym_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm1]);
(* *** Goal "3" *** *)
a(POP_ASM_T (asm_tac o eq_sym_rule) 
	THEN asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm1]);
(* *** Goal "4" *** *)
a(asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN conv_tac (RAND_C eq_sym_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm1]);
val €adjacent_colour_thm› = save_pop_thm "adjacent_colour_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "domino_colour_thm");
a(z_µ_tac THEN rewrite_tac[domino_def]
	THEN REPEAT strip_tac);
a(all_fc_tac[z_size_2_thm] THEN1 all_var_elim_asm_tac1);
a(z_spec_nth_asm_tac 2 Ò(x1 ¶ x', x2 ¶ y)Æ);
a(all_fc_tac[adjacent_colour_thm]);
a(strip_asm_tac (z_µ_elimÒx'Æ ran_colour_thm));
(* *** Goal "1" *** *)
a(z_∂_tacÒ(u¶x', v¶y)Æ THEN asm_rewrite_tac[]);
a(strip_asm_tac (z_µ_elimÒyÆ ran_colour_thm));
a(swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(z_∂_tacÒ(u¶y, v¶x')Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_sets_ext" REPEAT strip_tac);
a(strip_asm_tac (z_µ_elimÒyÆ ran_colour_thm));
a(swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[]);
val €domino_colour_thm› = save_pop_thm "domino_colour_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "board_finite_thm");
a(rewrite_tac[board_def]);
a(lemma_tacÒ0 .. 7 ç (Ê_)Æ
	THEN1 rewrite_tac[z_size_dot_dot_thm1]);
a(all_fc_tac[z_size_product_thm]);
val €board_finite_thm› = save_pop_thm "board_finite_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "tiling_colour_thm");
a(REPEAT strip_tac);
a(z_∂_tacÒ
	{	d:z; u, v:Square
	|	d = {u, v};
		Colour u = 0;
		Colour v = 1
	∑	(u, v) } Æ);
a(rewrite_tac[z_‡_thm1, z_Ô_thm, z_è_def,
	z_≠_thm, z_ﬂ_thm, z_™_thm]);
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[tiling_def]));
a(REPEAT strip_tac);
(* *** Goal "1" duplicates "5" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(z_∂_tacÒ{(x1, x2), (x3, x4)}Æ THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(z_∂_tacÒ{(x1, x2), (x3, x4)}Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" duplicates "6" *** *)
a(lemma_tacÒ≥{x, y1} ° {x, y2} = {}Æ
	THEN1 PC_T1 "z_sets_ext" prove_tac[]);
a(z_spec_nth_asm_tac 13 Ò(x¶{x, y1}, y¶{x, y2})Æ);
a(POP_ASM_T ante_tac THEN rewrite_tac[
	pc_rule1 "z_sets_ext" prove_rule[]
	Òµa, b:É∑a = b § (µx:É∑x ç a § x ç b)Æ]);
a(STRIP_T (ante_tac o z_µ_elimÒy1Æ));
a(LEMMA_T Ò≥y1 = xÆ rewrite_thm_tac
	THEN1 (contr_tac THEN all_var_elim_asm_tac));
a(DROP_NTH_ASM_T 7 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(z_∂_tacÒ{(x1, x2), y}Æ THEN asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(PC_T1 "z_sets_ext" all_asm_fc_tac[]);
a(all_fc_tac[domino_colour_thm]);
a(z_∂_tacÒvÆ THEN asm_rewrite_tac[]);
a(lemma_tacÒ≥(x1, x2) = vÆ 
	THEN1 (contr_tac
	THEN all_var_elim_asm_tac1
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]));
a(PC_T "z_predicates" all_var_elim_asm_tac1);
a(LEMMA_TÒ(x1, x2) = uÆ asm_rewrite_thm_tac);
a(DROP_NTH_ASM_T 8 strip_asm_tac);
(* *** Goal "4" duplicates "7" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(z_∂_tacÒ{x, (x1, x2)}Æ THEN asm_rewrite_tac[]);
(* *** Goal "4.2" *** *)
a(PC_T1 "z_sets_ext" all_asm_fc_tac[]);
a(all_fc_tac[domino_colour_thm]);
a(z_∂_tacÒuÆ THEN asm_rewrite_tac[]);
a(lemma_tacÒ≥(x1, x2) = uÆ 
	THEN1 (contr_tac
	THEN all_var_elim_asm_tac1
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]));
a(PC_T "z_predicates" all_var_elim_asm_tac1);
a(LEMMA_TÒ(x1, x2) = vÆ asm_rewrite_thm_tac);
a(DROP_NTH_ASM_T 8 strip_asm_tac);
(* *** Goal "8" ("5", "6", "7" were duplicates) *** *)
a(lemma_tacÒ≥{x, z'} ° {y, z'} = {}Æ
	THEN1 PC_T1 "z_sets_ext" prove_tac[]);
a(z_spec_nth_asm_tac 7 Ò(x¶{x, z'}, y¶{y, z'})Æ);
a(POP_ASM_T ante_tac THEN rewrite_tac[
	pc_rule1 "z_sets_ext" prove_rule[]
	Òµa, b:É∑a = b § (µx:É∑x ç a § x ç b)Æ]);
a(STRIP_T (ante_tac o z_µ_elimÒxÆ));
a(rewrite_tac[]);
a(LEMMA_T Ò≥x = z'Æ rewrite_thm_tac
	THEN1 (contr_tac THEN all_var_elim_asm_tac));
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
val €tiling_colour_thm› = save_pop_thm "tiling_colour_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "tiling_colour_size_thm");
a(REPEAT strip_tac);
a(all_fc_tac[tiling_colour_thm]);
a(lemma_tacÒ{u : ﬁ z | Colour u = 0} Ä ﬁzÆ
	THEN1 PC_T1 "z_sets_ext" prove_tac[]);
a(all_fc_tac[z_finite_subset_thm]);
a(LIST_DROP_NTH_ASM_T [2, 4, 5] discard_tac);
a(all_fc_tac[z_finite_size_thm1, z_size_Ó_thm]);
a(all_fc_tac[z_o_è_thm]);
a(all_fc_tac[z_Ê_size_thm] THEN asm_rewrite_tac[]);
val €tiling_colour_size_thm› = save_pop_thm "tiling_colour_size_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "adjacent_trick_thm");
a(z_µ_tac THEN strip_tac THEN rewrite_tac[adjacent_def]);
a(lemma_tacÒAbs (x1.1 + ~ x2.1) ç Ó ± Abs (x1.2 + ~ x2.2) ç ÓÆ
	THEN1 rewrite_tac[z_abs_nat_thm]);
a(LEMMA_TÒµi, j:Ó∑
	i + j = 1 § i = 1 ± j = 0 ≤ i = 0 ± j = 1Æ
	(fn th => ALL_FC_T1 fc_§_canon rewrite_tac[th])
	THEN1 PC_T1 "z_lin_arith" prove_tac[]);
a(rewrite_tac[rewrite_rule[] z_abs_eq_0_thm] THEN PC_T1 "z_lin_arith" prove_tac[]);
val €adjacent_trick_thm› = save_pop_thm "adjacent_trick_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "board_tiling_thm");
a(lemma_tacÒµi, j:É∑≥2*i = 2*j + 1Æ THEN1
	(contr_tac THEN LEMMA_T
	Ò(2 * i) mod 2 = (2 * j + 1) mod 2Æ ante_tac
	THEN1 asm_rewrite_tac[]
	THEN rewrite_tac[z_mod_2_thm1]));
a(TOP_ASM_T (strip_asm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
a(rewrite_tac[board_tiling_def, tiling_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T "z_sets_ext" strip_tac
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
a(rewrite_tac[domino_def, adjacent_def,
	rewrite_rule[]z_abs_eq_1_thm]);
a(LEMMA_TÒ≥(i, 2 * j) = (i, 2 * j + 1)Æ asm_tac
	THEN1 rewrite_tac[]);
a(ALL_FC_T rewrite_tac[z_size_pair_thm]);
a(REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1
	THEN_TRY asm_rewrite_tac[]
	THEN all_asm_ante_tac
	THEN_TRY rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
(* Just stripping gives 64 subgoals here *)
a(POP_ASM_T ante_tac THEN
	LIST_DROP_NTH_ASM_T [9, 10]
	(fn ths => 
	PC_T1 "z_library_ext" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1
	THEN_TRY asm_rewrite_tac[]
	THEN all_asm_ante_tac
	THEN_TRY rewrite_tac ths
	THEN MAP_EVERY asm_tac ths
	THEN REPEAT strip_tac
	THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]));
(* *** Goal "3" *** *)
a(PC_T "z_sets_ext" strip_tac
	THEN rewrite_tac[board_def]
	THEN REPEAT_UNTIL is_± strip_tac
	THEN strip_tac);
(* *** Goal "3.1" *** *)
a(strip_tac THEN all_var_elim_asm_tac1
	THEN all_var_elim_asm_tac1
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2" *** *)
a(strip_tac THEN
	LEMMA_T Òx2 mod 2 = x2 mod 2Æ ante_tac
	THEN1 REPEAT strip_tac);
a(pure_rewrite_tac[z_mod_2_thm]);
a(REPEAT strip_tac
	THEN POP_ASM_T ante_tac
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.2.1" *** *)
a(z_∂_tacÒ{(x1, 2 * d), (x1, 2 * d + 1)}Æ
	THEN rewrite_tac[]);
a(z_∂_tacÒ(i¶x1, j¶d)Æ
	THEN PC_T1 "z_library_ext" asm_rewrite_tac[]);
a(REPEAT strip_tac THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.2" *** *)
a(z_∂_tacÒ{(x1, 2 * d), (x1, 2 * d + 1)}Æ
	THEN rewrite_tac[]);
a(z_∂_tacÒ(i¶x1, j¶d)Æ
	THEN PC_T1 "z_library_ext" asm_rewrite_tac[]);
a(REPEAT strip_tac THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val €board_tiling_thm› = save_pop_thm "board_tiling_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "colours_on_board_thm");
a(strip_asm_tac board_tiling_thm);
a(lemma_tacÒﬁ BoardTiling ç (Ê_)Æ THEN1
	asm_rewrite_tac[board_finite_thm]);
a(ALL_FC_T (MAP_EVERY ante_tac) [tiling_colour_size_thm]);
a(asm_rewrite_tac[]);
val €colours_on_board_thm› = save_pop_thm "colours_on_board_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "colours_on_mutilated_board_thm");
a(LEMMA_T Ò
	{u : MutilatedBoard | Colour u = 0} =
	{u : Board | Colour u = 0} \ {(0, 0), (7, 7)}
±	{u : MutilatedBoard | Colour u = 1} =
	{u : Board | Colour u = 1}Æ
	rewrite_thm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[board_def, mutilated_board_def]
	THEN PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(swap_nth_asm_concl_tac 2 THEN
	asm_rewrite_tac[colour_def]);
(* *** Goal "1.2" *** *)
a(swap_nth_asm_concl_tac 2 THEN
	asm_rewrite_tac[colour_def]);
(* *** Goal "2" *** *)
a(LEMMA_T Ò{(0, 0), (7, 7)} Ä {u : Board | Colour u = 0}Æ asm_tac);
(* *** Goal "2.1" *** *)
a(PC_T1 "z_sets_ext" rewrite_tac[board_def]);
a(rewrite_tac[colour_def]);
(* *** Goal "2.2" *** *)
a(lemma_tac Ò{u : Board | Colour u = 0} Ä BoardÆ
	THEN1 PC_T1 "z_sets_ext" prove_tac[]);
a(strip_asm_tac board_finite_thm);
a(all_fc_tac[z_finite_subset_thm]);
a(LEMMA_TÒ≥(0, 0) = (7, 7)Æ asm_tac
	THEN1 REPEAT strip_tac);
a(all_fc_tac[z_size_pair_thm]);
a(ante_tac (
	z_µ_elim Ò(a¶{u : Board | Colour u = 0}, b¶{(0, 0), (7, 7)})Æ z_size_diff_thm
)
	THEN asm_rewrite_tac[]);
a(ALL_FC_T asm_rewrite_tac[
	pc_rule1 "z_sets_ext" prove_rule[]
	Òµa, b: É∑ b Ä a ¥ a ° b = bÆ]);
a(PC_T1 "z_lin_arith" prove_tac[]);
val €colours_on_mutilated_board_thm› = save_pop_thm "colours_on_mutilated_board_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "mutilated_chessboard_thm");
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN contr_tac);
a(lemma_tacÒﬁz Ä BoardÆ THEN1
	(asm_rewrite_tac[mutilated_board_def]
	THEN PC_T1 "z_sets_ext" prove_tac[]));
a(strip_asm_tac board_finite_thm);
a(all_fc_tac[z_finite_subset_thm]);
a(ALL_FC_T (MAP_EVERY ante_tac) [tiling_colour_size_thm]);
a(ante_tac colours_on_mutilated_board_thm
	THEN asm_rewrite_tac[colours_on_board_thm]);
a(PC_T1 "z_lin_arith" prove_tac[]);
val €mutilated_chessboard_thm› = save_pop_thm "mutilated_chessboard_thm";
=TEX
=SML

=TEX
\section{Epilogue}
=TEX
=SML
fun check_conjecture name = (
	if	let	val tm = get_conjecture "-" name;
			val thm = get_thm "-" name;
		in	is_nil (asms thm)
		andalso	tm =$ concl thm
		end	handle Fail _ => false
	then	(delete_conjecture name;
		true)
	else	(diag_line ("Conjecture " ^ name ^ " has not been proved");
		false)
);
if all (map (check_conjecture)
	(map (hd o fst) (get_conjectures "-")))
	(fn x => x)
then	diag_line "All conjectures have been proved."
else	();
=SML
z_output_theory{out_file="mutcb.th.doc", theory="-"};
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
=TEX
\end{document}
=IGN
