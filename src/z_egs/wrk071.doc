=IGN
=TEX
\documentclass[12pt]{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\underscoreoff
\ftaboveboxskip=0.5\abovedisplayskip
\ftbelowboxskip=0.1\belowdisplayskip
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\def\Hide#1{\relax}
\title{The Mutilated Chessboard Theorem in Z}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\begin{abstract}
This note presents a statement and proof of the mutilated chessboard theorem is the Z notation.
The formulation is along the lines of the one proposed by McCarthy for a `heavy duty set theory'' theorem prover.
The proof is presented as a series of Z conjectures all of which have been formally verified using the {\Product} system.
\end{abstract}

\section{INTRODUCTION}

The mutilated chessboard theorem was proposed over 40 years ago by John McCarthy as a ``tough nut to crack'' for automated reasoning \cite{McCarthy64}.
The theorem is rather trivial: if a chess board is ``mutilated'' by removing two diagonally opposite corner squares, then the result cannot be tiled with domino-shaped tiles each covering two adjacent squares of the board.
Why is this so?
Well, because each domino contributes one white square and one black, any such tiling must cover exactly as many black squares as it does white.
However, the two squares removed from the mutilated board both have the same colour, and so the mutilated board contains two more squares of one colour than it does of the other.

A discussion of why this theorem is a challenge for theorem-proving is outside the scope of this note.
However, as McCarthy [McCarthy95] notes, the counting argument given above should be ``admitted in any heavy duty set theory''.
I.e., the argument should admit formalisation in any general purpose theorem-proving system allowing reasoning about sets.
The theorem has indeed been proved in a number of systems including NQTHM \cite{Subramanian94}, Mizar\cite{Bancerek95,Rudnicki95}, Isabelle \cite{Paulson01}.

Z notation provides a convenient notation for set theory and
This note presents the statement and proof of the theorem formulated in Z and prepared and checked using the {\Product} system.
The treatment is in the spirit of McCarthy's formulation in [McCarthy95], which turns out to admit a very concise rendition in Z.

\Hide{
The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"z_library";
set_pc"z_library1";
force_delete_theory"mutcb" handle Fail _ => ();
new_theory"mutcb";
=TEX
}
\section{STATEMENT OF THE THEOREM}
\vertbarfalse
{%\catcode`\^^I=\active
\obeyspaces
\gdef\AbsDef{%
πZAX
‹    €Abs› : ˙ ≠ ˙
˜¸¸¸¸¸¸
‹    µm:Ó ∑ Abs (~m) = Abs m = m
∞
}
\gdef\FigureTwo{%
\begin{figure}
\ftaboveboxskip=0.1\abovedisplayskip
\ftbelowboxskip=0.5\belowdisplayskip
\begin{tabular}{|c|}\hline
\begin{minipage}[t]{0.975\hsize}
\ftaboveboxskip=0.1\abovedisplayskip
\ftbelowboxskip=0.5\belowdisplayskip
πZ
‹ €Adjacent› ¶ {x1, x2 : ˙ ∏ ˙ | Abs(x1.1 - x2.1) + Abs(x1.2 - x2.2) = 1}
∞
πZ
‹ €Domino› ¶ {x:Ê(˙ ∏ ˙) | #x = 2 ± (µx1, x2:x | x1 Ω x2 ∑ (x1, x2) ç Adjacent)}
∞
πZ
‹ €Tiling› ¶ {z:((˙ ∏ ˙)) | z Ä Domino ± (µx, y:z ∑ x = y ≤ x ° y = {})}
∞
πZ
‹ €Board› ¶ (0 .. 7) ∏ (0 .. 7)
∞
πZ
‹ €MutilatedBoard› ¶ Board \ {(0,0), (7,7)}
∞
\end{minipage}
\\\hline
\end{tabular}
\caption{The Specification}
\label{fig2}
\end{figure}%
} % \FigureTGwo
\gdef\FigureOne{%
\begin{figure}
\ftaboveboxskip=0.1\abovedisplayskip
\ftbelowboxskip=0.5\belowdisplayskip
\begin{tabular}{|c|}\hline
\begin{minipage}[t]{0.975\hsize}
πZ
‹ €mutilated_chessboard_thm› ?Ù ≥(∂z: Tiling ∑ ﬁz = MutilatedBoard)
∞
\end{minipage}
\\\hline
\end{tabular}
\caption{Statement of the Theorem}
\label{fig1}
\end{figure}
} %\FigureOne
} %\opeyspaces
Our statement of the theorem is the Z conjecture shown in figure~\ref{fig1}.
It involves the sets, {\em Tiling} and {\em MutilatedBoard} defined along with the sets {\em Adjacent}, {\em Domino} and {\em Board} in the little Z specification shown in figure~\ref{fig2}.
The specification is based on that of \cite{McCarthy95} with some simplifications.
Let us discuss each of the 5 sets in the order of their definitions in figure~\ref{fig2}.
\FigureOne
\FigureTwo


We represent a square on the chessboard as a pair of integers.
Two squares are adjacent iff. the distance between them is 1 (where we measure distances using the Manhattan taxi-cab metric).
The set {\em Adjacent} represents this relation.
Z would allow us to use predicate-style notation for membership of sets as McCarthy does, but it seems more convenient and perfectly natural to use $\in$ for membership of the sets in this example.


A domino in some position on the board is represented by the set comprising the two adjacent squares it occupies.
The set of all such sets is our set {\em Domino}\footnote{%
I should explain to those unfamiliar with Z how its very convenient and clear notation for set comprehensions works. The expression ``%
=INLINEFT
{decs | pred ∑ expr}
=TEX
'' denotes the set whose memebers comprise all values of the expression ``%
=INLINEFT
expr
=TEX
'' as the variables declared by the declarations ``%
=INLINEFT
decs
=TEX
'' range over values satisfying the predicate ``%
=INLINEFT
pred
=TEX
''.
If the part ``%
=INLINEFT
∑ expr
=TEX
'' is omitted, the expression giving the members of the set is inferred from the form of the declarations ``%
=INLINEFT
decs
=TEX
'', e.g., in the definitions of {\em Adjacent} and {\em Tiling} in figure~\ref{fig2}, it is taken to be ``%
=INLINEFT
(x1. x2)
=TEX
'' and ``%
=INLINEFT
z
=TEX
'' respectively.
Similarly, the part ``%
=INLINEFT
| pred
=TEX
'' may be omitted in which case the predicate is taken to be ``%
=INLINEFT
true
=TEX
''. % end of footnote
}.
% We could easily avoid the use of the size function (\#) in this definition (see [Paulson01]).
% However, the definitions are equivalent as is easily proved and the one given is closer to the natural language statement.
Unlike McCarthy, we do not constrain our dominoes to lie on the chessboard, this makes our statement a little more general than his.
(Yes, it is obvious that a tiling that contains dominoes that are not on the board doesn't tile the board, but the whole thing is ``obvious'' so we may as well formalise it as generally as we conveniently can.)

A tiling is a set of dominoes positioned so that no two dominoes overlap.
Our set {\em Tiling} is the set of all such tilings.
Paulson defines this set inductively, an approach that I cannot endorse in this case.
It is more general, technically easier and much closer to our intuition to avoid induction for this kind of property.
In natural language we say ``positioned so that no two dominoes overlap'' not ``that could be positioned one at a time with each domino positioned so as not to overlap the dominoes that have been positioned before it''.
I see no grounds for preferring the more complicated exposition in the formalisation.

As reflected in the definition of the set {\em Board}, the complete board is to be represented by the set of squares with co-ordinates in the range 0 to 7, which we can write as the cartesian product of the integer interval
=INLINEFT
0 .. 7
=TEX
\ with itself.
The set {\em MutilatedBoard} representing the mutilated board is then obtained by removing the squares $(0, 0)$ and $(7, 7)$.

With our representation of dominoes, the set of squares covered by a tiling $z$ is the union $\bigcup z$.
Returning to the conjecture shown in figure~\ref{fig1}, we see that it says there is no tiling whose union is equal to the mutilated board, i.e., no tiling that covers the mutilated board.
This is precisely what we want the mutilated chessboard theorem to state.

\section{THE PROOF}\label{proof}

We now given a ``semiformal'' proof of the little theorem couched strictly in terms of the Z formalisation.
The semiformal proof comprises rigorous formal statements of a series of lemmas interleaved with informal narrative explanations of these statements and how they relate.
As discussed in section~\ref{machine} below, a formal mechanized version of this proof has been prepared and can be checked using~\Product, a specification and proof system supporting HOL and Z\footnote{
\raggedright
See {\tt http://www.lemma-one.com/ProofPower/index/} for more information on {\sf ProofPower} including full documentation and information about how to obtain the system.}.

The lemmas are formulated as conjecture paragraphs in Z and
some of them involve additional notation which we define in Z as needed.
Some of the informal explanations rely on elementary mathematical properties which are further discussed in section~\ref{supporting} below.

We begin with a more explicit characterisation of adjacency saying that two squares are adjacent iff. their eastings differ by 1 and their northings are equal, or vice versa.
It follows from the definition of adjacency and from elementary properties of the absolute value function.

πZ
‹ €adjacent_thm› ?Ù
‹ 	µx1, x2:˙ ∏ ˙ ∑ 
‹		(x1, x2) ç Adjacent
‹ 	§	Abs(x1.1 - x2.1) = 1 ± x1.2 = x2.2
‹	≤	Abs(x1.2 - x2.2) = 1 ± x1.1 = x2.1
∞

That every domino comprises two squares is wired into our definition of domino.
That these two square have different colours needs to be proved.
First we need a definition of the notion of colour.

πZAX
‹    €Colour› : ˙ ∏ ˙ ≠ ˙
˜¸¸¸¸¸¸
‹    µx:˙ ∏ ˙ ∑ Colour x = (x.1 + x.2) mod 2
∞

This definition and elementary facts about remainders {\it modulo} 2 immediately imply that the colour of any square is either 0 or 1:

πZ
‹ €ran_colour_thm› ?Ù µu:˙ ∏ ˙ ∑ Colour u ç {0, 1}
∞

Using the case analysis given by {\em adjacent_thm}, we have that the colours of any two adjacent squares are different:

πZ
‹ €adjacent_colour_thm› ?Ù µu, v:˙ ∏ ˙ | (u, v) ç Adjacent ∑ Colour u Ω Colour v
∞

From the above facts and the definition of {\em Domino}, using elementary facts about sets of cardinality 2, we conclude that every domino comprises two squares whose colours are 0 and 1.
This is the only fact about dominoes that will be used hereafter.

πZ
‹ €domino_colour_thm› ?Ù 
‹ 	µx:Domino ∑ ∂u, v:x ∑ x = {u, v} ± Colour u = 0 ± Colour v = 1
∞

If $z$ is a tiling then within the squares it covers there is a bijection between those coloured 0 and those coloured 1.

πZ
‹ €tiling_colour_thm› ?Ù
‹	µz:Tiling ∑ ∂f:{u:ﬁz | Colour u = 0} è {u:ﬁz|Colour u = 1} ∑ true
∞

The proof of the above is very simple and direct and does not depend on $z$ being finite.
The witness for $f$ is given by the following set comprehension and the verification that it is the required bijection is routine.

=GFT
	{d:z; u, v:˙ ∏ ˙ | d = {u, v} ± Colour u = 0 ± Colour v = 1 ∑ (u, v)}
=TEX

From the above it follows that if the set of squares covered by a tiling is finite, then the colour function divides it into two subsets of equal sizes.


πZ
‹ €tiling_colour_size_thm› ?Ù
‹	µz:Tiling | ﬁz ç (Ê_) ∑ #{u:ﬁz | Colour u = 0} = #{u:ﬁz | Colour u = 1}
∞

The proof of the above is immediate from elementary facts about finite cardinalities and the existence of the bijection between the two sets.

We now need to show that the mutilated board is not divided into two equal subsets by the colour function.
To do this, we will first show that the unmutilated board can be so divided, which we can conveniently prove using
{\em tiling_colour_size_thm}.
We must first prove that the unmutilated board is finite:

πZ
‹ €board_finite_thm› ?Ù Board ç (Ê_)
∞
\ldots and that it can be tiled:

πZ
‹ €board_tiling_thm› ?Ù ∂z:Tiling ∑ ﬁz = Board
∞

For the witness in the above lemma, one can observe that
=INLINEFT
{(i, 2*j), (i, 2*j+1)}
=TEX
\ is a domino and that two distinct dominoes of this form cannot overlap and so take:

=GFT
	z = Board ° {i, j : ˙ ∑ {(i, 2*j), (i, 2*j+1)}}
=TEX


Hence the unmutilated board is divided into equal size subsets by the colour function:

πZ
‹ €colours_on_board_thm› ?Ù
‹	#{u:Board | Colour u = 0} = #{u:Board | Colour u = 1}
∞
\ldots but the mutilated board is not:
πZ
‹ €colours_on_mutilated_board_thm› ?Ù
‹	#{u:MutilatedBoard|Colour u = 0} = #{u:Board | Colour u = 0} - 2
‹ ±	#{u:MutilatedBoard|Colour u = 1} = #{u:Board | Colour u = 1}
∞

The mutilated chessboard theorem is now an immediate consequence of {\em tiling_colour_size_thm} and {\em 
colours_on_mutilated_board_thm}.

\section{SUPPORTING THEORY}\label{supporting}
In the narrative in section~\ref{proof} above, we have appealed to elementary properties of the absolute value function, of remainders {\it modulo} 2 and of finite cardinalities.
In this section we state the lemmas that we need which are additional to those already provided in {\Product}.
These comprise fairly immediate consequences of results that are already provided.

\subsection{Absolute Values}
The absolute value function is not in the Z library.
We adopt the following definition for it.

\AbsDef

The elementary properties we need are readily derived from the definition. They are as follows:

πZ
‹ €z_abs_nat_thm› ?Ù (µi:˙ ∑ Abs i ç Ó)
∞
πZ
‹ €z_abs_eq_0_thm› ?Ù µi, j:˙ ∑ Abs (i - j) = 0  § i = j
∞
πZ
‹ €z_abs_eq_1_thm› ?Ù
‹ µi, j:˙ ∑
‹	Abs (i - j) = 1
‹ §	i < j ± j = i + 1 ≤ j < i ± i = j + 1
∞
The proofs are all immediate by arithmetic after a case analysis on the sign on the operand of the absolute value function allowing the definition to be expanded.

\subsection{Remainders {\it modulo} 2}
We need the facts about remainders {\it modulo} 2.
The first is an immediate consequence of a theorem that is already provided characterising remainders modulo $d$ for any non-zero $d$.
πZ
‹ €z_mod_2_thm› ?Ù µi, j:˙ ∑ i mod 2 = j § j ç {0, 1} ± (∂d:É∑ i = 2*d + j)
∞
The remaining 3 facts facts follow easily from the above:
πZ
‹ €z_mod_2_thm1› ?Ù µi:˙ ∑ (2*i) mod 2 = 0 ± (2*i + 1) mod 2 = 1
∞
πZ
‹ €z_ran_mod_2_thm› ?Ù µi:˙ ∑ i mod 2 ç {0, 1}
∞
πZ
‹ €z_plus_1_mod_2_thm› ?Ù µi:˙ ∑ ≥i mod 2 = (i + 1) mod 2
∞
\subsection{Finite Cardinalities}
All the basics of the theory of finite cardinality are already provided including the fundamental fact that if $a$ and $b$ are finite sets then so are $a \cup b$ and $a \cap b$ and $\#(a \cup b) + \#(a \cap b) = \#a + \#b$.
From this material we derive the following facts:

πZ
‹ €z_size_pair_thm› ?Ù µx, y:É | ≥x = y ∑ {x, y} ç (Ê_) ± #{x, y} = 2
∞
πZ
‹ €z_size_eq_thm› ?Ù µa, b:(Ê_) | a Ä b ± #a = #b ∑ a = b 
∞
πZ
‹ €z_size_2_thm› ?Ù µa:(Ê_) ∑ #a = 2 § (∂x, y:É∑≥x = y ± a = {x, y})
∞
πZ
‹ €z_finite_subset_thm› ?Ù µa:(Ê_); b: É | b Ä a ∑ b ç (Ê_)
∞

The following are the only theorems in this note that are proved by induction.

πZ
‹ €z_size_product_thm› ?Ù µa : (Ê_); b:(Ê_) ∑ a ∏ b ç (Ê_) ± #(a ∏ b) = #a * #b
∞
πZ
‹ €z_finite_size_thm1› ?Ù µa: (Ê_) ∑ (∂f:1 .. #a è a ∑true)
∞


\section{THE MECHANIZED PROOFS}\label{machine}

The source text of this document is actually a script from which all the formal material can be extracted and checked using {\Product}.
The source text also includes a proof script giving the commands to prove all the conjectures mechanically.
The proof script has not been included in the printed form of the document for brevity (it comprises some 11 pages of ML code).

The proof of the mutilated chessboard theorem as given in section~\ref{proof} and the proofs of the supporting theory discussed in section~\ref{supporting} comprise about 270 and 120 lines of proof commands respectively. (The proof script also includes a few dozen lines of ``boiler-plate'', e.g., code to collect statistics on the numbers of inference steps.)
The proofs in section~\ref{proof} are very routine.

The specification was originally formulated to correspond very closely the treatment given in~\cite{McCarthy95} and inductive methods were used for the proofs as in~\cite{Paulson01}
This was done for comparative reasons with the expectation that the inductive approach was likely to be harder than what we present above.
It took about 10 hours' work spread over three afternoons.
The result is longer and more complicated than what we have presented above.

The main complications are that you have to prove that the tilings of interest are finite\footnote{
Even closer to the approach of~\cite{Paulson01} would be to define the set of tilings as an intersection giving the smallest set of domino configurations containing the empty configuration and closed under the operation that adds a non-overlapping domino to a configuration.
This saves having to prove that the resulting tilings are finite, but at the expense of making the specificaitons more complicated and the results less general.
It still results in a longer proof than the one presented above.
}. to justify proof by induction over them and then use induction to prove {\em tiling_colour_size_thm}.
This requires more work in the proof itself and more supporting theory (e.g., to reason about the finiteness of finite powersets).

The proof was then adapted to use the approach outlined above.
This amounted to proving what we have called {\em tiling_colour_thm} and {\em finite_colour_size_thm1} and using them to replace a long inductive proof of
{\em tiling_colour_size_thm} with a simple derivation using those results and elementary properties of finite cardinalities.
This took about 2 hours and reduces the amount of supporting theory required to what is presented above.
A final hour was then spent simplifying and abbreviating the specification and adopting the proofs to accommodate. 


 
\section{CONCLUDING REMARKS}

This problem lay unattended on my to-do list fpr far too long.
In fact, nothing in Z or {\Product} that was not available in 1995 has been exploited in the work described in this document.
As \cite{Subramanian94} and Mizar\cite{Bancerek95,Rudnicki95} also show there certainly were systems available at the time of writing of~\cite{McCarthy95} that would accept the proof it presents.

Conceivably, the proofs to date are much less automatic than McCarthy might have had in mind.
However, if one compares fairly, the de Bruihn factor\footnote{%
This term due to Freek Wiedijk denotes the ratio between the size of a formal mathematical text and its informal original.
%
}
\ obtained is quite good.
In the case of the mutilated chessboard theorem, I feel that to be fair one must compare the formal treatment with a reasonably detailed exposition of the finite combinatorics, ``obvious'' though it may be intuitively, along the lines of section~\ref{proof} above.
For the treatment in this document, the de Bruijn factor turns out to be about 3 measured either in terms of A4 pages or in terms of lines of ML code versus lines of {\LaTeX} source.

Further work, of course, remains to be done! One shortfall of the formalisation is that it contains nothing corresponding to the words ``diagonally opposite corner squares'' that appear in the informal statement of the theorem: the formalisation just takes it as obvious that these can be taken to be the ones labelled $(0, 0)$ and $(7, 7)$.
It is diverting to think about formalising the problem to take account of this aspect of the informal statement.

A deeper shortfall is that, apart form the informal statement of the problem, both the informal and the formal accounts only deal with dominoes that each lock into place over two adjacent squares of the board.
The proof does not discount the possibility of a tiling of the board in which dominoes can be placed at arbitrary positions and orientations.
To deal with this, a domino must be modelled as something like the range of an isometric mapping of the rectangle $[0, 1] \times [0, 2]$ into the plane and a tiling must be modelled as a set of such dominoes which only intersect at the edges.
This problem can be reduced to the discrete case, but the reduction must make essential use of the fact that the board contains no ranks or files that are unbounded in both directions.
To those whose systems support enough real analysis, I commend the geometric challenges of this reduction as food for thought.

\raggedright
\bibliographystyle{plain}
\bibliography{bookspapers}

=TEX
\end{document}
\newpage
\appendix
\section{STATISTICS}

Tables~\ref{tab1} and~\ref{tab2} show for each conjecture formulated in this document the number of lines of code in its proof and the number of primitive inferences that proof executes.

 
\begin{table}[bh]
\begin{center}
\begin{tabular}{|l|r|r|}\hline
\bf Conjecture & \bf LOC & \bf Inferences \\\hline
ran_colour_thm & 2 & 333 \\\hline
adjacent_thm & 8 & 180590 \\\hline
adjacent_colour_thm & 22 & 4065 \\\hline
domino_colour_thm & 15 & 4916 \\\hline
board_finite_thm & 4 & 442 \\\hline
tiling_colour_thm & 71 & 64227 \\\hline
tiling_colour_size_thm & 9 & 2969 \\\hline
board_tiling_thm & 79 & 105420 \\\hline
colours_on_board_thm & 5 & 762 \\\hline
colours_on_mutilated_board_thm & 36 & 22667 \\\hline
mutilated_chessboard_thm & 10 & 4719 \\\hline
\bf Total & 261 & 391090 \\\hline
\end{tabular}
\end{center}
\caption{Statistics for the Mutilated Chessboard Theorem}
\label{tab1}
\end{table}

\begin{table}[bh]
\begin{center}
\begin{tabular}{|l|r|r|}\hline
\bf Conjecture & \bf LOC & \bf Inferences \\\hline
z_abs_nat_thm & 4 & 1370 \\\hline
z_abs_eq_0_thm & 4 & 21256 \\\hline
z_abs_eq_1_thm & 4 & 84748 \\\hline
z_mod_2_thm & 6 & 38804 \\\hline
z_mod_2_thm1 & 3 & 309 \\\hline
z_ran_mod_2_thm & 4 & 715 \\\hline
z_plus_1_mod_2_thm & 9 & 8680 \\\hline
z_size_pair_thm & 7 & 1254 \\\hline
z_size_eq_thm & 8 & 4870 \\\hline
z_size_2_thm & 16 & 2038 \\\hline
z_size_product_thm & 30 & 5386 \\\hline
z_finite_subset_thm & 4 & 1043 \\\hline
z_finite_size_thm1 & 17 & 4577 \\\hline
\bf Total & 116 & 175050 \\\hline
\end{tabular}
\end{center}
\caption{Statistics for the Supporting Theory}
\label{tab2}
\end{table}

=IGN
{\HOLindexOff\small
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{mutcb.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
\printindex
=TEX
\newpage
\section{PROOF SCRIPTS}
\ftlinepenalty=9999
\subsection{Preliminaries}
=SML
val thm_stats : int S_DICT S_DICT ref = ref[];
fun save_pop_thm_stats name = (
	let	val thm = pop_thm();
	in	thm_stats := s_enter name (get_stats()) (!thm_stats);
		init_stats();
		save_thm(name, thm)
	end
);
val _ = (
	init_stats();
	set_flag("profiling", true)
);
=TEX
=SML
val €square_u_thm› = pc_rule1 "z_sets_ext" prove_rule[get_specÒ˙Æ]Ò˙ ∏ ˙ = ÉÆ;
=TEX
=SML
val €z_abs_def› = z_get_specÒAbsÆ;
val €adjacent_def› = z_get_specÒAdjacentÆ;
val €board_def› = z_get_specÒBoardÆ;
val €mutilated_board_def› = z_get_specÒMutilatedBoardÆ;
val €domino_def› =
	rewrite_rule[square_u_thm](z_get_specÒDominoÆ);

val €tiling_def› =
	rewrite_rule[square_u_thm](z_get_specÒTilingÆ);
val €colour_def› = z_get_specÒColourÆ;
=TEX
\newpage
\subsection{Supporting Theory}
=SML
set_goal([], get_conjecture "-" "z_abs_nat_thm");
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elimÒiÆ z_˙_cases_thm)
	THEN all_var_elim_asm_tac1
	THEN ALL_FC_T asm_rewrite_tac [z_abs_def]);
val €z_abs_nat_thm› = save_pop_thm_stats "z_abs_nat_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_eq_0_thm");
a(z_µ_tac THEN strip_tac);
a(strip_asm_tac(z_µ_elim Òi + ~jÆ z_˙_cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[z_abs_def]
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val €z_abs_eq_0_thm› = save_pop_thm_stats "z_abs_eq_0_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_eq_1_thm");
a(z_µ_tac THEN strip_tac);
a(strip_asm_tac(z_µ_elim Òi + ~jÆ z_˙_cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[z_abs_def]
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val €z_abs_eq_1_thm› = save_pop_thm_stats "z_abs_eq_1_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_mod_2_thm");
a(z_µ_tac THEN strip_tac);
a(LEMMA_T Ò≥2 = 0Æ asm_tac THEN1 REPEAT strip_tac);
a(ALL_FC_T1 fc_§_canon rewrite_tac
	[rewrite_rule[](conv_rule (MAP_C z_µ_elim_conv) (z_mod_thm))]);
a(REPEAT strip_tac THEN_TRY
	z_∂_tac Òd ∫ ˙Æ THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val €z_mod_2_thm› = save_pop_thm_stats "z_mod_2_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_mod_2_thm1");
a(z_µ_tac THEN strip_tac);
a(rewrite_tac[z_mod_2_thm]);
a(z_∂_tacÒiÆ THEN REPEAT strip_tac);
val €z_mod_2_thm1› = save_pop_thm_stats "z_mod_2_thm1";
=TEX
=SML
set_goal([], get_conjecture "-" "z_ran_mod_2_thm");
a(contr_tac);
a(fc_tac[
	inst_term_rule [(Òi mod 2Æ, Òj ∫ ˙Æ)]
		(all_µ_elim (hd (fc_canon z_mod_2_thm)))]);
val €z_ran_mod_2_thm› = save_pop_thm_stats "z_ran_mod_2_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_plus_1_mod_2_thm");
a(REPEAT strip_tac);
a(lemma_tac¨∂j∑Ò(i + 1) mod 2 = jÆÆ THEN1 prove_∂_tac);
a(asm_rewrite_tac[] THEN POP_ASM_T ante_tac);
a(rewrite_tac[z_mod_2_thm] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN all_asm_ante_tac THEN rewrite_tac[] THEN contr_tac);
(* *** Goal "1" duplicates "2" *** *)
a(lemma_tacÒ0 < d - d' < 1 Æ THEN
	PC_T1 "z_lin_arith" asm_prove_tac[]);
val €z_plus_1_mod_2_thm› = save_pop_thm_stats "z_plus_1_mod_2_thm";
val €z_plus_1_mod_2_thm1› =
	conv_rule (ONCE_MAP_C z_anf_conv) z_plus_1_mod_2_thm;
=TEX
=SML
val €z_Ê_¿_singleton_thm1› = z_gen_pred_elim[ÒÉÆ] z_Ê_¿_singleton_thm;
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_pair_thm");
a(z_µ_tac THEN strip_tac);
a(lemma_tacÒ{y} ç (Ê_) ± #{y} = 1Æ THEN1 rewrite_tac[z_size_singleton_thm]);
a(ante_tac (z_µ_elimÒ(x ¶ x, a ¶ {y})Æ z_size_¿_singleton_thm));
a(ante_tac (z_µ_elimÒ(x ¶ x, a ¶ {y})Æ z_Ê_¿_singleton_thm1));
a(asm_rewrite_tac[z_size_singleton_thm]);
a(LEMMA_T Ò{x, y} = {y} ¿ {x}Æ rewrite_thm_tac
	THEN PC_T1 "z_sets_ext" prove_tac[]);
val €z_size_pair_thm› = save_pop_thm_stats "z_size_pair_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_eq_thm");
a(PC_T "z_sets_ext" contr_tac
	THEN1 all_asm_fc_tac[]);
a(lemma_tacÒa Ä a ¿ {x1} ± a ¿ {x1} Ä bÆ THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(strip_asm_tac (z_µ_elimÒ(x ¶ x1, a ¶ a)Æ z_size_¿_singleton_thm));
a(strip_asm_tac (z_µ_elimÒ(x ¶ x1, a ¶ a)Æ z_Ê_¿_singleton_thm1));
a(strip_asm_tac (z_µ_elimÒ(a ¶ b, b ¶ a ¿ {x1})Æ z_size_mono_thm));
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
val €z_size_eq_thm› = save_pop_thm_stats "z_size_eq_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_2_thm");
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_sets_ext" lemma_tac Ò≥a = {}Æ
	THEN1 (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[z_size_empty_thm]));
a(PC_T1 "z_sets_ext" lemma_tac Ò≥a = {x1}Æ
	THEN1 (swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[z_size_singleton_thm])
	THEN_TRY all_var_elim_asm_tac1);
a(lemma_tacÒ{x2, x1} ç (Ê_) ± #{x2, x1} = 2Æ THEN1
	ALL_FC_T rewrite_tac[z_size_pair_thm]);
a(LEMMA_TÒ{x2, x1} Ä aÆ asm_tac THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(ante_tac (z_µ_elimÒ(a ¶ {x2, x1}, b ¶ a)Æ z_size_eq_thm));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(z_∂_tacÒ(x ¶ x2, y ¶ x1)Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(ALL_FC_T asm_rewrite_tac[z_size_pair_thm]);
val €z_size_2_thm› = save_pop_thm_stats "z_size_2_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_product_thm");
a(z_µ_tac THEN strip_tac);
a(z_Ê_induction_tacÒaÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[z_size_empty_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[
	pc_rule1 "z_library_ext"
		prove_rule[] Ò(a ¿ {x}) ∏ b = (a ∏ b) ¿ ({x} ∏ b)Æ]);
a(lemma_tacÒ(a ∏ b) ° ({x} ∏ b) = {}Æ THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(lemma_tacÒ({x} ∏ b) ç (Ê_) ± #({x} ∏ b) = #bÆ);
(* *** Goal "2.1" *** *)
a(LIST_DROP_NTH_ASM_T [1, 2, 3, 4, 5] discard_tac);
a(z_Ê_induction_tacÒbÆ
	THEN1 rewrite_tac[z_size_empty_thm]);
a(rewrite_tac[
	pc_rule1 "z_library_ext"
		prove_rule[] Ò{x} ∏ (b ¿ {x'}) = ({x} ∏ b) ¿ {(x, x')}Æ]);
a(LEMMA_TÒ≥(x, x') ç ({x} ∏ b)Æ asm_tac THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(ante_tac (z_µ_elimÒ(x ¶ (x, x'), a ¶ {x} ∏ b)Æ z_size_¿_singleton_thm));
a(ante_tac (z_µ_elimÒ(x ¶ x', a ¶ b)Æ z_size_¿_singleton_thm));
a(ante_tac (z_µ_elimÒ(x ¶ (x, x'), a ¶ {x} ∏ b)Æ z_Ê_¿_singleton_thm1));
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(ante_tac (z_µ_elimÒ(a ¶ a ∏ b, b ¶ {x} ∏ b)Æ z_size_¿_thm));
a(asm_rewrite_tac[z_size_empty_thm]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[z_size_¿_singleton_thm]);
a(PC_T1 "z_lin_arith" prove_tac[]);
val €z_size_product_thm› = save_pop_thm_stats "z_size_product_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_finite_subset_thm");
a(REPEAT strip_tac);
a(LEMMA_TÒb = a \ {x:a|≥x ç b}Æ once_rewrite_thm_tac
	THEN1 PC_T1 "z_sets_ext" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[z_Ê_diff_thm]);
val €z_finite_subset_thm› = save_pop_thm_stats "z_finite_subset_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_finite_size_thm1");
a(REPEAT strip_tac);
a(z_Ê_induction_tac ÒaÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[z_size_empty_thm] THEN REPEAT strip_tac);
a(z_∂_tacÒ{}Æ THEN PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "2" *** *)
a(all_fc_tac[z_size_¿_singleton_thm, z_size_Ó_thm]);
a(asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) z_dot_dot_¿_thm]);
a(z_∂_tacÒf ¿ {(#a + 1, x)}Æ THEN rewrite_tac[]);
a(bc_thm_tac
	(rewrite_rule[](conv_rule (MAP_C z_µ_elim_conv) (z_¿_è_thm))));
a(asm_rewrite_tac[
	pc_rule1 "z_library_ext" prove_rule[]
		Òµx:É; y:É∑{(x, y)} ç {x} è {y}Æ]);
a(PC_T1 "z_library_ext" REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
val €z_finite_size_thm1› = save_pop_thm_stats "z_finite_size_thm1";
=TEX
\newpage
\subsection{Mutilated Chessboard Proof}
=SML
set_goal([], get_conjecture "-" "ran_colour_thm");
a(rewrite_tac[colour_def,
	rewrite_rule[]z_ran_mod_2_thm]);
val €ran_colour_thm› = save_pop_thm_stats "ran_colour_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "adjacent_thm");
a(z_µ_tac THEN strip_tac THEN rewrite_tac[adjacent_def]);
a(lemma_tacÒAbs (x1.1 + ~ x2.1) ç Ó ± Abs (x1.2 + ~ x2.2) ç ÓÆ
	THEN1 rewrite_tac[z_abs_nat_thm]);
a(LEMMA_TÒµi, j:Ó∑
	i + j = 1 § i = 1 ± j = 0 ≤ i = 0 ± j = 1Æ
	(fn th => ALL_FC_T1 fc_§_canon rewrite_tac[th])
	THEN1 PC_T1 "z_lin_arith" prove_tac[]);
a(rewrite_tac[rewrite_rule[] z_abs_eq_0_thm] THEN PC_T1 "z_lin_arith" prove_tac[]);
val €adjacent_thm› = save_pop_thm_stats "adjacent_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "adjacent_colour_thm");
a(rewrite_tac[adjacent_thm, colour_def, z_abs_eq_1_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (asm_tac o eq_sym_rule) 
	THEN asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm1]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN conv_tac (RAND_C eq_sym_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm1]);
(* *** Goal "3" *** *)
a(POP_ASM_T (asm_tac o eq_sym_rule) 
	THEN asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm1]);
(* *** Goal "4" *** *)
a(asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN conv_tac (RAND_C eq_sym_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm1]);
val €adjacent_colour_thm› = save_pop_thm_stats "adjacent_colour_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "domino_colour_thm");
a(z_µ_tac THEN rewrite_tac[domino_def]
	THEN REPEAT strip_tac);
a(all_fc_tac[z_size_2_thm] THEN1 all_var_elim_asm_tac1);
a(z_spec_nth_asm_tac 2 Ò(x1 ¶ x', x2 ¶ y)Æ);
a(all_fc_tac[adjacent_colour_thm]);
a(strip_asm_tac (z_µ_elimÒx'Æ ran_colour_thm));
(* *** Goal "1" *** *)
a(z_∂_tacÒ(u¶x', v¶y)Æ THEN asm_rewrite_tac[]);
a(strip_asm_tac (z_µ_elimÒyÆ ran_colour_thm));
a(swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(z_∂_tacÒ(u¶y, v¶x')Æ THEN asm_rewrite_tac[]);
a(PC_T1 "z_sets_ext" REPEAT strip_tac);
a(strip_asm_tac (z_µ_elimÒyÆ ran_colour_thm));
a(swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[]);
val €domino_colour_thm› = save_pop_thm_stats "domino_colour_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "board_finite_thm");
a(rewrite_tac[board_def]);
a(lemma_tacÒ0 .. 7 ç (Ê_)Æ
	THEN1 rewrite_tac[z_size_dot_dot_thm1]);
a(all_fc_tac[z_size_product_thm]);
val €board_finite_thm› = save_pop_thm_stats "board_finite_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "tiling_colour_thm");
a(REPEAT strip_tac);
a(z_∂_tacÒ
	{	d:z; u, v:˙ ∏ ˙
	|	d = {u, v} ±
		Colour u = 0 ±
		Colour v = 1
	∑	(u, v) } Æ);
a(rewrite_tac[z_‡_thm1, z_Ô_thm, z_è_def,
	z_≠_thm, z_ﬂ_thm, z_™_thm]);
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[tiling_def]));
a(REPEAT strip_tac);
(* *** Goal "1" duplicates "5" *** *)
a(PC_T1 "z_library_ext" once_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(z_∂_tacÒ{(x1, x2), (x3, x4)}Æ THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(z_∂_tacÒ{(x1, x2), (x3, x4)}Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" duplicates "6" *** *)
a(lemma_tacÒ≥{x, y1} ° {x, y2} = {}Æ
	THEN1 PC_T1 "z_sets_ext" prove_tac[]);
a(z_spec_nth_asm_tac 13 Ò(x¶{x, y1}, y¶{x, y2})Æ);
a(POP_ASM_T ante_tac THEN rewrite_tac[
	pc_rule1 "z_sets_ext" prove_rule[]
	Òµa, b:É∑a = b § (µx:É∑x ç a § x ç b)Æ]);
a(STRIP_T (ante_tac o z_µ_elimÒy1Æ));
a(LEMMA_T Ò≥y1 = xÆ rewrite_thm_tac
	THEN1 (contr_tac THEN all_var_elim_asm_tac));
a(DROP_NTH_ASM_T 7 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(z_∂_tacÒ{(x1, x2), y}Æ THEN asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(PC_T1 "z_sets_ext" all_asm_fc_tac[]);
a(all_fc_tac[domino_colour_thm]);
a(z_∂_tacÒvÆ THEN asm_rewrite_tac[]);
a(lemma_tacÒ≥(x1, x2) = vÆ 
	THEN1 (contr_tac
	THEN all_var_elim_asm_tac1
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]));
a(PC_T "z_predicates" all_var_elim_asm_tac1);
a(LEMMA_TÒ(x1, x2) = uÆ asm_rewrite_thm_tac);
a(DROP_NTH_ASM_T 8 strip_asm_tac);
(* *** Goal "4" duplicates "7" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(z_∂_tacÒ{x, (x1, x2)}Æ THEN asm_rewrite_tac[]);
(* *** Goal "4.2" *** *)
a(PC_T1 "z_sets_ext" all_asm_fc_tac[]);
a(all_fc_tac[domino_colour_thm]);
a(z_∂_tacÒuÆ THEN asm_rewrite_tac[]);
a(lemma_tacÒ≥(x1, x2) = uÆ 
	THEN1 (contr_tac
	THEN all_var_elim_asm_tac1
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]));
a(PC_T "z_predicates" all_var_elim_asm_tac1);
a(LEMMA_TÒ(x1, x2) = vÆ asm_rewrite_thm_tac);
a(DROP_NTH_ASM_T 8 strip_asm_tac);
(* *** Goal "8" ("5", "6", "7" were duplicates) *** *)
a(lemma_tacÒ≥{x, z'} ° {y, z'} = {}Æ
	THEN1 PC_T1 "z_sets_ext" prove_tac[]);
a(z_spec_nth_asm_tac 7 Ò(x¶{x, z'}, y¶{y, z'})Æ);
a(POP_ASM_T ante_tac THEN rewrite_tac[
	pc_rule1 "z_sets_ext" prove_rule[]
	Òµa, b:É∑a = b § (µx:É∑x ç a § x ç b)Æ]);
a(STRIP_T (ante_tac o z_µ_elimÒxÆ));
a(rewrite_tac[]);
a(LEMMA_T Ò≥x = z'Æ rewrite_thm_tac
	THEN1 (contr_tac THEN all_var_elim_asm_tac));
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
val €tiling_colour_thm› = save_pop_thm_stats "tiling_colour_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "tiling_colour_size_thm");
a(REPEAT strip_tac);
a(all_fc_tac[tiling_colour_thm]);
a(lemma_tacÒ{u : ﬁ z | Colour u = 0} Ä ﬁzÆ
	THEN1 PC_T1 "z_sets_ext" prove_tac[]);
a(all_fc_tac[z_finite_subset_thm]);
a(LIST_DROP_NTH_ASM_T [2, 4, 5] discard_tac);
a(all_fc_tac[z_finite_size_thm1, z_size_Ó_thm]);
a(all_fc_tac[z_o_è_thm]);
a(all_fc_tac[z_Ê_size_thm] THEN asm_rewrite_tac[]);
val €tiling_colour_size_thm› = save_pop_thm_stats "tiling_colour_size_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "board_tiling_thm");
a(lemma_tacÒµi, j:É∑≥2*i = 2*j + 1Æ THEN1
	(contr_tac THEN LEMMA_T
	Ò(2 * i) mod 2 = (2 * j + 1) mod 2Æ ante_tac
	THEN1 asm_rewrite_tac[]
	THEN rewrite_tac[z_mod_2_thm1]));
a(TOP_ASM_T (strip_asm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
a(z_∂_tacÒBoard ° {i, j : ˙ ∑ {(i, 2*j), (i, 2*j+1)}}Æ
	THEN rewrite_tac[tiling_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T "z_sets_ext" strip_tac
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
a(rewrite_tac[domino_def, adjacent_thm,
	rewrite_rule[]z_abs_eq_1_thm]);
a(LEMMA_TÒ≥(i, 2 * j) = (i, 2 * j + 1)Æ asm_tac
	THEN1 rewrite_tac[]);
a(ALL_FC_T rewrite_tac[z_size_pair_thm]);
a(REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1
	THEN_TRY asm_rewrite_tac[]
	THEN all_asm_ante_tac
	THEN_TRY rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
(* Just stripping gives 64 subgoals here *)
a(POP_ASM_T ante_tac THEN
	LIST_DROP_NTH_ASM_T [5, 6]
	(fn ths => 
	PC_T1 "z_library_ext" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1
	THEN_TRY asm_rewrite_tac[]
	THEN all_asm_ante_tac
	THEN_TRY rewrite_tac ths
	THEN MAP_EVERY asm_tac ths
	THEN REPEAT strip_tac
	THEN_TRY PC_T1 "z_lin_arith" asm_prove_tac[]));
(* *** Goal "3" *** *)
a(rewrite_tac[
	pc_rule1 "z_sets_ext" prove_rule[]
		Ò(µa:É; b:É∑ ﬁ(a ° b) Ä a)
		± (µa:É; b:É∑ a = b § a Ä b ± b Ä a)Æ]);
a(PC_T "z_sets_ext" strip_tac
	THEN rewrite_tac[board_def]
	THEN REPEAT strip_tac);
a(LEMMA_T Òx2 mod 2 = x2 mod 2Æ ante_tac
	THEN1 REPEAT strip_tac);
a(pure_rewrite_tac[z_mod_2_thm]);
a(REPEAT strip_tac
	THEN POP_ASM_T ante_tac
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.1" *** *)
a(z_∂_tacÒ{(x1, 2 * d), (x1, 2 * d + 1)}Æ
	THEN rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "3.1.1" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3.1.2" *** *)
a(LEMMA_TÒ≥2*d = 2*3+1Æ (strip_asm_tac o rewrite_rule[])
	THEN1 (pure_asm_rewrite_tac[] THEN REPEAT strip_tac));
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3.1.3" *** *)
a(z_∂_tacÒ(i¶x1, j¶d)Æ
	THEN PC_T1 "z_library_ext" asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(z_∂_tacÒ{(x1, 2 * d), (x1, 2 * d + 1)}Æ
	THEN rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "3.2.1" *** *)
a(LEMMA_TÒ≥2*d + 1 = 2*0Æ (strip_asm_tac o rewrite_rule[])
	THEN1 (pure_asm_rewrite_tac[] THEN REPEAT strip_tac));
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.2" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.3" *** *)
a(z_∂_tacÒ(i¶x1, j¶d)Æ
	THEN PC_T1 "z_library_ext" asm_rewrite_tac[]);
val €board_tiling_thm› = save_pop_thm_stats "board_tiling_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "colours_on_board_thm");
a(strip_asm_tac board_tiling_thm);
a(lemma_tacÒﬁz ç (Ê_)Æ THEN1
	asm_rewrite_tac[board_finite_thm]);
a(ALL_FC_T (MAP_EVERY ante_tac) [tiling_colour_size_thm]);
a(asm_rewrite_tac[]);
val €colours_on_board_thm› = save_pop_thm_stats "colours_on_board_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "colours_on_mutilated_board_thm");
a(LEMMA_T Ò
	{u : MutilatedBoard | Colour u = 0} =
	{u : Board | Colour u = 0} \ {(0, 0), (7, 7)}
±	{u : MutilatedBoard | Colour u = 1} =
	{u : Board | Colour u = 1}Æ
	rewrite_thm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[board_def, mutilated_board_def]
	THEN PC_T1 "z_library_ext" REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(swap_nth_asm_concl_tac 2 THEN
	asm_rewrite_tac[colour_def]);
(* *** Goal "1.2" *** *)
a(swap_nth_asm_concl_tac 2 THEN
	asm_rewrite_tac[colour_def]);
(* *** Goal "2" *** *)
a(LEMMA_T Ò{(0, 0), (7, 7)} Ä {u : Board | Colour u = 0}Æ asm_tac);
(* *** Goal "2.1" *** *)
a(PC_T1 "z_sets_ext" rewrite_tac[board_def]);
a(rewrite_tac[colour_def]);
(* *** Goal "2.2" *** *)
a(lemma_tac Ò{u : Board | Colour u = 0} Ä BoardÆ
	THEN1 PC_T1 "z_sets_ext" prove_tac[]);
a(strip_asm_tac board_finite_thm);
a(all_fc_tac[z_finite_subset_thm]);
a(LEMMA_TÒ≥(0, 0) = (7, 7)Æ asm_tac
	THEN1 REPEAT strip_tac);
a(all_fc_tac[z_size_pair_thm]);
a(ante_tac (
	z_µ_elim Ò(a¶{u : Board | Colour u = 0}, b¶{(0, 0), (7, 7)})Æ z_size_diff_thm
)
	THEN asm_rewrite_tac[]);
a(ALL_FC_T asm_rewrite_tac[
	pc_rule1 "z_sets_ext" prove_rule[]
	Òµa, b: É∑ b Ä a ¥ a ° b = bÆ]);
a(PC_T1 "z_lin_arith" prove_tac[]);
val €colours_on_mutilated_board_thm› =
	save_pop_thm_stats "colours_on_mutilated_board_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "mutilated_chessboard_thm");
a(contr_tac);
a(lemma_tacÒﬁz Ä BoardÆ THEN1
	(asm_rewrite_tac[mutilated_board_def]
	THEN PC_T1 "z_sets_ext" prove_tac[]));
a(strip_asm_tac board_finite_thm);
a(all_fc_tac[z_finite_subset_thm]);
a(ALL_FC_T (MAP_EVERY ante_tac) [tiling_colour_size_thm]);
a(ante_tac colours_on_mutilated_board_thm
	THEN asm_rewrite_tac[colours_on_board_thm]);
a(PC_T1 "z_lin_arith" prove_tac[]);
val €mutilated_chessboard_thm› = save_pop_thm_stats "mutilated_chessboard_thm";
=TEX
=SML

=TEX
\newpage
\section{Epilogue}
=TEX
=SML
fun sum_stats s = (switch (fold (op+)) 0 o map snd) s;
val summary_stats = 
	map (Combinators.I ** sum_stats) (!thm_stats);
val total_stats = sum_stats summary_stats;
fun check_conjecture name = (
	if	let	val tm = get_conjecture "-" name;
			val thm = get_thm "-" name;
		in	is_nil (asms thm)
		andalso	tm =$ concl thm
		end	handle Fail _ => false
	then	(delete_conjecture name;
		true)
	else	(diag_line ("Conjecture " ^ name ^ " has not been proved");
		false)
);
if all (map (check_conjecture)
	(map (hd o fst) (get_conjectures "-")))
	(fn x => x)
then	diag_line "All conjectures have been proved."
else	();
=SML
z_output_theory{out_file="mutcb.th.doc", theory="-"};
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
=TEX
\end{document}
=IGN
