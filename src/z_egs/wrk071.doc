=IGN
=TEX
\documentclass[12pt]{article}
\usepackage{ProofPower}
\usepackage{A4}
\usepackage{latexsym}
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\def\Hide#1{\relax}
\title{Mutilated Chessboard \\ (DRAFT)}
\author{R.D. Arthan}
\makeindex
\begin{document}
\maketitle
\begin{abstract}
John McCarthy's Mutilated Chessboard problem in set theory, more specifically Z.
\end{abstract}
\section{Introduction}\label{Intro}

\Hide{
The following ML sets up a context for giving the {\ProductZ} specifications.
=SML
open_theory"z_library";
set_pc"z_library1";
force_delete_theory"mutcb" handle Fail _ => ();
new_theory"mutcb";
=TEX
}

¹ZAX
Ü ÛAbsÝ : ú ­ ú
÷üüüüüü
Ü Abs = {i, a:ú | i ¾ 0 ± a = i ² i < 0 ± a = ~i}
°
¹Z
Ü ÛBoardÝ ¦ (0 .. 7) ¸ (0 .. 7)
°
¹Z
Ü ÛMutilatedBoardÝ ¦ Board \ {(0,0), (7,7)}
°

¹ZAX
Ü ÛAdjacentÝ : ð((ú ¸ ú) ¸ (ú ¸ ú))
÷üüüüüü
Ü µx1, x2:ú ¸ ú·
Ü	(x1, x2)  Adjacent
Ü ¤	Abs(x1.1 - x2.1) = 1 ± x1.2 = x2.2
Ü ²	Abs(x1.2 - x2.2) = 1 ± x1.1 = x2.1
°
¹ZAX
Ü ÛDominoÝ : ð(ð(ú ¸ ú))
÷üüüüüü
Ü µx:ð(ú ¸ ú)·
Ü	x  Domino
Ü ¤	x  æ(ú ¸ ú) ± #x = 2
Ü ±	(µx1, x2:ú ¸ ú·x1 ½ x2 ± x1  x ± x2  x ´ (x1, x2)  Adjacent)
°
¹ZAX
Ü ÛDominoOnBoardÝ : ð(ð(ú ¸ ú))
÷üüüüüü
Ü µx:ð(ú ¸ ú)·
Ü	x  DominoOnBoard
Ü ¤	x € Board ± x  Domino
°
¹ZAX
Ü ÛPartialCoveringÝ : ð(ð(ð(ú ¸ ú)))
÷üüüüüü
Ü µz:ð(ð(ú ¸ ú))·
Ü	z  PartialCovering
Ü ¤	(µx:z· x  DominoOnBoard)
Ü ±	(µx, y:z·x = y ² x ¡ y = {})
°
The following definition is used in the proof.
¹ZAX
Ü ÛColourÝ : ú ¸ ú ­ {0, 1}
÷üüüüüü
Ü µx: ú ¸ ú· Colour x = (x.1 + x.2) mod 2
°
¹Z
Ü Ûz_abs_eq_thmÝ ?ô µi, j:ú· Abs i = j ¤ (i, j)  Abs
°
¹Z
Ü Ûz_abs_clausesÝ ?ô
Ü	Abs 0 = 0
Ü ±	(µm:î· Abs m = m ± Abs (~m) = m)
°
¹Z
Ü Ûz_abs_eq_0_thmÝ ?ô
Ü µi, j:ú·
Ü	Abs (i - j) = 0
Ü ¤	i = j
°
¹Z
Ü Ûz_abs_eq_1_thmÝ ?ô
Ü µi, j:ú·
Ü	Abs (i - j) = 1
Ü ¤	i < j ± j = i + 1 ² j < i ± i = j + 1
°
¹Z
Ü Ûz_mod_2_thmÝ ?ô
Ü µi, j:ú· i mod 2 = j ¤ j  {0, 1} ± (¶d:ƒ· i = 2*d + j)
°
¹Z
Ü Ûz_ran_mod_2_thmÝ ?ô µi:ú·i mod 2  {0, 1}
°
¹Z
Ü Ûz_plus_1_mod_2_thmÝ ?ô µi:ú· ³i mod 2 = (i + 1) mod 2
°
¹Z
Ü Ûz_size_pair_thmÝ ?ô µx, y:ƒ | ³x = y ·{x, y}  (æ_) ± #{x, y} = 2
°
¹Z
Ü Ûz_size_eq_thmÝ ?ô µa, b:(æ_) | a € b ± #a = #b · a = b 
°
¹Z
Ü Ûz_size_2_thmÝ ?ô µa:(æ_)· #a = 2 ¤ (¶x, y:ƒ·³x = y ± a = {x, y})
°
¹Z
Ü Ûz_size_product_thmÝ ?ô µa : (æ_); b:(æ_)· a ¸ b  (æ_) ± #(a ¸ b) = #a * #b
°
¹Z
Ü Ûz_ran_finite_thmÝ ?ô µf: (_­_); a:(æ_)· {x:a; y:ƒ|(x, y)  f·y}  (æ_)
°
¹Z
Ü Ûz_finite_powerset_thmÝ ?ô µa:(æ_)· ða  (æ_)
°
¹Z
Ü Ûadjacent_colour_thmÝ ?ô µu, v:ú ¸ ú·(u, v)  Adjacent ´ Colour u ½ Colour v
°
¹Z
Ü Ûran_colour_thmÝ ?ô µu:ú ¸ ú· Colour u  {0, 1}
°
¹Z
Ü Ûdomino_colour_thmÝ ?ô µx:Domino·¶u, v:x·x = {u, v} ± Colour u = 0 ± Colour v = 1
°
=TEX
\newpage
\appendix
=TEX
{\HOLindexOff\small
\let\Section\section
\def\section#1{\Section{#1}\label{THEORYLISTING}}
\include{mutcb.th}}

\twocolumn[\section{INDEX}\label{INDEX}]
\printindex
=TEX
\end{document}
=SML
val Ûú_¸_ú_lemmaÝ = pc_rule1 "z_sets_ext" prove_rule[get_specñú®]ñú ¸ ú = ƒ®;
=TEX
=SML
val Ûz_abs_defÝ = z_get_specñAbs®;
val Ûadjacent_defÝ = z_get_specñAdjacent®;
val Ûboard_defÝ = z_get_specñBoard®;
val Ûmutilated_board_defÝ = z_get_specñMutilatedBoard®;
val Ûdomino_defÝ =
	rewrite_rule[ú_¸_ú_lemma](z_get_specñDomino®);
val Ûdomino_on_board_defÝ =
	rewrite_rule[ú_¸_ú_lemma](z_get_specñDominoOnBoard®);
val Ûpartial_covering_defÝ =
	rewrite_rule[ú_¸_ú_lemma](z_get_specñPartialCovering®);
val Ûcolour_defÝ = z_get_specñColour®;
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_eq_thm");
a(z_µ_tac THEN strip_tac);
a(bc_thm_tac
	(rewrite_rule[](conv_rule (MAP_C z_µ_elim_conv) (z_­_app_eq_¤__rel_thm))));
a(¶_tacñú® THEN ¶_tacñú® THEN rewrite_tac[z_abs_def]);
val Ûz_abs_eq_thmÝ = save_pop_thm "z_abs_eq_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_clauses");
a(rewrite_tac[z_abs_eq_thm]);
a(rewrite_tac[z_abs_def]);
a(PC_T1 "z_lin_arith" prove_tac[]);
val Ûz_abs_clausesÝ = save_pop_thm "z_abs_clauses";
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_eq_0_thm");
a(z_µ_tac THEN strip_tac);
a(strip_asm_tac(z_µ_elim ñi + ~j® z_ú_cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[z_abs_clauses]
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val Ûz_abs_eq_0_thmÝ = save_pop_thm "z_abs_eq_0_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_abs_eq_1_thm");
a(z_µ_tac THEN strip_tac);
a(strip_asm_tac(z_µ_elim ñi + ~j® z_ú_cases_thm)
	THEN ALL_FC_T asm_rewrite_tac[z_abs_clauses]
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val Ûz_abs_eq_1_thmÝ = save_pop_thm "z_abs_eq_1_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_mod_2_thm");
a(z_µ_tac THEN strip_tac);
a(LEMMA_T ñ³2 = 0® asm_tac THEN1 REPEAT strip_tac);
a(ALL_FC_T1 fc_¤_canon rewrite_tac
	[rewrite_rule[](conv_rule (MAP_C z_µ_elim_conv) (z_mod_thm))]);
a(REPEAT strip_tac THEN_TRY
	z_¶_tac ñd º ú® THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val Ûz_mod_2_thmÝ = save_pop_thm "z_mod_2_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_ran_mod_2_thm");
a(contr_tac);
a(fc_tac[
	inst_term_rule [(ñi mod 2®, ñj º ú®)]
		(all_µ_elim (hd (fc_canon z_mod_2_thm)))]);
val Ûz_ran_mod_2_thmÝ = save_pop_thm "z_ran_mod_2_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_plus_1_mod_2_thm");
a(REPEAT strip_tac);
a(lemma_tac¬¶j·ñ(i + 1) mod 2 = j®® THEN1 prove_¶_tac);
a(asm_rewrite_tac[] THEN POP_ASM_T ante_tac);
a(rewrite_tac[z_mod_2_thm] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1
	THEN all_asm_ante_tac THEN rewrite_tac[] THEN contr_tac);
(* *** Goal "1" duplicates "2" *** *)
a(lemma_tacñ0 < d - d' < 1 ® THEN
	PC_T1 "z_lin_arith" asm_prove_tac[]);
val Ûz_plus_1_mod_2_thmÝ = save_pop_thm "z_plus_1_mod_2_thm";
val Ûz_plus_1_mod_2_thmÝ =
	conv_rule (ONCE_MAP_C z_anf_conv) z_plus_1_mod_2_thm;
=TEX
=SML
val Ûz_æ_À_singleton_thm1Ý = z_gen_pred_elim[ñƒ®] z_æ_À_singleton_thm;
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_pair_thm");
a(z_µ_tac THEN strip_tac);
a(lemma_tacñ{y}  (æ_) ± #{y} = 1® THEN1 rewrite_tac[z_size_singleton_thm]);
a(ante_tac (z_µ_elimñ(x ¦ x, a ¦ {y})® z_size_À_singleton_thm));
a(ante_tac (z_µ_elimñ(x ¦ x, a ¦ {y})® z_æ_À_singleton_thm1));
a(asm_rewrite_tac[z_size_singleton_thm]);
a(LEMMA_T ñ{x, y} = {y} À {x}® rewrite_thm_tac
	THEN PC_T1 "z_sets_ext" prove_tac[]);
val Ûz_size_pair_thmÝ = save_pop_thm "z_size_pair_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_eq_thm");
a(PC_T "z_sets_ext" contr_tac
	THEN1 all_asm_fc_tac[]);
a(lemma_tacña € a À {x1} ± a À {x1} € b® THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(strip_asm_tac (z_µ_elimñ(x ¦ x1, a ¦ a)® z_size_À_singleton_thm));
a(strip_asm_tac (z_µ_elimñ(x ¦ x1, a ¦ a)® z_æ_À_singleton_thm1));
a(strip_asm_tac (z_µ_elimñ(a ¦ b, b ¦ a À {x1})® z_size_mono_thm));
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
val Ûz_size_eq_thmÝ = save_pop_thm "z_size_eq_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_2_thm");
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_sets_ext" lemma_tac ñ³a = {}®
	THEN1 (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[z_size_empty_thm]));
a(PC_T1 "z_sets_ext" lemma_tac ñ³a = {x1}®
	THEN1 (swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[z_size_singleton_thm])
	THEN_TRY all_var_elim_asm_tac1);
a(lemma_tacñ{x2, x1}  (æ_) ± #{x2, x1} = 2® THEN1
	ALL_FC_T rewrite_tac[z_size_pair_thm]);
a(LEMMA_Tñ{x2, x1} € a® asm_tac THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(ante_tac (z_µ_elimñ(a ¦ {x2, x1}, b ¦ a)® z_size_eq_thm));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(z_¶_tacñ(x ¦ x2, y ¦ x1)® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(ALL_FC_T asm_rewrite_tac[z_size_pair_thm]);
val Ûz_size_2_thmÝ = save_pop_thm "z_size_2_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_size_product_thm");
a(z_µ_tac THEN strip_tac);
a(z_æ_induction_tacña®);
(* *** Goal "1" *** *)
a(rewrite_tac[z_size_empty_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[
	pc_rule1 "z_library_ext"
		prove_rule[] ñ(a À {x})  ¸ b = (a ¸ b) À ({x} ¸ b)®]);
a(lemma_tacñ(a ¸ b) ¡ ({x} ¸ b) = {}® THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(lemma_tacñ({x} ¸ b)  (æ_) ± #({x} ¸ b) = #b®);
(* *** Goal "2.1" *** *)
a(LIST_DROP_NTH_ASM_T [1, 2, 3, 4, 5] discard_tac);
a(z_æ_induction_tacñb®
	THEN1 rewrite_tac[z_size_empty_thm]);
a(rewrite_tac[
	pc_rule1 "z_library_ext"
		prove_rule[] ñ{x} ¸ (b À {x'}) = ({x} ¸ b) À {(x, x')}®]);
a(LEMMA_Tñ³(x, x')  ({x} ¸ b)® asm_tac THEN1
	PC_T1 "z_sets_ext" asm_prove_tac[]);
a(ante_tac (z_µ_elimñ(x ¦ (x, x'), a ¦ {x} ¸ b)® z_size_À_singleton_thm));
a(ante_tac (z_µ_elimñ(x ¦ x', a ¦ b)® z_size_À_singleton_thm));
a(ante_tac (z_µ_elimñ(x ¦ (x, x'), a ¦ {x} ¸ b)® z_æ_À_singleton_thm1));
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(ante_tac (z_µ_elimñ(a ¦ a ¸ b, b ¦ {x} ¸ b)® z_size_À_thm));
a(asm_rewrite_tac[z_size_empty_thm]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[z_size_À_singleton_thm]);
a(PC_T1 "z_lin_arith" prove_tac[]);
val Ûz_size_product_thmÝ = save_pop_thm "z_size_product_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_ran_finite_thm");
a(REPEAT strip_tac);
a(z_æ_induction_tacña®);
(* *** Goal "1" *** *)
a(rewrite_tac[
	z_size_empty_thm,
	pc_rule1 "z_library_ext"
prove_rule[] ñ{x : {}; y : ƒ | (x, y)  f · y} = {}®]);
(* *** Goal "2" *** *)
a(LEMMA_T ñx  ƒ® asm_tac THEN REPEAT strip_tac);
a(LEMMA_T ñ{x' : a À {x}; y : ƒ | (x', y)  f · y} = {x' : a; y : ƒ | (x', y)  f · y} À {f x}®
	rewrite_thm_tac THEN1
	PC_T1 "z_sets_ext" REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac1);
(* *** Goal "2.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(ALL_FC_T rewrite_tac [z_­__rel_¤_app_eq_thm]);
(* *** Goal "2.3" *** *)
a(z_¶_tacñ(x'¦x', y¦x1)® THEN REPEAT strip_tac);
(* *** Goal "2.4" *** *)
a(z_¶_tacñ(x'¦x, y¦f x)® THEN REPEAT strip_tac);
a(all_fc_tac[z_­_app_thm]);
(* *** Goal "2.5" *** *)
a(ALL_FC_T rewrite_tac [z_æ_À_singleton_thm1]);
val Ûz_ran_finite_thmÝ = save_pop_thm "z_ran_finite_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "z_finite_powerset_thm");
a(REPEAT strip_tac);
a(z_æ_induction_tacña®);
(* *** Goal "1" *** *)
a(rewrite_tac[
	z_size_singleton_thm,
	pc_rule1 "z_sets_ext"
		prove_rule[] ñð{} = {{}}®]);
(* *** Goal "2" *** *)
a(lemma_tacñ
	¶f:(_­_)·ð(a À {x})={x:{0, 1} ¸ ða; y:ƒ|(x, y)  f·y}
®);
(* *** Goal "2.1" *** *)
a(z_¶_tacñ{p:ƒ ¸ ƒ; b:ƒ | p.1 = 0 ± b = p.2 ² ³p.1 = 0 ± b = p.2 À {x}·(p, b)}®);
a(REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(PC_T1 "z_library_ext" REPEAT strip_tac
	THEN_TRY SOLVED_T(POP_ASM_T ante_tac THEN asm_rewrite_tac[]));
a(PC_T1 "z_sets_ext" once_rewrite_tac[]);
a(cases_tacñx1 = 0® THEN asm_rewrite_tac[]);
(* *** Goal "2.1.1.1" *** *)
a(z_¶_tacñx2® THEN rewrite_tac[]);
(* *** Goal "2.1.1.2" *** *)
a(z_¶_tacñx2 À {x}® THEN rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a(PC_T1 "z_sets_ext" once_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.1.2.1" *** *)
a(lemma_tacñx1 \ {x} € a® THEN1 PC_T1 "z_sets_ext" asm_prove_tac[]);
a(cases_tacñx  x1®);
(* *** Goal "2.1.2.1.1" *** *)
a(z_¶_tacñ(x'¦(1, x1 \ {x}), y¦x1)®
	THEN asm_rewrite_tac[]);
a(PC_T1 "z_sets_ext" asm_prove_tac[]);
(* *** Goal "2.1.2.1.2" *** *)
a(z_¶_tacñ(x'¦(0, x1 \ {x}), y¦x1)®
	THEN asm_rewrite_tac[]);
a(PC_T1 "z_sets_ext" asm_prove_tac[]);
a(contr_tac THEN all_var_elim_asm_tac1);
(* *** Goal "2.1.2.2" *** *)
a(all_var_elim_asm_tac1);
a(PC_T1 "z_sets_ext" asm_prove_tac[]);
(* *** Goal "2.1.2.3" *** *)
a(all_var_elim_asm_tac1);
a(PC_T1 "z_sets_ext" asm_prove_tac[]);
(* *** Goal "2.1.2.4" *** *)
a(all_var_elim_asm_tac1);
a(PC_T1 "z_sets_ext" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(LEMMA_T ñ³0 = 1® asm_tac THEN REPEAT strip_tac);
a(lemma_tacñ{0, 1}  (æ_)® THEN1
	all_fc_tac[z_size_pair_thm]);
a(lemma_tacñ{0, 1} ¸ ða  (æ_)® THEN1
	all_fc_tac[z_size_product_thm]);
a(all_fc_tac[z_ran_finite_thm]);
val Ûz_finite_powerset_thmÝ = save_pop_thm "z_finite_powerset_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "ran_colour_thm");
a(rewrite_tac[colour_def,
	rewrite_rule[]z_ran_mod_2_thm]);
val Ûran_colour_thmÝ = save_pop_thm "ran_colour_thm";
=TEX
=SML
set_goal([], get_conjecture "-" "adjacent_colour_thm");
a(rewrite_tac[adjacent_def, colour_def, z_abs_eq_1_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (asm_tac o eq_sym_rule) 
	THEN asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN conv_tac (RAND_C eq_sym_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm]);
(* *** Goal "3" *** *)
a(POP_ASM_T (asm_tac o eq_sym_rule) 
	THEN asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm]);
(* *** Goal "4" *** *)
a(asm_rewrite_tac[]
	THEN conv_tac (ONCE_MAP_C z_anf_conv)
	THEN conv_tac (RAND_C eq_sym_conv)
	THEN rewrite_tac[z_plus_1_mod_2_thm]);
val Ûadjacent_colour_thmÝ = save_pop_thm "adjacent_colour_thm";

=TEX
=SML
set_goal([], get_conjecture "-" "domino_colour_thm");
a(z_µ_tac THEN rewrite_tac[domino_def]
	THEN REPEAT strip_tac);
a(all_fc_tac[z_size_2_thm] THEN1 all_var_elim_asm_tac1);
a(z_spec_nth_asm_tac 2 ñ(x1 ¦ x', x2 ¦ y)®);
a(all_fc_tac[adjacent_colour_thm]);
a(strip_asm_tac (z_µ_elimñx'® ran_colour_thm));
(* *** Goal "1" *** *)
a(z_¶_tacñ(u¦x', v¦y)® THEN asm_rewrite_tac[]);
a(strip_asm_tac (z_µ_elimñy® ran_colour_thm));
a(swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(z_¶_tacñ(u¦y, v¦x')® THEN asm_rewrite_tac[]);
a(PC_T1 "z_sets_ext" REPEAT strip_tac);
a(strip_asm_tac (z_µ_elimñy® ran_colour_thm));
a(swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[]);
val Ûdomino_colour_thmÝ = save_pop_thm "domino_colour_thm";
=TEX
\ftlinepenalty=999
=SML

=TEX
\section{Epilogue}
=TEX
=SML
fun check_conjecture name = (
	if	let	val tm = get_conjecture "-" name;
			val thm = get_thm "-" name;
		in	is_nil (asms thm)
		andalso	tm =$ concl thm
		end	handle Fail _ => false
	then	true
	else	(diag_line ("Conjecture " ^ name ^ " has not been proved");
		false)
);
if all (map (check_conjecture)
	(map (hd o fst) (get_conjectures "-")))
	(fn x => x)
then	diag_line "All conjectures have been proved."
else	();
=SML
z_output_theory{out_file="mutcb.th.doc", theory="-"};
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROOF SCRIPTS END HERE
=TEX
\end{document}
=IGN
