=IGN
********************************************************************************
%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING, E.G. FOR QCZ:
wrk084.doc: this file is part of the ProofPower system

Copyright (c) Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% $Id: wrk084.doc,v 1.3 2014/02/14 18:13:00 rda Exp rda $
=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,12pt]{article}
%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex
\ftlinepenalty=9999

%%%%% YOU WILL WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{ OpenTheory for ProofPower }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document discusses an experimental implementation
of OpenTheory for {\Product}.}
\end{center}}

\def\Reference{LEMMA1/QCZ/WRK084}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 7947 030 682}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.3 $%
}
\def\Date{\FormatDate{$Date: 2014/02/14 18:13:00 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\newpage
\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}

%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1] Initial draft.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}
 
%%%%% DISTRIBUTION LIST

%\subsection{Distribution}
%\begin{center}
%\begin{tabular}{ll}
%Rob Arthan & Lemma 1\\
%\end{tabular}
%\end{center}

%%%%% NOW THE CREATIVE BIT:
\newpage

\section{INTRODUCTION}
{\Product} is an interactive theorem prover in the HOL family, that {\it inter alia}
provides proof support for the Z notation and is used as the proof engine for
Z in D-RisQ's CLawZ toolset \cite{OHalloran13}.

OpenTheory \cite{hurd11} is an initiative to develop a concept of {\em theory engineering} for the
development and management of large bodies of formal specifications and proofs, analogous to the
concept of {\em software engineering} that arose in the 1960s for the development and management
of large software systems.
OpenTheory defines an {\em article} format that can be used to transfer
definitions and theorems from one theorem proving system in the HOL
family to another. This is
supported by the {\tt opentheory} tool which provides a number of useful
services for grouping articles into packages and for managing a set of packages.

In order to provide some level of inter-operability between {\Product} and
other implementations of HOL, specifically to allow specifications to
be transferred between the two systems. As part of a research programme
funded by DSTL, D-RisQ have commissioned
an experimental implementation of OpenTheory  in {\Product}.
This document is a {\Product} literate script that contains this
implemementation and some discussion of its capabilities and of further work
that could be done in this area.

The OpenTheory interface provided here comprises a {\em reader} for importing
OpenTheory articles and a {\em writer} for exporting them.
Both these interfaces are experimental and are likely to need further customisation
but they serve the basic goal of transferring specifications between HOL4 and {\Product}.

The remainder of this document is structured as follows:
\begin{description}
\item[Section~\ref{sec:discussion}] discusses OpenTheory and the present
implementation of it in {\Product}.
\item[Section~\ref{sec:structure}] documents the interfaces provided in
the style of the {\Product} reference manual.
\item[Appendix~\ref{sec:implementation}] is the {\Product} literate script that
implements the interfaces. (There is an index to the implementation at the end of
the document.)
\end{description}

\newpage
\section{DISCUSSION}\label{sec:discussion}
\subsection{Overview of OpenTheory}
The goal of OpenTheory is to allow proofs and the specifications on which
those proofs depend to be shared between different
implementations higher-order logic (HOL) theorem provers, specifically,
HOL4, HOL Light and {\Product}.
The Gilith OpenTheory Repo, a collection of theory packages containing
a large collection of proofs extending a base theory package containing
definitions intended to be common to all HOL implementations.

The OpenTheory project has defined two file formats that are used to
describe theory packages: the {\em article file format} is the basic
mechanism for transferring specifications and proofs;
the {\em theory file format} describes how one or more article files
can be combined into a package. In this document we are only
concerned with importing from and exporting to article files
(The {\tt opentheory} tool can be used, as needed, to create theory
files.)

An article file comprises a sequence of commands for a virtual machine.
The virtual machine constructs HOL types, terms and theorems and outputs
two sets: a set of assumptions, i.e., axioms, and a set of theorems,
i.e., assertions that have been proved using the axioms.
An implementation in a system like {\Product} can realise the virtual
machine so that the output is added to its database of
definitions, axioms and theorems.
The OpenTheory reader for {\Product} does exactly that.

We did not think that the Gilith OpenTheory Repo would be relevant to the
specific problem of transferring specifications from HOL4 to {\Product}.
However, it turned out to be very useful both as a source of test material
and in defining a common vocabulary that is used by the HOL4 implementation
of an OpenTheory writer.

\subsection{{\Product} OpenTheory Reader}
The OpenTheory reader is based on a generic implementation
of the OpenTheory virtual machine with parameters defining the
mapping of the vocabulary and definitions in the input to
{\Product} vocabulary and extension mechanisms.
This has then been instantiated to accept the vocabulary and
definitions used by the Gilith OpenTheory Repo and the HOL4 OpenTheory writer.

There is an issue with the packaging of the base theory package in the Gilith OpenTheory Repo
that is under discussion. The issue is that the package currently gives concrete constructions of
types rather than abstract specifications. This results in certain constants appearing in the
name space that are not actually part of the documented interface. For this reason,
the {\Product} reader currently only maps the basic logical vocabulary to native {\Product}
vocabulary. Vocabulary relating to defined types, such as lists or numbers, is
defined afresh when the base theory article is imported.

Once the mapping of vocabulary is settled importing proofs is relatively straightforward
since one has all the capabilities of {\Product} available to implement the OpenTheory
inference rules as derived rules.
The mapping of the definitional principle of OpenTheory is also straightforward, but slightly
complicated in the present implementation to support the handling of the basic logical
vocabulary of the base theory package in the Gilith OpenTheory Repo. This is done by
recognising the OpenTheory definitions of the logical operators and substituting
a theorem derived from the {\Product} definitions.

\subsection{{\Product} OpenTheory Writer}
The OpenTheory writers for HOL4 and HOL Light use a special version of the logical
kernel that includes a proof tree in the representation of a theorem. 
{\Product} enables functions that monitor logical kernel operations to be registered
and the {\Product} OpenTheory writer uses this facility to export a trace
of the kernel operations as an OpenTheory article. The process is parametrized
by functions that map type and constant names to the desired external form.

Exporting proofs is a more intricate problem than importing them because OpenTheory
does not provide high-level facilities for programming proofs. (This is intended,
since it makes the OpenTheory kernel small, simple and dependable.)

\newpage
\section{THE STRUCTURE OpenTheory}\label{sec:structure}
The OpenTheory implementation is packaged in a structure (i.e., a Standard ML module)
with the following signature.
(As usual in {\Product} we document a structure by annotating its
signature with narrative describing the intended implementation.)
=SML
signature €OpenTheory› = sig
=TEX

\subsection{The Reader}\label{sec:reader}

\subsubsection{Command Interface}

=DOC
val €open_theory_import› : {file : string, parent : string, theory : string} -> unit;
=DESCRIBE
This function provides a simple interface to the OpenTheory reader to
import a single article file into a {\Product} theory.
It expects the article to use the naming conventions and definitions
of the Gilith OpenTheory Repo.
The article file is loaded into the named theory, which is newly created
for the purpose (any existing theory of that name is deleted).
The theory is created as a child of the indicated parent theory and
the theory ``open-theory-base'' is made a parent if it is not an ancestor
of the specified parent.


=ENDDOC
\subsubsection{Programmatic Interface}
For experimental purposes, the core functionality of the OpenTheory reader
is presented as a programmable interface to the OpenTheory
virtual machine.
=TEX
A name in an article file is a pair comprising a hierarchical name space and the name of a component within that namespace.
=SML
type €NAME› = string list * string;
=TEX
The virtual machine is parametrized by tables mapping OpenTheory names to the
{\Product} names of types and constants.
=SML
type €NAME_MAPS› = {
	type_map : (NAME * string) list,
	const_map : (NAME * string) list
};
=TEX
The types {\em TYPE\_DEFN\_INFO} and {\em ABS\_REP\_THMS} represent
the inputs and outputs of the {\em defineTypeOp} command.
The virtual machine is parametrized by a function that provides the semantics
for this command. This function may, for example, create the outputs using
an existing type definition rather than trying to define
a new type.
=SML
type €TYPE_DEFN_INFO› =  {
	thm : THM,
	pars : string list,
	rep : string,
	abs : string,
	tyname : string
};
type €ABS_REP_THMS› = {
	abs_rep : THM,
	rep_abs : THM
};
=TEX
The type {\em CONST\_DEFN\_INFO} represents the inputs of the {\em defineConst}
command.
The virtual machine is parametrized by a function that maps these inputs
to the desired designing theorem, e.g., by using the defining property of
an existing constant.
=SML
type €CONST_DEFN_INFO› = {
	name : string,
	def_rhs : TERM
};
=TEX
The import interface then comprises the parameters discussed above together
with a function {\em declare\_axiom} to handle the {\em axiom} command.
{\em declare\_axiom} will typically use various heuristics to attempt to
prove the axiom rather than create an actual {\Product} axiom.
=SML
type €IMPORT_INTERFACE› = {
	declare_axiom : SEQ -> THM,
	define_type_op : TYPE_DEFN_INFO -> ABS_REP_THMS,
 	define_const : CONST_DEFN_INFO -> THM,
	const_name : NAME -> string,
	type_name : NAME -> string 
};
=TEX
The objects that the virtual machine deals with range over the type {\em OBJECT}:
=SML
datatype €OBJECT› =
		€ONum› of INTEGER    		(* A number *)
	|	€OName› of NAME		(* A name *)
	|	€OList› of OBJECT list		(* A list (or tuple) of objects *)
	|	€OTypeOp› of string		(* A higher order logic type operator *)
	|	€OType› of TYPE			(* A higher order logic type *)
	|	€OConst› of NAME			(* A higher order logic constant *)
	|	€OVar› of string * TYPE		(* A higher order logic term variable *)
	|	€OTerm› of TERM			(* A higher order logic term *)
	|	€OThm› of THM			(* A higher order logic theorem *);
=TEX
The state of the virtual machine includes a dictionary mapping integers
to objects:
=SML
type €OBJECT_DICT› = (int, OBJECT) SEARCH_TREE;
type €WM_STATE› = {
	interface : IMPORT_INTERFACE,
	stack : OBJECT list,
	dictionary : OBJECT_DICT,
	assumptions : THM NET,
	theorems : THM NET};
=TEX
{\em vm\_diagnostics} can be set to give various levels of diagnostic
output.
=SML
val €vm_diagnostics› : int ref;
=TEX
The virtual machine records its current state in the variable {\em diag\_state}.
=SML
val €diag_state› : WM_STATE OPT ref;
=TEX
The programmatic interface to the virtual machine is the following
function.
The second parameter represents the input stream.
=SML
val €open_theory_vm› : IMPORT_INTERFACE -> 
	('s -> (string * 's) OPT) -> 's -> WM_STATE;
=TEX
\subsection{The Writer}\label{sec:writer}
\subsubsection{Parameters}
The writer is parametrized by functions that map type and constant names to
OpenTheory names.
=TEX
=SML
type EXPORT_INTERFACE = {
	type_name : string -> NAME,
	const_name : string -> NAME};
=TEX
=SML
val export_interface : EXPORT_INTERFACE ref;
=TEX
\subsubsection{Interface}
=DOC
val €proof_to_article› : {file: string, prf_fun: 'a -> THM list} -> 'a -> unit;
=DESCRIBE
This function generates an OpenTheory article from a function that proves
 a list of theorems. This provides a simple mechanism for
transferring proofs from {\Product} to another HOL system or to the Gilith OpenTheory Repository.
=ENDDOC
=DOC
val €term_to_article› : {tm: TERM, file: string} -> unit;
=DESCRIBE
This function generates an OpenTheory article from a term, $t$.
The article proves the theorem $t = t$. This provides a simple mechanism for
transferring terms from {\Product} to another HOL system.
=ENDDOC
=SML
end (* of signature OpenTheory *);
=TEX
\subsection{Errors}
The OpenTheory interfaces define the following error messages.
=FAILURE
122001	invalid stack. Expected ?0
122002	unexpected empty stack
122003	invalid command ?0
122004	invalid name (final quotation symbol missing)
122005	invalid name (junk after final quotation symbol)
122006	invalid name (ends with a backslash)
122007	invalid variable or type variable name (not in global namespace)
122008	invalid list
122009	¨?0Æ is not of type îBOOLÆ
122010	attempt to access non-existent dictionary entry
122011	ill-formed substitution
122012	invalid command
122013	Cannot define ?0 = ?1 (?0 clashes with an existing constant, original exception: ?2)
=TEX

\newpage
\appendix
\section{IMPLEMENTATION}\label{sec:implementation}
=TEX
=SML
structure €OpenTheoryInternals› = struct 
=TEX
=IGN
use_file "opentheory";
val _ = open_theory_import{file = "basethms.art", parent = "open-theory-base", theory = "t"};
output_theory{theory = "t", out_file = "t.thy.doc"};
=TEX

\subsection{Interface Types}

=SML
type €NAME› = string list * string;
type €NAME_MAPS› = {
	type_map : (NAME * string) list,
	const_map : (NAME * string) list
};
type €TYPE_DEFN_INFO› =  {
	thm : THM,
	pars : string list,
	rep : string,
	abs : string,
	tyname : string
};
type €CONST_DEFN_INFO› = {name : string, def_rhs : TERM};
type €ABS_REP_THMS› = {abs_rep : THM, rep_abs : THM};
type €IMPORT_INTERFACE› = {
	declare_axiom : SEQ -> THM,
	define_type_op : TYPE_DEFN_INFO -> ABS_REP_THMS,
 	define_const : CONST_DEFN_INFO -> THM,
	const_name : NAME -> string,
	type_name : NAME -> string 
};
=SML
datatype €OBJECT› =
		€ONum› of INTEGER    		(* A number *)
	|	€OName› of NAME		(* A name *)
	|	€OList› of OBJECT list		(* A list (or tuple) of objects *)
	|	€OTypeOp› of string		(* A higher order logic type operator *)
	|	€OType› of TYPE			(* A higher order logic type *)
	|	€OConst› of NAME			(* A higher order logic constant *)
	|	€OVar› of string * TYPE		(* A higher order logic term variable *)
	|	€OTerm› of TERM			(* A higher order logic term *)
	|	€OThm› of THM			(* A higher order logic theorem *);
=TEX
\subsection{Reader}
=TEX
=SML
val €vm_diagnostics› : int ref = ref 0;
=TEX
\subsubsection{Virtual Machine Types}
=SML
type €OBJECT_DICT› = (int, OBJECT) SEARCH_TREE;
type €WM_STATE› = {
	interface : IMPORT_INTERFACE,
	stack : OBJECT list,
	dictionary : OBJECT_DICT,
	assumptions : THM NET,
	theorems : THM NET};
=TEX
\subsubsection{State Access Functions}
=TEX
=SML
fun €convert_var_name› ( ([], base) : NAME ) : string = (
	base
) | convert_var_name _ = fail "open-theory-reader" 122007 [];
=TEX
=SML
fun €convert_tyvar_name› ( ([], base) : NAME ) : string = (
	case explode base of
		"'"::_ => base
	|	_ => "'" ^ base
) | convert_tyvar_name _ = fail "open-theory-reader" 122007 [];
=SML
fun €initial_vm_state› (interface : IMPORT_INTERFACE) : WM_STATE = ({
	interface = interface,
	stack = [],
	dictionary = initial_search_tree int_order,
	assumptions = empty_net,
	theorems = empty_net}
);
=TEX
=SML
fun €push_object› (ob : OBJECT)
	({interface, stack, dictionary, assumptions, theorems} : WM_STATE)
		: WM_STATE = (
	{	interface = interface,
		stack = ob::stack,
		dictionary = dictionary,
		assumptions = assumptions,
		theorems = theorems }
);
=TEX
=SML
fun €pop_object›
	({interface, stack, dictionary, assumptions, theorems} : WM_STATE)
		: OBJECT * WM_STATE = (
	case stack of
		h::t =>
		(h,
		{	interface = interface,
			stack = t,
			dictionary = dictionary,
			assumptions = assumptions,
			theorems = theorems })
	|	[] => fail "open-theory-reader" 122002 []
);
=TEX
=SML
fun €push_num› (x : INTEGER) (st : WM_STATE) : WM_STATE =
	push_object (ONum x) st;
fun €push_name› (x : NAME) (st : WM_STATE) : WM_STATE =
	push_object (OName x) st;
fun €push_list› (x : OBJECT list) (st : WM_STATE) : WM_STATE =
	push_object (OList x) st;
fun €push_type_op› (x : string) (st : WM_STATE) : WM_STATE =
	push_object (OTypeOp x) st;
fun €push_type› (x : TYPE) (st : WM_STATE) : WM_STATE =
	push_object (OType x) st;
fun €push_const› (x : NAME) (st : WM_STATE) : WM_STATE =
	push_object (OConst x) st;
fun €push_var› (x : string * TYPE) (st : WM_STATE) : WM_STATE =
	push_object (OVar x) st;
fun €push_term› (x : TERM) (st : WM_STATE) : WM_STATE =
	push_object (OTerm x) st;
fun €push_thm› (x : THM) (st : WM_STATE) : WM_STATE =
	push_object (OThm x) st;
=TEX
=SML
fun €pop_num› (st : WM_STATE) : INTEGER * WM_STATE = (
	case pop_object st of
		(ONum x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "an integer"]
);
=TEX
=SML
fun €pop_name› (st : WM_STATE) : NAME * WM_STATE = (
	case pop_object st of
		(OName x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "a name"]
);
=TEX
=SML
fun €pop_list› (st : WM_STATE) : OBJECT list * WM_STATE = (
	case pop_object st of
		(OList x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "a list"]
);
=TEX
=SML
fun €pop_type_op› (st : WM_STATE) : string * WM_STATE = (
	case pop_object st of
		(OTypeOp x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "a type operator"]
);
=TEX
=SML
fun €pop_type› (st : WM_STATE) : TYPE * WM_STATE = (
	case pop_object st of
		(OType x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "a type"]
);
=TEX
=SML
fun €pop_const› (st : WM_STATE) : NAME * WM_STATE = (
	case pop_object st of
		(OConst x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "a constant name"]
);
=TEX
=SML
fun €pop_var› (st : WM_STATE) : (string * TYPE) * WM_STATE = (
	case pop_object st of
		(OVar x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "a variable"]
);
=TEX
=SML
fun €pop_term› (st : WM_STATE) : TERM * WM_STATE = (
	case pop_object st of
		(OTerm x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "a term"]
);
=TEX
=SML
fun €pop_thm› (st : WM_STATE) : THM * WM_STATE = (
	case pop_object st of
		(OThm x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "a theorem"]
);
=TEX
=SML
fun €pop_item_list›
	(proj : OBJECT -> 'a) (st : WM_STATE) : 'a list * WM_STATE = (
	let	val (objs, st') = pop_list st;
	in	(map proj objs, st')
	end
);
=TEX
=SML
val €pop_term_list› : WM_STATE -> TERM list * WM_STATE = pop_item_list (fn
		OTerm x => x
	|	_ => fail "open-theory-reader" 122008 []
);
=TEX
=SML
val €pop_name_list› : WM_STATE -> NAME list * WM_STATE = pop_item_list (fn
		OName x => x
	|	_ => fail "open-theory-reader" 122008 []
);
=TEX
=SML
val €pop_type_list› : WM_STATE -> TYPE list * WM_STATE = pop_item_list (fn
		OType x => x
	|	_ => fail "open-theory-reader" 122008 []
);
=TEX
=SML
fun €pop_sequent› (st : WM_STATE) : SEQ * WM_STATE = (
	let 	val (cncl, st') = pop_term st;
		val (asms, st'') = pop_term_list st';
		fun check t = 
			if type_of t = BOOL
			then () else
			term_fail "open-theory-reader" 122009 [t];
		val _ = (check cncl; app check asms);
	in	((asms, cncl), st'')
	end
);
=TEX
=SML
fun €pop_subst_info› (st : WM_STATE) :
	((TYPE * TYPE) list * (TERM * TERM) list) * WM_STATE = (
	let	fun moan () = fail "open-theory-reader" 12011 [];
		fun get_pairs acc [] = rev acc
		|   get_pairs acc (OList [x, y]::more) = get_pairs ((x, y)::acc) more
		|   get_pairs _ _ = moan();
		fun do1_tysubs (OName n, OType ty) =
			(ty, mk_vartype (convert_tyvar_name n))
		|   do1_tysubs _ =
			moan();
		fun do1_varsubs (OVar v, OTerm tm) = (tm, mk_var v)
		|   do1_varsubs _ = moan();
	in	case pop_list st of
			([OList ntys, OList vtms], st') => (
				(((map do1_tysubs o get_pairs []) ntys,
					(map do1_varsubs o get_pairs []) vtms), st')
			)
		|	_ => moan()
	end

);
=TEX
=SML
fun €set_dictionary› (dict : OBJECT_DICT)
	({interface, stack, assumptions, theorems, ...} : WM_STATE)
		: WM_STATE = (
		{	interface = interface,
			stack = stack,
			dictionary = dict,
			assumptions = assumptions,
			theorems = theorems }
);
=TEX
=SML
fun €set_assumptions› (asms: THM NET)
	({interface, stack, dictionary, theorems, ...} : WM_STATE)
		: WM_STATE = (
		{	interface = interface,
			stack = stack,
			dictionary = dictionary,
			assumptions = asms,
			theorems = theorems }
);
=TEX
=SML
fun €set_theorems› (thms: THM NET)
	({interface, stack, dictionary, assumptions, ...} : WM_STATE)
		: WM_STATE = (
		{	interface = interface,
			stack = stack,
			dictionary = dictionary,
			assumptions = assumptions,
			theorems = thms }
);
=TEX
\subsubsection{Command Functions}
=TEX
=SML
fun €try_decimal_integer› (cmd : string) (st : WM_STATE) : WM_STATE OPT = (
	Value (push_num (integer_of_string cmd) st) handle Fail _ => Nil	
);
=TEX
The functions local to
=INLINEFT
name_of_quoted_string
=TEX
\ correspond to the four states of a finite state machine that recognises the syntax for OpenTheory names.
=SML
fun €name_of_quoted_string› (chars : string) : NAME OPT = (
	let	fun initial ("\""::more) = in_component [] [] more
		|   initial _ = Nil
		and in_component comps comp [] =
			fail "open-theory-reader" 122004 []
		|   in_component comps comp ("\\"::cs) =
			escaped comps comp cs
		|   in_component comps comp ("\""::cs) =
			final comps comp cs
		|   in_component comps comp ("."::cs) =
			in_component (implode (rev comp)::comps) [] cs
		|   in_component comps comp (c::cs) =
			in_component comps (c::comp) cs
		and escaped comps comp (c::cs) =
			in_component comps (c::comp) cs
		|   escaped comps comp [] =
			fail "open-theory-reader"122006 []
		and final comps comp [] =
			Value (rev comps, implode(rev comp))
		|   final _ _ _ =
			fail "open-theory-reader" 122005 [];
	in	initial (explode chars)
	end
);
=TEX
=SML
fun €try_quoted_string› (chars : string) (st : WM_STATE) : WM_STATE OPT = (
	case name_of_quoted_string chars of
		Value n => Value(push_name n st)
	|	Nil => Nil
);
=TEX
=SML
fun €do_abs_term› (st : WM_STATE) : WM_STATE = (
	let	val (b, st') = pop_term st;
		val (v, st'') = pop_var st';
		val abs = mk_simple_Ã(mk_var v, b);
	in	push_term abs st''
	end
);
=TEX
=SML
fun €do_abs_thm› (st : WM_STATE) : WM_STATE = (
	let	val (thm, st') = pop_thm st;
		val (v, st'') = pop_var st';
		val thm' = simple_Ã_eq_rule (mk_var v) thm;
	in	push_thm thm' st''
	end
);
=TEX
=SML
fun €do_app_term› (st : WM_STATE) : WM_STATE = (
	let	val (x, st') = pop_term st;
		val (f, st'') = pop_term st';
		val app = mk_app(f, x)
	in	push_term app st''
	end
);
=TEX
=SML
fun €do_app_thm› (st : WM_STATE) : WM_STATE = (
	let	val (rand_thm, st') = pop_thm st;
		val (rator_thm, st'') = pop_thm st';
		val thm = mk_app_rule rator_thm rand_thm;
	in	push_thm thm st''
	end
);
=TEX
=SML
fun €do_assume› (st : WM_STATE) : WM_STATE = (
	let	val (phi, st') = pop_term st;
		val thm = asm_rule phi;
	in	push_thm thm st'
	end
);
=TEX
=SML
fun €do_axiom›
	(st as {interface = {declare_axiom, ...}, assumptions, ...} : WM_STATE)
		: WM_STATE = (
	let	val (seq as (_, conc), st') = pop_sequent st;
		val thms = net_lookup assumptions conc;
		fun wanted th = dest_thm th ~=# seq;
		val (new, thm) =
			(false, find thms wanted)
				handle Fail _ => (true, declare_axiom seq);
		val assumptions' =
			if new
			then net_enter (conc, thm) assumptions
			else assumptions;
	in	(set_assumptions assumptions' o push_thm thm) st'
	end
);
=TEX
=SML
fun €do_beta_conv› (st : WM_STATE) : WM_STATE = (
	let	val (t, st') = pop_term st;
		val thm = simple_¬_conv t;
	in	push_thm thm st'
	end
);
=TEX
=SML
fun €do_cons› (st : WM_STATE) : WM_STATE = (
	let	val (t, st') = pop_list st;
		val (h, st'') = pop_object st';
	in	push_list (h::t) st''
	end
);
=TEX
=SML
fun €do_const› (st : WM_STATE) : WM_STATE = (
	let	val (n, st') = pop_name st;
	in	push_const n st'
	end
);
=TEX
=SML
fun €do_const_term›
	(st as {interface = {const_name, ...}, ...} : WM_STATE)
		: WM_STATE = (
	let	val (ty, st') = pop_type st;
		val (c, st'') = pop_const st';
		val ctm = mk_const(const_name c, ty);
	in	push_term ctm st''
	end
);
=TEX
=SML
fun €do_deduct_antisym› (st : WM_STATE) : WM_STATE = (
	let	val (thm1, st') = pop_thm st;
		val (thm2, st'') = pop_thm st';
		val conc1 = concl thm1;
		val conc2 = concl thm2;
		val thm3 = ¥_intro conc2 thm1;
		val thm4 = ¥_intro conc1 thm2;
		val thm5 = §_intro thm3 thm4;
	in	push_thm thm5 st''
	end
);
=TEX
=SML
fun €do_def› (st as {dictionary, ...} : WM_STATE) : WM_STATE = (
	let	val (k, st') = pop_num st;
		val (x, _) = pop_object st';
		val dictionary' = st_enter k x dictionary;
	in	set_dictionary dictionary' st'
	end
);
=TEX
=SML
fun €do_define_const›
	(st as {interface = {define_const, const_name, ...}, ...} : WM_STATE)
		: WM_STATE = (
	let	val (t, st') = pop_term st;
		val (c, st'') = pop_name st';
		val thm = define_const {name = const_name c, def_rhs = t};
	in	(push_thm thm o push_const c) st''
	end
);
=TEX
=SML
fun €do_define_type_op›
	(st as {interface = {define_type_op, type_name, const_name, ...}, ...}
		: WM_STATE) : WM_STATE = (
	let	val (thm, st') = pop_thm st;
		val (pars, st'') = pop_name_list st';
		val (rep, st''') = pop_name st'';
		val (abs, st'''') = pop_name st''';
		val (tyname, st''''') = pop_name st'''';
		val pp_tyname = type_name tyname;
		val pp_pars = map convert_tyvar_name pars;
		val pp_rep = const_name rep;
		val pp_abs = const_name abs;
		val {abs_rep, rep_abs} =
			define_type_op
				{thm = thm, pars = pp_pars, rep = pp_rep,
					abs = pp_abs, tyname = pp_tyname};
	in	(push_thm rep_abs o push_thm abs_rep o push_const rep
			o push_const abs o push_type_op pp_tyname) st'''''
	end
);
=TEX
=SML
fun €do_eq_mp› (st : WM_STATE) : WM_STATE = (
	let	val (thm1, st') = pop_thm st;
		val (thm2, st'') = pop_thm st';
		val thm3 = §_mp_rule thm2 thm1;
	in	push_thm thm3 st''
	end
);
=TEX
=SML
fun €do_nil› (st : WM_STATE) : WM_STATE = (
	push_list [] st
);
=TEX
=SML
fun €do_op_type› (st : WM_STATE) : WM_STATE = (
	let	val (pars, st') = pop_type_list st;
		val (opn, st'') = pop_type_op st';
		val ty = mk_ctype(opn, pars);
	in	push_type ty st''
	end
);
=TEX
=SML
fun €do_pop› (st : WM_STATE) : WM_STATE = (
	(snd o pop_object) st
);
=TEX
=SML
fun €do_ref› (st as {dictionary, ...} : WM_STATE) : WM_STATE = (
	let	val (k, st') = pop_num st;
		val obj = force_value (st_lookup k dictionary)
			handle Fail _ => fail "open-theory-reader" 122010 [];
	in	push_object obj st'
	end
);
=TEX
=SML
fun €do_refl› (st : WM_STATE) : WM_STATE = (
	let	val (t, st') = pop_term st;
		val thm = refl_conv t;
	in	push_thm thm st'
	end
);
=TEX
=SML
fun €do_remove› (st as {dictionary, ...} : WM_STATE) : WM_STATE = (
	let	val (k, st') = pop_num st;
		val obj = force_value (st_lookup k dictionary)
			handle Fail _ => fail "open-theory-reader" 122010 [];
		val dictionary' = st_delete k dictionary;
	in	(set_dictionary dictionary' o push_object obj) st'
	end
);
=TEX
=IGN
=SML
fun €do_subst› (st : WM_STATE) : WM_STATE = (
	let	val (thm1, st') = pop_thm st;
		val ((tysubs, tmsubs), st'') = pop_subst_info st';
		val thm2 = (asm_inst_term_rule tmsubs o
				asm_inst_type_rule tysubs) thm1;
	in	push_thm thm2 st''
	end
);
=TEX
=SML
fun €do_thm› (st as {theorems, ...} : WM_STATE) : WM_STATE = (
	let	val (seq as (_, conc), st') = pop_sequent st;
		val (thm1, st'') = pop_thm st';
		val thm2 = tac_proof(seq, accept_tac thm1);
		val theorems' = net_enter (conc, thm2) theorems;
	in	(set_theorems theorems' o push_thm thm2) st''
	end
);
=TEX
=SML
fun €do_type_op›
	(st as {interface = {type_name, ...}, ...} : WM_STATE)
		: WM_STATE = (
	let	val (n, st') = pop_name st;
		val opn = type_name n;
	in	push_type_op opn st'
	end
);
=TEX
=SML
fun €do_var› (st : WM_STATE) : WM_STATE = (
	let	val (ty, st') = pop_type st;
		val (n, st'') = pop_name st';
		val v = (convert_var_name n, ty);
	in	push_var v st''
	end
);
=SML
fun €do_var_term› (st : WM_STATE) : WM_STATE =  (
	let	val (v, st') = pop_var st;
		val t = mk_var v;
	in	push_term t st'
	end
	
);
=TEX
=SML
fun €do_var_type› (st : WM_STATE) : WM_STATE = (
	let	val (n, st') = pop_name st;
		val ty = (mk_vartype o convert_tyvar_name) n;
	in	push_type ty st'
	end
);
=TEX
\subsubsection {Command Interpreter}
=SML
fun €illegal_command› (s : string) = fail "open-theory-reader" 122012 [];
=TEX
=SML
val €diag_state› : WM_STATE OPT ref = ref Nil;
=TEX
=SML
val €vm_inference_cmds› : string list =  [
	"absThm",
	"appThm",
	"assume",
	"axiom",
	"betaConv",
	"deductAntisym",
	"defineConst",
	"defineTypeOp",
	"eqMp",
	"refl",
	"subst",
	"thm"];
val €vm_fetch_cmds› : string list =  ["ref", "remove"];

=TEX
=SML
fun €vm_diags› (cmd : string)
	(st1 : WM_STATE)
	(st2 : WM_STATE) : WM_STATE = (
	let	val (msg, stk1, st3 as {stack = stk3, ...}) =
			if cmd = "diag"
			then	let	val ((_, m), st) = pop_name st2;
				in	("diag: " ^ m, (tl o #stack) st1, st)
				end
			else	("diag: " ^ cmd, #stack st1, st2);
		val show_old_stack = cmd = "diag" orelse
			(!vm_diagnostics >= 1 andalso
			(cmd mem vm_inference_cmds orelse 
				((case stk3 of (OThm _::_) => true | _ => false) andalso
					cmd mem vm_fetch_cmds)));
	in	(if	!vm_diagnostics > 2 orelse show_old_stack
		then	let	val n = length stk3;
				val tos =
					if n = 0
					then "."
					else ": new top of stack:\n" ^
						PolyML.makestring (hd stk3);
			in
				diag_line (msg ^ ": new stack length: " ^
						string_of_int n ^ tos)
			end
		else	());
		(if show_old_stack
		then	(diag_line ("old stack length: " ^ (string_of_int o length) stk1
						^ ": old stack:");
				PolyML.print stk1; ())
		else	());
		st3
	end
);
=TEX
=SML
fun €do_command› (cmd : string) (st : WM_STATE) : WM_STATE = (
	vm_diags cmd st
	((case try_decimal_integer cmd st of
		Value st' => st'
	|	Nil =>
	case try_quoted_string cmd st of
		Value st' => st'
	|	Nil =>
	case cmd of
		"absTerm" =>  do_abs_term st
	|	"absThm" =>  do_abs_thm st
	|	"appTerm" =>  do_app_term st
	|	"appThm" =>  do_app_thm st
	|	"assume" =>  do_assume st
	|	"axiom" =>  do_axiom st
	|	"betaConv" =>  do_beta_conv st
	|	"cons" =>  do_cons st
	|	"const" =>  do_const st
	|	"constTerm" =>  do_const_term st
	|	"deductAntisym" =>  do_deduct_antisym st
	|	"def" =>  do_def st
	|	"defineConst" =>  do_define_const st
	|	"defineTypeOp" =>  do_define_type_op st
	|	"diag" =>  st
	|	"eqMp" =>  do_eq_mp st
	|	"nil" =>  do_nil st
	|	"opType" =>  do_op_type st
	|	"pop" =>  do_pop st
	|	"ref" =>  do_ref st
	|	"refl" =>  do_refl st
	|	"remove" =>  do_remove st
	|	"subst" =>  do_subst st
	|	"thm" =>  do_thm st
	|	"typeOp" =>  do_type_op st
	|	"var" =>  do_var st
	|	"varTerm" =>  do_var_term st
	|	"varType" =>  do_var_type st
	|	_ => (
			if	size cmd = 0 orelse substring(cmd, 0, 1) = "#"
			then	st
			else	illegal_command cmd
	))	handle ex as Fail _ => (
			diag_state := Value st;
			diag_line ("Could not execute \"" ^ cmd ^ "\"");
			raise ex
		))
);
=TEX
=TEX
\subsubsection {Generic Virtual Machine}
=SML
fun €open_theory_vm› (interface : IMPORT_INTERFACE)
	(read : 's -> (string * 's) OPT) (src : 's) : WM_STATE = (
	let	fun go Nil st = st
		|   go (Value (cmd, more)) st = (
			let	val st' = do_command cmd st;
			in	go (read more) st'
			end
		);
		val _ = diag_state := Nil;
		val final_state = go (read src) (initial_vm_state interface);
		val _ = diag_state := Value final_state;
	in	final_state	
	end
);
=TEX
\subsubsection{OpenTheory Interface}
=SML
val _ = open_theory "basic_hol";
val _ = new_theory "open-theory-base";
val _ = new_parent "one";
val _ = new_parent "combin";
val _ = set_merge_pcs ["basic_hol1", "'one"];
=TEX
=SML
val €ot_t_def› : THM = t_def;
val €ot_f_def› : THM = f_def;
val €ot_≥_def› : THM = ≥_def;
val €ot_µ_def› : THM = µ_def;
val €ot_±_def› : THM = tac_proof(([],
		¨$± = Ãp q∑(Ãf∑f p q : BOOL) = (Ãf∑f T T)Æ),
	rewrite_tac[] THEN REPEAT_UNTIL is_¥ strip_tac THEN1
		(strip_tac THEN asm_rewrite_tac[]) THEN
			STRIP_T (ante_tac o µ_elim¨Ãa b∑a ± bÆ) THEN rewrite_tac[]);
val €ot_¥_def› : THM = tac_proof(([], ¨$¥ = Ãp q∑p ± q § pÆ), rewrite_tac[]
	THEN taut_tac);
val €ot_∂_def› : THM = tac_proof(([], ¨$∂ = Ãp∑µq∑ (µx: 'a∑p x ¥ q) ¥ qÆ),
	rewrite_tac[] THEN µ_tac THEN
		pure_once_rewrite_tac
			[(conv_rule eq_sym_conv o µ_elim¨x: 'a ≠ BOOLÆ)»_axiom]
				THEN rewrite_tac[] THEN prove_tac[]);
val €ot_≤_def› : THM = ≤_def;
val €ot_∂â1_def› : THM = tac_proof(([],
		¨$∂â1 = ÃP∑ $∂ P ± (µx y:'a∑P x ± P y ¥ x = y)Æ),
	rewrite_tac[∂â1_def] THEN µ_tac THEN 
		pure_once_rewrite_tac [prove_rule[»_axiom] ¨x = Ãt∑x tÆ]
			THEN rewrite_tac[] THEN REPEAT strip_tac THEN_LIST
			[asm_prove_tac[],
			 contr_tac THEN all_asm_fc_tac[] THEN all_var_elim_asm_tac,
			 ∂_tac¨t : 'aÆ THEN contr_tac THEN all_asm_fc_tac[]]);
val €ot_cond_def› : THM = cond_def;
=TEX
=SML
val €ot_bool_defs› : THM list = [
	ot_t_def,
	ot_f_def,
	ot_≥_def,
	ot_µ_def,
	ot_±_def,
	ot_¥_def,
	ot_∂_def,
	ot_≤_def,
	ot_∂â1_def,
	ot_cond_def];
=TEX
=SML
val €ot_one_one_def› : THM = one_one_def;
val €ot_onto_def› : THM = onto_def;
val €ot_o_def› : THM = tac_proof(([], ¨$o = Ãf g x∑f(g x)Æ),
	rewrite_tac[get_spec ¨$oÆ]);
val €ot_comb_i_def› : THM = tac_proof(([], ¨CombI = Ãx∑ xÆ),
	rewrite_tac[get_spec ¨CombIÆ]);
val €ot_comb_k_def› : THM = tac_proof(([], ¨CombK = Ãx y∑ xÆ),
	rewrite_tac[get_spec ¨CombKÆ]);
val €ot_comb_s_def› : THM = tac_proof(([], ¨CombS = Ãf g x∑ f x (g x)Æ),
	rewrite_tac[get_spec ¨CombSÆ]);
val €ot_function_defs› : THM list = [
	ot_one_one_def,
	ot_onto_def,
	ot_o_def,
	ot_comb_i_def,
	ot_comb_k_def,
	ot_comb_s_def];
=TEX
=SML
val €ot_defs› : (string * THM) list = 
	map (fn th => ((fst o dest_const o fst o dest_eq o concl) th, th))
		(	ot_bool_defs @
			ot_function_defs );
=TEX
=SML
fun €get_ot_def› (n : string) (rhs : TERM) : THM = (
	let	val thm1 = lassoc3 ot_defs n;
		val rhs1 = (snd o dest_eq o concl) thm1;
		val (tysubs, _) = term_match rhs rhs1;
	in	inst_type_rule tysubs thm1
	end
);
=TEX
=SML
fun €convert_name›
	(interp : (NAME * string) list) ( n as (cxt, base) : NAME )
		: string = (
	lassoc3 interp n
	handle Fail _ => format_list (fn s => s) (cxt @ [base]) "_"
);
=IGN
new_theory "temp";
set_pc "basic_hol1";
=SML
val €ot_»_axiom› : THM =
	(conv_rule (MAP_C ¬_conv) o
		pure_rewrite_rule ot_bool_defs) »_axiom;
val €ot_≈_axiom› : THM =
	(conv_rule (MAP_C ¬_conv) o
		pure_rewrite_rule ot_bool_defs) ≈_axiom;
val €ot_infinity_axiom› : THM  =
	(conv_rule (MAP_C ¬_conv) o
		pure_rewrite_rule (ot_function_defs @ ot_bool_defs)) infinity_axiom;
val €ot_axioms› : THM list = [
	ot_»_axiom,
	ot_≈_axiom,
	ot_infinity_axiom];
=TEX
The following does not allow for renaming in the assumptions of the theorem.
(since that is not needed for dealing with the axioms of the Gilith Open Theory Repo base package).
It does allow for renaming of free variables in the conclusion and it also allows for the
conclusion of the wanted theorem to contain $\beta$-redexes.
=SML
fun €mk_instance› (wanted : TERM) (thm : THM) : THM = (
	let	val thm1 = eq_sym_rule (TRY_C (MAP_C ¬_conv) wanted);
		val wanted1 = (fst o dest_eq o concl) thm1;
		val c = concl thm;
		val (tysubs, tmsubs) = term_match wanted1 c;
		val thm2 = inst_term_rule tmsubs (inst_type_rule tysubs thm);
		val thm3 = §_mp_rule thm1 thm2;
	in	thm3
	end
);
=TEX
=SML
fun €get_ot_axiom› (tm : TERM) : THM OPT = (
	let	fun aux [] = Nil
		|   aux (thm::more) =
			Value (mk_instance tm thm) handle Fail _ => aux more;
	in	aux ot_axioms
	end
);
=TEX
=SML
val €axiom_count› : int ref = ref 0;
fun €axiom_as_axiom› ( (asms, conc) : SEQ ) : THM = (
	case if asms = [] then get_ot_axiom conc else Nil of
		Value thm => thm
	|	Nil => (
		let	val tm = list_mk_¥(asms @ [conc]);
			val _ = axiom_count := !axiom_count + 1;
			val n  = "axiom" ^ string_of_int(!axiom_count);
			val thm1 = new_axiom ([n], tm);
			fun aux [] thm = thm
			|   aux (_::tms) thm = aux tms (undisch_rule thm);
			val thm2 = aux asms thm1;
		in	thm2
		end
	)
);
=TEX
=SML
val €type_defn_count› : int ref = ref 0;
fun €convert_type_defn_thm› (ot_thm : THM) : THM = (
	let	val c = concl ot_thm;
		val (p, t) = dest_app c;
		val x = variant (frees c) (mk_var("x", type_of t));
		val c' = mk_∂(x, mk_app(p, x));
		val pp_thm = simple_∂_intro c' ot_thm;
	in	pp_thm
	end
);
=TEX
=SML
fun €define_hol_type_op› ({thm, pars, rep, abs, tyname} : TYPE_DEFN_INFO)
		: ABS_REP_THMS = (
	let	val _ = type_defn_count := !type_defn_count + 1;
		val thm1 =
			let	val n  = "type_defn" ^ string_of_int(!type_defn_count);
				val pp_thm = convert_type_defn_thm thm;
			in	new_type_defn([n], tyname, pars, pp_thm)
			end;
		val thm2 = simple_¥_match_mp_rule type_lemmas_thm thm1;
		val conc2 = concl thm2;
		val (abs_var, (rep_var, body2)) =
			let val (x, b) = dest_∂ conc2 in (x, dest_∂ b) end;
		val pp_abs_var = mk_var(abs, type_of abs_var);
		val pp_rep_var = mk_var(rep, type_of rep_var);
		val body3 = subst[(pp_abs_var, abs_var), (pp_rep_var, rep_var)] body2; 
		val conc3 = list_mk_∂([pp_abs_var, pp_rep_var], body3);
		val cn = "abs_rep" ^ string_of_int(!type_defn_count);
		val thm3 = §_mp_rule (¡_conv conc3 conc2) thm2;
		val thm4 = new_spec([cn], 2, thm3);
		val abs_rep_thm = (all_µ_elim o ±_left_elim) thm4;
		val rep_abs_thm = (all_µ_elim o ±_right_elim) thm4;
	in	{abs_rep = abs_rep_thm, rep_abs = rep_abs_thm}
	end
);
=TEX
=IGN
=SML
val €const_spec_count› : int ref = ref 0;
fun €define_hol_const› ({name, def_rhs} : CONST_DEFN_INFO) : THM = (
	let	val v = mk_var(name, type_of def_rhs);
		val c = mk_∂(v, mk_eq(v, def_rhs));
		val thm1 = simple_∂_intro c (refl_conv def_rhs);
		val _ = const_spec_count := !const_spec_count + 1;
		val n  = "const_spec" ^ string_of_int(!const_spec_count);
		val thm2 = new_spec([n], 1, thm1);
	in	thm2
	end	handle ex as (Fail _) => (
			get_ot_def name def_rhs
			handle Fail _ => fail "open-theory-reader" 122013 [
				fn _ => name,
				fn _ => string_of_term def_rhs, 
				fn _ => string_of_exn ex]
		)
);
=TEX
=SML
fun €axiomatic_hol_interface›
	({type_map, const_map} : NAME_MAPS)
		: IMPORT_INTERFACE = {
	declare_axiom = axiom_as_axiom,
	define_type_op = define_hol_type_op,
	define_const = define_hol_const,
	const_name = convert_name const_map,
	type_name = convert_name type_map 
};
=TEX
=SML
val €line_count› : int ref = ref 0;
fun €read_instream› (strm : instream) = (
	line_count := !line_count + 1;
	case ExtendedIO.input_line strm of 
		"" => (close_in strm; Nil)
	|	s => Value(substring(s, 0, size s - 1), strm)
);
=TEX
=SML
val €name_of_string› : string -> NAME =
	force_value o name_of_quoted_string o (fn s => "\"" ^ s ^ "\"");
=TEX
The following translates the Gilith Open Theory Repo namespace to ProofPower:
=SML
val €gilith_maps› : NAME_MAPS = {
	type_map = map (name_of_string ** (fn x => x)) [
		("bool", "BOOL"), ("->", "≠"), ("ind", "IND")
	],
	const_map = map (name_of_string ** (fn x => x)) [
		("select", "≈"),
		("Data.Bool.T", "T"), ("Data.Bool.F", "F"),
		("Data.Bool.~", "≥"),
		("Data.Bool./\\\\", "±"), ("Data.Bool.\\\\/", "≤"),
		("Data.Bool.==>", "¥"),
		("Data.Bool.!", "µ"),
		("Data.Bool.?", "∂"), ("Data.Bool.?!", "∂â1"),
		("Data.Bool.cond", "Cond"),
		("Function.id", "CombI"),
		("Function.K", "CombK"),
		("Function.S", "CombS"),
		("Function.C", "CombC"),
		("Function.W", "CombW")
	]
};
=TEX
\subsubsection{Entry Point}
=SML
fun €open_theory_import› {file : string, parent : string, theory : string} : unit = (
	let	val _ = force_delete_theory theory handle Fail _ => ();
		val _ = open_theory parent;
		val _ = new_theory theory;
		val _ = if "open-theory-base" mem get_ancestors "-" then ()
			else new_parent "open-theory-base";
		val strm = open_in file;
		val _ = line_count := 0;
		val {theorems, ...} = open_theory_vm
			(axiomatic_hol_interface gilith_maps)
			read_instream strm
			handle ex as Fail _ => (close_in strm; raise ex);
		val thms = net_flatten theorems;
		val names =
			map (fn n => "thm" ^ string_of_int n)
				(interval 1 (length thms));
	in	map save_thm (combine names thms); ()
	end
);
=TEX
\subsection{Writer}
=TEX
\subsubsection{Writer Types}
=TEX
=SML
type €EXPORT_INTERFACE› = {
	const_name : string -> NAME,
	type_name : string -> NAME 
};
=SML
type €KEY_DICT› = (OBJECT, int) SEARCH_TREE;
=TEX
\subsubsection{Managing Keys}
=SML
val €name_order› : NAME ORDER = pair_order (list_order string_order) string_order;
val €seq_order› : SEQ ORDER = pair_order (list_order term_order) term_order;
val €thm_order› : THM ORDER = induced_order (dest_thm, seq_order);
=TEX
=SML
fun €object_class› (OConst _) = 0
|   object_class (OList _) = 1
|   object_class (OName _) = 2
|   object_class (ONum _) = 3
|   object_class (OTerm _) = 4
|   object_class (OThm _) = 5
|   object_class (OType _) = 6
|   object_class (OTypeOp _) = 7
|   object_class (OVar _) = 8;
=TEX
=SML
val rec €object_order› : OBJECT ORDER = (fn o1 => fn o2 =>
	case (o1, o2) of 
		(OConst x, OConst y) => name_order x y
	|	(OList x, OList y) => list_order object_order x y
	|	(OName x, OName y) => name_order x y
	|	(ONum x, ONum y) => integer_order x y
	|	(OTerm x, OTerm y) => term_order x y
	|	(OThm x, OThm y) => thm_order x y
	|	(OType x, OType y) => type_order x y
	|	(OTypeOp x, OTypeOp y) => string_order x y
	|	(OVar x, OVar y) => pair_order string_order type_order x y
	|	(x, y) => induced_order (object_class, int_order) x y
);
=TEX
=SML
type €KM_STATE› = {
	dictionary : KEY_DICT,
	tide_mark : int
};
=TEX
=SML
val km_state : KM_STATE ref = ref {
	dictionary = initial_search_tree object_order,
	tide_mark = ~1
};
=TEX
=SML
fun €reset_km_state› ((): unit) : unit = (
	km_state := {
		dictionary = initial_search_tree object_order,
		tide_mark = ~1
	}
);
=TEX
{\em stored\_key} raises {\em Fail} if the object does not have a stored key.
=SML
fun €stored_key› (x : OBJECT) : int = (
	let	val {dictionary,...} = !km_state;
	in	force_value(st_lookup x dictionary)
	end
);
=TEX
=SML
fun €new_key› (x : OBJECT) : int = (
	let	val {dictionary, tide_mark} = !km_state;
	in	let	val k = tide_mark + 1;
			val d = st_extend x k dictionary;
			val _ = km_state := {dictionary = d, tide_mark = k};
		in	k
		end
	end
);
=TEX
=SML
fun €next_key› (() : unit) : int = (
	let	val {dictionary = d, tide_mark} = !km_state;
	in	let	val k = tide_mark + 1;
			val _ = km_state := {dictionary = d, tide_mark = k};
		in	k
		end
	end
);
=TEX
\subsubsection{Building Types and Terms}
=SML
fun €export_type_name› (x : string) : NAME = (
	let	val pfx = [ (* get_type_theory x *) ] handle Fail _ => [];
	in	(pfx, x)
	end
);
fun €export_const_name› (x : string) : NAME = (
	let	val pfx = [ (* get_const_theory x *) ] handle Fail _ => [];
	in	(pfx, x)
	end
);
=TEX
=SML
val €export_interface› : EXPORT_INTERFACE ref = ref {
	type_name = export_type_name,
	const_name = export_const_name
};
=TEX
=SML
val €out_stream› : outstream OPT ref = ref Nil;
=TEX
=SML
fun €say› (x : string) : unit = (
	TextIO.output(
		case !out_stream of Value s => s | Nil => TextIO.stdOut,
		x)
);
=TEX
=SML
fun €open_log› (n : string) : unit = (
	out_stream := Value(open_out n)
);
=TEX
=SML
fun €close_log› (():unit) : unit = (
	(case !out_stream of Value s => close_out s | Nil => ());
	out_stream := Nil
);
=TEX
{\em log\_cmd} outputs the OpenTheory command given by its argument.
=SML
fun €log_cmd› (x : string) : unit = (say x; say "\n");
=TEX
Subsequent functions named {\em log\_xxx} typically output OpenTheory commands
to construct an {\em xxx}.
=SML
val €log_num› : int -> unit = log_cmd o string_of_int;
fun €log_name› ((pfx, sfx) : NAME) :unit = (
	let	fun esc1 "." = "\\."
		|   esc1 "\"" = "\\\""
		|   esc1 c = c;
		val escape = implode o map esc1 o explode;
	in	log_cmd("\"" ^ format_list escape (pfx @ [sfx]) "." ^ "\"")
	end
);
=TEX
Diagnostics: must be turned off when exporting to a system other than {\Product}.
=SML
val €logging_diagnostics› : bool ref = ref false;
fun €log_diag› (msg : string) = (
	if !logging_diagnostics
	then	(
		log_name ([], msg);
		log_cmd "diag"
	) else ()
);
=TEX
=SML
fun €log_nil› (() : unit) : unit = log_cmd "nil";
fun €log_cons› (() : unit) : unit = log_cmd "cons";
fun €log_list› (_ : 'a -> unit) ([] : 'a list) : unit = log_nil()
|   log_list log_x (x::xs) = (log_x x; log_list log_x xs; log_cons());
fun €log_pair› (log_x : 'a -> unit, log_y : 'b -> unit) ((x, y) : 'a * 'b) : unit = (
	log_x x;
	log_y y;
	log_nil();
	log_cons();
	log_cons()
);
=TEX
The following two functions raise {\em Fail} if the object does not have a stored key.
{\em try\_stored} generates the commands to push a stored object onto the stack.
=SML
fun €try_stored› (x : OBJECT) = (
	log_num (stored_key x);
	log_cmd "ref"
);
=TEX
{\em check\_stored} just checks whether the object has been stored.
=SML
fun €check_stored› (x : OBJECT) : unit = (
	stored_key x;
	()
);
=TEX
{\em store} assumes that we have already logged the commands to put {\em x} on the top of the stack.
It is possible that the caller will have called some other function that will already have stored
the same object, in which case the call to {\em new\_key} will fail and {\em store}
must return the stored key.
=SML
fun €store› (x : OBJECT) : int = (
	let	val k = new_key x;
	in	log_num k;
		log_cmd "def";
		k
	end	handle Fail _ => stored_key x
);
=TEX
=SML
fun €store_and_drop› (x : OBJECT) : unit = (
	store x;
	log_cmd "pop"
);
=TEX
=SML
fun €log_type_var› (tyv : string)  = log_name([], tyv);
=TEX
=SML
fun €log_type_op› (x : string) = (
	let	val obj = OTypeOp x;
	in	try_stored obj handle Fail _ => (
			log_name (#type_name(!export_interface) x);
			log_cmd "typeOp";
			store obj; ()
		)
	end
);
=TEX
=SML
fun €log_type› (x : TYPE) = (
	let	val obj = OType x;
	in	try_stored obj handle Fail _ => (
			case dest_simple_type x of
				Vartype v => (
					log_type_var v;
					log_cmd "varType";
					store obj; ()
				)
			|	Ctype (type_op, args) => (
					log_type_op type_op;
					log_list log_type args;
					log_cmd "opType";
					store obj; ()
			)
		)
	end
);
=TEX
=SML
fun €log_var› (x as (v, ty) : string * TYPE) = (
	let	val obj = OVar x;
	in	try_stored obj handle Fail _ => (
			log_name ([], v);
			log_type ty;
			log_cmd "var";
			store obj; ()
		)
	end
);
=TEX
=SML
fun €log_const_name› (x : string) = (
	log_name (#const_name(!export_interface) x)
);
=TEX
=SML
fun €log_const› (x : string) = (
	let	val obj = OConst ([], x);
	in	try_stored obj handle Fail _ => (
			log_const_name x;
			log_cmd "const";
			store obj; ()
		)
	end
);
=TEX
=SML
fun €log_term› (x : TERM) = (
	let	val obj = OTerm x;
	in	try_stored obj handle Fail _ => (
			case dest_simple_term x of
				Var vty => (
					log_var vty;
					log_cmd "varTerm";
					store obj; ()
			) |	Const (c, ty)  => (
					log_const c;
					log_type ty;
					log_cmd "constTerm";
					store obj; ()
			) | 	App (f, a) => (
					log_term f;
					log_term a;
					log_cmd "appTerm";
					store obj; ()
			) |	SimpleÃ (v, b) => (
					log_var(dest_var v);
					log_term b;
					log_cmd "absTerm";
					store obj; ()
			)
		)
	end
);
=TEX
=TEX
\subsubsection{Logging Proofs}
{\em log\_antecedent} is used to derive an antecedent of an inference rule application.
If the antecedent isn't in the database, it makes it an axiom.
=SML
fun €log_antecedent› (thm : THM) : unit = (
	let	val obj = OThm thm;
	in	try_stored obj handle Fail _ => (
			let	val (asms, conc) = dest_thm thm;
			in	log_list log_term asms;
				log_term conc;
				log_cmd "axiom"
			end;
			store obj; ()
		)
	end
);
=TEX
=SML
val €log_subst_params› : (TYPE * TYPE) list * (TERM * TERM) list -> unit = (
	log_pair (
		log_list (log_pair (log_type_var o dest_vartype, log_type) o swap),
		log_list (log_pair (log_var o dest_var, log_term) o swap))
);
=TEX
We define some derived rules to support logging the {\Product} built-ins.

{\em log\_prove\_asm} maps a stack of the following form:
=GFT
Thm Ñ, A Ù B ::
Thm á Ù A ::
Stack
=TEX
to:
=GFT
Thm á, Ñ Ù B ::
Stack
=TEX
Here and in future derived rules, we give comments indicating what
theorems is expected to be on the stack after execution of selected commands.
The numbers indicate the depth: 1 is deepest, 2 is second deepest, etc.
Here for example, we expect theorem
=INLINEFT
á Ù A
=TEX
\ and
=INLINEFT
Ñ, A Ù B
=TEX
\ to be on the stack on entry. 
=SML
fun €log_prove_asm› (():unit) : unit = (
	let	val k1 = next_key();
		val k2 = k1 + 1;
	in					(* 1. á Ù A *)
						(* 2. Ñ, A Ù B *)
		log_num k1;
		log_cmd "def";
		log_cmd "pop";			(* 1. á Ù A *)
		log_num k2;
		log_cmd "def";
		log_num k1;
		log_cmd "ref";			
		log_cmd "deductAntisym";	(* 1. á, Ñ Ù A = B *)
		log_num k2;
		log_cmd "remove";		(* 2. á Ù A *)
		log_cmd "eqMp";			(* 1. á, Ñ Ù B *)
		log_num k1;
		log_cmd "remove";
		log_cmd "pop"
	end
);
=TEX
{\em log\_refl t} pushes the following theorem onto the stack:
=GFT
Ù t = t
=TEX
=SML
fun €log_refl› (t : TERM) : unit = (
	log_term t;
	log_cmd"refl"
);
=TEX
{\em log\_assume t} pushes the following theorem onto the stack:
=GFT
t Ù t
=TEX
=SML
fun €log_assume› (t : TERM) : unit = (
	log_term t;
	log_cmd"assume"
);
=TEX
We define some standard term and type variables for use in pattern theorems:
=SML
val €x_var› : TERM = ¨x : 'aÆ;
val €y_var› : TERM = ¨y : 'aÆ;
val €z_var› : TERM = ¨z : 'aÆ;
val €alpha› : TYPE = î'aÆ;
=TEX
{\em log\_eq\_sym\_thm()} pushes the following theorem onto the stack:
=GFT
x = y Ù y = x
=TEX
(where $x$ and $y$ are actual variables not metavariables.)
=SML
val €log_eq_sym_thm› : unit -> unit = (
	let	val obj = (OThm o undisch_rule o prove_rule[]) ¨x = y ¥ y = xÆ;
		val eq = ¨$=:'a ≠ 'a ≠ BOOLÆ;
		val x_eq_y = ¨x:'a = yÆ;
	in	fn () => try_stored obj handle Fail _ => (
			log_refl eq;		(* 1. Ù ($=) = ($=) *)
			log_assume x_eq_y;	(* 2. x = y Ù x = y *)
			log_cmd "appThm";	(* 1. x = y Ù ($= x) = ($= y) *)
			log_refl x_var;		(* 2. Ù x = x *)
			log_cmd "appThm";	(* 1. x = y Ù x = x § y = x *)
			log_refl x_var;		(* 2. Ù x = x *)
			log_cmd "eqMp";		(* 1. x = y Ù y = x *)
			store obj; ()
		)
	end
);
=TEX
{\em log\_eq\_trans\_thm()} pushes the following theorem onto the stack:
=GFT
x = y, y = z Ù x = z
=TEX
(where $x$, $y$ and $z$ are actual variables not metavariables.)
=TEX
=SML
val €log_eq_trans_thm› : unit -> unit = (
	let	val obj = (OThm o undisch_rule o undisch_rule o prove_rule[])
					¨x = y ¥ y = z ¥ x = zÆ;
		val eq = ¨$=:'a ≠ 'a ≠ BOOLÆ;
		val x_eq_y = ¨x:'a = yÆ;
		val y_eq_z = ¨y:'a = zÆ;
	in	fn () => try_stored obj handle Fail _ => (
			log_refl eq;		(* 1. Ù ($=) = ($=) *)
			log_refl x_var;		(* 2. Ù x = x *)
			log_cmd"appThm";	(* 1. Ù ($= x) = ($= x) *)
			log_assume y_eq_z;	(* 2. y = z Ù y = z *)
			log_cmd"appThm";	(* 1. y = z Ù x = y § x = z *)
			log_assume x_eq_y;	(* 2. x = y Ù x = y *)
			log_cmd"eqMp";		(* 1. x = y, y = z Ù x = z *)
			store obj; ()
		)
	end
);
=TEX
{\em log\_eq\_sym\_thm (a, b)} pushes the following theorem onto the stack:
=GFT
a = b Ù b = a
=TEX
=SML
fun €log_eq_sym› (a : TERM, b : TERM) : unit = (
	let	val ty_subs = [(type_of a, alpha)];
		val tm_subs = [(a, inst [] ty_subs x_var), (b, inst [] ty_subs y_var)];
	in	log_subst_params (ty_subs, tm_subs);
		log_eq_sym_thm ();	(* 1. x = y Ù y = x *)
		log_cmd"subst"		(* 1. a = b Ù b = a *)
	end
);
=TEX
{\em log\_eq\_trans\_thm (a, b. c)} pushes the following theorem onto the stack:
=GFT
a = b, b = c Ù a = c
=TEX
=SML
fun €log_eq_trans› (a : TERM, b : TERM, c : TERM) : unit = (
	let	val ty_subs = [(type_of a, alpha)];
		val tm_subs = [(a, inst [] ty_subs x_var),
				(b, inst [] ty_subs y_var),
				(c, inst [] ty_subs z_var)];
	in	log_subst_params (ty_subs, tm_subs);
		log_eq_trans_thm ();	(* 1. x = y, y = z Ù x = z *)
		log_cmd"subst"		(* 1. a = b, b = c Ù a = c *)
	end
);
=TEX
{\em log\_t\_thm ()} pushes the following theorem onto the stack:
=GFT
Ù T
=TEX
=SML
fun €log_t_thm› (():unit) : unit = (
	let	val obj = OThm t_thm;
		val q = ¨(Ãx:BOOL∑x) = (Ãx∑x)Æ;
	in	try_stored obj handle Fail _ => (
			log_antecedent ot_t_def;
						(* 1. Ù T § (Ãx∑x) = (Ãx∑x) *)
			log_eq_sym(mk_t, q);
			log_prove_asm();	(* 1. Ù  (Ãx∑x) = (Ãx∑x) § T *)
			(log_refl o fst o dest_eq o snd o dest_eq o concl) ot_t_def;
						(* 2. Ù (Ãx∑x) = (Ãx∑x) *)
			log_cmd "eqMp";		(* 1. Ù T *)
			store obj; ()
		)
	end
);
=TEX
We define some standard variables for propositions and propositional functions for use
in pattern theorems:
=SML
val €a_prop› : TERM = ¨A: BOOLÆ;
val €b_prop› : TERM = ¨B: BOOLÆ;
val €c_prop› : TERM = ¨C: BOOLÆ;
val €p_func› :  TERM = ¨P : 'a ≠ BOOLÆ;
=TEX
{\em log\_eq\_t\_intro\_thm ()} pushes the following theorem onto the stack:
=GFT
A Ù A § T
=TEX
=SML
val €log_§_t_intro_thm› : unit -> unit = (
	let	val obj = OThm (undisch_rule (taut_rule ¨A ¥ (A § T)Æ));
	in	fn () => try_stored obj handle Fail _ => (
			log_eq_sym (a_prop, mk_t);
						(* 1. A § T Ù T § A *)
			log_t_thm();		(* 2. Ù T *)
			log_cmd"eqMp";		(* 1. A § T Ù A *)
			log_assume a_prop;	(* 2. A Ù A *)
			log_t_thm();		(* 3. Ù T *)
			log_cmd"deductAntisym";	(* 2. A Ù A § T *)
			log_cmd"deductAntisym";	(* 1. Ù A § (A § T) *)
			log_assume a_prop;	(* 2. A Ù A *)
			log_cmd "eqMp";		(* 1. A Ù A § T *)
			store obj; ()
		)
	end
);
=TEX
{\em log\_eq\_t\_elim\_thm ()} pushes the following theorem onto the stack:
=GFT
A § T Ù A
=TEX
=SML
val €log_§_t_elim_thm› : unit -> unit = (
	let	val obj = OThm (undisch_rule (taut_rule ¨(A § T) ¥ AÆ));
		val a_iff_t = ¨A § TÆ;
	in	fn () => try_stored obj handle Fail _ => (
			log_assume a_prop;	(* 1. A Ù A *)
			log_t_thm();		(* 2. Ù T *)
			log_cmd"deductAntisym";	(* 1. A Ù A § T *)
			log_eq_sym(a_prop, mk_t);
						(* 2. A § T Ù T § A *)
			log_t_thm();		(* 3. Ù T *)
			log_cmd"eqMp";		(* 2. A § T Ù A *)
			log_cmd"deductAntisym";	(* 1. Ù (A § T) § A*)
			log_assume a_iff_t;	(* 2. A § T Ù A § T *)
			log_cmd "eqMp";		(* 1. A § T Ù A *)
			store obj; ()
		)
	end
);
=TEX
=INLINEFT
log_¬_conv ¨(Ãv∑ b) tÆ
=TEX
\ pushes the following theorem onto the stack:
=GFT
Ù (Ãv∑b) t = b[t/v]
=TEX
=SML
fun €log_¬_conv› (tm : TERM) : unit = (
	log_term tm;
	log_cmd "betaConv"	(* 1. Ù (Ãv∑b) t = b[t/v] *)
);
=TEX
=INLINEFT
log_¬_¬_conv ¨(Ãv w∑ b) s tÆ
=TEX
\ pushes the following theorem onto the stack:
=GFT
Ù (Ãv w∑b) s t = b[s/v, t/w]
=TEX
=SML
fun €log_¬_¬_conv› (tm : TERM) : unit = (
	let	val (fs, t) = dest_app tm;
		val (f, s) = dest_app fs;
		val (v, wb) = dest_Ã f;
		val (w, b) = dest_Ã wb;
		val rhs1 = mk_app(subst [(s, v)] wb, t);
		val rhs2 = subst[(s, v), (t, w)] b;
	in	log_¬_conv fs;		(* 1. Ù (Ãv w∑b) s = (Ãw∑b)[s/v] *)
		log_refl t;		(* 2. Ù t = t *)
		log_cmd"appThm";	(* 1. Ù (Ãv w∑b) s t = (Ãw∑b)[s/v] t *)
		log_¬_conv rhs1;	(* 2. Ù (Ãw∑b)[s/v] t = b[s/v,t/w] *)
		log_eq_trans(tm, rhs1, rhs2);
		log_prove_asm();
		log_prove_asm()		(* 1. Ù (Ãv w∑b) s t = [s/v,t/v] *)
	end
);

=TEX
=INLINEFT
log_±_intro_thm ()
=TEX
\ pushes the following theorem onto the stack:
=GFT
A, B Ù A ± B
=TEX
=SML
val €log_±_intro_thm› : unit -> unit = (
	let	val obj = (OThm o undisch_rule o undisch_rule o taut_rule)
				¨A ¥ B ¥ A ± BÆ;
		val f = ¨f : BOOL ≠ BOOL ≠ BOOLÆ;
		val a_±_b = mk_±(a_prop, b_prop);
		val conj_def = ¨Ã p q∑ (Ã f∑ f p q:BOOL) = (Ã f∑ f T T)Æ;
		val conj_def_a_b = list_mk_app(conj_def, [a_prop, b_prop]);
		val q = ¨(Ã f∑ f A B : BOOL) = (Ã f∑ f T T)Æ;
	in	fn () => try_stored obj handle Fail _ => (
			log_antecedent ot_±_def;
						(* 1. Ù $± = (Ãp q∑Q[p/A, q/B]) *)
			log_refl a_prop;
			log_cmd"appThm";
			log_refl b_prop;
			log_cmd"appThm";	(* 1. A ± B = (Ãp q∑Q[p/A, q/B]) A B *)
			log_¬_¬_conv conj_def_a_b;
						(* 2. Ù (Ãp q∑Q[p/A,q/B]) A B § Q *)
			log_eq_trans(a_±_b, conj_def_a_b, q);
			log_prove_asm();
			log_prove_asm();	(* 1. Ù A ± B § Q *)
			log_eq_sym(a_±_b, q);
			log_prove_asm();	(* 1. Ù Q § A ± B *)
			log_var (dest_var f);
			log_refl f;		(* 2. Ù f = f *)
			log_§_t_intro_thm();	(* 3. A Ù A § T *)
			log_cmd"appThm";	(* 2. A Ù f A = f T *)
			log_subst_params ([], [(b_prop, a_prop)]);
			log_§_t_intro_thm();	(* 3. A Ù A § T *)
			log_cmd"subst";		(* 3. B Ù B § T *)
			log_cmd"appThm";	(* 2. A, B Ù f A B § f T T *)
			log_cmd"absThm";	(* 2. A, B Ù Q *)
			log_cmd"eqMp";		(* 2. A, B Ù A ± B *)
			store obj; ()
		)
	end
);

=TEX
=INLINEFT
log_±_left_elim_thm ()
=TEX
\ pushes the following theorem onto the stack:
=GFT
A ± B Ù A
=TEX
=SML
val €log_±_left_elim_thm› : unit -> unit = (
	let	val obj = (OThm o undisch_rule o taut_rule) ¨A ± B ¥ AÆ;
		val a_±_b = mk_±(a_prop, b_prop);
		val conj_def = ¨Ã p q∑ (Ã f∑ f p q:BOOL) = (Ã f∑ f T T)Æ;
		val conj_def_a_b = list_mk_app(conj_def, [a_prop, b_prop]);
		val q = ¨(Ã f∑ f A B : BOOL) = (Ã f∑ f T T)Æ;
		val p1 = ¨Ãp q : BOOL∑ pÆ;
		val (s, t) = dest_eq q;
		val sp1 = mk_app(s, p1);
		val tp1 = mk_app(t, p1);
		val p1ab = list_mk_app(p1, [a_prop, b_prop]);
		val p1tt = list_mk_app(p1, [mk_t, mk_t]);
	in	fn () => try_stored obj handle Fail _ => (
			log_antecedent ot_±_def;
					(* 1. Ù $± = (Ãp q∑Q[p/A, q/B]) *)
			log_refl a_prop;
			log_cmd"appThm";
			log_refl b_prop;
			log_cmd"appThm";
					(* 1. A ± B = (Ãp q∑Q[p/A, q/B]) A B *)
			log_¬_¬_conv conj_def_a_b;
					(* 2. Ù (Ãp q∑Q[p/A,q/B]) A B § Q *)
			log_eq_trans(a_±_b, conj_def_a_b, q);
			log_prove_asm();
			log_prove_asm();
					(* 1. Ù A ± B § Q *)
			log_assume a_±_b;
					(* 2. Ù A ± B Ù A ± B *)
			log_cmd"eqMp";
					(* 1. Ù A ± B Ù Q *)
			log_refl p1;
					(* 2. Ù (Ãp q∑p) = (Ãp q∑p) *)
			log_cmd"appThm";
					(* 1. A ± B  Ù s (Ãp q∑p) = t (Ãp q∑p) *)
			log_¬_conv sp1;
					(* 2. Ù s (Ãp q∑p) = (Ãp q∑p) A B *)
			log_eq_sym(sp1, p1ab);
			log_prove_asm();
					(* 2. Ù (Ãp q∑p) A B = s (Ãp q∑p) *)
			log_eq_trans(p1ab, sp1, tp1);
			log_prove_asm();
			log_prove_asm();
					(* 1. A ± B Ù (Ãp q∑p) A B = t (Ãp q∑ p) *)
			log_¬_conv tp1;
					(* Ù t(Ãp q∑p) = (Ãp q∑p) T T *)
			log_eq_trans(p1ab, tp1, p1tt);
			log_prove_asm();
			log_prove_asm();
					(* 1. A ± B Ù (Ãp q∑p) A B = (Ãp q∑p) T T *)
			log_¬_¬_conv p1tt;
					(* 2. Ù (Ãp q∑p) T T = T *)
			log_eq_trans(p1ab, p1tt, mk_t);
			log_prove_asm();
			log_prove_asm();
					(* 1. A ± B Ù (Ãp q∑p) A B = T *)
			log_¬_¬_conv p1ab;
					(* 2. Ù (Ãp q∑p) A B = A *)
			log_eq_sym(p1ab, a_prop);
			log_prove_asm();
					(* 2. Ù A = (Ãp q∑p) A B *)
			log_eq_trans(a_prop, p1ab, mk_t);
			log_prove_asm();
			log_prove_asm();
					(* 1. A ± B Ù A § T *)
			log_§_t_elim_thm();
					(* 2. A § T Ù A *)
			log_prove_asm();
					(* 1. A ± B Ù A *)
			store obj; ()
		)
	end
);

=TEX
=INLINEFT
log_±_right_elim_thm ()
=TEX
\ pushes the following theorem onto the stack:
=GFT
A ± B Ù B
=TEX
=SML
val €log_±_right_elim_thm› : unit -> unit = (
	let	val obj = (OThm o undisch_rule o taut_rule) ¨A ± B ¥ AÆ;
		val a_±_b = mk_±(a_prop, b_prop);
		val conj_def = ¨Ã p q∑ (Ã f∑ f p q:BOOL) = (Ã f∑ f T T)Æ;
		val conj_def_a_b = list_mk_app(conj_def, [a_prop, b_prop]);
		val q = ¨(Ã f∑ f A B : BOOL) = (Ã f∑ f T T)Æ;
		val p2 = ¨Ãp q : BOOL∑ qÆ;
		val (s, t) = dest_eq q;
		val sp2 = mk_app(s, p2);
		val tp2 = mk_app(t, p2);
		val p2ab = list_mk_app(p2, [a_prop, b_prop]);
		val p2tt = list_mk_app(p2, [mk_t, mk_t]);
	in	fn () => try_stored obj handle Fail _ => (
			log_antecedent ot_±_def;
					(* 1. Ù $± = (Ãp q∑Q[p/A, q/B]) *)
			log_refl a_prop;
			log_cmd"appThm";
			log_refl b_prop;
			log_cmd"appThm";
					(* 1. A ± B = (Ãp q∑Q[p/A, q/B]) A B *)
			log_¬_¬_conv conj_def_a_b;
						(* 2. Ù (Ãp q∑Q[p/A,q/B]) A B § Q *)
			log_eq_trans(a_±_b, conj_def_a_b, q);
			log_prove_asm();
			log_prove_asm();
					(* 1. Ù A ± B § Q *)
			log_assume a_±_b;
					(* 2. Ù A ± B Ù A ± B *)
			log_cmd"eqMp";
					(* 1. Ù A ± B Ù Q *)
			log_refl p2;
					(* 2. Ù (Ãp q∑q) = (Ãp q∑q) *)
			log_cmd"appThm";
					(* 1. A ± B  Ù s (Ãp q∑q) = t (Ãp q∑p) *)
			log_¬_conv sp2;
					(* 2. Ù s (Ãp q∑q) = (Ãp q∑q) A B *)
			log_eq_sym(sp2, p2ab);
			log_prove_asm();
					(* 2. Ù (Ãp q∑q) A B = s (Ãp q∑q) *)
			log_eq_trans(p2ab, sp2, tp2);
			log_prove_asm();
			log_prove_asm();
					(* 1. A ± B Ù (Ãp q∑q) A B = t (Ãp q∑ q) *)
			log_¬_conv tp2;
					(* Ù t(Ãp q∑q) = (Ãp q∑q) T T *)
			log_eq_trans(p2ab, tp2, p2tt);
			log_prove_asm();
			log_prove_asm();
					(* 1. A ± B Ù (Ãp q∑q) A B = (Ãp q∑p) T T *)
			log_¬_¬_conv p2tt;
					(* 2. Ù (Ãp q∑q) T T = T *)
			log_eq_trans(p2ab, p2tt, mk_t);
			log_prove_asm();
			log_prove_asm();
					(* 1. A ± B Ù (Ãp q∑q) A B = T *)
			log_¬_¬_conv p2ab;
					(* 2. Ù (Ãp q∑q) A B = B *)
			log_eq_sym(p2ab, b_prop);
			log_prove_asm();
					(* 2. Ù B = (Ãp q∑q) A B *)
			log_eq_trans(b_prop, p2ab, mk_t);
			log_prove_asm();
			log_prove_asm();
					(* 1. A ± B Ù B § T *)
			log_subst_params ([], [(b_prop, a_prop)]);
			log_§_t_elim_thm();
					(* 2. A § T Ù A *)
			log_cmd"subst";
					(* 2. B § T Ù B *)
			log_prove_asm();
					(* 1. A ± B Ù B *)
			store obj; ()
		)
	end
);

=TEX
=INLINEFT
log_¥_intro_lemma ()
=TEX
\ pushes the following theorem onto the stack:
=GFT
A ± B § A Ù A ¥ B
=TEX
=SML
val €log_¥_intro_lemma› : unit -> unit = (
	let	val obj = (OThm o undisch_rule o prove_rule[ot_¥_def])
			¨(A § A ± B) ¥ (A ¥ B)Æ;
		val a_¥_b = mk_¥(a_prop, b_prop);
		val imp_def = ¨Ã p q∑ p ± q § pÆ;
		val imp_def_a_b = list_mk_app(imp_def, [a_prop, b_prop]);
		val r =  ¨A ± B § AÆ;
	in	fn () => try_stored obj handle Fail _ => (
			log_antecedent ot_¥_def;
				(* 1. Ù $¥ = (Ãp q∑p ± q § p) *)
			log_refl a_prop;
			log_cmd"appThm";
			log_refl b_prop;
			log_cmd"appThm";
				(* 1. (A ¥ B) = (Ãp q∑p ± q § p) A B *)
			log_¬_¬_conv imp_def_a_b;
				(* 2. Ù (Ãp q∑p ± q § p) A B § (A ± B § A) *)
			log_eq_trans(a_¥_b, imp_def_a_b, r);
			log_prove_asm();
			log_prove_asm();
				(* 1. Ù (A ¥ B) § (A ± B ¥ A) *)
			log_eq_sym(a_¥_b, r);
			log_prove_asm();
				(* 1. Ù (A ± B ¥ A) § (A ¥ B) *)
			log_assume r;	
				(* 2. A ± B § A Ù A ± B § A *)
			log_cmd"eqMp";
				(* 1. A ± B § A Ù A ¥ B *)
			store obj; ()
		)
	end
);

=TEX
=INLINEFT
log_¥_elim_them ()
=TEX
\ pushes the following theorem onto the stack:
=GFT
A, A § B Ù B
=TEX
=SML
val €log_¥_elim_thm› : unit -> unit = (
	let	val obj = (OThm o undisch_rule o undisch_rule o taut_rule)
					¨A ¥ (A ¥ B) ¥ AÆ;
		val a_¥_b = mk_¥(a_prop, b_prop);
		val imp_def = ¨Ã p q∑ p ± q § pÆ;
		val imp_def_a_b = list_mk_app(imp_def, [a_prop, b_prop]);
		val r =  ¨A ± B § AÆ;
	in	fn () => try_stored obj handle Fail _ => (
			log_antecedent ot_¥_def;
				(* 1. Ù $¥ = (Ãp q∑p ± q § p) *)
			log_refl a_prop;
			log_cmd"appThm";
			log_refl b_prop;
			log_cmd"appThm";
				(* 1. (A ¥ B) = (Ãp q∑p ± q § p) A B *)
			log_¬_¬_conv imp_def_a_b;
				(* 2. Ù (Ãp q∑p ± q § p) A B § (A ± B § A) *)
			log_eq_trans(a_¥_b, imp_def_a_b, r);
			log_prove_asm();
			log_prove_asm();
				(* 1. Ù (A ¥ B) § (A ± B ¥ A) *)
			log_assume a_¥_b;
				(* 2. A ¥ B Ù A ¥ B *)
			log_cmd"eqMp";	
				(* 1. A ¥ B Ù A ± B = A *)
			log_eq_sym(mk_±(a_prop, b_prop), a_prop);
			log_prove_asm();
				(* 1. A ¥ B Ù A = A ± B *)
			log_assume a_prop;
				(* 2. A Ù A *)
			log_cmd"eqMp";	
				(* 1. A, A ¥ B Ù A ± B *)
			log_±_right_elim_thm();
				(* 2. A ± B Ù B *)
			log_prove_asm();
				(* 1. A, A ¥ B Ù B *)
			store obj; ()
		)
	end
);

=TEX
=INLINEFT
log_µ_elim_them ()
=TEX
\ pushes the following theorem onto the stack:
=GFT
$µ P Ù P x
=TEX
=SML
val €log_µ_elim_thm› : unit -> unit = (
	let	val obj = (OThm o rewrite_rule[] o app_arg_rule ¨x:'aÆ o 
				conv_rule ¬_conv o pure_rewrite_rule[µ_def] o asm_rule)
					¨$µ (P : 'a ≠ BOOL)Æ;
		val µ_p = ¨$µ (P : 'a ≠ BOOL)Æ;;
		val all_def = ¨Ã P∑ P = (Ã x : 'a∑ T)Æ;
		val all_def_p = mk_app(all_def, p_func);
		val px = mk_app(p_func, x_var);
		val t = ¨(Ãx:'a∑ T) xÆ;
	in	fn () => try_stored obj handle Fail _ => (
			log_¬_conv all_def_p;
				(* 1. Ù (Ã P∑ P = (Ã x∑ T)) P § (P = (Ãx∑ T)) *)
			log_antecedent ot_µ_def;
				(* 2. Ù $µ = (Ã P∑ P = (Ã x∑ T)) *)
			log_refl p_func;
				(* 3. Ù P = P *)
			log_cmd"appThm";
				(* 2. $µ P § (Ã P∑ P = (Ã x∑ T)) P *)
			log_assume µ_p;
				(* 3. $µ P Ù $µ P *)
			log_cmd"eqMp";
				(* 2. $µ P Ù (Ã P∑ P = (Ã x∑ T)) P *)
			log_cmd"eqMp";	
				(* 1. $µ P Ù P = (Ãx∑ T) *)
			log_refl x_var;	
				(* 2. Ù x = x *)
			log_cmd"appThm";
				(* 1. $µ P Ù P x § (Ãx∑ T) x *)
			log_¬_conv t;
				(* 2. Ù (Ãx∑ T) x § T *)
			log_eq_trans(px, t, mk_t);
			log_prove_asm();
			log_prove_asm();
				(* 1. $µ P Ù P x § T *)
			log_subst_params([], [(px, a_prop)]);
			log_§_t_elim_thm();
			log_cmd"subst";
				(* 2. P x § T Ù P x *)
			log_prove_asm();
				(* 1. $µ P Ù P x *)
			store obj; ()
		)
	end
);

=TEX
=INLINEFT
log_µ_elim (¨tÆ, ¨AÆ)
=TEX
\ maps a stack of the following form:
=GFT
Thm á Ù µx∑A ::
Stack
=TEX
to:
=GFT
Thm á Ù A[t/x] ::
Stack
=TEX
It returns
=INLINEFT
A[t/x]
=TEX
.
=SML
fun €log_µ_elim› (t : TERM, q : TERM) : TERM = (
	let	val Ã = (snd o dest_app) q;
		val tysubs = [(type_of t, alpha)];
		val varsubs = [(t, inst [] tysubs x_var), (Ã, inst [] tysubs p_func)];
		val app = mk_app(Ã, t);
		val (v, b) = dest_simple_Ã Ã;
		val r = subst[(t, v)] b;
	in				(* 1. á Ù µx∑A *)
		log_term app;
		log_cmd"betaConv";	(* 2. Ù (Ãx∑A) t § A[t/x]  *)
		log_subst_params (tysubs, varsubs);
		log_µ_elim_thm();
		log_cmd"subst";		(* 3. µx∑A Ù (Ãx∑A) t *)
		log_cmd"eqMp";		(* 2. µx∑A Ù A[t/x] *)
		log_prove_asm();	(* 1. á Ù A[t/x] *)
		r
	end
);

=TEX
=INLINEFT
log_µ_intro_lemma ()
=TEX
\ pushes the following theorem onto the stack:
=GFT
A § (ÃP∑ P = (Ãx∑ T))(Ãx∑ T) Ù A
=TEX
=SML
val €log_µ_intro_lemma› : unit -> unit = (
	let	val obj = (OThm o undisch_rule o §_t_elim o rewrite_conv[])
				¨(A § (ÃP∑ P = (Ãx:'a∑ T))(Ãx∑ T)) ¥ AÆ;
		val r = ¨(ÃP∑ P = (Ãx:'a∑ T))(Ãx∑ T)Æ;;
		val a_§_r = ¨A § (ÃP∑ P = (Ãx:'a∑ T))(Ãx∑ T)Æ;
		val Ã_eq_Ã = ¨(Ãx:'a∑T) = (Ãx∑T)Æ;
		val Ã = ¨(Ãx:'a∑T)Æ;
	in	fn () => try_stored obj handle Fail _ => (
			log_assume a_§_r;	
(* 1. (A § (ÃP∑ P = (Ãx∑ T))(Ãx∑ T)) Ù (A § (ÃP∑ P = (Ãx∑ T))(Ãx∑ T)) *)
			log_¬_conv r;
			log_eq_trans(a_prop, r, Ã_eq_Ã);
			log_prove_asm();
			log_prove_asm();	
(* 1. (A § (ÃP∑ P = (Ãx∑ T))(Ãx∑ T)) Ù A § ((Ãx∑T) = (Ãx∑T)) *)
			log_eq_sym(a_prop, Ã_eq_Ã);
			log_prove_asm();
(* 1. (A § (ÃP∑ P = (Ãx∑ T))(Ãx∑ T)) Ù ((Ãx∑T) = (Ãx∑T)) § A *)
			log_refl Ã;
			log_cmd "eqMp";
(* 1. (A § (ÃP∑ P = (Ãx∑ T))(Ãx∑ T)) Ù A *)
			store obj; ()
		)
	end
);

=TEX
Now the actual {\Product} built-ins
=SML
fun €log_subst_rule›
	((thm_var_list, template, ithm, res)
		: (THM * TERM) list * TERM * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_antecedent res;
			store_and_drop obj; ()
		)
	end
);
=TEX
=IGN
=SML
fun €log_simple_Ã_eq_rule›
	((absvar, thrm, res) : TERM * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			(log_var o dest_var) absvar;
			log_antecedent res;
			log_cmd "absThm";
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_inst_type_rule›
	((talist, thrm, res) : (TYPE * TYPE) list * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_subst_params (talist, []);
			log_antecedent thrm;
			log_cmd "subst";
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_¥_intro›
	((asm, thrm, res) : TERM * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			let	val a = asm;
				val b = concl thrm;
			in
				log_antecedent thrm;	(* 1. á, A Ù B *)
				log_subst_params ([], [(a, a_prop), (b, b_prop)]);
				log_±_intro_thm();
				log_cmd"subst";		(* 2. A, B Ù A ± B *)
				log_prove_asm();	(* 1. á, A Ù A ± B *)
				log_subst_params ([], [(a, a_prop), (b, b_prop)]);
				log_±_left_elim_thm();
				log_cmd"subst";		(* 2. A ± B Ù A *)
				log_cmd"deductAntisym";	(* 1. á Ù A ± B § A *)
				log_subst_params ([], [(a, a_prop), (b, b_prop)]);
				log_¥_intro_lemma();
				log_cmd"subst";		(* 2. A ± B § A Ù A ¥ B *)
				log_prove_asm();	(* 1. á Ù A ¥ B *)
				store_and_drop obj; ()
			end
		)
	end
);
=TEX
=SML
fun €log_¥_elim›
	((thrm1, thrm2, res) : THM * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			let	val (a, b) = (dest_¥ o concl) thrm1;
			in	log_antecedent thrm1;
				log_antecedent thrm2;
				log_subst_params ([], [(a, a_prop), (b, b_prop)]);
				log_¥_elim_thm();
				log_cmd"subst";
				log_prove_asm();
				log_prove_asm();
				store_and_drop obj; ()
			end
		)
	end
);
=TEX
=SML
fun €log_asm_rule›
	((tm, res) : TERM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_term tm;
			log_cmd "assume";
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_refl_conv›
	((tm, res) : TERM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_term tm;
			log_cmd "refl";
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_simple_¬_conv›
	((tm, res) : TERM * THM) : unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_term tm;
			log_cmd "betaConv";
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_suc_conv›
	((tm, res) : TERM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_antecedent res;
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_string_conv›
	((tm, res) : TERM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_antecedent res;
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_char_conv›
	((tm, res) : TERM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_antecedent res;
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_eq_sym_rule›
	((thrm, res) : THM * THM)
		: unit = (
	let	val obj = OThm res;
		val (a, b) = (dest_eq o concl) thrm;
	in	check_stored obj handle Fail _ => (
			log_antecedent thrm;
			log_eq_sym(a, b);
			log_prove_asm();
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_list_simple_µ_elim›
	((tml, thrm, res) : TERM list * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			let	fun aux (t::ts) vs q = (
					let	val q' = log_µ_elim (hd vs, q);
						val vs' = tl vs;
					in	aux ts vs' q'
					end
				)  | aux [] _ _ = (
					log_cmd"subst"
				);
				fun mk_v(i, ty) = mk_var("v" ^ string_of_int i, ty);
				val vs = map mk_v
					(combine (interval 1 (length tml))
						(map type_of tml));
			in	log_subst_params([], combine tml vs);
				log_antecedent thrm;
				aux tml vs (concl thrm);
				store_and_drop obj; ()
			end
		)
	end
);

=TEX
=SML
fun €log_eq_trans_rule›
	((thrm1, thrm2, res) : THM * THM * THM)
		: unit = (
	let	val obj = OThm res;
		val (a, b) = (dest_eq o concl) thrm1;
		val (_, c) = (dest_eq o concl) thrm2;
	in	check_stored obj handle Fail _ => (
			log_antecedent thrm1;
			log_antecedent thrm2;
			log_eq_trans(a, b, c);
			log_prove_asm();
			log_prove_asm();
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_mk_app_rule›
	((thrm1, thrm2, res) : THM * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_antecedent thrm1;
			log_antecedent thrm2;
			log_cmd "appThm";
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_§_mp_rule›
	((thrm1, thrm2, res) : THM * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_antecedent thrm1;
			log_antecedent thrm2;
			log_cmd "eqMp";
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_simple_µ_intro›
	((tm, thrm, res) : TERM * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			let	val a = concl thrm;
				val x = dest_var tm;
				val ty = snd x;
				val µ = concl res;
			in	log_subst_params ([(ty, alpha)], []);
				log_antecedent ot_µ_def;
				log_cmd"subst";
					(* 1. Ù $µ = (Ã P∑ P = (Ã x∑T)) *)
				log_var x;
				log_antecedent thrm;
					(* 2. á Ù A *)
				log_subst_params([], [(a, a_prop)]);
				log_§_t_intro_thm();
				log_cmd"subst";
				log_prove_asm();
					(* 2. á Ù A § T *)
				log_cmd"absThm";
					(* 2. á Ù (Ãx∑A) § (Ãx∑T) *)
				log_cmd"appThm";
					(* 1. á Ù (µx∑A) § (ÃP∑ P = (Ã x∑T))(Ãx∑T) *)
				log_subst_params([(ty, alpha)], [(µ, a_prop)]);
				log_µ_intro_lemma();
				log_cmd"subst";
					(* 2. (µx∑A) § (ÃP∑P = (Ãx∑T))(Ãx∑T) Ù µx∑A *)
				log_prove_asm();
				store_and_drop obj; ()
			end
		)
	end
);

=TEX
=SML
fun €log_inst_term_rule›
	((tvl, thrm, res) : (TERM * TERM) list * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_subst_params ([], tvl);
			log_antecedent res;
			log_cmd "subst";
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_plus_conv›
	((tm, res) : TERM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_antecedent res;
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
val €kernel_inference_name› : KERNEL_INFERENCE -> string = (fn
		KISubstRule _ => "KISubstRule"
	|	KISimpleÃEqRule _ => "KISimpleÃEqRule"
	|	KIInstTypeRule _ => "KIInstTypeRule"
	|	KI¥Intro _ => "KI¥Intro"
	|	KI¥Elim _ => "KI¥Elim"
	|	KIAsmRule _ => "KIAsmRule"
	|	KIReflConv _ => "KIReflConv"
	|	KISimple¬Conv _ => "KISimple¬Conv"
	|	KISucConv _ => "KISucConv"
	|	KIStringConv _ => "KIStringConv"
	|	KICharConv _ => "KICharConv"
	|	KIEqSymRule _ => "KIEqSymRule"
	|	KIListSimpleµElim _ => "KIListSimpleµElim"
	|	KIEqTransRule _ => "KIEqTransRule"
	|	KIMkAppRule _ => "KIMkAppRule"
	|	KI§MPRule _ => "KI§MPRule"
	|	KISimpleµIntro _ => "KISimpleµIntro"
	|	KIInstTermRule _ => "KIInstTermRule"
	|	KIPlusConv _ => "KIPlusConv"
);
val €log_failures› : KERNEL_INFERENCE list ref = ref [];
fun €logging_checks› (ki : KERNEL_INFERENCE) (f : 'a -> unit) (x : 'a) : unit = (
	f x handle ex as Fail _ => (
		log_failures := ki :: !log_failures;
		diag_line "*** Logging function failed:";
		(diag_line o string_of_exn) ex;
		raise ex
	);
	log_diag (kernel_inference_name ki)
);
=TEX
=SML
fun €log_inference›(ki as KISubstRule par) =
	logging_checks ki log_subst_rule par
|   log_inference(ki as KISimpleÃEqRule par) =
	logging_checks ki log_simple_Ã_eq_rule par
|   log_inference(ki as KIInstTypeRule par) =
	logging_checks ki log_inst_type_rule par
|   log_inference(ki as KI¥Intro par) =
	logging_checks ki log_¥_intro par
|   log_inference(ki as KI¥Elim par) =
	logging_checks ki log_¥_elim par
|   log_inference(ki as KIAsmRule par) =
	logging_checks ki log_asm_rule par
|   log_inference(ki as KIReflConv par) =
	logging_checks ki log_refl_conv par
|   log_inference(ki as KISimple¬Conv par) =
	logging_checks ki log_simple_¬_conv par
|   log_inference(ki as KISucConv par) =
	logging_checks ki log_suc_conv par
|   log_inference(ki as KIStringConv par) =
	logging_checks ki log_string_conv par
|   log_inference(ki as KICharConv par) =
	logging_checks ki log_char_conv par
|   log_inference(ki as KIEqSymRule par) =
	logging_checks ki log_eq_sym_rule par
|   log_inference(ki as KIListSimpleµElim par) =
	logging_checks ki log_list_simple_µ_elim par
|   log_inference(ki as KIEqTransRule par) =
	logging_checks ki log_eq_trans_rule par
|   log_inference(ki as KIMkAppRule par) =
	logging_checks ki log_mk_app_rule par
|   log_inference(ki as KI§MPRule par) =
	logging_checks ki log_§_mp_rule par
|   log_inference(ki as KISimpleµIntro par) =
	logging_checks ki log_simple_µ_intro par
|   log_inference(ki as KIInstTermRule par) =
	logging_checks ki log_inst_term_rule par
|   log_inference(ki as KIPlusConv par) =
	logging_checks ki log_plus_conv par;
=TEX
To log a theorem, {\em log\_antecedent} will generate the commands to prove
and stack the theorem.
=SML
fun €log_thm› (thm : THM) : unit = (
	let	val (asms, conc) = dest_thm thm;
	in	log_antecedent thm;
		log_list log_term asms;
		log_term conc;
		log_cmd "thm";
		()
	end	
);
=TEX
=SML
fun €log_new_axiom› (tm : TERM) : unit = (
	log_list log_term [];
	log_term tm;
	log_cmd "axiom"
);
=TEX
For the following, note that {\em defineConst} stacks two things:
the constant and its defining theorem and that removes pushes
the object it is removing from the dictionary onto the stack.
=SML
fun €log_simple_new_defn› (n : string, t : TERM) : unit = (
	let	val k = next_key();
	in	log_const_name n;
		log_term t;
		log_cmd "defineConst";
			(* 1. OConst c *)
			(* 2. Ù c = t *)
		log_num k;
		log_cmd "def";
		log_cmd "pop";
		log_cmd "pop";
		log_num k;
		log_cmd "remove"
	end
);
=TEX
Note that we must ensure
that each constant is defined before proving theorems that contain it.
=SML
fun €log_new_spec› (ndefs : int, thm : THM) : unit = (
	let			fun aux2 0 thm0 = thm0
		|   aux2 i thm0 = (
			let	val (n, ty) = (dest_var o fst o dest_∂ o concl) thm0;
				val c = mk_const(n, ty);
				val t = (mk_≈ o dest_∂ o concl) thm0;
				val _ = log_simple_new_defn (n, t);
				val thm1 = ∂_≈_rule thm0;
				val thm2 = (eq_sym_rule o asm_rule o mk_eq) (c, t);
				val thm3 = pure_once_rewrite_rule [thm2] thm1;
						(* c = (≈c∑p), ... Ù p[c/v] *)
			in	aux2 (i-1) thm3
			end
		);
		fun aux3 0 = ()
		|   aux3 i = (
log_diag "calling prove_asm";
			log_prove_asm();
			aux3 (i-1)
		);
	in	log_antecedent (aux2 ndefs thm);
				(* 1. Ù c1 = ≈c∑p1 *)
				(* ... *)
				(* (ndefs+1). c1 = ≈c∑p1, ... Ù p[c1/v1, ...] *)
		aux3 ndefs
				(* 1. Ù p[c1/v1, ...] *)
	end
);
=IGN
=TEX
=SML
fun €log_state_change› (SaveThm (_, thm)) =
	log_thm thm
|   log_state_change (ListSaveThm (_, thm)) =
	log_thm thm
|   log_state_change (NewAxiom ((_, tm), _)) =
	log_new_axiom tm
|   log_state_change (SimpleNewDefn ((_, n, tm), _)) =
	log_simple_new_defn(n, tm)
(*
|   log_state_change (NewTypeDefn (_, name, typars, thm), _)) =
	log_new_type_defn (name, typars, thm)
*)
|   log_state_change (NewSpec ((_, ndefs, thm), _)) =
	log_new_spec (ndefs, thm)
|   log_state_change _ = ();

=TEX
\subsubsection{Interface}
=TEX
=SML
val €ki_key› : KI_KEY ref = ref (on_kernel_inference log_inference);
val €oksc_key› : OKSC_KEY ref = ref (on_kernel_state_change log_state_change);
val _ = delete_kernel_inference_fun (!ki_key);
val _ = delete_on_kernel_state_change_fun (!oksc_key);
=TEX
=SML
fun €start_logging› (() : unit) : unit = (
	(delete_kernel_inference_fun (!ki_key) handle Fail _ => ());
	ki_key := on_kernel_inference log_inference;
	(delete_on_kernel_state_change_fun (!oksc_key) handle Fail _ => ());
	oksc_key := on_kernel_state_change log_state_change
);
=TEX
=SML
fun €stop_logging› (() : unit) : unit = (
	delete_kernel_inference_fun (!ki_key) handle Fail _ => ();
	delete_on_kernel_state_change_fun (!oksc_key) handle Fail _ => ()
);
=TEX
=SML
fun €proof_to_article› {file : string, prf_fun : 'a -> THM list} (x : 'a) : unit = (
	reset_km_state ();
	open_log file;
	start_logging ();
	app log_thm (prf_fun x);
	stop_logging ();
	close_log();
	()
);
=TEX
=SML
fun €term_to_article› {file : string, tm : TERM} : unit = (
	proof_to_article {file = file, prf_fun = fn tm => [refl_conv tm]} tm
);
=SML
=TEX
\subsection{Epilogue}
=SML
end (* of structure OpenTheoryInternals *);
structure OpenTheory : OpenTheory = OpenTheoryInternals;
open OpenTheory;
open OpenTheoryInternals; (* TODO: remove this and following *)
val _ = logging_diagnostics := true;
=TEX

\twocolumn[\section*{INDEX}]
\small
\printindex

\end{document}
=IGN

val th1 = pc_rule1 "lin_arith" prove_rule[] ¨2 < x ¥ 1 < xÆ;
val th2 = asm_rule ¨2 < xÆ;
open_log "t.art";
reset_km_state();
start_logging();
¥_elim th1 th2;
log_diag "end of test";
stop_logging();
close_log();

open_log "t.art";
reset_km_state();
start_logging();
¥_intro ¨1 < xÆ th2;
stop_logging();
log_diag "end of test";
close_log();

val th3 = (undisch_rule o undisch_rule o pc_rule1 "lin_arith" prove_rule[])
		¨2 < x ¥ x < y ¥ 1 < xÆ;
open_log "t.art";
reset_km_state();
start_logging();
¥_intro ¨2 < xÆ th3;
log_diag "end of test";
stop_logging();
close_log();

open_log "t.art";
reset_km_state();
start_logging();
¥_elim (¥_intro ¨2 < xÆ t_thm) (asm_rule ¨2 < xÆ);
log_diag "end of test";
stop_logging();
close_log();

open_log "t.art";
reset_km_state();
start_logging();
¥_elim  th3a th3b;
log_diag "end of test";
stop_logging();
close_log();

val th4 = pc_rule1 "lin_arith" prove_rule[]
		¨2 < x ¥ x < y ¥ 1 < xÆ;
open_log "t.art";
reset_km_state();
start_logging();
val res = simple_µ_intro ¨x:ÓÆ th4;
log_diag "end of test";
stop_logging();
close_log();


val th5 = times_assoc_thm;

open_log "t.art";
reset_km_state();
start_logging();
val res = list_simple_µ_elim [¨x+1Æ, ¨v2+27Æ] th5;
log_diag "end of test";
stop_logging();
close_log();

val th6 = µ_intro ¨i:ÓÆ times_assoc_thm;

open_log "t.art";
reset_km_state();
start_logging();
val res = list_simple_µ_elim [¨x+1Æ, ¨v2+27Æ] th6;
log_diag "end of test";
stop_logging();
close_log();


val th7 = map_def;

open_log "t.art";
reset_km_state();
start_logging();
val res = inst_type_rule [(îÓÆ, î'aÆ)] th7;
log_diag "end of test";
stop_logging();
close_log();


open_log "t.art";
reset_km_state();
start_logging();
val res = refl_conv ¨xÆ;
log_diag "end of test";
stop_logging();
close_log();

val thm1 = tac_proof (([], ¨∂a:Ó∑  a < 10Æ),
	∂_tac ¨1Æ THEN PC_T1 "basic_hol1" REPEAT strip_tac
);

open_log "t.art";
reset_km_state();
start_logging();
val _ = new_spec (["a"], 1, thm1);
stop_logging();
log_diag "end of test";
close_log();



val thm2 = tac_proof (([], ¨∂a b c:Ó∑  a < b ± b < cÆ),
	∂_tac ¨1Æ THEN ∂_tac ¨2Æ THEN ∂_tac ¨3Æ THEN PC_T1 "basic_hol1" REPEAT strip_tac
);

open_log "t.art";
reset_km_state();
start_logging();
val _ = new_spec (["a", "b"], 2, thm2);
stop_logging();
log_diag "end of test";
close_log();

open_log "t.art";
reset_km_state();
start_logging();
val _ = simple_new_defn (["a"], "xyz", mk_t);
stop_logging();
log_diag "end of test";
close_log();

vm_diagnostics := 0;

val _ = open_theory_import{file = "t.art", parent = "open-theory-base", theory = "t"}; 

