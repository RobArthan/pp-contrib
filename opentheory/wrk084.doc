=IGN
********************************************************************************
%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING, E.G. FOR QCZ:
wrk084.doc: this file is part of the ProofPower system

Copyright (c) Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% $Id: wrk084.doc,v 1.9 2014/03/11 10:17:46 rda Exp rda $
=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,12pt]{article}
%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{url}
\makeindex
\ftlinepenalty=9999

%%%%% YOU WILL WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{ OpenTheory for ProofPower }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{ This document discusses the transfer of specifications and proofs
between {\Product} and other members of the HOL family of interactive theorem provers
via OpenTheory. It includes a literate script providing an experimental implementation
of an OpenTheory reader and an OpenTheory writer for {\Product}.
}
\end{center}}

\def\Reference{LEMMA1/QCZ/WRK084}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 7947 030 682}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.9 $%
}
\def\Date{\FormatDate{$Date: 2014/03/11 10:17:46 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

%%%% %%%% %%%% %%%%
\subsection{Contents}
%%%% %%%% %%%% %%%%


\tableofcontents

%%%%% REFERENCES:

\newpage
%%%% %%%% %%%% %%%%
\subsection{References}
%%%% %%%% %%%% %%%%


\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{daz}
}

%%%%% CHANGES HISTORY:
%\subsection{Changes History}
%\begin{description}
%\item[Issues 1.1] Initial draft.
%\end{description}

%%%%%  CHANGES FORECAST:

%\subsection{Changes Forecast}
 
%%%%% DISTRIBUTION LIST

%\subsection{Distribution}
%\begin{center}
%\begin{tabular}{ll}
%Rob Arthan & Lemma 1\\
%\end{tabular}
%\end{center}

%%%%% NOW THE CREATIVE BIT:
\newpage

%%%% %%%% %%%% %%%%
\section{INTRODUCTION}
%%%% %%%% %%%% %%%%

{\Product} is an interactive theorem prover in the HOL family, that {\it inter alia}
provides proof support for the Z notation and is used as the proof engine for
Z in D-RisQ's CLawZ toolset~\cite{OHalloran13}.
HOL4 is another system in the HOL family that is widely used in academia.
In particular, HOL4 is the platform for the work of Myreen {\it et al.}
on decompiling object code into logic~\cite{myreen-et-al12}.
D-RisQ are interested in combining the capabilities of the CLawZ tools and
the technique of decompilation into logic.

OpenTheory \cite{hurd11} is an initiative to develop a concept of {\em theory engineering} for the
development and management of large bodies of formal specifications and proofs, analogous to the
concept of {\em software engineering} that arose in the 1960s for the development and management
of large software systems.
OpenTheory defines a file format that can be used to transfer
specifications and proofs from one theorem proving system in the HOL
family to another. This is
supported by the {\tt opentheory} tool which provides a number of useful
services for grouping articles into packages and for managing a set of packages.

As part of a research programme
funded by DSTL, D-RisQ have commissioned
an experimental implementation of OpenTheory in {\Product},
in order to provide some level of inter-operability between {\Product} and
other implementations of HOL, specifically to allow specification to
be transferred betweem HOL4 and {\Product}. 
This document is a {\Product} literate script that contains this
implemementation and some discussion of its design.

The OpenTheory interface provided here comprises a {\em reader} for importing
OpenTheory articles and a {\em writer} for exporting them.
Both these interfaces are experimental and are likely to need further customisation.
However, transfer of specifications and proofs in both direction between HOL4 and {\Product}
has been demonstrated as has importing specifications from the Gilith OpenTheory Repo.

The remainder of this document is structured as follows:
\begin{description}
\item[Section~\ref{sec:discussion}] discusses OpenTheory and the present
implementation of a reader and a writer for the OpenTheory article format in {\Product}.
\item[Section~\ref{sec:examples}] shows examples of transfer from HOL4 to {\Product} and {\it vice versa}.
\item[Section~\ref{sec:structure}] documents the interfaces provided in
the style of the {\Product} reference manual.
\item[Appendix~\ref{sec:implementation}] is the {\Product} literate script that
implements the interfaces. (There is an index to the implementation at the end of
the document.)
\end{description}

\newpage
%%%% %%%% %%%% %%%%
\section{DISCUSSION}\label{sec:discussion}
%%%% %%%% %%%% %%%%

%%%% %%%% %%%% %%%%
\subsection{Overview of OpenTheory}
%%%% %%%% %%%% %%%%

The goal of OpenTheory is to allow proofs and the specifications on which
those proofs depend to be shared between different
implementations of theorem provers for higher-order logic (HOL), specifically,
HOL4, HOL Light and {\Product}.
The OpenTheory initiative has also produced the
Gilith OpenTheory Repo, a collection of theory packages containing
a large body of specifications and proofs extending a base theory package containing
definitions intended to be common to all HOL implementations.

The OpenTheory project has defined two file formats that are used to
describe theory packages: the {\em article file format} is the basic
mechanism for transferring specifications and proofs;
the {\em theory file format} describes how one or more article files
can be combined into a package. In this document we are only
concerned with importing from and exporting to article files.
(The {\tt opentheory} tool can be used, if needed, to create theory
files.)

An article file comprises a sequence of commands for a virtual machine.
The virtual machine constructs HOL types, terms and theorems and outputs
two sets: a set of assumptions, i.e., axioms, and a set of theorems,
i.e., assertions that have been proved using the axioms.
An implementation in a system like {\Product} can realise the virtual
machine so that the output is added to its database of
definitions, axioms and theorems.
The OpenTheory reader for {\Product} does exactly that.

Initially, it was not clear whether the Gilith OpenTheory Repo would be relevant to the
specific problem of transferring specifications from HOL4 to {\Product}.
However, it turned out to be very useful both as a source of test material
and in defining a common vocabulary that is used by the HOL4 implementation
of an OpenTheory writer.

%%%% %%%% %%%% %%%%
\subsection{{\Product} OpenTheory Reader}
%%%% %%%% %%%% %%%%

The {\Product} OpenTheory reader is based on a generic implementation
of the OpenTheory virtual machine with parameters defining the
mapping of the vocabulary and definitions in the input to
{\Product} vocabulary and extension mechanisms.
This has then been instantiated to accept the vocabulary and
definitions used by the Gilith OpenTheory Repo and the HOL4 OpenTheory writer.

The base theory package in the Gilith OpenTheory Repo has been imported into {\Product}.
However, the level of integration with the native {\Product} vocabulary is limited.
This is due to an issue with the level of abstraction in the base theory package as currently
distributed.The issue is that the package currently gives concrete constructions of
types rather than abstract specifications. This results in certain constants appearing in the
name space that are not actually part of the documented interface. For this reason,
the {\Product} reader currently only maps the basic logical vocabulary to native {\Product}
vocabulary. Vocabulary relating to defined types, such as lists or numbers, is
defined afresh when the base theory article is imported.
Options for repackaging the base theory package are under discussion.

Once the mapping of vocabulary is settled importing proofs is relatively straightforward
since one has all the capabilities of {\Product} available to implement the OpenTheory
inference rules as derived rules.
The mapping of the definitional principles of OpenTheory is also straightforward, but slightly
complicated in the present implementation to support the handling of the basic logical
vocabulary of the base theory package in the Gilith OpenTheory Repo. This is done by
recognising the OpenTheory definitions of the logical operators and simulating the
definitions using theorems derived from the {\Product} definitions. Extending this
approach to deal with the types defined in the base theory package is not
practical without some more detailed analysis of the base theory package internals.
The approach will be revisited when the outcome of ongoing discussions
about the packaging of the base theory is known.

%%%% %%%% %%%% %%%%
\subsection{{\Product} OpenTheory Writer}
%%%% %%%% %%%% %%%%

The OpenTheory writers for HOL4 and HOL Light are implemented with
a special version of the logical
kernel that includes a proof tree in the representation of a theorem. 
{\Product} enables functions that monitor logical kernel operations to be registered.
The {\Product} OpenTheory writer uses this facility to export a log
of the kernel operations as an OpenTheory article. The process is parametrized
by functions that map type and constant names to the desired external form.

Exporting proofs is a more intricate problem than importing them because OpenTheory
does not provide high-level facilities for programming proofs. (This is intended,
since it makes the OpenTheory kernel small, simple and dependable.)
The writer is implemented as a library of functions that output the command sequences
for tasks such as building a term or carrying out an inference step.

OpenTheory only supports constant definitions of the form $c = t$ where $c$ is
the constant being defined, whereas {\Product} and HOL4 both support
a more general mechanism whereby if an existence theorem
$\vdash \exists x_1, \ldots x_k \bullet \phi(x_1, \ldots, x_k)$ has been
proved, it can be used to specify new constants $c_1, \ldots, c_k$
with defining property $\vdash \phi(c_1, \ldots, c_k)$.
We simulate the effect of this mechanism using the Hilbert choice function
$\epsilon$, defining
$c_1 = \epsilon x_1 \bullet  \exists x_2, \ldots x_k \bullet \phi(x_1, \ldots, x_k)$, 
$c_2 = \epsilon x_2 \bullet  \exists x_3, \ldots x_k \bullet \phi(c_1, x_2, \ldots, x_k)$ and so on.
The theorem  $\vdash \phi(c_1, \ldots, c_k)$ can then be inferred from
the existence theorem and these definitions.
The resulting translated definition is less abstract than the original
but this is inevitable. It is hoped that a more general mechanism for
constant definitions will be added to OpenTheory.

Type definitions in OpenTheory follow HOL Light in introducing constants
for the abstraction and representation functions for the new type.
In contrast, the new type definition mechanism
in {\Product} and HOL4 returns a theorem that implies the abstraction
and representation functions exist, but does not actually make the
constant definitions. The translation of type definitions involves
deducing the existence theorem from the defining properties of the
new constants.
The writer also has to invent names for the new constants, which will
only be used in the proof of the existence theorem.

An issue with the chosen implementation approach is that theorems
that have been proved when logging is not turned on will appear as
assumptions in the article file if they are used in a proof that is exported.
Typically such theorems will be lemmas used in derived inference rules.
One solution to this would be to record some or all of the inferences made when the
system is built, so that the proofs of these lemmas can be recreated.

\newpage
%%%% %%%% %%%% %%%%
\section{EXAMPLES}\label{sec:examples}
%%%% %%%% %%%% %%%%

{\vertbarfalse

Time has not permitted evaluation of the {\Product} OpenTheory implementation on
large-scale examples from HOL4 during the preparation of this document.
In this section we give small examples of transfer in
both directions between HOL4 and {\Product}.
These examples are intended to illustrate the various mappings that are applied during transfer
of a theory and give an idea of what information is transferred and
what information is lost.

%%%% %%%% %%%% %%%%
\subsection{Import from HOL4}
%%%% %%%% %%%% %%%%

A theory was constructed in HOL4 containing the definition
of a predicate {\em is\_non\_const\_fun} that is true
of non-constant functions and used to define a type
in one-to-one correspondence with the non-constant
one-argument propositional functions.
=GFT HOL4 Theory Listing
	Theory: OpenTheoryEg

	Parents:
	    string

	Type constants:
	    non_const_fun 0

	Term constants:
	    is_non_const   :('a -> 'b) -> bool

	Definitions:
	    is_non_const_def
	      |- !f. is_non_const f <=> ?x y. f x <> f y
	    non_const_fun_TY_DEF
	      |- ?rep. TYPE_DEFINITION is_non_const rep
=TEX
(For technical reasons, it is not possible to typeset Unicode
symbols in this document, so HOL4 listings have to be given in
the ASCII format.)

The defining property of the type was exported into
an article file (which also causes the definition
of {\em is\_non\_const\_fun} to be exported, since the
type definition depends on it).
The article file was then imported into {\Product}.

=GFT ProofPower Theory Listing
	=== The theory open-theory-eg1 ===

	--- Parents ---

			open-theory-base

	--- Constants ---

	is_non_const	('A ≠ 'B) ≠ BOOL
	non_const_fun_rep
			non_const_fun ≠ BOOL ≠ BOOL
	non_const_fun_abs
			(BOOL ≠ BOOL) ≠ non_const_fun

	--- Types ---

	non_const_fun

	--- Definitions ---

	const_spec1	Ù is_non_const = (Ã f∑ ∂ x y∑ ≥ f x = f y)
	type_defn1	Ù ∂ f∑ TypeDefn is_non_const f
	abs_rep1	Ù (µ a∑ non_const_fun_abs (non_const_fun_rep a) = a)
			    ± (µ r∑ is_non_const r §
				non_const_fun_rep (non_const_fun_abs r) = r)

	--- Theorems ---

	thm1		Ù ∂ rep∑ TypeDefn is_non_const rep

	=== End of listing of theory open-theory-eg1 ===
=TEX
Note that the type variable names are in upper case in the imported theory.
This is because the HOL4 OpenTheory writer maps the names to follow
the Gilith OpenTheory repo conventions, so $'a$ becomes $A$. The {\Product} reader
then makes the names conform with {\Product} (and HOL4) convention that
type variable names begin with a prime character.
Since {\Product} and HOL4 have essentially the same conventions for type variable names,
it would be desirable if their OpenTheory readers and writers used the same mappings.
This is a point for discussion, since the mapping has to be one-to-one,
but the mappings currently used are only one-to-one subject to some assumptions
on the input.

The type name {\em bool} has been converted to upper case by the {\Product}
OpenTheory reader to match the {\Product} case conventions.
The reader has converted the HOL4 function {\em TYPE\_DEFINITION} into the
{\Product} equivalent {\em TypeDefn}.
The extra constants {\em non\_const\_fun\_rep} and {\em non\_const\_fun\_abs}
introduced by the OpenTheory type definition mechanism
have names invented by the HOL4 writer.

The idea that a theory includes a database of named definitions is implementation-specific:
HOL4 and {\Product} have this feature, but HOL Light does not. 
Consequently, the HOL4 database keys ({\em is\_non\_const\_def} etc.) are not represented
in the OpenTheory article file and the {\Product} database keys ({\em const\_spec1} etc.)
are invented by the {\Product} OpenTheory reader.

%%%% %%%% %%%% %%%%
\subsection{Export to HOL4}
%%%% %%%% %%%% %%%%

A theory was constructed in {\Product} containing the definition
of a predicate {\em is\_const\_fun} that is true
of constant functions and used to define a polymorphic
type of constant functions.
=GFT ProofPower Theory Listing
	=== The theory open-theory-eg2 ===

	--- Parents ---

			open-theory-base

	--- Constants ---

	is_const	('a ≠ 'b) ≠ BOOL

	--- Types ---

	('1, '2) CONST_FUN

	--- Definitions ---

	is_const_def	Ù µ f∑ is_const f § (µ x y∑ f x = f y)
	CONST_FUN	Ù ∂ f∑ TypeDefn is_const f

	=== End of listing of theory open-theory-eg2 ===
=TEX
The {\Product} theory was constructed with OpenTheory logging switched
on resulting in an article file, which was then imported into HOL4.
=GFT HOL4 Theory Listing
	Theory: OpenTheoryEg

	Parents:
	    string

	Type constants:
	    CONST_FUN 2

	Term constants:
	    CONST_FUN_abs_   :('a -> 'b) -> ('a, 'b) CONST_FUN
	    CONST_FUN_rep_   :('a, 'b) CONST_FUN -> 'a -> 'b
	    is_const         :('a -> 'b) -> bool

	Definitions:
	    CONST_FUN_TY_DEF
	      |- ?rep. TYPE_DEFINITION is_const rep
	    CONST_FUN_bij
	      |- (!a. CONST_FUN_abs_ (CONST_FUN_rep_ a) = a) /\
	         !r. is_const r <=> (CONST_FUN_rep_ (CONST_FUN_abs_ r) = r)
	    is_const_def
	      |- is_const = @is_const. !f. is_const f <=> !x y. f x = f y
=TEX
The names of the extra constants {\em CONST\_FUN\_abs\_}
and {\em CONST\_FUN\_rep\_} have been invented by the {\Product} writer,
while the definition keys {\em CONST\_FUN\_DEF} have been invented by the
HOL4 reader.
} %\vertbarfalse

\newpage
%%%% %%%% %%%% %%%%
\section{THE STRUCTURE OpenTheory}\label{sec:structure}
%%%% %%%% %%%% %%%%

The OpenTheory implementation is packaged in a structure (i.e., a Standard ML module)
with the following signature.
(As usual in {\Product} we document a structure by annotating its
signature with narrative describing the intended implementation.)
=SML
signature €OpenTheory› = sig
=TEX

%%%% %%%% %%%% %%%%
\subsection{The Reader}\label{sec:reader}
%%%% %%%% %%%% %%%%


%%%% %%%% %%%% %%%%
\subsubsection{Command Interface}
%%%% %%%% %%%% %%%%


=DOC
val €open_theory_import› : {file : string, parent : string, theory : string} -> unit;
=DESCRIBE
This function provides a simple interface to the OpenTheory reader to
import a single article file into a {\Product} theory.
It expects the article to use the naming conventions and definitions
of the Gilith OpenTheory Repo, but also supports the forms of
type definition implemented in HOL4 and {\Product}.
The article file is loaded into the named theory, which is newly created
for the purpose (any existing theory of that name is deleted).
The theory is created as a child of the indicated parent theory and
the theory ``open-theory-base'' is made a parent if it is not an ancestor
of the specified parent.
=ENDDOC
%%%% %%%% %%%% %%%%
\subsubsection{Programmatic Interface}
%%%% %%%% %%%% %%%%

For experimental purposes, the core functionality of the OpenTheory reader
is presented as a programmable interface to the OpenTheory
virtual machine.
=TEX
A name in an article file is a pair comprising a hierarchical name space and the name of a component within that namespace.
=SML
type €NAME› = string list * string;
=TEX
The types {\em TYPE\_DEFN\_INFO} and {\em ABS\_REP\_THMS} represent
the inputs and outputs of the {\em defineTypeOp} command.
The virtual machine is parametrized by a function that provides the semantics
for this command. This function may, for example, create the outputs using
an existing type definition rather than trying to define
a new type.
=SML
type €TYPE_DEFN_INFO› =  {
	thm : THM,
	pars : string list,
	rep : string,
	abs : string,
	tyname : string
};
type €ABS_REP_THMS› = {
	abs_rep : THM,
	rep_abs : THM
};
=TEX
The type {\em CONST\_DEFN\_INFO} represents the inputs of the {\em defineConst}
command.
The virtual machine is parametrized by a function that maps these inputs
to the desired designing theorem, e.g., by using the defining property of
an existing constant.
=SML
type €CONST_DEFN_INFO› = {
	name : string,
	def_rhs : TERM
};
=TEX
The import interface then comprises 
{\em(i)} a function {\em declare\_axiom} to handle the {\em axiom} command,
{\em(ii)} a function {\em define\_type\_op} to handle the {\em defineTypeOp} command,
{\em(iii)} a function {\em define\_const} to handle the {\em defineConst} command,
{\em(iv)} a function {\em const\_name} to map OpenTheory names to constant names,
{\em(v)} a function {\em type\_name} to map OpenTheory names to type names
and {\em(vi)} a an initial set of assumptions.
=SML
type €IMPORT_INTERFACE› = {
	declare_axiom : SEQ -> THM,
	define_type_op : TYPE_DEFN_INFO -> ABS_REP_THMS,
 	define_const : CONST_DEFN_INFO -> THM,
	const_name : NAME -> string,
	type_name : NAME -> string,
	assumptions : THM list
};
=TEX
The {\em const\_name} and {\em type\_name} functions in the import
interfaces may be defined using tables mapping OpenTheory names to the
{\Product} names of types and constants.
=SML
type €NAME_MAPS› = {
	type_map : (NAME * string) list,
	const_map : (NAME * string) list
};
=TEX
The function {\em mk\_import\_interface} sets up an import interface
from name map tables given as a parameter.
The functions {\em declare\_axiom}, {\em define\_type\_op} and
{\em define\_const} it constructs map to the corresponding {\Product}
operations or use the Gilith OpenTheory Repo definitions (proved
as theorems using existing {\Product} definitions for the relevant operators).
=SML
val mk_import_interface : NAME_MAPS -> IMPORT_INTERFACE;
=SML
=TEX
The objects that the virtual machine deals with range over the type {\em OBJECT}:
=SML
datatype €OBJECT› =
		€ONum› of INTEGER    		(* A number *)
	|	€OName› of NAME		(* A name *)
	|	€OList› of OBJECT list		(* A list (or tuple) of objects *)
	|	€OTypeOp› of string		(* A higher order logic type operator *)
	|	€OType› of TYPE			(* A higher order logic type *)
	|	€OConst› of NAME			(* A higher order logic constant *)
	|	€OVar› of string * TYPE		(* A higher order logic term variable *)
	|	€OTerm› of TERM			(* A higher order logic term *)
	|	€OThm› of THM			(* A higher order logic theorem *);
=TEX
The state of the virtual machine includes a dictionary mapping integers
to objects:
=SML
type €OBJECT_DICT› = (int, OBJECT) SEARCH_TREE;
=TEX
The stack and 
=SML
type €WM_STATE› = {
	interface : IMPORT_INTERFACE,
	command_count : int,
	stack : OBJECT list,
	dictionary : OBJECT_DICT,
	assumptions : THM NET,
	theorems : THM list};
=TEX
=SML
val €vm_diagnostics› : int ref;
=TEX
{\em vm\_diagnostics} can be set to give various levels of diagnostic
output. It is checked after each command is executed resulting in output
as follows:

\begin{center}
\begin{tabular}{|r|p{5in}|}\hline
${} < 0$ & All diagnostic output is suppressed.\\\hline
$0$ & A progress pragma command will output its operand. \\\hline
$1$ & A progress pragma command will output its operand and the number of commands executed (including this command). \\\hline
$2$ & A progress pragma command will cause its operand, the number of commands executed, the new top of stack and the old stack to be printed. \\\hline
$3$ & The command and the number of commands executed are printed. A progress pragma command does not output its operand. \\\hline
$4$ & The command, the number of commands executed and the new top of stack are printed if the command has inferred a theorem or fetched a theorem from the dictionary. A progress pragma command outputs its operand. \\\hline
$5$ & The command, the number of commands executed, the new top of stack and the old stack are printed if the command has inferred a theorem or fetched a theorem from the dictionary. A progress pragma command outputs its operand. \\\hline
${} > 5$ & The command, the number of commands executed, the new top of stack and the old stack are printed unconditionally. A progress pragma command outputs its operand. \\\hline
\end{tabular}
\end{center}

The virtual machine records its current state in the variable {\em diag\_state}.
=SML
val €diag_state› : WM_STATE OPT ref;
=TEX
The programmatic interface to the virtual machine is the following
function.
The second parameter represents the input stream.
=SML
val €open_theory_vm› : IMPORT_INTERFACE -> 
	('s -> (string * 's) OPT) -> 's -> WM_STATE;
=TEX
%%%% %%%% %%%% %%%%
\subsection{The Writer}\label{sec:writer}
%%%% %%%% %%%% %%%%

%%%% %%%% %%%% %%%%
\subsubsection{Parameters}
%%%% %%%% %%%% %%%%

The writer is parametrized by functions that map type and constant names to
OpenTheory names and by strings used as suffixes for the abstraction and representation
functions for new types. 
=TEX
=SML
type €EXPORT_INTERFACE› = {
	type_name : string -> NAME,
	const_name : string -> NAME,
	abs_suffix : string,
	rep_suffix : string};
=TEX
=SML
val €export_interface› : EXPORT_INTERFACE ref;
=TEX
%%%% %%%% %%%% %%%%
\subsubsection{Interface}
%%%% %%%% %%%% %%%%

=DOC
val €begin_open_theory_export› : string -> unit;
val €end_open_theory_export› : unit -> unit;
=DESCRIBE
These functions control the OpenTheory writer enabling definitions and proofs to
be exported in the OpenTheory article format.
{\em begin\_open\_theory\_export file} reinitialises the writer state and
initiates exporting into the specified article file.
The article file is overwritten if it already exists.

{\em end\_open\_theory\_export} closes the current article file and terminates logging.
=SEEALSO
{\em proof\_to\_article, term\_to\_article}
=ENDDOC
=DOC
val €proof_to_article› : {file: string, prf_fun: 'a -> THM list} -> 'a -> unit;
=DESCRIBE
{\em proof\_to\_article} generates an OpenTheory article from a function that proves
 a list of theorems. This provides a simple mechanism for
transferring proofs from {\Product} to another HOL system or to the Gilith OpenTheory Repository.
=SEEALSO
{\em term\_to\_article, begin\_open\_theory\_export, end\_open\_theory\_export}
=ENDDOC
=DOC
val €term_to_article› : {tm: TERM, file: string} -> unit;
=DESCRIBE
This function generates an OpenTheory article from a term, $t$.
The article proves the theorem $t = t$. This provides a simple mechanism for
transferring terms from {\Product} to another HOL system.
=SEEALSO
{\em proof\_to\_article, begin\_open\_theory\_export, end\_open\_theory\_export}
=ENDDOC
=SML
end (* of signature OpenTheory *);
=TEX
%%%% %%%% %%%% %%%%
\subsection{Errors}
%%%% %%%% %%%% %%%%

The OpenTheory interfaces define the following error messages.
=FAILURE
122001	invalid stack. Expected ?0
122002	unexpected empty stack
122003	invalid command ?0
122004	invalid name (final quotation symbol missing)
122005	invalid name (junk after final quotation symbol)
122006	invalid name (ends with a backslash)
122007	invalid variable or type variable name (not in global namespace)
122008	invalid list
122009	¨?0Æ is not of type îBOOLÆ
122010	attempt to access non-existent dictionary entry
122011	ill-formed substitution
122012	invalid command
122013	Cannot define ?0 = ?1 (?0 clashes with an existing constant,
	original exception: ?2)
=TEX
\newpage
\appendix
%%%% %%%% %%%% %%%%
\section{IMPLEMENTATION}\label{sec:implementation}
%%%% %%%% %%%% %%%%

=TEX
=SML
structure €OpenTheoryInternals› = struct 
=TEX
=SML
val _ = open_theory "basic_hol";
val _ = set_merge_pcs ["basic_hol1"];
=TEX

%%%% %%%% %%%% %%%%
\subsection{Interface Types}
%%%% %%%% %%%% %%%%


=SML
type €NAME› = string list * string;
type €NAME_MAPS› = {
	type_map : (NAME * string) list,
	const_map : (NAME * string) list
};
type €TYPE_DEFN_INFO› =  {
	thm : THM,
	pars : string list,
	rep : string,
	abs : string,
	tyname : string
};
type €CONST_DEFN_INFO› = {name : string, def_rhs : TERM};
type €ABS_REP_THMS› = {abs_rep : THM, rep_abs : THM};
type €IMPORT_INTERFACE› = {
	declare_axiom : SEQ -> THM,
	define_type_op : TYPE_DEFN_INFO -> ABS_REP_THMS,
 	define_const : CONST_DEFN_INFO -> THM,
	assumptions : THM list,
	const_name : NAME -> string,
	type_name : NAME -> string 
};
=SML
datatype €OBJECT› =
		€ONum› of INTEGER    		(* A number *)
	|	€OName› of NAME		(* A name *)
	|	€OList› of OBJECT list		(* A list (or tuple) of objects *)
	|	€OTypeOp› of string		(* A higher order logic type operator *)
	|	€OType› of TYPE			(* A higher order logic type *)
	|	€OConst› of NAME			(* A higher order logic constant *)
	|	€OVar› of string * TYPE		(* A higher order logic term variable *)
	|	€OTerm› of TERM			(* A higher order logic term *)
	|	€OThm› of THM			(* A higher order logic theorem *);
=TEX
%%%% %%%% %%%% %%%%
\subsection{Reader}
%%%% %%%% %%%% %%%%

=TEX
=SML
val €vm_diagnostics› : int ref = ref 0;
=TEX
%%%% %%%% %%%% %%%%
\subsubsection{Virtual Machine Types}
%%%% %%%% %%%% %%%%

=SML
type €OBJECT_DICT› = (int, OBJECT) SEARCH_TREE;
type €WM_STATE› = {
	interface : IMPORT_INTERFACE,
	command_count : int,
	stack : OBJECT list,
	dictionary : OBJECT_DICT,
	assumptions : THM NET,
	theorems : THM list};
=TEX
%%%% %%%% %%%% %%%%
\subsubsection{State Access Functions}
%%%% %%%% %%%% %%%%

=TEX
=SML
fun €convert_var_name› ( ([], base) : NAME ) : string = (
	base
) | convert_var_name _ = fail "open-theory-reader" 122007 [];
=TEX
=SML
fun €convert_tyvar_name› ( ([], base) : NAME ) : string = (
	case explode base of
		"'"::_ => base
	|	_ => "'" ^ base
) | convert_tyvar_name _ = fail "open-theory-reader" 122007 [];
=TEX
=SML
fun €initial_vm_state› (interface : IMPORT_INTERFACE) : WM_STATE = ({
	interface = interface,
	command_count = 0,
	stack = [],
	dictionary = initial_search_tree int_order,
	assumptions =
		list_net_enter
			(map (fn th => (concl th, th)) (#assumptions interface))
				empty_net,
	theorems = []}
);
=TEX
=SML
fun €push_object› (ob : OBJECT)
	({interface, command_count, stack, dictionary, assumptions, theorems} : WM_STATE)
		: WM_STATE = (
	{	interface = interface,
		command_count = command_count,
		stack = ob::stack,
		dictionary = dictionary,
		assumptions = assumptions,
		theorems = theorems }
);
=TEX
=SML
fun €pop_object›
	({interface, stack, command_count, dictionary, assumptions, theorems} : WM_STATE)
		: OBJECT * WM_STATE = (
	case stack of
		h::t =>
		(h,
		{	interface = interface,
			command_count = command_count,
			stack = t,
			dictionary = dictionary,
			assumptions = assumptions,
			theorems = theorems })
	|	[] => fail "open-theory-reader" 122002 []
);
=TEX
=SML
fun €push_num› (x : INTEGER) (st : WM_STATE) : WM_STATE =
	push_object (ONum x) st;
fun €push_name› (x : NAME) (st : WM_STATE) : WM_STATE =
	push_object (OName x) st;
fun €push_list› (x : OBJECT list) (st : WM_STATE) : WM_STATE =
	push_object (OList x) st;
fun €push_type_op› (x : string) (st : WM_STATE) : WM_STATE =
	push_object (OTypeOp x) st;
fun €push_type› (x : TYPE) (st : WM_STATE) : WM_STATE =
	push_object (OType x) st;
fun €push_const› (x : NAME) (st : WM_STATE) : WM_STATE =
	push_object (OConst x) st;
fun €push_var› (x : string * TYPE) (st : WM_STATE) : WM_STATE =
	push_object (OVar x) st;
fun €push_term› (x : TERM) (st : WM_STATE) : WM_STATE =
	push_object (OTerm x) st;
fun €push_thm› (x : THM) (st : WM_STATE) : WM_STATE =
	push_object (OThm x) st;
=TEX
=SML
fun €pop_num› (st : WM_STATE) : INTEGER * WM_STATE = (
	case pop_object st of
		(ONum x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "an integer"]
);
=TEX
=SML
fun €pop_name› (st : WM_STATE) : NAME * WM_STATE = (
	case pop_object st of
		(OName x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "a name"]
);
=TEX
=SML
fun €pop_list› (st : WM_STATE) : OBJECT list * WM_STATE = (
	case pop_object st of
		(OList x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "a list"]
);
=TEX
=SML
fun €pop_type_op› (st : WM_STATE) : string * WM_STATE = (
	case pop_object st of
		(OTypeOp x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "a type operator"]
);
=TEX
=SML
fun €pop_type› (st : WM_STATE) : TYPE * WM_STATE = (
	case pop_object st of
		(OType x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "a type"]
);
=TEX
=SML
fun €pop_const› (st : WM_STATE) : NAME * WM_STATE = (
	case pop_object st of
		(OConst x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "a constant name"]
);
=TEX
=SML
fun €pop_var› (st : WM_STATE) : (string * TYPE) * WM_STATE = (
	case pop_object st of
		(OVar x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "a variable"]
);
=TEX
=SML
fun €pop_term› (st : WM_STATE) : TERM * WM_STATE = (
	case pop_object st of
		(OTerm x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "a term"]
);
=TEX
=SML
fun €pop_thm› (st : WM_STATE) : THM * WM_STATE = (
	case pop_object st of
		(OThm x, st') => (x, st')
	|	_ => fail "open-theory-reader" 122001 [fn _ => "a theorem"]
);
=TEX
=SML
fun €pop_item_list›
	(proj : OBJECT -> 'a) (st : WM_STATE) : 'a list * WM_STATE = (
	let	val (objs, st') = pop_list st;
	in	(map proj objs, st')
	end
);
=TEX
=SML
val €pop_term_list› : WM_STATE -> TERM list * WM_STATE = pop_item_list (fn
		OTerm x => x
	|	_ => fail "open-theory-reader" 122008 []
);
=TEX
=SML
val €pop_name_list› : WM_STATE -> NAME list * WM_STATE = pop_item_list (fn
		OName x => x
	|	_ => fail "open-theory-reader" 122008 []
);
=TEX
=SML
val €pop_type_list› : WM_STATE -> TYPE list * WM_STATE = pop_item_list (fn
		OType x => x
	|	_ => fail "open-theory-reader" 122008 []
);
=TEX
=SML
fun €pop_sequent› (st : WM_STATE) : SEQ * WM_STATE = (
	let 	val (cncl, st') = pop_term st;
		val (asms, st'') = pop_term_list st';
		fun check t = 
			if type_of t = BOOL
			then () else
			term_fail "open-theory-reader" 122009 [t];
		val _ = (check cncl; app check asms);
	in	((asms, cncl), st'')
	end
);
=TEX
=SML
fun €pop_subst_info› (st : WM_STATE) :
	((TYPE * TYPE) list * (TERM * TERM) list) * WM_STATE = (
	let	fun moan () = fail "open-theory-reader" 12011 [];
		fun get_pairs acc [] = rev acc
		|   get_pairs acc (OList [x, y]::more) = get_pairs ((x, y)::acc) more
		|   get_pairs _ _ = moan();
		fun do1_tysubs (OName n, OType ty) =
			(ty, mk_vartype (convert_tyvar_name n))
		|   do1_tysubs _ =
			moan();
		fun do1_varsubs (OVar v, OTerm tm) = (tm, mk_var v)
		|   do1_varsubs _ = moan();
	in	case pop_list st of
			([OList ntys, OList vtms], st') => (
				(((map do1_tysubs o get_pairs []) ntys,
					(map do1_varsubs o get_pairs []) vtms), st')
			)
		|	_ => moan()
	end

);
=TEX
=SML
fun €inc_command_count›
	({interface, command_count, stack, assumptions, theorems, dictionary} : WM_STATE)
		: WM_STATE = (
		{	interface = interface,
			command_count = command_count + 1,
			stack = stack,
			dictionary = dictionary,
			assumptions = assumptions,
			theorems = theorems }
);
=TEX
=SML
fun €set_dictionary› (dict : OBJECT_DICT)
	({interface, command_count, stack, assumptions, theorems, ...} : WM_STATE)
		: WM_STATE = (
		{	interface = interface,
			command_count = command_count,
			stack = stack,
			dictionary = dict,
			assumptions = assumptions,
			theorems = theorems }
);
=TEX
=SML
fun €set_assumptions› (asms: THM NET)
	({interface, command_count, stack, dictionary, theorems, ...} : WM_STATE)
		: WM_STATE = (
		{	interface = interface,
			command_count = command_count,
			stack = stack,
			dictionary = dictionary,
			assumptions = asms,
			theorems = theorems }
);
=TEX
=SML
fun €set_theorems› (thms: THM list)
	({interface, command_count, stack, dictionary, assumptions, ...} : WM_STATE)
		: WM_STATE = (
		{	interface = interface,
			command_count = command_count,
			stack = stack,
			dictionary = dictionary,
			assumptions = assumptions,
			theorems = thms }
);
=TEX
%%%% %%%% %%%% %%%%
\subsubsection{Heuristics for Assumptions}
%%%% %%%% %%%% %%%%

If an assumption is a formula of propositional logic then it better be a tautology.
=SML
fun €is_propositional› (tm : TERM) : bool = (
	let	fun rec2 (tm1, tm2) =
			is_propositional tm1 andalso is_propositional tm2;
		fun rec3 (tm1, tm2, tm3) = 
			rec2(tm1, tm2) andalso is_propositional tm3;
	in	(rec2 o dest_¥) tm handle Fail _ =>
		(rec2 o dest_±) tm handle Fail _ =>
		(rec2 o dest_≤) tm handle Fail _ =>
		(rec2 o dest_§) tm handle Fail _ =>
		(rec3 o dest_if) tm handle Fail _ =>
		is_t tm orelse
		is_f tm orelse
		(is_var tm andalso type_of tm = BOOL)
	end
);
=TEX
=SML
fun €try_taut_rule› (([], conc) : SEQ) : THM OPT = (
	if	(is_propositional o snd o strip_µ) conc
	then	Value (taut_rule conc) handle Fail _ => Nil
	else	Nil
) | try_taut_rule _ = Nil;
=TEX
Rewriting in the proof context for the predicate calculus (which also
does $\beta$-reduction) will prove many trivia.
=SML
fun €try_pred_rewrites› (([], conc) : SEQ) : THM OPT = (
	(Value o §_t_elim o PC_C1 "predicates" rewrite_conv[]) conc
		handle Fail _ => Nil
) | try_pred_rewrites _ = Nil;
=TEX
If an assumption is an instance of an existing assumption, then we
can just instantiate that.
In the following, we assume that the types in the conclusiom of the sequent
and an assumption will be sufficient to determine the correct instantation
of the assumption.
=SML
fun €try_assumptions›
	(st as {assumptions, ...} : WM_STATE)
		(seq as (_, conc): SEQ)
			: THM OPT = (
	let	val thms = net_lookup assumptions conc;
		fun aux (th :: more) = (
			let	val (tym, tmm) = term_match conc (concl th);
				val th' = (asm_inst_term_rule tmm o
					asm_inst_type_rule tym) th;
			in	if	dest_thm th' ~=# seq
				then	Value th'
				else	aux more
			end	handle Fail _ => aux more
		) | aux [] = Nil;
	in	aux thms
	end
);
=TEX
=SML
fun €heuristics› (st : WM_STATE) (seq : SEQ) : THM OPT = (
	let	fun first [] = Nil
		|   first (t::ts) = (
			case t seq of
				res as Value _ => res
			|	Nil => first ts
		);
	in	first [
			try_assumptions st,
			try_taut_rule,
			try_pred_rewrites]
	end
);
=TEX
%%%% %%%% %%%% %%%%
\subsubsection{Command Functions}
%%%% %%%% %%%% %%%%

=TEX
=SML
fun €try_decimal_integer› (cmd : string) (st : WM_STATE) : WM_STATE OPT = (
	Value (push_num (integer_of_string cmd) st) handle Fail _ => Nil	
);
=TEX
The functions local to
=INLINEFT
name_of_quoted_string
=TEX
\ correspond to the four states of a finite state machine that recognises the syntax for OpenTheory names.
=SML
fun €name_of_quoted_string› (chars : string) : NAME OPT = (
	let	fun initial ("\""::more) = in_component [] [] more
		|   initial _ = Nil
		and in_component comps comp [] =
			fail "open-theory-reader" 122004 []
		|   in_component comps comp ("\\"::cs) =
			escaped comps comp cs
		|   in_component comps comp ("\""::cs) =
			final comps comp cs
		|   in_component comps comp ("."::cs) =
			in_component (implode (rev comp)::comps) [] cs
		|   in_component comps comp (c::cs) =
			in_component comps (c::comp) cs
		and escaped comps comp (c::cs) =
			in_component comps (c::comp) cs
		|   escaped comps comp [] =
			fail "open-theory-reader"122006 []
		and final comps comp [] =
			Value (rev comps, implode(rev comp))
		|   final _ _ _ =
			fail "open-theory-reader" 122005 [];
	in	initial (explode chars)
	end
);
=TEX
=SML
fun €try_quoted_string› (chars : string) (st : WM_STATE) : WM_STATE OPT = (
	case name_of_quoted_string chars of
		Value n => Value(push_name n st)
	|	Nil => Nil
);
=TEX
=SML
fun €do_abs_term› (st : WM_STATE) : WM_STATE = (
	let	val (b, st') = pop_term st;
		val (v, st'') = pop_var st';
		val abs = mk_simple_Ã(mk_var v, b);
	in	push_term abs st''
	end
);
=TEX
=SML
fun €do_abs_thm› (st : WM_STATE) : WM_STATE = (
	let	val (thm, st') = pop_thm st;
		val (v, st'') = pop_var st';
		val thm' = simple_Ã_eq_rule (mk_var v) thm;
	in	push_thm thm' st''
	end
);
=TEX
=SML
fun €do_app_term› (st : WM_STATE) : WM_STATE = (
	let	val (x, st') = pop_term st;
		val (f, st'') = pop_term st';
		val app = mk_app(f, x)
	in	push_term app st''
	end
);
=TEX
=SML
fun €do_app_thm› (st : WM_STATE) : WM_STATE = (
	let	val (rand_thm, st') = pop_thm st;
		val (rator_thm, st'') = pop_thm st';
		val thm = mk_app_rule rator_thm rand_thm;
	in	push_thm thm st''
	end
);
=TEX
=SML
fun €do_assume› (st : WM_STATE) : WM_STATE = (
	let	val (phi, st') = pop_term st;
		val thm = asm_rule phi;
	in	push_thm thm st'
	end
);
=TEX
=SML
fun €do_axiom›
	(st as {interface = {declare_axiom, ...}, assumptions, ...} : WM_STATE)
		: WM_STATE = (
	let	val (seq, st') = pop_sequent st;
		val (new, thm) = 
			case heuristics st' seq of
				Value thm => (false, thm)
			|	Nil => (true, declare_axiom seq);
		val assumptions' =
			if new
			then net_enter (concl thm, thm) assumptions
			else assumptions;
	in	(set_assumptions assumptions' o push_thm thm) st'
	end
);
=TEX
=SML
fun €do_beta_conv› (st : WM_STATE) : WM_STATE = (
	let	val (t, st') = pop_term st;
		val thm = simple_¬_conv t;
	in	push_thm thm st'
	end
);
=TEX
=SML
fun €do_cons› (st : WM_STATE) : WM_STATE = (
	let	val (t, st') = pop_list st;
		val (h, st'') = pop_object st';
	in	push_list (h::t) st''
	end
);
=TEX
=SML
fun €do_const› (st : WM_STATE) : WM_STATE = (
	let	val (n, st') = pop_name st;
	in	push_const n st'
	end
);
=TEX
=SML
fun €do_const_term›
	(st as {interface = {const_name, ...}, ...} : WM_STATE)
		: WM_STATE = (
	let	val (ty, st') = pop_type st;
		val (c, st'') = pop_const st';
		val ctm = mk_const(const_name c, ty);
	in	push_term ctm st''
	end
);
=TEX
=SML
fun €do_deduct_antisym› (st : WM_STATE) : WM_STATE = (
	let	val (thm1, st') = pop_thm st;
		val (thm2, st'') = pop_thm st';
		val conc1 = concl thm1;
		val conc2 = concl thm2;
		val thm3 = ¥_intro conc2 thm1;
		val thm4 = ¥_intro conc1 thm2;
		val thm5 = §_intro thm3 thm4;
	in	push_thm thm5 st''
	end
);
=TEX
=SML
fun €do_def› (st as {dictionary, ...} : WM_STATE) : WM_STATE = (
	let	val (k, st') = pop_num st;
		val (x, _) = pop_object st';
		val dictionary' = st_enter k x dictionary;
	in	set_dictionary dictionary' st'
	end
);
=TEX
=SML
fun €do_define_const›
	(st as {interface = {define_const, const_name, ...}, ...} : WM_STATE)
		: WM_STATE = (
	let	val (t, st') = pop_term st;
		val (c, st'') = pop_name st';
		val thm = define_const {name = const_name c, def_rhs = t};
	in	(push_thm thm o push_const c) st''
	end
);
=TEX
=SML
fun €do_define_type_op›
	(st as {interface = {define_type_op, type_name, const_name, ...}, ...}
		: WM_STATE) : WM_STATE = (
	let	val (thm, st') = pop_thm st;
		val (pars, st'') = pop_name_list st';
		val (rep, st''') = pop_name st'';
		val (abs, st'''') = pop_name st''';
		val (tyname, st''''') = pop_name st'''';
		val pp_tyname = type_name tyname;
		val pp_pars = map convert_tyvar_name pars;
		val pp_rep = const_name rep;
		val pp_abs = const_name abs;
		val {abs_rep, rep_abs} =
			define_type_op
				{thm = thm, pars = pp_pars, rep = pp_rep,
					abs = pp_abs, tyname = pp_tyname};
	in	(push_thm rep_abs o push_thm abs_rep o push_const rep
			o push_const abs o push_type_op pp_tyname) st'''''
	end
);
=TEX
=SML
fun €do_eq_mp› (st : WM_STATE) : WM_STATE = (
	let	val (thm1, st') = pop_thm st;
		val (thm2, st'') = pop_thm st';
		val thm3 = §_mp_rule thm2 thm1;
	in	push_thm thm3 st''
	end
);
=TEX
=SML
fun €do_nil› (st : WM_STATE) : WM_STATE = (
	push_list [] st
);
=TEX
=SML
fun €do_op_type› (st : WM_STATE) : WM_STATE = (
	let	val (pars, st') = pop_type_list st;
		val (opn, st'') = pop_type_op st';
		val ty = mk_ctype(opn, pars);
	in	push_type ty st''
	end
);
=TEX
=SML
fun €do_pop› (st : WM_STATE) : WM_STATE = (
	(snd o pop_object) st
);
=TEX
=SML
fun €progress› ((sl, s) : NAME, command_count : int) : unit = (
	if !vm_diagnostics >= 0 andalso !vm_diagnostics <> 3
	then	let	val msg = format_list (fn x => x) (sl @ [s]) ".";
			val cc =
				if !vm_diagnostics = 1
				then "command count: " ^
					string_of_int (command_count + 1) ^ ": "
				else "";
		in	diag_line("progress: " ^ cc ^ msg)
		end
	else ()
);
=TEX
The only kind of pragma currently supported is a debug/progress message.
=SML
fun €do_pragma› (st : WM_STATE) : WM_STATE = (
	let	val (obj, st' as {command_count, ...}) = pop_object st;
	in	(case obj of
			OList [OName([], "debug"), OName([], "progress"),
				OName msg] => progress (msg, command_count)
		|	_ => progress(([], "unsupported pragma"), command_count)
		);
		st'
	end
);
=TEX
=SML
fun €do_ref› (st as {dictionary, ...} : WM_STATE) : WM_STATE = (
	let	val (k, st') = pop_num st;
		val obj = force_value (st_lookup k dictionary)
			handle Fail _ => fail "open-theory-reader" 122010 [];
	in	push_object obj st'
	end
);
=TEX
=SML
fun €do_refl› (st : WM_STATE) : WM_STATE = (
	let	val (t, st') = pop_term st;
		val thm = refl_conv t;
	in	push_thm thm st'
	end
);
=TEX
=SML
fun €do_remove› (st as {dictionary, ...} : WM_STATE) : WM_STATE = (
	let	val (k, st') = pop_num st;
		val obj = force_value (st_lookup k dictionary)
			handle Fail _ => fail "open-theory-reader" 122010 [];
		val dictionary' = st_delete k dictionary;
	in	(set_dictionary dictionary' o push_object obj) st'
	end
);
=TEX
=IGN
=SML
fun €do_subst› (st : WM_STATE) : WM_STATE = (
	let	val (thm1, st') = pop_thm st;
		val ((tysubs, tmsubs), st'') = pop_subst_info st';
		val thm2 = (asm_inst_term_rule tmsubs o
				asm_inst_type_rule tysubs) thm1;
	in	push_thm thm2 st''
	end
);
=TEX
=SML
fun €do_thm› (st as {theorems, ...} : WM_STATE) : WM_STATE = (
	let	val (seq as (_, conc), st') = pop_sequent st;
		val (thm1, st'') = pop_thm st';
		val thm2 = tac_proof(seq, accept_tac thm1);
		val theorems' = thm2 :: theorems;
	in	(set_theorems theorems' o push_thm thm2) st''
	end
);
=TEX
=SML
fun €do_type_op›
	(st as {interface = {type_name, ...}, ...} : WM_STATE)
		: WM_STATE = (
	let	val (n, st') = pop_name st;
		val opn = type_name n;
	in	push_type_op opn st'
	end
);
=TEX
=SML
fun €do_var› (st : WM_STATE) : WM_STATE = (
	let	val (ty, st') = pop_type st;
		val (n, st'') = pop_name st';
		val v = (convert_var_name n, ty);
	in	push_var v st''
	end
);
=SML
fun €do_var_term› (st : WM_STATE) : WM_STATE =  (
	let	val (v, st') = pop_var st;
		val t = mk_var v;
	in	push_term t st'
	end
	
);
=TEX
=SML
fun €do_var_type› (st : WM_STATE) : WM_STATE = (
	let	val (n, st') = pop_name st;
		val ty = (mk_vartype o convert_tyvar_name) n;
	in	push_type ty st'
	end
);
=TEX
%%%% %%%% %%%% %%%%
\subsubsection {Command Interpreter}
%%%% %%%% %%%% %%%%

=SML
fun €illegal_command› (s : string) = fail "open-theory-reader" 122012 [];
=TEX
=SML
val €diag_state› : WM_STATE OPT ref = ref Nil;
=TEX
=SML
val €vm_inference_cmds› : string list =  [
	"absThm",
	"appThm",
	"assume",
	"axiom",
	"betaConv",
	"deductAntisym",
	"defineConst",
	"defineTypeOp",
	"eqMp",
	"refl",
	"subst",
	"thm"];
val €vm_fetch_cmds› : string list =  ["ref", "remove"];

=TEX
=SML
fun €vm_diags› (cmd : string)
	(st1 as {stack = stk1, ...} : WM_STATE)
	(st2 as {stack = stk2, command_count, ...} : WM_STATE) : WM_STATE = (
	let	fun is_progress "pragma"
			(OList (OName ([], "debug") :: OName ([], "progress") :: _) :: _) = true
		|   is_progress _ _ = false;
		val is_thm_command = 
			cmd mem vm_inference_cmds orelse 
				((case stk2 of (OThm _::_) => true | _ => false) andalso
					cmd mem vm_fetch_cmds);
		val show_old_stack = !vm_diagnostics > 5 orelse
			(!vm_diagnostics = 2 andalso is_progress cmd stk1) orelse
			(!vm_diagnostics = 5 andalso is_thm_command);
		val cmd_num =  cmd ^ ": command number: " ^ string_of_int command_count;
	in	(if	!vm_diagnostics = 3
		then	diag_line cmd_num
		else if	!vm_diagnostics > 2 orelse show_old_stack
		then	let	val n = length stk2;
				val tos =
					if n = 0
					then "."
					else ": new top of stack:\n" ^
						PolyML.makestring (hd stk2);
			in
				diag_line (cmd_num ^ ": new stack length: " ^
						string_of_int n ^ tos)
			end
		else	());
		(if show_old_stack
		then	(diag_line ("old stack length: " ^ (string_of_int o length) stk1
						^ ": old stack:");
				PolyML.print stk1; ())
		else	());
		st2
	end
);
=TEX
=SML
fun €do_command› (cmd : string) (st : WM_STATE) : WM_STATE = (
	vm_diags cmd st
	(inc_command_count (case try_decimal_integer cmd st of
		Value st' => st'
	|	Nil =>
	case try_quoted_string cmd st of
		Value st' => st'
	|	Nil =>
	case cmd of
		"absTerm" =>  do_abs_term st
	|	"absThm" =>  do_abs_thm st
	|	"appTerm" =>  do_app_term st
	|	"appThm" =>  do_app_thm st
	|	"assume" =>  do_assume st
	|	"axiom" =>  do_axiom st
	|	"betaConv" =>  do_beta_conv st
	|	"cons" =>  do_cons st
	|	"const" =>  do_const st
	|	"constTerm" =>  do_const_term st
	|	"deductAntisym" =>  do_deduct_antisym st
	|	"def" =>  do_def st
	|	"defineConst" =>  do_define_const st
	|	"defineTypeOp" =>  do_define_type_op st
	|	"eqMp" =>  do_eq_mp st
	|	"nil" =>  do_nil st
	|	"opType" =>  do_op_type st
	|	"pop" =>  do_pop st
	|	"pragma" => do_pragma st
	|	"ref" =>  do_ref st
	|	"refl" =>  do_refl st
	|	"remove" =>  do_remove st
	|	"subst" =>  do_subst st
	|	"thm" =>  do_thm st
	|	"typeOp" =>  do_type_op st
	|	"var" =>  do_var st
	|	"varTerm" =>  do_var_term st
	|	"varType" =>  do_var_type st
	|	_ => (
			if	size cmd = 0 orelse substring(cmd, 0, 1) = "#"
			then	st
			else	illegal_command cmd
	))	handle ex as Fail _ => (
			diag_state := Value st;
			diag_line ("Could not execute \"" ^ cmd ^ "\"");
			raise ex
		))
);
=TEX
=TEX
%%%% %%%% %%%% %%%%
\subsubsection {Generic Virtual Machine}
%%%% %%%% %%%% %%%%

=SML
fun €open_theory_vm› (interface : IMPORT_INTERFACE)
	(read : 's -> (string * 's) OPT) (src : 's) : WM_STATE = (
	let	fun go Nil st = st
		|   go (Value (cmd, more)) st = (
			let	val st' = do_command cmd st;
			in	go (read more) st'
			end
		);
		val _ = diag_state := Nil;
		val final_state = go (read src) (initial_vm_state interface);
		val _ = diag_state := Value final_state;
	in	final_state	
	end
);
=TEX
%%%% %%%% %%%% %%%%
\subsubsection{OpenTheory Interface}
%%%% %%%% %%%% %%%%

We set up a context suitable for the parts of the OpenTheory vocabulary
that are to be supported.
=SML
val _ = open_theory "basic_hol";
val _ = new_theory "open-theory-base";
val _ = new_parent "one";
val _ = new_parent "combin";
val _ = set_merge_pcs ["basic_hol1", "'one"];
=TEX
The OpenTheory interface also includes some special support for {\Product} and HOL4
type definitions.
To export type definitions, we have to presuppose the existence of the constant
{\em TypeDefn} satisfying the following theorem in the target environment.
=SML
val €type_defn_thm› = tac_proof(
	([¨µr∑phi r § ((rep : 'a ≠ 'r) (abs r) = r)Æ,
		¨µa∑ abs((rep : 'a ≠ 'r) a) = aÆ],
			¨∂f:'a ≠ 'r∑ TypeDefn phi fÆ),
	∂_tac¨repÆ THEN rewrite_tac[type_defn_def, one_one_def]
	THEN REPEAT strip_tac
	THEN_LIST [
		LEMMA_T
			¨(abs : 'r ≠ 'a)((rep : 'a ≠ 'r) x1) = abs(rep x2)Æ
				ante_tac
			THEN_LIST [
				POP_ASM_T rewrite_thm_tac,
				POP_ASM_T discard_tac THEN asm_rewrite_tac[]
			],
		∂_tac¨(abs : 'r ≠ 'a) xÆ
			THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]
				THEN STRIP_T rewrite_thm_tac,
		asm_rewrite_tac[]
	]);
=TEX
To import type definitions from HOL4, we need to recognise the definition
it uses for its equivalent of {\em TypeDefn}.
=SML
val €hol4_type_definition_def› =
	(conv_rule (eq_sym_conv THEN_C
		RIGHT_C (rewrite_conv[type_defn_def, one_one_def])) o
				µ_elim ¨TypeDefnÆ) »_axiom;
=TEX
=SML
val €ot_t_def› : THM = t_def;
val €ot_f_def› : THM = f_def;
val €ot_≥_def› : THM = ≥_def;
val €ot_µ_def› : THM = µ_def;
val €ot_±_def› : THM = tac_proof(([],
		¨$± = Ãp q∑(Ãf∑f p q : BOOL) = (Ãf∑f T T)Æ),
	rewrite_tac[] THEN REPEAT_UNTIL is_¥ strip_tac THEN1
		(strip_tac THEN asm_rewrite_tac[]) THEN
			STRIP_T (ante_tac o µ_elim¨Ãa b∑a ± bÆ) THEN rewrite_tac[]);
val €ot_¥_def› : THM = tac_proof(([], ¨$¥ = Ãp q∑p ± q § pÆ), rewrite_tac[]
	THEN taut_tac);
val €ot_∂_def› : THM = tac_proof(([], ¨$∂ = Ãp∑µq∑ (µx: 'a∑p x ¥ q) ¥ qÆ),
	rewrite_tac[] THEN µ_tac THEN
		pure_once_rewrite_tac
			[(conv_rule eq_sym_conv o µ_elim¨x: 'a ≠ BOOLÆ)»_axiom]
				THEN rewrite_tac[] THEN prove_tac[]);
val €ot_≤_def› : THM = ≤_def;
val €ot_∂â1_def› : THM = tac_proof(([],
		¨$∂â1 = ÃP∑ $∂ P ± (µx y:'a∑P x ± P y ¥ x = y)Æ),
	rewrite_tac[∂â1_def] THEN µ_tac THEN 
		pure_once_rewrite_tac [prove_rule[»_axiom] ¨x = Ãt∑x tÆ]
			THEN rewrite_tac[] THEN REPEAT strip_tac THEN_LIST
			[asm_prove_tac[],
			 contr_tac THEN all_asm_fc_tac[] THEN all_var_elim_asm_tac,
			 ∂_tac¨t : 'aÆ THEN contr_tac THEN all_asm_fc_tac[]]);
val €ot_cond_def› : THM = cond_def;
=TEX
=SML
val €ot_bool_defs› : THM list = [
	ot_t_def,
	ot_f_def,
	ot_≥_def,
	ot_µ_def,
	ot_±_def,
	ot_¥_def,
	ot_∂_def,
	ot_≤_def,
	ot_∂â1_def,
	ot_cond_def];
=TEX
=SML
val €ot_one_one_def› : THM = one_one_def;
val €ot_onto_def› : THM = onto_def;
val €ot_o_def› : THM = tac_proof(([], ¨$o = Ãf g x∑f(g x)Æ),
	rewrite_tac[get_spec ¨$oÆ]);
val €ot_comb_i_def› : THM = tac_proof(([], ¨CombI = Ãx∑ xÆ),
	rewrite_tac[get_spec ¨CombIÆ]);
val €ot_comb_k_def› : THM = tac_proof(([], ¨CombK = Ãx y∑ xÆ),
	rewrite_tac[get_spec ¨CombKÆ]);
val €ot_comb_s_def› : THM = tac_proof(([], ¨CombS = Ãf g x∑ f x (g x)Æ),
	rewrite_tac[get_spec ¨CombSÆ]);
val €ot_function_defs› : THM list = [
	ot_one_one_def,
	ot_onto_def,
	ot_o_def,
	ot_comb_i_def,
	ot_comb_k_def,
	ot_comb_s_def];
=TEX
=SML
val €ot_defs› : (string * THM) list = 
	map (fn th => ((fst o dest_const o fst o dest_eq o concl) th, th))
		(	ot_bool_defs @
			ot_function_defs );
=TEX
=SML
fun €get_ot_def› (n : string) (rhs : TERM) : THM = (
	let	val thm1 = lassoc3 ot_defs n;
		val rhs1 = (snd o dest_eq o concl) thm1;
		val (tysubs, _) = term_match rhs rhs1;
	in	inst_type_rule tysubs thm1
	end
);
=TEX
=SML
fun €import_name›
	(interp : (NAME * string) list) ( n as (cxt, base) : NAME )
		: string = (
	lassoc3 interp n
	handle Fail _ => format_list (fn s => s) (cxt @ [base]) "_"
);
=IGN
new_theory "temp";
set_pc "basic_hol1";
=SML
val €ot_»_axiom› : THM =
	(conv_rule (MAP_C ¬_conv) o
		pure_rewrite_rule ot_bool_defs) »_axiom;
val €ot_≈_axiom› : THM =
	(conv_rule (MAP_C ¬_conv) o
		pure_rewrite_rule ot_bool_defs) ≈_axiom;
val €ot_infinity_axiom› : THM  =
	(conv_rule (MAP_C ¬_conv) o
		pure_rewrite_rule (ot_function_defs @ ot_bool_defs)) infinity_axiom;
val €ot_axioms› : THM list = [
	ot_»_axiom,
	ot_≈_axiom,
	ot_infinity_axiom];
=TEX
The following allows for renaming of free variables in the conclusion and it also allows for the
conclusion of the wanted theorem to contain $\beta$-redexes.
=SML
fun €mk_instance› (wanted : TERM) (thm : THM) : THM = (
	let	val thm1 = eq_sym_rule (TRY_C (MAP_C ¬_conv) wanted);
		val wanted1 = (fst o dest_eq o concl) thm1;
		val c = concl thm;
		val (tysubs, tmsubs) = term_match wanted1 c;
		val thm2 = asm_inst_term_rule tmsubs (inst_type_rule tysubs thm);
		val thm3 = §_mp_rule thm1 thm2;
	in	thm3
	end
);
=TEX
=SML
val €all_ot_axioms› = ±_def :: ∂_def :: ∂â1_def :: ot_axioms @ map snd ot_defs;
fun €get_ot_axiom› (tm : TERM) : THM OPT = (
	let	fun aux [] = Nil
		|   aux (thm::more) =
			Value (mk_instance tm thm) handle Fail _ => aux more;
	in	aux all_ot_axioms
	end
);
=TEX
=SML
val €axiom_count› : int ref = ref 0;
fun €axiom_as_axiom› ( (asms, conc) : SEQ ) : THM = (
	case if asms = [] then get_ot_axiom conc else Nil of
		Value thm => thm
	|	Nil => (
		let	val tm = list_mk_¥(asms @ [conc]);
			val _ = axiom_count := !axiom_count + 1;
			val n  = "axiom" ^ string_of_int(!axiom_count);
			val thm1 = new_axiom ([n], tm);
			fun aux [] thm = thm
			|   aux (_::tms) thm = aux tms (undisch_rule thm);
			val thm2 = aux asms thm1;
		in	thm2
		end
	)
);
=TEX
=SML
val €type_defn_count› : int ref = ref 0;
fun €convert_type_defn_thm› (ot_thm : THM) : THM = (
	let	val c = concl ot_thm;
		val (p, t) = dest_app c;
		val x = variant (frees c) (mk_var("x", type_of t));
		val c' = mk_∂(x, mk_app(p, x));
		val pp_thm = simple_∂_intro c' ot_thm;
	in	pp_thm
	end
);
=TEX
=SML
fun €define_hol_type_op› ({thm, pars, rep, abs, tyname} : TYPE_DEFN_INFO)
		: ABS_REP_THMS = (
	let	val _ = type_defn_count := !type_defn_count + 1;
		val thm1 =
			let	val n  = "type_defn" ^ string_of_int(!type_defn_count);
				val pp_thm = convert_type_defn_thm thm;
			in	new_type_defn([n], tyname, pars, pp_thm)
			end;
		val thm2 = simple_¥_match_mp_rule type_lemmas_thm thm1;
		val conc2 = concl thm2;
		val (abs_var, (rep_var, body2)) =
			let val (x, b) = dest_∂ conc2 in (x, dest_∂ b) end;
		val pp_abs_var = mk_var(abs, type_of abs_var);
		val pp_rep_var = mk_var(rep, type_of rep_var);
		val body3 = subst[(pp_abs_var, abs_var), (pp_rep_var, rep_var)] body2; 
		val conc3 = list_mk_∂([pp_abs_var, pp_rep_var], body3);
		val cn = "abs_rep" ^ string_of_int(!type_defn_count);
		val thm3 = §_mp_rule (¡_conv conc3 conc2) thm2;
		val thm4 = new_spec([cn], 2, thm3);
		val abs_rep_thm = (all_µ_elim o ±_left_elim) thm4;
		val rep_abs_thm = (all_µ_elim o ±_right_elim) thm4;
	in	{abs_rep = abs_rep_thm, rep_abs = rep_abs_thm}
	end
);
=TEX
=IGN
=SML
val €const_spec_count› : int ref = ref 0;
fun €define_hol_const› ({name, def_rhs} : CONST_DEFN_INFO) : THM = (
	let	val v = mk_var(name, type_of def_rhs);
		val c = mk_∂(v, mk_eq(v, def_rhs));
		val thm1 = simple_∂_intro c (refl_conv def_rhs);
		val _ = const_spec_count := !const_spec_count + 1;
		val n  = "const_spec" ^ string_of_int(!const_spec_count);
		val thm2 = new_spec([n], 1, thm1);
	in	thm2
	end	handle ex as (Fail _) => (
			get_ot_def name def_rhs
			handle Fail _ => fail "open-theory-reader" 122013 [
				fn _ => name,
				fn _ => string_of_term def_rhs, 
				fn _ => string_of_exn ex]
		)
);
=TEX
=SML
fun €mk_import_interface›
	({type_map, const_map} : NAME_MAPS)
		: IMPORT_INTERFACE = {
	declare_axiom = axiom_as_axiom,
	define_type_op = define_hol_type_op,
	define_const = define_hol_const,
	assumptions = [type_defn_thm, hol4_type_definition_def, ≈_axiom, »_axiom],
	const_name = import_name const_map,
	type_name = import_name type_map 
};
=TEX
=SML
val €line_count› : int ref = ref 0;
fun €read_instream› (strm : instream) = (
	line_count := !line_count + 1;
	case ExtendedIO.input_line strm of 
		"" => (close_in strm; Nil)
	|	s => Value(substring(s, 0, size s - 1), strm)
);
=TEX
=SML
val €name_of_string› : string -> NAME =
	force_value o name_of_quoted_string o (fn s => "\"" ^ s ^ "\"");
=TEX
The following translates the Gilith Open Theory Repo namespace to ProofPower:
=SML
val €gilith_maps› : NAME_MAPS = {
	type_map = map (name_of_string ** (fn x => x)) [
		("bool", "BOOL"), ("->", "≠"), ("ind", "IND")
	],
	const_map = map (name_of_string ** (fn x => x)) [
		("HOL4.TYPE_DEFINITION", "TypeDefn"),
		("select", "≈"),
		("Data.Bool.T", "T"), ("Data.Bool.F", "F"),
		("Data.Bool.~", "≥"),
		("Data.Bool./\\\\", "±"), ("Data.Bool.\\\\/", "≤"),
		("Data.Bool.==>", "¥"),
		("Data.Bool.!", "µ"),
		("Data.Bool.?", "∂"), ("Data.Bool.?!", "∂â1"),
		("Data.Bool.cond", "Cond"),
		("Function.id", "CombI"),
		("Function.K", "CombK"),
		("Function.S", "CombS"),
		("Function.C", "CombC"),
		("Function.W", "CombW")
	]
};
=TEX
%%%% %%%% %%%% %%%%
\subsubsection{User Interface}
%%%% %%%% %%%% %%%%

=SML
fun €open_theory_import› {file : string, parent : string, theory : string} : unit = (
	let	val _ = force_delete_theory theory handle Fail _ => ();
		val _ = open_theory parent;
		val _ = new_theory theory;
		val _ = if "open-theory-base" mem get_ancestors "-" then ()
			else new_parent "open-theory-base";
		val strm = open_in file;
		val _ = line_count := 0;
		val {theorems, ...} = open_theory_vm
			(mk_import_interface gilith_maps)
			read_instream strm
			handle ex as Fail _ => (close_in strm; raise ex);
		val thms = rev theorems;
		val names =
			map (fn n => "thm" ^ string_of_int n)
				(interval 1 (length thms));
		fun save name_thm = (save_thm name_thm; ());
	in	app save (combine names thms)
	end
);
=TEX
%%%% %%%% %%%% %%%%
\subsection{Writer}
%%%% %%%% %%%% %%%%

=TEX
%%%% %%%% %%%% %%%%
\subsubsection{Writer Types}
%%%% %%%% %%%% %%%%

=TEX
=SML
type €EXPORT_INTERFACE› = {
	const_name : string -> NAME,
	type_name : string -> NAME,
	abs_suffix : string,
	rep_suffix : string
};
=SML
type €KEY_DICT› = (OBJECT, int) SEARCH_TREE;
=TEX
%%%% %%%% %%%% %%%%
\subsubsection{Managing Keys}
%%%% %%%% %%%% %%%%

=SML
val €name_order› : NAME ORDER = pair_order (list_order string_order) string_order;
val €seq_order› : SEQ ORDER = pair_order (list_order term_order) term_order;
val €thm_order› : THM ORDER = induced_order (dest_thm, seq_order);
=TEX
=SML
fun €object_class› (OConst _) = 0
|   object_class (OList _) = 1
|   object_class (OName _) = 2
|   object_class (ONum _) = 3
|   object_class (OTerm _) = 4
|   object_class (OThm _) = 5
|   object_class (OType _) = 6
|   object_class (OTypeOp _) = 7
|   object_class (OVar _) = 8;
=TEX
=SML
val rec €object_order› : OBJECT ORDER = (fn o1 => fn o2 =>
	case (o1, o2) of 
		(OConst x, OConst y) => name_order x y
	|	(OList x, OList y) => list_order object_order x y
	|	(OName x, OName y) => name_order x y
	|	(ONum x, ONum y) => integer_order x y
	|	(OTerm x, OTerm y) => term_order x y
	|	(OThm x, OThm y) => thm_order x y
	|	(OType x, OType y) => type_order x y
	|	(OTypeOp x, OTypeOp y) => string_order x y
	|	(OVar x, OVar y) => pair_order string_order type_order x y
	|	(x, y) => induced_order (object_class, int_order) x y
);
=TEX
=SML
type €KM_STATE› = {
	dictionary : KEY_DICT,
	tide_mark : int
};
=TEX
=SML
val km_state : KM_STATE ref = ref {
	dictionary = initial_search_tree object_order,
	tide_mark = ~1
};
=TEX
=SML
fun €reset_km_state› ((): unit) : unit = (
	km_state := {
		dictionary = initial_search_tree object_order,
		tide_mark = ~1
	}
);
=TEX
{\em stored\_key} raises {\em Fail} if the object does not have a stored key.
=SML
fun €stored_key› (x : OBJECT) : int = (
	let	val {dictionary,...} = !km_state;
	in	force_value(st_lookup x dictionary)
	end
);
=TEX
=SML
fun €new_key› (x : OBJECT) : int = (
	let	val {dictionary, tide_mark} = !km_state;
	in	let	val k = tide_mark + 1;
			val d = st_extend x k dictionary;
			val _ = km_state := {dictionary = d, tide_mark = k};
		in	k
		end
	end
);
=TEX
=SML
fun €next_key› (() : unit) : int = (
	let	val {dictionary = d, tide_mark} = !km_state;
	in	let	val k = tide_mark + 1;
			val _ = km_state := {dictionary = d, tide_mark = k};
		in	k
		end
	end
);
=TEX
%%%% %%%% %%%% %%%%
\subsubsection{Building Types and Terms}
%%%% %%%% %%%% %%%%

=SML
fun €export_type_name› (x : string) : NAME = (
	rassoc3 (#type_map gilith_maps) x
	handle Fail _ => ([], x)
);
fun €export_const_name› (x : string) : NAME = (
	rassoc3 (#const_map gilith_maps) x
	handle Fail _ => ([], x)
);
=TEX
=SML
val €export_interface› : EXPORT_INTERFACE ref = ref {
	type_name = export_type_name,
	const_name = export_const_name,
	abs_suffix = "_abs_",
	rep_suffix = "_rep_"
};
=TEX
=SML
val €out_stream› : outstream OPT ref = ref Nil;
=TEX
=SML
fun €say› (x : string) : unit = (
	TextIO.output(
		case !out_stream of Value s => s | Nil => TextIO.stdOut,
		x)
);
=TEX
=SML
fun €open_log› (n : string) : unit = (
	out_stream := Value(open_out n)
);
=TEX
=SML
fun €close_log› (():unit) : unit = (
	(case !out_stream of Value s => close_out s | Nil => ());
	out_stream := Nil
);
=TEX
{\em log\_cmd} outputs the OpenTheory command given by its argument.
=SML
fun €log_cmd› (x : string) : unit = (say x; say "\n");
=TEX
Subsequent functions named {\em log\_xxx} typically output OpenTheory commands
to construct an {\em xxx}.
=SML
val €log_num› : int -> unit = log_cmd o string_of_int;
fun €log_name› ((pfx, sfx) : NAME) :unit = (
	let	fun esc1 "." = "\\."
		|   esc1 "\"" = "\\\""
		|   esc1 "\\" = "\\\\"
		|   esc1 c = c;
		val escape = implode o map esc1 o explode;
	in	log_cmd("\"" ^ format_list escape (pfx @ [sfx]) "." ^ "\"")
	end
);
=TEX
=SML
fun €log_nil› (() : unit) : unit = log_cmd "nil";
fun €log_cons› (() : unit) : unit = log_cmd "cons";
fun €log_list› (_ : 'a -> unit) ([] : 'a list) : unit = log_nil()
|   log_list log_x (x::xs) = (log_x x; log_list log_x xs; log_cons());
fun €log_pair› (log_x : 'a -> unit, log_y : 'b -> unit) ((x, y) : 'a * 'b) : unit = (
	log_x x;
	log_y y;
	log_nil();
	log_cons();
	log_cons()
);
=TEX
=SML
val €logging_progress› : bool ref = ref false;
fun €log_progress› (msg : string) = (
	if !logging_progress
	then	(
		log_list (fn s => log_name([], s)) ["debug", "progress", msg];
		log_cmd "pragma"
	) else ()
);
=TEX
The following two functions raise {\em Fail} if the object does not have a stored key.
{\em try\_stored} generates the commands to push a stored object onto the stack.
=SML
fun €try_stored› (x : OBJECT) = (
	log_num (stored_key x);
	log_cmd "ref"
);
=TEX
{\em check\_stored} just checks whether the object has been stored.
=SML
fun €check_stored› (x : OBJECT) : unit = (
	stored_key x;
	()
);
=TEX
{\em store} assumes that we have already logged the commands to put {\em x} on the top of the stack.
It is possible that the caller will have called some other function that will already have stored
the same object, in which case the call to {\em new\_key} will fail and {\em store}
must return the stored key.
=SML
fun €store› (x : OBJECT) : int = (
	let	val k = new_key x;
	in	log_num k;
		log_cmd "def";
		k
	end	handle Fail _ => stored_key x
);
=TEX
=SML
fun €store_and_drop› (x : OBJECT) : unit = (
	store x;
	log_cmd "pop"
);
=TEX
=SML
fun €log_type_var› (tyv : string)  = log_name([], tyv);
=TEX
=SML
fun €log_type_name› (x : string) = (
	log_name (#type_name(!export_interface) x)
);
=TEX
=SML
fun €log_type_op› (x : string) = (
	let	val obj = OTypeOp x;
	in	try_stored obj handle Fail _ => (
			log_type_name x;
			log_cmd "typeOp";
			store obj; ()
		)
	end
);
=TEX
=SML
fun €log_type› (x : TYPE) = (
	let	val obj = OType x;
	in	try_stored obj handle Fail _ => (
			case dest_simple_type x of
				Vartype v => (
					log_type_var v;
					log_cmd "varType";
					store obj; ()
				)
			|	Ctype (type_op, args) => (
					log_type_op type_op;
					log_list log_type args;
					log_cmd "opType";
					store obj; ()
			)
		)
	end
);
=TEX
=SML
fun €log_var› (x as (v, ty) : string * TYPE) = (
	let	val obj = OVar x;
	in	try_stored obj handle Fail _ => (
			log_name ([], v);
			log_type ty;
			log_cmd "var";
			store obj; ()
		)
	end
);
=TEX
=SML
fun €log_const_name› (x : string) = (
	log_name (#const_name(!export_interface) x)
);
=TEX
=SML
fun €log_const› (x : string) = (
	let	val obj = OConst ([], x);
	in	try_stored obj handle Fail _ => (
			log_const_name x;
			log_cmd "const";
			store obj; ()
		)
	end
);
=TEX
=SML
fun €log_term› (x : TERM) = (
	let	val obj = OTerm x;
	in	try_stored obj handle Fail _ => (
			case dest_simple_term x of
				Var vty => (
					log_var vty;
					log_cmd "varTerm";
					store obj; ()
			) |	Const (c, ty)  => (
					log_const c;
					log_type ty;
					log_cmd "constTerm";
					store obj; ()
			) | 	App (f, a) => (
					log_term f;
					log_term a;
					log_cmd "appTerm";
					store obj; ()
			) |	SimpleÃ (v, b) => (
					log_var(dest_var v);
					log_term b;
					log_cmd "absTerm";
					store obj; ()
			)
		)
	end
);
=TEX
=TEX
%%%% %%%% %%%% %%%%
\subsubsection{Logging Proofs}
%%%% %%%% %%%% %%%%

{\em log\_antecedent} is used to derive an antecedent of an inference rule application.
If the antecedent isn't in the database, it makes it an axiom.
=SML
fun €log_antecedent› (thm : THM) : unit = (
	let	val obj = OThm thm;
	in	try_stored obj handle Fail _ => (
			let	val (asms, conc) = dest_thm thm;
			in	log_list log_term asms;
				log_term conc;
				log_cmd "axiom"
			end;
			store obj; ()
		)
	end
);
=TEX
=SML
val €log_subst_params› : (TYPE * TYPE) list * (TERM * TERM) list -> unit = (
	log_pair (
		log_list (log_pair (log_type_var o dest_vartype, log_type) o swap),
		log_list (log_pair (log_var o dest_var, log_term) o swap))
);
=TEX
We define some derived rules to support logging the {\Product} built-ins.

{\em log\_prove\_asm} maps a stack of the following form:
=GFT
Thm Ñ, A Ù B ::
Thm á Ù A ::
Stack
=TEX
to:
=GFT
Thm á, Ñ Ù B ::
Stack
=TEX
Here and in future derived rules, we give comments indicating what
theorems is expected to be on the stack after execution of selected commands.
The numbers indicate the depth: 1 is deepest, 2 is second deepest, etc.
Here for example, we expect theorem
=INLINEFT
á Ù A
=TEX
\ and
=INLINEFT
Ñ, A Ù B
=TEX
\ to be on the stack on entry. 
=SML
fun €log_prove_asm› (():unit) : unit = (
	let	val k1 = next_key();
		val k2 = k1 + 1;
	in					(* 1. á Ù A *)
						(* 2. Ñ, A Ù B *)
		log_num k1;
		log_cmd "def";
		log_cmd "pop";			(* 1. á Ù A *)
		log_num k2;
		log_cmd "def";
		log_num k1;
		log_cmd "ref";			(* 1. á Ù A *)		
						(* 2. Ñ, A Ù B *)
		log_cmd "deductAntisym";	(* 1. á, Ñ Ù A = B *)
		log_num k2;
		log_cmd "remove";		(* 2. á Ù A *)
		log_cmd "eqMp";			(* 1. á, Ñ Ù B *)
		log_num k1;
		log_cmd "remove";
		log_cmd "pop"
	end
);
=TEX
{\em log\_refl t} pushes the following theorem onto the stack:
=GFT
Ù t = t
=TEX
=SML
fun €log_refl› (t : TERM) : unit = (
	log_term t;
	log_cmd"refl"
);
=TEX
{\em log\_assume t} pushes the following theorem onto the stack:
=GFT
t Ù t
=TEX
=SML
fun €log_assume› (t : TERM) : unit = (
	log_term t;
	log_cmd"assume"
);
=TEX
We define some standard term and type variables for use in pattern theorems:
=SML
val €x_var› : TERM = ¨x : 'aÆ;
val €y_var› : TERM = ¨y : 'aÆ;
val €z_var› : TERM = ¨z : 'aÆ;
val €alpha› : TYPE = î'aÆ;
=TEX
{\em log\_eq\_sym\_thm()} pushes the following theorem onto the stack:
=GFT
x = y Ù y = x
=TEX
(where $x$ and $y$ are actual variables not metavariables.)
=SML
val €log_eq_sym_thm› : unit -> unit = (
	let	val obj = (OThm o undisch_rule o prove_rule[]) ¨x = y ¥ y = xÆ;
		val eq = ¨$=:'a ≠ 'a ≠ BOOLÆ;
		val x_eq_y = ¨x:'a = yÆ;
	in	fn () => try_stored obj handle Fail _ => (
			log_refl eq;		(* 1. Ù ($=) = ($=) *)
			log_assume x_eq_y;	(* 2. x = y Ù x = y *)
			log_cmd "appThm";	(* 1. x = y Ù ($= x) = ($= y) *)
			log_refl x_var;		(* 2. Ù x = x *)
			log_cmd "appThm";	(* 1. x = y Ù x = x § y = x *)
			log_refl x_var;		(* 2. Ù x = x *)
			log_cmd "eqMp";		(* 1. x = y Ù y = x *)
			store obj; ()
		)
	end
);
=TEX
{\em log\_eq\_trans\_thm()} pushes the following theorem onto the stack:
=GFT
x = y, y = z Ù x = z
=TEX
(where $x$, $y$ and $z$ are actual variables not metavariables.)
=TEX
=SML
val €log_eq_trans_thm› : unit -> unit = (
	let	val obj = (OThm o undisch_rule o undisch_rule o prove_rule[])
					¨x = y ¥ y = z ¥ x = zÆ;
		val eq = ¨$=:'a ≠ 'a ≠ BOOLÆ;
		val x_eq_y = ¨x:'a = yÆ;
		val y_eq_z = ¨y:'a = zÆ;
	in	fn () => try_stored obj handle Fail _ => (
			log_refl eq;		(* 1. Ù ($=) = ($=) *)
			log_refl x_var;		(* 2. Ù x = x *)
			log_cmd"appThm";	(* 1. Ù ($= x) = ($= x) *)
			log_assume y_eq_z;	(* 2. y = z Ù y = z *)
			log_cmd"appThm";	(* 1. y = z Ù x = y § x = z *)
			log_assume x_eq_y;	(* 2. x = y Ù x = y *)
			log_cmd"eqMp";		(* 1. x = y, y = z Ù x = z *)
			store obj; ()
		)
	end
);
=TEX
{\em log\_eq\_sym\_thm (a, b)} pushes the following theorem onto the stack:
=GFT
a = b Ù b = a
=TEX
=SML
fun €log_eq_sym› (a : TERM, b : TERM) : unit = (
	let	val ty_subs = [(type_of a, alpha)];
		val tm_subs = [(a, inst [] ty_subs x_var), (b, inst [] ty_subs y_var)];
	in	log_subst_params (ty_subs, tm_subs);
		log_eq_sym_thm ();	(* 1. x = y Ù y = x *)
		log_cmd"subst"		(* 1. a = b Ù b = a *)
	end
);
=TEX
{\em log\_eq\_trans\_thm (a, b. c)} pushes the following theorem onto the stack:
=GFT
a = b, b = c Ù a = c
=TEX
=SML
fun €log_eq_trans› (a : TERM, b : TERM, c : TERM) : unit = (
	let	val ty_subs = [(type_of a, alpha)];
		val tm_subs = [(a, inst [] ty_subs x_var),
				(b, inst [] ty_subs y_var),
				(c, inst [] ty_subs z_var)];
	in	log_subst_params (ty_subs, tm_subs);
		log_eq_trans_thm ();	(* 1. x = y, y = z Ù x = z *)
		log_cmd"subst"		(* 1. a = b, b = c Ù a = c *)
	end
);
=TEX
{\em log\_t\_thm ()} pushes the following theorem onto the stack:
=GFT
Ù T
=TEX
=SML
fun €log_t_thm› (():unit) : unit = (
	let	val obj = OThm t_thm;
		val q = ¨(Ãx:BOOL∑x) = (Ãx∑x)Æ;
	in	try_stored obj handle Fail _ => (
			log_antecedent ot_t_def;
						(* 1. Ù T § (Ãx∑x) = (Ãx∑x) *)
			log_eq_sym(mk_t, q);
			log_prove_asm();	(* 1. Ù  (Ãx∑x) = (Ãx∑x) § T *)
			(log_refl o fst o dest_eq o snd o dest_eq o concl) ot_t_def;
						(* 2. Ù (Ãx∑x) = (Ãx∑x) *)
			log_cmd "eqMp";		(* 1. Ù T *)
			store obj; ()
		)
	end
);
=TEX
We define some standard variables for propositions and propositional functions for use
in pattern theorems:
=SML
val €a_prop› : TERM = ¨A: BOOLÆ;
val €b_prop› : TERM = ¨B: BOOLÆ;
val €c_prop› : TERM = ¨C: BOOLÆ;
val €p_func› :  TERM = ¨P : 'a ≠ BOOLÆ;
=TEX
{\em log\_eq\_t\_intro\_thm ()} pushes the following theorem onto the stack:
=GFT
A Ù A § T
=TEX
=SML
val €log_§_t_intro_thm› : unit -> unit = (
	let	val obj = OThm (undisch_rule (taut_rule ¨A ¥ (A § T)Æ));
	in	fn () => try_stored obj handle Fail _ => (
			log_eq_sym (a_prop, mk_t);
						(* 1. A § T Ù T § A *)
			log_t_thm();		(* 2. Ù T *)
			log_cmd"eqMp";		(* 1. A § T Ù A *)
			log_assume a_prop;	(* 2. A Ù A *)
			log_t_thm();		(* 3. Ù T *)
			log_cmd"deductAntisym";	(* 2. A Ù A § T *)
			log_cmd"deductAntisym";	(* 1. Ù A § (A § T) *)
			log_assume a_prop;	(* 2. A Ù A *)
			log_cmd "eqMp";		(* 1. A Ù A § T *)
			store obj; ()
		)
	end
);
=TEX
{\em log\_eq\_t\_elim\_thm ()} pushes the following theorem onto the stack:
=GFT
A § T Ù A
=TEX
=SML
val €log_§_t_elim_thm› : unit -> unit = (
	let	val obj = OThm (undisch_rule (taut_rule ¨(A § T) ¥ AÆ));
		val a_iff_t = ¨A § TÆ;
	in	fn () => try_stored obj handle Fail _ => (
			log_assume a_prop;	(* 1. A Ù A *)
			log_t_thm();		(* 2. Ù T *)
			log_cmd"deductAntisym";	(* 1. A Ù A § T *)
			log_eq_sym(a_prop, mk_t);
						(* 2. A § T Ù T § A *)
			log_t_thm();		(* 3. Ù T *)
			log_cmd"eqMp";		(* 2. A § T Ù A *)
			log_cmd"deductAntisym";	(* 1. Ù (A § T) § A*)
			log_assume a_iff_t;	(* 2. A § T Ù A § T *)
			log_cmd "eqMp";		(* 1. A § T Ù A *)
			store obj; ()
		)
	end
);
=TEX
=INLINEFT
log_¬_conv ¨(Ãv∑ b) tÆ
=TEX
\ pushes the following theorem onto the stack:
=GFT
Ù (Ãv∑b) t = b[t/v]
=TEX
=SML
fun €log_¬_conv› (tm : TERM) : unit = (
	log_term tm;
	log_cmd "betaConv"	(* 1. Ù (Ãv∑b) t = b[t/v] *)
);
=TEX
=INLINEFT
log_¬_¬_conv ¨(Ãv w∑ b) s tÆ
=TEX
\ pushes the following theorem onto the stack:
=GFT
Ù (Ãv w∑b) s t = b[s/v, t/w]
=TEX
=SML
fun €log_¬_¬_conv› (tm : TERM) : unit = (
	let	val (fs, t) = dest_app tm;
		val (f, s) = dest_app fs;
		val (v, wb) = dest_Ã f;
		val (w, b) = dest_Ã wb;
		val rhs1 = mk_app(subst [(s, v)] wb, t);
		val rhs2 = subst[(s, v), (t, w)] b;
	in	log_¬_conv fs;		(* 1. Ù (Ãv w∑b) s = (Ãw∑b)[s/v] *)
		log_refl t;		(* 2. Ù t = t *)
		log_cmd"appThm";	(* 1. Ù (Ãv w∑b) s t = (Ãw∑b)[s/v] t *)
		log_¬_conv rhs1;	(* 2. Ù (Ãw∑b)[s/v] t = b[s/v,t/w] *)
		log_eq_trans(tm, rhs1, rhs2);
		log_prove_asm();
		log_prove_asm()		(* 1. Ù (Ãv w∑b) s t = [s/v,t/v] *)
	end
);

=TEX
=INLINEFT
log_±_intro_thm ()
=TEX
\ pushes the following theorem onto the stack:
=GFT
A, B Ù A ± B
=TEX
=SML
val €log_±_intro_thm› : unit -> unit = (
	let	val obj = (OThm o undisch_rule o undisch_rule o taut_rule)
				¨A ¥ B ¥ A ± BÆ;
		val f = ¨f : BOOL ≠ BOOL ≠ BOOLÆ;
		val a_±_b = mk_±(a_prop, b_prop);
		val conj_def = ¨Ã p q∑ (Ã f∑ f p q:BOOL) = (Ã f∑ f T T)Æ;
		val conj_def_a_b = list_mk_app(conj_def, [a_prop, b_prop]);
		val q = ¨(Ã f∑ f A B : BOOL) = (Ã f∑ f T T)Æ;
	in	fn () => try_stored obj handle Fail _ => (
			log_antecedent ot_±_def;
						(* 1. Ù $± = (Ãp q∑Q[p/A, q/B]) *)
			log_refl a_prop;
			log_cmd"appThm";
			log_refl b_prop;
			log_cmd"appThm";	(* 1. A ± B = (Ãp q∑Q[p/A, q/B]) A B *)
			log_¬_¬_conv conj_def_a_b;
						(* 2. Ù (Ãp q∑Q[p/A,q/B]) A B § Q *)
			log_eq_trans(a_±_b, conj_def_a_b, q);
			log_prove_asm();
			log_prove_asm();	(* 1. Ù A ± B § Q *)
			log_eq_sym(a_±_b, q);
			log_prove_asm();	(* 1. Ù Q § A ± B *)
			log_var (dest_var f);
			log_refl f;		(* 2. Ù f = f *)
			log_§_t_intro_thm();	(* 3. A Ù A § T *)
			log_cmd"appThm";	(* 2. A Ù f A = f T *)
			log_subst_params ([], [(b_prop, a_prop)]);
			log_§_t_intro_thm();	(* 3. A Ù A § T *)
			log_cmd"subst";		(* 3. B Ù B § T *)
			log_cmd"appThm";	(* 2. A, B Ù f A B § f T T *)
			log_cmd"absThm";	(* 2. A, B Ù Q *)
			log_cmd"eqMp";		(* 2. A, B Ù A ± B *)
			store obj; ()
		)
	end
);

=TEX
=INLINEFT
log_±_left_elim_thm ()
=TEX
\ pushes the following theorem onto the stack:
=GFT
A ± B Ù A
=TEX
=SML
val €log_±_left_elim_thm› : unit -> unit = (
	let	val obj = (OThm o undisch_rule o taut_rule) ¨A ± B ¥ AÆ;
		val a_±_b = mk_±(a_prop, b_prop);
		val conj_def = ¨Ã p q∑ (Ã f∑ f p q:BOOL) = (Ã f∑ f T T)Æ;
		val conj_def_a_b = list_mk_app(conj_def, [a_prop, b_prop]);
		val q = ¨(Ã f∑ f A B : BOOL) = (Ã f∑ f T T)Æ;
		val p1 = ¨Ãp q : BOOL∑ pÆ;
		val (s, t) = dest_eq q;
		val sp1 = mk_app(s, p1);
		val tp1 = mk_app(t, p1);
		val p1ab = list_mk_app(p1, [a_prop, b_prop]);
		val p1tt = list_mk_app(p1, [mk_t, mk_t]);
	in	fn () => try_stored obj handle Fail _ => (
			log_antecedent ot_±_def;
					(* 1. Ù $± = (Ãp q∑Q[p/A, q/B]) *)
			log_refl a_prop;
			log_cmd"appThm";
			log_refl b_prop;
			log_cmd"appThm";
					(* 1. A ± B = (Ãp q∑Q[p/A, q/B]) A B *)
			log_¬_¬_conv conj_def_a_b;
					(* 2. Ù (Ãp q∑Q[p/A,q/B]) A B § Q *)
			log_eq_trans(a_±_b, conj_def_a_b, q);
			log_prove_asm();
			log_prove_asm();
					(* 1. Ù A ± B § Q *)
			log_assume a_±_b;
					(* 2. Ù A ± B Ù A ± B *)
			log_cmd"eqMp";
					(* 1. Ù A ± B Ù Q *)
			log_refl p1;
					(* 2. Ù (Ãp q∑p) = (Ãp q∑p) *)
			log_cmd"appThm";
					(* 1. A ± B  Ù s (Ãp q∑p) = t (Ãp q∑p) *)
			log_¬_conv sp1;
					(* 2. Ù s (Ãp q∑p) = (Ãp q∑p) A B *)
			log_eq_sym(sp1, p1ab);
			log_prove_asm();
					(* 2. Ù (Ãp q∑p) A B = s (Ãp q∑p) *)
			log_eq_trans(p1ab, sp1, tp1);
			log_prove_asm();
			log_prove_asm();
					(* 1. A ± B Ù (Ãp q∑p) A B = t (Ãp q∑ p) *)
			log_¬_conv tp1;
					(* Ù t(Ãp q∑p) = (Ãp q∑p) T T *)
			log_eq_trans(p1ab, tp1, p1tt);
			log_prove_asm();
			log_prove_asm();
					(* 1. A ± B Ù (Ãp q∑p) A B = (Ãp q∑p) T T *)
			log_¬_¬_conv p1tt;
					(* 2. Ù (Ãp q∑p) T T = T *)
			log_eq_trans(p1ab, p1tt, mk_t);
			log_prove_asm();
			log_prove_asm();
					(* 1. A ± B Ù (Ãp q∑p) A B = T *)
			log_¬_¬_conv p1ab;
					(* 2. Ù (Ãp q∑p) A B = A *)
			log_eq_sym(p1ab, a_prop);
			log_prove_asm();
					(* 2. Ù A = (Ãp q∑p) A B *)
			log_eq_trans(a_prop, p1ab, mk_t);
			log_prove_asm();
			log_prove_asm();
					(* 1. A ± B Ù A § T *)
			log_§_t_elim_thm();
					(* 2. A § T Ù A *)
			log_prove_asm();
					(* 1. A ± B Ù A *)
			store obj; ()
		)
	end
);

=TEX
=INLINEFT
log_±_right_elim_thm ()
=TEX
\ pushes the following theorem onto the stack:
=GFT
A ± B Ù B
=TEX
=SML
val €log_±_right_elim_thm› : unit -> unit = (
	let	val obj = (OThm o undisch_rule o taut_rule) ¨A ± B ¥ BÆ;
		val a_±_b = mk_±(a_prop, b_prop);
		val conj_def = ¨Ã p q∑ (Ã f∑ f p q:BOOL) = (Ã f∑ f T T)Æ;
		val conj_def_a_b = list_mk_app(conj_def, [a_prop, b_prop]);
		val q = ¨(Ã f∑ f A B : BOOL) = (Ã f∑ f T T)Æ;
		val p2 = ¨Ãp q : BOOL∑ qÆ;
		val (s, t) = dest_eq q;
		val sp2 = mk_app(s, p2);
		val tp2 = mk_app(t, p2);
		val p2ab = list_mk_app(p2, [a_prop, b_prop]);
		val p2tt = list_mk_app(p2, [mk_t, mk_t]);
	in	fn () => try_stored obj handle Fail _ => (
			log_antecedent ot_±_def;
					(* 1. Ù $± = (Ãp q∑Q[p/A, q/B]) *)
			log_refl a_prop;
			log_cmd"appThm";
			log_refl b_prop;
			log_cmd"appThm";
					(* 1. A ± B = (Ãp q∑Q[p/A, q/B]) A B *)
			log_¬_¬_conv conj_def_a_b;
						(* 2. Ù (Ãp q∑Q[p/A,q/B]) A B § Q *)
			log_eq_trans(a_±_b, conj_def_a_b, q);
			log_prove_asm();
			log_prove_asm();
					(* 1. Ù A ± B § Q *)
			log_assume a_±_b;
					(* 2. Ù A ± B Ù A ± B *)
			log_cmd"eqMp";
					(* 1. Ù A ± B Ù Q *)
			log_refl p2;
					(* 2. Ù (Ãp q∑q) = (Ãp q∑q) *)
			log_cmd"appThm";
					(* 1. A ± B  Ù s (Ãp q∑q) = t (Ãp q∑p) *)
			log_¬_conv sp2;
					(* 2. Ù s (Ãp q∑q) = (Ãp q∑q) A B *)
			log_eq_sym(sp2, p2ab);
			log_prove_asm();
					(* 2. Ù (Ãp q∑q) A B = s (Ãp q∑q) *)
			log_eq_trans(p2ab, sp2, tp2);
			log_prove_asm();
			log_prove_asm();
					(* 1. A ± B Ù (Ãp q∑q) A B = t (Ãp q∑ q) *)
			log_¬_conv tp2;
					(* Ù t(Ãp q∑q) = (Ãp q∑q) T T *)
			log_eq_trans(p2ab, tp2, p2tt);
			log_prove_asm();
			log_prove_asm();
					(* 1. A ± B Ù (Ãp q∑q) A B = (Ãp q∑p) T T *)
			log_¬_¬_conv p2tt;
					(* 2. Ù (Ãp q∑q) T T = T *)
			log_eq_trans(p2ab, p2tt, mk_t);
			log_prove_asm();
			log_prove_asm();
					(* 1. A ± B Ù (Ãp q∑q) A B = T *)
			log_¬_¬_conv p2ab;
					(* 2. Ù (Ãp q∑q) A B = B *)
			log_eq_sym(p2ab, b_prop);
			log_prove_asm();
					(* 2. Ù B = (Ãp q∑q) A B *)
			log_eq_trans(b_prop, p2ab, mk_t);
			log_prove_asm();
			log_prove_asm();
					(* 1. A ± B Ù B § T *)
			log_subst_params ([], [(b_prop, a_prop)]);
			log_§_t_elim_thm();
					(* 2. A § T Ù A *)
			log_cmd"subst";
					(* 2. B § T Ù B *)
			log_prove_asm();
					(* 1. A ± B Ù B *)
			store obj; ()
		)
	end
);

=TEX
=INLINEFT
log_¥_intro_lemma ()
=TEX
\ pushes the following theorem onto the stack:
=GFT
A ± B § A Ù A ¥ B
=TEX
=SML
val €log_¥_intro_lemma› : unit -> unit = (
	let	val obj = (OThm o undisch_rule o prove_rule[ot_¥_def])
			¨(A § A ± B) ¥ (A ¥ B)Æ;
		val a_¥_b = mk_¥(a_prop, b_prop);
		val imp_def = ¨Ã p q∑ p ± q § pÆ;
		val imp_def_a_b = list_mk_app(imp_def, [a_prop, b_prop]);
		val r =  ¨A ± B § AÆ;
	in	fn () => try_stored obj handle Fail _ => (
			log_antecedent ot_¥_def;
				(* 1. Ù $¥ = (Ãp q∑p ± q § p) *)
			log_refl a_prop;
			log_cmd"appThm";
			log_refl b_prop;
			log_cmd"appThm";
				(* 1. (A ¥ B) = (Ãp q∑p ± q § p) A B *)
			log_¬_¬_conv imp_def_a_b;
				(* 2. Ù (Ãp q∑p ± q § p) A B § (A ± B § A) *)
			log_eq_trans(a_¥_b, imp_def_a_b, r);
			log_prove_asm();
			log_prove_asm();
				(* 1. Ù (A ¥ B) § (A ± B ¥ A) *)
			log_eq_sym(a_¥_b, r);
			log_prove_asm();
				(* 1. Ù (A ± B ¥ A) § (A ¥ B) *)
			log_assume r;	
				(* 2. A ± B § A Ù A ± B § A *)
			log_cmd"eqMp";
				(* 1. A ± B § A Ù A ¥ B *)
			store obj; ()
		)
	end
);

=TEX
=INLINEFT
log_¥_elim_them ()
=TEX
\ pushes the following theorem onto the stack:
=GFT
A, A ¥ B Ù B
=TEX
=SML
val €log_¥_elim_thm› : unit -> unit = (
	let	val obj = (OThm o undisch_rule o undisch_rule o taut_rule)
					¨A ¥ (A ¥ B) ¥ AÆ;
		val a_¥_b = mk_¥(a_prop, b_prop);
		val imp_def = ¨Ã p q∑ p ± q § pÆ;
		val imp_def_a_b = list_mk_app(imp_def, [a_prop, b_prop]);
		val r =  ¨A ± B § AÆ;
	in	fn () => try_stored obj handle Fail _ => (
			log_antecedent ot_¥_def;
				(* 1. Ù $¥ = (Ãp q∑p ± q § p) *)
			log_refl a_prop;
			log_cmd"appThm";
			log_refl b_prop;
			log_cmd"appThm";
				(* 1. (A ¥ B) = (Ãp q∑p ± q § p) A B *)
			log_¬_¬_conv imp_def_a_b;
				(* 2. Ù (Ãp q∑p ± q § p) A B § (A ± B § A) *)
			log_eq_trans(a_¥_b, imp_def_a_b, r);
			log_prove_asm();
			log_prove_asm();
				(* 1. Ù (A ¥ B) § (A ± B ¥ A) *)
			log_assume a_¥_b;
				(* 2. A ¥ B Ù A ¥ B *)
			log_cmd"eqMp";	
				(* 1. A ¥ B Ù A ± B = A *)
			log_eq_sym(mk_±(a_prop, b_prop), a_prop);
			log_prove_asm();
				(* 1. A ¥ B Ù A = A ± B *)
			log_assume a_prop;
				(* 2. A Ù A *)
			log_cmd"eqMp";	
				(* 1. A, A ¥ B Ù A ± B *)
			log_±_right_elim_thm();
				(* 2. A ± B Ù B *)
			log_prove_asm();
				(* 1. A, A ¥ B Ù B *)
			store obj; ()
		)
	end
);

=TEX
=INLINEFT
log_µ_elim_them ()
=TEX
\ pushes the following theorem onto the stack:
=GFT
$µ P Ù P x
=TEX
=SML
val €log_µ_elim_thm› : unit -> unit = (
	let	val obj = (OThm o rewrite_rule[] o app_arg_rule ¨x:'aÆ o 
				conv_rule ¬_conv o pure_rewrite_rule[µ_def] o asm_rule)
					¨$µ (P : 'a ≠ BOOL)Æ;
		val µ_p = ¨$µ (P : 'a ≠ BOOL)Æ;;
		val all_def = ¨Ã P∑ P = (Ã x : 'a∑ T)Æ;
		val all_def_p = mk_app(all_def, p_func);
		val px = mk_app(p_func, x_var);
		val t = ¨(Ãx:'a∑ T) xÆ;
	in	fn () => try_stored obj handle Fail _ => (
			log_¬_conv all_def_p;
				(* 1. Ù (Ã P∑ P = (Ã x∑ T)) P § (P = (Ãx∑ T)) *)
			log_antecedent ot_µ_def;
				(* 2. Ù $µ = (Ã P∑ P = (Ã x∑ T)) *)
			log_refl p_func;
				(* 3. Ù P = P *)
			log_cmd"appThm";
				(* 2. $µ P § (Ã P∑ P = (Ã x∑ T)) P *)
			log_assume µ_p;
				(* 3. $µ P Ù $µ P *)
			log_cmd"eqMp";
				(* 2. $µ P Ù (Ã P∑ P = (Ã x∑ T)) P *)
			log_cmd"eqMp";	
				(* 1. $µ P Ù P = (Ãx∑ T) *)
			log_refl x_var;	
				(* 2. Ù x = x *)
			log_cmd"appThm";
				(* 1. $µ P Ù P x § (Ãx∑ T) x *)
			log_¬_conv t;
				(* 2. Ù (Ãx∑ T) x § T *)
			log_eq_trans(px, t, mk_t);
			log_prove_asm();
			log_prove_asm();
				(* 1. $µ P Ù P x § T *)
			log_subst_params([], [(px, a_prop)]);
			log_§_t_elim_thm();
			log_cmd"subst";
				(* 2. P x § T Ù P x *)
			log_prove_asm();
				(* 1. $µ P Ù P x *)
			store obj; ()
		)
	end
);

=TEX
=INLINEFT
log_µ_elim (¨tÆ, ¨AÆ)
=TEX
\ maps a stack of the following form:
=GFT
Thm á Ù µx∑A ::
Stack
=TEX
to:
=GFT
Thm á Ù A[t/x] ::
Stack
=TEX
It returns
=INLINEFT
A[t/x]
=TEX
.
=SML
fun €log_µ_elim› (t : TERM, q : TERM) : TERM = (
	let	val Ã = (snd o dest_app) q;
		val tysubs = [(type_of t, alpha)];
		val varsubs = [(t, inst [] tysubs x_var), (Ã, inst [] tysubs p_func)];
		val app = mk_app(Ã, t);
		val (v, b) = dest_simple_Ã Ã;
		val r = subst[(t, v)] b;
	in				(* 1. á Ù µx∑A *)
		log_term app;
		log_cmd"betaConv";	(* 2. Ù (Ãx∑A) t § A[t/x]  *)
		log_subst_params (tysubs, varsubs);
		log_µ_elim_thm();
		log_cmd"subst";		(* 3. µx∑A Ù (Ãx∑A) t *)
		log_cmd"eqMp";		(* 2. µx∑A Ù A[t/x] *)
		log_prove_asm();	(* 1. á Ù A[t/x] *)
		r
	end
);

=TEX
=INLINEFT
log_µ_intro_lemma ()
=TEX
\ pushes the following theorem onto the stack:
=GFT
A § (ÃP∑ P = (Ãx∑ T))(Ãx∑ T) Ù A
=TEX
=SML
val €log_µ_intro_lemma› : unit -> unit = (
	let	val obj = (OThm o undisch_rule o §_t_elim o rewrite_conv[])
				¨(A § (ÃP∑ P = (Ãx:'a∑ T))(Ãx∑ T)) ¥ AÆ;
		val r = ¨(ÃP∑ P = (Ãx:'a∑ T))(Ãx∑ T)Æ;;
		val a_§_r = ¨A § (ÃP∑ P = (Ãx:'a∑ T))(Ãx∑ T)Æ;
		val Ã_eq_Ã = ¨(Ãx:'a∑T) = (Ãx∑T)Æ;
		val Ã = ¨(Ãx:'a∑T)Æ;
	in	fn () => try_stored obj handle Fail _ => (
			log_assume a_§_r;	
(* 1. (A § (ÃP∑ P = (Ãx∑ T))(Ãx∑ T)) Ù (A § (ÃP∑ P = (Ãx∑ T))(Ãx∑ T)) *)
			log_¬_conv r;
			log_eq_trans(a_prop, r, Ã_eq_Ã);
			log_prove_asm();
			log_prove_asm();	
(* 1. (A § (ÃP∑ P = (Ãx∑ T))(Ãx∑ T)) Ù A § ((Ãx∑T) = (Ãx∑T)) *)
			log_eq_sym(a_prop, Ã_eq_Ã);
			log_prove_asm();
(* 1. (A § (ÃP∑ P = (Ãx∑ T))(Ãx∑ T)) Ù ((Ãx∑T) = (Ãx∑T)) § A *)
			log_refl Ã;
			log_cmd "eqMp";
(* 1. (A § (ÃP∑ P = (Ãx∑ T))(Ãx∑ T)) Ù A *)
			store obj; ()
		)
	end
);
=TEX
The following function supports both the rule
=INLINEFT
simple_µ_intro
=TEX
\ and
=INLINEFT
new_type_defn
=TEX
, which has to take the universal closure of
the defining properties of the abstraction
and representation functions introduced by
=INLINEFT
defineType
=TEX
.
The parameters are a term giving the bound variable,
a term giving the conclusion of the input theorem and a function
to generate the commands to stack the input theorem.
=SML
fun €log_µ_intro› (v : TERM, cnc : TERM, thm_cmds : unit -> unit)
		: unit = (
	let	val x = dest_var v;
		val ty = snd x;
		val µ = mk_simple_µ(v, cnc);
	in	log_subst_params ([(ty, alpha)], []);
		log_antecedent ot_µ_def;
		log_cmd"subst";
				(* 1. Ù $µ = (Ã P∑ P = (Ã x∑T)) *)
		log_var x;
		thm_cmds();
				(* 2. á Ù A *)
		log_subst_params([], [(cnc, a_prop)]);
		log_§_t_intro_thm();
		log_cmd"subst";
		log_prove_asm();
				(* 2. á Ù A § T *)
		log_cmd"absThm";
				(* 2. á Ù (Ãx∑A) § (Ãx∑T) *)
		log_cmd"appThm";
				(* 1. á Ù (µx∑A) § (ÃP∑ P = (Ã x∑T))(Ãx∑T) *)
		log_subst_params([(ty, alpha)], [(µ, a_prop)]);
		log_µ_intro_lemma();
		log_cmd"subst";
				(* 2. (µx∑A) § (ÃP∑P = (Ãx∑T))(Ãx∑T) Ù µx∑A *)
		log_prove_asm()
	end
);
=TEX
Now the actual {\Product} built-ins
=SML
fun €log_subst_rule›
	((thm_var_list, template, ithm, res)
		: (THM * TERM) list * TERM * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_antecedent res;
			store_and_drop obj; ()
		)
	end
);
=TEX
=IGN
=SML
fun €log_simple_Ã_eq_rule›
	((absvar, thrm, res) : TERM * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			(log_var o dest_var) absvar;
			log_antecedent res;
			log_cmd "absThm";
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_inst_type_rule›
	((talist, thrm, res) : (TYPE * TYPE) list * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_subst_params (talist, []);
			log_antecedent thrm;
			log_cmd "subst";
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_¥_intro›
	((asm, thrm, res) : TERM * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			let	val a = asm;
				val b = concl thrm;
			in
				log_antecedent thrm;	(* 1. á, A Ù B *)
				log_subst_params ([], [(a, a_prop), (b, b_prop)]);
				log_±_intro_thm();
				log_cmd"subst";		(* 2. A, B Ù A ± B *)
				log_prove_asm();	(* 1. á, A Ù A ± B *)
				log_subst_params ([], [(a, a_prop), (b, b_prop)]);
				log_±_left_elim_thm();
				log_cmd"subst";		(* 2. A ± B Ù A *)
				log_cmd"deductAntisym";	(* 1. á Ù A ± B § A *)
				log_subst_params ([], [(a, a_prop), (b, b_prop)]);
				log_¥_intro_lemma();
				log_cmd"subst";		(* 2. A ± B § A Ù A ¥ B *)
				log_prove_asm();	(* 1. á Ù A ¥ B *)
				store_and_drop obj; ()
			end
		)
	end
);
=TEX
=SML
fun €log_¥_elim›
	((thrm1, thrm2, res) : THM * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			let	val (a, b) = (dest_¥ o concl) thrm1;
			in	log_antecedent thrm1;
				log_antecedent thrm2;
				log_subst_params ([], [(a, a_prop), (b, b_prop)]);
				log_¥_elim_thm();
				log_cmd"subst";
				log_prove_asm();
				log_prove_asm();
				store_and_drop obj; ()
			end
		)
	end
);
=TEX
=SML
fun €log_asm_rule›
	((tm, res) : TERM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_term tm;
			log_cmd "assume";
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_refl_conv›
	((tm, res) : TERM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_term tm;
			log_cmd "refl";
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_simple_¬_conv›
	((tm, res) : TERM * THM) : unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_term tm;
			log_cmd "betaConv";
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_suc_conv›
	((tm, res) : TERM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_antecedent res;
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_string_conv›
	((tm, res) : TERM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_antecedent res;
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_char_conv›
	((tm, res) : TERM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_antecedent res;
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_eq_sym_rule›
	((thrm, res) : THM * THM)
		: unit = (
	let	val obj = OThm res;
		val (a, b) = (dest_eq o concl) thrm;
	in	check_stored obj handle Fail _ => (
			log_antecedent thrm;
			log_eq_sym(a, b);
			log_prove_asm();
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_list_simple_µ_elim›
	((tml, thrm, res) : TERM list * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			let	fun aux (t::ts) vs q = (
					let	val q' = log_µ_elim (hd vs, q);
						val vs' = tl vs;
					in	aux ts vs' q'
					end
				)  | aux [] _ _ = (
					log_cmd"subst"
				);
				fun mk_v(i, ty) = mk_var("v" ^ string_of_int i, ty);
				val vs = map mk_v
					(combine (interval 1 (length tml))
						(map type_of tml));
			in	log_subst_params([], combine tml vs);
				log_antecedent thrm;
				aux tml vs (concl thrm);
				store_and_drop obj; ()
			end
		)
	end
);

=TEX
=SML
fun €log_eq_trans_rule›
	((thrm1, thrm2, res) : THM * THM * THM)
		: unit = (
	let	val obj = OThm res;
		val (a, b) = (dest_eq o concl) thrm1;
		val (_, c) = (dest_eq o concl) thrm2;
	in	check_stored obj handle Fail _ => (
			log_antecedent thrm1;
			log_antecedent thrm2;
			log_eq_trans(a, b, c);
			log_prove_asm();
			log_prove_asm();
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_mk_app_rule›
	((thrm1, thrm2, res) : THM * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_antecedent thrm1;
			log_antecedent thrm2;
			log_cmd "appThm";
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_§_mp_rule›
	((thrm1, thrm2, res) : THM * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_antecedent thrm1;
			log_antecedent thrm2;
			log_cmd "eqMp";
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_simple_µ_intro›
	((tm, thrm, res) : TERM * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_µ_intro (tm, concl thrm, fn () => log_antecedent thrm);
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_inst_term_rule›
	((tvl, thrm, res) : (TERM * TERM) list * THM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_subst_params ([], tvl);
			log_antecedent res;
			log_cmd "subst";
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
fun €log_plus_conv›
	((tm, res) : TERM * THM)
		: unit = (
	let	val obj = OThm res;
	in	check_stored obj handle Fail _ => (
			log_antecedent res;
			store_and_drop obj; ()
		)
	end
);
=TEX
=SML
val €kernel_inference_name› : KERNEL_INFERENCE -> string = (fn
		KISubstRule _ => "KISubstRule"
	|	KISimpleÃEqRule _ => "KISimpleÃEqRule"
	|	KIInstTypeRule _ => "KIInstTypeRule"
	|	KI¥Intro _ => "KI¥Intro"
	|	KI¥Elim _ => "KI¥Elim"
	|	KIAsmRule _ => "KIAsmRule"
	|	KIReflConv _ => "KIReflConv"
	|	KISimple¬Conv _ => "KISimple¬Conv"
	|	KISucConv _ => "KISucConv"
	|	KIStringConv _ => "KIStringConv"
	|	KICharConv _ => "KICharConv"
	|	KIEqSymRule _ => "KIEqSymRule"
	|	KIListSimpleµElim _ => "KIListSimpleµElim"
	|	KIEqTransRule _ => "KIEqTransRule"
	|	KIMkAppRule _ => "KIMkAppRule"
	|	KI§MPRule _ => "KI§MPRule"
	|	KISimpleµIntro _ => "KISimpleµIntro"
	|	KIInstTermRule _ => "KIInstTermRule"
	|	KIPlusConv _ => "KIPlusConv"
);
=TEX
=SML
val €log_inference_failures› : KERNEL_INFERENCE list ref = ref [];
fun €inference_checks› (ki : KERNEL_INFERENCE) (f : 'a -> unit) (x : 'a) : unit = (
	(log_progress o kernel_inference_name) ki;
	f x handle ex as Fail _ => (
		log_inference_failures := ki :: !log_inference_failures;
		diag_line "*** Logging function failed:";
		(diag_line o string_of_exn) ex;
		raise ex
	)
);
=TEX
=SML
fun €log_inference›(ki as KISubstRule par) =
	inference_checks ki log_subst_rule par
|   log_inference(ki as KISimpleÃEqRule par) =
	inference_checks ki log_simple_Ã_eq_rule par
|   log_inference(ki as KIInstTypeRule par) =
	inference_checks ki log_inst_type_rule par
|   log_inference(ki as KI¥Intro par) =
	inference_checks ki log_¥_intro par
|   log_inference(ki as KI¥Elim par) =
	inference_checks ki log_¥_elim par
|   log_inference(ki as KIAsmRule par) =
	inference_checks ki log_asm_rule par
|   log_inference(ki as KIReflConv par) =
	inference_checks ki log_refl_conv par
|   log_inference(ki as KISimple¬Conv par) =
	inference_checks ki log_simple_¬_conv par
|   log_inference(ki as KISucConv par) =
	inference_checks ki log_suc_conv par
|   log_inference(ki as KIStringConv par) =
	inference_checks ki log_string_conv par
|   log_inference(ki as KICharConv par) =
	inference_checks ki log_char_conv par
|   log_inference(ki as KIEqSymRule par) =
	inference_checks ki log_eq_sym_rule par
|   log_inference(ki as KIListSimpleµElim par) =
	inference_checks ki log_list_simple_µ_elim par
|   log_inference(ki as KIEqTransRule par) =
	inference_checks ki log_eq_trans_rule par
|   log_inference(ki as KIMkAppRule par) =
	inference_checks ki log_mk_app_rule par
|   log_inference(ki as KI§MPRule par) =
	inference_checks ki log_§_mp_rule par
|   log_inference(ki as KISimpleµIntro par) =
	inference_checks ki log_simple_µ_intro par
|   log_inference(ki as KIInstTermRule par) =
	inference_checks ki log_inst_term_rule par
|   log_inference(ki as KIPlusConv par) =
	inference_checks ki log_plus_conv par;
=TEX
To log a theorem, {\em log\_antecedent} will generate the commands to prove
and stack the theorem.
=SML
fun €log_thm› (thm : THM) : unit = (
	let	val (asms, conc) = dest_thm thm;
	in	log_antecedent thm;
		log_list log_term asms;
		log_term conc;
		log_cmd "thm";
		()
	end	
);
=TEX
=SML
fun €log_new_axiom› (tm : TERM) : unit = (
	log_list log_term [];
	log_term tm;
	log_cmd "axiom"
);
=TEX
For the following, note that {\em defineConst} stacks two things:
the constant and its defining theorem and that removes pushes
the object it is removing from the dictionary onto the stack.
=SML
fun €log_simple_new_defn› (n : string, t : TERM) : unit = (
	let	val k = next_key();
	in	log_const_name n;
		log_term t;
		log_cmd "defineConst";
			(* 1. OConst c *)
			(* 2. Ù c = t *)
		log_num k;
		log_cmd "def";
		log_cmd "pop";
		log_cmd "pop";
		log_num k;
		log_cmd "remove"
	end
);
=TEX
Note that we must ensure
that each constant is defined before proving theorems that contain it
(systems other than {\Product} may require this).
=SML
fun €log_new_spec› (ndefs : int, thm : THM) : unit = (
	let	fun aux2 0 thm0 = thm0
		|   aux2 i thm0 = (
			let	val (n, ty) = (dest_var o fst o dest_∂ o concl) thm0;
				val c = mk_const(n, ty);
				val t = (mk_≈ o dest_∂ o concl) thm0;
				val _ = log_simple_new_defn (n, t);
				val thm1 = ∂_≈_rule thm0;
				val thm2 = (eq_sym_rule o asm_rule o mk_eq) (c, t);
				val thm3 = pure_once_rewrite_rule [thm2] thm1;
						(* c = (≈c∑p), ... Ù p[c/v] *)
			in	aux2 (i-1) thm3
			end
		);
		fun aux3 0 = ()
		|   aux3 i = (
			log_prove_asm();
			aux3 (i-1)
		);
	in	log_antecedent (aux2 ndefs thm);
				(* 1. Ù c1 = ≈c∑p1 *)
				(* ... *)
				(* (ndefs+1). c1 = ≈c∑p1, ... Ù p[c1/v1, ...] *)
		aux3 ndefs
				(* 1. Ù p[c1/v1, ...] *)
	end
);
=TEX
In the following, the prefix ``i'' stands for ``instance''.
=SML
local
	val [ra_eq, ar_eq] = (map (snd o dest_µ) o fst o dest_thm) type_defn_thm;
	val phi = (fst o dest_app o fst o dest_eq) ra_eq;
	val abs = (fst o dest_app o fst o dest_eq) ar_eq;
	val rep = (fst o dest_app o snd o dest_app o fst o dest_eq) ar_eq;
	val [abs_ty, rep_ty] = (snd o dest_ctype o type_of) rep;
in
fun €log_new_type_defn›
	(name : string, typars : string list, thm : THM)
		: unit = (
	let	val thm1 = ∂_≈_rule thm;
		val i_abs_name = name ^ #abs_suffix(!export_interface);
		val i_rep_name = name ^ #rep_suffix(!export_interface);
		val i_abs_ty = mk_ctype(name, map mk_vartype typars);
		val i_rep_ty = (type_of o fst o dest_∂ o concl) thm;
		val ty_subs = [(i_abs_ty, abs_ty), (i_rep_ty, rep_ty)];
		val i_abs = mk_const(i_abs_name, mk_≠_type(i_rep_ty, i_abs_ty));
		val i_rep = mk_const(i_rep_name, mk_≠_type(i_abs_ty, i_rep_ty));
		val i_phi = (fst o dest_app o concl) thm1;
		val tm_subs = [(i_abs, inst [] ty_subs abs),
			(i_rep, inst [] ty_subs rep),
			(i_phi, inst [] ty_subs phi)];
		val a = mk_var("a", i_abs_ty);
		val r = mk_var("r", i_rep_ty);
		val i_ra_eq = (subst tm_subs o inst [] ty_subs) ra_eq;
		val i_ar_eq = (subst tm_subs o inst [] ty_subs) ar_eq;
		val k_ra = next_key();
		val k_ar = next_key();
		fun log_fetch k = (log_num k; log_cmd "ref");
	in	log_type_name name;
		log_const_name i_abs_name;
		log_const_name i_rep_name;
		log_list log_type_var typars;
		log_antecedent thm1;
		log_cmd "defineTypeOp";
				(* 1. OTypeOp name *)
				(* 2. OConst i_abs *)
				(* 3. OConst i_rep *)
				(* 4. Ù i_abs(i_rep a) = a *)
				(* 5. Ù ∆ r § i_rep(i_abs r) = r *)
		log_num k_ra;
		log_cmd "def";
		log_cmd "pop";
		log_num k_ar;
		log_cmd "def";
		log_cmd "pop";
		log_cmd "pop";
		log_cmd "pop";
		log_cmd "pop";
		log_µ_intro(a, i_ar_eq, fn () => log_fetch k_ar);
				(* 1. Ù µr∑ ∆ r § i_rep(i_abs r) = r *)
		log_µ_intro(r, i_ra_eq, fn () => log_fetch k_ra);
				(* 2. Ù µa∑ i_abs(i_rep a) = a *)
		log_subst_params(ty_subs, tm_subs);
		log_antecedent type_defn_thm;
				(* 3. µa∑ =abs(rep a) = a,
					µr∑ ∆ r § rep(abs r) = r
						Ù ∂ f∑ TypeDefn p f *)
		log_cmd "subst";
				(* 3. µa∑ i_abs(i_rep a) = a,
					µr∑ ∆ r § i_rep(i_abs r) = r
						Ù ∂ f∑ TypeDefn p f *)
		log_prove_asm();
				(* 2. µr∑ ∆ r § i_rep(i_abs r) = r
						Ù ∂ f∑ TypeDefn p f *)
		log_prove_asm()
				(* 2. Ù ∂ f∑ TypeDefn p f *)
	end
);
end;
=TEX
=SML
fun €kernel_state_change_name› (SaveThm (n, _)) = n
|   kernel_state_change_name (ListSaveThm (ns, thm)) = hd ns
|   kernel_state_change_name (NewAxiom ((ns, tm), thm)) = hd ns
|   kernel_state_change_name (SimpleNewDefn ((ns, n, tm), thm)) = hd ns
|   kernel_state_change_name (NewTypeDefn ((ns, name, typars, thm), _)) = hd ns
|   kernel_state_change_name (NewSpec ((ns, ndefs, thm), _)) = hd ns
|   kernel_state_change_name (NewConst(n, _)) = n
|   kernel_state_change_name (NewType(n, _)) = n
|   kernel_state_change_name _ = "<other>";
=TEX
=SML
val €log_state_change_failures› : KERNEL_STATE_CHANGE list ref = ref [];
fun €state_change_checks› (ksc : KERNEL_STATE_CHANGE) (f : 'a -> unit) (x : 'a) : unit = (
	(log_progress o kernel_state_change_name) ksc;
	f x handle ex as Fail _ => (
		log_state_change_failures := ksc :: !log_state_change_failures;
		diag_line "*** Logging function failed:";
		(diag_line o string_of_exn) ex;
		raise ex
	)
);
=TEX
=SML
fun €log_state_change› (ksc as SaveThm (_, thm)) =
	state_change_checks ksc log_thm thm
|   log_state_change (ksc as ListSaveThm (_, thm)) =
	state_change_checks ksc log_thm thm
|   log_state_change (ksc as NewAxiom ((_, tm), _)) =
	state_change_checks ksc log_new_axiom tm
|   log_state_change (ksc as SimpleNewDefn ((_, n, tm), _)) =
	state_change_checks ksc log_simple_new_defn(n, tm)
|   log_state_change (ksc as NewTypeDefn ((_, name, typars, thm), _)) =
	state_change_checks ksc log_new_type_defn (name, typars, thm)
|   log_state_change (ksc as NewSpec ((_, ndefs, thm), _)) =
	state_change_checks ksc log_new_spec (ndefs, thm)
|   log_state_change _ = ();
=TEX
%%%% %%%% %%%% %%%%
\subsubsection{User Interface}
%%%% %%%% %%%% %%%%

=TEX
=SML
val €ki_key› : KI_KEY ref = ref (on_kernel_inference log_inference);
val €oksc_key› : OKSC_KEY ref = ref (on_kernel_state_change log_state_change);
val _ = delete_kernel_inference_fun (!ki_key);
val _ = delete_on_kernel_state_change_fun (!oksc_key);
=TEX
=SML
fun €begin_open_theory_export› (file : string) : unit = (
	reset_km_state ();
	open_log file;
	(delete_kernel_inference_fun (!ki_key) handle Fail _ => ());
	ki_key := on_kernel_inference log_inference;
	(delete_on_kernel_state_change_fun (!oksc_key) handle Fail _ => ());
	oksc_key := on_kernel_state_change log_state_change
);
=TEX
=SML
fun €end_open_theory_export› (() : unit) : unit = (
	delete_kernel_inference_fun (!ki_key) handle Fail _ => ();
	delete_on_kernel_state_change_fun (!oksc_key) handle Fail _ => ();
	close_log()
);
=TEX
=SML
fun €proof_to_article› {file : string, prf_fun : 'a -> THM list} (x : 'a) : unit = (
	begin_open_theory_export file;
	app log_thm (prf_fun x);
	end_open_theory_export ();
	()
);
=TEX
=SML
fun €term_to_article› {file : string, tm : TERM} : unit = (
	proof_to_article {file = file, prf_fun = fn tm => [refl_conv tm]} tm
);
=SML
=TEX
%%%% %%%% %%%% %%%%
\subsection{Epilogue}
%%%% %%%% %%%% %%%%

=SML
end (* of structure OpenTheoryInternals *);
structure OpenTheory : OpenTheory = OpenTheoryInternals;
open OpenTheory;
=TEX

%%%% %%%% %%%% %%%%
\twocolumn[\section*{INDEX}]
%%%% %%%% %%%% %%%%

\small
\printindex
\end{document}
=IGN
fun €ki_result›(ki as KISubstRule (_, _, _, thm)) = thm
|   ki_result(ki as KISimpleÃEqRule (_, _, thm)) = thm
|   ki_result(ki as KIInstTypeRule (_, _, thm)) = thm
|   ki_result(ki as KI¥Intro (_, _, thm)) = thm
|   ki_result(ki as KI¥Elim (_, _, thm)) = thm
|   ki_result(ki as KIAsmRule (_, thm)) = thm
|   ki_result(ki as KIReflConv (_, thm)) = thm
|   ki_result(ki as KISimple¬Conv (_, thm)) = thm
|   ki_result(ki as KISucConv (_, thm)) = thm
|   ki_result(ki as KIStringConv (_, thm)) = thm
|   ki_result(ki as KICharConv (_, thm)) = thm
|   ki_result(ki as KIEqSymRule (_, thm)) = thm
|   ki_result(ki as KIListSimpleµElim (_, _, thm)) = thm
|   ki_result(ki as KIEqTransRule (_, _, thm)) = thm
|   ki_result(ki as KIMkAppRule (_, _, thm)) = thm
|   ki_result(ki as KI§MPRule (_, _, thm)) = thm
|   ki_result(ki as KISimpleµIntro (_, _, thm)) = thm
|   ki_result(ki as KIInstTermRule (_, _, thm)) = thm
|   ki_result(ki as KIPlusConv (_, thm)) = thm;
=IGN
open OpenTheoryInternals;
logging_progress := true;

val th1 = pc_rule1 "lin_arith" prove_rule[] ¨2 < x ¥ 1 < xÆ;
val th2 = asm_rule ¨2 < xÆ;
begin_open_theory_export "t.art";
¥_elim th1 th2;
log_progress "end of test";
end_open_theory_export();

begin_open_theory_export "t.art";
¥_intro ¨1 < xÆ th2;
log_progress "end of test";
end_open_theory_export();

val th3 = (undisch_rule o undisch_rule o pc_rule1 "lin_arith" prove_rule[])
		¨2 < x ¥ x < y ¥ 1 < xÆ;
begin_open_theory_export "t.art";
¥_intro ¨2 < xÆ th3;
log_progress "end of test";
end_open_theory_export();

begin_open_theory_export "t.art";
¥_elim (¥_intro ¨2 < xÆ t_thm) (asm_rule ¨2 < xÆ);
log_progress "end of test";
end_open_theory_export();

begin_open_theory_export "t.art";
¥_elim  th3a th3b;
log_progress "end of test";
end_open_theory_export();

val th4 = pc_rule1 "lin_arith" prove_rule[]
		¨2 < x ¥ x < y ¥ 1 < xÆ;
begin_open_theory_export "t.art";
val res = simple_µ_intro ¨x:ÓÆ th4;
log_progress "end of test";
end_open_theory_export();


val th5 = times_assoc_thm;

begin_open_theory_export "t.art";
val res = list_simple_µ_elim [¨x+1Æ, ¨v2+27Æ] th5;
log_progress "end of test";
end_open_theory_export();

val th6 = µ_intro ¨i:ÓÆ times_assoc_thm;

begin_open_theory_export "t.art";
val res = list_simple_µ_elim [¨x+1Æ, ¨v2+27Æ] th6;
log_progress "end of test";
end_open_theory_export();


val th7 = map_def;

begin_open_theory_export "t.art";
val res = inst_type_rule [(îÓÆ, î'aÆ)] th7;
log_progress "end of test";
end_open_theory_export();


begin_open_theory_export "t.art";
val res = refl_conv ¨xÆ;
log_progress "end of test";
end_open_theory_export();


begin_open_theory_export "t.art";
val thm1 = tac_proof (([], ¨∂is_const∑µf∑ is_const f § µx y∑f x = f yÆ),
	prove_∂_tac
);
val _ = new_spec (["f"], 1, thm1);
log_progress "end of test";
end_open_theory_export();


val thm2 = tac_proof (([], ¨∂a b c:Ó∑  a < b ± b < cÆ),
	∂_tac ¨1Æ THEN ∂_tac ¨2Æ THEN ∂_tac ¨3Æ THEN PC_T1 "basic_hol1" rewrite_tac[]
);

begin_open_theory_export "t.art";
val _ = new_spec (["a", "b"], 2, thm2);
log_progress "end of test";
end_open_theory_export();

begin_open_theory_export "t.art";
val _ = simple_new_defn (["a"], "xyz", mk_t);
log_progress "end of test";
end_open_theory_export();


val thm3 = tac_proof (([], ¨∂x:Ó∑ (Ãx∑ ∂y∑ ≥x = y) xÆ),
	∂_tac ¨1Æ THEN conv_tac ¬_conv THEN ∂_tac ¨2Æ THEN PC_T1 "basic_hol1" rewrite_tac[]
);

begin_open_theory_export "t.art";
val two_or_more_def = new_type_defn (["a"], "TWO_OR_MORE", [], thm3);
log_progress "end of test";
end_open_theory_export();


val thm4 = tac_proof (([], ¨∂f:'a ≠ 'b∑ (Ãf∑ µx y∑ f x = f y) fÆ),
	∂_tac ¨(Ãx∑ y) : 'a ≠ 'bÆ THEN PC_T1 "basic_hol1" rewrite_tac[]
);

begin_open_theory_export "t.art";
val thm4 = tac_proof (([], ¨∂f:'a ≠ 'b∑ (Ãf∑ µx y∑ f x = f y) fÆ),
	∂_tac ¨(Ãx∑ y) : 'a ≠ 'bÆ THEN PC_T1 "basic_hol1" rewrite_tac[]
);
save_thm("banana", thm4);
end_open_theory_export();


begin_open_theory_export "t.art";
new_theory "open-theory-eg2";
val is_const_exists_thm = tac_proof (([], ¨∂is_const∑µf: 'x ≠ 'y∑ is_const f § µx y∑f x = f yÆ),
	∂_tac ¨Ãf: 'x ≠ 'y∑ µx y∑ f x = f yÆ THEN PC_T1 "basic_hol1" rewrite_tac[]
);
val is_const_def = new_spec (["is_const_def"], 1, is_const_exists_thm);
val const_funs_exist_thm = tac_proof (([], ¨∂f:'x ≠ 'y∑ is_const fÆ),
	∂_tac ¨(Ãx∑ y) : 'x ≠ 'yÆ THEN PC_T1 "basic_hol1" rewrite_tac[is_const_def]
);
val const_fun_def = new_type_defn (["CONST_FUN"], "CONST_FUN", ["'x", "'y"], const_funs_exist_thm);
end_open_theory_export();


(*
open OpenTheoryInternals;
vm_diagnostics := ~1;
val _ = open_theory_import{file = "t.art", parent = "open-theory-base", theory = "t"};
vm_diagnostics := 0;
val _ = open_theory_import{file = "t.art", parent = "open-theory-base", theory = "t"};
vm_diagnostics := 1;
val _ = open_theory_import{file = "t.art", parent = "open-theory-base", theory = "t"};
vm_diagnostics := 2;
val _ = open_theory_import{file = "t.art", parent = "open-theory-base", theory = "t"};
vm_diagnostics := 3;
val _ = open_theory_import{file = "t.art", parent = "open-theory-base", theory = "t"};
vm_diagnostics := 4;
val _ = open_theory_import{file = "t.art", parent = "open-theory-base", theory = "t"};
vm_diagnostics := 5;
val _ = open_theory_import{file = "t.art", parent = "open-theory-base", theory = "t"};
vm_diagnostics := 6;
val _ = open_theory_import{file = "t.art", parent = "open-theory-base", theory = "t"};
*)

val _ = open_theory_import{file = "t.art", parent = "open-theory-base", theory = "t"};

val _ = open_theory_import{file = "base.art", parent = "open-theory-base", theory = "t"};

val _ = open_theory_import{file = "condef.art", parent = "open-theory-base", theory = "t"};

val _ = open_theory_import{file = "tydef.art", parent = "open-theory-base", theory = "t"};

val _ = open_theory_import{file = "fundef.art", parent = "open-theory-base", theory = "t"};

val _ = open_theory_import{file = "non_const_fun_def.art", parent = "open-theory-base", theory = "open_theory-eg1"};

rewrite_rule [one_one_def] type_defn_def;
»_axiom;

(flat o map get_axioms o get_ancestors) "basic_hol";


PC_C1 "predicates" rewrite_conv[] ¨ µ t1 t2∑ (Ã x∑ t1) t2 = t1Æ;


val _ = open_theory_import{file = "function-def.art", parent = "open-theory-base", theory = "t"};
val _ = open_theory_import{file = "natural-def.art", parent = "t", theory = "u"};

